#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GFXUtilities

#include "Basic.hpp"

#include "GFXUtilities_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Niagara_classes.hpp"


namespace SDK
{

// Class GFXUtilities.BatchMeshCommands
// 0x0090 (0x02B0 - 0x0220)
#pragma pack(push, 0x1)
class alignas(0x10) UBatchMeshCommands : public USceneComponent
{
public:
	uint8                                         Pad_218[0x60];                                     // 0x0218(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMaterialNamedGroup>            Groups;                                            // 0x0278(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMaterialHelperOriginalMeshState> TargetMeshes;                                    // 0x0288(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class FString                                 _materialGroupName;                                // 0x0298(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BatchSetComponentTickEnabled(bool enabled);
	void BatchSetSkipComponentAndChildrenTransformUpdate(bool skip);
	void BatchSetVisibility(bool bNewVisibility, bool bPropagateToChildren);
	bool CopyFirstScalarParameter(const class FName parameterName, float* outValue);
	void ResetMaterials();
	void SetAllToSameMaterial(class UMaterialInterface* materialInterface);
	void SetCastCinematicShadows(bool castCinematicShadows);
	void SetColourParameter(const class FName parameterName, const struct FLinearColor& newValue);
	void SetCustomDepthStencilValue(int32 stencilValue);
	void SetLightingChannelForAllMeshes(const struct FLightingChannels& lightingChannels);
	void SetMaterial(const class FString& groupName);
	void SetReceivesDecals(bool receivesDecals);
	void SetRenderInCustomColourNoDepth(bool renderInCustomColour);
	void SetRenderInCustomDepth(bool renderInCustomDepth);
	void SetRenderInMainPass(bool inRenderInMainPass);
	void SetScalarParameter(const class FName parameterName, const float newValue);
	void SetStencilIntegerScalarParameter(const class FName parameterName, const int32& newValue);
	void SetTextureParameter(const class FName parameterName, class UTexture* newTexture);
	void SetVectorParameter(const class FName parameterName, const struct FVector& newValue);
	void UpdateMaterials();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BatchMeshCommands">();
	}
	static class UBatchMeshCommands* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBatchMeshCommands>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBatchMeshCommands) == 0x000010, "Wrong alignment on UBatchMeshCommands");
static_assert(sizeof(UBatchMeshCommands) == 0x0002B0, "Wrong size on UBatchMeshCommands");
static_assert(offsetof(UBatchMeshCommands, Groups) == 0x000278, "Member 'UBatchMeshCommands::Groups' has a wrong offset!");
static_assert(offsetof(UBatchMeshCommands, TargetMeshes) == 0x000288, "Member 'UBatchMeshCommands::TargetMeshes' has a wrong offset!");
static_assert(offsetof(UBatchMeshCommands, _materialGroupName) == 0x000298, "Member 'UBatchMeshCommands::_materialGroupName' has a wrong offset!");

// Class GFXUtilities.AlternatingColor
// 0x0048 (0x0078 - 0x0030)
class UAlternatingColor final : public UObject
{
public:
	struct FLinearColor                           FirstColor;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           SecondColor;                                       // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ColorChangePeriod;                                 // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x24];                                      // 0x0054(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlternatingColor">();
	}
	static class UAlternatingColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlternatingColor>();
	}
};
static_assert(alignof(UAlternatingColor) == 0x000008, "Wrong alignment on UAlternatingColor");
static_assert(sizeof(UAlternatingColor) == 0x000078, "Wrong size on UAlternatingColor");
static_assert(offsetof(UAlternatingColor, FirstColor) == 0x000030, "Member 'UAlternatingColor::FirstColor' has a wrong offset!");
static_assert(offsetof(UAlternatingColor, SecondColor) == 0x000040, "Member 'UAlternatingColor::SecondColor' has a wrong offset!");
static_assert(offsetof(UAlternatingColor, ColorChangePeriod) == 0x000050, "Member 'UAlternatingColor::ColorChangePeriod' has a wrong offset!");

// Class GFXUtilities.BaseOutlineRenderStrategy
// 0x0040 (0x0070 - 0x0030)
class UBaseOutlineRenderStrategy : public UObject
{
public:
	TArray<class UBatchMeshCommands*>             _batchCommands;                                    // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x30];                                      // 0x0040(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseOutlineRenderStrategy">();
	}
	static class UBaseOutlineRenderStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseOutlineRenderStrategy>();
	}
};
static_assert(alignof(UBaseOutlineRenderStrategy) == 0x000008, "Wrong alignment on UBaseOutlineRenderStrategy");
static_assert(sizeof(UBaseOutlineRenderStrategy) == 0x000070, "Wrong size on UBaseOutlineRenderStrategy");
static_assert(offsetof(UBaseOutlineRenderStrategy, _batchCommands) == 0x000030, "Member 'UBaseOutlineRenderStrategy::_batchCommands' has a wrong offset!");

// Class GFXUtilities.ClippableProviderComponent
// 0x0068 (0x0120 - 0x00B8)
class UClippableProviderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UPrimitiveComponent*>              _ignoredPrimitives;                                // 0x00D0(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddIgnoredPrimitives(const TArray<class UPrimitiveComponent*>& ignoredPrimitives);
	void SetIgnoredPrimitives(const TArray<class UPrimitiveComponent*>& ignoredPrimitives);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClippableProviderComponent">();
	}
	static class UClippableProviderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClippableProviderComponent>();
	}
};
static_assert(alignof(UClippableProviderComponent) == 0x000008, "Wrong alignment on UClippableProviderComponent");
static_assert(sizeof(UClippableProviderComponent) == 0x000120, "Wrong size on UClippableProviderComponent");
static_assert(offsetof(UClippableProviderComponent, _ignoredPrimitives) == 0x0000D0, "Member 'UClippableProviderComponent::_ignoredPrimitives' has a wrong offset!");

// Class GFXUtilities.ClonedMeshComponent
// 0x00A0 (0x0350 - 0x02B0)
class UClonedMeshComponent : public UBatchMeshCommands
{
public:
	TMap<class USceneComponent*, class UMeshComponent*> _originalToClone;                            // 0x02A8(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UMeshComponent*, class USceneComponent*> _cloneToOriginal;                            // 0x02F8(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClonedMeshComponent">();
	}
	static class UClonedMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClonedMeshComponent>();
	}
};
static_assert(alignof(UClonedMeshComponent) == 0x000010, "Wrong alignment on UClonedMeshComponent");
static_assert(sizeof(UClonedMeshComponent) == 0x000350, "Wrong size on UClonedMeshComponent");
static_assert(offsetof(UClonedMeshComponent, _originalToClone) == 0x0002A8, "Member 'UClonedMeshComponent::_originalToClone' has a wrong offset!");
static_assert(offsetof(UClonedMeshComponent, _cloneToOriginal) == 0x0002F8, "Member 'UClonedMeshComponent::_cloneToOriginal' has a wrong offset!");

// Class GFXUtilities.ClonedMeshComponentTranslucentOutline
// 0x0000 (0x0350 - 0x0350)
class UClonedMeshComponentTranslucentOutline final : public UClonedMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClonedMeshComponentTranslucentOutline">();
	}
	static class UClonedMeshComponentTranslucentOutline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClonedMeshComponentTranslucentOutline>();
	}
};
static_assert(alignof(UClonedMeshComponentTranslucentOutline) == 0x000010, "Wrong alignment on UClonedMeshComponentTranslucentOutline");
static_assert(sizeof(UClonedMeshComponentTranslucentOutline) == 0x000350, "Wrong size on UClonedMeshComponentTranslucentOutline");

// Class GFXUtilities.ClonedStaticMeshComponent
// 0x0000 (0x0550 - 0x0550)
class UClonedStaticMeshComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClonedStaticMeshComponent">();
	}
	static class UClonedStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClonedStaticMeshComponent>();
	}
};
static_assert(alignof(UClonedStaticMeshComponent) == 0x000010, "Wrong alignment on UClonedStaticMeshComponent");
static_assert(sizeof(UClonedStaticMeshComponent) == 0x000550, "Wrong size on UClonedStaticMeshComponent");

// Class GFXUtilities.ClonedSkeletalMeshComponent
// 0x0000 (0x0F80 - 0x0F80)
class UClonedSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClonedSkeletalMeshComponent">();
	}
	static class UClonedSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClonedSkeletalMeshComponent>();
	}
};
static_assert(alignof(UClonedSkeletalMeshComponent) == 0x000010, "Wrong alignment on UClonedSkeletalMeshComponent");
static_assert(sizeof(UClonedSkeletalMeshComponent) == 0x000F80, "Wrong size on UClonedSkeletalMeshComponent");

// Class GFXUtilities.CustomDepthOutlineRenderStrategy
// 0x0018 (0x0088 - 0x0070)
class UCustomDepthOutlineRenderStrategy final : public UBaseOutlineRenderStrategy
{
public:
	class UMaterialInterface*                     _replacementMaterial;                              // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UBatchMeshCommands*>             _translucentCopies;                                // 0x0078(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomDepthOutlineRenderStrategy">();
	}
	static class UCustomDepthOutlineRenderStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomDepthOutlineRenderStrategy>();
	}
};
static_assert(alignof(UCustomDepthOutlineRenderStrategy) == 0x000008, "Wrong alignment on UCustomDepthOutlineRenderStrategy");
static_assert(sizeof(UCustomDepthOutlineRenderStrategy) == 0x000088, "Wrong size on UCustomDepthOutlineRenderStrategy");
static_assert(offsetof(UCustomDepthOutlineRenderStrategy, _replacementMaterial) == 0x000070, "Member 'UCustomDepthOutlineRenderStrategy::_replacementMaterial' has a wrong offset!");
static_assert(offsetof(UCustomDepthOutlineRenderStrategy, _translucentCopies) == 0x000078, "Member 'UCustomDepthOutlineRenderStrategy::_translucentCopies' has a wrong offset!");

// Class GFXUtilities.DBDReflectionCaptureSpawnerComponent
// 0x0050 (0x0270 - 0x0220)
class UDBDReflectionCaptureSpawnerComponent : public USceneComponent
{
public:
	EReflectionSourceType                         ReflectionSourceType;                              // 0x0218(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureCube*                           Cubemap;                                           // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SourceCubemapAngle;                                // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Brightness;                                        // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContributionFactor;                                // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IBLMultiplicator;                                  // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeTinted;                                      // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CaptureOffset;                                     // 0x023C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AReflectionCapture*>             SpawnedReflectionCaptures;                         // 0x0250(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UReflectionCaptureComponent*>    SpawnedReflectionCaptureComponents;                // 0x0260(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void SetBrightness(float brightness);
	void SetContributionFactor(float contributionFactor);
	void SetIBLMultiplicator(float IBLMultiplicator_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDReflectionCaptureSpawnerComponent">();
	}
	static class UDBDReflectionCaptureSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDReflectionCaptureSpawnerComponent>();
	}
};
static_assert(alignof(UDBDReflectionCaptureSpawnerComponent) == 0x000010, "Wrong alignment on UDBDReflectionCaptureSpawnerComponent");
static_assert(sizeof(UDBDReflectionCaptureSpawnerComponent) == 0x000270, "Wrong size on UDBDReflectionCaptureSpawnerComponent");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, ReflectionSourceType) == 0x000218, "Member 'UDBDReflectionCaptureSpawnerComponent::ReflectionSourceType' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, Cubemap) == 0x000220, "Member 'UDBDReflectionCaptureSpawnerComponent::Cubemap' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, SourceCubemapAngle) == 0x000228, "Member 'UDBDReflectionCaptureSpawnerComponent::SourceCubemapAngle' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, Brightness) == 0x00022C, "Member 'UDBDReflectionCaptureSpawnerComponent::Brightness' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, ContributionFactor) == 0x000230, "Member 'UDBDReflectionCaptureSpawnerComponent::ContributionFactor' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, IBLMultiplicator) == 0x000234, "Member 'UDBDReflectionCaptureSpawnerComponent::IBLMultiplicator' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, bCanBeTinted) == 0x000238, "Member 'UDBDReflectionCaptureSpawnerComponent::bCanBeTinted' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, CaptureOffset) == 0x00023C, "Member 'UDBDReflectionCaptureSpawnerComponent::CaptureOffset' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, SpawnedReflectionCaptures) == 0x000250, "Member 'UDBDReflectionCaptureSpawnerComponent::SpawnedReflectionCaptures' has a wrong offset!");
static_assert(offsetof(UDBDReflectionCaptureSpawnerComponent, SpawnedReflectionCaptureComponents) == 0x000260, "Member 'UDBDReflectionCaptureSpawnerComponent::SpawnedReflectionCaptureComponents' has a wrong offset!");

// Class GFXUtilities.DBDBoxReflectionCaptureSpawnerComponent
// 0x0020 (0x0290 - 0x0270)
class UDBDBoxReflectionCaptureSpawnerComponent final : public UDBDReflectionCaptureSpawnerComponent
{
public:
	struct FVector                                InfluenceBox;                                      // 0x0270(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoxTransitionDistance;                             // 0x027C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          PreviewInfluenceBox;                               // 0x0280(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          PreviewCaptureBox;                                 // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBoxReflectionCaptureSpawnerComponent">();
	}
	static class UDBDBoxReflectionCaptureSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBoxReflectionCaptureSpawnerComponent>();
	}
};
static_assert(alignof(UDBDBoxReflectionCaptureSpawnerComponent) == 0x000010, "Wrong alignment on UDBDBoxReflectionCaptureSpawnerComponent");
static_assert(sizeof(UDBDBoxReflectionCaptureSpawnerComponent) == 0x000290, "Wrong size on UDBDBoxReflectionCaptureSpawnerComponent");
static_assert(offsetof(UDBDBoxReflectionCaptureSpawnerComponent, InfluenceBox) == 0x000270, "Member 'UDBDBoxReflectionCaptureSpawnerComponent::InfluenceBox' has a wrong offset!");
static_assert(offsetof(UDBDBoxReflectionCaptureSpawnerComponent, BoxTransitionDistance) == 0x00027C, "Member 'UDBDBoxReflectionCaptureSpawnerComponent::BoxTransitionDistance' has a wrong offset!");
static_assert(offsetof(UDBDBoxReflectionCaptureSpawnerComponent, PreviewInfluenceBox) == 0x000280, "Member 'UDBDBoxReflectionCaptureSpawnerComponent::PreviewInfluenceBox' has a wrong offset!");
static_assert(offsetof(UDBDBoxReflectionCaptureSpawnerComponent, PreviewCaptureBox) == 0x000288, "Member 'UDBDBoxReflectionCaptureSpawnerComponent::PreviewCaptureBox' has a wrong offset!");

// Class GFXUtilities.DBDCullDistanceVolumeComponent
// 0x0030 (0x0250 - 0x0220)
class UDBDCullDistanceVolumeComponent final : public USceneComponent
{
public:
	TArray<struct FDBDCullDistanceSizePair>       CullDistances;                                     // 0x0218(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                InfluenceBox;                                      // 0x0228(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x0234(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Unbound;                                           // 0x0235(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_236[0x2];                                      // 0x0236(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          _previewInfluenceBox;                              // 0x0238(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCullDistanceVolumeComponent">();
	}
	static class UDBDCullDistanceVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCullDistanceVolumeComponent>();
	}
};
static_assert(alignof(UDBDCullDistanceVolumeComponent) == 0x000010, "Wrong alignment on UDBDCullDistanceVolumeComponent");
static_assert(sizeof(UDBDCullDistanceVolumeComponent) == 0x000250, "Wrong size on UDBDCullDistanceVolumeComponent");
static_assert(offsetof(UDBDCullDistanceVolumeComponent, CullDistances) == 0x000218, "Member 'UDBDCullDistanceVolumeComponent::CullDistances' has a wrong offset!");
static_assert(offsetof(UDBDCullDistanceVolumeComponent, InfluenceBox) == 0x000228, "Member 'UDBDCullDistanceVolumeComponent::InfluenceBox' has a wrong offset!");
static_assert(offsetof(UDBDCullDistanceVolumeComponent, Enabled) == 0x000234, "Member 'UDBDCullDistanceVolumeComponent::Enabled' has a wrong offset!");
static_assert(offsetof(UDBDCullDistanceVolumeComponent, Unbound) == 0x000235, "Member 'UDBDCullDistanceVolumeComponent::Unbound' has a wrong offset!");
static_assert(offsetof(UDBDCullDistanceVolumeComponent, _previewInfluenceBox) == 0x000238, "Member 'UDBDCullDistanceVolumeComponent::_previewInfluenceBox' has a wrong offset!");

// Class GFXUtilities.DBDSphereReflectionCaptureSpawnerComponent
// 0x0010 (0x0280 - 0x0270)
class UDBDSphereReflectionCaptureSpawnerComponent final : public UDBDReflectionCaptureSpawnerComponent
{
public:
	float                                         InfluenceRadius;                                   // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDrawSphereComponent*                   PreviewInfluenceRadius;                            // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSphereReflectionCaptureSpawnerComponent">();
	}
	static class UDBDSphereReflectionCaptureSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSphereReflectionCaptureSpawnerComponent>();
	}
};
static_assert(alignof(UDBDSphereReflectionCaptureSpawnerComponent) == 0x000010, "Wrong alignment on UDBDSphereReflectionCaptureSpawnerComponent");
static_assert(sizeof(UDBDSphereReflectionCaptureSpawnerComponent) == 0x000280, "Wrong size on UDBDSphereReflectionCaptureSpawnerComponent");
static_assert(offsetof(UDBDSphereReflectionCaptureSpawnerComponent, InfluenceRadius) == 0x000270, "Member 'UDBDSphereReflectionCaptureSpawnerComponent::InfluenceRadius' has a wrong offset!");
static_assert(offsetof(UDBDSphereReflectionCaptureSpawnerComponent, PreviewInfluenceRadius) == 0x000278, "Member 'UDBDSphereReflectionCaptureSpawnerComponent::PreviewInfluenceRadius' has a wrong offset!");

// Class GFXUtilities.GFXUtilities
// 0x0000 (0x0030 - 0x0030)
class UGFXUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void ActivateVFX(class USkeletalMeshComponent* skeletalMeshComponent, bool active);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GFXUtilities">();
	}
	static class UGFXUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGFXUtilities>();
	}
};
static_assert(alignof(UGFXUtilities) == 0x000008, "Wrong alignment on UGFXUtilities");
static_assert(sizeof(UGFXUtilities) == 0x000030, "Wrong size on UGFXUtilities");

// Class GFXUtilities.InFrustumComponent
// 0x0008 (0x00C0 - 0x00B8)
class UInFrustumComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InFrustumComponent">();
	}
	static class UInFrustumComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInFrustumComponent>();
	}
};
static_assert(alignof(UInFrustumComponent) == 0x000008, "Wrong alignment on UInFrustumComponent");
static_assert(sizeof(UInFrustumComponent) == 0x0000C0, "Wrong size on UInFrustumComponent");

// Class GFXUtilities.LightIntensityTimelineComponent
// 0x0058 (0x0110 - 0x00B8)
class ULightIntensityTimelineComponent final : public UActorComponent
{
public:
	TArray<struct FLightUpdate>                   lights;                                            // 0x00B8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FLightMaterialUpdate>           materialHelpers;                                   // 0x00C8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UCurveFloat*                            intensityCurve;                                    // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          randomizeStart;                                    // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          randomizeLength;                                   // 0x00E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x2];                                       // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         minLength;                                         // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         maxLength;                                         // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          normalizeCurve;                                    // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          startTicking;                                      // 0x00ED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELightUnits                                   inputLightUnit;                                    // 0x00EE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EF[0x1];                                       // 0x00EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnTimelineFinished;                                // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddLight(class ULightComponent* light, float multiplier);
	void AddMaterialHelper(class UMaterialHelper* matHelper, class FName propName, float multiplier);
	void DeactivateTick();
	void RegisterForTick();
	void Reset();
	void SetLightCurve(class UCurveFloat* lightcurve);
	void SetLightToMaxValue();
	void SetMaxLength(float newMaxValue);
	void SetMinLength(float newMinValue);
	void SetRandomizeLength(bool isRandom);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightIntensityTimelineComponent">();
	}
	static class ULightIntensityTimelineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightIntensityTimelineComponent>();
	}
};
static_assert(alignof(ULightIntensityTimelineComponent) == 0x000008, "Wrong alignment on ULightIntensityTimelineComponent");
static_assert(sizeof(ULightIntensityTimelineComponent) == 0x000110, "Wrong size on ULightIntensityTimelineComponent");
static_assert(offsetof(ULightIntensityTimelineComponent, lights) == 0x0000B8, "Member 'ULightIntensityTimelineComponent::lights' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, materialHelpers) == 0x0000C8, "Member 'ULightIntensityTimelineComponent::materialHelpers' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, intensityCurve) == 0x0000D8, "Member 'ULightIntensityTimelineComponent::intensityCurve' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, randomizeStart) == 0x0000E0, "Member 'ULightIntensityTimelineComponent::randomizeStart' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, randomizeLength) == 0x0000E1, "Member 'ULightIntensityTimelineComponent::randomizeLength' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, minLength) == 0x0000E4, "Member 'ULightIntensityTimelineComponent::minLength' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, maxLength) == 0x0000E8, "Member 'ULightIntensityTimelineComponent::maxLength' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, normalizeCurve) == 0x0000EC, "Member 'ULightIntensityTimelineComponent::normalizeCurve' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, startTicking) == 0x0000ED, "Member 'ULightIntensityTimelineComponent::startTicking' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, inputLightUnit) == 0x0000EE, "Member 'ULightIntensityTimelineComponent::inputLightUnit' has a wrong offset!");
static_assert(offsetof(ULightIntensityTimelineComponent, OnTimelineFinished) == 0x0000F0, "Member 'ULightIntensityTimelineComponent::OnTimelineFinished' has a wrong offset!");

// Class GFXUtilities.MaterialExpressionBHVRCustomColorOutput
// 0x0020 (0x0068 - 0x0048)
class UMaterialExpressionBHVRCustomColorOutput final : public UMaterialExpressionCustomOutput
{
public:
	struct FExpressionInput                       Input;                                             // 0x0048(0x001C)(NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionBHVRCustomColorOutput">();
	}
	static class UMaterialExpressionBHVRCustomColorOutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionBHVRCustomColorOutput>();
	}
};
static_assert(alignof(UMaterialExpressionBHVRCustomColorOutput) == 0x000008, "Wrong alignment on UMaterialExpressionBHVRCustomColorOutput");
static_assert(sizeof(UMaterialExpressionBHVRCustomColorOutput) == 0x000068, "Wrong size on UMaterialExpressionBHVRCustomColorOutput");
static_assert(offsetof(UMaterialExpressionBHVRCustomColorOutput, Input) == 0x000048, "Member 'UMaterialExpressionBHVRCustomColorOutput::Input' has a wrong offset!");

// Class GFXUtilities.MaterialExpressionBHVRCustomColorSampler
// 0x0000 (0x0048 - 0x0048)
class UMaterialExpressionBHVRCustomColorSampler final : public UMaterialExpressionCustomOutput
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialExpressionBHVRCustomColorSampler">();
	}
	static class UMaterialExpressionBHVRCustomColorSampler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialExpressionBHVRCustomColorSampler>();
	}
};
static_assert(alignof(UMaterialExpressionBHVRCustomColorSampler) == 0x000008, "Wrong alignment on UMaterialExpressionBHVRCustomColorSampler");
static_assert(sizeof(UMaterialExpressionBHVRCustomColorSampler) == 0x000048, "Wrong size on UMaterialExpressionBHVRCustomColorSampler");

// Class GFXUtilities.MaterialHelper
// 0x0000 (0x02B0 - 0x02B0)
class UMaterialHelper final : public UBatchMeshCommands
{
public:
	void RefreshMesh(class UMeshComponent* mc);
	void RefreshMeshes();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialHelper">();
	}
	static class UMaterialHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialHelper>();
	}
};
static_assert(alignof(UMaterialHelper) == 0x000010, "Wrong alignment on UMaterialHelper");
static_assert(sizeof(UMaterialHelper) == 0x0002B0, "Wrong size on UMaterialHelper");

// Class GFXUtilities.MaterialHelperUnaffectedComponentInterface
// 0x0000 (0x0000 - 0x0000)
class IMaterialHelperUnaffectedComponentInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialHelperUnaffectedComponentInterface">();
	}
	static class IMaterialHelperUnaffectedComponentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMaterialHelperUnaffectedComponentInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMaterialHelperUnaffectedComponentInterface) == 0x000001, "Wrong alignment on IMaterialHelperUnaffectedComponentInterface");
static_assert(sizeof(IMaterialHelperUnaffectedComponentInterface) == 0x000001, "Wrong size on IMaterialHelperUnaffectedComponentInterface");

// Class GFXUtilities.MaterialHelperUnaffectedStaticMeshComponent
// 0x0000 (0x0550 - 0x0550)
class UMaterialHelperUnaffectedStaticMeshComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialHelperUnaffectedStaticMeshComponent">();
	}
	static class UMaterialHelperUnaffectedStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialHelperUnaffectedStaticMeshComponent>();
	}
};
static_assert(alignof(UMaterialHelperUnaffectedStaticMeshComponent) == 0x000010, "Wrong alignment on UMaterialHelperUnaffectedStaticMeshComponent");
static_assert(sizeof(UMaterialHelperUnaffectedStaticMeshComponent) == 0x000550, "Wrong size on UMaterialHelperUnaffectedStaticMeshComponent");

// Class GFXUtilities.MaterialHelperUnaffectedNiagaraComponent
// 0x0000 (0x0630 - 0x0630)
class UMaterialHelperUnaffectedNiagaraComponent final : public UNiagaraComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialHelperUnaffectedNiagaraComponent">();
	}
	static class UMaterialHelperUnaffectedNiagaraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialHelperUnaffectedNiagaraComponent>();
	}
};
static_assert(alignof(UMaterialHelperUnaffectedNiagaraComponent) == 0x000010, "Wrong alignment on UMaterialHelperUnaffectedNiagaraComponent");
static_assert(sizeof(UMaterialHelperUnaffectedNiagaraComponent) == 0x000630, "Wrong size on UMaterialHelperUnaffectedNiagaraComponent");

// Class GFXUtilities.MeshCloningFactory
// 0x0000 (0x02B0 - 0x02B0)
class UMeshCloningFactory final : public UBatchMeshCommands
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshCloningFactory">();
	}
	static class UMeshCloningFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshCloningFactory>();
	}
};
static_assert(alignof(UMeshCloningFactory) == 0x000010, "Wrong alignment on UMeshCloningFactory");
static_assert(sizeof(UMeshCloningFactory) == 0x0002B0, "Wrong size on UMeshCloningFactory");

// Class GFXUtilities.OuterlineComponent
// 0x0030 (0x0250 - 0x0220)
class UOuterlineComponent final : public USceneComponent
{
public:
	class UMaterialInterface*                     CloneCustomDepthMaterial;                          // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CloneTranslucentMaterial;                          // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _cloneCustomDepthMaterialDynamic;                  // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _cloneTranslucentMaterialDynamic;                  // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 _customDepthSkeletalMesh;                          // 0x0238(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 _overlaySkeletalMesh;                              // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIntensity(float intensity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OuterlineComponent">();
	}
	static class UOuterlineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOuterlineComponent>();
	}
};
static_assert(alignof(UOuterlineComponent) == 0x000010, "Wrong alignment on UOuterlineComponent");
static_assert(sizeof(UOuterlineComponent) == 0x000250, "Wrong size on UOuterlineComponent");
static_assert(offsetof(UOuterlineComponent, CloneCustomDepthMaterial) == 0x000218, "Member 'UOuterlineComponent::CloneCustomDepthMaterial' has a wrong offset!");
static_assert(offsetof(UOuterlineComponent, CloneTranslucentMaterial) == 0x000220, "Member 'UOuterlineComponent::CloneTranslucentMaterial' has a wrong offset!");
static_assert(offsetof(UOuterlineComponent, _cloneCustomDepthMaterialDynamic) == 0x000228, "Member 'UOuterlineComponent::_cloneCustomDepthMaterialDynamic' has a wrong offset!");
static_assert(offsetof(UOuterlineComponent, _cloneTranslucentMaterialDynamic) == 0x000230, "Member 'UOuterlineComponent::_cloneTranslucentMaterialDynamic' has a wrong offset!");
static_assert(offsetof(UOuterlineComponent, _customDepthSkeletalMesh) == 0x000238, "Member 'UOuterlineComponent::_customDepthSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UOuterlineComponent, _overlaySkeletalMesh) == 0x000240, "Member 'UOuterlineComponent::_overlaySkeletalMesh' has a wrong offset!");

// Class GFXUtilities.StencilOutlineRenderStrategy
// 0x0028 (0x0098 - 0x0070)
class UStencilOutlineRenderStrategy final : public UBaseOutlineRenderStrategy
{
public:
	TArray<class UMaterialInterface*>             _replacementMaterials;                             // 0x0070(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UBatchMeshCommands*>             _translucentCopies;                                // 0x0080(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void EnableCopyStencilToCustomStencil(bool enabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StencilOutlineRenderStrategy">();
	}
	static class UStencilOutlineRenderStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStencilOutlineRenderStrategy>();
	}
};
static_assert(alignof(UStencilOutlineRenderStrategy) == 0x000008, "Wrong alignment on UStencilOutlineRenderStrategy");
static_assert(sizeof(UStencilOutlineRenderStrategy) == 0x000098, "Wrong size on UStencilOutlineRenderStrategy");
static_assert(offsetof(UStencilOutlineRenderStrategy, _replacementMaterials) == 0x000070, "Member 'UStencilOutlineRenderStrategy::_replacementMaterials' has a wrong offset!");
static_assert(offsetof(UStencilOutlineRenderStrategy, _translucentCopies) == 0x000080, "Member 'UStencilOutlineRenderStrategy::_translucentCopies' has a wrong offset!");

// Class GFXUtilities.TranslucentOutlineRenderStrategy
// 0x0010 (0x0080 - 0x0070)
class UTranslucentOutlineRenderStrategy final : public UBaseOutlineRenderStrategy
{
public:
	TArray<class UMaterialInterface*>             _replacementMaterials;                             // 0x0070(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TranslucentOutlineRenderStrategy">();
	}
	static class UTranslucentOutlineRenderStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTranslucentOutlineRenderStrategy>();
	}
};
static_assert(alignof(UTranslucentOutlineRenderStrategy) == 0x000008, "Wrong alignment on UTranslucentOutlineRenderStrategy");
static_assert(sizeof(UTranslucentOutlineRenderStrategy) == 0x000080, "Wrong size on UTranslucentOutlineRenderStrategy");
static_assert(offsetof(UTranslucentOutlineRenderStrategy, _replacementMaterials) == 0x000070, "Member 'UTranslucentOutlineRenderStrategy::_replacementMaterials' has a wrong offset!");

}

