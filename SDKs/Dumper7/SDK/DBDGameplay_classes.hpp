#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDGameplay

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "VFXUtilities_classes.hpp"
#include "DBDGameplay_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "StatSystem_structs.hpp"
#include "GameplayUtilities_classes.hpp"
#include "NetworkUtilities_structs.hpp"
#include "DBDSharedTypes_structs.hpp"


namespace SDK
{

// Class DBDGameplay.ReadMapInteraction
// 0x0010 (0x0750 - 0x0740)
class UReadMapInteraction final : public UChargeableInteractionDefinition
{
public:
	bool                                          _chargeCompleted;                                  // 0x0740(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_741[0xF];                                      // 0x0741(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReadMapInteraction">();
	}
	static class UReadMapInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReadMapInteraction>();
	}
};
static_assert(alignof(UReadMapInteraction) == 0x000010, "Wrong alignment on UReadMapInteraction");
static_assert(sizeof(UReadMapInteraction) == 0x000750, "Wrong size on UReadMapInteraction");
static_assert(offsetof(UReadMapInteraction, _chargeCompleted) == 0x000740, "Member 'UReadMapInteraction::_chargeCompleted' has a wrong offset!");

// Class DBDGameplay.AISenseEvent_Terror
// 0x0028 (0x0058 - 0x0030)
class UAISenseEvent_Terror final : public UAISenseEvent
{
public:
	struct FAITerrorEvent                         Event;                                             // 0x0030(0x0028)(Edit, BlueprintVisible, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseEvent_Terror">();
	}
	static class UAISenseEvent_Terror* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseEvent_Terror>();
	}
};
static_assert(alignof(UAISenseEvent_Terror) == 0x000008, "Wrong alignment on UAISenseEvent_Terror");
static_assert(sizeof(UAISenseEvent_Terror) == 0x000058, "Wrong size on UAISenseEvent_Terror");
static_assert(offsetof(UAISenseEvent_Terror, Event) == 0x000030, "Member 'UAISenseEvent_Terror::Event' has a wrong offset!");

// Class DBDGameplay.BaseHusk
// 0x0020 (0x0258 - 0x0238)
class ABaseHusk : public ABaseVFX
{
public:
	class UDBDSkeletalMeshComponentBudgeted*      _huskMesh;                                         // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCustomizedSkeletalMesh*                _huskCustomizedSkeletalMesh;                       // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldDeactivateVFX;                              // 0x0248(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_249[0xB];                                      // 0x0249(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _updateWeaponAccessories;                          // 0x0254(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldWeaponBeVisible;                            // 0x0255(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_256[0x2];                                      // 0x0256(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_InitializeSkeletalMesh(class USkeletalMeshComponent* mesh);
	void InitializeHusk(class UCustomizedSkeletalMesh* customizedSkeletalMeshToCopy);
	void SetHuskVisibility(bool visible);
	void SetScalarParameterOnAllChildrenMeshes(class FName parameterName, float value, class USkeletalMeshComponent* mesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseHusk">();
	}
	static class ABaseHusk* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseHusk>();
	}
};
static_assert(alignof(ABaseHusk) == 0x000008, "Wrong alignment on ABaseHusk");
static_assert(sizeof(ABaseHusk) == 0x000258, "Wrong size on ABaseHusk");
static_assert(offsetof(ABaseHusk, _huskMesh) == 0x000238, "Member 'ABaseHusk::_huskMesh' has a wrong offset!");
static_assert(offsetof(ABaseHusk, _huskCustomizedSkeletalMesh) == 0x000240, "Member 'ABaseHusk::_huskCustomizedSkeletalMesh' has a wrong offset!");
static_assert(offsetof(ABaseHusk, _shouldDeactivateVFX) == 0x000248, "Member 'ABaseHusk::_shouldDeactivateVFX' has a wrong offset!");
static_assert(offsetof(ABaseHusk, _updateWeaponAccessories) == 0x000254, "Member 'ABaseHusk::_updateWeaponAccessories' has a wrong offset!");
static_assert(offsetof(ABaseHusk, _shouldWeaponBeVisible) == 0x000255, "Member 'ABaseHusk::_shouldWeaponBeVisible' has a wrong offset!");

// Class DBDGameplay.PoseableHusk
// 0x0008 (0x0260 - 0x0258)
class APoseableHusk final : public ABaseHusk
{
public:
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CapturePose();
	void Cosmetic_OnAnimationPoseCaptured();
	void OnActiveStateChanged(bool isActive);
	void SetIsActive(bool isActive);

	bool GetIsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoseableHusk">();
	}
	static class APoseableHusk* GetDefaultObj()
	{
		return GetDefaultObjImpl<APoseableHusk>();
	}
};
static_assert(alignof(APoseableHusk) == 0x000008, "Wrong alignment on APoseableHusk");
static_assert(sizeof(APoseableHusk) == 0x000260, "Wrong size on APoseableHusk");

// Class DBDGameplay.ActorPairQueryEvaluatorUtilities
// 0x0000 (0x0030 - 0x0030)
class UActorPairQueryEvaluatorUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorPairQueryEvaluatorUtilities">();
	}
	static class UActorPairQueryEvaluatorUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorPairQueryEvaluatorUtilities>();
	}
};
static_assert(alignof(UActorPairQueryEvaluatorUtilities) == 0x000008, "Wrong alignment on UActorPairQueryEvaluatorUtilities");
static_assert(sizeof(UActorPairQueryEvaluatorUtilities) == 0x000030, "Wrong size on UActorPairQueryEvaluatorUtilities");

// Class DBDGameplay.PositionLagCompensationComponent
// 0x0008 (0x00C0 - 0x00B8)
class UPositionLagCompensationComponent final : public UActorComponent
{
public:
	float                                         _maxExtrapolationDurationInSeconds;                // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxInterpolationToServerMoveInSeconds;            // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PositionLagCompensationComponent">();
	}
	static class UPositionLagCompensationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPositionLagCompensationComponent>();
	}
};
static_assert(alignof(UPositionLagCompensationComponent) == 0x000008, "Wrong alignment on UPositionLagCompensationComponent");
static_assert(sizeof(UPositionLagCompensationComponent) == 0x0000C0, "Wrong size on UPositionLagCompensationComponent");
static_assert(offsetof(UPositionLagCompensationComponent, _maxExtrapolationDurationInSeconds) == 0x0000B8, "Member 'UPositionLagCompensationComponent::_maxExtrapolationDurationInSeconds' has a wrong offset!");
static_assert(offsetof(UPositionLagCompensationComponent, _maxInterpolationToServerMoveInSeconds) == 0x0000BC, "Member 'UPositionLagCompensationComponent::_maxInterpolationToServerMoveInSeconds' has a wrong offset!");

// Class DBDGameplay.AimableComponent
// 0x0058 (0x0110 - 0x00B8)
class UAimableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _occlusionIgnoredActors;                           // 0x00C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         _maxAimDistance;                                   // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAimDirectionProvider*                  _aimDirectionProvider;                             // 0x00D8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useOcclusion;                                     // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _aimPointLerpFactor;                               // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAimPointProcessor*>             _preOcclusionAimPointProcessors;                   // 0x00E8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x18];                                      // 0x00F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMaxAimDistance(float maxAimDistance);
	void SetOcclusionIgnoredActors(const TArray<class AActor*>& ignoredActors);
	void SetProcessors(const TArray<class UAimPointProcessor*>& processors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimableComponent">();
	}
	static class UAimableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimableComponent>();
	}
};
static_assert(alignof(UAimableComponent) == 0x000008, "Wrong alignment on UAimableComponent");
static_assert(sizeof(UAimableComponent) == 0x000110, "Wrong size on UAimableComponent");
static_assert(offsetof(UAimableComponent, _occlusionIgnoredActors) == 0x0000C0, "Member 'UAimableComponent::_occlusionIgnoredActors' has a wrong offset!");
static_assert(offsetof(UAimableComponent, _maxAimDistance) == 0x0000D0, "Member 'UAimableComponent::_maxAimDistance' has a wrong offset!");
static_assert(offsetof(UAimableComponent, _aimDirectionProvider) == 0x0000D8, "Member 'UAimableComponent::_aimDirectionProvider' has a wrong offset!");
static_assert(offsetof(UAimableComponent, _useOcclusion) == 0x0000E0, "Member 'UAimableComponent::_useOcclusion' has a wrong offset!");
static_assert(offsetof(UAimableComponent, _aimPointLerpFactor) == 0x0000E4, "Member 'UAimableComponent::_aimPointLerpFactor' has a wrong offset!");
static_assert(offsetof(UAimableComponent, _preOcclusionAimPointProcessors) == 0x0000E8, "Member 'UAimableComponent::_preOcclusionAimPointProcessors' has a wrong offset!");

// Class DBDGameplay.AISense_Terror
// 0x0060 (0x00F0 - 0x0090)
class UAISense_Terror final : public UAISense
{
public:
	TArray<struct FAITerrorEvent>                 _events;                                           // 0x0090(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x50];                                      // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ReportTerrorEvent(class UObject* worldContextObj, const struct FVector& location, class AActor* instigator, class UTerrorRadiusEmitterComponent* terrorEmitter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_Terror">();
	}
	static class UAISense_Terror* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_Terror>();
	}
};
static_assert(alignof(UAISense_Terror) == 0x000008, "Wrong alignment on UAISense_Terror");
static_assert(sizeof(UAISense_Terror) == 0x0000F0, "Wrong size on UAISense_Terror");
static_assert(offsetof(UAISense_Terror, _events) == 0x000090, "Member 'UAISense_Terror::_events' has a wrong offset!");

// Class DBDGameplay.PowerChargeComponent
// 0x00A8 (0x0160 - 0x00B8)
class UPowerChargeComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(float currentChargePercent)> OnPowerChargeChanged;                 // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x58];                                      // 0x00C8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpeedBasedNetSyncedValue              _currentCharge;                                    // 0x0120(0x0038)(Net, Transient, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x4];                                      // 0x0158(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _forceFullCharge;                                  // 0x015C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15D[0x3];                                      // 0x015D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCurrentChargeChanged(float value);
	void OnRep_CurrentCharge();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerChargeComponent">();
	}
	static class UPowerChargeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerChargeComponent>();
	}
};
static_assert(alignof(UPowerChargeComponent) == 0x000008, "Wrong alignment on UPowerChargeComponent");
static_assert(sizeof(UPowerChargeComponent) == 0x000160, "Wrong size on UPowerChargeComponent");
static_assert(offsetof(UPowerChargeComponent, OnPowerChargeChanged) == 0x0000B8, "Member 'UPowerChargeComponent::OnPowerChargeChanged' has a wrong offset!");
static_assert(offsetof(UPowerChargeComponent, _currentCharge) == 0x000120, "Member 'UPowerChargeComponent::_currentCharge' has a wrong offset!");
static_assert(offsetof(UPowerChargeComponent, _forceFullCharge) == 0x00015C, "Member 'UPowerChargeComponent::_forceFullCharge' has a wrong offset!");

// Class DBDGameplay.AimDirectionProvider
// 0x0000 (0x0030 - 0x0030)
class UAimDirectionProvider : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimDirectionProvider">();
	}
	static class UAimDirectionProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimDirectionProvider>();
	}
};
static_assert(alignof(UAimDirectionProvider) == 0x000008, "Wrong alignment on UAimDirectionProvider");
static_assert(sizeof(UAimDirectionProvider) == 0x000030, "Wrong size on UAimDirectionProvider");

// Class DBDGameplay.AimPointProcessor
// 0x0000 (0x00B8 - 0x00B8)
class UAimPointProcessor : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimPointProcessor">();
	}
	static class UAimPointProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimPointProcessor>();
	}
};
static_assert(alignof(UAimPointProcessor) == 0x000008, "Wrong alignment on UAimPointProcessor");
static_assert(sizeof(UAimPointProcessor) == 0x0000B8, "Wrong size on UAimPointProcessor");

// Class DBDGameplay.PowerChargePresentationItemProgressComponent
// 0x0018 (0x00D0 - 0x00B8)
class UPowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	class UPowerChargeComponent*                  _powerChargeComponent;                             // 0x00B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPowerToggleComponent*                  _powerToggleComponent;                             // 0x00C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _chargeReadyThreshold;                             // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerChargePresentationItemProgressComponent">();
	}
	static class UPowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UPowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UPowerChargePresentationItemProgressComponent");
static_assert(sizeof(UPowerChargePresentationItemProgressComponent) == 0x0000D0, "Wrong size on UPowerChargePresentationItemProgressComponent");
static_assert(offsetof(UPowerChargePresentationItemProgressComponent, _powerChargeComponent) == 0x0000B8, "Member 'UPowerChargePresentationItemProgressComponent::_powerChargeComponent' has a wrong offset!");
static_assert(offsetof(UPowerChargePresentationItemProgressComponent, _powerToggleComponent) == 0x0000C0, "Member 'UPowerChargePresentationItemProgressComponent::_powerToggleComponent' has a wrong offset!");
static_assert(offsetof(UPowerChargePresentationItemProgressComponent, _chargeReadyThreshold) == 0x0000C8, "Member 'UPowerChargePresentationItemProgressComponent::_chargeReadyThreshold' has a wrong offset!");

// Class DBDGameplay.AimPointPerlinNoise
// 0x0030 (0x00E8 - 0x00B8)
class UAimPointPerlinNoise final : public UAimPointProcessor
{
public:
	uint8                                         Pad_B8[0x4];                                       // 0x00B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _baseInaccuracyNoisePersistence;                   // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _baseInaccuracyNoiseOctaveCount;                   // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _baseInaccuracyNoiseAmplitude;                     // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x4];                                       // 0x00C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _baseInaccuracyNoiseFrequency;                     // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x4];                                       // 0x00D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeOffset;                                       // 0x00D4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBaseInaccuracyNoiseAmplitude(const float amplitude);
	void SetBaseInaccuracyNoiseFrequency(const float frequency);
	void SetBaseInaccuracyNoiseOctaveCount(const int32 octaveCount);
	void SetBaseInaccuracyNoisePersistence(const float noisePersistence);
	void SetNoiseAmplitudeMultiplier(const float multiplier);
	void SetNoiseFrequencyMultiplier(const float multiplier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimPointPerlinNoise">();
	}
	static class UAimPointPerlinNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimPointPerlinNoise>();
	}
};
static_assert(alignof(UAimPointPerlinNoise) == 0x000008, "Wrong alignment on UAimPointPerlinNoise");
static_assert(sizeof(UAimPointPerlinNoise) == 0x0000E8, "Wrong size on UAimPointPerlinNoise");
static_assert(offsetof(UAimPointPerlinNoise, _baseInaccuracyNoisePersistence) == 0x0000BC, "Member 'UAimPointPerlinNoise::_baseInaccuracyNoisePersistence' has a wrong offset!");
static_assert(offsetof(UAimPointPerlinNoise, _baseInaccuracyNoiseOctaveCount) == 0x0000C0, "Member 'UAimPointPerlinNoise::_baseInaccuracyNoiseOctaveCount' has a wrong offset!");
static_assert(offsetof(UAimPointPerlinNoise, _baseInaccuracyNoiseAmplitude) == 0x0000C4, "Member 'UAimPointPerlinNoise::_baseInaccuracyNoiseAmplitude' has a wrong offset!");
static_assert(offsetof(UAimPointPerlinNoise, _baseInaccuracyNoiseFrequency) == 0x0000CC, "Member 'UAimPointPerlinNoise::_baseInaccuracyNoiseFrequency' has a wrong offset!");
static_assert(offsetof(UAimPointPerlinNoise, _timeOffset) == 0x0000D4, "Member 'UAimPointPerlinNoise::_timeOffset' has a wrong offset!");

// Class DBDGameplay.RangeToActorsTrackerComponent
// 0x0010 (0x00C8 - 0x00B8)
class URangeToActorsTrackerComponent final : public UActorComponent
{
public:
	TArray<class URangeToActorsTrackerStrategy*>  _rangeTrackers;                                    // 0x00B8(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, NoClear, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangeToActorsTrackerComponent">();
	}
	static class URangeToActorsTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangeToActorsTrackerComponent>();
	}
};
static_assert(alignof(URangeToActorsTrackerComponent) == 0x000008, "Wrong alignment on URangeToActorsTrackerComponent");
static_assert(sizeof(URangeToActorsTrackerComponent) == 0x0000C8, "Wrong size on URangeToActorsTrackerComponent");
static_assert(offsetof(URangeToActorsTrackerComponent, _rangeTrackers) == 0x0000B8, "Member 'URangeToActorsTrackerComponent::_rangeTrackers' has a wrong offset!");

// Class DBDGameplay.AISenseConfig_Terror
// 0x0068 (0x00B8 - 0x0050)
class UAISenseConfig_Terror final : public UAISenseConfig
{
public:
	TSubclassOf<class UAISense_Terror>            Implementation;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxBreathingSoundRange;                            // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAITerrorLevel, float>                   TerrorRanges;                                      // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_Terror">();
	}
	static class UAISenseConfig_Terror* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_Terror>();
	}
};
static_assert(alignof(UAISenseConfig_Terror) == 0x000008, "Wrong alignment on UAISenseConfig_Terror");
static_assert(sizeof(UAISenseConfig_Terror) == 0x0000B8, "Wrong size on UAISenseConfig_Terror");
static_assert(offsetof(UAISenseConfig_Terror, Implementation) == 0x000050, "Member 'UAISenseConfig_Terror::Implementation' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Terror, MaxBreathingSoundRange) == 0x000058, "Member 'UAISenseConfig_Terror::MaxBreathingSoundRange' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Terror, TerrorRanges) == 0x000060, "Member 'UAISenseConfig_Terror::TerrorRanges' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Terror, DetectionByAffiliation) == 0x0000B0, "Member 'UAISenseConfig_Terror::DetectionByAffiliation' has a wrong offset!");

// Class DBDGameplay.AuraOverriderComponent
// 0x0050 (0x0108 - 0x00B8)
class UAuraOverriderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceShowAura(const class AActor* actor, const struct FLinearColor& color, bool isAlwaysVisible, const float minimumOutlineDistance);
	void ResetAura(const class AActor* actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuraOverriderComponent">();
	}
	static class UAuraOverriderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuraOverriderComponent>();
	}
};
static_assert(alignof(UAuraOverriderComponent) == 0x000008, "Wrong alignment on UAuraOverriderComponent");
static_assert(sizeof(UAuraOverriderComponent) == 0x000108, "Wrong size on UAuraOverriderComponent");

// Class DBDGameplay.BaseActorAttackableComponent
// 0x0038 (0x00F0 - 0x00B8)
class UBaseActorAttackableComponent final : public UAttackableComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _killerProjectilesThatCanDamageActor;              // 0x00D0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void HitWithProjectile(class ABaseProjectile* projectile);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseActorAttackableComponent">();
	}
	static class UBaseActorAttackableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseActorAttackableComponent>();
	}
};
static_assert(alignof(UBaseActorAttackableComponent) == 0x000008, "Wrong alignment on UBaseActorAttackableComponent");
static_assert(sizeof(UBaseActorAttackableComponent) == 0x0000F0, "Wrong size on UBaseActorAttackableComponent");
static_assert(offsetof(UBaseActorAttackableComponent, _killerProjectilesThatCanDamageActor) == 0x0000D0, "Member 'UBaseActorAttackableComponent::_killerProjectilesThatCanDamageActor' has a wrong offset!");

// Class DBDGameplay.BaseCamperCollectable
// 0x0048 (0x04F8 - 0x04B0)
class ABaseCamperCollectable : public ACollectable
{
public:
	class USpherePlayerOverlapComponent*          _interactable;                                     // 0x04B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _collectableInteractor;                            // 0x04B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDropItemInteraction*                   _dropInteraction;                                  // 0x04C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCollectItemInteraction*                _collectInteraction;                               // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       _infectablePrimitive;                              // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x04D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialHelper*                        _materialHelper;                                   // 0x04E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USurvivorCollectableOutlineUpdateStrategy* _survivorCollectableOutlineUpdateStrategy;      // 0x04E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F0[0x8];                                      // 0x04F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCamperCollectable">();
	}
	static class ABaseCamperCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseCamperCollectable>();
	}
};
static_assert(alignof(ABaseCamperCollectable) == 0x000008, "Wrong alignment on ABaseCamperCollectable");
static_assert(sizeof(ABaseCamperCollectable) == 0x0004F8, "Wrong size on ABaseCamperCollectable");
static_assert(offsetof(ABaseCamperCollectable, _interactable) == 0x0004B0, "Member 'ABaseCamperCollectable::_interactable' has a wrong offset!");
static_assert(offsetof(ABaseCamperCollectable, _collectableInteractor) == 0x0004B8, "Member 'ABaseCamperCollectable::_collectableInteractor' has a wrong offset!");
static_assert(offsetof(ABaseCamperCollectable, _dropInteraction) == 0x0004C0, "Member 'ABaseCamperCollectable::_dropInteraction' has a wrong offset!");
static_assert(offsetof(ABaseCamperCollectable, _collectInteraction) == 0x0004C8, "Member 'ABaseCamperCollectable::_collectInteraction' has a wrong offset!");
static_assert(offsetof(ABaseCamperCollectable, _infectablePrimitive) == 0x0004D0, "Member 'ABaseCamperCollectable::_infectablePrimitive' has a wrong offset!");
static_assert(offsetof(ABaseCamperCollectable, _outlineComponent) == 0x0004D8, "Member 'ABaseCamperCollectable::_outlineComponent' has a wrong offset!");
static_assert(offsetof(ABaseCamperCollectable, _materialHelper) == 0x0004E0, "Member 'ABaseCamperCollectable::_materialHelper' has a wrong offset!");
static_assert(offsetof(ABaseCamperCollectable, _survivorCollectableOutlineUpdateStrategy) == 0x0004E8, "Member 'ABaseCamperCollectable::_survivorCollectableOutlineUpdateStrategy' has a wrong offset!");

// Class DBDGameplay.FlashlightableLightingStrategy
// 0x0000 (0x0030 - 0x0030)
class UFlashlightableLightingStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightableLightingStrategy">();
	}
	static class UFlashlightableLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightableLightingStrategy>();
	}
};
static_assert(alignof(UFlashlightableLightingStrategy) == 0x000008, "Wrong alignment on UFlashlightableLightingStrategy");
static_assert(sizeof(UFlashlightableLightingStrategy) == 0x000030, "Wrong size on UFlashlightableLightingStrategy");

// Class DBDGameplay.FlashlightablePointsLightingStrategy
// 0x0010 (0x0040 - 0x0030)
class UFlashlightablePointsLightingStrategy : public UFlashlightableLightingStrategy
{
public:
	class UPointsProvider*                        _pointsProvider;                                   // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoClear, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _impactPointDistanceError;                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightablePointsLightingStrategy">();
	}
	static class UFlashlightablePointsLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightablePointsLightingStrategy>();
	}
};
static_assert(alignof(UFlashlightablePointsLightingStrategy) == 0x000008, "Wrong alignment on UFlashlightablePointsLightingStrategy");
static_assert(sizeof(UFlashlightablePointsLightingStrategy) == 0x000040, "Wrong size on UFlashlightablePointsLightingStrategy");
static_assert(offsetof(UFlashlightablePointsLightingStrategy, _pointsProvider) == 0x000030, "Member 'UFlashlightablePointsLightingStrategy::_pointsProvider' has a wrong offset!");
static_assert(offsetof(UFlashlightablePointsLightingStrategy, _impactPointDistanceError) == 0x000038, "Member 'UFlashlightablePointsLightingStrategy::_impactPointDistanceError' has a wrong offset!");

// Class DBDGameplay.BlindFlashlightableLightingStrategy
// 0x0000 (0x0040 - 0x0040)
class UBlindFlashlightableLightingStrategy : public UFlashlightablePointsLightingStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindFlashlightableLightingStrategy">();
	}
	static class UBlindFlashlightableLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindFlashlightableLightingStrategy>();
	}
};
static_assert(alignof(UBlindFlashlightableLightingStrategy) == 0x000008, "Wrong alignment on UBlindFlashlightableLightingStrategy");
static_assert(sizeof(UBlindFlashlightableLightingStrategy) == 0x000040, "Wrong size on UBlindFlashlightableLightingStrategy");

// Class DBDGameplay.FlashlightTargetFXComponent
// 0x0048 (0x0100 - 0x00B8)
class UFlashlightTargetFXComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _modifiesBeamAngle;                                // 0x00E8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlashlightableComponent*               _flashlightable;                                   // 0x00F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIsLitChanged(bool isLit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightTargetFXComponent">();
	}
	static class UFlashlightTargetFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightTargetFXComponent>();
	}
};
static_assert(alignof(UFlashlightTargetFXComponent) == 0x000008, "Wrong alignment on UFlashlightTargetFXComponent");
static_assert(sizeof(UFlashlightTargetFXComponent) == 0x000100, "Wrong size on UFlashlightTargetFXComponent");
static_assert(offsetof(UFlashlightTargetFXComponent, _modifiesBeamAngle) == 0x0000E8, "Member 'UFlashlightTargetFXComponent::_modifiesBeamAngle' has a wrong offset!");
static_assert(offsetof(UFlashlightTargetFXComponent, _flashlightable) == 0x0000F0, "Member 'UFlashlightTargetFXComponent::_flashlightable' has a wrong offset!");

// Class DBDGameplay.BlindFlashlightTargetFXComponent
// 0x0028 (0x0128 - 0x0100)
class UBlindFlashlightTargetFXComponent final : public UFlashlightTargetFXComponent
{
public:
	uint8                                         Pad_100[0x28];                                     // 0x0100(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindFlashlightTargetFXComponent">();
	}
	static class UBlindFlashlightTargetFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindFlashlightTargetFXComponent>();
	}
};
static_assert(alignof(UBlindFlashlightTargetFXComponent) == 0x000008, "Wrong alignment on UBlindFlashlightTargetFXComponent");
static_assert(sizeof(UBlindFlashlightTargetFXComponent) == 0x000128, "Wrong size on UBlindFlashlightTargetFXComponent");

// Class DBDGameplay.FootstepCreatorComponent
// 0x0050 (0x0108 - 0x00B8)
class UFootstepCreatorComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _fadeCurve;                                        // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _veinsCurve;                                       // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UFootstepManagerComponent>  _footstepManagerComponentClass;                    // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _secondsUntilFootprintTrigger;                     // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _canSpawnFootstepsDefaultValue;                    // 0x00FC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD[0xB];                                       // 0x00FD(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepCreatorComponent">();
	}
	static class UFootstepCreatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepCreatorComponent>();
	}
};
static_assert(alignof(UFootstepCreatorComponent) == 0x000008, "Wrong alignment on UFootstepCreatorComponent");
static_assert(sizeof(UFootstepCreatorComponent) == 0x000108, "Wrong size on UFootstepCreatorComponent");
static_assert(offsetof(UFootstepCreatorComponent, _fadeCurve) == 0x0000D8, "Member 'UFootstepCreatorComponent::_fadeCurve' has a wrong offset!");
static_assert(offsetof(UFootstepCreatorComponent, _veinsCurve) == 0x0000E0, "Member 'UFootstepCreatorComponent::_veinsCurve' has a wrong offset!");
static_assert(offsetof(UFootstepCreatorComponent, _footstepManagerComponentClass) == 0x0000E8, "Member 'UFootstepCreatorComponent::_footstepManagerComponentClass' has a wrong offset!");
static_assert(offsetof(UFootstepCreatorComponent, _secondsUntilFootprintTrigger) == 0x0000F8, "Member 'UFootstepCreatorComponent::_secondsUntilFootprintTrigger' has a wrong offset!");
static_assert(offsetof(UFootstepCreatorComponent, _canSpawnFootstepsDefaultValue) == 0x0000FC, "Member 'UFootstepCreatorComponent::_canSpawnFootstepsDefaultValue' has a wrong offset!");

// Class DBDGameplay.CamperFootstepCreatorComponent
// 0x0238 (0x0340 - 0x0108)
class UCamperFootstepCreatorComponent final : public UFootstepCreatorComponent
{
public:
	TArray<struct FGameplayTag>                   _disallowFootstepsSpawnPerkFlags;                  // 0x0108(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FStatProperty                          _footstepIndicatorAngle;                           // 0x0118(0x0088)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _footstepIndicatorDecalSize;                       // 0x01A0(0x0088)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _footstepIndicatorDurationAdditive;                // 0x0228(0x0088)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _footstepIndicatorDurationMultiplictive;           // 0x02B0(0x0088)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoudNoiseTriggered(class AActor* originator, class AActor* instigatingActor, const struct FVector& location, bool shouldTrack, float* audibleRange, bool isQuickAction, bool isDeceivingNoise);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperFootstepCreatorComponent">();
	}
	static class UCamperFootstepCreatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperFootstepCreatorComponent>();
	}
};
static_assert(alignof(UCamperFootstepCreatorComponent) == 0x000008, "Wrong alignment on UCamperFootstepCreatorComponent");
static_assert(sizeof(UCamperFootstepCreatorComponent) == 0x000340, "Wrong size on UCamperFootstepCreatorComponent");
static_assert(offsetof(UCamperFootstepCreatorComponent, _disallowFootstepsSpawnPerkFlags) == 0x000108, "Member 'UCamperFootstepCreatorComponent::_disallowFootstepsSpawnPerkFlags' has a wrong offset!");
static_assert(offsetof(UCamperFootstepCreatorComponent, _footstepIndicatorAngle) == 0x000118, "Member 'UCamperFootstepCreatorComponent::_footstepIndicatorAngle' has a wrong offset!");
static_assert(offsetof(UCamperFootstepCreatorComponent, _footstepIndicatorDecalSize) == 0x0001A0, "Member 'UCamperFootstepCreatorComponent::_footstepIndicatorDecalSize' has a wrong offset!");
static_assert(offsetof(UCamperFootstepCreatorComponent, _footstepIndicatorDurationAdditive) == 0x000228, "Member 'UCamperFootstepCreatorComponent::_footstepIndicatorDurationAdditive' has a wrong offset!");
static_assert(offsetof(UCamperFootstepCreatorComponent, _footstepIndicatorDurationMultiplictive) == 0x0002B0, "Member 'UCamperFootstepCreatorComponent::_footstepIndicatorDurationMultiplictive' has a wrong offset!");

// Class DBDGameplay.FootstepPerceptionComponent
// 0x0018 (0x00D0 - 0x00B8)
class UFootstepPerceptionComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _canSeeFootstepsDefaultValue;                      // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepPerceptionComponent">();
	}
	static class UFootstepPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepPerceptionComponent>();
	}
};
static_assert(alignof(UFootstepPerceptionComponent) == 0x000008, "Wrong alignment on UFootstepPerceptionComponent");
static_assert(sizeof(UFootstepPerceptionComponent) == 0x0000D0, "Wrong size on UFootstepPerceptionComponent");
static_assert(offsetof(UFootstepPerceptionComponent, _canSeeFootstepsDefaultValue) == 0x0000C8, "Member 'UFootstepPerceptionComponent::_canSeeFootstepsDefaultValue' has a wrong offset!");

// Class DBDGameplay.PlayerFootstepPerceptionComponent
// 0x0040 (0x0110 - 0x00D0)
class UPlayerFootstepPerceptionComponent : public UFootstepPerceptionComponent
{
public:
	TArray<struct FGameplayTag>                   _allowFootstepsSeenPerkFlags;                      // 0x00D0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _disallowFootstepsSeenPerkFlags;                   // 0x00E0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x20];                                      // 0x00F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerFootstepPerceptionComponent">();
	}
	static class UPlayerFootstepPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerFootstepPerceptionComponent>();
	}
};
static_assert(alignof(UPlayerFootstepPerceptionComponent) == 0x000008, "Wrong alignment on UPlayerFootstepPerceptionComponent");
static_assert(sizeof(UPlayerFootstepPerceptionComponent) == 0x000110, "Wrong size on UPlayerFootstepPerceptionComponent");
static_assert(offsetof(UPlayerFootstepPerceptionComponent, _allowFootstepsSeenPerkFlags) == 0x0000D0, "Member 'UPlayerFootstepPerceptionComponent::_allowFootstepsSeenPerkFlags' has a wrong offset!");
static_assert(offsetof(UPlayerFootstepPerceptionComponent, _disallowFootstepsSeenPerkFlags) == 0x0000E0, "Member 'UPlayerFootstepPerceptionComponent::_disallowFootstepsSeenPerkFlags' has a wrong offset!");

// Class DBDGameplay.CamperFootstepPerceptionComponent
// 0x0000 (0x0110 - 0x0110)
class UCamperFootstepPerceptionComponent final : public UPlayerFootstepPerceptionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperFootstepPerceptionComponent">();
	}
	static class UCamperFootstepPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperFootstepPerceptionComponent>();
	}
};
static_assert(alignof(UCamperFootstepPerceptionComponent) == 0x000008, "Wrong alignment on UCamperFootstepPerceptionComponent");
static_assert(sizeof(UCamperFootstepPerceptionComponent) == 0x000110, "Wrong size on UCamperFootstepPerceptionComponent");

// Class DBDGameplay.CharacterOptimizer
// 0x0010 (0x00C8 - 0x00B8)
class UCharacterOptimizer final : public UActorComponent
{
public:
	float                                         _characterMovementTickRateWhenInsignificant;       // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0xC];                                       // 0x00BC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterOptimizer">();
	}
	static class UCharacterOptimizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterOptimizer>();
	}
};
static_assert(alignof(UCharacterOptimizer) == 0x000008, "Wrong alignment on UCharacterOptimizer");
static_assert(sizeof(UCharacterOptimizer) == 0x0000C8, "Wrong size on UCharacterOptimizer");
static_assert(offsetof(UCharacterOptimizer, _characterMovementTickRateWhenInsignificant) == 0x0000B8, "Member 'UCharacterOptimizer::_characterMovementTickRateWhenInsignificant' has a wrong offset!");

// Class DBDGameplay.CollectableComponentUtilities
// 0x0000 (0x0030 - 0x0030)
class UCollectableComponentUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class ADBDPlayer* GetCollector(const class UActorComponent* component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectableComponentUtilities">();
	}
	static class UCollectableComponentUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectableComponentUtilities>();
	}
};
static_assert(alignof(UCollectableComponentUtilities) == 0x000008, "Wrong alignment on UCollectableComponentUtilities");
static_assert(sizeof(UCollectableComponentUtilities) == 0x000030, "Wrong size on UCollectableComponentUtilities");

// Class DBDGameplay.ConspicuousActionComponent
// 0x0030 (0x00E8 - 0x00B8)
class UConspicuousActionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConspicuousActionComponent">();
	}
	static class UConspicuousActionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConspicuousActionComponent>();
	}
};
static_assert(alignof(UConspicuousActionComponent) == 0x000008, "Wrong alignment on UConspicuousActionComponent");
static_assert(sizeof(UConspicuousActionComponent) == 0x0000E8, "Wrong size on UConspicuousActionComponent");

// Class DBDGameplay.DBDCharacterPusherComponent
// 0x0010 (0x0180 - 0x0170)
class UDBDCharacterPusherComponent final : public UCharacterPusherComponent
{
public:
	uint8                                         Pad_170[0x10];                                     // 0x0170(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCharacterPusherComponent">();
	}
	static class UDBDCharacterPusherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCharacterPusherComponent>();
	}
};
static_assert(alignof(UDBDCharacterPusherComponent) == 0x000008, "Wrong alignment on UDBDCharacterPusherComponent");
static_assert(sizeof(UDBDCharacterPusherComponent) == 0x000180, "Wrong size on UDBDCharacterPusherComponent");

// Class DBDGameplay.DebugIndicator
// 0x0020 (0x0250 - 0x0230)
class ADebugIndicator final : public AActor
{
public:
	class UStaticMeshComponent*                   _staticMeshComponent;                              // 0x0230(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x0238(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColor(const struct FLinearColor& color);
	void SetVisible(const bool visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugIndicator">();
	}
	static class ADebugIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugIndicator>();
	}
};
static_assert(alignof(ADebugIndicator) == 0x000008, "Wrong alignment on ADebugIndicator");
static_assert(sizeof(ADebugIndicator) == 0x000250, "Wrong size on ADebugIndicator");
static_assert(offsetof(ADebugIndicator, _staticMeshComponent) == 0x000230, "Member 'ADebugIndicator::_staticMeshComponent' has a wrong offset!");
static_assert(offsetof(ADebugIndicator, _outlineComponent) == 0x000238, "Member 'ADebugIndicator::_outlineComponent' has a wrong offset!");

// Class DBDGameplay.DecoySlasherComponent
// 0x0040 (0x00F8 - 0x00B8)
class UDecoySlasherComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AActor* instigator)> OnStunned;                              // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool visible, const struct FVector& location, const struct FRotator& rotation)> TriggerDecoyVisibilityVFX; // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          HasTerrorRadius;                                   // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HasRedGlow;                                        // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActive;                                         // 0x00E2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _initialized;                                      // 0x00E3(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTerrorRadiusEmitterComponent*          _terrorRadiusEmitter;                              // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URedStainComponent*                     _redStainComponent;                                // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CopyCustomizationFromSlasher();
	void DoPostVFXUpdates(const struct FVector& location, const struct FRotator& rotation);
	void OnRealSlasherTerrorRadiusChanged(float newValue);
	void SetDecoyIsActive(bool isActive, const struct FVector& location, const struct FRotator& rotation, bool visibleRedGlow);

	class ASlasherPlayer* GetRealSlasher() const;
	bool IsDecoyActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecoySlasherComponent">();
	}
	static class UDecoySlasherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecoySlasherComponent>();
	}
};
static_assert(alignof(UDecoySlasherComponent) == 0x000008, "Wrong alignment on UDecoySlasherComponent");
static_assert(sizeof(UDecoySlasherComponent) == 0x0000F8, "Wrong size on UDecoySlasherComponent");
static_assert(offsetof(UDecoySlasherComponent, OnStunned) == 0x0000C0, "Member 'UDecoySlasherComponent::OnStunned' has a wrong offset!");
static_assert(offsetof(UDecoySlasherComponent, TriggerDecoyVisibilityVFX) == 0x0000D0, "Member 'UDecoySlasherComponent::TriggerDecoyVisibilityVFX' has a wrong offset!");
static_assert(offsetof(UDecoySlasherComponent, HasTerrorRadius) == 0x0000E0, "Member 'UDecoySlasherComponent::HasTerrorRadius' has a wrong offset!");
static_assert(offsetof(UDecoySlasherComponent, HasRedGlow) == 0x0000E1, "Member 'UDecoySlasherComponent::HasRedGlow' has a wrong offset!");
static_assert(offsetof(UDecoySlasherComponent, _isActive) == 0x0000E2, "Member 'UDecoySlasherComponent::_isActive' has a wrong offset!");
static_assert(offsetof(UDecoySlasherComponent, _initialized) == 0x0000E3, "Member 'UDecoySlasherComponent::_initialized' has a wrong offset!");
static_assert(offsetof(UDecoySlasherComponent, _terrorRadiusEmitter) == 0x0000E8, "Member 'UDecoySlasherComponent::_terrorRadiusEmitter' has a wrong offset!");
static_assert(offsetof(UDecoySlasherComponent, _redStainComponent) == 0x0000F0, "Member 'UDecoySlasherComponent::_redStainComponent' has a wrong offset!");

// Class DBDGameplay.EtherealComponent
// 0x0040 (0x00F8 - 0x00B8)
class UEtherealComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isEthereal;                                       // 0x00E0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x17];                                      // 0x00E1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_OnIsEtherealChanged();
	void Server_SetIsEthereal(float timestamp, bool ethereal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EtherealComponent">();
	}
	static class UEtherealComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEtherealComponent>();
	}
};
static_assert(alignof(UEtherealComponent) == 0x000008, "Wrong alignment on UEtherealComponent");
static_assert(sizeof(UEtherealComponent) == 0x0000F8, "Wrong size on UEtherealComponent");
static_assert(offsetof(UEtherealComponent, _isEthereal) == 0x0000E0, "Member 'UEtherealComponent::_isEthereal' has a wrong offset!");

// Class DBDGameplay.RangeToActorsTrackerStrategy
// 0x0040 (0x0070 - 0x0030)
class URangeToActorsTrackerStrategy : public UObject
{
public:
	struct FDBDTunableRowHandle                   _range;                                            // 0x0030(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInRangeToTrackedActorsChanged(const bool inRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangeToActorsTrackerStrategy">();
	}
	static class URangeToActorsTrackerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangeToActorsTrackerStrategy>();
	}
};
static_assert(alignof(URangeToActorsTrackerStrategy) == 0x000008, "Wrong alignment on URangeToActorsTrackerStrategy");
static_assert(sizeof(URangeToActorsTrackerStrategy) == 0x000070, "Wrong size on URangeToActorsTrackerStrategy");
static_assert(offsetof(URangeToActorsTrackerStrategy, _range) == 0x000030, "Member 'URangeToActorsTrackerStrategy::_range' has a wrong offset!");

// Class DBDGameplay.ExitGateSwitchesRangeTrackerStrategy
// 0x0000 (0x0070 - 0x0070)
class UExitGateSwitchesRangeTrackerStrategy final : public URangeToActorsTrackerStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExitGateSwitchesRangeTrackerStrategy">();
	}
	static class UExitGateSwitchesRangeTrackerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExitGateSwitchesRangeTrackerStrategy>();
	}
};
static_assert(alignof(UExitGateSwitchesRangeTrackerStrategy) == 0x000008, "Wrong alignment on UExitGateSwitchesRangeTrackerStrategy");
static_assert(sizeof(UExitGateSwitchesRangeTrackerStrategy) == 0x000070, "Wrong size on UExitGateSwitchesRangeTrackerStrategy");

// Class DBDGameplay.FadeComponent
// 0x0020 (0x00D8 - 0x00B8)
class UFadeComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(float fadePercent)> OnFadePercentChanged;                          // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         _fadeDuration;                                     // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0xC];                                       // 0x00CC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetFadePercent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadeComponent">();
	}
	static class UFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadeComponent>();
	}
};
static_assert(alignof(UFadeComponent) == 0x000008, "Wrong alignment on UFadeComponent");
static_assert(sizeof(UFadeComponent) == 0x0000D8, "Wrong size on UFadeComponent");
static_assert(offsetof(UFadeComponent, OnFadePercentChanged) == 0x0000B8, "Member 'UFadeComponent::OnFadePercentChanged' has a wrong offset!");
static_assert(offsetof(UFadeComponent, _fadeDuration) == 0x0000C8, "Member 'UFadeComponent::_fadeDuration' has a wrong offset!");

// Class DBDGameplay.FirecrackerSpawner
// 0x0000 (0x04F8 - 0x04F8)
class AFirecrackerSpawner final : public ABaseCamperCollectable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirecrackerSpawner">();
	}
	static class AFirecrackerSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFirecrackerSpawner>();
	}
};
static_assert(alignof(AFirecrackerSpawner) == 0x000008, "Wrong alignment on AFirecrackerSpawner");
static_assert(sizeof(AFirecrackerSpawner) == 0x0004F8, "Wrong size on AFirecrackerSpawner");

// Class DBDGameplay.Flashlight
// 0x00B8 (0x05B0 - 0x04F8)
class AFlashlight final : public ABaseCamperCollectable
{
public:
	struct FGameplayTagContainer                  _allowedInteractionSemanticsDuringUse;             // 0x04F8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_518[0x58];                                     // 0x0518(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _shouldUseCooldowns;                               // 0x0570(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_571[0x3];                                      // 0x0571(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _cooldownWhileOnDuration;                          // 0x0574(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cooldownWhileOffDuration;                         // 0x0578(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_57C[0x34];                                     // 0x057C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USpotLightComponent* GetSpotlightComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Flashlight">();
	}
	static class AFlashlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlashlight>();
	}
};
static_assert(alignof(AFlashlight) == 0x000008, "Wrong alignment on AFlashlight");
static_assert(sizeof(AFlashlight) == 0x0005B0, "Wrong size on AFlashlight");
static_assert(offsetof(AFlashlight, _allowedInteractionSemanticsDuringUse) == 0x0004F8, "Member 'AFlashlight::_allowedInteractionSemanticsDuringUse' has a wrong offset!");
static_assert(offsetof(AFlashlight, _shouldUseCooldowns) == 0x000570, "Member 'AFlashlight::_shouldUseCooldowns' has a wrong offset!");
static_assert(offsetof(AFlashlight, _cooldownWhileOnDuration) == 0x000574, "Member 'AFlashlight::_cooldownWhileOnDuration' has a wrong offset!");
static_assert(offsetof(AFlashlight, _cooldownWhileOffDuration) == 0x000578, "Member 'AFlashlight::_cooldownWhileOffDuration' has a wrong offset!");

// Class DBDGameplay.FlashlightableComponent
// 0x0088 (0x0140 - 0x00B8)
class UFlashlightableComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const class UFlashlightComponent* flashlight)> OnFlashlightAddedEvent; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class UFlashlightComponent* flashlight)> OnFlashlightRemovedEvent; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool isLit)>    OnFlashlightLitChangedEvent;                       // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UFlashlightableLightingStrategy*        _lightingStrategy;                                 // 0x00E8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UFlashlightComponent*>             _flashlights;                                      // 0x00F0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	bool IsLit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightableComponent">();
	}
	static class UFlashlightableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightableComponent>();
	}
};
static_assert(alignof(UFlashlightableComponent) == 0x000008, "Wrong alignment on UFlashlightableComponent");
static_assert(sizeof(UFlashlightableComponent) == 0x000140, "Wrong size on UFlashlightableComponent");
static_assert(offsetof(UFlashlightableComponent, OnFlashlightAddedEvent) == 0x0000B8, "Member 'UFlashlightableComponent::OnFlashlightAddedEvent' has a wrong offset!");
static_assert(offsetof(UFlashlightableComponent, OnFlashlightRemovedEvent) == 0x0000C8, "Member 'UFlashlightableComponent::OnFlashlightRemovedEvent' has a wrong offset!");
static_assert(offsetof(UFlashlightableComponent, OnFlashlightLitChangedEvent) == 0x0000D8, "Member 'UFlashlightableComponent::OnFlashlightLitChangedEvent' has a wrong offset!");
static_assert(offsetof(UFlashlightableComponent, _lightingStrategy) == 0x0000E8, "Member 'UFlashlightableComponent::_lightingStrategy' has a wrong offset!");
static_assert(offsetof(UFlashlightableComponent, _flashlights) == 0x0000F0, "Member 'UFlashlightableComponent::_flashlights' has a wrong offset!");

// Class DBDGameplay.FlashlightComponent
// 0x0148 (0x0200 - 0x00B8)
class UFlashlightComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnFlashlightTurnedOn;                              // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFlashlightTurnedOff;                             // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFlashlightablesUpdated;                          // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _baseBlindnessDuration;                            // 0x00F0(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _baseAccuracy;                                     // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lagDuration;                                      // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UFlashlightableComponent*>         _flashlightables;                                  // 0x0120(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UFlashlightableComponent*>         _autonomousLitFlashlightables;                     // 0x0170(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UFlashlightableComponent*>       _replicatedLitFlashlightables;                     // 0x01C0(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          _isOwnerLagging;                                   // 0x01D0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D1[0x2F];                                     // 0x01D1(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsOwnerLagging();
	void OnRep_ReplicatedLitFlashlightables();
	void Server_SetAndUpdateAutonomousLitFlashlightables(const TArray<class UFlashlightableComponent*>& newLitFlashlightables);
	void TurnOff();
	void TurnOn();

	float GetEffectiveBlindnessDuration() const;
	float GetEffectiveTimeToBlindModifier() const;
	bool IsOn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightComponent">();
	}
	static class UFlashlightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightComponent>();
	}
};
static_assert(alignof(UFlashlightComponent) == 0x000008, "Wrong alignment on UFlashlightComponent");
static_assert(sizeof(UFlashlightComponent) == 0x000200, "Wrong size on UFlashlightComponent");
static_assert(offsetof(UFlashlightComponent, OnFlashlightTurnedOn) == 0x0000C0, "Member 'UFlashlightComponent::OnFlashlightTurnedOn' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, OnFlashlightTurnedOff) == 0x0000D0, "Member 'UFlashlightComponent::OnFlashlightTurnedOff' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, OnFlashlightablesUpdated) == 0x0000E0, "Member 'UFlashlightComponent::OnFlashlightablesUpdated' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _baseBlindnessDuration) == 0x0000F0, "Member 'UFlashlightComponent::_baseBlindnessDuration' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _baseAccuracy) == 0x000118, "Member 'UFlashlightComponent::_baseAccuracy' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _lagDuration) == 0x00011C, "Member 'UFlashlightComponent::_lagDuration' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _flashlightables) == 0x000120, "Member 'UFlashlightComponent::_flashlightables' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _autonomousLitFlashlightables) == 0x000170, "Member 'UFlashlightComponent::_autonomousLitFlashlightables' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _replicatedLitFlashlightables) == 0x0001C0, "Member 'UFlashlightComponent::_replicatedLitFlashlightables' has a wrong offset!");
static_assert(offsetof(UFlashlightComponent, _isOwnerLagging) == 0x0001D0, "Member 'UFlashlightComponent::_isOwnerLagging' has a wrong offset!");

// Class DBDGameplay.FlashlightConeComponent
// 0x0090 (0x0148 - 0x00B8)
class UFlashlightConeComponent final : public UActorComponent
{
public:
	struct FVector                                AIAimBeamLocationOffset;                           // 0x00B8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AIAimBeamRotationOffset;                           // 0x00C4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class USceneComponent*                        _flashlightBottom;                                 // 0x00D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _baseBeamAngle;                                    // 0x00D8(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _baseBeamLength;                                   // 0x0100(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  _cacheCollidingActor;                              // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x18];                                     // 0x0130(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetEffectiveConeHalfAngle() const;
	float GetEffectiveConeLength() const;
	float GetOcclusionDistance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightConeComponent">();
	}
	static class UFlashlightConeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightConeComponent>();
	}
};
static_assert(alignof(UFlashlightConeComponent) == 0x000008, "Wrong alignment on UFlashlightConeComponent");
static_assert(sizeof(UFlashlightConeComponent) == 0x000148, "Wrong size on UFlashlightConeComponent");
static_assert(offsetof(UFlashlightConeComponent, AIAimBeamLocationOffset) == 0x0000B8, "Member 'UFlashlightConeComponent::AIAimBeamLocationOffset' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, AIAimBeamRotationOffset) == 0x0000C4, "Member 'UFlashlightConeComponent::AIAimBeamRotationOffset' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, _flashlightBottom) == 0x0000D0, "Member 'UFlashlightConeComponent::_flashlightBottom' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, _baseBeamAngle) == 0x0000D8, "Member 'UFlashlightConeComponent::_baseBeamAngle' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, _baseBeamLength) == 0x000100, "Member 'UFlashlightConeComponent::_baseBeamLength' has a wrong offset!");
static_assert(offsetof(UFlashlightConeComponent, _cacheCollidingActor) == 0x000128, "Member 'UFlashlightConeComponent::_cacheCollidingActor' has a wrong offset!");

// Class DBDGameplay.FlashlightFXComponent
// 0x01A0 (0x0258 - 0x00B8)
class UFlashlightFXComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnFlashEvent;                                      // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USceneComponent*                        _tip;                                              // 0x00C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _centerGlowMesh;                                   // 0x00D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineMeshComponent*                   _beamMesh;                                         // 0x00D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minimumOcclusionDistanceForSpotlight;             // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _flashEffectIntensityCurve;                        // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _flashEffectDuration;                              // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _spotLightHalfAngle;                               // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _spotLightIntensity;                               // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _beamBlindingHalfAngle;                            // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _beamFlashHalfAngle;                               // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _beamBlindingRatioInterpSpeedWithTarget;           // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _beamBlindingRatioInterpSpeedWithoutTarget;        // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _resizeConeLength;                                 // 0x010C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _centerGlowWidthScaleWithoutBlindTarget;           // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _centerGlowWidthScaleWithBlindTarget;              // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _centerGlowWidthScaleDuringFlash;                  // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _centerGlowShrinkDistance;                         // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _centerGlowLengthMaxScale;                         // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAkObservedPlayerSoundLoop             _aimedAtSoundLoop;                                 // 0x0128(0x0040)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UFlashlightTargetFXComponent*           _currentBeamModifyingTarget;                       // 0x0168(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UFlashlightTargetFXComponent*>     _targets;                                          // 0x0170(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x98];                                     // 0x01C0(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCollectedEvent(class ADBDPlayer* collector);
	void OnCollectorLocallyObservedChangedEvent(bool isLocallyObserved);
	void OnDroppedEvent();
	void OnStartEvent();
	void OnStopEvent();
	void OnTurnedOff();
	void OnTurnedOn();
	void PostUpdateEvent();
	void UpdateConeEvent(float length, float halfAngle);
	void UpdateFXTargets();

	float GetBlindingSuccessRatio() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightFXComponent">();
	}
	static class UFlashlightFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightFXComponent>();
	}
};
static_assert(alignof(UFlashlightFXComponent) == 0x000008, "Wrong alignment on UFlashlightFXComponent");
static_assert(sizeof(UFlashlightFXComponent) == 0x000258, "Wrong size on UFlashlightFXComponent");
static_assert(offsetof(UFlashlightFXComponent, OnFlashEvent) == 0x0000B8, "Member 'UFlashlightFXComponent::OnFlashEvent' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _tip) == 0x0000C8, "Member 'UFlashlightFXComponent::_tip' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowMesh) == 0x0000D0, "Member 'UFlashlightFXComponent::_centerGlowMesh' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _beamMesh) == 0x0000D8, "Member 'UFlashlightFXComponent::_beamMesh' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _minimumOcclusionDistanceForSpotlight) == 0x0000E0, "Member 'UFlashlightFXComponent::_minimumOcclusionDistanceForSpotlight' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _flashEffectIntensityCurve) == 0x0000E8, "Member 'UFlashlightFXComponent::_flashEffectIntensityCurve' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _flashEffectDuration) == 0x0000F0, "Member 'UFlashlightFXComponent::_flashEffectDuration' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _spotLightHalfAngle) == 0x0000F4, "Member 'UFlashlightFXComponent::_spotLightHalfAngle' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _spotLightIntensity) == 0x0000F8, "Member 'UFlashlightFXComponent::_spotLightIntensity' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _beamBlindingHalfAngle) == 0x0000FC, "Member 'UFlashlightFXComponent::_beamBlindingHalfAngle' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _beamFlashHalfAngle) == 0x000100, "Member 'UFlashlightFXComponent::_beamFlashHalfAngle' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _beamBlindingRatioInterpSpeedWithTarget) == 0x000104, "Member 'UFlashlightFXComponent::_beamBlindingRatioInterpSpeedWithTarget' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _beamBlindingRatioInterpSpeedWithoutTarget) == 0x000108, "Member 'UFlashlightFXComponent::_beamBlindingRatioInterpSpeedWithoutTarget' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _resizeConeLength) == 0x00010C, "Member 'UFlashlightFXComponent::_resizeConeLength' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowWidthScaleWithoutBlindTarget) == 0x000110, "Member 'UFlashlightFXComponent::_centerGlowWidthScaleWithoutBlindTarget' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowWidthScaleWithBlindTarget) == 0x000114, "Member 'UFlashlightFXComponent::_centerGlowWidthScaleWithBlindTarget' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowWidthScaleDuringFlash) == 0x000118, "Member 'UFlashlightFXComponent::_centerGlowWidthScaleDuringFlash' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowShrinkDistance) == 0x00011C, "Member 'UFlashlightFXComponent::_centerGlowShrinkDistance' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _centerGlowLengthMaxScale) == 0x000120, "Member 'UFlashlightFXComponent::_centerGlowLengthMaxScale' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _aimedAtSoundLoop) == 0x000128, "Member 'UFlashlightFXComponent::_aimedAtSoundLoop' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _currentBeamModifyingTarget) == 0x000168, "Member 'UFlashlightFXComponent::_currentBeamModifyingTarget' has a wrong offset!");
static_assert(offsetof(UFlashlightFXComponent, _targets) == 0x000170, "Member 'UFlashlightFXComponent::_targets' has a wrong offset!");

// Class DBDGameplay.FlashlightUtilities
// 0x0000 (0x0030 - 0x0030)
class UFlashlightUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashlightUtilities">();
	}
	static class UFlashlightUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashlightUtilities>();
	}
};
static_assert(alignof(UFlashlightUtilities) == 0x000008, "Wrong alignment on UFlashlightUtilities");
static_assert(sizeof(UFlashlightUtilities) == 0x000030, "Wrong size on UFlashlightUtilities");

// Class DBDGameplay.FootstepManagerComponent
// 0x0328 (0x03E0 - 0x00B8)
class UFootstepManagerComponent final : public UActorComponent
{
public:
	struct FBHVRPerDetailModeInt                  _decalPoolSize;                                    // 0x00B8(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _recycleThresholdPercentage;                       // 0x0158(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _recycleDistancePercentage;                        // 0x01F8(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeInt                  _maxOverlapping;                                   // 0x0298(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _raycastHalfAngle;                                 // 0x0338(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _raycastZOffset;                                   // 0x033C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _raycastDistance;                                  // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumDecalSize;                                 // 0x0344(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maximumDecalSize;                                 // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _projectionTickness;                               // 0x034C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              _footstepsMaterial;                                // 0x0350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FFootstep>                      _currentFootSteps;                                 // 0x0358(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UDecalSpawner*                          _decalSpawner;                                     // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0x70];                                     // 0x0370(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUpdateCreatorFootsteps(class UFootstepCreatorComponent* creator);
	void OnUpdateObserverFootsteps();
	void TriggerSpawnFootstep(class UFootstepCreatorComponent* originatorComponent, const struct FVector& location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootstepManagerComponent">();
	}
	static class UFootstepManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstepManagerComponent>();
	}
};
static_assert(alignof(UFootstepManagerComponent) == 0x000008, "Wrong alignment on UFootstepManagerComponent");
static_assert(sizeof(UFootstepManagerComponent) == 0x0003E0, "Wrong size on UFootstepManagerComponent");
static_assert(offsetof(UFootstepManagerComponent, _decalPoolSize) == 0x0000B8, "Member 'UFootstepManagerComponent::_decalPoolSize' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _recycleThresholdPercentage) == 0x000158, "Member 'UFootstepManagerComponent::_recycleThresholdPercentage' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _recycleDistancePercentage) == 0x0001F8, "Member 'UFootstepManagerComponent::_recycleDistancePercentage' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _maxOverlapping) == 0x000298, "Member 'UFootstepManagerComponent::_maxOverlapping' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _raycastHalfAngle) == 0x000338, "Member 'UFootstepManagerComponent::_raycastHalfAngle' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _raycastZOffset) == 0x00033C, "Member 'UFootstepManagerComponent::_raycastZOffset' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _raycastDistance) == 0x000340, "Member 'UFootstepManagerComponent::_raycastDistance' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _minimumDecalSize) == 0x000344, "Member 'UFootstepManagerComponent::_minimumDecalSize' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _maximumDecalSize) == 0x000348, "Member 'UFootstepManagerComponent::_maximumDecalSize' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _projectionTickness) == 0x00034C, "Member 'UFootstepManagerComponent::_projectionTickness' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _footstepsMaterial) == 0x000350, "Member 'UFootstepManagerComponent::_footstepsMaterial' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _currentFootSteps) == 0x000358, "Member 'UFootstepManagerComponent::_currentFootSteps' has a wrong offset!");
static_assert(offsetof(UFootstepManagerComponent, _decalSpawner) == 0x000368, "Member 'UFootstepManagerComponent::_decalSpawner' has a wrong offset!");

// Class DBDGameplay.HooksWithSurvivorRangeTrackerStrategy
// 0x0068 (0x00D8 - 0x0070)
class UHooksWithSurvivorRangeTrackerStrategy final : public URangeToActorsTrackerStrategy
{
public:
	uint8                                         Pad_70[0x68];                                      // 0x0070(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HooksWithSurvivorRangeTrackerStrategy">();
	}
	static class UHooksWithSurvivorRangeTrackerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHooksWithSurvivorRangeTrackerStrategy>();
	}
};
static_assert(alignof(UHooksWithSurvivorRangeTrackerStrategy) == 0x000008, "Wrong alignment on UHooksWithSurvivorRangeTrackerStrategy");
static_assert(sizeof(UHooksWithSurvivorRangeTrackerStrategy) == 0x0000D8, "Wrong size on UHooksWithSurvivorRangeTrackerStrategy");

// Class DBDGameplay.InteractionStarterComponent
// 0x0018 (0x00D0 - 0x00B8)
class UInteractionStarterComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _interaction;                                      // 0x00C0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldStartInteraction;                           // 0x00C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInteractionStarted();
	void OnRep_ShouldStartInteraction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionStarterComponent">();
	}
	static class UInteractionStarterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionStarterComponent>();
	}
};
static_assert(alignof(UInteractionStarterComponent) == 0x000008, "Wrong alignment on UInteractionStarterComponent");
static_assert(sizeof(UInteractionStarterComponent) == 0x0000D0, "Wrong size on UInteractionStarterComponent");
static_assert(offsetof(UInteractionStarterComponent, _interaction) == 0x0000C0, "Member 'UInteractionStarterComponent::_interaction' has a wrong offset!");
static_assert(offsetof(UInteractionStarterComponent, _shouldStartInteraction) == 0x0000C8, "Member 'UInteractionStarterComponent::_shouldStartInteraction' has a wrong offset!");

// Class DBDGameplay.KillerFlashlightSFXComponent
// 0x00A0 (0x0158 - 0x00B8)
class UKillerFlashlightSFXComponent final : public UActorComponent
{
public:
	struct FAkObservedPlayerSoundLoop             _targetSoundLoop;                                  // 0x00B8(0x0040)(Edit, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UFlashlightTargetFXComponent*>   _flashlightTargets;                                // 0x00F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x50];                                     // 0x0108(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerFlashlightSFXComponent">();
	}
	static class UKillerFlashlightSFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerFlashlightSFXComponent>();
	}
};
static_assert(alignof(UKillerFlashlightSFXComponent) == 0x000008, "Wrong alignment on UKillerFlashlightSFXComponent");
static_assert(sizeof(UKillerFlashlightSFXComponent) == 0x000158, "Wrong size on UKillerFlashlightSFXComponent");
static_assert(offsetof(UKillerFlashlightSFXComponent, _targetSoundLoop) == 0x0000B8, "Member 'UKillerFlashlightSFXComponent::_targetSoundLoop' has a wrong offset!");
static_assert(offsetof(UKillerFlashlightSFXComponent, _flashlightTargets) == 0x0000F8, "Member 'UKillerFlashlightSFXComponent::_flashlightTargets' has a wrong offset!");

// Class DBDGameplay.KillerFootstepPerceptionComponent
// 0x0000 (0x0110 - 0x0110)
class UKillerFootstepPerceptionComponent final : public UPlayerFootstepPerceptionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerFootstepPerceptionComponent">();
	}
	static class UKillerFootstepPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerFootstepPerceptionComponent>();
	}
};
static_assert(alignof(UKillerFootstepPerceptionComponent) == 0x000008, "Wrong alignment on UKillerFootstepPerceptionComponent");
static_assert(sizeof(UKillerFootstepPerceptionComponent) == 0x000110, "Wrong size on UKillerFootstepPerceptionComponent");

// Class DBDGameplay.KillerInstinctComponent
// 0x0178 (0x0230 - 0x00B8)
class UKillerInstinctComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCustomKillerInstinctData              _defaultKillerInstinctAsset;                       // 0x00C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _particleSystemComponent;                          // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x4];                                       // 0x00F0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _camperHighlightColorOverride;                     // 0x00F4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0xAC];                                     // 0x0104(0x00AC)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCustomKillerInstinctData>      _customKillerInstinctData;                         // 0x01B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FCustomKillerInstinctData              _currentKillerInstinctData;                        // 0x01C0(0x0028)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x48];                                     // 0x01E8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UNiagaraComponent* GetParticleSystem();
	void OnKillerLocallyObservedChanged(bool locallyObserved);
	void SetParticleSystem(class UNiagaraComponent* particleSystemComponent);

	bool IsOwnerInKillerInstinctRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerInstinctComponent">();
	}
	static class UKillerInstinctComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerInstinctComponent>();
	}
};
static_assert(alignof(UKillerInstinctComponent) == 0x000008, "Wrong alignment on UKillerInstinctComponent");
static_assert(sizeof(UKillerInstinctComponent) == 0x000230, "Wrong size on UKillerInstinctComponent");
static_assert(offsetof(UKillerInstinctComponent, _defaultKillerInstinctAsset) == 0x0000C0, "Member 'UKillerInstinctComponent::_defaultKillerInstinctAsset' has a wrong offset!");
static_assert(offsetof(UKillerInstinctComponent, _particleSystemComponent) == 0x0000E8, "Member 'UKillerInstinctComponent::_particleSystemComponent' has a wrong offset!");
static_assert(offsetof(UKillerInstinctComponent, _camperHighlightColorOverride) == 0x0000F4, "Member 'UKillerInstinctComponent::_camperHighlightColorOverride' has a wrong offset!");
static_assert(offsetof(UKillerInstinctComponent, _customKillerInstinctData) == 0x0001B0, "Member 'UKillerInstinctComponent::_customKillerInstinctData' has a wrong offset!");
static_assert(offsetof(UKillerInstinctComponent, _currentKillerInstinctData) == 0x0001C0, "Member 'UKillerInstinctComponent::_currentKillerInstinctData' has a wrong offset!");

// Class DBDGameplay.LullabyFeedbackComponent
// 0x0080 (0x0138 - 0x00B8)
class ULullabyFeedbackComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLullabyKillerData>             _killersData;                                      // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x58];                                      // 0x00E0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSlasherSet(class ASlasherPlayer* killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LullabyFeedbackComponent">();
	}
	static class ULullabyFeedbackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULullabyFeedbackComponent>();
	}
};
static_assert(alignof(ULullabyFeedbackComponent) == 0x000008, "Wrong alignment on ULullabyFeedbackComponent");
static_assert(sizeof(ULullabyFeedbackComponent) == 0x000138, "Wrong size on ULullabyFeedbackComponent");
static_assert(offsetof(ULullabyFeedbackComponent, _killersData) == 0x0000D0, "Member 'ULullabyFeedbackComponent::_killersData' has a wrong offset!");

// Class DBDGameplay.MapCollectable
// 0x0000 (0x04F8 - 0x04F8)
class AMapCollectable final : public ABaseCamperCollectable
{
public:
	class UActorKnowledgeCollection* GetActorKnowledgeCollection() const;
	class UChargeableComponent* GetChargeableComponent() const;
	class UChargerComponent* GetChargerComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapCollectable">();
	}
	static class AMapCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapCollectable>();
	}
};
static_assert(alignof(AMapCollectable) == 0x000008, "Wrong alignment on AMapCollectable");
static_assert(sizeof(AMapCollectable) == 0x0004F8, "Wrong size on AMapCollectable");

// Class DBDGameplay.Medkit
// 0x0040 (0x0538 - 0x04F8)
class AMedkit final : public ABaseCamperCollectable
{
public:
	class UAkComponent*                           _akComponent;                                      // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargerComponent*                      _charger;                                          // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        _dustRingTemplate;                                 // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _medkitGetAkEvent;                                 // 0x0510(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _medkitDropAkEvent;                                // 0x0518(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioBank*                           _medkitBank;                                       // 0x0520(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _healOtherChargeMultiplier;                        // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52C[0xC];                                      // 0x052C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_ConsumeIfNotInteracting();
	void Authority_OnAnyOngoingInteractionChanged(const bool isInteracting);
	void Authority_OnChargeStateChange(const bool empty);
	void OnMedkitHealedCamper(class ADBDPlayer* healedPlayer);
	void UseCharge(float seconds);

	float GetCharge() const;
	float GetChargeMultiplier() const;
	bool HasCharge() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Medkit">();
	}
	static class AMedkit* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMedkit>();
	}
};
static_assert(alignof(AMedkit) == 0x000008, "Wrong alignment on AMedkit");
static_assert(sizeof(AMedkit) == 0x000538, "Wrong size on AMedkit");
static_assert(offsetof(AMedkit, _akComponent) == 0x0004F8, "Member 'AMedkit::_akComponent' has a wrong offset!");
static_assert(offsetof(AMedkit, _charger) == 0x000500, "Member 'AMedkit::_charger' has a wrong offset!");
static_assert(offsetof(AMedkit, _dustRingTemplate) == 0x000508, "Member 'AMedkit::_dustRingTemplate' has a wrong offset!");
static_assert(offsetof(AMedkit, _medkitGetAkEvent) == 0x000510, "Member 'AMedkit::_medkitGetAkEvent' has a wrong offset!");
static_assert(offsetof(AMedkit, _medkitDropAkEvent) == 0x000518, "Member 'AMedkit::_medkitDropAkEvent' has a wrong offset!");
static_assert(offsetof(AMedkit, _medkitBank) == 0x000520, "Member 'AMedkit::_medkitBank' has a wrong offset!");
static_assert(offsetof(AMedkit, _healOtherChargeMultiplier) == 0x000528, "Member 'AMedkit::_healOtherChargeMultiplier' has a wrong offset!");

// Class DBDGameplay.PointsProvider
// 0x0000 (0x0030 - 0x0030)
class UPointsProvider : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PointsProvider">();
	}
	static class UPointsProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPointsProvider>();
	}
};
static_assert(alignof(UPointsProvider) == 0x000008, "Wrong alignment on UPointsProvider");
static_assert(sizeof(UPointsProvider) == 0x000030, "Wrong size on UPointsProvider");

// Class DBDGameplay.MeshSocketPointsProvider
// 0x0048 (0x0078 - 0x0030)
class UMeshSocketPointsProvider final : public UPointsProvider
{
public:
	struct FComponentReference                    _meshReference;                                    // 0x0030(0x0030)(Edit, NativeAccessSpecifierPrivate)
	class UMeshComponent*                         _mesh;                                             // 0x0060(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _sockets;                                          // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshSocketPointsProvider">();
	}
	static class UMeshSocketPointsProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshSocketPointsProvider>();
	}
};
static_assert(alignof(UMeshSocketPointsProvider) == 0x000008, "Wrong alignment on UMeshSocketPointsProvider");
static_assert(sizeof(UMeshSocketPointsProvider) == 0x000078, "Wrong size on UMeshSocketPointsProvider");
static_assert(offsetof(UMeshSocketPointsProvider, _meshReference) == 0x000030, "Member 'UMeshSocketPointsProvider::_meshReference' has a wrong offset!");
static_assert(offsetof(UMeshSocketPointsProvider, _mesh) == 0x000060, "Member 'UMeshSocketPointsProvider::_mesh' has a wrong offset!");
static_assert(offsetof(UMeshSocketPointsProvider, _sockets) == 0x000068, "Member 'UMeshSocketPointsProvider::_sockets' has a wrong offset!");

// Class DBDGameplay.MoveToGroundComponent
// 0x0010 (0x00C8 - 0x00B8)
class UMoveToGroundComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MoveOwnerToGround();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveToGroundComponent">();
	}
	static class UMoveToGroundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveToGroundComponent>();
	}
};
static_assert(alignof(UMoveToGroundComponent) == 0x000008, "Wrong alignment on UMoveToGroundComponent");
static_assert(sizeof(UMoveToGroundComponent) == 0x0000C8, "Wrong size on UMoveToGroundComponent");

// Class DBDGameplay.MultiSceneComponentPointProvider
// 0x0020 (0x0050 - 0x0030)
class UMultiSceneComponentPointProvider final : public UPointsProvider
{
public:
	TArray<struct FComponentReference>            _sceneReferences;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class USceneComponent*>                _sceneComponents;                                  // 0x0040(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultiSceneComponentPointProvider">();
	}
	static class UMultiSceneComponentPointProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMultiSceneComponentPointProvider>();
	}
};
static_assert(alignof(UMultiSceneComponentPointProvider) == 0x000008, "Wrong alignment on UMultiSceneComponentPointProvider");
static_assert(sizeof(UMultiSceneComponentPointProvider) == 0x000050, "Wrong size on UMultiSceneComponentPointProvider");
static_assert(offsetof(UMultiSceneComponentPointProvider, _sceneReferences) == 0x000030, "Member 'UMultiSceneComponentPointProvider::_sceneReferences' has a wrong offset!");
static_assert(offsetof(UMultiSceneComponentPointProvider, _sceneComponents) == 0x000040, "Member 'UMultiSceneComponentPointProvider::_sceneComponents' has a wrong offset!");

// Class DBDGameplay.NearestOutsideMapBoundsLocator
// 0x0028 (0x00E0 - 0x00B8)
class UNearestOutsideMapBoundsLocator final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           _akComponent;                                      // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxDistanceFromBorderAllowed;                     // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _heightOfOOBPosition;                              // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_InitializeAkLimitPointEvent();
	void OnGameBegin();
	void OnGameEnd(EEndGameReason endGameReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NearestOutsideMapBoundsLocator">();
	}
	static class UNearestOutsideMapBoundsLocator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNearestOutsideMapBoundsLocator>();
	}
};
static_assert(alignof(UNearestOutsideMapBoundsLocator) == 0x000008, "Wrong alignment on UNearestOutsideMapBoundsLocator");
static_assert(sizeof(UNearestOutsideMapBoundsLocator) == 0x0000E0, "Wrong size on UNearestOutsideMapBoundsLocator");
static_assert(offsetof(UNearestOutsideMapBoundsLocator, _akComponent) == 0x0000C0, "Member 'UNearestOutsideMapBoundsLocator::_akComponent' has a wrong offset!");
static_assert(offsetof(UNearestOutsideMapBoundsLocator, _maxDistanceFromBorderAllowed) == 0x0000C8, "Member 'UNearestOutsideMapBoundsLocator::_maxDistanceFromBorderAllowed' has a wrong offset!");
static_assert(offsetof(UNearestOutsideMapBoundsLocator, _heightOfOOBPosition) == 0x0000CC, "Member 'UNearestOutsideMapBoundsLocator::_heightOfOOBPosition' has a wrong offset!");

// Class DBDGameplay.PlayerCameraAimDirectionProvider
// 0x0000 (0x0030 - 0x0030)
class UPlayerCameraAimDirectionProvider final : public UAimDirectionProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCameraAimDirectionProvider">();
	}
	static class UPlayerCameraAimDirectionProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCameraAimDirectionProvider>();
	}
};
static_assert(alignof(UPlayerCameraAimDirectionProvider) == 0x000008, "Wrong alignment on UPlayerCameraAimDirectionProvider");
static_assert(sizeof(UPlayerCameraAimDirectionProvider) == 0x000030, "Wrong size on UPlayerCameraAimDirectionProvider");

// Class DBDGameplay.PlayerInteractionListenerComponent
// 0x0050 (0x0108 - 0x00B8)
class UPlayerInteractionListenerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ListenToInteractionEnd(class ADBDPlayer* player, const struct FGameplayTag& interactionSemantic, const TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)>& interactionDelegate);
	void ListenToInteractionStart(class ADBDPlayer* player, const struct FGameplayTag& interactionSemantic, const TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)>& interactionDelegate);
	void OnActorDestroyed(class AActor* destroyedActor);
	void UnlistenToInteractionEnd(class ADBDPlayer* player, const struct FGameplayTag& interactionSemantic);
	void UnlistenToInteractionStart(class ADBDPlayer* player, const struct FGameplayTag& interactionSemantic);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInteractionListenerComponent">();
	}
	static class UPlayerInteractionListenerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInteractionListenerComponent>();
	}
};
static_assert(alignof(UPlayerInteractionListenerComponent) == 0x000008, "Wrong alignment on UPlayerInteractionListenerComponent");
static_assert(sizeof(UPlayerInteractionListenerComponent) == 0x000108, "Wrong size on UPlayerInteractionListenerComponent");

// Class DBDGameplay.PlayerMovementUtilities
// 0x0000 (0x0030 - 0x0030)
class UPlayerMovementUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void Local_ApplyGamepadPitchScaleMultiplier(class ADBDPlayer* player, const float multiplier, const float adjustmentTime);
	static void Local_ApplyGamepadYawScaleMultiplier(class ADBDPlayer* player, const float multiplier, const float adjustmentTime);
	static void Local_ApplyMousePitchScaleMultiplier(class ADBDPlayer* player, const float multiplier, const float adjustmentTime);
	static void Local_ApplyMouseYawScaleMultiplier(class ADBDPlayer* player, const float multiplier, const float adjustmentTime);
	static void Local_ApplyPitchScaleMultiplier(class ADBDPlayer* player, const float multiplier, const float adjustmentTime);
	static void Local_ApplyRotationScaleMultiplier(class ADBDPlayer* player, const float multiplier, const float adjustmentTime);
	static void Local_ApplyYawScaleMultiplier(class ADBDPlayer* player, const float multiplier, const float adjustmentTime);
	static void Local_ResetGamepadLookCurves(class ADBDPlayer* player);
	static void Local_ResetRotationScale(class ADBDPlayer* player, const float adjustmentTime);
	static void Local_SetGamepadPitchCurve(class ADBDPlayer* player, class UCurveFloat* curve);
	static void Local_SetGamepadYawCurve(class ADBDPlayer* player, class UCurveFloat* curve);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMovementUtilities">();
	}
	static class UPlayerMovementUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerMovementUtilities>();
	}
};
static_assert(alignof(UPlayerMovementUtilities) == 0x000008, "Wrong alignment on UPlayerMovementUtilities");
static_assert(sizeof(UPlayerMovementUtilities) == 0x000030, "Wrong size on UPlayerMovementUtilities");

// Class DBDGameplay.PowerToggleComponent
// 0x0020 (0x00D8 - 0x00B8)
class UPowerToggleComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isInPower;                                        // 0x00D0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsInPower() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerToggleComponent">();
	}
	static class UPowerToggleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerToggleComponent>();
	}
};
static_assert(alignof(UPowerToggleComponent) == 0x000008, "Wrong alignment on UPowerToggleComponent");
static_assert(sizeof(UPowerToggleComponent) == 0x0000D8, "Wrong size on UPowerToggleComponent");
static_assert(offsetof(UPowerToggleComponent, _isInPower) == 0x0000D0, "Member 'UPowerToggleComponent::_isInPower' has a wrong offset!");

// Class DBDGameplay.RangeToActorsTrackerDefaultStrategy
// 0x0008 (0x0078 - 0x0070)
class URangeToActorsTrackerDefaultStrategy final : public URangeToActorsTrackerStrategy
{
public:
	TSubclassOf<class AActor>                     _actorClass;                                       // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RangeToActorsTrackerDefaultStrategy">();
	}
	static class URangeToActorsTrackerDefaultStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URangeToActorsTrackerDefaultStrategy>();
	}
};
static_assert(alignof(URangeToActorsTrackerDefaultStrategy) == 0x000008, "Wrong alignment on URangeToActorsTrackerDefaultStrategy");
static_assert(sizeof(URangeToActorsTrackerDefaultStrategy) == 0x000078, "Wrong size on URangeToActorsTrackerDefaultStrategy");
static_assert(offsetof(URangeToActorsTrackerDefaultStrategy, _actorClass) == 0x000070, "Member 'URangeToActorsTrackerDefaultStrategy::_actorClass' has a wrong offset!");

// Class DBDGameplay.SceneComponentPointProvider
// 0x0038 (0x0068 - 0x0030)
class USceneComponentPointProvider final : public UPointsProvider
{
public:
	struct FComponentReference                    _sceneReference;                                   // 0x0030(0x0030)(Edit, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _sceneComponent;                                   // 0x0060(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneComponentPointProvider">();
	}
	static class USceneComponentPointProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneComponentPointProvider>();
	}
};
static_assert(alignof(USceneComponentPointProvider) == 0x000008, "Wrong alignment on USceneComponentPointProvider");
static_assert(sizeof(USceneComponentPointProvider) == 0x000068, "Wrong size on USceneComponentPointProvider");
static_assert(offsetof(USceneComponentPointProvider, _sceneReference) == 0x000030, "Member 'USceneComponentPointProvider::_sceneReference' has a wrong offset!");
static_assert(offsetof(USceneComponentPointProvider, _sceneComponent) == 0x000060, "Member 'USceneComponentPointProvider::_sceneComponent' has a wrong offset!");

// Class DBDGameplay.SightRevealableComponent
// 0x0218 (0x02D0 - 0x00B8)
class USightRevealableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x48];                                      // 0x00B8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _ignoredTags;                                      // 0x0100(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _revealTimeBase;                                   // 0x0120(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _revealRate;                                       // 0x01A0(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _revealRegressionRate;                             // 0x0220(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x30];                                     // 0x02A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SightRevealableComponent">();
	}
	static class USightRevealableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USightRevealableComponent>();
	}
};
static_assert(alignof(USightRevealableComponent) == 0x000008, "Wrong alignment on USightRevealableComponent");
static_assert(sizeof(USightRevealableComponent) == 0x0002D0, "Wrong size on USightRevealableComponent");
static_assert(offsetof(USightRevealableComponent, _ignoredTags) == 0x000100, "Member 'USightRevealableComponent::_ignoredTags' has a wrong offset!");
static_assert(offsetof(USightRevealableComponent, _revealTimeBase) == 0x000120, "Member 'USightRevealableComponent::_revealTimeBase' has a wrong offset!");
static_assert(offsetof(USightRevealableComponent, _revealRate) == 0x0001A0, "Member 'USightRevealableComponent::_revealRate' has a wrong offset!");
static_assert(offsetof(USightRevealableComponent, _revealRegressionRate) == 0x000220, "Member 'USightRevealableComponent::_revealRegressionRate' has a wrong offset!");

// Class DBDGameplay.TerrorRadiusEmitterComponent
// 0x00F0 (0x0310 - 0x0220)
class UTerrorRadiusEmitterComponent : public USceneComponent
{
public:
	uint8                                         Pad_218[0x30];                                     // 0x0218(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _simulatedFixedDistance;                           // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _imitatesAudioOnly;                                // 0x024C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _active;                                           // 0x024D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isFakeTerrorRadius;                               // 0x024E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_24F[0x1];                                      // 0x024F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _radius;                                           // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class UTerrorRadiusReceiverComponent>, bool> _receiversInTerrorRadiusMap;    // 0x0258(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class UTerrorRadiusReceiverComponent>, bool> _receiversPhysicallyInRadiusRangeMap; // 0x02A8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F8[0x18];                                     // 0x02F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RemoveEmitterFromList();
	void SetEmitterActive(bool active);
	void SetImitatesAudioOnly(bool imitatesAudioOnly);
	void SetIsFakeTerrorRadius(bool value);
	void SetSimulatedFixedDistance(float distance);
	void SetTerrorRadius(float radius);

	bool GetImitatesAudioOnly() const;
	bool GetIsActive() const;
	float GetRadius() const;
	float GetSimulatedFixedDistance() const;
	bool IsInTerrorRadius(class UTerrorRadiusReceiverComponent* receiver) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusEmitterComponent">();
	}
	static class UTerrorRadiusEmitterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusEmitterComponent>();
	}
};
static_assert(alignof(UTerrorRadiusEmitterComponent) == 0x000010, "Wrong alignment on UTerrorRadiusEmitterComponent");
static_assert(sizeof(UTerrorRadiusEmitterComponent) == 0x000310, "Wrong size on UTerrorRadiusEmitterComponent");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _simulatedFixedDistance) == 0x000248, "Member 'UTerrorRadiusEmitterComponent::_simulatedFixedDistance' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _imitatesAudioOnly) == 0x00024C, "Member 'UTerrorRadiusEmitterComponent::_imitatesAudioOnly' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _active) == 0x00024D, "Member 'UTerrorRadiusEmitterComponent::_active' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _isFakeTerrorRadius) == 0x00024E, "Member 'UTerrorRadiusEmitterComponent::_isFakeTerrorRadius' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _radius) == 0x000250, "Member 'UTerrorRadiusEmitterComponent::_radius' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _receiversInTerrorRadiusMap) == 0x000258, "Member 'UTerrorRadiusEmitterComponent::_receiversInTerrorRadiusMap' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusEmitterComponent, _receiversPhysicallyInRadiusRangeMap) == 0x0002A8, "Member 'UTerrorRadiusEmitterComponent::_receiversPhysicallyInRadiusRangeMap' has a wrong offset!");

// Class DBDGameplay.SlasherTerrorRadiusEmitterComponent
// 0x0090 (0x03A0 - 0x0310)
class USlasherTerrorRadiusEmitterComponent final : public UTerrorRadiusEmitterComponent
{
public:
	uint8                                         Pad_310[0x90];                                     // 0x0310(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBaseTerrorRadius(float baseTerrorRadius, const bool progressive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherTerrorRadiusEmitterComponent">();
	}
	static class USlasherTerrorRadiusEmitterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherTerrorRadiusEmitterComponent>();
	}
};
static_assert(alignof(USlasherTerrorRadiusEmitterComponent) == 0x000010, "Wrong alignment on USlasherTerrorRadiusEmitterComponent");
static_assert(sizeof(USlasherTerrorRadiusEmitterComponent) == 0x0003A0, "Wrong size on USlasherTerrorRadiusEmitterComponent");

// Class DBDGameplay.StruggleComponent
// 0x00C8 (0x0180 - 0x00B8)
class UStruggleComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x5C];                                      // 0x00B8(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _skillCheckCount;                                  // 0x0114(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x68];                                     // 0x0118(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_TryActivateSkillCheck();
	void OnSkillCheckEnd(bool hadInput, bool success, bool bonus, ESkillCheckCustomType type, class ADBDPlayer* player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StruggleComponent">();
	}
	static class UStruggleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStruggleComponent>();
	}
};
static_assert(alignof(UStruggleComponent) == 0x000008, "Wrong alignment on UStruggleComponent");
static_assert(sizeof(UStruggleComponent) == 0x000180, "Wrong size on UStruggleComponent");
static_assert(offsetof(UStruggleComponent, _skillCheckCount) == 0x000114, "Member 'UStruggleComponent::_skillCheckCount' has a wrong offset!");

// Class DBDGameplay.SurvivorAimStanceCameraDirectionProvider
// 0x0000 (0x0030 - 0x0030)
class USurvivorAimStanceCameraDirectionProvider final : public UAimDirectionProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAimStanceCameraDirectionProvider">();
	}
	static class USurvivorAimStanceCameraDirectionProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAimStanceCameraDirectionProvider>();
	}
};
static_assert(alignof(USurvivorAimStanceCameraDirectionProvider) == 0x000008, "Wrong alignment on USurvivorAimStanceCameraDirectionProvider");
static_assert(sizeof(USurvivorAimStanceCameraDirectionProvider) == 0x000030, "Wrong size on USurvivorAimStanceCameraDirectionProvider");

// Class DBDGameplay.SurvivorAimStateComponent
// 0x0060 (0x0118 - 0x00B8)
class USurvivorAimStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ACollectable*                           _aimableCollectable;                               // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x48];                                      // 0x00D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAimStateComponent">();
	}
	static class USurvivorAimStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAimStateComponent>();
	}
};
static_assert(alignof(USurvivorAimStateComponent) == 0x000008, "Wrong alignment on USurvivorAimStateComponent");
static_assert(sizeof(USurvivorAimStateComponent) == 0x000118, "Wrong size on USurvivorAimStateComponent");
static_assert(offsetof(USurvivorAimStateComponent, _aimableCollectable) == 0x0000C8, "Member 'USurvivorAimStateComponent::_aimableCollectable' has a wrong offset!");

// Class DBDGameplay.TerrorRadiusAudioFeedbackComponent
// 0x0010 (0x00C8 - 0x00B8)
class UTerrorRadiusAudioFeedbackComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusAudioFeedbackComponent">();
	}
	static class UTerrorRadiusAudioFeedbackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusAudioFeedbackComponent>();
	}
};
static_assert(alignof(UTerrorRadiusAudioFeedbackComponent) == 0x000008, "Wrong alignment on UTerrorRadiusAudioFeedbackComponent");
static_assert(sizeof(UTerrorRadiusAudioFeedbackComponent) == 0x0000C8, "Wrong size on UTerrorRadiusAudioFeedbackComponent");

// Class DBDGameplay.TerrorRadiusBPMComponent
// 0x0058 (0x0110 - 0x00B8)
class UTerrorRadiusBPMComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x58];                                      // 0x00B8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusBPMComponent">();
	}
	static class UTerrorRadiusBPMComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusBPMComponent>();
	}
};
static_assert(alignof(UTerrorRadiusBPMComponent) == 0x000008, "Wrong alignment on UTerrorRadiusBPMComponent");
static_assert(sizeof(UTerrorRadiusBPMComponent) == 0x000110, "Wrong size on UTerrorRadiusBPMComponent");

// Class DBDGameplay.TerrorRadiusEmitterFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UTerrorRadiusEmitterFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetActiveFakeTerrorRadiusEmittersCount(const class UObject* worldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusEmitterFunctionLibrary">();
	}
	static class UTerrorRadiusEmitterFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusEmitterFunctionLibrary>();
	}
};
static_assert(alignof(UTerrorRadiusEmitterFunctionLibrary) == 0x000008, "Wrong alignment on UTerrorRadiusEmitterFunctionLibrary");
static_assert(sizeof(UTerrorRadiusEmitterFunctionLibrary) == 0x000030, "Wrong size on UTerrorRadiusEmitterFunctionLibrary");

// Class DBDGameplay.TerrorRadiusReceiverComponent
// 0x0118 (0x01D0 - 0x00B8)
class UTerrorRadiusReceiverComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _trVerticalDistanceFactor;                         // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _heartbeatSmoothingInterpolationSpeed;             // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnIsInTerrorRadiusChanged;                         // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0xC8];                                     // 0x0108(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsInTerrorRadius() const;
	bool IsInTerrorRadiusRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusReceiverComponent">();
	}
	static class UTerrorRadiusReceiverComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusReceiverComponent>();
	}
};
static_assert(alignof(UTerrorRadiusReceiverComponent) == 0x000008, "Wrong alignment on UTerrorRadiusReceiverComponent");
static_assert(sizeof(UTerrorRadiusReceiverComponent) == 0x0001D0, "Wrong size on UTerrorRadiusReceiverComponent");
static_assert(offsetof(UTerrorRadiusReceiverComponent, _trVerticalDistanceFactor) == 0x0000E8, "Member 'UTerrorRadiusReceiverComponent::_trVerticalDistanceFactor' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusReceiverComponent, _heartbeatSmoothingInterpolationSpeed) == 0x0000F0, "Member 'UTerrorRadiusReceiverComponent::_heartbeatSmoothingInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusReceiverComponent, OnIsInTerrorRadiusChanged) == 0x0000F8, "Member 'UTerrorRadiusReceiverComponent::OnIsInTerrorRadiusChanged' has a wrong offset!");

// Class DBDGameplay.TerrorRadiusScreenIndicatorComponent
// 0x0020 (0x0250 - 0x0230)
class UTerrorRadiusScreenIndicatorComponent final : public UScreenIndicatorWorldMarkerComponent
{
public:
	uint8                                         Pad_230[0x20];                                     // 0x0230(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHeartStateChanged(const struct FGameplayTag& heartState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusScreenIndicatorComponent">();
	}
	static class UTerrorRadiusScreenIndicatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusScreenIndicatorComponent>();
	}
};
static_assert(alignof(UTerrorRadiusScreenIndicatorComponent) == 0x000010, "Wrong alignment on UTerrorRadiusScreenIndicatorComponent");
static_assert(sizeof(UTerrorRadiusScreenIndicatorComponent) == 0x000250, "Wrong size on UTerrorRadiusScreenIndicatorComponent");

// Class DBDGameplay.TerrorRadiusVisualFeedbackComponent
// 0x00B8 (0x0170 - 0x00B8)
class UTerrorRadiusVisualFeedbackComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const struct FGameplayTag& heartState)> OnHeartStateChanged;       // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FTerrorRadiusVisualIndicatorHeartStateRange> _heartStateRanges;                    // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _hideHeartStateTags;                               // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(float bpmIntensityPercentage)> OnHeartBeat;                        // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x78];                                      // 0x00F8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusVisualFeedbackComponent">();
	}
	static class UTerrorRadiusVisualFeedbackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusVisualFeedbackComponent>();
	}
};
static_assert(alignof(UTerrorRadiusVisualFeedbackComponent) == 0x000008, "Wrong alignment on UTerrorRadiusVisualFeedbackComponent");
static_assert(sizeof(UTerrorRadiusVisualFeedbackComponent) == 0x000170, "Wrong size on UTerrorRadiusVisualFeedbackComponent");
static_assert(offsetof(UTerrorRadiusVisualFeedbackComponent, OnHeartStateChanged) == 0x0000B8, "Member 'UTerrorRadiusVisualFeedbackComponent::OnHeartStateChanged' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusVisualFeedbackComponent, _heartStateRanges) == 0x0000C8, "Member 'UTerrorRadiusVisualFeedbackComponent::_heartStateRanges' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusVisualFeedbackComponent, _hideHeartStateTags) == 0x0000D8, "Member 'UTerrorRadiusVisualFeedbackComponent::_hideHeartStateTags' has a wrong offset!");
static_assert(offsetof(UTerrorRadiusVisualFeedbackComponent, OnHeartBeat) == 0x0000E8, "Member 'UTerrorRadiusVisualFeedbackComponent::OnHeartBeat' has a wrong offset!");

// Class DBDGameplay.TracingConeFlashlightableLightingStrategy
// 0x0008 (0x0038 - 0x0030)
class UTracingConeFlashlightableLightingStrategy final : public UFlashlightableLightingStrategy
{
public:
	int32                                         _aroundConeCircleTraceCount;                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TracingConeFlashlightableLightingStrategy">();
	}
	static class UTracingConeFlashlightableLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTracingConeFlashlightableLightingStrategy>();
	}
};
static_assert(alignof(UTracingConeFlashlightableLightingStrategy) == 0x000008, "Wrong alignment on UTracingConeFlashlightableLightingStrategy");
static_assert(sizeof(UTracingConeFlashlightableLightingStrategy) == 0x000038, "Wrong size on UTracingConeFlashlightableLightingStrategy");
static_assert(offsetof(UTracingConeFlashlightableLightingStrategy, _aroundConeCircleTraceCount) == 0x000030, "Member 'UTracingConeFlashlightableLightingStrategy::_aroundConeCircleTraceCount' has a wrong offset!");

// Class DBDGameplay.UnhookedSurvivorTrackerComponent
// 0x0030 (0x00E8 - 0x00B8)
class UUnhookedSurvivorTrackerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnhookedSurvivorTrackerComponent">();
	}
	static class UUnhookedSurvivorTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnhookedSurvivorTrackerComponent>();
	}
};
static_assert(alignof(UUnhookedSurvivorTrackerComponent) == 0x000008, "Wrong alignment on UUnhookedSurvivorTrackerComponent");
static_assert(sizeof(UUnhookedSurvivorTrackerComponent) == 0x0000E8, "Wrong size on UUnhookedSurvivorTrackerComponent");

// Class DBDGameplay.VisibleHatchRangeTrackerStrategy
// 0x0028 (0x0098 - 0x0070)
class UVisibleHatchRangeTrackerStrategy final : public URangeToActorsTrackerStrategy
{
public:
	uint8                                         Pad_70[0x28];                                      // 0x0070(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisibleHatchRangeTrackerStrategy">();
	}
	static class UVisibleHatchRangeTrackerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisibleHatchRangeTrackerStrategy>();
	}
};
static_assert(alignof(UVisibleHatchRangeTrackerStrategy) == 0x000008, "Wrong alignment on UVisibleHatchRangeTrackerStrategy");
static_assert(sizeof(UVisibleHatchRangeTrackerStrategy) == 0x000098, "Wrong size on UVisibleHatchRangeTrackerStrategy");

// Class DBDGameplay.WiggleComponent
// 0x0190 (0x0248 - 0x00B8)
class UWiggleComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnFailSkillCheckAudioEvent;                        // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnMissSkillCheckAudioEvent;                        // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class FString                                 AUDIO_EVENT_SKILL_CHECK_WARNING;                   // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AUDIO_EVENT_SKILL_CHECK_GOOD;                      // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 AUDIO_EVENT_SKILL_CHECK_GREAT;                     // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _wiggleProgress;                                   // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ASlasherPlayer>          _killerWigglingFrom;                               // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UInputComponent>         _inputComponent;                                   // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x110];                                    // 0x0128(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _wiggleInputLockTime;                              // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23C[0xC];                                      // 0x023C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AddWiggleCharge(float chargeAmount);
	void Authority_TutorialEndWiggle();
	void OnHideWiggleSkillCheck(ESkillCheckCustomType type);
	void OnKeyBindingsChanged();
	void OnLevelReadyToPlay();
	void OnPickedUpSkillCheckEnd(bool hadInput, bool success, bool bonus, ESkillCheckCustomType type, class ADBDPlayer* player);
	void OnPlayerPickedUpEnd(class ADBDPlayer* picker);
	void OnPlayerPickedUpStart(class ADBDPlayer* picker);
	void OnWiggleEnd();
	void OnWiggleInput();
	void OnWiggleSkillCheckEnd(bool hadInput, bool success, bool bonus, ESkillCheckCustomType type, class ADBDPlayer* player);
	void Server_OnWiggleEnd();

	void DBD_SetWiggleProgress(const float progressPercent) const;
	class UChargeableComponent* GetWiggleChargeable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WiggleComponent">();
	}
	static class UWiggleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWiggleComponent>();
	}
};
static_assert(alignof(UWiggleComponent) == 0x000008, "Wrong alignment on UWiggleComponent");
static_assert(sizeof(UWiggleComponent) == 0x000248, "Wrong size on UWiggleComponent");
static_assert(offsetof(UWiggleComponent, OnFailSkillCheckAudioEvent) == 0x0000C0, "Member 'UWiggleComponent::OnFailSkillCheckAudioEvent' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, OnMissSkillCheckAudioEvent) == 0x0000D0, "Member 'UWiggleComponent::OnMissSkillCheckAudioEvent' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, AUDIO_EVENT_SKILL_CHECK_WARNING) == 0x0000E0, "Member 'UWiggleComponent::AUDIO_EVENT_SKILL_CHECK_WARNING' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, AUDIO_EVENT_SKILL_CHECK_GOOD) == 0x0000F0, "Member 'UWiggleComponent::AUDIO_EVENT_SKILL_CHECK_GOOD' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, AUDIO_EVENT_SKILL_CHECK_GREAT) == 0x000100, "Member 'UWiggleComponent::AUDIO_EVENT_SKILL_CHECK_GREAT' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, _wiggleProgress) == 0x000110, "Member 'UWiggleComponent::_wiggleProgress' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, _killerWigglingFrom) == 0x000118, "Member 'UWiggleComponent::_killerWigglingFrom' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, _inputComponent) == 0x000120, "Member 'UWiggleComponent::_inputComponent' has a wrong offset!");
static_assert(offsetof(UWiggleComponent, _wiggleInputLockTime) == 0x000238, "Member 'UWiggleComponent::_wiggleInputLockTime' has a wrong offset!");

// Class DBDGameplay.WiggleFreeComponent
// 0x0030 (0x00E8 - 0x00B8)
class UWiggleFreeComponent final : public UActorComponent
{
public:
	class ASlasherPlayer*                         _killerWigglingFrom;                               // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x28];                                      // 0x00C0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnChargeableCompleteEvent(bool completed, const TArray<class AActor*>& instigatorsForCompletion);
	void Authority_OnLevelReadyToPlay();
	void Authority_OnPlayerPickedUpEnd(class ADBDPlayer* picker);
	void Authority_OnWiggleEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WiggleFreeComponent">();
	}
	static class UWiggleFreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWiggleFreeComponent>();
	}
};
static_assert(alignof(UWiggleFreeComponent) == 0x000008, "Wrong alignment on UWiggleFreeComponent");
static_assert(sizeof(UWiggleFreeComponent) == 0x0000E8, "Wrong size on UWiggleFreeComponent");
static_assert(offsetof(UWiggleFreeComponent, _killerWigglingFrom) == 0x0000B8, "Member 'UWiggleFreeComponent::_killerWigglingFrom' has a wrong offset!");

// Class DBDGameplay.WiggleMotionComponent
// 0x00A8 (0x0160 - 0x00B8)
class UWiggleMotionComponent final : public UActorComponent
{
public:
	class ADBDPlayer*                             _carriedPlayer;                                    // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDCharacterMovementComponent*         _ownerMovementComponent;                           // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x48];                                      // 0x00C8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _goodSkillCheckBumpsAmplitude;                     // 0x0110(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _greatSkillCheckBumpsAmplitude;                    // 0x0138(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnHideWiggleSkillCheck(ESkillCheckCustomType type);
	void OnSurvivorPickedUp(class ADBDPlayer* target);
	void OnSurvivorRemoved(class ADBDPlayer* target);
	void OnWiggleSkillCheckEnd(bool hadInput, bool success, bool bonus, ESkillCheckCustomType type, class ADBDPlayer* player);
	void Server_SetIsBeingWiggled(const bool isBeingWiggled);
	void SetIsBeingWiggled(const bool isBeingWiggled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WiggleMotionComponent">();
	}
	static class UWiggleMotionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWiggleMotionComponent>();
	}
};
static_assert(alignof(UWiggleMotionComponent) == 0x000008, "Wrong alignment on UWiggleMotionComponent");
static_assert(sizeof(UWiggleMotionComponent) == 0x000160, "Wrong size on UWiggleMotionComponent");
static_assert(offsetof(UWiggleMotionComponent, _carriedPlayer) == 0x0000B8, "Member 'UWiggleMotionComponent::_carriedPlayer' has a wrong offset!");
static_assert(offsetof(UWiggleMotionComponent, _ownerMovementComponent) == 0x0000C0, "Member 'UWiggleMotionComponent::_ownerMovementComponent' has a wrong offset!");
static_assert(offsetof(UWiggleMotionComponent, _goodSkillCheckBumpsAmplitude) == 0x000110, "Member 'UWiggleMotionComponent::_goodSkillCheckBumpsAmplitude' has a wrong offset!");
static_assert(offsetof(UWiggleMotionComponent, _greatSkillCheckBumpsAmplitude) == 0x000138, "Member 'UWiggleMotionComponent::_greatSkillCheckBumpsAmplitude' has a wrong offset!");

}

