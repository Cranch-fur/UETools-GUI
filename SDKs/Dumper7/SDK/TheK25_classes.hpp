#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK25

#include "Basic.hpp"

#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDBots_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DBDCompetence_classes.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "DBDAnimation_classes.hpp"
#include "Competence_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "SystemUtilities_structs.hpp"
#include "TheK25_structs.hpp"
#include "GameplayUtilities_classes.hpp"
#include "FiniteStateMachine_classes.hpp"
#include "StatSystem_structs.hpp"
#include "DBDInteraction_classes.hpp"
#include "Projectile_structs.hpp"
#include "Projectile_classes.hpp"
#include "DBDAttack_classes.hpp"
#include "DBDGameplay_structs.hpp"
#include "AnimationUtilities_structs.hpp"


namespace SDK
{

// Class TheK25.LamentConfiguration
// 0x02C0 (0x0770 - 0x04B0)
class ALamentConfiguration final : public ACollectable
{
public:
	uint8                                         Pad_4B0[0x38];                                     // 0x04B0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class USpherePlayerOverlapComponent*          _interactable;                                     // 0x04E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _collectableInteractor;                            // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK25CollectLamentConfigurationInteraction* _survivorCollectItemInteraction;                // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK25CollectLamentConfigurationInteraction* _killerCollectItemInteraction;                  // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x0508(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialHelper*                        _materialHelper;                                   // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULamentConfigurationOutlineStrategy*    _outlineStrategy;                                  // 0x0518(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULamentConfigurationSpawnStrategy*      _spawnStrategy;                                    // 0x0520(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULamentConfigurationChainHuntComponent* _chainHuntComponent;                               // 0x0528(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dotProductMinValue;                               // 0x0530(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachToSocketNameEnum                       _survivorAttachmentSocket;                         // 0x0534(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachToSocketNameEnum                       _killerAttachmentSocket;                           // 0x0535(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_536[0x2];                                      // 0x0536(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimationMontageSlave*                 _montageFollower;                                  // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AAnimationFollowerActor>    _chainAnimationActorClass;                         // 0x0548(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AK25LamentConfigurationTeleportIndicator> _lamentConfigurationTeleportIndicatorClass; // 0x0550(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _chainAnimationFollowerAttachmentSocketName;       // 0x0558(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_564[0x4];                                      // 0x0564(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAkObservedPlayerSoundLoop             _possessionSoundLoop;                              // 0x0568(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _respawnTimeAfterLamentConfigurationSolved;        // 0x05A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _respawnTimeAfterKillerPickUp;                     // 0x05D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _respawnTimeAfterSurvivorFreeBySelf;               // 0x05F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _respawnTimeAfterSurvivorFreeByAttack;             // 0x0620(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _numberChainsToLaunchUponKillerPickUpLamentConfiguration; // 0x0648(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _hostageInteractionTime;                           // 0x0670(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELamentConfigurationState                     _localLamentConfigurationState;                    // 0x0698(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELamentConfigurationState                     _lamentconfigurationState;                         // 0x0699(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_69A[0x6];                                      // 0x069A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AAnimationFollowerActor*                _chainAnimationActor;                              // 0x06A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A8[0x48];                                     // 0x06A8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          _survivorHeldHostage;                              // 0x06F0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6F8[0x58];                                     // 0x06F8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          _standingOnLamentConfigurationCollisionChecker;    // 0x0750(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timeAllowedToStandOnCubeBeforeTeleport;           // 0x0758(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _solvedLamentConfigurationDropDistanceToCollectorCentimeters; // 0x075C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _failedLamentConfigurationSolveDropDistanceToCollectorCentimeters; // 0x0760(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _solved;                                           // 0x0764(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _releasedByAttack;                                 // 0x0765(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_766[0x2];                                      // 0x0766(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AK25LamentConfigurationTeleportIndicator* _lamentConfigurationTeleportIndicator;           // 0x0768(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnEndGameOver(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Authority_OnGameEnded(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Authority_OnIntroCompletedOrLevelReadyToPlay();
	void Authority_OnOverlapBegin(class UPrimitiveComponent* overlappedComponent, class AActor* other, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult);
	void Authority_OnOverlapEnd(class UPrimitiveComponent* overlappedComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex);
	void Authority_OnSurvivorHitByControlledProjectile(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Authority_RespawnLamentConfiguration(bool triggerChainHuntUponSpawning);
	void Cosmetic_BeginSolvingCubeSFX();
	void Cosmetic_EndSolvingCubeSFX(bool hasBeenSolved);
	void Cosmetic_OnChainHuntChargeEnd();
	void Cosmetic_OnChainHuntChargeStart(float chargeTime);
	void Cosmetic_OnChainHuntEndedEffects();
	void Cosmetic_OnChainHuntStartedEffects();
	void Cosmetic_OnHoldingSurvivorHostageEnd(bool hasEndedThroughKillerAttack);
	void Cosmetic_OnHoldingSurvivorHostageStart(float hostageDuration);
	void Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration(class ASlasherPlayer* killer, class ACamperPlayer* survivorDowned);
	void Cosmetic_TriggerDisappearsSFX();
	void Cosmetic_TriggerOnSurvivorEscapedWithLamentConfigurationSFX();
	void Cosmetic_TriggerRespawnDuringChainHuntSFX();
	void Cosmetic_TriggerSolvedSFX();
	void Cosmetic_TriggerSpawnedSFX();
	void Cosmetic_TriggerSurvivorPickUpSFX();
	void Multicast_CorrectLamentConfigurationPosition(const struct FVector& newPosition);
	void Multicast_DownedSurvivorHoldingLamentConfiguration(class ACamperPlayer* survivor);
	void Multicast_TriggerKillerPickUpSFX(const TArray<class ACamperPlayer*>& affectedSurvivors);
	void Multicast_TriggerSolvedSFX();
	void OnCamperEscaped(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void OnRep_LamentConfigurationState();
	void OnRep_SurvivorHeldHostage(class ACamperPlayer* oldSurvivorHeldHostage);
	void TriggerKillerPickUpSFX(const TArray<class ACamperPlayer*>& affectedSurvivors);

	float GetChainHuntProgressPercentage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LamentConfiguration">();
	}
	static class ALamentConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALamentConfiguration>();
	}
};
static_assert(alignof(ALamentConfiguration) == 0x000008, "Wrong alignment on ALamentConfiguration");
static_assert(sizeof(ALamentConfiguration) == 0x000770, "Wrong size on ALamentConfiguration");
static_assert(offsetof(ALamentConfiguration, _interactable) == 0x0004E8, "Member 'ALamentConfiguration::_interactable' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _collectableInteractor) == 0x0004F0, "Member 'ALamentConfiguration::_collectableInteractor' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _survivorCollectItemInteraction) == 0x0004F8, "Member 'ALamentConfiguration::_survivorCollectItemInteraction' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _killerCollectItemInteraction) == 0x000500, "Member 'ALamentConfiguration::_killerCollectItemInteraction' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _outlineComponent) == 0x000508, "Member 'ALamentConfiguration::_outlineComponent' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _materialHelper) == 0x000510, "Member 'ALamentConfiguration::_materialHelper' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _outlineStrategy) == 0x000518, "Member 'ALamentConfiguration::_outlineStrategy' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _spawnStrategy) == 0x000520, "Member 'ALamentConfiguration::_spawnStrategy' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _chainHuntComponent) == 0x000528, "Member 'ALamentConfiguration::_chainHuntComponent' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _dotProductMinValue) == 0x000530, "Member 'ALamentConfiguration::_dotProductMinValue' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _survivorAttachmentSocket) == 0x000534, "Member 'ALamentConfiguration::_survivorAttachmentSocket' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _killerAttachmentSocket) == 0x000535, "Member 'ALamentConfiguration::_killerAttachmentSocket' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _montageFollower) == 0x000538, "Member 'ALamentConfiguration::_montageFollower' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _montagePlayer) == 0x000540, "Member 'ALamentConfiguration::_montagePlayer' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _chainAnimationActorClass) == 0x000548, "Member 'ALamentConfiguration::_chainAnimationActorClass' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _lamentConfigurationTeleportIndicatorClass) == 0x000550, "Member 'ALamentConfiguration::_lamentConfigurationTeleportIndicatorClass' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _chainAnimationFollowerAttachmentSocketName) == 0x000558, "Member 'ALamentConfiguration::_chainAnimationFollowerAttachmentSocketName' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _possessionSoundLoop) == 0x000568, "Member 'ALamentConfiguration::_possessionSoundLoop' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _respawnTimeAfterLamentConfigurationSolved) == 0x0005A8, "Member 'ALamentConfiguration::_respawnTimeAfterLamentConfigurationSolved' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _respawnTimeAfterKillerPickUp) == 0x0005D0, "Member 'ALamentConfiguration::_respawnTimeAfterKillerPickUp' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _respawnTimeAfterSurvivorFreeBySelf) == 0x0005F8, "Member 'ALamentConfiguration::_respawnTimeAfterSurvivorFreeBySelf' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _respawnTimeAfterSurvivorFreeByAttack) == 0x000620, "Member 'ALamentConfiguration::_respawnTimeAfterSurvivorFreeByAttack' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _numberChainsToLaunchUponKillerPickUpLamentConfiguration) == 0x000648, "Member 'ALamentConfiguration::_numberChainsToLaunchUponKillerPickUpLamentConfiguration' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _hostageInteractionTime) == 0x000670, "Member 'ALamentConfiguration::_hostageInteractionTime' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _localLamentConfigurationState) == 0x000698, "Member 'ALamentConfiguration::_localLamentConfigurationState' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _lamentconfigurationState) == 0x000699, "Member 'ALamentConfiguration::_lamentconfigurationState' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _chainAnimationActor) == 0x0006A0, "Member 'ALamentConfiguration::_chainAnimationActor' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _survivorHeldHostage) == 0x0006F0, "Member 'ALamentConfiguration::_survivorHeldHostage' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _standingOnLamentConfigurationCollisionChecker) == 0x000750, "Member 'ALamentConfiguration::_standingOnLamentConfigurationCollisionChecker' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _timeAllowedToStandOnCubeBeforeTeleport) == 0x000758, "Member 'ALamentConfiguration::_timeAllowedToStandOnCubeBeforeTeleport' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _solvedLamentConfigurationDropDistanceToCollectorCentimeters) == 0x00075C, "Member 'ALamentConfiguration::_solvedLamentConfigurationDropDistanceToCollectorCentimeters' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _failedLamentConfigurationSolveDropDistanceToCollectorCentimeters) == 0x000760, "Member 'ALamentConfiguration::_failedLamentConfigurationSolveDropDistanceToCollectorCentimeters' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _solved) == 0x000764, "Member 'ALamentConfiguration::_solved' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _releasedByAttack) == 0x000765, "Member 'ALamentConfiguration::_releasedByAttack' has a wrong offset!");
static_assert(offsetof(ALamentConfiguration, _lamentConfigurationTeleportIndicator) == 0x000768, "Member 'ALamentConfiguration::_lamentConfigurationTeleportIndicator' has a wrong offset!");

// Class TheK25.Addon_K25Power_16
// 0x0018 (0x02D0 - 0x02B8)
class UAddon_K25Power_16 final : public UItemAddon
{
public:
	uint8                                         Pad_2B8[0x18];                                     // 0x02B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K25Power_16">();
	}
	static class UAddon_K25Power_16* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K25Power_16>();
	}
};
static_assert(alignof(UAddon_K25Power_16) == 0x000008, "Wrong alignment on UAddon_K25Power_16");
static_assert(sizeof(UAddon_K25Power_16) == 0x0002D0, "Wrong size on UAddon_K25Power_16");

// Class TheK25.LamentConfigurationAnalyticsComponent
// 0x0038 (0x00F0 - 0x00B8)
class ULamentConfigurationAnalyticsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x38];                                      // 0x00B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LamentConfigurationAnalyticsComponent">();
	}
	static class ULamentConfigurationAnalyticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULamentConfigurationAnalyticsComponent>();
	}
};
static_assert(alignof(ULamentConfigurationAnalyticsComponent) == 0x000008, "Wrong alignment on ULamentConfigurationAnalyticsComponent");
static_assert(sizeof(ULamentConfigurationAnalyticsComponent) == 0x0000F0, "Wrong size on ULamentConfigurationAnalyticsComponent");

// Class TheK25.AISkill_FindCollectable_LamentConfiguration
// 0x0020 (0x0150 - 0x0130)
class UAISkill_FindCollectable_LamentConfiguration final : public UAISkill_FindCollectable
{
public:
	struct FAITunableParameter                    StopChainHuntGoalWeight;                           // 0x0130(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PreemptiveFindLamentGoalWeight;                    // 0x0140(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable_LamentConfiguration">();
	}
	static class UAISkill_FindCollectable_LamentConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable_LamentConfiguration>();
	}
};
static_assert(alignof(UAISkill_FindCollectable_LamentConfiguration) == 0x000008, "Wrong alignment on UAISkill_FindCollectable_LamentConfiguration");
static_assert(sizeof(UAISkill_FindCollectable_LamentConfiguration) == 0x000150, "Wrong size on UAISkill_FindCollectable_LamentConfiguration");
static_assert(offsetof(UAISkill_FindCollectable_LamentConfiguration, StopChainHuntGoalWeight) == 0x000130, "Member 'UAISkill_FindCollectable_LamentConfiguration::StopChainHuntGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_LamentConfiguration, PreemptiveFindLamentGoalWeight) == 0x000140, "Member 'UAISkill_FindCollectable_LamentConfiguration::PreemptiveFindLamentGoalWeight' has a wrong offset!");

// Class TheK25.AISkill_InteractionBreakFreeFromChains
// 0x0028 (0x01A8 - 0x0180)
class UAISkill_InteractionBreakFreeFromChains final : public UAISkill_Interaction
{
public:
	struct FDBDTunableRowHandle                   _breakFreeFromChainsMaxCharge;                     // 0x0180(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionBreakFreeFromChains">();
	}
	static class UAISkill_InteractionBreakFreeFromChains* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionBreakFreeFromChains>();
	}
};
static_assert(alignof(UAISkill_InteractionBreakFreeFromChains) == 0x000008, "Wrong alignment on UAISkill_InteractionBreakFreeFromChains");
static_assert(sizeof(UAISkill_InteractionBreakFreeFromChains) == 0x0001A8, "Wrong size on UAISkill_InteractionBreakFreeFromChains");
static_assert(offsetof(UAISkill_InteractionBreakFreeFromChains, _breakFreeFromChainsMaxCharge) == 0x000180, "Member 'UAISkill_InteractionBreakFreeFromChains::_breakFreeFromChainsMaxCharge' has a wrong offset!");

// Class TheK25.AISkill_InteractionUseItem_LamentConfiguration
// 0x0038 (0x01C0 - 0x0188)
class UAISkill_InteractionUseItem_LamentConfiguration final : public UAISkill_InteractionUseItem
{
public:
	struct FAITunableParameter                    SolveLamentThreshold;                              // 0x0188(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _solveLamentMaxCharge;                             // 0x0198(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_LamentConfiguration">();
	}
	static class UAISkill_InteractionUseItem_LamentConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_LamentConfiguration>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_LamentConfiguration) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_LamentConfiguration");
static_assert(sizeof(UAISkill_InteractionUseItem_LamentConfiguration) == 0x0001C0, "Wrong size on UAISkill_InteractionUseItem_LamentConfiguration");
static_assert(offsetof(UAISkill_InteractionUseItem_LamentConfiguration, SolveLamentThreshold) == 0x000188, "Member 'UAISkill_InteractionUseItem_LamentConfiguration::SolveLamentThreshold' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionUseItem_LamentConfiguration, _solveLamentMaxCharge) == 0x000198, "Member 'UAISkill_InteractionUseItem_LamentConfiguration::_solveLamentMaxCharge' has a wrong offset!");

// Class TheK25.ChainAttachedGateBlockerEffect
// 0x0028 (0x03B0 - 0x0388)
class UChainAttachedGateBlockerEffect final : public UGateBlockerEffect
{
public:
	struct FDBDTunableRowHandle                   _blockGateLingeringTimeDyingState;                 // 0x0388(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnSurvivorDamageStateChanged(const ECamperDamageState oldState, const ECamperDamageState newState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChainAttachedGateBlockerEffect">();
	}
	static class UChainAttachedGateBlockerEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChainAttachedGateBlockerEffect>();
	}
};
static_assert(alignof(UChainAttachedGateBlockerEffect) == 0x000008, "Wrong alignment on UChainAttachedGateBlockerEffect");
static_assert(sizeof(UChainAttachedGateBlockerEffect) == 0x0003B0, "Wrong size on UChainAttachedGateBlockerEffect");
static_assert(offsetof(UChainAttachedGateBlockerEffect, _blockGateLingeringTimeDyingState) == 0x000388, "Member 'UChainAttachedGateBlockerEffect::_blockGateLingeringTimeDyingState' has a wrong offset!");

// Class TheK25.IsChainHuntActive
// 0x0028 (0x0110 - 0x00E8)
class UIsChainHuntActive final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x28];                                      // 0x00E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsChainHuntActive">();
	}
	static class UIsChainHuntActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsChainHuntActive>();
	}
};
static_assert(alignof(UIsChainHuntActive) == 0x000008, "Wrong alignment on UIsChainHuntActive");
static_assert(sizeof(UIsChainHuntActive) == 0x000110, "Wrong size on UIsChainHuntActive");

// Class TheK25.K25AnimInstance
// 0x0010 (0x0610 - 0x0600)
class UK25AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isTeleporting;                                    // 0x0600(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPossessingGateway;                              // 0x0601(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSelectingGatewayLocation;                       // 0x0602(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_603[0xD];                                      // 0x0603(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25AnimInstance">();
	}
	static class UK25AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25AnimInstance>();
	}
};
static_assert(alignof(UK25AnimInstance) == 0x000010, "Wrong alignment on UK25AnimInstance");
static_assert(sizeof(UK25AnimInstance) == 0x000610, "Wrong size on UK25AnimInstance");
static_assert(offsetof(UK25AnimInstance, _isTeleporting) == 0x000600, "Member 'UK25AnimInstance::_isTeleporting' has a wrong offset!");
static_assert(offsetof(UK25AnimInstance, _isPossessingGateway) == 0x000601, "Member 'UK25AnimInstance::_isPossessingGateway' has a wrong offset!");
static_assert(offsetof(UK25AnimInstance, _isSelectingGatewayLocation) == 0x000602, "Member 'UK25AnimInstance::_isSelectingGatewayLocation' has a wrong offset!");

// Class TheK25.K25AttackSubAnimInstance
// 0x0010 (0x0630 - 0x0620)
class UK25AttackSubAnimInstance final : public UKillerAttackSubAnimInstance
{
public:
	bool                                          _hasDownedTargetHoldingLamentConfiguration;        // 0x0618(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_619[0x17];                                     // 0x0619(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttackStart(const EAttackType attackType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25AttackSubAnimInstance">();
	}
	static class UK25AttackSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25AttackSubAnimInstance>();
	}
};
static_assert(alignof(UK25AttackSubAnimInstance) == 0x000010, "Wrong alignment on UK25AttackSubAnimInstance");
static_assert(sizeof(UK25AttackSubAnimInstance) == 0x000630, "Wrong size on UK25AttackSubAnimInstance");
static_assert(offsetof(UK25AttackSubAnimInstance, _hasDownedTargetHoldingLamentConfiguration) == 0x000618, "Member 'UK25AttackSubAnimInstance::_hasDownedTargetHoldingLamentConfiguration' has a wrong offset!");

// Class TheK25.K25Chain
// 0x0200 (0x0430 - 0x0230)
class AK25Chain final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const bool acquired)> OnAcquiredChanged;                           // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _attachedToProjectileInfluenceCurve;               // 0x0248(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _reelbackInfluenceCurve;                           // 0x0250(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            _offsetMultiplierInfluenceCurve;                   // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0x50];                                     // 0x0260(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _reelingBackSpeed;                                 // 0x02B0(0x0028)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _chainOffsetMinValue;                              // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _chainOffsetMaxValue;                              // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _reelbackChainOffsetMinValue;                      // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _reelbackChainOffsetMaxValue;                      // 0x02E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _chainInstanceSpacing;                             // 0x02E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _quickChainOffsetTimerLength;                      // 0x02EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _reachingSurvivorAnchorTime;                       // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _chainScale;                                       // 0x02F4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _chainOffsetTimerLength;                           // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        _currentChainPoints;                               // 0x0308(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          _isAcquiredFromPool;                               // 0x0318(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _sphereTraceRadius;                                // 0x031C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _chainStartPosition;                               // 0x0320(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _reelBackPosition;                                 // 0x032C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _reelbackStartPosition;                            // 0x0338(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AK25Projectile*                         _projectileAttachedTo;                             // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AK25SurvivorChainAttachmentAnchor> _survivorAnchorAttachedTo;               // 0x0350(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AK25SurvivorChainAttachmentAnchor> _targetAnchorToReach;                    // 0x0358(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USplineComponent*                       _chainSplineComponent;                             // 0x0360(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          _chainInstancedMesh;                               // 0x0368(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _currentInfluenceCurve;                            // 0x0370(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _chainCurveOffset;                                 // 0x0378(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EK25ChainState                                _chainState;                                       // 0x0384(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_385[0x3];                                      // 0x0385(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFastTimer                             _curveOffsetStrengthTimer;                         // 0x0388(0x0030)(Transient, NativeAccessSpecifierPrivate)
	struct FFastTimer                             _reelbackTimer;                                    // 0x03B8(0x0030)(Transient, NativeAccessSpecifierPrivate)
	struct FFastTimer                             _reachSurvivorAnchorPositionTimer;                 // 0x03E8(0x0030)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        _forcedPositions;                                  // 0x0418(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	EK25ChainCreationStrategy                     _chainCreationStrategy;                            // 0x0428(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_429[0x7];                                      // 0x0429(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnChainAppears();
	void Cosmetic_OnChainAttachedToSurvivor(bool wasReachingSurvivorAnchorPoint);
	void Cosmetic_OnChainDetachedFromSurvivor(EK25ChainDetachmentReason detachmentReason);
	void Cosmetic_OnChainDisappears();
	void Cosmetic_OnChainStartedToReelback();
	void Cosmetic_OnChainUnleashedWithProjectile();
	void Cosmetic_OnInstantChainUnleashedTowardsAttachmentPointFX();
	void Cosmetic_OnSurvivorStartedRemovingChainSFX();
	void Cosmetic_OnSurvivorStoppedRemovingChainSFX(bool hasRemovedChainDueToInteraction);
	void SetInstancedMeshComponent(class UInstancedStaticMeshComponent* instancedMesh);
	void SetSplineComponent(class USplineComponent* component);

	struct FVector GetChainEndLocation() const;
	struct FVector GetChainStartLocation() const;
	class AK25SurvivorChainAttachmentAnchor* GetSurvivorChainAttachmentAnchor() const;
	bool IsAttachedToControlledProjectile() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25Chain">();
	}
	static class AK25Chain* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25Chain>();
	}
};
static_assert(alignof(AK25Chain) == 0x000008, "Wrong alignment on AK25Chain");
static_assert(sizeof(AK25Chain) == 0x000430, "Wrong size on AK25Chain");
static_assert(offsetof(AK25Chain, OnAcquiredChanged) == 0x000238, "Member 'AK25Chain::OnAcquiredChanged' has a wrong offset!");
static_assert(offsetof(AK25Chain, _attachedToProjectileInfluenceCurve) == 0x000248, "Member 'AK25Chain::_attachedToProjectileInfluenceCurve' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reelbackInfluenceCurve) == 0x000250, "Member 'AK25Chain::_reelbackInfluenceCurve' has a wrong offset!");
static_assert(offsetof(AK25Chain, _offsetMultiplierInfluenceCurve) == 0x000258, "Member 'AK25Chain::_offsetMultiplierInfluenceCurve' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reelingBackSpeed) == 0x0002B0, "Member 'AK25Chain::_reelingBackSpeed' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainOffsetMinValue) == 0x0002D8, "Member 'AK25Chain::_chainOffsetMinValue' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainOffsetMaxValue) == 0x0002DC, "Member 'AK25Chain::_chainOffsetMaxValue' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reelbackChainOffsetMinValue) == 0x0002E0, "Member 'AK25Chain::_reelbackChainOffsetMinValue' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reelbackChainOffsetMaxValue) == 0x0002E4, "Member 'AK25Chain::_reelbackChainOffsetMaxValue' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainInstanceSpacing) == 0x0002E8, "Member 'AK25Chain::_chainInstanceSpacing' has a wrong offset!");
static_assert(offsetof(AK25Chain, _quickChainOffsetTimerLength) == 0x0002EC, "Member 'AK25Chain::_quickChainOffsetTimerLength' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reachingSurvivorAnchorTime) == 0x0002F0, "Member 'AK25Chain::_reachingSurvivorAnchorTime' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainScale) == 0x0002F4, "Member 'AK25Chain::_chainScale' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainOffsetTimerLength) == 0x000300, "Member 'AK25Chain::_chainOffsetTimerLength' has a wrong offset!");
static_assert(offsetof(AK25Chain, _currentChainPoints) == 0x000308, "Member 'AK25Chain::_currentChainPoints' has a wrong offset!");
static_assert(offsetof(AK25Chain, _isAcquiredFromPool) == 0x000318, "Member 'AK25Chain::_isAcquiredFromPool' has a wrong offset!");
static_assert(offsetof(AK25Chain, _sphereTraceRadius) == 0x00031C, "Member 'AK25Chain::_sphereTraceRadius' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainStartPosition) == 0x000320, "Member 'AK25Chain::_chainStartPosition' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reelBackPosition) == 0x00032C, "Member 'AK25Chain::_reelBackPosition' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reelbackStartPosition) == 0x000338, "Member 'AK25Chain::_reelbackStartPosition' has a wrong offset!");
static_assert(offsetof(AK25Chain, _projectileAttachedTo) == 0x000348, "Member 'AK25Chain::_projectileAttachedTo' has a wrong offset!");
static_assert(offsetof(AK25Chain, _survivorAnchorAttachedTo) == 0x000350, "Member 'AK25Chain::_survivorAnchorAttachedTo' has a wrong offset!");
static_assert(offsetof(AK25Chain, _targetAnchorToReach) == 0x000358, "Member 'AK25Chain::_targetAnchorToReach' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainSplineComponent) == 0x000360, "Member 'AK25Chain::_chainSplineComponent' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainInstancedMesh) == 0x000368, "Member 'AK25Chain::_chainInstancedMesh' has a wrong offset!");
static_assert(offsetof(AK25Chain, _currentInfluenceCurve) == 0x000370, "Member 'AK25Chain::_currentInfluenceCurve' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainCurveOffset) == 0x000378, "Member 'AK25Chain::_chainCurveOffset' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainState) == 0x000384, "Member 'AK25Chain::_chainState' has a wrong offset!");
static_assert(offsetof(AK25Chain, _curveOffsetStrengthTimer) == 0x000388, "Member 'AK25Chain::_curveOffsetStrengthTimer' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reelbackTimer) == 0x0003B8, "Member 'AK25Chain::_reelbackTimer' has a wrong offset!");
static_assert(offsetof(AK25Chain, _reachSurvivorAnchorPositionTimer) == 0x0003E8, "Member 'AK25Chain::_reachSurvivorAnchorPositionTimer' has a wrong offset!");
static_assert(offsetof(AK25Chain, _forcedPositions) == 0x000418, "Member 'AK25Chain::_forcedPositions' has a wrong offset!");
static_assert(offsetof(AK25Chain, _chainCreationStrategy) == 0x000428, "Member 'AK25Chain::_chainCreationStrategy' has a wrong offset!");

// Class TheK25.K25ChainAttachedStatusEffect
// 0x0018 (0x0368 - 0x0350)
class UK25ChainAttachedStatusEffect final : public UStatusEffect
{
public:
	class UCurveFloat*                            _percentageReductionSpeedPerChainCurve;            // 0x0350(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK25SurvivorChainAttachmentComponent*   _chainAttachmentComponent;                         // 0x0358(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _cachedNumberOfChainsAttached;                     // 0x0360(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ChainAttachementComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainAttachedStatusEffect">();
	}
	static class UK25ChainAttachedStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainAttachedStatusEffect>();
	}
};
static_assert(alignof(UK25ChainAttachedStatusEffect) == 0x000008, "Wrong alignment on UK25ChainAttachedStatusEffect");
static_assert(sizeof(UK25ChainAttachedStatusEffect) == 0x000368, "Wrong size on UK25ChainAttachedStatusEffect");
static_assert(offsetof(UK25ChainAttachedStatusEffect, _percentageReductionSpeedPerChainCurve) == 0x000350, "Member 'UK25ChainAttachedStatusEffect::_percentageReductionSpeedPerChainCurve' has a wrong offset!");
static_assert(offsetof(UK25ChainAttachedStatusEffect, _chainAttachmentComponent) == 0x000358, "Member 'UK25ChainAttachedStatusEffect::_chainAttachmentComponent' has a wrong offset!");
static_assert(offsetof(UK25ChainAttachedStatusEffect, _cachedNumberOfChainsAttached) == 0x000360, "Member 'UK25ChainAttachedStatusEffect::_cachedNumberOfChainsAttached' has a wrong offset!");

// Class TheK25.K25ChainAttachmentReplicationComponent
// 0x0000 (0x00B8 - 0x00B8)
class UK25ChainAttachmentReplicationComponent final : public UActorComponent
{
public:
	void Multicast_AttachChainToAnchor(class UK25SurvivorChainAttachmentComponent* chainAttachementComponent, class AK25Chain* chainToAttach, class AK25SurvivorChainAttachmentAnchor* anchorPoint);
	void Multicast_DetachChains(class UK25SurvivorChainAttachmentComponent* chainAttachementComponent, const TArray<class AK25Chain*>& chainsToDetach, EK25ChainDetachmentReason detachmentReason, const TArray<class AK25Chain*>& chainsAttached);
	void Multicast_LaunchInstantHitChainTowardsSurvivor(class AK25Chain* newChainToAttach, class AK25SurvivorChainAttachmentAnchor* targetAnchor, const struct FVector& startPosition);
	void Multicast_StartChainReelback(class AK25Chain* chainToAttach);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainAttachmentReplicationComponent">();
	}
	static class UK25ChainAttachmentReplicationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainAttachmentReplicationComponent>();
	}
};
static_assert(alignof(UK25ChainAttachmentReplicationComponent) == 0x000008, "Wrong alignment on UK25ChainAttachmentReplicationComponent");
static_assert(sizeof(UK25ChainAttachmentReplicationComponent) == 0x0000B8, "Wrong size on UK25ChainAttachmentReplicationComponent");

// Class TheK25.K25ChainHuntEffectsComponent
// 0x0038 (0x00F0 - 0x00B8)
class UK25ChainHuntEffectsComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x38];                                      // 0x00B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_ActivateChainHuntEffects(const bool hasChainHuntStarted);
	void Cosmetic_DeactivateChainHuntEffects();
	void Cosmetic_TriggerChainHuntActivationSFX();

	class ADBDPlayer* GetOwningPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainHuntEffectsComponent">();
	}
	static class UK25ChainHuntEffectsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainHuntEffectsComponent>();
	}
};
static_assert(alignof(UK25ChainHuntEffectsComponent) == 0x000008, "Wrong alignment on UK25ChainHuntEffectsComponent");
static_assert(sizeof(UK25ChainHuntEffectsComponent) == 0x0000F0, "Wrong size on UK25ChainHuntEffectsComponent");

// Class TheK25.K25ChainLocomotionSurvivorAnimInstance
// 0x0180 (0x06D0 - 0x0550)
class UK25ChainLocomotionSurvivorAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasChainsAttached;                                // 0x0550(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPerformingBreakChainInteraction;                // 0x0551(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_552[0x2];                                      // 0x0552(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _forwardDirectionDotProductResult;                 // 0x0554(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lateralDirectionDotProductResult;                 // 0x0558(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55C[0x4];                                      // 0x055C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AK25Chain*                              _currentChainBeingDetached;                        // 0x0560(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FK25ChainAnchorAnimationData           _leftHandAttachmentData;                           // 0x0568(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FK25ChainAnchorAnimationData           _rightHandAttachmentData;                          // 0x0580(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FK25ChainAnchorAnimationData           _leftShoulderAttachmentData;                       // 0x0598(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FK25ChainAnchorAnimationData           _rightShoulderAttachmentData;                      // 0x05B0(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FK25ChainAnchorAnimationData           _stomachAttachmentData;                            // 0x05C8(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FK25ChainAnchorAnimationData           _backAttachmentData;                               // 0x05E0(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EK25ChainAnchorPointDirection                 _chainDirection;                                   // 0x05F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasBrokenFreeFromChain;                           // 0x05F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FA[0x2];                                      // 0x05FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _hasBrokenFreeTime;                                // 0x05FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasBeenHitByChain;                                // 0x0600(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x0601(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsCrouched;                                       // 0x0602(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMale;                                           // 0x0603(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingCarried;                                   // 0x0604(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_605[0x3];                                      // 0x0605(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _hasBeenHitByChainTime;                            // 0x0608(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _hitChainName;                                     // 0x060C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _detachedChainAnchorName;                          // 0x0618(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_624[0xAC];                                     // 0x0624(0x00AC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChainAttached(class AK25Chain* chain, class AK25SurvivorChainAttachmentAnchor* chainAttachmentAnchor);
	void OnChainDetached(class AK25Chain* chain, class AK25SurvivorChainAttachmentAnchor* chainAttachmentAnchor, EK25ChainDetachmentReason detachmentReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainLocomotionSurvivorAnimInstance">();
	}
	static class UK25ChainLocomotionSurvivorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainLocomotionSurvivorAnimInstance>();
	}
};
static_assert(alignof(UK25ChainLocomotionSurvivorAnimInstance) == 0x000010, "Wrong alignment on UK25ChainLocomotionSurvivorAnimInstance");
static_assert(sizeof(UK25ChainLocomotionSurvivorAnimInstance) == 0x0006D0, "Wrong size on UK25ChainLocomotionSurvivorAnimInstance");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _hasChainsAttached) == 0x000550, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_hasChainsAttached' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _isPerformingBreakChainInteraction) == 0x000551, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_isPerformingBreakChainInteraction' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _forwardDirectionDotProductResult) == 0x000554, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_forwardDirectionDotProductResult' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _lateralDirectionDotProductResult) == 0x000558, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_lateralDirectionDotProductResult' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _currentChainBeingDetached) == 0x000560, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_currentChainBeingDetached' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _leftHandAttachmentData) == 0x000568, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_leftHandAttachmentData' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _rightHandAttachmentData) == 0x000580, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_rightHandAttachmentData' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _leftShoulderAttachmentData) == 0x000598, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_leftShoulderAttachmentData' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _rightShoulderAttachmentData) == 0x0005B0, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_rightShoulderAttachmentData' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _stomachAttachmentData) == 0x0005C8, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_stomachAttachmentData' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _backAttachmentData) == 0x0005E0, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_backAttachmentData' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _chainDirection) == 0x0005F8, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_chainDirection' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _hasBrokenFreeFromChain) == 0x0005F9, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_hasBrokenFreeFromChain' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _hasBrokenFreeTime) == 0x0005FC, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_hasBrokenFreeTime' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _hasBeenHitByChain) == 0x000600, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_hasBeenHitByChain' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _isIdle) == 0x000601, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _IsCrouched) == 0x000602, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_IsCrouched' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _isMale) == 0x000603, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_isMale' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _isBeingCarried) == 0x000604, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_isBeingCarried' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _hasBeenHitByChainTime) == 0x000608, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_hasBeenHitByChainTime' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _hitChainName) == 0x00060C, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_hitChainName' has a wrong offset!");
static_assert(offsetof(UK25ChainLocomotionSurvivorAnimInstance, _detachedChainAnchorName) == 0x000618, "Member 'UK25ChainLocomotionSurvivorAnimInstance::_detachedChainAnchorName' has a wrong offset!");

// Class TheK25.K25ChainPool
// 0x0000 (0x00F0 - 0x00F0)
class UK25ChainPool final : public UAuthoritativeActorPoolComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainPool">();
	}
	static class UK25ChainPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainPool>();
	}
};
static_assert(alignof(UK25ChainPool) == 0x000008, "Wrong alignment on UK25ChainPool");
static_assert(sizeof(UK25ChainPool) == 0x0000F0, "Wrong size on UK25ChainPool");

// Class TheK25.K25ChainStrike_IsGatewayOrientationTimerExpired
// 0x0000 (0x0038 - 0x0038)
class UK25ChainStrike_IsGatewayOrientationTimerExpired final : public UFSM_Condition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrike_IsGatewayOrientationTimerExpired">();
	}
	static class UK25ChainStrike_IsGatewayOrientationTimerExpired* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrike_IsGatewayOrientationTimerExpired>();
	}
};
static_assert(alignof(UK25ChainStrike_IsGatewayOrientationTimerExpired) == 0x000008, "Wrong alignment on UK25ChainStrike_IsGatewayOrientationTimerExpired");
static_assert(sizeof(UK25ChainStrike_IsGatewayOrientationTimerExpired) == 0x000038, "Wrong size on UK25ChainStrike_IsGatewayOrientationTimerExpired");

// Class TheK25.K25ChainStrike_IsGatewayPlacementValidCondition
// 0x0000 (0x0038 - 0x0038)
class UK25ChainStrike_IsGatewayPlacementValidCondition final : public UFSM_Condition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrike_IsGatewayPlacementValidCondition">();
	}
	static class UK25ChainStrike_IsGatewayPlacementValidCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrike_IsGatewayPlacementValidCondition>();
	}
};
static_assert(alignof(UK25ChainStrike_IsGatewayPlacementValidCondition) == 0x000008, "Wrong alignment on UK25ChainStrike_IsGatewayPlacementValidCondition");
static_assert(sizeof(UK25ChainStrike_IsGatewayPlacementValidCondition) == 0x000038, "Wrong size on UK25ChainStrike_IsGatewayPlacementValidCondition");

// Class TheK25.K25ChainStrike_IsPlayerPressingInputCondition
// 0x0008 (0x0040 - 0x0038)
class UK25ChainStrike_IsPlayerPressingInputCondition final : public UFSM_Condition
{
public:
	EInputInteractionType                         _inputType;                                        // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrike_IsPlayerPressingInputCondition">();
	}
	static class UK25ChainStrike_IsPlayerPressingInputCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrike_IsPlayerPressingInputCondition>();
	}
};
static_assert(alignof(UK25ChainStrike_IsPlayerPressingInputCondition) == 0x000008, "Wrong alignment on UK25ChainStrike_IsPlayerPressingInputCondition");
static_assert(sizeof(UK25ChainStrike_IsPlayerPressingInputCondition) == 0x000040, "Wrong size on UK25ChainStrike_IsPlayerPressingInputCondition");
static_assert(offsetof(UK25ChainStrike_IsPlayerPressingInputCondition, _inputType) == 0x000038, "Member 'UK25ChainStrike_IsPlayerPressingInputCondition::_inputType' has a wrong offset!");

// Class TheK25.K25ChainStrikeBaseState
// 0x0050 (0x00C8 - 0x0078)
class UK25ChainStrikeBaseState : public UFSM_State
{
public:
	TSet<class FName>                             _secondaryInteractionIDs;                          // 0x0078(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	class AK25Gateway* GetK25Gateway() const;
	class AK25Power* GetK25Power() const;
	class ADBDPlayer* GetPlayerOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeBaseState">();
	}
	static class UK25ChainStrikeBaseState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeBaseState>();
	}
};
static_assert(alignof(UK25ChainStrikeBaseState) == 0x000008, "Wrong alignment on UK25ChainStrikeBaseState");
static_assert(sizeof(UK25ChainStrikeBaseState) == 0x0000C8, "Wrong size on UK25ChainStrikeBaseState");
static_assert(offsetof(UK25ChainStrikeBaseState, _secondaryInteractionIDs) == 0x000078, "Member 'UK25ChainStrikeBaseState::_secondaryInteractionIDs' has a wrong offset!");

// Class TheK25.K25ChainStrikeImmunityEffect
// 0x0028 (0x03A8 - 0x0380)
class UK25ChainStrikeImmunityEffect final : public UActivateOnEventTimedStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _chainStrikeImmunityDuration;                      // 0x0380(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeImmunityEffect">();
	}
	static class UK25ChainStrikeImmunityEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeImmunityEffect>();
	}
};
static_assert(alignof(UK25ChainStrikeImmunityEffect) == 0x000008, "Wrong alignment on UK25ChainStrikeImmunityEffect");
static_assert(sizeof(UK25ChainStrikeImmunityEffect) == 0x0003A8, "Wrong size on UK25ChainStrikeImmunityEffect");
static_assert(offsetof(UK25ChainStrikeImmunityEffect, _chainStrikeImmunityDuration) == 0x000380, "Member 'UK25ChainStrikeImmunityEffect::_chainStrikeImmunityDuration' has a wrong offset!");

// Class TheK25.K25ChainStrikeInteraction
// 0x0230 (0x0970 - 0x0740)
class UK25ChainStrikeInteraction final : public UChargeableInteractionDefinition
{
public:
	TSubclassOf<class UFiniteStateMachine>        _chainStrikeStateMachineclass;                     // 0x0740(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _repossessFadeOutTime;                             // 0x0748(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74C[0x4];                                      // 0x074C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _repossessFadeInTime;                              // 0x0750(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _gatewayPossessionFovModifierCurve;                // 0x0778(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _controlledProjectilePossessionFovModifierCurve;   // 0x0780(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _chargeTimeAfterGatewayPlacementCancelled;         // 0x0788(0x0028)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _chargeTimeAfterGatewayPossessionCancelled;        // 0x07B0(0x0028)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _chargeTimeAfterControlledChainShot;               // 0x07D8(0x0028)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _gatewayPossessionFovChangeDuration;               // 0x0800(0x0028)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _gatewayPossessionCameraPanTime;                   // 0x0828(0x0028)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _controlledProjectilePossessionCameraPanTime;      // 0x0850(0x0028)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _controlledProjectilePossessionFovTimeChangeDuration; // 0x0878(0x0028)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFiniteStateMachine*                    _stateMachine;                                     // 0x08A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _authority_shouldIncrementChargeableComponent;     // 0x08A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8A9[0x68];                                     // 0x08A9(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	EChainStrikeCameraViewTarget                  _chainStrikeCameraViewTarget;                      // 0x0911(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasHitSurvivor;                                   // 0x0912(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_913[0x5D];                                     // 0x0913(0x005D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_ResetAllVignetteValues(class ASlasherPlayer* killer);
	void Cosmetic_TriggerGatewayPossessionEffects(const float transitionTime);
	void Cosmetic_TriggerKillerRepossessionFadeInEffects(class ASlasherPlayer* killer, const bool hasHitSurvivor, const bool preventAudioTriggers);
	void Cosmetic_TriggerKillerRepossessionFadeOutEffects(class ASlasherPlayer* killer, const bool preventAudioTriggers);
	void Multicast_AddStateTagToPlayer(const struct FGameplayTag& tag);
	void Multicast_RemoveStateTagFromPlayer(const struct FGameplayTag& tag);
	void Multicast_SetFallbackEndReason(EChainStrikeEndReason chainStrikeEndReason);
	void OnRep_ChainStrikeCameraViewTarget();
	void Server_AddStateTagToPlayer(const struct FGameplayTag& tag);
	void Server_RemoveStateTagFromPlayer(const struct FGameplayTag& tag);
	void Server_SetFallbackEndReason(EChainStrikeEndReason chainStrikeEndReason);
	void Server_SetShouldIncrementChargeableComponent(bool shouldIncrement);
	void Server_UpdateCameraViewTargetForObservers(EChainStrikeCameraViewTarget newViewTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeInteraction">();
	}
	static class UK25ChainStrikeInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeInteraction>();
	}
};
static_assert(alignof(UK25ChainStrikeInteraction) == 0x000010, "Wrong alignment on UK25ChainStrikeInteraction");
static_assert(sizeof(UK25ChainStrikeInteraction) == 0x000970, "Wrong size on UK25ChainStrikeInteraction");
static_assert(offsetof(UK25ChainStrikeInteraction, _chainStrikeStateMachineclass) == 0x000740, "Member 'UK25ChainStrikeInteraction::_chainStrikeStateMachineclass' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _repossessFadeOutTime) == 0x000748, "Member 'UK25ChainStrikeInteraction::_repossessFadeOutTime' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _repossessFadeInTime) == 0x000750, "Member 'UK25ChainStrikeInteraction::_repossessFadeInTime' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _gatewayPossessionFovModifierCurve) == 0x000778, "Member 'UK25ChainStrikeInteraction::_gatewayPossessionFovModifierCurve' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _controlledProjectilePossessionFovModifierCurve) == 0x000780, "Member 'UK25ChainStrikeInteraction::_controlledProjectilePossessionFovModifierCurve' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _chargeTimeAfterGatewayPlacementCancelled) == 0x000788, "Member 'UK25ChainStrikeInteraction::_chargeTimeAfterGatewayPlacementCancelled' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _chargeTimeAfterGatewayPossessionCancelled) == 0x0007B0, "Member 'UK25ChainStrikeInteraction::_chargeTimeAfterGatewayPossessionCancelled' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _chargeTimeAfterControlledChainShot) == 0x0007D8, "Member 'UK25ChainStrikeInteraction::_chargeTimeAfterControlledChainShot' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _gatewayPossessionFovChangeDuration) == 0x000800, "Member 'UK25ChainStrikeInteraction::_gatewayPossessionFovChangeDuration' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _gatewayPossessionCameraPanTime) == 0x000828, "Member 'UK25ChainStrikeInteraction::_gatewayPossessionCameraPanTime' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _controlledProjectilePossessionCameraPanTime) == 0x000850, "Member 'UK25ChainStrikeInteraction::_controlledProjectilePossessionCameraPanTime' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _controlledProjectilePossessionFovTimeChangeDuration) == 0x000878, "Member 'UK25ChainStrikeInteraction::_controlledProjectilePossessionFovTimeChangeDuration' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _stateMachine) == 0x0008A0, "Member 'UK25ChainStrikeInteraction::_stateMachine' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _authority_shouldIncrementChargeableComponent) == 0x0008A8, "Member 'UK25ChainStrikeInteraction::_authority_shouldIncrementChargeableComponent' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _chainStrikeCameraViewTarget) == 0x000911, "Member 'UK25ChainStrikeInteraction::_chainStrikeCameraViewTarget' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeInteraction, _hasHitSurvivor) == 0x000912, "Member 'UK25ChainStrikeInteraction::_hasHitSurvivor' has a wrong offset!");

// Class TheK25.K25ChainStrikeReplicationComponent
// 0x0000 (0x00B8 - 0x00B8)
class UK25ChainStrikeReplicationComponent final : public UActorComponent
{
public:
	void Multicast_EndChainStrike(class UK25ChainStrikeInteraction* interaction, EChainStrikeEndReason endReason);
	void Server_EndChainStrike(class UK25ChainStrikeInteraction* interaction, EChainStrikeEndReason endReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeReplicationComponent">();
	}
	static class UK25ChainStrikeReplicationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeReplicationComponent>();
	}
};
static_assert(alignof(UK25ChainStrikeReplicationComponent) == 0x000008, "Wrong alignment on UK25ChainStrikeReplicationComponent");
static_assert(sizeof(UK25ChainStrikeReplicationComponent) == 0x0000B8, "Wrong size on UK25ChainStrikeReplicationComponent");

// Class TheK25.K25ChainStrikeState_EndChainStrike
// 0x0008 (0x00D0 - 0x00C8)
class UK25ChainStrikeState_EndChainStrike final : public UK25ChainStrikeBaseState
{
public:
	EChainStrikeEndReason                         _chainStrikeEndReason;                             // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeState_EndChainStrike">();
	}
	static class UK25ChainStrikeState_EndChainStrike* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeState_EndChainStrike>();
	}
};
static_assert(alignof(UK25ChainStrikeState_EndChainStrike) == 0x000008, "Wrong alignment on UK25ChainStrikeState_EndChainStrike");
static_assert(sizeof(UK25ChainStrikeState_EndChainStrike) == 0x0000D0, "Wrong size on UK25ChainStrikeState_EndChainStrike");
static_assert(offsetof(UK25ChainStrikeState_EndChainStrike, _chainStrikeEndReason) == 0x0000C8, "Member 'UK25ChainStrikeState_EndChainStrike::_chainStrikeEndReason' has a wrong offset!");

// Class TheK25.K25ChainStrikeState_GatewayPlacement
// 0x0000 (0x00C8 - 0x00C8)
class UK25ChainStrikeState_GatewayPlacement final : public UK25ChainStrikeBaseState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeState_GatewayPlacement">();
	}
	static class UK25ChainStrikeState_GatewayPlacement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeState_GatewayPlacement>();
	}
};
static_assert(alignof(UK25ChainStrikeState_GatewayPlacement) == 0x000008, "Wrong alignment on UK25ChainStrikeState_GatewayPlacement");
static_assert(sizeof(UK25ChainStrikeState_GatewayPlacement) == 0x0000C8, "Wrong size on UK25ChainStrikeState_GatewayPlacement");

// Class TheK25.K25ChainStrikeState_OutOfBodyState
// 0x0028 (0x00F0 - 0x00C8)
class UK25ChainStrikeState_OutOfBodyState final : public UK25ChainStrikeBaseState
{
public:
	struct FDBDTunableRowHandle                   _fovTimeChangeDuration;                            // 0x00C8(0x0028)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeState_OutOfBodyState">();
	}
	static class UK25ChainStrikeState_OutOfBodyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeState_OutOfBodyState>();
	}
};
static_assert(alignof(UK25ChainStrikeState_OutOfBodyState) == 0x000008, "Wrong alignment on UK25ChainStrikeState_OutOfBodyState");
static_assert(sizeof(UK25ChainStrikeState_OutOfBodyState) == 0x0000F0, "Wrong size on UK25ChainStrikeState_OutOfBodyState");
static_assert(offsetof(UK25ChainStrikeState_OutOfBodyState, _fovTimeChangeDuration) == 0x0000C8, "Member 'UK25ChainStrikeState_OutOfBodyState::_fovTimeChangeDuration' has a wrong offset!");

// Class TheK25.K25ChainStrikeState_PossessGateway
// 0x0010 (0x00D8 - 0x00C8)
class UK25ChainStrikeState_PossessGateway final : public UK25ChainStrikeBaseState
{
public:
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeState_PossessGateway">();
	}
	static class UK25ChainStrikeState_PossessGateway* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeState_PossessGateway>();
	}
};
static_assert(alignof(UK25ChainStrikeState_PossessGateway) == 0x000008, "Wrong alignment on UK25ChainStrikeState_PossessGateway");
static_assert(sizeof(UK25ChainStrikeState_PossessGateway) == 0x0000D8, "Wrong size on UK25ChainStrikeState_PossessGateway");

// Class TheK25.K25ChainStrikeState_SelectGatewayOrientation
// 0x0018 (0x00E0 - 0x00C8)
class UK25ChainStrikeState_SelectGatewayOrientation final : public UK25ChainStrikeBaseState
{
public:
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeState_SelectGatewayOrientation">();
	}
	static class UK25ChainStrikeState_SelectGatewayOrientation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeState_SelectGatewayOrientation>();
	}
};
static_assert(alignof(UK25ChainStrikeState_SelectGatewayOrientation) == 0x000008, "Wrong alignment on UK25ChainStrikeState_SelectGatewayOrientation");
static_assert(sizeof(UK25ChainStrikeState_SelectGatewayOrientation) == 0x0000E0, "Wrong size on UK25ChainStrikeState_SelectGatewayOrientation");

// Class TheK25.K25ChainStrikeState_ShootControlledProjectile
// 0x0040 (0x0108 - 0x00C8)
class UK25ChainStrikeState_ShootControlledProjectile final : public UK25ChainStrikeBaseState
{
public:
	float                                         _minimumThrottleTimeForInputServerCall;            // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _inputResetSpeed;                                  // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x38];                                      // 0x00D0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ChainStrikeState_ShootControlledProjectile">();
	}
	static class UK25ChainStrikeState_ShootControlledProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ChainStrikeState_ShootControlledProjectile>();
	}
};
static_assert(alignof(UK25ChainStrikeState_ShootControlledProjectile) == 0x000008, "Wrong alignment on UK25ChainStrikeState_ShootControlledProjectile");
static_assert(sizeof(UK25ChainStrikeState_ShootControlledProjectile) == 0x000108, "Wrong size on UK25ChainStrikeState_ShootControlledProjectile");
static_assert(offsetof(UK25ChainStrikeState_ShootControlledProjectile, _minimumThrottleTimeForInputServerCall) == 0x0000C8, "Member 'UK25ChainStrikeState_ShootControlledProjectile::_minimumThrottleTimeForInputServerCall' has a wrong offset!");
static_assert(offsetof(UK25ChainStrikeState_ShootControlledProjectile, _inputResetSpeed) == 0x0000CC, "Member 'UK25ChainStrikeState_ShootControlledProjectile::_inputResetSpeed' has a wrong offset!");

// Class TheK25.K25CheatComponent
// 0x0000 (0x00B8 - 0x00B8)
class UK25CheatComponent final : public UActorComponent
{
public:
	void DBD_K25ComeToMeLamentConfiguration();
	void DBD_K25ComeToPositionLamentConfiguration(float x, float y, float z);
	void DBD_K25ForceRemoveAllChainsOnAllSurvivors();
	void DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition(float x, float y, float z);
	void DBD_K25ForceRemoveAllChainsOnLocalSurvivor();
	void DBD_K25ForceRespawnLamentConfiguration();
	void DBD_K25RevealLamentConfigurationLocation(float timeDisplayed);
	void DBD_K25SetPowerNoCooldown(bool noCooldown);
	void DBD_K25ShowAllLamentConfigurationSpawnPoints(float timeDisplayed);
	void DBD_K25TriggerUncontrolledChainsOnAllSurvivors(const int32 numbChains);
	void DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition(float x, float y, float z, const int32 numbChains);
	void DBD_K25TriggerUncontrolledChainsOnLocalSurvivor(const int32 numbChains);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25CheatComponent">();
	}
	static class UK25CheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25CheatComponent>();
	}
};
static_assert(alignof(UK25CheatComponent) == 0x000008, "Wrong alignment on UK25CheatComponent");
static_assert(sizeof(UK25CheatComponent) == 0x0000B8, "Wrong size on UK25CheatComponent");

// Class TheK25.K25CollectLamentConfigurationInteraction
// 0x0010 (0x0650 - 0x0640)
class UK25CollectLamentConfigurationInteraction final : public UCollectItemInteraction
{
public:
	uint8                                         Pad_640[0x10];                                     // 0x0640(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25CollectLamentConfigurationInteraction">();
	}
	static class UK25CollectLamentConfigurationInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25CollectLamentConfigurationInteraction>();
	}
};
static_assert(alignof(UK25CollectLamentConfigurationInteraction) == 0x000010, "Wrong alignment on UK25CollectLamentConfigurationInteraction");
static_assert(sizeof(UK25CollectLamentConfigurationInteraction) == 0x000650, "Wrong size on UK25CollectLamentConfigurationInteraction");

// Class TheK25.K25Projectile
// 0x00F8 (0x0430 - 0x0338)
class AK25Projectile : public AKillerProjectile
{
public:
	uint8                                         Pad_338[0x48];                                     // 0x0338(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   _staticMesh;                                       // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _characterCollider;                                // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _environmentCollider;                              // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKillerProjectileDodgeComponent*        _projectileDodgeComponent;                         // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLaunchInfo                            _launchInfo;                                       // 0x03A0(0x001C)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AK25Chain*                              _attachedChain;                                    // 0x03C0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _timeIgnoreSlasherCollision;                       // 0x03C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActive;                                         // 0x03CC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3CD[0x3];                                      // 0x03CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FK25ProjectileDeactivationData         _lastDeactivationData;                             // 0x03D0(0x0020)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x40];                                     // 0x03F0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnProjectileActivated();
	void Cosmetic_OnProjectileDeactivated(const struct FK25ProjectileDeactivationData& deactivationData);
	void OnProjectileStopped(const struct FHitResult& result);
	void Server_RequestDisableProjectile(EK25ProjectileDeactivateReason deactivateReason);

	struct FVector GetChainAttachmentLocation() const;
	class UDBDProjectileMovementComponent* GetMovementComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25Projectile">();
	}
	static class AK25Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25Projectile>();
	}
};
static_assert(alignof(AK25Projectile) == 0x000008, "Wrong alignment on AK25Projectile");
static_assert(sizeof(AK25Projectile) == 0x000430, "Wrong size on AK25Projectile");
static_assert(offsetof(AK25Projectile, _staticMesh) == 0x000380, "Member 'AK25Projectile::_staticMesh' has a wrong offset!");
static_assert(offsetof(AK25Projectile, _characterCollider) == 0x000388, "Member 'AK25Projectile::_characterCollider' has a wrong offset!");
static_assert(offsetof(AK25Projectile, _environmentCollider) == 0x000390, "Member 'AK25Projectile::_environmentCollider' has a wrong offset!");
static_assert(offsetof(AK25Projectile, _projectileDodgeComponent) == 0x000398, "Member 'AK25Projectile::_projectileDodgeComponent' has a wrong offset!");
static_assert(offsetof(AK25Projectile, _launchInfo) == 0x0003A0, "Member 'AK25Projectile::_launchInfo' has a wrong offset!");
static_assert(offsetof(AK25Projectile, _attachedChain) == 0x0003C0, "Member 'AK25Projectile::_attachedChain' has a wrong offset!");
static_assert(offsetof(AK25Projectile, _timeIgnoreSlasherCollision) == 0x0003C8, "Member 'AK25Projectile::_timeIgnoreSlasherCollision' has a wrong offset!");
static_assert(offsetof(AK25Projectile, _isActive) == 0x0003CC, "Member 'AK25Projectile::_isActive' has a wrong offset!");
static_assert(offsetof(AK25Projectile, _lastDeactivationData) == 0x0003D0, "Member 'AK25Projectile::_lastDeactivationData' has a wrong offset!");

// Class TheK25.K25ControlledProjectile
// 0x0270 (0x06A0 - 0x0430)
class AK25ControlledProjectile final : public AK25Projectile
{
public:
	uint8                                         Pad_430[0x8];                                      // 0x0430(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   _killerViewProjectileStaticMesh;                   // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    _killerSpringArm;                                  // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       _killerCameraPlacement;                            // 0x0448(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pitchClampAngle;                                  // 0x0450(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_454[0x4];                                      // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _maximumYawTurnRate;                               // 0x0458(0x0080)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _maximumPitchTurnRate;                             // 0x04D8(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _cameraRollSpeedMultiplier;                        // 0x0558(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _cameraRollGoBackSpeedMultiplier;                  // 0x0580(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _cameraMaximumRollDegree;                          // 0x05A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _numbExtraChainsOnControlledProjectileHit;         // 0x05D0(0x0080)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK25ControlledProjectileMovementComponent* _controlledProjectileMovementComponent;         // 0x0650(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _currentRoll;                                      // 0x0658(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _targetRoll;                                       // 0x065C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_660[0x30];                                     // 0x0660(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantize                    _lastAppliedAngularVelocity;                       // 0x0690(0x000C)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_69C[0x4];                                      // 0x069C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnKillerPossessProjectileEffects();
	void OnRep_AngularVelocity();
	void Server_ProcessPitchInput(float deltaTime, float scaledInput);
	void Server_ProcessYawInput(float deltaTime, float scaledInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ControlledProjectile">();
	}
	static class AK25ControlledProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25ControlledProjectile>();
	}
};
static_assert(alignof(AK25ControlledProjectile) == 0x000008, "Wrong alignment on AK25ControlledProjectile");
static_assert(sizeof(AK25ControlledProjectile) == 0x0006A0, "Wrong size on AK25ControlledProjectile");
static_assert(offsetof(AK25ControlledProjectile, _killerViewProjectileStaticMesh) == 0x000438, "Member 'AK25ControlledProjectile::_killerViewProjectileStaticMesh' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _killerSpringArm) == 0x000440, "Member 'AK25ControlledProjectile::_killerSpringArm' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _killerCameraPlacement) == 0x000448, "Member 'AK25ControlledProjectile::_killerCameraPlacement' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _pitchClampAngle) == 0x000450, "Member 'AK25ControlledProjectile::_pitchClampAngle' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _maximumYawTurnRate) == 0x000458, "Member 'AK25ControlledProjectile::_maximumYawTurnRate' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _maximumPitchTurnRate) == 0x0004D8, "Member 'AK25ControlledProjectile::_maximumPitchTurnRate' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _cameraRollSpeedMultiplier) == 0x000558, "Member 'AK25ControlledProjectile::_cameraRollSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _cameraRollGoBackSpeedMultiplier) == 0x000580, "Member 'AK25ControlledProjectile::_cameraRollGoBackSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _cameraMaximumRollDegree) == 0x0005A8, "Member 'AK25ControlledProjectile::_cameraMaximumRollDegree' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _numbExtraChainsOnControlledProjectileHit) == 0x0005D0, "Member 'AK25ControlledProjectile::_numbExtraChainsOnControlledProjectileHit' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _controlledProjectileMovementComponent) == 0x000650, "Member 'AK25ControlledProjectile::_controlledProjectileMovementComponent' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _currentRoll) == 0x000658, "Member 'AK25ControlledProjectile::_currentRoll' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _targetRoll) == 0x00065C, "Member 'AK25ControlledProjectile::_targetRoll' has a wrong offset!");
static_assert(offsetof(AK25ControlledProjectile, _lastAppliedAngularVelocity) == 0x000690, "Member 'AK25ControlledProjectile::_lastAppliedAngularVelocity' has a wrong offset!");

// Class TheK25.K25ControlledProjectileMovementComponent
// 0x0140 (0x03A0 - 0x0260)
class UK25ControlledProjectileMovementComponent final : public UPhysicsBasedProjectileMovementComponent
{
public:
	struct FDBDTunableRowHandle                   _projectileBaseSpeed;                              // 0x0260(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _baseProjectileMaximumDistance;                    // 0x0288(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _projectileSpeedIncreaseTime;                      // 0x02B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _maximumTravelDistanceStat;                        // 0x02D8(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _projectileSpeedIncreaseMultiplier;                // 0x0358(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _totaldistanceTravelled;                           // 0x0360(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_364[0x3C];                                     // 0x0364(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ControlledProjectileMovementComponent">();
	}
	static class UK25ControlledProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ControlledProjectileMovementComponent>();
	}
};
static_assert(alignof(UK25ControlledProjectileMovementComponent) == 0x000010, "Wrong alignment on UK25ControlledProjectileMovementComponent");
static_assert(sizeof(UK25ControlledProjectileMovementComponent) == 0x0003A0, "Wrong size on UK25ControlledProjectileMovementComponent");
static_assert(offsetof(UK25ControlledProjectileMovementComponent, _projectileBaseSpeed) == 0x000260, "Member 'UK25ControlledProjectileMovementComponent::_projectileBaseSpeed' has a wrong offset!");
static_assert(offsetof(UK25ControlledProjectileMovementComponent, _baseProjectileMaximumDistance) == 0x000288, "Member 'UK25ControlledProjectileMovementComponent::_baseProjectileMaximumDistance' has a wrong offset!");
static_assert(offsetof(UK25ControlledProjectileMovementComponent, _projectileSpeedIncreaseTime) == 0x0002B0, "Member 'UK25ControlledProjectileMovementComponent::_projectileSpeedIncreaseTime' has a wrong offset!");
static_assert(offsetof(UK25ControlledProjectileMovementComponent, _maximumTravelDistanceStat) == 0x0002D8, "Member 'UK25ControlledProjectileMovementComponent::_maximumTravelDistanceStat' has a wrong offset!");
static_assert(offsetof(UK25ControlledProjectileMovementComponent, _projectileSpeedIncreaseMultiplier) == 0x000358, "Member 'UK25ControlledProjectileMovementComponent::_projectileSpeedIncreaseMultiplier' has a wrong offset!");
static_assert(offsetof(UK25ControlledProjectileMovementComponent, _totaldistanceTravelled) == 0x000360, "Member 'UK25ControlledProjectileMovementComponent::_totaldistanceTravelled' has a wrong offset!");

// Class TheK25.K25EscapeLamentConfigurationGrasp
// 0x0010 (0x0750 - 0x0740)
class UK25EscapeLamentConfigurationGrasp final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_740[0x10];                                     // 0x0740(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25EscapeLamentConfigurationGrasp">();
	}
	static class UK25EscapeLamentConfigurationGrasp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25EscapeLamentConfigurationGrasp>();
	}
};
static_assert(alignof(UK25EscapeLamentConfigurationGrasp) == 0x000010, "Wrong alignment on UK25EscapeLamentConfigurationGrasp");
static_assert(sizeof(UK25EscapeLamentConfigurationGrasp) == 0x000750, "Wrong size on UK25EscapeLamentConfigurationGrasp");

// Class TheK25.K25Gateway
// 0x02A0 (0x04D0 - 0x0230)
class AK25Gateway final : public AActor
{
public:
	uint8                                         Pad_230[0x20];                                     // 0x0230(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _rayCastZOffet;                                    // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rayCastLength;                                    // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 _distancePercentLocations;                         // 0x0258(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         _survivorGatewayRotationSpeed;                     // 0x0268(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minimumIndicatorVelocity;                         // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _indicatorVelocityEasingFactor;                    // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minimumTimeBeforeTargetLocationMulticast;         // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _gatewayNoiseEventTimeInterval;                    // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _gatewayNoiseEventRange;                           // 0x0284(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _minDistanceFromPlayer;                            // 0x0288(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _maxDistanceFromPlayer;                            // 0x02B0(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _gatewayPlacementSpeed;                            // 0x0330(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _pitchLevelChangeAngleThreshold;                   // 0x0358(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _pitchLevelChangeZoneThreshold;                    // 0x0380(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maximumCameraPitchOrientationAngle;               // 0x03A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _minimumCameraPitchOrientationAngle;               // 0x03D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maxGatewayPossessionDuration;                     // 0x03F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActorComponent*                        _visualComponent;                                  // 0x0420(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _targetLocation;                                   // 0x0428(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_434[0x14];                                     // 0x0434(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       _cameraPlacementComponent;                         // 0x0448(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isGatewayPossessed;                               // 0x0450(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_451[0x1B];                                     // 0x0451(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isBeingPositionned;                               // 0x046C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46D[0x1B];                                     // 0x046D(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFastTimer                             _possessionTimer;                                  // 0x0488(0x0030)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0x10];                                     // 0x04B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_SetIsGatewayPositionValid(bool isGatewayPlacementValid);
	void Cosmetic_SetKillerVisualVisibility(bool isVisible);
	void Cosmetic_TriggerGatewayPlacementCancel();
	void Cosmetic_TriggerGatewayPlacementStart();
	void Cosmetic_TriggerGatewayPlacementStop();
	void Cosmetic_TriggerGatewayPossessedEffects(const float transitionTime);
	void Cosmetic_TriggerGatewayPossessionCancel();
	void Cosmetic_TriggerGatewayUnpossessedEffects();
	void Cosmetic_TriggerInvalidGatewayPlacementSFX();
	void Multicast_SetGatewayLocation(const struct FVector& possessionLocation);
	void Multicast_SetGatewayOrientation(const struct FRotator& rotation);
	void Multicast_SetGatewayTargetLocation(const struct FVector& targetLocation, bool isValidLocation);
	void OnRep_IsBeingPositionned();
	void OnRep_IsGatewayPossessed();
	void Server_EndGatewayPossession();
	void Server_SetGatewayOrientation(const struct FRotator& rotation);
	void Server_SetGatewayTargetLocation(const struct FVector& targetLocation, bool isValidLocation);
	void Server_SetIsGatewayBeingPositionned(bool isBeingPositionned);
	void Server_StartGatewayPossession(const struct FVector& possessionLocation, const struct FRotator& gatewayRotation);

	class UCameraComponent* GetCameraComponent() const;
	bool IsGatewayPossessed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25Gateway">();
	}
	static class AK25Gateway* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25Gateway>();
	}
};
static_assert(alignof(AK25Gateway) == 0x000008, "Wrong alignment on AK25Gateway");
static_assert(sizeof(AK25Gateway) == 0x0004D0, "Wrong size on AK25Gateway");
static_assert(offsetof(AK25Gateway, _rayCastZOffet) == 0x000250, "Member 'AK25Gateway::_rayCastZOffet' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _rayCastLength) == 0x000254, "Member 'AK25Gateway::_rayCastLength' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _distancePercentLocations) == 0x000258, "Member 'AK25Gateway::_distancePercentLocations' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _survivorGatewayRotationSpeed) == 0x000268, "Member 'AK25Gateway::_survivorGatewayRotationSpeed' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _minimumIndicatorVelocity) == 0x00026C, "Member 'AK25Gateway::_minimumIndicatorVelocity' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _indicatorVelocityEasingFactor) == 0x000270, "Member 'AK25Gateway::_indicatorVelocityEasingFactor' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _minimumTimeBeforeTargetLocationMulticast) == 0x000274, "Member 'AK25Gateway::_minimumTimeBeforeTargetLocationMulticast' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _gatewayNoiseEventTimeInterval) == 0x000280, "Member 'AK25Gateway::_gatewayNoiseEventTimeInterval' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _gatewayNoiseEventRange) == 0x000284, "Member 'AK25Gateway::_gatewayNoiseEventRange' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _minDistanceFromPlayer) == 0x000288, "Member 'AK25Gateway::_minDistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _maxDistanceFromPlayer) == 0x0002B0, "Member 'AK25Gateway::_maxDistanceFromPlayer' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _gatewayPlacementSpeed) == 0x000330, "Member 'AK25Gateway::_gatewayPlacementSpeed' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _pitchLevelChangeAngleThreshold) == 0x000358, "Member 'AK25Gateway::_pitchLevelChangeAngleThreshold' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _pitchLevelChangeZoneThreshold) == 0x000380, "Member 'AK25Gateway::_pitchLevelChangeZoneThreshold' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _maximumCameraPitchOrientationAngle) == 0x0003A8, "Member 'AK25Gateway::_maximumCameraPitchOrientationAngle' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _minimumCameraPitchOrientationAngle) == 0x0003D0, "Member 'AK25Gateway::_minimumCameraPitchOrientationAngle' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _maxGatewayPossessionDuration) == 0x0003F8, "Member 'AK25Gateway::_maxGatewayPossessionDuration' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _visualComponent) == 0x000420, "Member 'AK25Gateway::_visualComponent' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _targetLocation) == 0x000428, "Member 'AK25Gateway::_targetLocation' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _cameraPlacementComponent) == 0x000448, "Member 'AK25Gateway::_cameraPlacementComponent' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _isGatewayPossessed) == 0x000450, "Member 'AK25Gateway::_isGatewayPossessed' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _isBeingPositionned) == 0x00046C, "Member 'AK25Gateway::_isBeingPositionned' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _possessionTimer) == 0x000488, "Member 'AK25Gateway::_possessionTimer' has a wrong offset!");
static_assert(offsetof(AK25Gateway, _perceptionStimuliComponent) == 0x0004C8, "Member 'AK25Gateway::_perceptionStimuliComponent' has a wrong offset!");

// Class TheK25.K25Husk
// 0x0040 (0x05A0 - 0x0560)
class AK25Husk final : public ADBDBasePlayer
{
public:
	class UCustomizedSkeletalMesh*                _customizedSkeletalMeshComponent;                  // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationMontageSlave*                 _montageFollower;                                  // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _k25CharacterOverrideID;                           // 0x0578(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_57C[0x24];                                     // 0x057C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_HideHusk();
	void Cosmetic_StartAppearing();
	void Cosmetic_StartDisappearing();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25Husk">();
	}
	static class AK25Husk* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25Husk>();
	}
};
static_assert(alignof(AK25Husk) == 0x000010, "Wrong alignment on AK25Husk");
static_assert(sizeof(AK25Husk) == 0x0005A0, "Wrong size on AK25Husk");
static_assert(offsetof(AK25Husk, _customizedSkeletalMeshComponent) == 0x000560, "Member 'AK25Husk::_customizedSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AK25Husk, _montageFollower) == 0x000568, "Member 'AK25Husk::_montageFollower' has a wrong offset!");
static_assert(offsetof(AK25Husk, _montagePlayer) == 0x000570, "Member 'AK25Husk::_montagePlayer' has a wrong offset!");
static_assert(offsetof(AK25Husk, _k25CharacterOverrideID) == 0x000578, "Member 'AK25Husk::_k25CharacterOverrideID' has a wrong offset!");

// Class TheK25.K25KillerChainHuntEffectsComponent
// 0x0000 (0x00F0 - 0x00F0)
class UK25KillerChainHuntEffectsComponent final : public UK25ChainHuntEffectsComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25KillerChainHuntEffectsComponent">();
	}
	static class UK25KillerChainHuntEffectsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25KillerChainHuntEffectsComponent>();
	}
};
static_assert(alignof(UK25KillerChainHuntEffectsComponent) == 0x000008, "Wrong alignment on UK25KillerChainHuntEffectsComponent");
static_assert(sizeof(UK25KillerChainHuntEffectsComponent) == 0x0000F0, "Wrong size on UK25KillerChainHuntEffectsComponent");

// Class TheK25.K25KillerTeleportationPositionFinderComponent
// 0x0120 (0x01D8 - 0x00B8)
class UK25KillerTeleportationPositionFinderComponent final : public UActorComponent
{
public:
	float                                         _rayCastZOffet;                                    // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rayCastLength;                                    // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _killerInRangeMinimumDistanceCheck;                // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _killerInRangeMaxRangePercentage;                  // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _deltaHeightThreshold;                             // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _minDistanceFromLamentConfiguration;               // 0x00D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maxDistanceFromLamentConfiguration;               // 0x00F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120[0x20];                                     // 0x0120(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeBetweenFailsafeChecks;                        // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_144[0x44];                                     // 0x0144(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	EK25TeleportLocationStatus                    _teleportLocationStatus;                           // 0x0188(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _bestTeleportLocation;                             // 0x018C(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AEscapeDoor*>                    _escapeDoors;                                      // 0x0198(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8[0x30];                                     // 0x01A8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25KillerTeleportationPositionFinderComponent">();
	}
	static class UK25KillerTeleportationPositionFinderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25KillerTeleportationPositionFinderComponent>();
	}
};
static_assert(alignof(UK25KillerTeleportationPositionFinderComponent) == 0x000008, "Wrong alignment on UK25KillerTeleportationPositionFinderComponent");
static_assert(sizeof(UK25KillerTeleportationPositionFinderComponent) == 0x0001D8, "Wrong size on UK25KillerTeleportationPositionFinderComponent");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _rayCastZOffet) == 0x0000B8, "Member 'UK25KillerTeleportationPositionFinderComponent::_rayCastZOffet' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _rayCastLength) == 0x0000BC, "Member 'UK25KillerTeleportationPositionFinderComponent::_rayCastLength' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _killerInRangeMinimumDistanceCheck) == 0x0000C0, "Member 'UK25KillerTeleportationPositionFinderComponent::_killerInRangeMinimumDistanceCheck' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _killerInRangeMaxRangePercentage) == 0x0000C4, "Member 'UK25KillerTeleportationPositionFinderComponent::_killerInRangeMaxRangePercentage' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _deltaHeightThreshold) == 0x0000C8, "Member 'UK25KillerTeleportationPositionFinderComponent::_deltaHeightThreshold' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _minDistanceFromLamentConfiguration) == 0x0000D0, "Member 'UK25KillerTeleportationPositionFinderComponent::_minDistanceFromLamentConfiguration' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _maxDistanceFromLamentConfiguration) == 0x0000F8, "Member 'UK25KillerTeleportationPositionFinderComponent::_maxDistanceFromLamentConfiguration' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _timeBetweenFailsafeChecks) == 0x000140, "Member 'UK25KillerTeleportationPositionFinderComponent::_timeBetweenFailsafeChecks' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _teleportLocationStatus) == 0x000188, "Member 'UK25KillerTeleportationPositionFinderComponent::_teleportLocationStatus' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _bestTeleportLocation) == 0x00018C, "Member 'UK25KillerTeleportationPositionFinderComponent::_bestTeleportLocation' has a wrong offset!");
static_assert(offsetof(UK25KillerTeleportationPositionFinderComponent, _escapeDoors) == 0x000198, "Member 'UK25KillerTeleportationPositionFinderComponent::_escapeDoors' has a wrong offset!");

// Class TheK25.K25LamentConfigurationPossessionChainAttacksEffect
// 0x0090 (0x03E0 - 0x0350)
class UK25LamentConfigurationPossessionChainAttacksEffect final : public UStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _timeBetweenChainTargettingAttempt;                // 0x0350(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _numberOfChainsToTriggerTowardsSurvivor;           // 0x0378(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x40];                                     // 0x03A0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25LamentConfigurationPossessionChainAttacksEffect">();
	}
	static class UK25LamentConfigurationPossessionChainAttacksEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25LamentConfigurationPossessionChainAttacksEffect>();
	}
};
static_assert(alignof(UK25LamentConfigurationPossessionChainAttacksEffect) == 0x000008, "Wrong alignment on UK25LamentConfigurationPossessionChainAttacksEffect");
static_assert(sizeof(UK25LamentConfigurationPossessionChainAttacksEffect) == 0x0003E0, "Wrong size on UK25LamentConfigurationPossessionChainAttacksEffect");
static_assert(offsetof(UK25LamentConfigurationPossessionChainAttacksEffect, _timeBetweenChainTargettingAttempt) == 0x000350, "Member 'UK25LamentConfigurationPossessionChainAttacksEffect::_timeBetweenChainTargettingAttempt' has a wrong offset!");
static_assert(offsetof(UK25LamentConfigurationPossessionChainAttacksEffect, _numberOfChainsToTriggerTowardsSurvivor) == 0x000378, "Member 'UK25LamentConfigurationPossessionChainAttacksEffect::_numberOfChainsToTriggerTowardsSurvivor' has a wrong offset!");

// Class TheK25.K25LamentConfigurationPossessionStatusEffect
// 0x0000 (0x0360 - 0x0360)
class UK25LamentConfigurationPossessionStatusEffect final : public UObliviousEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25LamentConfigurationPossessionStatusEffect">();
	}
	static class UK25LamentConfigurationPossessionStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25LamentConfigurationPossessionStatusEffect>();
	}
};
static_assert(alignof(UK25LamentConfigurationPossessionStatusEffect) == 0x000008, "Wrong alignment on UK25LamentConfigurationPossessionStatusEffect");
static_assert(sizeof(UK25LamentConfigurationPossessionStatusEffect) == 0x000360, "Wrong size on UK25LamentConfigurationPossessionStatusEffect");

// Class TheK25.K25LamentConfigurationTeleportIndicator
// 0x0008 (0x0238 - 0x0230)
class AK25LamentConfigurationTeleportIndicator final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_UpdateIndicatorVisibility(bool isVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25LamentConfigurationTeleportIndicator">();
	}
	static class AK25LamentConfigurationTeleportIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25LamentConfigurationTeleportIndicator>();
	}
};
static_assert(alignof(AK25LamentConfigurationTeleportIndicator) == 0x000008, "Wrong alignment on AK25LamentConfigurationTeleportIndicator");
static_assert(sizeof(AK25LamentConfigurationTeleportIndicator) == 0x000238, "Wrong size on AK25LamentConfigurationTeleportIndicator");

// Class TheK25.K25P01
// 0x0060 (0x0428 - 0x03C8)
class UK25P01 final : public UPerk
{
public:
	float                                         _generatorBlockDuration[0x3];                      // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _auraRevealDuration[0x3];                          // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _allowPerkToBlockZeroProgressionGenerators;        // 0x03E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _generatorAuraColorForKiller;                      // 0x03E4(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFastTimer>                     _generatorBlockingTimers;                          // 0x03F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AGenerator*>                     _generatorsBlocked;                                // 0x0408(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class AGenerator*>                     _local_generatorsBlocked;                          // 0x0418(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Authority_OnBlockTimerDone(class AGenerator* generator);
	void OnRep_GeneratorsBlocked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25P01">();
	}
	static class UK25P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25P01>();
	}
};
static_assert(alignof(UK25P01) == 0x000008, "Wrong alignment on UK25P01");
static_assert(sizeof(UK25P01) == 0x000428, "Wrong size on UK25P01");
static_assert(offsetof(UK25P01, _generatorBlockDuration) == 0x0003C8, "Member 'UK25P01::_generatorBlockDuration' has a wrong offset!");
static_assert(offsetof(UK25P01, _auraRevealDuration) == 0x0003D4, "Member 'UK25P01::_auraRevealDuration' has a wrong offset!");
static_assert(offsetof(UK25P01, _allowPerkToBlockZeroProgressionGenerators) == 0x0003E0, "Member 'UK25P01::_allowPerkToBlockZeroProgressionGenerators' has a wrong offset!");
static_assert(offsetof(UK25P01, _generatorAuraColorForKiller) == 0x0003E4, "Member 'UK25P01::_generatorAuraColorForKiller' has a wrong offset!");
static_assert(offsetof(UK25P01, _generatorBlockingTimers) == 0x0003F8, "Member 'UK25P01::_generatorBlockingTimers' has a wrong offset!");
static_assert(offsetof(UK25P01, _generatorsBlocked) == 0x000408, "Member 'UK25P01::_generatorsBlocked' has a wrong offset!");
static_assert(offsetof(UK25P01, _local_generatorsBlocked) == 0x000418, "Member 'UK25P01::_local_generatorsBlocked' has a wrong offset!");

// Class TheK25.K25P02
// 0x0080 (0x04C8 - 0x0448)
class UK25P02 final : public UHexPerk
{
public:
	float                                         _totemAuraRevealRadius[0x3];                       // 0x0448(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _totemBlockerHasLifetime;                          // 0x0454(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_455[0x3];                                      // 0x0455(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _totemBlockerDuration[0x3];                        // 0x0458(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_464[0x4];                                      // 0x0464(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _obliviousStatusEffectClass;                       // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDBDPlayerTotemPair>            _cursedSurvivors;                                  // 0x0478(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_488[0x10];                                     // 0x0488(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _hookedSurvivors;                                  // 0x0498(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ATotem*>                         _previouslyBoundTotems;                            // 0x04A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FDBDPlayerTotemPair                    _lastPlayerTotemPair;                              // 0x04B8(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void OnRep_CursedSurvivors();

	float GetTotemAuraRevealRadius() const;
	float GetTotemBlockerDuration() const;
	bool GetTotemBlockerHasLifetime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25P02">();
	}
	static class UK25P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25P02>();
	}
};
static_assert(alignof(UK25P02) == 0x000008, "Wrong alignment on UK25P02");
static_assert(sizeof(UK25P02) == 0x0004C8, "Wrong size on UK25P02");
static_assert(offsetof(UK25P02, _totemAuraRevealRadius) == 0x000448, "Member 'UK25P02::_totemAuraRevealRadius' has a wrong offset!");
static_assert(offsetof(UK25P02, _totemBlockerHasLifetime) == 0x000454, "Member 'UK25P02::_totemBlockerHasLifetime' has a wrong offset!");
static_assert(offsetof(UK25P02, _totemBlockerDuration) == 0x000458, "Member 'UK25P02::_totemBlockerDuration' has a wrong offset!");
static_assert(offsetof(UK25P02, _obliviousStatusEffectClass) == 0x000468, "Member 'UK25P02::_obliviousStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK25P02, _cursedSurvivors) == 0x000478, "Member 'UK25P02::_cursedSurvivors' has a wrong offset!");
static_assert(offsetof(UK25P02, _hookedSurvivors) == 0x000498, "Member 'UK25P02::_hookedSurvivors' has a wrong offset!");
static_assert(offsetof(UK25P02, _previouslyBoundTotems) == 0x0004A8, "Member 'UK25P02::_previouslyBoundTotems' has a wrong offset!");
static_assert(offsetof(UK25P02, _lastPlayerTotemPair) == 0x0004B8, "Member 'UK25P02::_lastPlayerTotemPair' has a wrong offset!");

// Class TheK25.K25P03
// 0x0038 (0x0400 - 0x03C8)
class UK25P03 final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _hemorrhageEffect;                                 // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _mangledEffect;                                    // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _K25P03SurvivorStateTwoEffect;                     // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _numberOfSurvivorsWaitingForDamageStateChange;     // 0x03E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _state2ActionSpeedDebuffPercentage[0x3];           // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCamperUnhookedFromScourgeHook(const struct FGameEventData& gameEventData);
	void OnDamageStateChanged(const struct FGameplayTag& gameplayTag, const struct FGameEventData& gameEventData);
	void OnSurvivorRemoved(class ACamperPlayer* survivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25P03">();
	}
	static class UK25P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25P03>();
	}
};
static_assert(alignof(UK25P03) == 0x000008, "Wrong alignment on UK25P03");
static_assert(sizeof(UK25P03) == 0x000400, "Wrong size on UK25P03");
static_assert(offsetof(UK25P03, _hemorrhageEffect) == 0x0003C8, "Member 'UK25P03::_hemorrhageEffect' has a wrong offset!");
static_assert(offsetof(UK25P03, _mangledEffect) == 0x0003D0, "Member 'UK25P03::_mangledEffect' has a wrong offset!");
static_assert(offsetof(UK25P03, _K25P03SurvivorStateTwoEffect) == 0x0003D8, "Member 'UK25P03::_K25P03SurvivorStateTwoEffect' has a wrong offset!");
static_assert(offsetof(UK25P03, _numberOfSurvivorsWaitingForDamageStateChange) == 0x0003E8, "Member 'UK25P03::_numberOfSurvivorsWaitingForDamageStateChange' has a wrong offset!");
static_assert(offsetof(UK25P03, _state2ActionSpeedDebuffPercentage) == 0x0003EC, "Member 'UK25P03::_state2ActionSpeedDebuffPercentage' has a wrong offset!");

// Class TheK25.K25PounceAttack
// 0x0020 (0x03A0 - 0x0380)
class UK25PounceAttack final : public UPounceAttack
{
public:
	uint8                                         Pad_380[0x20];                                     // 0x0380(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_InvalidateDownedTargetHoldingLamentConfiguration();
	void Multicast_DownedTargetHoldingLamentConfiguration();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25PounceAttack">();
	}
	static class UK25PounceAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25PounceAttack>();
	}
};
static_assert(alignof(UK25PounceAttack) == 0x000010, "Wrong alignment on UK25PounceAttack");
static_assert(sizeof(UK25PounceAttack) == 0x0003A0, "Wrong size on UK25PounceAttack");

// Class TheK25.K25PounceAttackHittingSubstate
// 0x0000 (0x01A0 - 0x01A0)
class UK25PounceAttackHittingSubstate final : public UPounceAttackHittingSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25PounceAttackHittingSubstate">();
	}
	static class UK25PounceAttackHittingSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25PounceAttackHittingSubstate>();
	}
};
static_assert(alignof(UK25PounceAttackHittingSubstate) == 0x000008, "Wrong alignment on UK25PounceAttackHittingSubstate");
static_assert(sizeof(UK25PounceAttackHittingSubstate) == 0x0001A0, "Wrong size on UK25PounceAttackHittingSubstate");

// Class TheK25.K25Power
// 0x0158 (0x0608 - 0x04B0)
class AK25Power final : public ACollectable
{
public:
	uint8                                         Pad_4B0[0x18];                                     // 0x04B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _k25ChainStrikeInteractionChargeableComponent;     // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _k25TeleportChargeableComponent;                   // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCustomKillerInstinctData>      _customKillerInstinctDatas;                        // 0x04D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           _survivorStatusEffectID;                           // 0x04E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           _killerStatusEffectID;                             // 0x04F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UK25SurvivorChainAttachmentComponent> _survivorChainAttachmentComponentClass;  // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK25SurvivorChainTargetterComponent> _survivorChainTargetterComponentClass;    // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AK25Gateway>                _k25GatewayClass;                                  // 0x0518(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AK25ControlledProjectile>   _controlledProjectileClass;                        // 0x0520(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ALamentConfiguration>       _lamentConfigurationClass;                         // 0x0528(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AK25Husk>                   _k25HuskClass;                                     // 0x0530(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK25KillerTeleportationPositionFinderComponent> _killerTeleportFinderComponentClass; // 0x0538(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AAnimationFollowerActor>    _chainAnimationActorClass;                         // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UDataTable*>                     _chainAnimationMappingsTables;                     // 0x0548(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AAnimationFollowerActor>    _pillarAnimationActorClass;                        // 0x0558(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK25ProjectileLauncher*                 _k25ProjectileLauncher;                            // 0x0560(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAuthoritativeActorPoolComponent*       _k25ProjectilePool;                                // 0x0568(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAuthoritativeActorPoolComponent*       _k25ChainPool;                                     // 0x0570(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPowerChargeComponent*                  _k25PowerChargeComponent;                          // 0x0578(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAuthoritativePoolProjectileProviderAdapter* _k25ProjectileProvider;                       // 0x0580(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK25PowerChargePresentationItemProgressComponent* _k25PowerPresentationItemProgressComponent; // 0x0588(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK25Gateway*                            _gateway;                                          // 0x0590(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK25ControlledProjectile*               _controlledProjectileInstance;                     // 0x0598(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALamentConfiguration*                   _lamentConfiguration;                              // 0x05A0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK25Husk*                               _k25Husk;                                          // 0x05A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK25ChainAttachmentReplicationComponent* _chainAttachmentReplicationComponent;             // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x48];                                     // 0x05B8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isPowerCharged;                                   // 0x0600(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_601[0x7];                                      // 0x0601(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnKillerInterruptOpenHatchSFX(class ASlasherPlayer* killer);
	void Cosmetic_OnKillerInterruptSFX(class ASlasherPlayer* killer);
	void OnKillerAdded(class ASlasherPlayer* killer);
	void OnRep_K25ControlledProjectile();
	void OnRep_K25Gateway();
	void OnRep_LamentConfiguration();
	void OnSurvivorAdded(class ACamperPlayer* survivor, class ASlasherPlayer* killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25Power">();
	}
	static class AK25Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25Power>();
	}
};
static_assert(alignof(AK25Power) == 0x000008, "Wrong alignment on AK25Power");
static_assert(sizeof(AK25Power) == 0x000608, "Wrong size on AK25Power");
static_assert(offsetof(AK25Power, _k25ChainStrikeInteractionChargeableComponent) == 0x0004C8, "Member 'AK25Power::_k25ChainStrikeInteractionChargeableComponent' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25TeleportChargeableComponent) == 0x0004D0, "Member 'AK25Power::_k25TeleportChargeableComponent' has a wrong offset!");
static_assert(offsetof(AK25Power, _customKillerInstinctDatas) == 0x0004D8, "Member 'AK25Power::_customKillerInstinctDatas' has a wrong offset!");
static_assert(offsetof(AK25Power, _survivorStatusEffectID) == 0x0004E8, "Member 'AK25Power::_survivorStatusEffectID' has a wrong offset!");
static_assert(offsetof(AK25Power, _killerStatusEffectID) == 0x0004F8, "Member 'AK25Power::_killerStatusEffectID' has a wrong offset!");
static_assert(offsetof(AK25Power, _survivorChainAttachmentComponentClass) == 0x000508, "Member 'AK25Power::_survivorChainAttachmentComponentClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _survivorChainTargetterComponentClass) == 0x000510, "Member 'AK25Power::_survivorChainTargetterComponentClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25GatewayClass) == 0x000518, "Member 'AK25Power::_k25GatewayClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _controlledProjectileClass) == 0x000520, "Member 'AK25Power::_controlledProjectileClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _lamentConfigurationClass) == 0x000528, "Member 'AK25Power::_lamentConfigurationClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25HuskClass) == 0x000530, "Member 'AK25Power::_k25HuskClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _killerTeleportFinderComponentClass) == 0x000538, "Member 'AK25Power::_killerTeleportFinderComponentClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _chainAnimationActorClass) == 0x000540, "Member 'AK25Power::_chainAnimationActorClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _chainAnimationMappingsTables) == 0x000548, "Member 'AK25Power::_chainAnimationMappingsTables' has a wrong offset!");
static_assert(offsetof(AK25Power, _pillarAnimationActorClass) == 0x000558, "Member 'AK25Power::_pillarAnimationActorClass' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25ProjectileLauncher) == 0x000560, "Member 'AK25Power::_k25ProjectileLauncher' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25ProjectilePool) == 0x000568, "Member 'AK25Power::_k25ProjectilePool' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25ChainPool) == 0x000570, "Member 'AK25Power::_k25ChainPool' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25PowerChargeComponent) == 0x000578, "Member 'AK25Power::_k25PowerChargeComponent' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25ProjectileProvider) == 0x000580, "Member 'AK25Power::_k25ProjectileProvider' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25PowerPresentationItemProgressComponent) == 0x000588, "Member 'AK25Power::_k25PowerPresentationItemProgressComponent' has a wrong offset!");
static_assert(offsetof(AK25Power, _gateway) == 0x000590, "Member 'AK25Power::_gateway' has a wrong offset!");
static_assert(offsetof(AK25Power, _controlledProjectileInstance) == 0x000598, "Member 'AK25Power::_controlledProjectileInstance' has a wrong offset!");
static_assert(offsetof(AK25Power, _lamentConfiguration) == 0x0005A0, "Member 'AK25Power::_lamentConfiguration' has a wrong offset!");
static_assert(offsetof(AK25Power, _k25Husk) == 0x0005A8, "Member 'AK25Power::_k25Husk' has a wrong offset!");
static_assert(offsetof(AK25Power, _chainAttachmentReplicationComponent) == 0x0005B0, "Member 'AK25Power::_chainAttachmentReplicationComponent' has a wrong offset!");
static_assert(offsetof(AK25Power, _isPowerCharged) == 0x000600, "Member 'AK25Power::_isPowerCharged' has a wrong offset!");

// Class TheK25.K25PowerChargePresentationItemProgressComponent
// 0x0010 (0x00C8 - 0x00B8)
class UK25PowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	class UPowerChargeComponent*                  _powerChargeComponent;                             // 0x00B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK25Power*                              _k25Power;                                         // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25PowerChargePresentationItemProgressComponent">();
	}
	static class UK25PowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25PowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK25PowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK25PowerChargePresentationItemProgressComponent");
static_assert(sizeof(UK25PowerChargePresentationItemProgressComponent) == 0x0000C8, "Wrong size on UK25PowerChargePresentationItemProgressComponent");
static_assert(offsetof(UK25PowerChargePresentationItemProgressComponent, _powerChargeComponent) == 0x0000B8, "Member 'UK25PowerChargePresentationItemProgressComponent::_powerChargeComponent' has a wrong offset!");
static_assert(offsetof(UK25PowerChargePresentationItemProgressComponent, _k25Power) == 0x0000C0, "Member 'UK25PowerChargePresentationItemProgressComponent::_k25Power' has a wrong offset!");

// Class TheK25.K25ProjectileLauncher
// 0x0038 (0x01B8 - 0x0180)
class UK25ProjectileLauncher final : public UBaseProjectileLauncher
{
public:
	struct FDBDTunableRowHandle                   _controlledProjectileInitialSpeed;                 // 0x0180(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isControlledProjectileRequested;                  // 0x01A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AK25ControlledProjectile*               _controlledProjectile;                             // 0x01B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ProjectileLauncher">();
	}
	static class UK25ProjectileLauncher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ProjectileLauncher>();
	}
};
static_assert(alignof(UK25ProjectileLauncher) == 0x000008, "Wrong alignment on UK25ProjectileLauncher");
static_assert(sizeof(UK25ProjectileLauncher) == 0x0001B8, "Wrong size on UK25ProjectileLauncher");
static_assert(offsetof(UK25ProjectileLauncher, _controlledProjectileInitialSpeed) == 0x000180, "Member 'UK25ProjectileLauncher::_controlledProjectileInitialSpeed' has a wrong offset!");
static_assert(offsetof(UK25ProjectileLauncher, _isControlledProjectileRequested) == 0x0001A8, "Member 'UK25ProjectileLauncher::_isControlledProjectileRequested' has a wrong offset!");
static_assert(offsetof(UK25ProjectileLauncher, _controlledProjectile) == 0x0001B0, "Member 'UK25ProjectileLauncher::_controlledProjectile' has a wrong offset!");

// Class TheK25.K25ProjectilePool
// 0x0000 (0x00F0 - 0x00F0)
class UK25ProjectilePool final : public UAuthoritativeActorPoolComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ProjectilePool">();
	}
	static class UK25ProjectilePool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ProjectilePool>();
	}
};
static_assert(alignof(UK25ProjectilePool) == 0x000008, "Wrong alignment on UK25ProjectilePool");
static_assert(sizeof(UK25ProjectilePool) == 0x0000F0, "Wrong size on UK25ProjectilePool");

// Class TheK25.K25ProjectileReplicationComponent
// 0x0000 (0x00B8 - 0x00B8)
class UK25ProjectileReplicationComponent : public UBaseProjectileReplicationComponent
{
public:
	void Multicast_DeactivateProjectile(class AK25Projectile* projectile, const struct FK25ProjectileDeactivationData& deactivationData);
	void Multicast_SetAttachedChain(class AK25Projectile* projectile, class AK25Chain* chainToAttach, const struct FLaunchInfo& launchInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25ProjectileReplicationComponent">();
	}
	static class UK25ProjectileReplicationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25ProjectileReplicationComponent>();
	}
};
static_assert(alignof(UK25ProjectileReplicationComponent) == 0x000008, "Wrong alignment on UK25ProjectileReplicationComponent");
static_assert(sizeof(UK25ProjectileReplicationComponent) == 0x0000B8, "Wrong size on UK25ProjectileReplicationComponent");

// Class TheK25.K25RemoveChainInteraction
// 0x0060 (0x07A0 - 0x0740)
class UK25RemoveChainInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_740[0x18];                                     // 0x0740(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _interactionTimePerChainsAttached;                 // 0x0758(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK25SurvivorChainAttachmentComponent*   _cachedSurvivorChainAttachmentComponent;           // 0x0780(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AK25Chain>               _chainBeingRemoved;                                // 0x0788(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UK25SurvivorChainAttachmentComponent> _chainAttachmentComponent;            // 0x0790(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_798[0x8];                                      // 0x0798(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25RemoveChainInteraction">();
	}
	static class UK25RemoveChainInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25RemoveChainInteraction>();
	}
};
static_assert(alignof(UK25RemoveChainInteraction) == 0x000010, "Wrong alignment on UK25RemoveChainInteraction");
static_assert(sizeof(UK25RemoveChainInteraction) == 0x0007A0, "Wrong size on UK25RemoveChainInteraction");
static_assert(offsetof(UK25RemoveChainInteraction, _interactionTimePerChainsAttached) == 0x000758, "Member 'UK25RemoveChainInteraction::_interactionTimePerChainsAttached' has a wrong offset!");
static_assert(offsetof(UK25RemoveChainInteraction, _cachedSurvivorChainAttachmentComponent) == 0x000780, "Member 'UK25RemoveChainInteraction::_cachedSurvivorChainAttachmentComponent' has a wrong offset!");
static_assert(offsetof(UK25RemoveChainInteraction, _chainBeingRemoved) == 0x000788, "Member 'UK25RemoveChainInteraction::_chainBeingRemoved' has a wrong offset!");
static_assert(offsetof(UK25RemoveChainInteraction, _chainAttachmentComponent) == 0x000790, "Member 'UK25RemoveChainInteraction::_chainAttachmentComponent' has a wrong offset!");

// Class TheK25.K25SolveLamentConfigurationInteraction
// 0x00E0 (0x0820 - 0x0740)
class UK25SolveLamentConfigurationInteraction final : public UChargeableInteractionDefinition
{
public:
	float                                         _timeBufferBeforeAllowedToUseInteractionAgain;     // 0x0740(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_744[0x4];                                      // 0x0744(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _failSkillCheckTimePenalty;                        // 0x0748(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimationMontageDescriptor            _failMontage;                                      // 0x0770(0x0020)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_790[0x90];                                     // 0x0790(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSkillCheckResponseAuthority(bool success, bool bonus, class ADBDPlayer* player, bool triggerLoudNoise, ESkillCheckCustomType type);
	void Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX(class ASlasherPlayer* killer);
	void Multicast_TriggerKillerStoppedInteractionViaAttackSFX(class ASlasherPlayer* killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25SolveLamentConfigurationInteraction">();
	}
	static class UK25SolveLamentConfigurationInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25SolveLamentConfigurationInteraction>();
	}
};
static_assert(alignof(UK25SolveLamentConfigurationInteraction) == 0x000010, "Wrong alignment on UK25SolveLamentConfigurationInteraction");
static_assert(sizeof(UK25SolveLamentConfigurationInteraction) == 0x000820, "Wrong size on UK25SolveLamentConfigurationInteraction");
static_assert(offsetof(UK25SolveLamentConfigurationInteraction, _timeBufferBeforeAllowedToUseInteractionAgain) == 0x000740, "Member 'UK25SolveLamentConfigurationInteraction::_timeBufferBeforeAllowedToUseInteractionAgain' has a wrong offset!");
static_assert(offsetof(UK25SolveLamentConfigurationInteraction, _failSkillCheckTimePenalty) == 0x000748, "Member 'UK25SolveLamentConfigurationInteraction::_failSkillCheckTimePenalty' has a wrong offset!");
static_assert(offsetof(UK25SolveLamentConfigurationInteraction, _failMontage) == 0x000770, "Member 'UK25SolveLamentConfigurationInteraction::_failMontage' has a wrong offset!");

// Class TheK25.K25SurvivorChainAttachmentAnchor
// 0x00C0 (0x02F0 - 0x0230)
class AK25SurvivorChainAttachmentAnchor final : public AActor
{
public:
	uint8                                         Pad_230[0x18];                                     // 0x0230(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _chainMaxBreakingLength;                           // 0x0248(0x0028)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _timeBetweenTrace;                                 // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FK25SurvivorChainAttachmentData        _attachmentData;                                   // 0x0278(0x0028)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ACamperPlayer>           _owningSurvivor;                                   // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AK25Chain>               _attachedChain;                                    // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x28];                                     // 0x02B0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _cachedPullDirection;                              // 0x02D8(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E4[0xC];                                      // 0x02E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnChainAttached(class AK25Chain* chainToAttach);
	void Cosmetic_OnChainDetached(class AK25Chain* chainToDetach);
	void OnRep_AttachmentData();

	struct FK25SurvivorChainAttachmentData GetChainAttachmentData() const;
	struct FVector GetChainAttachmentLocation() const;
	float GetChainPullDirectionAngle() const;
	struct FVector GetChainsPullDirection() const;
	struct FVector GetChainsPullLocation() const;
	int32 GetNumberOfChainsAttached() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25SurvivorChainAttachmentAnchor">();
	}
	static class AK25SurvivorChainAttachmentAnchor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25SurvivorChainAttachmentAnchor>();
	}
};
static_assert(alignof(AK25SurvivorChainAttachmentAnchor) == 0x000008, "Wrong alignment on AK25SurvivorChainAttachmentAnchor");
static_assert(sizeof(AK25SurvivorChainAttachmentAnchor) == 0x0002F0, "Wrong size on AK25SurvivorChainAttachmentAnchor");
static_assert(offsetof(AK25SurvivorChainAttachmentAnchor, _chainMaxBreakingLength) == 0x000248, "Member 'AK25SurvivorChainAttachmentAnchor::_chainMaxBreakingLength' has a wrong offset!");
static_assert(offsetof(AK25SurvivorChainAttachmentAnchor, _timeBetweenTrace) == 0x000270, "Member 'AK25SurvivorChainAttachmentAnchor::_timeBetweenTrace' has a wrong offset!");
static_assert(offsetof(AK25SurvivorChainAttachmentAnchor, _attachmentData) == 0x000278, "Member 'AK25SurvivorChainAttachmentAnchor::_attachmentData' has a wrong offset!");
static_assert(offsetof(AK25SurvivorChainAttachmentAnchor, _owningSurvivor) == 0x0002A0, "Member 'AK25SurvivorChainAttachmentAnchor::_owningSurvivor' has a wrong offset!");
static_assert(offsetof(AK25SurvivorChainAttachmentAnchor, _attachedChain) == 0x0002A8, "Member 'AK25SurvivorChainAttachmentAnchor::_attachedChain' has a wrong offset!");
static_assert(offsetof(AK25SurvivorChainAttachmentAnchor, _cachedPullDirection) == 0x0002D8, "Member 'AK25SurvivorChainAttachmentAnchor::_cachedPullDirection' has a wrong offset!");

// Class TheK25.K25SurvivorChainAttachmentComponent
// 0x00E0 (0x0198 - 0x00B8)
class UK25SurvivorChainAttachmentComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AK25SurvivorChainAttachmentAnchor> _attachmentAnchorClass;                     // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FK25SurvivorChainAttachmentData> _survivorAnchorData;                              // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UK25SurvivorChainRotationStrategy> _survivorChainRotationStrategyClass;        // 0x0100(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UInteractionDefinition>> _interruptableInteractionClasses;              // 0x0108(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maximumNumberOfChainsAttached;                    // 0x0118(0x0028)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AK25SurvivorChainAttachmentAnchor*> _chainAttachmentAnchors;                        // 0x0140(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AK25Chain>>       _chainsAttached;                                   // 0x0150(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _removeChainChargeableComponent;                   // 0x0160(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UK25SurvivorChainRotationStrategy*      _survivorChainRotationStrategy;                    // 0x0170(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK25ChainAttachmentReplicationComponent* _chainAttachmentReplicationComponent;             // 0x0178(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0x18];                                     // 0x0180(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_TriggerHitSurvivorInExitAreaSFX(class ASlasherPlayer* killer);
	void Multicast_TriggerHitSurvivorInExitAreaSFX(class ASlasherPlayer* killer);
	void OnRep_RemoveChainChargeableComponent();

	class AK25Chain* GetFirstChainToRelease() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25SurvivorChainAttachmentComponent">();
	}
	static class UK25SurvivorChainAttachmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25SurvivorChainAttachmentComponent>();
	}
};
static_assert(alignof(UK25SurvivorChainAttachmentComponent) == 0x000008, "Wrong alignment on UK25SurvivorChainAttachmentComponent");
static_assert(sizeof(UK25SurvivorChainAttachmentComponent) == 0x000198, "Wrong size on UK25SurvivorChainAttachmentComponent");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _attachmentAnchorClass) == 0x0000E8, "Member 'UK25SurvivorChainAttachmentComponent::_attachmentAnchorClass' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _survivorAnchorData) == 0x0000F0, "Member 'UK25SurvivorChainAttachmentComponent::_survivorAnchorData' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _survivorChainRotationStrategyClass) == 0x000100, "Member 'UK25SurvivorChainAttachmentComponent::_survivorChainRotationStrategyClass' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _interruptableInteractionClasses) == 0x000108, "Member 'UK25SurvivorChainAttachmentComponent::_interruptableInteractionClasses' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _maximumNumberOfChainsAttached) == 0x000118, "Member 'UK25SurvivorChainAttachmentComponent::_maximumNumberOfChainsAttached' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _chainAttachmentAnchors) == 0x000140, "Member 'UK25SurvivorChainAttachmentComponent::_chainAttachmentAnchors' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _chainsAttached) == 0x000150, "Member 'UK25SurvivorChainAttachmentComponent::_chainsAttached' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _removeChainChargeableComponent) == 0x000160, "Member 'UK25SurvivorChainAttachmentComponent::_removeChainChargeableComponent' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _survivorChainRotationStrategy) == 0x000170, "Member 'UK25SurvivorChainAttachmentComponent::_survivorChainRotationStrategy' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainAttachmentComponent, _chainAttachmentReplicationComponent) == 0x000178, "Member 'UK25SurvivorChainAttachmentComponent::_chainAttachmentReplicationComponent' has a wrong offset!");

// Class TheK25.K25SurvivorChainHuntEffectsComponent
// 0x0008 (0x00F8 - 0x00F0)
class UK25SurvivorChainHuntEffectsComponent final : public UK25ChainHuntEffectsComponent
{
public:
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACamperPlayer* GetOwningSurvivor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25SurvivorChainHuntEffectsComponent">();
	}
	static class UK25SurvivorChainHuntEffectsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25SurvivorChainHuntEffectsComponent>();
	}
};
static_assert(alignof(UK25SurvivorChainHuntEffectsComponent) == 0x000008, "Wrong alignment on UK25SurvivorChainHuntEffectsComponent");
static_assert(sizeof(UK25SurvivorChainHuntEffectsComponent) == 0x0000F8, "Wrong size on UK25SurvivorChainHuntEffectsComponent");

// Class TheK25.K25SurvivorChainRotationStrategy
// 0x0010 (0x00C8 - 0x00B8)
class UK25SurvivorChainRotationStrategy final : public UBaseCharacterRotationStrategy
{
public:
	TWeakObjectPtr<class ACamperPlayer>           _cachedSurvivor;                                   // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK25SurvivorChainAttachmentComponent*   _cachedChainAttachmentComponent;                   // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25SurvivorChainRotationStrategy">();
	}
	static class UK25SurvivorChainRotationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25SurvivorChainRotationStrategy>();
	}
};
static_assert(alignof(UK25SurvivorChainRotationStrategy) == 0x000008, "Wrong alignment on UK25SurvivorChainRotationStrategy");
static_assert(sizeof(UK25SurvivorChainRotationStrategy) == 0x0000C8, "Wrong size on UK25SurvivorChainRotationStrategy");
static_assert(offsetof(UK25SurvivorChainRotationStrategy, _cachedSurvivor) == 0x0000B8, "Member 'UK25SurvivorChainRotationStrategy::_cachedSurvivor' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainRotationStrategy, _cachedChainAttachmentComponent) == 0x0000C0, "Member 'UK25SurvivorChainRotationStrategy::_cachedChainAttachmentComponent' has a wrong offset!");

// Class TheK25.K25SurvivorChainTargetterComponent
// 0x0118 (0x01D0 - 0x00B8)
class UK25SurvivorChainTargetterComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _timeBetweenQueuedChainsLaunch;                    // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _timeBetweenQueuedChainsLaunchAfterPreviousFailedAttempt; // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _minimumSpawnDistance;                             // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maximumSpawnDistance;                             // 0x0110(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sphereCastRadius;                                 // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _numberOfPositionFindingTries;                     // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x4];                                      // 0x0140(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _maxNumberOfChainRetries;                          // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x88];                                     // 0x0148(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorHealthStateChanged(ECamperDamageState oldDamageState, ECamperDamageState currentDamageState);

	void Multicast_DebugPositionFind(const struct FVector& startSweepPosition, const struct FVector& endSweepPosition, bool hasFoundPosition, const struct FVector& foundPosition, bool hasFoundCollision, const struct FVector& collisionPosition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25SurvivorChainTargetterComponent">();
	}
	static class UK25SurvivorChainTargetterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25SurvivorChainTargetterComponent>();
	}
};
static_assert(alignof(UK25SurvivorChainTargetterComponent) == 0x000008, "Wrong alignment on UK25SurvivorChainTargetterComponent");
static_assert(sizeof(UK25SurvivorChainTargetterComponent) == 0x0001D0, "Wrong size on UK25SurvivorChainTargetterComponent");
static_assert(offsetof(UK25SurvivorChainTargetterComponent, _timeBetweenQueuedChainsLaunch) == 0x0000B8, "Member 'UK25SurvivorChainTargetterComponent::_timeBetweenQueuedChainsLaunch' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainTargetterComponent, _timeBetweenQueuedChainsLaunchAfterPreviousFailedAttempt) == 0x0000E0, "Member 'UK25SurvivorChainTargetterComponent::_timeBetweenQueuedChainsLaunchAfterPreviousFailedAttempt' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainTargetterComponent, _minimumSpawnDistance) == 0x0000E8, "Member 'UK25SurvivorChainTargetterComponent::_minimumSpawnDistance' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainTargetterComponent, _maximumSpawnDistance) == 0x000110, "Member 'UK25SurvivorChainTargetterComponent::_maximumSpawnDistance' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainTargetterComponent, _sphereCastRadius) == 0x000138, "Member 'UK25SurvivorChainTargetterComponent::_sphereCastRadius' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainTargetterComponent, _numberOfPositionFindingTries) == 0x00013C, "Member 'UK25SurvivorChainTargetterComponent::_numberOfPositionFindingTries' has a wrong offset!");
static_assert(offsetof(UK25SurvivorChainTargetterComponent, _maxNumberOfChainRetries) == 0x000144, "Member 'UK25SurvivorChainTargetterComponent::_maxNumberOfChainRetries' has a wrong offset!");

// Class TheK25.K25TeleportInteraction
// 0x00B0 (0x07F0 - 0x0740)
class UK25TeleportInteraction final : public UChargeableInteractionDefinition
{
public:
	int32                                         _maxNumberLocationQueriesPerTick;                  // 0x0740(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _timeSensingLamentConfigurationAfterInteractionEnded; // 0x0744(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_748[0x20];                                     // 0x0748(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _slowdownAfterTeleportDuration;                    // 0x0768(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_790[0x60];                                     // 0x0790(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_TeleportAbortedEffects(class ASlasherPlayer* killer);
	void Cosmetic_TeleportEndEffects(class ASlasherPlayer* killer);
	void Cosmetic_TeleportStartEffects(class ASlasherPlayer* killer);
	void Multicast_InitializeHusk(const struct FVector& location, const struct FRotator& rotation);
	void Multicast_TeleportKillerToTargetPosition(class ASlasherPlayer* killer, const struct FVector& location, const struct FRotator& rotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25TeleportInteraction">();
	}
	static class UK25TeleportInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25TeleportInteraction>();
	}
};
static_assert(alignof(UK25TeleportInteraction) == 0x000010, "Wrong alignment on UK25TeleportInteraction");
static_assert(sizeof(UK25TeleportInteraction) == 0x0007F0, "Wrong size on UK25TeleportInteraction");
static_assert(offsetof(UK25TeleportInteraction, _maxNumberLocationQueriesPerTick) == 0x000740, "Member 'UK25TeleportInteraction::_maxNumberLocationQueriesPerTick' has a wrong offset!");
static_assert(offsetof(UK25TeleportInteraction, _timeSensingLamentConfigurationAfterInteractionEnded) == 0x000744, "Member 'UK25TeleportInteraction::_timeSensingLamentConfigurationAfterInteractionEnded' has a wrong offset!");
static_assert(offsetof(UK25TeleportInteraction, _slowdownAfterTeleportDuration) == 0x000768, "Member 'UK25TeleportInteraction::_slowdownAfterTeleportDuration' has a wrong offset!");

// Class TheK25.K25UncontrolledProjectile
// 0x00F8 (0x0528 - 0x0430)
class AK25UncontrolledProjectile final : public AK25Projectile
{
public:
	uint8                                         Pad_430[0x8];                                      // 0x0430(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const bool acquired)> OnAcquiredChanged;                           // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _minimumTimeBeforeProjectileLaunch;                // 0x0448(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _maximumTimeBeforeProjectileLaunch;                // 0x0470(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _projectileSpeed;                                  // 0x0498(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _projectileMaximumTravelDistance;                  // 0x04C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _isAcquiredFromPool;                               // 0x04E8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E9[0x37];                                     // 0x04E9(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          _targetSurvivor;                                   // 0x0520(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_TriggerUncontrolledProjectileSpawnSFX();
	void OnRep_TargetSurvivor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25UncontrolledProjectile">();
	}
	static class AK25UncontrolledProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK25UncontrolledProjectile>();
	}
};
static_assert(alignof(AK25UncontrolledProjectile) == 0x000008, "Wrong alignment on AK25UncontrolledProjectile");
static_assert(sizeof(AK25UncontrolledProjectile) == 0x000528, "Wrong size on AK25UncontrolledProjectile");
static_assert(offsetof(AK25UncontrolledProjectile, OnAcquiredChanged) == 0x000438, "Member 'AK25UncontrolledProjectile::OnAcquiredChanged' has a wrong offset!");
static_assert(offsetof(AK25UncontrolledProjectile, _minimumTimeBeforeProjectileLaunch) == 0x000448, "Member 'AK25UncontrolledProjectile::_minimumTimeBeforeProjectileLaunch' has a wrong offset!");
static_assert(offsetof(AK25UncontrolledProjectile, _maximumTimeBeforeProjectileLaunch) == 0x000470, "Member 'AK25UncontrolledProjectile::_maximumTimeBeforeProjectileLaunch' has a wrong offset!");
static_assert(offsetof(AK25UncontrolledProjectile, _projectileSpeed) == 0x000498, "Member 'AK25UncontrolledProjectile::_projectileSpeed' has a wrong offset!");
static_assert(offsetof(AK25UncontrolledProjectile, _projectileMaximumTravelDistance) == 0x0004C0, "Member 'AK25UncontrolledProjectile::_projectileMaximumTravelDistance' has a wrong offset!");
static_assert(offsetof(AK25UncontrolledProjectile, _isAcquiredFromPool) == 0x0004E8, "Member 'AK25UncontrolledProjectile::_isAcquiredFromPool' has a wrong offset!");
static_assert(offsetof(AK25UncontrolledProjectile, _targetSurvivor) == 0x000520, "Member 'AK25UncontrolledProjectile::_targetSurvivor' has a wrong offset!");

// Class TheK25.K25UncontrolledProjectileReplicationComponent
// 0x0000 (0x00B8 - 0x00B8)
class UK25UncontrolledProjectileReplicationComponent final : public UK25ProjectileReplicationComponent
{
public:
	void Multicast_LaunchProjectile(class AK25UncontrolledProjectile* projectile, const struct FLaunchInfo& launchInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25UncontrolledProjectileReplicationComponent">();
	}
	static class UK25UncontrolledProjectileReplicationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25UncontrolledProjectileReplicationComponent>();
	}
};
static_assert(alignof(UK25UncontrolledProjectileReplicationComponent) == 0x000008, "Wrong alignment on UK25UncontrolledProjectileReplicationComponent");
static_assert(sizeof(UK25UncontrolledProjectileReplicationComponent) == 0x0000B8, "Wrong size on UK25UncontrolledProjectileReplicationComponent");

// Class TheK25.K25Utilities
// 0x0000 (0x0030 - 0x0030)
class UK25Utilities final : public UBlueprintFunctionLibrary
{
public:
	static class AK25ControlledProjectile* GetK25ControlledProjectile(class UObject* worldContextObject);
	static class AK25Gateway* GetK25Gateway(class UObject* worldContextObject);
	static class AK25Husk* GetK25Husk(class UObject* worldContextObject);
	static class AK25Power* GetK25Power(class UObject* worldContextObject);
	static class ALamentConfiguration* GetLamentConfiguration(class UObject* worldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25Utilities">();
	}
	static class UK25Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25Utilities>();
	}
};
static_assert(alignof(UK25Utilities) == 0x000008, "Wrong alignment on UK25Utilities");
static_assert(sizeof(UK25Utilities) == 0x000030, "Wrong size on UK25Utilities");

// Class TheK25.K25WeaponAnimInstance
// 0x0000 (0x0380 - 0x0380)
class UK25WeaponAnimInstance final : public UBaseKillerWeaponAnimInstance
{
public:
	bool                                          _hasDownedTargetHoldingLamentConfiguration;        // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttackStart(const EAttackType attackType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25WeaponAnimInstance">();
	}
	static class UK25WeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25WeaponAnimInstance>();
	}
};
static_assert(alignof(UK25WeaponAnimInstance) == 0x000010, "Wrong alignment on UK25WeaponAnimInstance");
static_assert(sizeof(UK25WeaponAnimInstance) == 0x000380, "Wrong size on UK25WeaponAnimInstance");
static_assert(offsetof(UK25WeaponAnimInstance, _hasDownedTargetHoldingLamentConfiguration) == 0x000378, "Member 'UK25WeaponAnimInstance::_hasDownedTargetHoldingLamentConfiguration' has a wrong offset!");

// Class TheK25.LamentConfigurationChainHuntComponent
// 0x01D0 (0x0288 - 0x00B8)
class ULamentConfigurationChainHuntComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x78];                                      // 0x00B8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _floorChainHuntTimeBetweenChainStrikes;            // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _chainHuntChargeTime;                              // 0x0138(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _chainNumberPerChainHuntCluster;                   // 0x01B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _timeBetweenChainHuntClusterStrikes;               // 0x01C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK25KillerChainHuntEffectsComponent> _killerChainHuntEffectsComponentClass;    // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK25SurvivorChainHuntEffectsComponent> _survivorChainHuntEffectsComponentClass; // 0x01D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK25KillerChainHuntEffectsComponent*    _killerChainHuntEffectsComponent;                  // 0x01D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UK25SurvivorChainHuntEffectsComponent*> _chainHuntEffectsComponents;                // 0x01E0(0x0010)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F0[0x30];                                     // 0x01F0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _cachedAdditiveChainStrikeDelayTime;               // 0x0220(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_224[0x34];                                     // 0x0224(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	struct FChainHuntStateData                    _chainHuntStateData;                               // 0x0258(0x0010)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	EChainHuntState                               _oldChainHuntState;                                // 0x0268(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_269[0x1F];                                     // 0x0269(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ChainHuntStateData();

	float GetChainHuntProgressPercentage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LamentConfigurationChainHuntComponent">();
	}
	static class ULamentConfigurationChainHuntComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULamentConfigurationChainHuntComponent>();
	}
};
static_assert(alignof(ULamentConfigurationChainHuntComponent) == 0x000008, "Wrong alignment on ULamentConfigurationChainHuntComponent");
static_assert(sizeof(ULamentConfigurationChainHuntComponent) == 0x000288, "Wrong size on ULamentConfigurationChainHuntComponent");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _floorChainHuntTimeBetweenChainStrikes) == 0x000130, "Member 'ULamentConfigurationChainHuntComponent::_floorChainHuntTimeBetweenChainStrikes' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _chainHuntChargeTime) == 0x000138, "Member 'ULamentConfigurationChainHuntComponent::_chainHuntChargeTime' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _chainNumberPerChainHuntCluster) == 0x0001B8, "Member 'ULamentConfigurationChainHuntComponent::_chainNumberPerChainHuntCluster' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _timeBetweenChainHuntClusterStrikes) == 0x0001C0, "Member 'ULamentConfigurationChainHuntComponent::_timeBetweenChainHuntClusterStrikes' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _killerChainHuntEffectsComponentClass) == 0x0001C8, "Member 'ULamentConfigurationChainHuntComponent::_killerChainHuntEffectsComponentClass' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _survivorChainHuntEffectsComponentClass) == 0x0001D0, "Member 'ULamentConfigurationChainHuntComponent::_survivorChainHuntEffectsComponentClass' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _killerChainHuntEffectsComponent) == 0x0001D8, "Member 'ULamentConfigurationChainHuntComponent::_killerChainHuntEffectsComponent' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _chainHuntEffectsComponents) == 0x0001E0, "Member 'ULamentConfigurationChainHuntComponent::_chainHuntEffectsComponents' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _cachedAdditiveChainStrikeDelayTime) == 0x000220, "Member 'ULamentConfigurationChainHuntComponent::_cachedAdditiveChainStrikeDelayTime' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _chainHuntStateData) == 0x000258, "Member 'ULamentConfigurationChainHuntComponent::_chainHuntStateData' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationChainHuntComponent, _oldChainHuntState) == 0x000268, "Member 'ULamentConfigurationChainHuntComponent::_oldChainHuntState' has a wrong offset!");

// Class TheK25.LamentConfigurationOutlineStrategy
// 0x0068 (0x0128 - 0x00C0)
class ULamentConfigurationOutlineStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _noChainHuntProgressColor;                         // 0x00C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _chainHuntActiveColor;                             // 0x00D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _killerColor;                                      // 0x00E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x38];                                      // 0x00F0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LamentConfigurationOutlineStrategy">();
	}
	static class ULamentConfigurationOutlineStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULamentConfigurationOutlineStrategy>();
	}
};
static_assert(alignof(ULamentConfigurationOutlineStrategy) == 0x000008, "Wrong alignment on ULamentConfigurationOutlineStrategy");
static_assert(sizeof(ULamentConfigurationOutlineStrategy) == 0x000128, "Wrong size on ULamentConfigurationOutlineStrategy");
static_assert(offsetof(ULamentConfigurationOutlineStrategy, _noChainHuntProgressColor) == 0x0000C0, "Member 'ULamentConfigurationOutlineStrategy::_noChainHuntProgressColor' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationOutlineStrategy, _chainHuntActiveColor) == 0x0000D0, "Member 'ULamentConfigurationOutlineStrategy::_chainHuntActiveColor' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationOutlineStrategy, _killerColor) == 0x0000E0, "Member 'ULamentConfigurationOutlineStrategy::_killerColor' has a wrong offset!");

// Class TheK25.LamentConfigurationPlayerAnalyticsComponent
// 0x0020 (0x00D8 - 0x00B8)
class ULamentConfigurationPlayerAnalyticsComponent final : public UActorComponent
{
public:
	int32                                         _analyticsCount;                                   // 0x00B8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLamentConfigurationPlayerPossessionData _possessionAnalytics;                            // 0x00C0(0x0018)(Net, NativeAccessSpecifierPrivate)

public:
	void OnRep_AnalyticsCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LamentConfigurationPlayerAnalyticsComponent">();
	}
	static class ULamentConfigurationPlayerAnalyticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULamentConfigurationPlayerAnalyticsComponent>();
	}
};
static_assert(alignof(ULamentConfigurationPlayerAnalyticsComponent) == 0x000008, "Wrong alignment on ULamentConfigurationPlayerAnalyticsComponent");
static_assert(sizeof(ULamentConfigurationPlayerAnalyticsComponent) == 0x0000D8, "Wrong size on ULamentConfigurationPlayerAnalyticsComponent");
static_assert(offsetof(ULamentConfigurationPlayerAnalyticsComponent, _analyticsCount) == 0x0000B8, "Member 'ULamentConfigurationPlayerAnalyticsComponent::_analyticsCount' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationPlayerAnalyticsComponent, _possessionAnalytics) == 0x0000C0, "Member 'ULamentConfigurationPlayerAnalyticsComponent::_possessionAnalytics' has a wrong offset!");

// Class TheK25.LamentConfigurationSpawnStrategy
// 0x0078 (0x0130 - 0x00B8)
class ULamentConfigurationSpawnStrategy final : public UActorComponent
{
public:
	float                                         _killerPointDistanceMultiplier;                    // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _survivorPointDistanceMultiplier;                  // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxDistancePointAllowed;                          // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minSurvivorDistance;                              // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minSurvivorDistancePointPenalty;                  // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minKillerDistance;                                // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minHatchDistance;                                 // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minDistanceFromOtherSpawns;                       // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minKillerDistancePointPenalty;                    // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _numberOfSpawnPointInLottery;                      // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pointPenaltyPerUsedLocationTime;                  // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ETileSpawnPointType>                   _spawnPointsTypes;                                 // 0x00F0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         _downRaycastLength;                                // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rayCastZOffet;                                    // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _navmeshCheckRadius;                               // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLamentConfigurationSpawnInfo>  _cached_spawnsInfo;                                // 0x0110(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AHatch*>                         _hatches;                                          // 0x0120(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LamentConfigurationSpawnStrategy">();
	}
	static class ULamentConfigurationSpawnStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULamentConfigurationSpawnStrategy>();
	}
};
static_assert(alignof(ULamentConfigurationSpawnStrategy) == 0x000008, "Wrong alignment on ULamentConfigurationSpawnStrategy");
static_assert(sizeof(ULamentConfigurationSpawnStrategy) == 0x000130, "Wrong size on ULamentConfigurationSpawnStrategy");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _killerPointDistanceMultiplier) == 0x0000B8, "Member 'ULamentConfigurationSpawnStrategy::_killerPointDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _survivorPointDistanceMultiplier) == 0x0000BC, "Member 'ULamentConfigurationSpawnStrategy::_survivorPointDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _maxDistancePointAllowed) == 0x0000C0, "Member 'ULamentConfigurationSpawnStrategy::_maxDistancePointAllowed' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _minSurvivorDistance) == 0x0000C4, "Member 'ULamentConfigurationSpawnStrategy::_minSurvivorDistance' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _minSurvivorDistancePointPenalty) == 0x0000C8, "Member 'ULamentConfigurationSpawnStrategy::_minSurvivorDistancePointPenalty' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _minKillerDistance) == 0x0000CC, "Member 'ULamentConfigurationSpawnStrategy::_minKillerDistance' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _minHatchDistance) == 0x0000D0, "Member 'ULamentConfigurationSpawnStrategy::_minHatchDistance' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _minDistanceFromOtherSpawns) == 0x0000D4, "Member 'ULamentConfigurationSpawnStrategy::_minDistanceFromOtherSpawns' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _minKillerDistancePointPenalty) == 0x0000E0, "Member 'ULamentConfigurationSpawnStrategy::_minKillerDistancePointPenalty' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _numberOfSpawnPointInLottery) == 0x0000E4, "Member 'ULamentConfigurationSpawnStrategy::_numberOfSpawnPointInLottery' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _pointPenaltyPerUsedLocationTime) == 0x0000E8, "Member 'ULamentConfigurationSpawnStrategy::_pointPenaltyPerUsedLocationTime' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _spawnPointsTypes) == 0x0000F0, "Member 'ULamentConfigurationSpawnStrategy::_spawnPointsTypes' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _downRaycastLength) == 0x000100, "Member 'ULamentConfigurationSpawnStrategy::_downRaycastLength' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _rayCastZOffet) == 0x000104, "Member 'ULamentConfigurationSpawnStrategy::_rayCastZOffet' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _navmeshCheckRadius) == 0x000108, "Member 'ULamentConfigurationSpawnStrategy::_navmeshCheckRadius' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _cached_spawnsInfo) == 0x000110, "Member 'ULamentConfigurationSpawnStrategy::_cached_spawnsInfo' has a wrong offset!");
static_assert(offsetof(ULamentConfigurationSpawnStrategy, _hatches) == 0x000120, "Member 'ULamentConfigurationSpawnStrategy::_hatches' has a wrong offset!");

// Class TheK25.OwningPlayerInLamentConfigurationRange
// 0x0020 (0x0120 - 0x0100)
class UOwningPlayerInLamentConfigurationRange final : public UAnyActorPairQueryRangeIsTrue
{
public:
	uint8                                         Pad_100[0x20];                                     // 0x0100(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OwningPlayerInLamentConfigurationRange">();
	}
	static class UOwningPlayerInLamentConfigurationRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOwningPlayerInLamentConfigurationRange>();
	}
};
static_assert(alignof(UOwningPlayerInLamentConfigurationRange) == 0x000008, "Wrong alignment on UOwningPlayerInLamentConfigurationRange");
static_assert(sizeof(UOwningPlayerInLamentConfigurationRange) == 0x000120, "Wrong size on UOwningPlayerInLamentConfigurationRange");

// Class TheK25.S28P01
// 0x0030 (0x03F8 - 0x03C8)
class US28P01 final : public UPerk
{
public:
	float                                         _auraRevealDuration[0x3];                          // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _auraRevealRange[0x3];                             // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _S28P01ChargeableComponent;                        // 0x03E0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isPerkActive;                                     // 0x03E8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInteractionOngoing;                             // 0x03E9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3EA[0x6];                                      // 0x03EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _playerOwner;                                      // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_IsInteractionOngoing();
	void OnRep_IsPerkActive();
	void OnRep_S28P01ChargeableComponent();

	float GetAuraRevealDuration() const;
	float GetAuraRevealRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S28P01">();
	}
	static class US28P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<US28P01>();
	}
};
static_assert(alignof(US28P01) == 0x000008, "Wrong alignment on US28P01");
static_assert(sizeof(US28P01) == 0x0003F8, "Wrong size on US28P01");
static_assert(offsetof(US28P01, _auraRevealDuration) == 0x0003C8, "Member 'US28P01::_auraRevealDuration' has a wrong offset!");
static_assert(offsetof(US28P01, _auraRevealRange) == 0x0003D4, "Member 'US28P01::_auraRevealRange' has a wrong offset!");
static_assert(offsetof(US28P01, _S28P01ChargeableComponent) == 0x0003E0, "Member 'US28P01::_S28P01ChargeableComponent' has a wrong offset!");
static_assert(offsetof(US28P01, _isPerkActive) == 0x0003E8, "Member 'US28P01::_isPerkActive' has a wrong offset!");
static_assert(offsetof(US28P01, _isInteractionOngoing) == 0x0003E9, "Member 'US28P01::_isInteractionOngoing' has a wrong offset!");
static_assert(offsetof(US28P01, _playerOwner) == 0x0003F0, "Member 'US28P01::_playerOwner' has a wrong offset!");

// Class TheK25.S28P01AuraReveal
// 0x0060 (0x07A0 - 0x0740)
class US28P01AuraReveal final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_740[0x60];                                     // 0x0740(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S28P01AuraReveal">();
	}
	static class US28P01AuraReveal* GetDefaultObj()
	{
		return GetDefaultObjImpl<US28P01AuraReveal>();
	}
};
static_assert(alignof(US28P01AuraReveal) == 0x000010, "Wrong alignment on US28P01AuraReveal");
static_assert(sizeof(US28P01AuraReveal) == 0x0007A0, "Wrong size on US28P01AuraReveal");

// Class TheK25.S28P02
// 0x0040 (0x04C0 - 0x0480)
class US28P02 final : public UBoonPerk
{
public:
	float                                         _healingSpeedGainPercentage[0x3];                  // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canSelfHeal;                                      // 0x048C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48D[0x3];                                      // 0x048D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _selfHealSpeedPenalty[0x3];                        // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _healingSpeedIncreaseEffect;                       // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _allowSelfHealEffectClass;                         // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _selfHealSpeedPenaltyEffectClass;                  // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _revealInjuredPlayersInBoonRangeEffectClass;       // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CanSelfHeal() const;
	float GetHealingSpeedGainPercentageAtLevel() const;
	float GetSelfHealSpeedPenaltyAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S28P02">();
	}
	static class US28P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<US28P02>();
	}
};
static_assert(alignof(US28P02) == 0x000008, "Wrong alignment on US28P02");
static_assert(sizeof(US28P02) == 0x0004C0, "Wrong size on US28P02");
static_assert(offsetof(US28P02, _healingSpeedGainPercentage) == 0x000480, "Member 'US28P02::_healingSpeedGainPercentage' has a wrong offset!");
static_assert(offsetof(US28P02, _canSelfHeal) == 0x00048C, "Member 'US28P02::_canSelfHeal' has a wrong offset!");
static_assert(offsetof(US28P02, _selfHealSpeedPenalty) == 0x000490, "Member 'US28P02::_selfHealSpeedPenalty' has a wrong offset!");
static_assert(offsetof(US28P02, _healingSpeedIncreaseEffect) == 0x0004A0, "Member 'US28P02::_healingSpeedIncreaseEffect' has a wrong offset!");
static_assert(offsetof(US28P02, _allowSelfHealEffectClass) == 0x0004A8, "Member 'US28P02::_allowSelfHealEffectClass' has a wrong offset!");
static_assert(offsetof(US28P02, _selfHealSpeedPenaltyEffectClass) == 0x0004B0, "Member 'US28P02::_selfHealSpeedPenaltyEffectClass' has a wrong offset!");
static_assert(offsetof(US28P02, _revealInjuredPlayersInBoonRangeEffectClass) == 0x0004B8, "Member 'US28P02::_revealInjuredPlayersInBoonRangeEffectClass' has a wrong offset!");

// Class TheK25.S28P03
// 0x0010 (0x0490 - 0x0480)
class US28P03 final : public UBoonPerk
{
public:
	float                                         _lingerDuration[0x3];                              // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const float GetLingerDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S28P03">();
	}
	static class US28P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<US28P03>();
	}
};
static_assert(alignof(US28P03) == 0x000008, "Wrong alignment on US28P03");
static_assert(sizeof(US28P03) == 0x000490, "Wrong size on US28P03");
static_assert(offsetof(US28P03, _lingerDuration) == 0x000480, "Member 'US28P03::_lingerDuration' has a wrong offset!");

}

