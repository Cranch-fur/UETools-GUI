#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheNightmare

#include "Basic.hpp"

#include "TheNightmare_classes.hpp"
#include "TheNightmare_parameters.hpp"


namespace SDK
{

// Function TheNightmare.DreamInducerComponent.Authority_OnLevelReadyToPlay
// (Final, Native, Private)

void UDreamInducerComponent::Authority_OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamInducerComponent", "Authority_OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.DreamSnareEffect.OnActorBeginOverlap
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamSnareEffect::OnActorBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamSnareEffect", "OnActorBeginOverlap");

	Params::DreamSnareEffect_OnActorBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.DreamSnareEffect.OnActorEndOverlap
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamSnareEffect::OnActorEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamSnareEffect", "OnActorEndOverlap");

	Params::DreamSnareEffect_OnActorEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.GeneratorDreamworldComponent.Cosmetic_OnPlayerFailSkillCheck
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorDreamworldComponent::Cosmetic_OnPlayerFailSkillCheck(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDreamworldComponent", "Cosmetic_OnPlayerFailSkillCheck");

	Params::GeneratorDreamworldComponent_Cosmetic_OnPlayerFailSkillCheck Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.GeneratorDreamworldComponent.OnRepairSkillCheckFailed
// (Final, Native, Private)
// Parameters:
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    triggerLoudNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   chargeChange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorDreamworldComponent::OnRepairSkillCheckFailed(bool success, bool bonus, class ADBDPlayer* player, bool triggerLoudNoise, bool hadInput, ESkillCheckCustomType type, float chargeChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDreamworldComponent", "OnRepairSkillCheckFailed");

	Params::GeneratorDreamworldComponent_OnRepairSkillCheckFailed Parms{};

	Parms.success = success;
	Parms.bonus = bonus;
	Parms.player = player;
	Parms.triggerLoudNoise = triggerLoudNoise;
	Parms.hadInput = hadInput;
	Parms.type = type;
	Parms.chargeChange = chargeChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.Authority_StartTeleportCooldown
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    teleported                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::Authority_StartTeleportCooldown(bool teleported)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "Authority_StartTeleportCooldown");

	Params::GeneratorTeleportInteraction_Authority_StartTeleportCooldown Parms{};

	Parms.teleported = teleported;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.Authority_TeleportPlayerToGenerator
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       playerToTeleport                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGenerator*                       generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGeneratorTeleportInteraction::Authority_TeleportPlayerToGenerator(class ADBDPlayer* playerToTeleport, class AGenerator* generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "Authority_TeleportPlayerToGenerator");

	Params::GeneratorTeleportInteraction_Authority_TeleportPlayerToGenerator Parms{};

	Parms.playerToTeleport = playerToTeleport;
	Parms.generator = generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.GeneratorTeleportInteraction.InitializeTunableValues
// (Final, Native, Private)
// Parameters:
// class ASlasherPlayer*                   killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::InitializeTunableValues(class ASlasherPlayer* killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "InitializeTunableValues");

	Params::GeneratorTeleportInteraction_InitializeTunableValues Parms{};

	Parms.killer = killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.Multicast_OnTeleportLocationChosen
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// class AGenerator*                       generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                location                                               (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::Multicast_OnTeleportLocationChosen(class AGenerator* generator, const struct FTransform& location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "Multicast_OnTeleportLocationChosen");

	Params::GeneratorTeleportInteraction_Multicast_OnTeleportLocationChosen Parms{};

	Parms.generator = generator;
	Parms.location = std::move(location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.Multicast_TeleportPlayer
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// const struct FVector&                   location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::Multicast_TeleportPlayer(const struct FVector& location, const struct FRotator& rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "Multicast_TeleportPlayer");

	Params::GeneratorTeleportInteraction_Multicast_TeleportPlayer Parms{};

	Parms.location = std::move(location);
	Parms.rotation = std::move(rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.OnBloodSpurts
// (Final, Native, Protected)

void UGeneratorTeleportInteraction::OnBloodSpurts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnBloodSpurts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.OnIntroCompleted
// (Final, Native, Protected)

void UGeneratorTeleportInteraction::OnIntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnIntroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.OnLocallySelectedGeneratorSet
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AGenerator*                       selectedGenerator                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::OnLocallySelectedGeneratorSet(class AGenerator* selectedGenerator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnLocallySelectedGeneratorSet");

	Params::GeneratorTeleportInteraction_OnLocallySelectedGeneratorSet Parms{};

	Parms.selectedGenerator = selectedGenerator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.GeneratorTeleportInteraction.OnRep_SelectedGenerator
// (Final, Native, Private)

void UGeneratorTeleportInteraction::OnRep_SelectedGenerator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnRep_SelectedGenerator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.OnRep_TeleportCooldownTimer
// (Final, Native, Private)

void UGeneratorTeleportInteraction::OnRep_TeleportCooldownTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnRep_TeleportCooldownTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.OnSelectedGeneratorSet
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AGenerator*                       selectedGenerator                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::OnSelectedGeneratorSet(class AGenerator* selectedGenerator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnSelectedGeneratorSet");

	Params::GeneratorTeleportInteraction_OnSelectedGeneratorSet Parms{};

	Parms.selectedGenerator = selectedGenerator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.GeneratorTeleportInteraction.OnTeleported
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FTransform&                transformBeforeTeleport                                (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::OnTeleported(const struct FTransform& transformBeforeTeleport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnTeleported");

	Params::GeneratorTeleportInteraction_OnTeleported Parms{};

	Parms.transformBeforeTeleport = std::move(transformBeforeTeleport);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.GeneratorTeleportInteraction.OnTeleportLocationChosen
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// class AGenerator*                       generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                location                                               (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::OnTeleportLocationChosen(class AGenerator* generator, const struct FTransform& location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnTeleportLocationChosen");

	Params::GeneratorTeleportInteraction_OnTeleportLocationChosen Parms{};

	Parms.generator = generator;
	Parms.location = std::move(location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.GeneratorTeleportInteraction.OnTeleportReady
// (Event, Protected, BlueprintEvent)

void UGeneratorTeleportInteraction::OnTeleportReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "OnTeleportReady");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheNightmare.GeneratorTeleportInteraction.Server_SetSelectedGenerator
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class AGenerator*                       generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTeleportInteraction::Server_SetSelectedGenerator(class AGenerator* generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "Server_SetSelectedGenerator");

	Params::GeneratorTeleportInteraction_Server_SetSelectedGenerator Parms{};

	Parms.generator = generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.ShowBloodSpurtsVFX
// (Event, Protected, BlueprintEvent)

void UGeneratorTeleportInteraction::ShowBloodSpurtsVFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "ShowBloodSpurtsVFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheNightmare.GeneratorTeleportInteraction.StartBloodSpurts
// (Final, Native, Protected, BlueprintCallable)

void UGeneratorTeleportInteraction::StartBloodSpurts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "StartBloodSpurts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.StopBloodSpurts
// (Final, Native, Protected, BlueprintCallable)

void UGeneratorTeleportInteraction::StopBloodSpurts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "StopBloodSpurts");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.GeneratorTeleportInteraction.CanTeleportAtGenerator
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AGenerator*                       generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGeneratorTeleportInteraction::CanTeleportAtGenerator(class AGenerator* generator) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "CanTeleportAtGenerator");

	Params::GeneratorTeleportInteraction_CanTeleportAtGenerator Parms{};

	Parms.generator = generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.GeneratorTeleportInteraction.GetInlineGenerator
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGenerator*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGenerator* UGeneratorTeleportInteraction::GetInlineGenerator(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "GetInlineGenerator");

	Params::GeneratorTeleportInteraction_GetInlineGenerator Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.GeneratorTeleportInteraction.GetOwningPlayer
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UGeneratorTeleportInteraction::GetOwningPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "GetOwningPlayer");

	Params::GeneratorTeleportInteraction_GetOwningPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.GeneratorTeleportInteraction.HasTeleportFailed
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGeneratorTeleportInteraction::HasTeleportFailed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "HasTeleportFailed");

	Params::GeneratorTeleportInteraction_HasTeleportFailed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.GeneratorTeleportInteraction.IsTeleportAvailable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGeneratorTeleportInteraction::IsTeleportAvailable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTeleportInteraction", "IsTeleportAvailable");

	Params::GeneratorTeleportInteraction_IsTeleportAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.NightmareCheatComponent.DBD_AllowWakeUpAtAnyClock
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    allow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNightmareCheatComponent::DBD_AllowWakeUpAtAnyClock(bool allow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NightmareCheatComponent", "DBD_AllowWakeUpAtAnyClock");

	Params::NightmareCheatComponent_DBD_AllowWakeUpAtAnyClock Parms{};

	Parms.allow = allow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.NightmareCheatComponent.OnRep_AllowWakeUpAnyClock
// (Final, Native, Private)

void UNightmareCheatComponent::OnRep_AllowWakeUpAnyClock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NightmareCheatComponent", "OnRep_AllowWakeUpAnyClock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.PlaceDreamPalletInteraction.InitializeTunableValues
// (Final, Native, Private)
// Parameters:
// class ASlasherPlayer*                   killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlaceDreamPalletInteraction::InitializeTunableValues(class ASlasherPlayer* killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlaceDreamPalletInteraction", "InitializeTunableValues");

	Params::PlaceDreamPalletInteraction_InitializeTunableValues Parms{};

	Parms.killer = killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheNightmare.PlaceDreamPalletInteraction.SpawnDreamPallet
// (Event, Public, BlueprintEvent)
// Parameters:
// class APalletTracker*                   trackerAtLocation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlaceDreamPalletInteraction::SpawnDreamPallet(class APalletTracker* trackerAtLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlaceDreamPalletInteraction", "SpawnDreamPallet");

	Params::PlaceDreamPalletInteraction_SpawnDreamPallet Parms{};

	Parms.trackerAtLocation = trackerAtLocation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheNightmare.PlaceDreamPalletInteraction.CanSpawnDreamPalletAtTracker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APalletTracker*                   tracker                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlaceDreamPalletInteraction::CanSpawnDreamPalletAtTracker(class APalletTracker* tracker) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlaceDreamPalletInteraction", "CanSpawnDreamPalletAtTracker");

	Params::PlaceDreamPalletInteraction_CanSpawnDreamPalletAtTracker Parms{};

	Parms.tracker = tracker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.PlaceDreamPalletInteraction.GetTargetedPallet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APalletTracker*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APalletTracker* UPlaceDreamPalletInteraction::GetTargetedPallet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlaceDreamPalletInteraction", "GetTargetedPallet");

	Params::PlaceDreamPalletInteraction_GetTargetedPallet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.RememberMe.DidLoseHealthState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     damagedActor                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   oldHealthStateCount                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URememberMe::DidLoseHealthState(const class AActor* damagedActor, int32 oldHealthStateCount) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RememberMe", "DidLoseHealthState");

	Params::RememberMe_DidLoseHealthState Parms{};

	Parms.damagedActor = damagedActor;
	Parms.oldHealthStateCount = oldHealthStateCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.SetDreamSnareInteraction.GetTrapDistanceFromControlRotation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USetDreamSnareInteraction::GetTrapDistanceFromControlRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SetDreamSnareInteraction", "GetTrapDistanceFromControlRotation");

	Params::SetDreamSnareInteraction_GetTrapDistanceFromControlRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheNightmare.SetDreamSnareInteraction.HasCancelledDreamSnare
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USetDreamSnareInteraction::HasCancelledDreamSnare() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SetDreamSnareInteraction", "HasCancelledDreamSnare");

	Params::SetDreamSnareInteraction_HasCancelledDreamSnare Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

