#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK28

#include "Basic.hpp"

#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDCompetence_classes.hpp"
#include "Engine_classes.hpp"
#include "AnimationUtilities_structs.hpp"
#include "DBDBots_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "Competence_classes.hpp"
#include "TheK28_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "DataTableUtilities_structs.hpp"
#include "DBDInteraction_classes.hpp"
#include "StatSystem_structs.hpp"
#include "GameplayTagUtilities_structs.hpp"
#include "DBDCosmetic_classes.hpp"
#include "DBDSharedTypes_structs.hpp"


namespace SDK
{

// Class TheK28.Addon_K28Power_04
// 0x0000 (0x02B8 - 0x02B8)
class UAddon_K28Power_04 final : public UItemAddon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K28Power_04">();
	}
	static class UAddon_K28Power_04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K28Power_04>();
	}
};
static_assert(alignof(UAddon_K28Power_04) == 0x000008, "Wrong alignment on UAddon_K28Power_04");
static_assert(sizeof(UAddon_K28Power_04) == 0x0002B8, "Wrong size on UAddon_K28Power_04");

// Class TheK28.Addon_K28Power_15
// 0x0018 (0x02E0 - 0x02C8)
class UAddon_K28Power_15 final : public UOnEventBaseAddon
{
public:
	TArray<TSubclassOf<class UStatusEffect>>      _survivorImposedEffectClasses;                     // 0x02C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         _statusEffectTime;                                 // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K28Power_15">();
	}
	static class UAddon_K28Power_15* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K28Power_15>();
	}
};
static_assert(alignof(UAddon_K28Power_15) == 0x000008, "Wrong alignment on UAddon_K28Power_15");
static_assert(sizeof(UAddon_K28Power_15) == 0x0002E0, "Wrong size on UAddon_K28Power_15");
static_assert(offsetof(UAddon_K28Power_15, _survivorImposedEffectClasses) == 0x0002C8, "Member 'UAddon_K28Power_15::_survivorImposedEffectClasses' has a wrong offset!");
static_assert(offsetof(UAddon_K28Power_15, _statusEffectTime) == 0x0002D8, "Member 'UAddon_K28Power_15::_statusEffectTime' has a wrong offset!");

// Class TheK28.Addon_K28Power_16
// 0x0000 (0x02C8 - 0x02C8)
class UAddon_K28Power_16 final : public UOnEventBaseAddon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K28Power_16">();
	}
	static class UAddon_K28Power_16* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K28Power_16>();
	}
};
static_assert(alignof(UAddon_K28Power_16) == 0x000008, "Wrong alignment on UAddon_K28Power_16");
static_assert(sizeof(UAddon_K28Power_16) == 0x0002C8, "Wrong size on UAddon_K28Power_16");

// Class TheK28.Addon_K28Power_17
// 0x0010 (0x02D8 - 0x02C8)
class UAddon_K28Power_17 final : public UOnEventBaseAddon
{
public:
	TSubclassOf<class UStatusEffect>              _survivorImposedEffectClass;                       // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _statusEffectDuration;                             // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnIntroComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K28Power_17">();
	}
	static class UAddon_K28Power_17* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K28Power_17>();
	}
};
static_assert(alignof(UAddon_K28Power_17) == 0x000008, "Wrong alignment on UAddon_K28Power_17");
static_assert(sizeof(UAddon_K28Power_17) == 0x0002D8, "Wrong size on UAddon_K28Power_17");
static_assert(offsetof(UAddon_K28Power_17, _survivorImposedEffectClass) == 0x0002C8, "Member 'UAddon_K28Power_17::_survivorImposedEffectClass' has a wrong offset!");
static_assert(offsetof(UAddon_K28Power_17, _statusEffectDuration) == 0x0002D0, "Member 'UAddon_K28Power_17::_statusEffectDuration' has a wrong offset!");

// Class TheK28.Addon_K28Power_18
// 0x0038 (0x0300 - 0x02C8)
class UAddon_K28Power_18 final : public UOnEventBaseAddon
{
public:
	TSubclassOf<class UStatusEffect>              _survivorImposedEffectClass;                       // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorStatusEffectTime;                         // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lockersToSlamRange;                               // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _montage;                                          // 0x02D8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_TriggerLockerAnimationOnAllLockers(const TArray<class ALocker*>& lockers);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K28Power_18">();
	}
	static class UAddon_K28Power_18* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K28Power_18>();
	}
};
static_assert(alignof(UAddon_K28Power_18) == 0x000008, "Wrong alignment on UAddon_K28Power_18");
static_assert(sizeof(UAddon_K28Power_18) == 0x000300, "Wrong size on UAddon_K28Power_18");
static_assert(offsetof(UAddon_K28Power_18, _survivorImposedEffectClass) == 0x0002C8, "Member 'UAddon_K28Power_18::_survivorImposedEffectClass' has a wrong offset!");
static_assert(offsetof(UAddon_K28Power_18, _survivorStatusEffectTime) == 0x0002D0, "Member 'UAddon_K28Power_18::_survivorStatusEffectTime' has a wrong offset!");
static_assert(offsetof(UAddon_K28Power_18, _lockersToSlamRange) == 0x0002D4, "Member 'UAddon_K28Power_18::_lockersToSlamRange' has a wrong offset!");
static_assert(offsetof(UAddon_K28Power_18, _montage) == 0x0002D8, "Member 'UAddon_K28Power_18::_montage' has a wrong offset!");

// Class TheK28.Addon_K28Power_19
// 0x0020 (0x02E8 - 0x02C8)
class UAddon_K28Power_19 final : public UOnEventBaseAddon
{
public:
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _blockingRadius;                                   // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _blockDuration;                                    // 0x02DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K28Power_19">();
	}
	static class UAddon_K28Power_19* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K28Power_19>();
	}
};
static_assert(alignof(UAddon_K28Power_19) == 0x000008, "Wrong alignment on UAddon_K28Power_19");
static_assert(sizeof(UAddon_K28Power_19) == 0x0002E8, "Wrong size on UAddon_K28Power_19");
static_assert(offsetof(UAddon_K28Power_19, _blockingRadius) == 0x0002D8, "Member 'UAddon_K28Power_19::_blockingRadius' has a wrong offset!");
static_assert(offsetof(UAddon_K28Power_19, _blockDuration) == 0x0002DC, "Member 'UAddon_K28Power_19::_blockDuration' has a wrong offset!");

// Class TheK28.Addon_K28Power_20
// 0x0090 (0x0348 - 0x02B8)
class UAddon_K28Power_20 final : public UItemAddon
{
public:
	TSubclassOf<class UStatusEffect>              _survivorImposedEffectClass;                       // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _effectDuration;                                   // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4[0x84];                                     // 0x02C4(0x0084)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K28Power_20">();
	}
	static class UAddon_K28Power_20* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K28Power_20>();
	}
};
static_assert(alignof(UAddon_K28Power_20) == 0x000008, "Wrong alignment on UAddon_K28Power_20");
static_assert(sizeof(UAddon_K28Power_20) == 0x000348, "Wrong size on UAddon_K28Power_20");
static_assert(offsetof(UAddon_K28Power_20, _survivorImposedEffectClass) == 0x0002B8, "Member 'UAddon_K28Power_20::_survivorImposedEffectClass' has a wrong offset!");
static_assert(offsetof(UAddon_K28Power_20, _effectDuration) == 0x0002C0, "Member 'UAddon_K28Power_20::_effectDuration' has a wrong offset!");

// Class TheK28.AISkill_FindInteractable_Lockbar
// 0x0118 (0x0240 - 0x0128)
class UAISkill_FindInteractable_Lockbar final : public UAISkill_FindInteractable
{
public:
	float                                         LockerCenterHeightDiffFromActorLocation;           // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    LockbarMaxDistanceFromCamper;                      // 0x012C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    LockbarMaxDistanceFromCamperTolerance;             // 0x013C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MinLockbarWeight;                                  // 0x014C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxLockbarWeight;                                  // 0x015C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    HighLockbarWeightLastSeconds;                      // 0x016C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MinDistanceToReachMaxLockbarWeight;                // 0x017C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxDistanceToReachMinLockbarWeight;                // 0x018C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C[0xA4];                                     // 0x019C(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_Lockbar">();
	}
	static class UAISkill_FindInteractable_Lockbar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_Lockbar>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_Lockbar) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_Lockbar");
static_assert(sizeof(UAISkill_FindInteractable_Lockbar) == 0x000240, "Wrong size on UAISkill_FindInteractable_Lockbar");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, LockerCenterHeightDiffFromActorLocation) == 0x000128, "Member 'UAISkill_FindInteractable_Lockbar::LockerCenterHeightDiffFromActorLocation' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, LockbarMaxDistanceFromCamper) == 0x00012C, "Member 'UAISkill_FindInteractable_Lockbar::LockbarMaxDistanceFromCamper' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, LockbarMaxDistanceFromCamperTolerance) == 0x00013C, "Member 'UAISkill_FindInteractable_Lockbar::LockbarMaxDistanceFromCamperTolerance' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, MinLockbarWeight) == 0x00014C, "Member 'UAISkill_FindInteractable_Lockbar::MinLockbarWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, MaxLockbarWeight) == 0x00015C, "Member 'UAISkill_FindInteractable_Lockbar::MaxLockbarWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, HighLockbarWeightLastSeconds) == 0x00016C, "Member 'UAISkill_FindInteractable_Lockbar::HighLockbarWeightLastSeconds' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, MinDistanceToReachMaxLockbarWeight) == 0x00017C, "Member 'UAISkill_FindInteractable_Lockbar::MinDistanceToReachMaxLockbarWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Lockbar, MaxDistanceToReachMinLockbarWeight) == 0x00018C, "Member 'UAISkill_FindInteractable_Lockbar::MaxDistanceToReachMinLockbarWeight' has a wrong offset!");

// Class TheK28.BTService_FindObject_K28Remnant
// 0x0008 (0x00C8 - 0x00C0)
class UBTService_FindObject_K28Remnant final : public UBTService_FindObject
{
public:
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindObject_K28Remnant">();
	}
	static class UBTService_FindObject_K28Remnant* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindObject_K28Remnant>();
	}
};
static_assert(alignof(UBTService_FindObject_K28Remnant) == 0x000008, "Wrong alignment on UBTService_FindObject_K28Remnant");
static_assert(sizeof(UBTService_FindObject_K28Remnant) == 0x0000C8, "Wrong size on UBTService_FindObject_K28Remnant");

// Class TheK28.K28TeleportTarget
// 0x0000 (0x0000 - 0x0000)
class IK28TeleportTarget final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28TeleportTarget">();
	}
	static class IK28TeleportTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IK28TeleportTarget>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IK28TeleportTarget) == 0x000001, "Wrong alignment on IK28TeleportTarget");
static_assert(sizeof(IK28TeleportTarget) == 0x000001, "Wrong size on IK28TeleportTarget");

// Class TheK28.IsInRangeOfK28UsedLocker
// 0x0038 (0x0128 - 0x00F0)
class UIsInRangeOfK28UsedLocker final : public URangeBasedCondition
{
public:
	uint8                                         Pad_F0[0x38];                                      // 0x00F0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsInRangeOfK28UsedLocker">();
	}
	static class UIsInRangeOfK28UsedLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsInRangeOfK28UsedLocker>();
	}
};
static_assert(alignof(UIsInRangeOfK28UsedLocker) == 0x000008, "Wrong alignment on UIsInRangeOfK28UsedLocker");
static_assert(sizeof(UIsInRangeOfK28UsedLocker) == 0x000128, "Wrong size on UIsInRangeOfK28UsedLocker");

// Class TheK28.K28AnimInstance
// 0x0040 (0x0640 - 0x0600)
class UK28AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isInLocker;                                       // 0x0600(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInChase;                                        // 0x0601(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingTeleportation;                          // 0x0602(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasTeleportationPowerCharged;                     // 0x0603(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasTeleportationBeenCancelled;                    // 0x0604(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hideHandsInFPV;                                   // 0x0605(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_606[0x2];                                      // 0x0606(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCustomizationAnimationSelector> _customizationAnimationSelectorClass;         // 0x0608(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomizationAnimationSelector*        _customizationAnimationSelector;                   // 0x0610(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_618[0x28];                                     // 0x0618(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnCustomizationAnimationMappingIDChanged(int32 animationMappingIndex);

	int32 GetAnimationMappingIndex() const;
	TArray<class FName> GetCustomAnimationTags() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28AnimInstance">();
	}
	static class UK28AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28AnimInstance>();
	}
};
static_assert(alignof(UK28AnimInstance) == 0x000010, "Wrong alignment on UK28AnimInstance");
static_assert(sizeof(UK28AnimInstance) == 0x000640, "Wrong size on UK28AnimInstance");
static_assert(offsetof(UK28AnimInstance, _isInLocker) == 0x000600, "Member 'UK28AnimInstance::_isInLocker' has a wrong offset!");
static_assert(offsetof(UK28AnimInstance, _isInChase) == 0x000601, "Member 'UK28AnimInstance::_isInChase' has a wrong offset!");
static_assert(offsetof(UK28AnimInstance, _isChargingTeleportation) == 0x000602, "Member 'UK28AnimInstance::_isChargingTeleportation' has a wrong offset!");
static_assert(offsetof(UK28AnimInstance, _hasTeleportationPowerCharged) == 0x000603, "Member 'UK28AnimInstance::_hasTeleportationPowerCharged' has a wrong offset!");
static_assert(offsetof(UK28AnimInstance, _hasTeleportationBeenCancelled) == 0x000604, "Member 'UK28AnimInstance::_hasTeleportationBeenCancelled' has a wrong offset!");
static_assert(offsetof(UK28AnimInstance, _hideHandsInFPV) == 0x000605, "Member 'UK28AnimInstance::_hideHandsInFPV' has a wrong offset!");
static_assert(offsetof(UK28AnimInstance, _customizationAnimationSelectorClass) == 0x000608, "Member 'UK28AnimInstance::_customizationAnimationSelectorClass' has a wrong offset!");
static_assert(offsetof(UK28AnimInstance, _customizationAnimationSelector) == 0x000610, "Member 'UK28AnimInstance::_customizationAnimationSelector' has a wrong offset!");

// Class TheK28.K28CheatComponent
// 0x0000 (0x00B8 - 0x00B8)
class UK28CheatComponent final : public UActorComponent
{
public:
	void DBD_K28BreakAllLocks();
	void DBD_K28DebugCosmetics(bool noCooldown);
	void DBD_K28DisplayLockerClusters(float secondsToDisplayDebugElements);
	void DBD_K28LockAllLockbars();
	void DBD_K28SetPowerNoCooldown(bool noCooldown);
	void DBD_K28TriggerNextNightCycle();
	void DBD_K28UnlockAllLockbars();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28CheatComponent">();
	}
	static class UK28CheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28CheatComponent>();
	}
};
static_assert(alignof(UK28CheatComponent) == 0x000008, "Wrong alignment on UK28CheatComponent");
static_assert(sizeof(UK28CheatComponent) == 0x0000B8, "Wrong size on UK28CheatComponent");

// Class TheK28.K28DayNightComponent
// 0x0530 (0x05E8 - 0x00B8)
class UK28DayNightComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x48];                                      // 0x00B8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UK28KillerComponent>        _killerK28ComponentClass;                          // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28SurvivorComponent>      _survivorK28ComponentClass;                        // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _chargesRequiredForNightCharge;                    // 0x0110(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _transitionToNightDuration;                        // 0x0138(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _transitiionToDayDuration;                         // 0x0160(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _chargesRequiredForNightDischarge;                 // 0x0188(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _killerInjuresSurvivorChargeAmount;                // 0x0208(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _killerHookSurvivorChargeAmount;                   // 0x0288(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _killerTeleportsToRemnantChargeAmount;             // 0x0308(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _defaultNightChargeTime;                           // 0x0330(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _injuredSurvivorsChargeTime;                       // 0x03B0(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _killerHidingInLockerChargeTime;                   // 0x0430(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _defaultNightTimeDischargeRate;                    // 0x04B0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _survivorInLockerDischargeRate;                    // 0x04D8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _nighttimeNearingActivationThresholdPercent;       // 0x0500(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _nightCycleNearingEndThresholdPercent;             // 0x0528(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EK28NightCycleState                           _currentNightCycleState;                           // 0x0550(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_551[0x1F];                                     // 0x0551(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _authority_numberInjuredSurvivors;                 // 0x0570(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxChargeAmount;                                  // 0x0574(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _currentChargeAmount;                              // 0x0578(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_57C[0x35];                                     // 0x057C(0x0035)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _nighttimeNearingActivationThresholdReached;       // 0x05B1(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasReachedNightCycleNearEndThreshold;             // 0x05B2(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B3[0x35];                                     // 0x05B3(0x0035)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnIntroCompleted();
	void Authority_OnSurvivorDamageStateChanged(ECamperDamageState previousDamageState, ECamperDamageState newDamageState);
	void Cosmetic_OnIsInLastTwentySecondsOfNightCycle(class UAkComponent* akComponent);
	void Cosmetic_OnNightCycleChanged(class UAkComponent* akComponent, EK28NightCycleState newNightCycleState);
	void OnRep_CurrentDayNightCycle();
	void OnRep_HasReachedNightCycleNearEndThreshold();
	void OnRep_NighttimeNearingActivation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28DayNightComponent">();
	}
	static class UK28DayNightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28DayNightComponent>();
	}
};
static_assert(alignof(UK28DayNightComponent) == 0x000008, "Wrong alignment on UK28DayNightComponent");
static_assert(sizeof(UK28DayNightComponent) == 0x0005E8, "Wrong size on UK28DayNightComponent");
static_assert(offsetof(UK28DayNightComponent, _killerK28ComponentClass) == 0x000100, "Member 'UK28DayNightComponent::_killerK28ComponentClass' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _survivorK28ComponentClass) == 0x000108, "Member 'UK28DayNightComponent::_survivorK28ComponentClass' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _chargesRequiredForNightCharge) == 0x000110, "Member 'UK28DayNightComponent::_chargesRequiredForNightCharge' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _transitionToNightDuration) == 0x000138, "Member 'UK28DayNightComponent::_transitionToNightDuration' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _transitiionToDayDuration) == 0x000160, "Member 'UK28DayNightComponent::_transitiionToDayDuration' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _chargesRequiredForNightDischarge) == 0x000188, "Member 'UK28DayNightComponent::_chargesRequiredForNightDischarge' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _killerInjuresSurvivorChargeAmount) == 0x000208, "Member 'UK28DayNightComponent::_killerInjuresSurvivorChargeAmount' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _killerHookSurvivorChargeAmount) == 0x000288, "Member 'UK28DayNightComponent::_killerHookSurvivorChargeAmount' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _killerTeleportsToRemnantChargeAmount) == 0x000308, "Member 'UK28DayNightComponent::_killerTeleportsToRemnantChargeAmount' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _defaultNightChargeTime) == 0x000330, "Member 'UK28DayNightComponent::_defaultNightChargeTime' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _injuredSurvivorsChargeTime) == 0x0003B0, "Member 'UK28DayNightComponent::_injuredSurvivorsChargeTime' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _killerHidingInLockerChargeTime) == 0x000430, "Member 'UK28DayNightComponent::_killerHidingInLockerChargeTime' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _defaultNightTimeDischargeRate) == 0x0004B0, "Member 'UK28DayNightComponent::_defaultNightTimeDischargeRate' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _survivorInLockerDischargeRate) == 0x0004D8, "Member 'UK28DayNightComponent::_survivorInLockerDischargeRate' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _nighttimeNearingActivationThresholdPercent) == 0x000500, "Member 'UK28DayNightComponent::_nighttimeNearingActivationThresholdPercent' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _nightCycleNearingEndThresholdPercent) == 0x000528, "Member 'UK28DayNightComponent::_nightCycleNearingEndThresholdPercent' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _currentNightCycleState) == 0x000550, "Member 'UK28DayNightComponent::_currentNightCycleState' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _authority_numberInjuredSurvivors) == 0x000570, "Member 'UK28DayNightComponent::_authority_numberInjuredSurvivors' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _maxChargeAmount) == 0x000574, "Member 'UK28DayNightComponent::_maxChargeAmount' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _currentChargeAmount) == 0x000578, "Member 'UK28DayNightComponent::_currentChargeAmount' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _nighttimeNearingActivationThresholdReached) == 0x0005B1, "Member 'UK28DayNightComponent::_nighttimeNearingActivationThresholdReached' has a wrong offset!");
static_assert(offsetof(UK28DayNightComponent, _hasReachedNightCycleNearEndThreshold) == 0x0005B2, "Member 'UK28DayNightComponent::_hasReachedNightCycleNearEndThreshold' has a wrong offset!");

// Class TheK28.K28FXInterface
// 0x0000 (0x0000 - 0x0000)
class IK28FXInterface final
{
public:
	void Cosmetic_OnChargeTeleportCancelled();
	void Cosmetic_OnChargeTeleportComplete();
	void Cosmetic_OnChargeTeleportStart();
	void Cosmetic_OnHideKiller();
	void Cosmetic_OnIsKillingSurvivorWithMoriStateChanged(bool isKillingSurvivorWithMori);
	void Cosmetic_OnKillerEnterLocker();
	void Cosmetic_OnLocallyObservedChanged();
	void Cosmetic_OnLockerTeleportTargetHighlighted();
	void Cosmetic_OnShowKiller(bool isInstantShow);
	void Cosmetic_OnTeleportationToLockerEnd();
	void Cosmetic_OnTeleportationToLockerStart(float teleportationDuration, bool isKillerAlreadyHidingInLocker);
	void Cosmetic_OnTeleportCooldownEnded();
	void Cosmetic_SetBlackMaterialOnKiller(bool blackMaterialApplied);
	void Cosmetic_SetDebugCosmetics(bool isDebugCosmeticsActive);
	void Cosmetic_TriggerFadeIn();
	void Cosmetic_TriggerFadeOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28FXInterface">();
	}
	static class IK28FXInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IK28FXInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IK28FXInterface) == 0x000001, "Wrong alignment on IK28FXInterface");
static_assert(sizeof(IK28FXInterface) == 0x000001, "Wrong size on IK28FXInterface");

// Class TheK28.K28IsNightCycleState
// 0x0010 (0x00F8 - 0x00E8)
class UK28IsNightCycleState final : public UEventDrivenModifierCondition
{
public:
	EK28NightCycleState                           _nightCycleState;                                  // 0x00E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E9[0xF];                                       // 0x00E9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28IsNightCycleState">();
	}
	static class UK28IsNightCycleState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28IsNightCycleState>();
	}
};
static_assert(alignof(UK28IsNightCycleState) == 0x000008, "Wrong alignment on UK28IsNightCycleState");
static_assert(sizeof(UK28IsNightCycleState) == 0x0000F8, "Wrong size on UK28IsNightCycleState");
static_assert(offsetof(UK28IsNightCycleState, _nightCycleState) == 0x0000E8, "Member 'UK28IsNightCycleState::_nightCycleState' has a wrong offset!");

// Class TheK28.K28PlayerComponent
// 0x00B8 (0x0170 - 0x00B8)
class UK28PlayerComponent : public UActorComponent
{
public:
	TWeakObjectPtr<class UK28DayNightComponent>   _dayNightComponent;                                // 0x00B8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _nightEffectMinimumDistance;                       // 0x00C0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _nightEffectMaximumDistance;                       // 0x00E8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x60];                                     // 0x0110(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_DayNightComponent();
	void OnSurvivorInRangeChanged(const bool inRange, class ACamperPlayer* player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28PlayerComponent">();
	}
	static class UK28PlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28PlayerComponent>();
	}
};
static_assert(alignof(UK28PlayerComponent) == 0x000008, "Wrong alignment on UK28PlayerComponent");
static_assert(sizeof(UK28PlayerComponent) == 0x000170, "Wrong size on UK28PlayerComponent");
static_assert(offsetof(UK28PlayerComponent, _dayNightComponent) == 0x0000B8, "Member 'UK28PlayerComponent::_dayNightComponent' has a wrong offset!");
static_assert(offsetof(UK28PlayerComponent, _nightEffectMinimumDistance) == 0x0000C0, "Member 'UK28PlayerComponent::_nightEffectMinimumDistance' has a wrong offset!");
static_assert(offsetof(UK28PlayerComponent, _nightEffectMaximumDistance) == 0x0000E8, "Member 'UK28PlayerComponent::_nightEffectMaximumDistance' has a wrong offset!");

// Class TheK28.K28KillerComponent
// 0x0008 (0x0178 - 0x0170)
class UK28KillerComponent final : public UK28PlayerComponent
{
public:
	uint8                                         Pad_170[0x8];                                      // 0x0170(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnNightCycleStateChanged(class ASlasherPlayer* killer, EK28NightCycleState dayNightCycleState);
	void Cosmetic_OnNighttimeNearingActivation(class ASlasherPlayer* killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerComponent">();
	}
	static class UK28KillerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerComponent>();
	}
};
static_assert(alignof(UK28KillerComponent) == 0x000008, "Wrong alignment on UK28KillerComponent");
static_assert(sizeof(UK28KillerComponent) == 0x000178, "Wrong size on UK28KillerComponent");

// Class TheK28.K28KillerEnterLockerInteraction
// 0x0030 (0x0680 - 0x0650)
class UK28KillerEnterLockerInteraction final : public UBaseLockerInteraction
{
public:
	float                                         _hideKillerTimePercentage;                         // 0x0648(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64C[0x34];                                     // 0x064C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsKillerAllowedToEnterLocker(const class ADBDPlayer* player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerEnterLockerInteraction">();
	}
	static class UK28KillerEnterLockerInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerEnterLockerInteraction>();
	}
};
static_assert(alignof(UK28KillerEnterLockerInteraction) == 0x000010, "Wrong alignment on UK28KillerEnterLockerInteraction");
static_assert(sizeof(UK28KillerEnterLockerInteraction) == 0x000680, "Wrong size on UK28KillerEnterLockerInteraction");
static_assert(offsetof(UK28KillerEnterLockerInteraction, _hideKillerTimePercentage) == 0x000648, "Member 'UK28KillerEnterLockerInteraction::_hideKillerTimePercentage' has a wrong offset!");

// Class TheK28.K28KillerExitLockerInteraction
// 0x00B0 (0x0700 - 0x0650)
class UK28KillerExitLockerInteraction : public UBaseLockerInteraction
{
public:
	EK28ExitLockerCameraBehaviour                 _cameraBehaviour;                                  // 0x0648(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_649[0x7];                                      // 0x0649(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _timeSearchLockerInteractionBlocked;               // 0x0650(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDotProductFadeOutThreshold;                    // 0x0678(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _rotationMaxTime;                                  // 0x067C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fadeOutTime;                                      // 0x0680(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fovChangeTime;                                    // 0x0684(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _fovChangeTeleportationCurve;                      // 0x0688(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_690[0x70];                                     // 0x0690(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerExitLockerInteraction">();
	}
	static class UK28KillerExitLockerInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerExitLockerInteraction>();
	}
};
static_assert(alignof(UK28KillerExitLockerInteraction) == 0x000010, "Wrong alignment on UK28KillerExitLockerInteraction");
static_assert(sizeof(UK28KillerExitLockerInteraction) == 0x000700, "Wrong size on UK28KillerExitLockerInteraction");
static_assert(offsetof(UK28KillerExitLockerInteraction, _cameraBehaviour) == 0x000648, "Member 'UK28KillerExitLockerInteraction::_cameraBehaviour' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockerInteraction, _timeSearchLockerInteractionBlocked) == 0x000650, "Member 'UK28KillerExitLockerInteraction::_timeSearchLockerInteractionBlocked' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockerInteraction, _minDotProductFadeOutThreshold) == 0x000678, "Member 'UK28KillerExitLockerInteraction::_minDotProductFadeOutThreshold' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockerInteraction, _rotationMaxTime) == 0x00067C, "Member 'UK28KillerExitLockerInteraction::_rotationMaxTime' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockerInteraction, _fadeOutTime) == 0x000680, "Member 'UK28KillerExitLockerInteraction::_fadeOutTime' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockerInteraction, _fovChangeTime) == 0x000684, "Member 'UK28KillerExitLockerInteraction::_fovChangeTime' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockerInteraction, _fovChangeTeleportationCurve) == 0x000688, "Member 'UK28KillerExitLockerInteraction::_fovChangeTeleportationCurve' has a wrong offset!");

// Class TheK28.K28KillerExitLockedLockerInteraction
// 0x0050 (0x0750 - 0x0700)
class UK28KillerExitLockedLockerInteraction final : public UK28KillerExitLockerInteraction
{
public:
	float                                         _lockbarBreakTimePercentage;                       // 0x0700(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minInteractionTime;                               // 0x0704(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_708[0x48];                                     // 0x0708(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerExitLockedLockerInteraction">();
	}
	static class UK28KillerExitLockedLockerInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerExitLockedLockerInteraction>();
	}
};
static_assert(alignof(UK28KillerExitLockedLockerInteraction) == 0x000010, "Wrong alignment on UK28KillerExitLockedLockerInteraction");
static_assert(sizeof(UK28KillerExitLockedLockerInteraction) == 0x000750, "Wrong size on UK28KillerExitLockedLockerInteraction");
static_assert(offsetof(UK28KillerExitLockedLockerInteraction, _lockbarBreakTimePercentage) == 0x000700, "Member 'UK28KillerExitLockedLockerInteraction::_lockbarBreakTimePercentage' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockedLockerInteraction, _minInteractionTime) == 0x000704, "Member 'UK28KillerExitLockedLockerInteraction::_minInteractionTime' has a wrong offset!");

// Class TheK28.K28KillerExitLockerWithSurvivorInteraction
// 0x00A0 (0x07A0 - 0x0700)
class UK28KillerExitLockerWithSurvivorInteraction final : public UK28KillerExitLockerInteraction
{
public:
	float                                         _waitTimeBeforeSettingIntoCarryState;              // 0x0700(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_704[0xC];                                      // 0x0704(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            _montageFromTeleportation;                         // 0x0710(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _montageFromAbduction;                             // 0x0730(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_750[0x50];                                     // 0x0750(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerExitLockerWithSurvivorInteraction">();
	}
	static class UK28KillerExitLockerWithSurvivorInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerExitLockerWithSurvivorInteraction>();
	}
};
static_assert(alignof(UK28KillerExitLockerWithSurvivorInteraction) == 0x000010, "Wrong alignment on UK28KillerExitLockerWithSurvivorInteraction");
static_assert(sizeof(UK28KillerExitLockerWithSurvivorInteraction) == 0x0007A0, "Wrong size on UK28KillerExitLockerWithSurvivorInteraction");
static_assert(offsetof(UK28KillerExitLockerWithSurvivorInteraction, _waitTimeBeforeSettingIntoCarryState) == 0x000700, "Member 'UK28KillerExitLockerWithSurvivorInteraction::_waitTimeBeforeSettingIntoCarryState' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockerWithSurvivorInteraction, _montageFromTeleportation) == 0x000710, "Member 'UK28KillerExitLockerWithSurvivorInteraction::_montageFromTeleportation' has a wrong offset!");
static_assert(offsetof(UK28KillerExitLockerWithSurvivorInteraction, _montageFromAbduction) == 0x000730, "Member 'UK28KillerExitLockerWithSurvivorInteraction::_montageFromAbduction' has a wrong offset!");

// Class TheK28.K28KillerInstinctEffect
// 0x00D8 (0x0428 - 0x0350)
class UK28KillerInstinctEffect final : public UStatusEffect
{
public:
	struct FTunableStat                           _secondsToLinger;                                  // 0x0350(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxDistanceToApplyRemnantTeleportKillerInstinct;  // 0x03D0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _lingeringEffectClass;                             // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _lingeringEffect;                                  // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x20];                                     // 0x0408(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnKillerInstinctApplicableChanged(bool active);
	void Authority_OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerInstinctEffect">();
	}
	static class UK28KillerInstinctEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerInstinctEffect>();
	}
};
static_assert(alignof(UK28KillerInstinctEffect) == 0x000008, "Wrong alignment on UK28KillerInstinctEffect");
static_assert(sizeof(UK28KillerInstinctEffect) == 0x000428, "Wrong size on UK28KillerInstinctEffect");
static_assert(offsetof(UK28KillerInstinctEffect, _secondsToLinger) == 0x000350, "Member 'UK28KillerInstinctEffect::_secondsToLinger' has a wrong offset!");
static_assert(offsetof(UK28KillerInstinctEffect, _maxDistanceToApplyRemnantTeleportKillerInstinct) == 0x0003D0, "Member 'UK28KillerInstinctEffect::_maxDistanceToApplyRemnantTeleportKillerInstinct' has a wrong offset!");
static_assert(offsetof(UK28KillerInstinctEffect, _lingeringEffectClass) == 0x0003F8, "Member 'UK28KillerInstinctEffect::_lingeringEffectClass' has a wrong offset!");
static_assert(offsetof(UK28KillerInstinctEffect, _lingeringEffect) == 0x000400, "Member 'UK28KillerInstinctEffect::_lingeringEffect' has a wrong offset!");

// Class TheK28.K28KillerLockerComponent
// 0x0150 (0x0208 - 0x00B8)
class UK28KillerLockerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _targetLockerFOV;                                  // 0x00D0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _fovChangeTeleportationCurve;                      // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fovChangeTime;                                    // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FK28KillerLockerState                  _lockerState_replicated;                           // 0x0108(0x0010)(Net, Transient, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0xA0];                                     // 0x0118(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AAnimationFollowerActor>    _extraArmsAnimationFollowerActorClass;             // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AAnimationFollowerActor*                _extraArmsAnimationFollowerActor;                  // 0x01C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeBetweenAttemptTrigger;                        // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D4[0x34];                                     // 0x01D4(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerInLockerChanged(class ADBDPlayer* previousPlayerInLocker, class ADBDPlayer* newPlayerInLocker);
	void OnRep_LockerState_Replicated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerLockerComponent">();
	}
	static class UK28KillerLockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerLockerComponent>();
	}
};
static_assert(alignof(UK28KillerLockerComponent) == 0x000008, "Wrong alignment on UK28KillerLockerComponent");
static_assert(sizeof(UK28KillerLockerComponent) == 0x000208, "Wrong size on UK28KillerLockerComponent");
static_assert(offsetof(UK28KillerLockerComponent, _targetLockerFOV) == 0x0000D0, "Member 'UK28KillerLockerComponent::_targetLockerFOV' has a wrong offset!");
static_assert(offsetof(UK28KillerLockerComponent, _fovChangeTeleportationCurve) == 0x0000F8, "Member 'UK28KillerLockerComponent::_fovChangeTeleportationCurve' has a wrong offset!");
static_assert(offsetof(UK28KillerLockerComponent, _fovChangeTime) == 0x000100, "Member 'UK28KillerLockerComponent::_fovChangeTime' has a wrong offset!");
static_assert(offsetof(UK28KillerLockerComponent, _lockerState_replicated) == 0x000108, "Member 'UK28KillerLockerComponent::_lockerState_replicated' has a wrong offset!");
static_assert(offsetof(UK28KillerLockerComponent, _extraArmsAnimationFollowerActorClass) == 0x0001B8, "Member 'UK28KillerLockerComponent::_extraArmsAnimationFollowerActorClass' has a wrong offset!");
static_assert(offsetof(UK28KillerLockerComponent, _extraArmsAnimationFollowerActor) == 0x0001C0, "Member 'UK28KillerLockerComponent::_extraArmsAnimationFollowerActor' has a wrong offset!");
static_assert(offsetof(UK28KillerLockerComponent, _timeBetweenAttemptTrigger) == 0x0001D0, "Member 'UK28KillerLockerComponent::_timeBetweenAttemptTrigger' has a wrong offset!");

// Class TheK28.K28KillerPlayerViewComponent
// 0x0028 (0x00E0 - 0x00B8)
class UK28KillerPlayerViewComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerPlayerViewComponent">();
	}
	static class UK28KillerPlayerViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerPlayerViewComponent>();
	}
};
static_assert(alignof(UK28KillerPlayerViewComponent) == 0x000008, "Wrong alignment on UK28KillerPlayerViewComponent");
static_assert(sizeof(UK28KillerPlayerViewComponent) == 0x0000E0, "Wrong size on UK28KillerPlayerViewComponent");

// Class TheK28.K28KillerTeleportationComponent
// 0x0230 (0x02E8 - 0x00B8)
class UK28KillerTeleportationComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _teleportationSpeed_DayCycle;                      // 0x00C8(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _teleportationSpeed_NightCycle;                    // 0x0148(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _teleportationTimeForSurvivorGrab;                 // 0x0170(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _survivorPanicInLockerAnimationMontageDescriptor;  // 0x0198(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isTeleporting;                                    // 0x01C8(0x0030)(Net, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _defaultTeleportationCurve;                        // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _grabTeleportationCurve;                           // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0xC8];                                     // 0x0210(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _actorsHiddenDuringTeleport;                       // 0x02D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Local_OnTeleportCollisionOverlapBegin(class UPrimitiveComponent* overlappedComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult);
	void Local_OnTeleportCollisionOverlapEnd(class UPrimitiveComponent* overlappedComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex);
	void Multicast_TeleportToLockerEnd(class UK28LockerComponent* lockerTeleportedTo, class ACamperPlayer* survivorInLocker);
	void Multicast_TeleportToLockerStart(const struct FK28SecondaryCameraMovementData& cameraMovementData, class UK28LockerComponent* lockerBeingTeleportedTo, class ACamperPlayer* survivorToGrab);
	void OnLevelReadyToPlay();
	void OnPlayerFinishedEnteringLocker(class ADBDPlayer* playerThatWasInLocker, class ADBDPlayer* playerNowInLocker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28KillerTeleportationComponent">();
	}
	static class UK28KillerTeleportationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28KillerTeleportationComponent>();
	}
};
static_assert(alignof(UK28KillerTeleportationComponent) == 0x000008, "Wrong alignment on UK28KillerTeleportationComponent");
static_assert(sizeof(UK28KillerTeleportationComponent) == 0x0002E8, "Wrong size on UK28KillerTeleportationComponent");
static_assert(offsetof(UK28KillerTeleportationComponent, _teleportationSpeed_DayCycle) == 0x0000C8, "Member 'UK28KillerTeleportationComponent::_teleportationSpeed_DayCycle' has a wrong offset!");
static_assert(offsetof(UK28KillerTeleportationComponent, _teleportationSpeed_NightCycle) == 0x000148, "Member 'UK28KillerTeleportationComponent::_teleportationSpeed_NightCycle' has a wrong offset!");
static_assert(offsetof(UK28KillerTeleportationComponent, _teleportationTimeForSurvivorGrab) == 0x000170, "Member 'UK28KillerTeleportationComponent::_teleportationTimeForSurvivorGrab' has a wrong offset!");
static_assert(offsetof(UK28KillerTeleportationComponent, _survivorPanicInLockerAnimationMontageDescriptor) == 0x000198, "Member 'UK28KillerTeleportationComponent::_survivorPanicInLockerAnimationMontageDescriptor' has a wrong offset!");
static_assert(offsetof(UK28KillerTeleportationComponent, _isTeleporting) == 0x0001C8, "Member 'UK28KillerTeleportationComponent::_isTeleporting' has a wrong offset!");
static_assert(offsetof(UK28KillerTeleportationComponent, _defaultTeleportationCurve) == 0x000200, "Member 'UK28KillerTeleportationComponent::_defaultTeleportationCurve' has a wrong offset!");
static_assert(offsetof(UK28KillerTeleportationComponent, _grabTeleportationCurve) == 0x000208, "Member 'UK28KillerTeleportationComponent::_grabTeleportationCurve' has a wrong offset!");
static_assert(offsetof(UK28KillerTeleportationComponent, _actorsHiddenDuringTeleport) == 0x0002D8, "Member 'UK28KillerTeleportationComponent::_actorsHiddenDuringTeleport' has a wrong offset!");

// Class TheK28.K28LockAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class UK28LockAnimInstance final : public UAnimInstance
{
public:
	EK28LockbarState                              _lockbarState;                                     // 0x02C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0xF];                                      // 0x02C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28LockAnimInstance">();
	}
	static class UK28LockAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28LockAnimInstance>();
	}
};
static_assert(alignof(UK28LockAnimInstance) == 0x000010, "Wrong alignment on UK28LockAnimInstance");
static_assert(sizeof(UK28LockAnimInstance) == 0x0002D0, "Wrong size on UK28LockAnimInstance");
static_assert(offsetof(UK28LockAnimInstance, _lockbarState) == 0x0002C0, "Member 'UK28LockAnimInstance::_lockbarState' has a wrong offset!");

// Class TheK28.K28Lockbar
// 0x0078 (0x02C0 - 0x0248)
class AK28Lockbar final : public ABaseLockerItem
{
public:
	EK28LockbarState                              _state;                                            // 0x0248(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            _lockbarStaticMesh;                                // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent;                            // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   _staticLockMesh;                                   // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _boxComponent;                                     // 0x0268(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseActorAttackableComponent*          _lockAttackableComponent;                          // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationMontageSlave*                 _animationMontageSlave;                            // 0x0280(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTagStateBool                          _isLocked;                                         // 0x0288(0x0030)(Net, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnStateChanged(EK28LockbarState newState);
	void Cosmetic_SetLockbarHighlightActivationState(bool isHightlightActive);
	void Cosmetic_TriggerLockbarBreak();
	void OnLocallyObservedChanged();
	void OnPlayerInLockerChanged(class ADBDPlayer* previousPlayerInLocker, class ADBDPlayer* newPlayerInLocker);
	void OnRep_State();

	class UMontagePlayer* GetMontagePlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28Lockbar">();
	}
	static class AK28Lockbar* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK28Lockbar>();
	}
};
static_assert(alignof(AK28Lockbar) == 0x000008, "Wrong alignment on AK28Lockbar");
static_assert(sizeof(AK28Lockbar) == 0x0002C0, "Wrong size on AK28Lockbar");
static_assert(offsetof(AK28Lockbar, _state) == 0x000248, "Member 'AK28Lockbar::_state' has a wrong offset!");
static_assert(offsetof(AK28Lockbar, _lockbarStaticMesh) == 0x000250, "Member 'AK28Lockbar::_lockbarStaticMesh' has a wrong offset!");
static_assert(offsetof(AK28Lockbar, _skeletalMeshComponent) == 0x000258, "Member 'AK28Lockbar::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AK28Lockbar, _staticLockMesh) == 0x000260, "Member 'AK28Lockbar::_staticLockMesh' has a wrong offset!");
static_assert(offsetof(AK28Lockbar, _boxComponent) == 0x000268, "Member 'AK28Lockbar::_boxComponent' has a wrong offset!");
static_assert(offsetof(AK28Lockbar, _lockAttackableComponent) == 0x000270, "Member 'AK28Lockbar::_lockAttackableComponent' has a wrong offset!");
static_assert(offsetof(AK28Lockbar, _montagePlayer) == 0x000278, "Member 'AK28Lockbar::_montagePlayer' has a wrong offset!");
static_assert(offsetof(AK28Lockbar, _animationMontageSlave) == 0x000280, "Member 'AK28Lockbar::_animationMontageSlave' has a wrong offset!");
static_assert(offsetof(AK28Lockbar, _isLocked) == 0x000288, "Member 'AK28Lockbar::_isLocked' has a wrong offset!");

// Class TheK28.K28LockerComponent
// 0x0250 (0x0308 - 0x00B8)
class UK28LockerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AK28LockerCosmeticHelperActor*          _lockerCosmeticHelper;                             // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WarningSoundTimeInterval;                          // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WarningSoundRange;                                 // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _timeToTriggerWarningReveal;                       // 0x00E8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minDistanceFromHookedSurvivor;                    // 0x0110(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minDistanceFromKillerForTeleportationEligibility; // 0x0138(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _lockerShakeTeleportAnimation;                     // 0x0160(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _lockerTeleportCompletedAnimation;                 // 0x0180(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _lockerTeleportationAbductionAnimation;            // 0x01A0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UBaseLockerInteraction>> _lockerInteractionClasses;                     // 0x01C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK28LockerCosmeticHelperActor> _lockerCosmeticHelperClass;                     // 0x01D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28SurvivorLockerAbductionInteraction> _lockerGrabOverridingClass;            // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UBaseLockerInteraction>> _lockerInteractionClassesToOverride;           // 0x01E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FCustomLockerOutlineOverride>   _lockedOutlineOverrides;                           // 0x01F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _maxSqrtDistanceForCluster;                        // 0x0200(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDotProductForCluster;                          // 0x0204(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _lockerLineTraceOffset;                            // 0x0208(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_214[0xD0];                                     // 0x0214(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _abductionCameraOffset;                            // 0x02E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x18];                                     // 0x02E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ASlasherPlayer*                         _killer;                                           // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28LockerComponent">();
	}
	static class UK28LockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28LockerComponent>();
	}
};
static_assert(alignof(UK28LockerComponent) == 0x000008, "Wrong alignment on UK28LockerComponent");
static_assert(sizeof(UK28LockerComponent) == 0x000308, "Wrong size on UK28LockerComponent");
static_assert(offsetof(UK28LockerComponent, _lockerCosmeticHelper) == 0x0000D0, "Member 'UK28LockerComponent::_lockerCosmeticHelper' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, WarningSoundTimeInterval) == 0x0000E0, "Member 'UK28LockerComponent::WarningSoundTimeInterval' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, WarningSoundRange) == 0x0000E4, "Member 'UK28LockerComponent::WarningSoundRange' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _timeToTriggerWarningReveal) == 0x0000E8, "Member 'UK28LockerComponent::_timeToTriggerWarningReveal' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _minDistanceFromHookedSurvivor) == 0x000110, "Member 'UK28LockerComponent::_minDistanceFromHookedSurvivor' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _minDistanceFromKillerForTeleportationEligibility) == 0x000138, "Member 'UK28LockerComponent::_minDistanceFromKillerForTeleportationEligibility' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockerShakeTeleportAnimation) == 0x000160, "Member 'UK28LockerComponent::_lockerShakeTeleportAnimation' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockerTeleportCompletedAnimation) == 0x000180, "Member 'UK28LockerComponent::_lockerTeleportCompletedAnimation' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockerTeleportationAbductionAnimation) == 0x0001A0, "Member 'UK28LockerComponent::_lockerTeleportationAbductionAnimation' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockerInteractionClasses) == 0x0001C0, "Member 'UK28LockerComponent::_lockerInteractionClasses' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockerCosmeticHelperClass) == 0x0001D0, "Member 'UK28LockerComponent::_lockerCosmeticHelperClass' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockerGrabOverridingClass) == 0x0001D8, "Member 'UK28LockerComponent::_lockerGrabOverridingClass' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockerInteractionClassesToOverride) == 0x0001E0, "Member 'UK28LockerComponent::_lockerInteractionClassesToOverride' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockedOutlineOverrides) == 0x0001F0, "Member 'UK28LockerComponent::_lockedOutlineOverrides' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _maxSqrtDistanceForCluster) == 0x000200, "Member 'UK28LockerComponent::_maxSqrtDistanceForCluster' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _minDotProductForCluster) == 0x000204, "Member 'UK28LockerComponent::_minDotProductForCluster' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _lockerLineTraceOffset) == 0x000208, "Member 'UK28LockerComponent::_lockerLineTraceOffset' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _abductionCameraOffset) == 0x0002E4, "Member 'UK28LockerComponent::_abductionCameraOffset' has a wrong offset!");
static_assert(offsetof(UK28LockerComponent, _killer) == 0x000300, "Member 'UK28LockerComponent::_killer' has a wrong offset!");

// Class TheK28.K28LockerCosmeticHelperActor
// 0x0018 (0x0248 - 0x0230)
class AK28LockerCosmeticHelperActor final : public AActor
{
public:
	uint8                                         Pad_230[0x18];                                     // 0x0230(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnKillerEnteredLocker();
	void Cosmetic_OnKillerExitLocker();
	void Cosmetic_OnKillerInsideLockerRevealed();
	void Cosmetic_OnKillerTeleportationToLockerEnd();
	void Cosmetic_OnKillerTeleportationToLockerStart();
	void Cosmetic_OnLockedStateChanged(bool isLockerLocked);
	void Cosmetic_OnLockerGrabStateChanged(bool isLockerGrabOngoing);
	void OnAssociatedLockerActorSet();

	class ALocker* GetLocker() const;
	class UMaterialHelper* GetMaterialHelper() const;
	class USkeletalMeshComponent* GetSkeletalMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28LockerCosmeticHelperActor">();
	}
	static class AK28LockerCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK28LockerCosmeticHelperActor>();
	}
};
static_assert(alignof(AK28LockerCosmeticHelperActor) == 0x000008, "Wrong alignment on AK28LockerCosmeticHelperActor");
static_assert(sizeof(AK28LockerCosmeticHelperActor) == 0x000248, "Wrong size on AK28LockerCosmeticHelperActor");

// Class TheK28.K28LockerEntitySpikesUpdateStrategy
// 0x0018 (0x00D8 - 0x00C0)
class UK28LockerEntitySpikesUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _outlineColor;                                     // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28LockerEntitySpikesUpdateStrategy">();
	}
	static class UK28LockerEntitySpikesUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28LockerEntitySpikesUpdateStrategy>();
	}
};
static_assert(alignof(UK28LockerEntitySpikesUpdateStrategy) == 0x000008, "Wrong alignment on UK28LockerEntitySpikesUpdateStrategy");
static_assert(sizeof(UK28LockerEntitySpikesUpdateStrategy) == 0x0000D8, "Wrong size on UK28LockerEntitySpikesUpdateStrategy");
static_assert(offsetof(UK28LockerEntitySpikesUpdateStrategy, _outlineColor) == 0x0000C0, "Member 'UK28LockerEntitySpikesUpdateStrategy::_outlineColor' has a wrong offset!");

// Class TheK28.K28LockerTeleportSwapInteraction
// 0x0020 (0x0640 - 0x0620)
class UK28LockerTeleportSwapInteraction final : public UInteractionDefinition
{
public:
	uint8                                         Pad_618[0x28];                                     // 0x0618(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_CompleteTeleportation();
	void Multicast_ConfirmTeleportationRequest(class ASlasherPlayer* killer, class UActorComponent* teleportTarget);
	void Multicast_RefuseTeleportationRequest();
	void Server_RequestTeleportToTarget(class ASlasherPlayer* killer, class UActorComponent* teleportTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28LockerTeleportSwapInteraction">();
	}
	static class UK28LockerTeleportSwapInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28LockerTeleportSwapInteraction>();
	}
};
static_assert(alignof(UK28LockerTeleportSwapInteraction) == 0x000010, "Wrong alignment on UK28LockerTeleportSwapInteraction");
static_assert(sizeof(UK28LockerTeleportSwapInteraction) == 0x000640, "Wrong size on UK28LockerTeleportSwapInteraction");

// Class TheK28.K28LockLockbarInteraction
// 0x0000 (0x0650 - 0x0650)
class UK28LockLockbarInteraction final : public UBaseLockerInteraction
{
public:
	float                                         _survivorAlignementTolerance;                      // 0x0648(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64C[0x4];                                      // 0x064C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28LockLockbarInteraction">();
	}
	static class UK28LockLockbarInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28LockLockbarInteraction>();
	}
};
static_assert(alignof(UK28LockLockbarInteraction) == 0x000010, "Wrong alignment on UK28LockLockbarInteraction");
static_assert(sizeof(UK28LockLockbarInteraction) == 0x000650, "Wrong size on UK28LockLockbarInteraction");
static_assert(offsetof(UK28LockLockbarInteraction, _survivorAlignementTolerance) == 0x000648, "Member 'UK28LockLockbarInteraction::_survivorAlignementTolerance' has a wrong offset!");

// Class TheK28.K28MenuAnimInstance
// 0x0010 (0x0310 - 0x0300)
class UK28MenuAnimInstance final : public UBaseMenuAnimInstance
{
public:
	TSubclassOf<class UCustomizationAnimationSelector> _customizationAnimationSelectorClass;         // 0x02F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomizationAnimationSelector*        _customizationAnimationSelector;                   // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnCustomizationAnimationMappingIDChanged(int32 animationMappingIndex);

	int32 GetAnimationMappingIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28MenuAnimInstance">();
	}
	static class UK28MenuAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28MenuAnimInstance>();
	}
};
static_assert(alignof(UK28MenuAnimInstance) == 0x000010, "Wrong alignment on UK28MenuAnimInstance");
static_assert(sizeof(UK28MenuAnimInstance) == 0x000310, "Wrong size on UK28MenuAnimInstance");
static_assert(offsetof(UK28MenuAnimInstance, _customizationAnimationSelectorClass) == 0x0002F8, "Member 'UK28MenuAnimInstance::_customizationAnimationSelectorClass' has a wrong offset!");
static_assert(offsetof(UK28MenuAnimInstance, _customizationAnimationSelector) == 0x000300, "Member 'UK28MenuAnimInstance::_customizationAnimationSelector' has a wrong offset!");

// Class TheK28.K28P01
// 0x0030 (0x03F8 - 0x03C8)
class UK28P01 final : public UPerk
{
public:
	float                                         _perkActivationDuration[0x3];                      // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _effectClass;                                      // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _injuryTimerDuration;                              // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimerObject*                           _injuryTimer;                                      // 0x03E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x8];                                      // 0x03F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28P01">();
	}
	static class UK28P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28P01>();
	}
};
static_assert(alignof(UK28P01) == 0x000008, "Wrong alignment on UK28P01");
static_assert(sizeof(UK28P01) == 0x0003F8, "Wrong size on UK28P01");
static_assert(offsetof(UK28P01, _perkActivationDuration) == 0x0003C8, "Member 'UK28P01::_perkActivationDuration' has a wrong offset!");
static_assert(offsetof(UK28P01, _effectClass) == 0x0003D8, "Member 'UK28P01::_effectClass' has a wrong offset!");
static_assert(offsetof(UK28P01, _injuryTimerDuration) == 0x0003E0, "Member 'UK28P01::_injuryTimerDuration' has a wrong offset!");
static_assert(offsetof(UK28P01, _injuryTimer) == 0x0003E8, "Member 'UK28P01::_injuryTimer' has a wrong offset!");

// Class TheK28.K28P01Effect
// 0x0008 (0x0358 - 0x0350)
class UK28P01Effect final : public UStatusEffect
{
public:
	class ADBDPlayer*                             _playerOwner;                                      // 0x0350(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28P01Effect">();
	}
	static class UK28P01Effect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28P01Effect>();
	}
};
static_assert(alignof(UK28P01Effect) == 0x000008, "Wrong alignment on UK28P01Effect");
static_assert(sizeof(UK28P01Effect) == 0x000358, "Wrong size on UK28P01Effect");
static_assert(offsetof(UK28P01Effect, _playerOwner) == 0x000350, "Member 'UK28P01Effect::_playerOwner' has a wrong offset!");

// Class TheK28.K28P02
// 0x0010 (0x03D8 - 0x03C8)
class UK28P02 final : public UPerk
{
public:
	float                                         PerkActivationTime;                                // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LockerDetectionRadius;                             // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D0[0x8];                                      // 0x03D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetLockerDetectionRadius() const;
	float GetPerkActivationTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28P02">();
	}
	static class UK28P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28P02>();
	}
};
static_assert(alignof(UK28P02) == 0x000008, "Wrong alignment on UK28P02");
static_assert(sizeof(UK28P02) == 0x0003D8, "Wrong size on UK28P02");
static_assert(offsetof(UK28P02, PerkActivationTime) == 0x0003C8, "Member 'UK28P02::PerkActivationTime' has a wrong offset!");
static_assert(offsetof(UK28P02, LockerDetectionRadius) == 0x0003CC, "Member 'UK28P02::LockerDetectionRadius' has a wrong offset!");

// Class TheK28.K28Power
// 0x0370 (0x0820 - 0x04B0)
class AK28Power final : public ACollectable
{
public:
	uint8                                         Pad_4B0[0x10];                                     // 0x04B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractor*                            _interactor;                                       // 0x04C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPowerChargeComponent*                  _powerChargeComponent;                             // 0x04C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK28PowerChargePresentationPowerFadeComponent* _k28PowerChargePresentationPowerFadeComponent; // 0x04D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK28PowerPresentationItemProgressComponent* _k28PowerPresentationItemProgressComponent;    // 0x04D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28DayNightComponent>      _dayNightComponentClass;                           // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28TeleportationStrategyComponent> _teleportationStrategyComponentClass;      // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28KillerTeleportationComponent> _killerTeleportationComponentClass;          // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28KillerPlayerViewComponent> _killerPlayerViewComponentClass;                // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28KillerLockerComponent>  _killerLockerComponentClass;                       // 0x0500(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK28SecondaryCamera>        _secondaryCameraClass;                             // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK28Remnant>                _k28RemnantClass;                                  // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AAnimationFollowerActor>    _moriArmsAnimationFollowerActorClass;              // 0x0518(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK28SecondaryCamera*                    _secondaryCamera;                                  // 0x0520(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK28KillerLockerComponent*              _killerLockerComponent;                            // 0x0528(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK28Remnant*                            _k28Remnant;                                       // 0x0530(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UStatusEffect>>      _killerStatusEffects;                              // 0x0538(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UStatusEffect>>      _survivorStatusEffects;                            // 0x0548(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28SurvivorAbductionCameraBehaviourComponent> _survivorAbductionCameraBehaviourClass; // 0x0558(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK28DayNightComponent*                  _dayNightComponent;                                // 0x0560(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK28TeleportationStrategyComponent*     _teleportationStrategyComponent;                   // 0x0568(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _tokensWhenPowerIsFullyCharged;                    // 0x0570(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _secondsRequiredToChargePowerStartOfMatch;         // 0x05F0(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _secondsRequiredToChargePowerDayTime;              // 0x0670(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _secondsRequiredToChargePowerNightTime;            // 0x06F0(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxTrackedTimeSinceLockerOrRemnantExit;           // 0x0770(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _teleportTokens;                                   // 0x0798(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79C[0x4];                                      // 0x079C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FK28InteractionPreventingTagsModification> _survivorInteractionsPreventingTagModifications; // 0x07A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7B0[0x68];                                     // 0x07B0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isTunableInit;                                    // 0x0818(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_819[0x7];                                      // 0x0819(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIntroCompleted();
	void OnRep_TeleportTokens();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28Power">();
	}
	static class AK28Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK28Power>();
	}
};
static_assert(alignof(AK28Power) == 0x000008, "Wrong alignment on AK28Power");
static_assert(sizeof(AK28Power) == 0x000820, "Wrong size on AK28Power");
static_assert(offsetof(AK28Power, _interactor) == 0x0004C0, "Member 'AK28Power::_interactor' has a wrong offset!");
static_assert(offsetof(AK28Power, _powerChargeComponent) == 0x0004C8, "Member 'AK28Power::_powerChargeComponent' has a wrong offset!");
static_assert(offsetof(AK28Power, _k28PowerChargePresentationPowerFadeComponent) == 0x0004D0, "Member 'AK28Power::_k28PowerChargePresentationPowerFadeComponent' has a wrong offset!");
static_assert(offsetof(AK28Power, _k28PowerPresentationItemProgressComponent) == 0x0004D8, "Member 'AK28Power::_k28PowerPresentationItemProgressComponent' has a wrong offset!");
static_assert(offsetof(AK28Power, _dayNightComponentClass) == 0x0004E0, "Member 'AK28Power::_dayNightComponentClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _teleportationStrategyComponentClass) == 0x0004E8, "Member 'AK28Power::_teleportationStrategyComponentClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _killerTeleportationComponentClass) == 0x0004F0, "Member 'AK28Power::_killerTeleportationComponentClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _killerPlayerViewComponentClass) == 0x0004F8, "Member 'AK28Power::_killerPlayerViewComponentClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _killerLockerComponentClass) == 0x000500, "Member 'AK28Power::_killerLockerComponentClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _secondaryCameraClass) == 0x000508, "Member 'AK28Power::_secondaryCameraClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _k28RemnantClass) == 0x000510, "Member 'AK28Power::_k28RemnantClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _moriArmsAnimationFollowerActorClass) == 0x000518, "Member 'AK28Power::_moriArmsAnimationFollowerActorClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _secondaryCamera) == 0x000520, "Member 'AK28Power::_secondaryCamera' has a wrong offset!");
static_assert(offsetof(AK28Power, _killerLockerComponent) == 0x000528, "Member 'AK28Power::_killerLockerComponent' has a wrong offset!");
static_assert(offsetof(AK28Power, _k28Remnant) == 0x000530, "Member 'AK28Power::_k28Remnant' has a wrong offset!");
static_assert(offsetof(AK28Power, _killerStatusEffects) == 0x000538, "Member 'AK28Power::_killerStatusEffects' has a wrong offset!");
static_assert(offsetof(AK28Power, _survivorStatusEffects) == 0x000548, "Member 'AK28Power::_survivorStatusEffects' has a wrong offset!");
static_assert(offsetof(AK28Power, _survivorAbductionCameraBehaviourClass) == 0x000558, "Member 'AK28Power::_survivorAbductionCameraBehaviourClass' has a wrong offset!");
static_assert(offsetof(AK28Power, _dayNightComponent) == 0x000560, "Member 'AK28Power::_dayNightComponent' has a wrong offset!");
static_assert(offsetof(AK28Power, _teleportationStrategyComponent) == 0x000568, "Member 'AK28Power::_teleportationStrategyComponent' has a wrong offset!");
static_assert(offsetof(AK28Power, _tokensWhenPowerIsFullyCharged) == 0x000570, "Member 'AK28Power::_tokensWhenPowerIsFullyCharged' has a wrong offset!");
static_assert(offsetof(AK28Power, _secondsRequiredToChargePowerStartOfMatch) == 0x0005F0, "Member 'AK28Power::_secondsRequiredToChargePowerStartOfMatch' has a wrong offset!");
static_assert(offsetof(AK28Power, _secondsRequiredToChargePowerDayTime) == 0x000670, "Member 'AK28Power::_secondsRequiredToChargePowerDayTime' has a wrong offset!");
static_assert(offsetof(AK28Power, _secondsRequiredToChargePowerNightTime) == 0x0006F0, "Member 'AK28Power::_secondsRequiredToChargePowerNightTime' has a wrong offset!");
static_assert(offsetof(AK28Power, _maxTrackedTimeSinceLockerOrRemnantExit) == 0x000770, "Member 'AK28Power::_maxTrackedTimeSinceLockerOrRemnantExit' has a wrong offset!");
static_assert(offsetof(AK28Power, _teleportTokens) == 0x000798, "Member 'AK28Power::_teleportTokens' has a wrong offset!");
static_assert(offsetof(AK28Power, _survivorInteractionsPreventingTagModifications) == 0x0007A0, "Member 'AK28Power::_survivorInteractionsPreventingTagModifications' has a wrong offset!");
static_assert(offsetof(AK28Power, _isTunableInit) == 0x000818, "Member 'AK28Power::_isTunableInit' has a wrong offset!");

// Class TheK28.K28PowerChargePresentationPowerFadeComponent
// 0x0000 (0x00B8 - 0x00B8)
class UK28PowerChargePresentationPowerFadeComponent final : public UPresentationPowerFadeComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28PowerChargePresentationPowerFadeComponent">();
	}
	static class UK28PowerChargePresentationPowerFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28PowerChargePresentationPowerFadeComponent>();
	}
};
static_assert(alignof(UK28PowerChargePresentationPowerFadeComponent) == 0x000008, "Wrong alignment on UK28PowerChargePresentationPowerFadeComponent");
static_assert(sizeof(UK28PowerChargePresentationPowerFadeComponent) == 0x0000B8, "Wrong size on UK28PowerChargePresentationPowerFadeComponent");

// Class TheK28.K28PowerPresentationItemProgressComponent
// 0x0008 (0x00C0 - 0x00B8)
class UK28PowerPresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	TWeakObjectPtr<class AK28Power>               _k28Power;                                         // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28PowerPresentationItemProgressComponent">();
	}
	static class UK28PowerPresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28PowerPresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK28PowerPresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK28PowerPresentationItemProgressComponent");
static_assert(sizeof(UK28PowerPresentationItemProgressComponent) == 0x0000C0, "Wrong size on UK28PowerPresentationItemProgressComponent");
static_assert(offsetof(UK28PowerPresentationItemProgressComponent, _k28Power) == 0x0000B8, "Member 'UK28PowerPresentationItemProgressComponent::_k28Power' has a wrong offset!");

// Class TheK28.K28Remnant
// 0x01E0 (0x0410 - 0x0230)
class AK28Remnant final : public AActor
{
public:
	uint8                                         Pad_230[0x60];                                     // 0x0230(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _teleportToRemnantSpeedCurve_Normal;               // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _teleportToRemnantSpeedCurve_Penalty;              // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMesh;                                     // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      _capsuleComponent;                                 // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationMontageSlave*                 _montageFollower;                                  // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK28RemnantOutlineUpdateStrategy*       _remnantOutlineStrategy;                           // 0x02C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _teleportationFadeInTime;                          // 0x02D0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _teleportationFadeOutTime;                         // 0x02F8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minDistanceFromHookedSurvivor;                    // 0x0320(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _renmantDeactivationTime;                          // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _remnantDestructionTime;                           // 0x034C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _slowTeleportToRenmantAnimationMontage;            // 0x0350(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _fastTeleportToRenmantAnimationMontage;            // 0x0370(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EK28RemnantState                              _remnantState;                                     // 0x0390(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_391[0x77];                                     // 0x0391(0x0077)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnCollisionDetected(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult);
	void Cosmetic_OnRemnantActivated();
	void Cosmetic_OnRemnantDeactivated();
	void Cosmetic_OnRemnantStateChanged(EK28RemnantState remnantState);
	void Cosmetic_OnTeleportationPerformedVFX(class ASlasherPlayer* killer, bool isSlowTeleportation);
	void Cosmetic_OnTeleportationStartVFX(class ASlasherPlayer* killer);
	void Cosmetic_SurvivorDestroyedRemnant(class ACamperPlayer* survivor);
	void Multicast_ActivateRemnant(const struct FVector& location, const struct FRotator& rotation);
	void Multicast_DeactivateRemnant();
	void Multicast_SurvivorDestroyedRemnant(class ACamperPlayer* survivor);
	void Multicast_TeleportToRemnant(class ASlasherPlayer* killer, const struct FRotator& teleportRotation, bool isAnimationSlowed);
	void Multicast_TriggerTeleportStart(class ASlasherPlayer* killer);
	void OnRep_RemnantState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28Remnant">();
	}
	static class AK28Remnant* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK28Remnant>();
	}
};
static_assert(alignof(AK28Remnant) == 0x000008, "Wrong alignment on AK28Remnant");
static_assert(sizeof(AK28Remnant) == 0x000410, "Wrong size on AK28Remnant");
static_assert(offsetof(AK28Remnant, _teleportToRemnantSpeedCurve_Normal) == 0x000290, "Member 'AK28Remnant::_teleportToRemnantSpeedCurve_Normal' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _teleportToRemnantSpeedCurve_Penalty) == 0x000298, "Member 'AK28Remnant::_teleportToRemnantSpeedCurve_Penalty' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _skeletalMesh) == 0x0002A0, "Member 'AK28Remnant::_skeletalMesh' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _capsuleComponent) == 0x0002A8, "Member 'AK28Remnant::_capsuleComponent' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _montageFollower) == 0x0002B0, "Member 'AK28Remnant::_montageFollower' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _montagePlayer) == 0x0002B8, "Member 'AK28Remnant::_montagePlayer' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _outlineComponent) == 0x0002C0, "Member 'AK28Remnant::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _remnantOutlineStrategy) == 0x0002C8, "Member 'AK28Remnant::_remnantOutlineStrategy' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _teleportationFadeInTime) == 0x0002D0, "Member 'AK28Remnant::_teleportationFadeInTime' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _teleportationFadeOutTime) == 0x0002F8, "Member 'AK28Remnant::_teleportationFadeOutTime' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _minDistanceFromHookedSurvivor) == 0x000320, "Member 'AK28Remnant::_minDistanceFromHookedSurvivor' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _renmantDeactivationTime) == 0x000348, "Member 'AK28Remnant::_renmantDeactivationTime' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _remnantDestructionTime) == 0x00034C, "Member 'AK28Remnant::_remnantDestructionTime' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _slowTeleportToRenmantAnimationMontage) == 0x000350, "Member 'AK28Remnant::_slowTeleportToRenmantAnimationMontage' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _fastTeleportToRenmantAnimationMontage) == 0x000370, "Member 'AK28Remnant::_fastTeleportToRenmantAnimationMontage' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _remnantState) == 0x000390, "Member 'AK28Remnant::_remnantState' has a wrong offset!");
static_assert(offsetof(AK28Remnant, _perceptionStimuliComponent) == 0x000408, "Member 'AK28Remnant::_perceptionStimuliComponent' has a wrong offset!");

// Class TheK28.K28RemnantAnimInstance
// 0x0020 (0x02E0 - 0x02C0)
class UK28RemnantAnimInstance final : public UAnimInstance
{
public:
	EK28RemnantState                              _currentRemnantState;                              // 0x02C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isTeleportingToRemnant;                           // 0x02C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C2[0x1E];                                     // 0x02C2(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACamperPlayer* ConsumeSurvivorWhoDestroyedRemnant();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28RemnantAnimInstance">();
	}
	static class UK28RemnantAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28RemnantAnimInstance>();
	}
};
static_assert(alignof(UK28RemnantAnimInstance) == 0x000010, "Wrong alignment on UK28RemnantAnimInstance");
static_assert(sizeof(UK28RemnantAnimInstance) == 0x0002E0, "Wrong size on UK28RemnantAnimInstance");
static_assert(offsetof(UK28RemnantAnimInstance, _currentRemnantState) == 0x0002C0, "Member 'UK28RemnantAnimInstance::_currentRemnantState' has a wrong offset!");
static_assert(offsetof(UK28RemnantAnimInstance, _isTeleportingToRemnant) == 0x0002C1, "Member 'UK28RemnantAnimInstance::_isTeleportingToRemnant' has a wrong offset!");

// Class TheK28.K28RemnantOutlineUpdateStrategy
// 0x0018 (0x00D8 - 0x00C0)
class UK28RemnantOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _availableForTeleportSelectionColor;               // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28RemnantOutlineUpdateStrategy">();
	}
	static class UK28RemnantOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28RemnantOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK28RemnantOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK28RemnantOutlineUpdateStrategy");
static_assert(sizeof(UK28RemnantOutlineUpdateStrategy) == 0x0000D8, "Wrong size on UK28RemnantOutlineUpdateStrategy");
static_assert(offsetof(UK28RemnantOutlineUpdateStrategy, _availableForTeleportSelectionColor) == 0x0000C0, "Member 'UK28RemnantOutlineUpdateStrategy::_availableForTeleportSelectionColor' has a wrong offset!");

// Class TheK28.K28SecondaryCamera
// 0x0158 (0x0388 - 0x0230)
class AK28SecondaryCamera final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          _teleportCollision;                                // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x4];                                      // 0x0240(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minimumCameraPitchOrientationAngle;               // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maximumCameraPitchOrientationAngle;               // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _observerRotationSpeed;                            // 0x024C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minTimeBetweenCameraRotationUpdateRPC;            // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorGrabTransition_CameraRotationEndPercentage; // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorGrabTransition_DistanceFromLocker;        // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25C[0x124];                                    // 0x025C(0x0124)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isKillerPlayerViewTarget;                         // 0x0380(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_DisableAllEffects();
	void Cosmetic_OnIsLocallyObservingKillerChanged(bool isLocallyObservingKiller);
	void Cosmetic_OnKillerEnterLocker();
	void Cosmetic_OnKillerExitLocker();
	void Cosmetic_OnNightCycleChanged(EK28NightCycleState newNightCycleState);
	void Cosmetic_TriggerFadeIn();
	void Cosmetic_TriggerFadeOut();
	void Cosmetic_TriggerTeleportEndVisuals();
	void Cosmetic_TriggerTeleportStartVisuals();
	void Cosmetic_UpdateDarknessPlaneVisibility(bool isVisible);
	void Multicast_SetCameraOrientation(const struct FRotator& newOrientation, bool isRelativeRotation);
	void OnLevelReadyToPlay();
	void OnRep_IsKillerPlayerViewTarget();
	void Server_SetCameraOrientation(const struct FRotator& newOrientation);
	void Server_SetIsKillerPlayerViewTarget(bool isKillerPlayerViewTarget);

	struct FRotator GetCameraWorldRotation() const;
	bool GetIsKillerPlayerViewTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28SecondaryCamera">();
	}
	static class AK28SecondaryCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK28SecondaryCamera>();
	}
};
static_assert(alignof(AK28SecondaryCamera) == 0x000008, "Wrong alignment on AK28SecondaryCamera");
static_assert(sizeof(AK28SecondaryCamera) == 0x000388, "Wrong size on AK28SecondaryCamera");
static_assert(offsetof(AK28SecondaryCamera, _teleportCollision) == 0x000238, "Member 'AK28SecondaryCamera::_teleportCollision' has a wrong offset!");
static_assert(offsetof(AK28SecondaryCamera, _minimumCameraPitchOrientationAngle) == 0x000244, "Member 'AK28SecondaryCamera::_minimumCameraPitchOrientationAngle' has a wrong offset!");
static_assert(offsetof(AK28SecondaryCamera, _maximumCameraPitchOrientationAngle) == 0x000248, "Member 'AK28SecondaryCamera::_maximumCameraPitchOrientationAngle' has a wrong offset!");
static_assert(offsetof(AK28SecondaryCamera, _observerRotationSpeed) == 0x00024C, "Member 'AK28SecondaryCamera::_observerRotationSpeed' has a wrong offset!");
static_assert(offsetof(AK28SecondaryCamera, _minTimeBetweenCameraRotationUpdateRPC) == 0x000250, "Member 'AK28SecondaryCamera::_minTimeBetweenCameraRotationUpdateRPC' has a wrong offset!");
static_assert(offsetof(AK28SecondaryCamera, _survivorGrabTransition_CameraRotationEndPercentage) == 0x000254, "Member 'AK28SecondaryCamera::_survivorGrabTransition_CameraRotationEndPercentage' has a wrong offset!");
static_assert(offsetof(AK28SecondaryCamera, _survivorGrabTransition_DistanceFromLocker) == 0x000258, "Member 'AK28SecondaryCamera::_survivorGrabTransition_DistanceFromLocker' has a wrong offset!");
static_assert(offsetof(AK28SecondaryCamera, _isKillerPlayerViewTarget) == 0x000380, "Member 'AK28SecondaryCamera::_isKillerPlayerViewTarget' has a wrong offset!");

// Class TheK28.K28SurvivorAbductionCameraBehaviourComponent
// 0x0020 (0x00D8 - 0x00B8)
class UK28SurvivorAbductionCameraBehaviourComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _targetSpringArmLength;                            // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _targetLockerOffsetForCameraView;                  // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              _cameraLocationOffset;                             // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28SurvivorAbductionCameraBehaviourComponent">();
	}
	static class UK28SurvivorAbductionCameraBehaviourComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28SurvivorAbductionCameraBehaviourComponent>();
	}
};
static_assert(alignof(UK28SurvivorAbductionCameraBehaviourComponent) == 0x000008, "Wrong alignment on UK28SurvivorAbductionCameraBehaviourComponent");
static_assert(sizeof(UK28SurvivorAbductionCameraBehaviourComponent) == 0x0000D8, "Wrong size on UK28SurvivorAbductionCameraBehaviourComponent");
static_assert(offsetof(UK28SurvivorAbductionCameraBehaviourComponent, _targetSpringArmLength) == 0x0000C0, "Member 'UK28SurvivorAbductionCameraBehaviourComponent::_targetSpringArmLength' has a wrong offset!");
static_assert(offsetof(UK28SurvivorAbductionCameraBehaviourComponent, _targetLockerOffsetForCameraView) == 0x0000C4, "Member 'UK28SurvivorAbductionCameraBehaviourComponent::_targetLockerOffsetForCameraView' has a wrong offset!");
static_assert(offsetof(UK28SurvivorAbductionCameraBehaviourComponent, _cameraLocationOffset) == 0x0000C8, "Member 'UK28SurvivorAbductionCameraBehaviourComponent::_cameraLocationOffset' has a wrong offset!");

// Class TheK28.K28SurvivorComponent
// 0x0060 (0x01D0 - 0x0170)
class UK28SurvivorComponent final : public UK28PlayerComponent
{
public:
	uint8                                         Pad_170[0x8];                                      // 0x0170(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _killerBlackMaterialDarknessEffect;                // 0x0178(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x30];                                     // 0x01A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKillerInRangeChanged(const bool inRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28SurvivorComponent">();
	}
	static class UK28SurvivorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28SurvivorComponent>();
	}
};
static_assert(alignof(UK28SurvivorComponent) == 0x000008, "Wrong alignment on UK28SurvivorComponent");
static_assert(sizeof(UK28SurvivorComponent) == 0x0001D0, "Wrong size on UK28SurvivorComponent");
static_assert(offsetof(UK28SurvivorComponent, _killerBlackMaterialDarknessEffect) == 0x000178, "Member 'UK28SurvivorComponent::_killerBlackMaterialDarknessEffect' has a wrong offset!");

// Class TheK28.K28SurvivorCosmeticHelperActor
// 0x0028 (0x0290 - 0x0268)
class AK28SurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	uint8                                         Pad_268[0x28];                                     // 0x0268(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_ActivateNightGlowVFX();
	void Cosmetic_DeactivateNightGlowVFX();
	void Cosmetic_OnLocallyObservedChanged();
	void Cosmetic_OnNightCycleChanged(EK28NightCycleState nightCycleState);
	void Cosmetic_OnNighttimeNearingActivation();
	void OnLevelReadyToPlay();

	class UStaticMeshComponent* GetDarknessPlaneMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28SurvivorCosmeticHelperActor">();
	}
	static class AK28SurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK28SurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AK28SurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AK28SurvivorCosmeticHelperActor");
static_assert(sizeof(AK28SurvivorCosmeticHelperActor) == 0x000290, "Wrong size on AK28SurvivorCosmeticHelperActor");

// Class TheK28.K28SurvivorLockerAbductionInteraction
// 0x0080 (0x06D0 - 0x0650)
class UK28SurvivorLockerAbductionInteraction final : public UBaseLockerInteraction
{
public:
	struct FAnimationMontageDescriptor            _survivorPanicInLockerAnimationMontageDescriptor;  // 0x0648(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UBaseLockerInteraction>  _overriddenInteractionInstance;                    // 0x0668(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _overridingTags;                                   // 0x0670(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _fadeOutTime;                                      // 0x0680(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDotProductFadeOutThreshold;                    // 0x0684(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _rotationMaxTime;                                  // 0x0688(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68C[0x44];                                     // 0x068C(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_OverriddenInteractionInstance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28SurvivorLockerAbductionInteraction">();
	}
	static class UK28SurvivorLockerAbductionInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28SurvivorLockerAbductionInteraction>();
	}
};
static_assert(alignof(UK28SurvivorLockerAbductionInteraction) == 0x000010, "Wrong alignment on UK28SurvivorLockerAbductionInteraction");
static_assert(sizeof(UK28SurvivorLockerAbductionInteraction) == 0x0006D0, "Wrong size on UK28SurvivorLockerAbductionInteraction");
static_assert(offsetof(UK28SurvivorLockerAbductionInteraction, _survivorPanicInLockerAnimationMontageDescriptor) == 0x000648, "Member 'UK28SurvivorLockerAbductionInteraction::_survivorPanicInLockerAnimationMontageDescriptor' has a wrong offset!");
static_assert(offsetof(UK28SurvivorLockerAbductionInteraction, _overriddenInteractionInstance) == 0x000668, "Member 'UK28SurvivorLockerAbductionInteraction::_overriddenInteractionInstance' has a wrong offset!");
static_assert(offsetof(UK28SurvivorLockerAbductionInteraction, _overridingTags) == 0x000670, "Member 'UK28SurvivorLockerAbductionInteraction::_overridingTags' has a wrong offset!");
static_assert(offsetof(UK28SurvivorLockerAbductionInteraction, _fadeOutTime) == 0x000680, "Member 'UK28SurvivorLockerAbductionInteraction::_fadeOutTime' has a wrong offset!");
static_assert(offsetof(UK28SurvivorLockerAbductionInteraction, _minDotProductFadeOutThreshold) == 0x000684, "Member 'UK28SurvivorLockerAbductionInteraction::_minDotProductFadeOutThreshold' has a wrong offset!");
static_assert(offsetof(UK28SurvivorLockerAbductionInteraction, _rotationMaxTime) == 0x000688, "Member 'UK28SurvivorLockerAbductionInteraction::_rotationMaxTime' has a wrong offset!");

// Class TheK28.K28TeleportationStrategyComponent
// 0x00A8 (0x0160 - 0x00B8)
class UK28TeleportationStrategyComponent final : public UActorComponent
{
public:
	TArray<struct FK28LockerCluster>              _lockerClusters;                                   // 0x00B8(0x0010)(Net, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         _minMovementSquaredDistanceForBestClusterRecalculation; // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDeltaSquaredDistanceForBestTargetRecalculation; // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDeltaDotProductForBestTargetRecalculation;     // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minDotProductToBeEligibleForBestCluster;          // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK28LockerComponent>        _lockerComponentClass;                             // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ADBDActorIndicator>         _teleportIndicatorClass;                           // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDActorIndicator*                     _teleportIndicator;                                // 0x00E8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x70];                                      // 0x00F0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnLevelReadyToPlay();
	void Multicast_UpdateBestTeleportTarget(int32 bestTeleportTargetID);
	void Server_UpdateBestTeleportTarget(int32 bestTeleportTargetID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28TeleportationStrategyComponent">();
	}
	static class UK28TeleportationStrategyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28TeleportationStrategyComponent>();
	}
};
static_assert(alignof(UK28TeleportationStrategyComponent) == 0x000008, "Wrong alignment on UK28TeleportationStrategyComponent");
static_assert(sizeof(UK28TeleportationStrategyComponent) == 0x000160, "Wrong size on UK28TeleportationStrategyComponent");
static_assert(offsetof(UK28TeleportationStrategyComponent, _lockerClusters) == 0x0000B8, "Member 'UK28TeleportationStrategyComponent::_lockerClusters' has a wrong offset!");
static_assert(offsetof(UK28TeleportationStrategyComponent, _minMovementSquaredDistanceForBestClusterRecalculation) == 0x0000C8, "Member 'UK28TeleportationStrategyComponent::_minMovementSquaredDistanceForBestClusterRecalculation' has a wrong offset!");
static_assert(offsetof(UK28TeleportationStrategyComponent, _minDeltaSquaredDistanceForBestTargetRecalculation) == 0x0000CC, "Member 'UK28TeleportationStrategyComponent::_minDeltaSquaredDistanceForBestTargetRecalculation' has a wrong offset!");
static_assert(offsetof(UK28TeleportationStrategyComponent, _minDeltaDotProductForBestTargetRecalculation) == 0x0000D0, "Member 'UK28TeleportationStrategyComponent::_minDeltaDotProductForBestTargetRecalculation' has a wrong offset!");
static_assert(offsetof(UK28TeleportationStrategyComponent, _minDotProductToBeEligibleForBestCluster) == 0x0000D4, "Member 'UK28TeleportationStrategyComponent::_minDotProductToBeEligibleForBestCluster' has a wrong offset!");
static_assert(offsetof(UK28TeleportationStrategyComponent, _lockerComponentClass) == 0x0000D8, "Member 'UK28TeleportationStrategyComponent::_lockerComponentClass' has a wrong offset!");
static_assert(offsetof(UK28TeleportationStrategyComponent, _teleportIndicatorClass) == 0x0000E0, "Member 'UK28TeleportationStrategyComponent::_teleportIndicatorClass' has a wrong offset!");
static_assert(offsetof(UK28TeleportationStrategyComponent, _teleportIndicator) == 0x0000E8, "Member 'UK28TeleportationStrategyComponent::_teleportIndicator' has a wrong offset!");

// Class TheK28.K28TeleportInteraction
// 0x00F0 (0x0830 - 0x0740)
class UK28TeleportInteraction final : public UChargeableInteractionDefinition
{
public:
	struct FSecondaryInteractionProperties        _confirmTeleportationProperties;                   // 0x0740(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSecondaryInteractionProperties        _returnToRemnantProperties;                        // 0x0778(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EInputInteractionType                         _triggerTeleportInputType;                         // 0x07B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7B1[0x7];                                      // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _chargingSpeedCurve;                               // 0x07B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _chargedSpeedCurve;                                // 0x07C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _cancelledSpeedCurve;                              // 0x07C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _releaseInputMaxTime;                              // 0x07D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumChargePercentageToConsiderTeleportButtonPress; // 0x07D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D8[0x58];                                     // 0x07D8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_CompleteTeleportation();
	void Multicast_ConfirmTeleportationRequest(class ASlasherPlayer* killer, class UObject* teleportTarget);
	void Multicast_RefuseTeleportationRequest();
	void Server_RequestTeleportToTarget(class ASlasherPlayer* killer, class UObject* teleportTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28TeleportInteraction">();
	}
	static class UK28TeleportInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28TeleportInteraction>();
	}
};
static_assert(alignof(UK28TeleportInteraction) == 0x000010, "Wrong alignment on UK28TeleportInteraction");
static_assert(sizeof(UK28TeleportInteraction) == 0x000830, "Wrong size on UK28TeleportInteraction");
static_assert(offsetof(UK28TeleportInteraction, _confirmTeleportationProperties) == 0x000740, "Member 'UK28TeleportInteraction::_confirmTeleportationProperties' has a wrong offset!");
static_assert(offsetof(UK28TeleportInteraction, _returnToRemnantProperties) == 0x000778, "Member 'UK28TeleportInteraction::_returnToRemnantProperties' has a wrong offset!");
static_assert(offsetof(UK28TeleportInteraction, _triggerTeleportInputType) == 0x0007B0, "Member 'UK28TeleportInteraction::_triggerTeleportInputType' has a wrong offset!");
static_assert(offsetof(UK28TeleportInteraction, _chargingSpeedCurve) == 0x0007B8, "Member 'UK28TeleportInteraction::_chargingSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK28TeleportInteraction, _chargedSpeedCurve) == 0x0007C0, "Member 'UK28TeleportInteraction::_chargedSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK28TeleportInteraction, _cancelledSpeedCurve) == 0x0007C8, "Member 'UK28TeleportInteraction::_cancelledSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK28TeleportInteraction, _releaseInputMaxTime) == 0x0007D0, "Member 'UK28TeleportInteraction::_releaseInputMaxTime' has a wrong offset!");
static_assert(offsetof(UK28TeleportInteraction, _minimumChargePercentageToConsiderTeleportButtonPress) == 0x0007D4, "Member 'UK28TeleportInteraction::_minimumChargePercentageToConsiderTeleportButtonPress' has a wrong offset!");

// Class TheK28.K28Utilities
// 0x0000 (0x0030 - 0x0030)
class UK28Utilities final : public UBlueprintFunctionLibrary
{
public:
	static class UK28DayNightComponent* GetDayNightComponent(const class UObject* worldContextObject);
	static class AK28Power* GetK28Power(const class UObject* worldContextObject);
	static class AK28Remnant* GetRemnant(const class UObject* worldContextObject);
	static class AK28SecondaryCamera* GetSecondaryCamera(const class UObject* worldContextObject);
	static class UK28TeleportationStrategyComponent* GetTeleportationStrategyComponent(const class UObject* worldContextObject);
	static bool IsLockerUsedByKillerLocked(const class UObject* worldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28Utilities">();
	}
	static class UK28Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28Utilities>();
	}
};
static_assert(alignof(UK28Utilities) == 0x000008, "Wrong alignment on UK28Utilities");
static_assert(sizeof(UK28Utilities) == 0x000030, "Wrong size on UK28Utilities");

// Class TheK28.S31P01
// 0x0020 (0x03E8 - 0x03C8)
class US31P01 final : public UPerk
{
public:
	float                                         _loseHealthStateDetectionRadius;                   // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _killerAuraRevealDuration[0x3];                    // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _timedAuraReveal;                                  // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S31P01">();
	}
	static class US31P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<US31P01>();
	}
};
static_assert(alignof(US31P01) == 0x000008, "Wrong alignment on US31P01");
static_assert(sizeof(US31P01) == 0x0003E8, "Wrong size on US31P01");
static_assert(offsetof(US31P01, _loseHealthStateDetectionRadius) == 0x0003C8, "Member 'US31P01::_loseHealthStateDetectionRadius' has a wrong offset!");
static_assert(offsetof(US31P01, _killerAuraRevealDuration) == 0x0003D0, "Member 'US31P01::_killerAuraRevealDuration' has a wrong offset!");
static_assert(offsetof(US31P01, _timedAuraReveal) == 0x0003E0, "Member 'US31P01::_timedAuraReveal' has a wrong offset!");

// Class TheK28.S31P02
// 0x0028 (0x03F0 - 0x03C8)
class US31P02 final : public UPerk
{
public:
	float                                         _blindnessDurationPerLevel[0x3];                   // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _blindnessEffect;                                  // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _itemFlag;                                         // 0x03E0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S31P02">();
	}
	static class US31P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<US31P02>();
	}
};
static_assert(alignof(US31P02) == 0x000008, "Wrong alignment on US31P02");
static_assert(sizeof(US31P02) == 0x0003F0, "Wrong size on US31P02");
static_assert(offsetof(US31P02, _blindnessDurationPerLevel) == 0x0003C8, "Member 'US31P02::_blindnessDurationPerLevel' has a wrong offset!");
static_assert(offsetof(US31P02, _blindnessEffect) == 0x0003D8, "Member 'US31P02::_blindnessEffect' has a wrong offset!");
static_assert(offsetof(US31P02, _itemFlag) == 0x0003E0, "Member 'US31P02::_itemFlag' has a wrong offset!");

// Class TheK28.S31P03
// 0x0030 (0x03F8 - 0x03C8)
class US31P03 final : public UPerk
{
public:
	float                                         _genRepairSpeedBoostForDullTotem[0x3];             // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _genRepairSpeedBoostForHexTotem[0x3];              // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _effectClass;                                      // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x10];                                     // 0x03E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S31P03">();
	}
	static class US31P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<US31P03>();
	}
};
static_assert(alignof(US31P03) == 0x000008, "Wrong alignment on US31P03");
static_assert(sizeof(US31P03) == 0x0003F8, "Wrong size on US31P03");
static_assert(offsetof(US31P03, _genRepairSpeedBoostForDullTotem) == 0x0003C8, "Member 'US31P03::_genRepairSpeedBoostForDullTotem' has a wrong offset!");
static_assert(offsetof(US31P03, _genRepairSpeedBoostForHexTotem) == 0x0003D4, "Member 'US31P03::_genRepairSpeedBoostForHexTotem' has a wrong offset!");
static_assert(offsetof(US31P03, _effectClass) == 0x0003E0, "Member 'US31P03::_effectClass' has a wrong offset!");

}

