#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDAnimation

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "AnimationUtilities_structs.hpp"
#include "AnimationUtilities_classes.hpp"
#include "Activation_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "DBDAnimation_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "GameplayTagUtilities_structs.hpp"


namespace SDK
{

// Class DBDAnimation.DBDBaseAnimInstance
// 0x0030 (0x02F0 - 0x02C0)
class UDBDBaseAnimInstance : public UAnimInstance
{
public:
	class UAnimEffectBlackBoard*                  _animEffectBlackBoard;                             // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimEffectHandler*                     _animEffectHandlerForSFX;                          // 0x02C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimEffectHandler*                     _animEffectHandlerForVFX;                          // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimEffectHandler>         _animEffectHandlerClassForSFX;                     // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimEffectHandler>         _animEffectHandlerClassForVFX;                     // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasBeenNotified(const class FName animNotify) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseAnimInstance">();
	}
	static class UDBDBaseAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBaseAnimInstance>();
	}
};
static_assert(alignof(UDBDBaseAnimInstance) == 0x000010, "Wrong alignment on UDBDBaseAnimInstance");
static_assert(sizeof(UDBDBaseAnimInstance) == 0x0002F0, "Wrong size on UDBDBaseAnimInstance");
static_assert(offsetof(UDBDBaseAnimInstance, _animEffectBlackBoard) == 0x0002C0, "Member 'UDBDBaseAnimInstance::_animEffectBlackBoard' has a wrong offset!");
static_assert(offsetof(UDBDBaseAnimInstance, _animEffectHandlerForSFX) == 0x0002C8, "Member 'UDBDBaseAnimInstance::_animEffectHandlerForSFX' has a wrong offset!");
static_assert(offsetof(UDBDBaseAnimInstance, _animEffectHandlerForVFX) == 0x0002D0, "Member 'UDBDBaseAnimInstance::_animEffectHandlerForVFX' has a wrong offset!");
static_assert(offsetof(UDBDBaseAnimInstance, _animEffectHandlerClassForSFX) == 0x0002D8, "Member 'UDBDBaseAnimInstance::_animEffectHandlerClassForSFX' has a wrong offset!");
static_assert(offsetof(UDBDBaseAnimInstance, _animEffectHandlerClassForVFX) == 0x0002E0, "Member 'UDBDBaseAnimInstance::_animEffectHandlerClassForVFX' has a wrong offset!");

// Class DBDAnimation.PlayerAnimInstance
// 0x0250 (0x0540 - 0x02F0)
class UPlayerAnimInstance : public UDBDBaseAnimInstance
{
public:
	uint8                                         Pad_2F0[0x20];                                     // 0x02F0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _owningPlayer;                                     // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTaggedAnimCollection>          _taggedAnimCollections;                            // 0x0318(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UAnimSequence*> _animations;                                     // 0x0328(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UBlendSpace*> _blendspaces;                                      // 0x0378(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UAimOffsetBlendSpace*> _aimoffsets;                              // 0x03C8(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UBlendSpace1D*> _blendspaces1d;                                  // 0x0418(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UAimOffsetBlendSpace1D*> _aimoffsets1d;                          // 0x0468(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, struct FAnimSequenceSelector> _selectors;                              // 0x04B8(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          _isInParadise;                                     // 0x0508(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIntroCompleted;                                 // 0x0509(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isLevelReadyToPlay;                               // 0x050A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50B[0x5];                                      // 0x050B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActivationDefinition                  _activationDefinition;                             // 0x0510(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _interactionDuration;                              // 0x0538(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_53C[0x4];                                      // 0x053C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIntroCompleted();
	void OnLevelReadyToPlay();

	const class ADBDPlayer* GetOwningPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAnimInstance">();
	}
	static class UPlayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAnimInstance>();
	}
};
static_assert(alignof(UPlayerAnimInstance) == 0x000010, "Wrong alignment on UPlayerAnimInstance");
static_assert(sizeof(UPlayerAnimInstance) == 0x000540, "Wrong size on UPlayerAnimInstance");
static_assert(offsetof(UPlayerAnimInstance, _owningPlayer) == 0x000310, "Member 'UPlayerAnimInstance::_owningPlayer' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _taggedAnimCollections) == 0x000318, "Member 'UPlayerAnimInstance::_taggedAnimCollections' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _animations) == 0x000328, "Member 'UPlayerAnimInstance::_animations' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _blendspaces) == 0x000378, "Member 'UPlayerAnimInstance::_blendspaces' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _aimoffsets) == 0x0003C8, "Member 'UPlayerAnimInstance::_aimoffsets' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _blendspaces1d) == 0x000418, "Member 'UPlayerAnimInstance::_blendspaces1d' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _aimoffsets1d) == 0x000468, "Member 'UPlayerAnimInstance::_aimoffsets1d' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _selectors) == 0x0004B8, "Member 'UPlayerAnimInstance::_selectors' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _isInParadise) == 0x000508, "Member 'UPlayerAnimInstance::_isInParadise' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _isIntroCompleted) == 0x000509, "Member 'UPlayerAnimInstance::_isIntroCompleted' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _isLevelReadyToPlay) == 0x00050A, "Member 'UPlayerAnimInstance::_isLevelReadyToPlay' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _activationDefinition) == 0x000510, "Member 'UPlayerAnimInstance::_activationDefinition' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, _interactionDuration) == 0x000538, "Member 'UPlayerAnimInstance::_interactionDuration' has a wrong offset!");

// Class DBDAnimation.BaseSurvivorAnimInstance
// 0x0010 (0x0550 - 0x0540)
#pragma pack(push, 0x1)
class alignas(0x10) UBaseSurvivorAnimInstance : public UPlayerAnimInstance
{
public:
	class ACamperPlayer*                          _owningSurvivor;                                   // 0x0540(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const class ACamperPlayer* GetOwningSurvivor() const;
	bool IsPlayingMontageByName(class FName montageId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSurvivorAnimInstance">();
	}
	static class UBaseSurvivorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseSurvivorAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBaseSurvivorAnimInstance) == 0x000010, "Wrong alignment on UBaseSurvivorAnimInstance");
static_assert(sizeof(UBaseSurvivorAnimInstance) == 0x000550, "Wrong size on UBaseSurvivorAnimInstance");
static_assert(offsetof(UBaseSurvivorAnimInstance, _owningSurvivor) == 0x000540, "Member 'UBaseSurvivorAnimInstance::_owningSurvivor' has a wrong offset!");

// Class DBDAnimation.AimOffsetSurvivorSubAnimInstance
// 0x0050 (0x05A0 - 0x0550)
class UAimOffsetSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	float                                         _pitch;                                            // 0x0548(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yaw;                                              // 0x054C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawInterpolated;                                  // 0x0550(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _allowLookAt;                                      // 0x0554(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingAimItem;                                   // 0x0555(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInjured;                                        // 0x0556(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x0557(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x0558(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDrasticYawChangeDetected;                       // 0x0559(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55A[0x2];                                      // 0x055A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _yawInterpolationSpeed;                            // 0x055C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawDeadzoneStart;                                 // 0x0560(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawClampValue;                                    // 0x0564(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawDrasticChangeUpperLimit;                       // 0x0568(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawDrasticChangeLowerLimit;                       // 0x056C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawDrasticChangeInterpolationSpeed;               // 0x0570(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_574[0x4];                                      // 0x0574(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _yawInterpolateEaseIn;                             // 0x0578(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _yawInterpolateEaseOut;                            // 0x0580(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawInterpolationEaseInLength;                     // 0x0588(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawInterpolationEaseOutDistance;                  // 0x058C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isYawInDeadZone;                                  // 0x0590(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_591[0x3];                                      // 0x0591(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _currentTargetYaw;                                 // 0x0594(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _yawAcceleration;                                  // 0x0598(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _yawAccelerationTime;                              // 0x059C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimOffsetSurvivorSubAnimInstance">();
	}
	static class UAimOffsetSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimOffsetSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UAimOffsetSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UAimOffsetSurvivorSubAnimInstance");
static_assert(sizeof(UAimOffsetSurvivorSubAnimInstance) == 0x0005A0, "Wrong size on UAimOffsetSurvivorSubAnimInstance");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _pitch) == 0x000548, "Member 'UAimOffsetSurvivorSubAnimInstance::_pitch' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yaw) == 0x00054C, "Member 'UAimOffsetSurvivorSubAnimInstance::_yaw' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawInterpolated) == 0x000550, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawInterpolated' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _allowLookAt) == 0x000554, "Member 'UAimOffsetSurvivorSubAnimInstance::_allowLookAt' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _isUsingAimItem) == 0x000555, "Member 'UAimOffsetSurvivorSubAnimInstance::_isUsingAimItem' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _isInjured) == 0x000556, "Member 'UAimOffsetSurvivorSubAnimInstance::_isInjured' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _isCrawling) == 0x000557, "Member 'UAimOffsetSurvivorSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _isIdle) == 0x000558, "Member 'UAimOffsetSurvivorSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _isDrasticYawChangeDetected) == 0x000559, "Member 'UAimOffsetSurvivorSubAnimInstance::_isDrasticYawChangeDetected' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawInterpolationSpeed) == 0x00055C, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawDeadzoneStart) == 0x000560, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawDeadzoneStart' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawClampValue) == 0x000564, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawClampValue' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawDrasticChangeUpperLimit) == 0x000568, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawDrasticChangeUpperLimit' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawDrasticChangeLowerLimit) == 0x00056C, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawDrasticChangeLowerLimit' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawDrasticChangeInterpolationSpeed) == 0x000570, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawDrasticChangeInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawInterpolateEaseIn) == 0x000578, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawInterpolateEaseIn' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawInterpolateEaseOut) == 0x000580, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawInterpolateEaseOut' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawInterpolationEaseInLength) == 0x000588, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawInterpolationEaseInLength' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawInterpolationEaseOutDistance) == 0x00058C, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawInterpolationEaseOutDistance' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _isYawInDeadZone) == 0x000590, "Member 'UAimOffsetSurvivorSubAnimInstance::_isYawInDeadZone' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _currentTargetYaw) == 0x000594, "Member 'UAimOffsetSurvivorSubAnimInstance::_currentTargetYaw' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawAcceleration) == 0x000598, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawAcceleration' has a wrong offset!");
static_assert(offsetof(UAimOffsetSurvivorSubAnimInstance, _yawAccelerationTime) == 0x00059C, "Member 'UAimOffsetSurvivorSubAnimInstance::_yawAccelerationTime' has a wrong offset!");

// Class DBDAnimation.ArmIKSurvivorSubAnimInstance
// 0x0080 (0x05D0 - 0x0550)
class UArmIKSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	struct FRotator                               _rightWristUpRotation;                             // 0x0548(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _leftWristUpRotation;                              // 0x0554(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFloatRange                            _localWristYawRange;                               // 0x0560(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRange                            _localWristPitchRange;                             // 0x0570(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _armInterpolationSpeed;                            // 0x0580(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _handInterpolationSpeed;                           // 0x0584(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _alphaLerpTime;                                    // 0x0588(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _reachPadding;                                     // 0x058C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rightArmIKAlpha;                                  // 0x0590(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _leftArmIKAlpha;                                   // 0x0594(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EArmIkMode                                    _armIkMode;                                        // 0x0598(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_599[0x7];                                      // 0x0599(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmDetectionFanComponent*              _rightDetectionFan;                                // 0x05A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArmDetectionFanComponent*              _leftDetectionFan;                                 // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 _meshComponent;                                    // 0x05B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x18];                                     // 0x05B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeMode(const EArmIkMode newMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmIKSurvivorSubAnimInstance">();
	}
	static class UArmIKSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmIKSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UArmIKSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UArmIKSurvivorSubAnimInstance");
static_assert(sizeof(UArmIKSurvivorSubAnimInstance) == 0x0005D0, "Wrong size on UArmIKSurvivorSubAnimInstance");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _rightWristUpRotation) == 0x000548, "Member 'UArmIKSurvivorSubAnimInstance::_rightWristUpRotation' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _leftWristUpRotation) == 0x000554, "Member 'UArmIKSurvivorSubAnimInstance::_leftWristUpRotation' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _localWristYawRange) == 0x000560, "Member 'UArmIKSurvivorSubAnimInstance::_localWristYawRange' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _localWristPitchRange) == 0x000570, "Member 'UArmIKSurvivorSubAnimInstance::_localWristPitchRange' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _armInterpolationSpeed) == 0x000580, "Member 'UArmIKSurvivorSubAnimInstance::_armInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _handInterpolationSpeed) == 0x000584, "Member 'UArmIKSurvivorSubAnimInstance::_handInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _alphaLerpTime) == 0x000588, "Member 'UArmIKSurvivorSubAnimInstance::_alphaLerpTime' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _reachPadding) == 0x00058C, "Member 'UArmIKSurvivorSubAnimInstance::_reachPadding' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _rightArmIKAlpha) == 0x000590, "Member 'UArmIKSurvivorSubAnimInstance::_rightArmIKAlpha' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _leftArmIKAlpha) == 0x000594, "Member 'UArmIKSurvivorSubAnimInstance::_leftArmIKAlpha' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _armIkMode) == 0x000598, "Member 'UArmIKSurvivorSubAnimInstance::_armIkMode' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _rightDetectionFan) == 0x0005A0, "Member 'UArmIKSurvivorSubAnimInstance::_rightDetectionFan' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _leftDetectionFan) == 0x0005A8, "Member 'UArmIKSurvivorSubAnimInstance::_leftDetectionFan' has a wrong offset!");
static_assert(offsetof(UArmIKSurvivorSubAnimInstance, _meshComponent) == 0x0005B0, "Member 'UArmIKSurvivorSubAnimInstance::_meshComponent' has a wrong offset!");

// Class DBDAnimation.BaseKillerAnimInstance
// 0x0010 (0x0550 - 0x0540)
class UBaseKillerAnimInstance : public UPlayerAnimInstance
{
public:
	class ASlasherPlayer*                         _owningKiller;                                     // 0x0540(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _firstPersonView;                                  // 0x0548(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_549[0x7];                                      // 0x0549(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_ForceAnimPOV(const int32 animPOV);

	const class ASlasherPlayer* GetOwningKiller() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseKillerAnimInstance">();
	}
	static class UBaseKillerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseKillerAnimInstance>();
	}
};
static_assert(alignof(UBaseKillerAnimInstance) == 0x000010, "Wrong alignment on UBaseKillerAnimInstance");
static_assert(sizeof(UBaseKillerAnimInstance) == 0x000550, "Wrong size on UBaseKillerAnimInstance");
static_assert(offsetof(UBaseKillerAnimInstance, _owningKiller) == 0x000540, "Member 'UBaseKillerAnimInstance::_owningKiller' has a wrong offset!");
static_assert(offsetof(UBaseKillerAnimInstance, _firstPersonView) == 0x000548, "Member 'UBaseKillerAnimInstance::_firstPersonView' has a wrong offset!");

// Class DBDAnimation.BasePlayerAttackSubAnimInstance
// 0x00D0 (0x0610 - 0x0540)
#pragma pack(push, 0x1)
class alignas(0x10) UBasePlayerAttackSubAnimInstance : public UPlayerAnimInstance
{
public:
	EAttackSubstate                               _attackState;                                      // 0x0540(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_541[0x3];                                      // 0x0541(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _direction;                                        // 0x0544(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _strafeAngle;                                      // 0x0548(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isStrafe;                                         // 0x054C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54D[0x3];                                      // 0x054D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _attackInPlayRate;                                 // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_554[0x4];                                      // 0x0554(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackIn;                                         // 0x0558(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _attackSwingPlayRate;                              // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_574[0x4];                                      // 0x0574(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackSwing;                                      // 0x0578(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _attackMissPlayRate;                               // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_594[0x4];                                      // 0x0594(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackMiss;                                       // 0x0598(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _attackHitPlayRate;                                // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B4[0x4];                                      // 0x05B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackHit;                                        // 0x05B8(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _attackBounceOfWallPlayRate;                       // 0x05D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackBounceOfWall;                               // 0x05D8(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F0[0x14];                                     // 0x05F0(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _firstPersonView;                                  // 0x0604(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_605[0x3];                                      // 0x0605(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePlayerAttackSubAnimInstance">();
	}
	static class UBasePlayerAttackSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePlayerAttackSubAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBasePlayerAttackSubAnimInstance) == 0x000010, "Wrong alignment on UBasePlayerAttackSubAnimInstance");
static_assert(sizeof(UBasePlayerAttackSubAnimInstance) == 0x000610, "Wrong size on UBasePlayerAttackSubAnimInstance");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackState) == 0x000540, "Member 'UBasePlayerAttackSubAnimInstance::_attackState' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _direction) == 0x000544, "Member 'UBasePlayerAttackSubAnimInstance::_direction' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _strafeAngle) == 0x000548, "Member 'UBasePlayerAttackSubAnimInstance::_strafeAngle' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _isStrafe) == 0x00054C, "Member 'UBasePlayerAttackSubAnimInstance::_isStrafe' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackInPlayRate) == 0x000550, "Member 'UBasePlayerAttackSubAnimInstance::_attackInPlayRate' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackIn) == 0x000558, "Member 'UBasePlayerAttackSubAnimInstance::_attackIn' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackSwingPlayRate) == 0x000570, "Member 'UBasePlayerAttackSubAnimInstance::_attackSwingPlayRate' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackSwing) == 0x000578, "Member 'UBasePlayerAttackSubAnimInstance::_attackSwing' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackMissPlayRate) == 0x000590, "Member 'UBasePlayerAttackSubAnimInstance::_attackMissPlayRate' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackMiss) == 0x000598, "Member 'UBasePlayerAttackSubAnimInstance::_attackMiss' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackHitPlayRate) == 0x0005B0, "Member 'UBasePlayerAttackSubAnimInstance::_attackHitPlayRate' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackHit) == 0x0005B8, "Member 'UBasePlayerAttackSubAnimInstance::_attackHit' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackBounceOfWallPlayRate) == 0x0005D0, "Member 'UBasePlayerAttackSubAnimInstance::_attackBounceOfWallPlayRate' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _attackBounceOfWall) == 0x0005D8, "Member 'UBasePlayerAttackSubAnimInstance::_attackBounceOfWall' has a wrong offset!");
static_assert(offsetof(UBasePlayerAttackSubAnimInstance, _firstPersonView) == 0x000604, "Member 'UBasePlayerAttackSubAnimInstance::_firstPersonView' has a wrong offset!");

// Class DBDAnimation.BaseKillerAttackSubAnimInstance
// 0x0000 (0x0610 - 0x0610)
class UBaseKillerAttackSubAnimInstance : public UBasePlayerAttackSubAnimInstance
{
public:
	class ASlasherPlayer*                         _owningKiller;                                     // 0x0608(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const class ASlasherPlayer* GetOwningKiller() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseKillerAttackSubAnimInstance">();
	}
	static class UBaseKillerAttackSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseKillerAttackSubAnimInstance>();
	}
};
static_assert(alignof(UBaseKillerAttackSubAnimInstance) == 0x000010, "Wrong alignment on UBaseKillerAttackSubAnimInstance");
static_assert(sizeof(UBaseKillerAttackSubAnimInstance) == 0x000610, "Wrong size on UBaseKillerAttackSubAnimInstance");
static_assert(offsetof(UBaseKillerAttackSubAnimInstance, _owningKiller) == 0x000608, "Member 'UBaseKillerAttackSubAnimInstance::_owningKiller' has a wrong offset!");

// Class DBDAnimation.BaseKillerWeaponAnimInstance
// 0x00C0 (0x0380 - 0x02C0)
#pragma pack(push, 0x1)
class alignas(0x10) UBaseKillerWeaponAnimInstance : public UAnimInstance
{
public:
	EAttackSubstate                               _attackState;                                      // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCarrying;                                       // 0x02C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActive;                                         // 0x02C2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C3[0x1];                                      // 0x02C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _attackInPlayRate;                                 // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimSequenceSelector                  _attackIn;                                         // 0x02C8(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _attackSwingPlayRate;                              // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackSwing;                                      // 0x02E8(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _attackMissPlayRate;                               // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackMiss;                                       // 0x0308(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _attackHitPlayRate;                                // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackHit;                                        // 0x0328(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _attackBounceOfWallPlayRate;                       // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimSequenceSelector                  _attackBounceOfWall;                               // 0x0348(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _firstPersonView;                                  // 0x0370(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseKillerWeaponAnimInstance">();
	}
	static class UBaseKillerWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseKillerWeaponAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBaseKillerWeaponAnimInstance) == 0x000010, "Wrong alignment on UBaseKillerWeaponAnimInstance");
static_assert(sizeof(UBaseKillerWeaponAnimInstance) == 0x000380, "Wrong size on UBaseKillerWeaponAnimInstance");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackState) == 0x0002C0, "Member 'UBaseKillerWeaponAnimInstance::_attackState' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _isCarrying) == 0x0002C1, "Member 'UBaseKillerWeaponAnimInstance::_isCarrying' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _isActive) == 0x0002C2, "Member 'UBaseKillerWeaponAnimInstance::_isActive' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackInPlayRate) == 0x0002C4, "Member 'UBaseKillerWeaponAnimInstance::_attackInPlayRate' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackIn) == 0x0002C8, "Member 'UBaseKillerWeaponAnimInstance::_attackIn' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackSwingPlayRate) == 0x0002E0, "Member 'UBaseKillerWeaponAnimInstance::_attackSwingPlayRate' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackSwing) == 0x0002E8, "Member 'UBaseKillerWeaponAnimInstance::_attackSwing' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackMissPlayRate) == 0x000300, "Member 'UBaseKillerWeaponAnimInstance::_attackMissPlayRate' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackMiss) == 0x000308, "Member 'UBaseKillerWeaponAnimInstance::_attackMiss' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackHitPlayRate) == 0x000320, "Member 'UBaseKillerWeaponAnimInstance::_attackHitPlayRate' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackHit) == 0x000328, "Member 'UBaseKillerWeaponAnimInstance::_attackHit' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackBounceOfWallPlayRate) == 0x000340, "Member 'UBaseKillerWeaponAnimInstance::_attackBounceOfWallPlayRate' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _attackBounceOfWall) == 0x000348, "Member 'UBaseKillerWeaponAnimInstance::_attackBounceOfWall' has a wrong offset!");
static_assert(offsetof(UBaseKillerWeaponAnimInstance, _firstPersonView) == 0x000370, "Member 'UBaseKillerWeaponAnimInstance::_firstPersonView' has a wrong offset!");

// Class DBDAnimation.BaseMenuAnimInstance
// 0x0010 (0x0300 - 0x02F0)
#pragma pack(push, 0x1)
class alignas(0x10) UBaseMenuAnimInstance : public UDBDBaseAnimInstance
{
public:
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCustomizationChanged(const TArray<class FName>& customizationArray);

	EGameFlowStep GetCurrentMenu() const;
	class ADBDMenuPlayer* GetOwningMenuPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseMenuAnimInstance">();
	}
	static class UBaseMenuAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseMenuAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBaseMenuAnimInstance) == 0x000010, "Wrong alignment on UBaseMenuAnimInstance");
static_assert(sizeof(UBaseMenuAnimInstance) == 0x000300, "Wrong size on UBaseMenuAnimInstance");

// Class DBDAnimation.BasePowerSubAnimInstance
// 0x0010 (0x0560 - 0x0550)
class UBasePowerSubAnimInstance final : public UBaseKillerAnimInstance
{
public:
	bool                                          _isUsingPower;                                     // 0x0550(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_551[0xF];                                      // 0x0551(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePowerSubAnimInstance">();
	}
	static class UBasePowerSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePowerSubAnimInstance>();
	}
};
static_assert(alignof(UBasePowerSubAnimInstance) == 0x000010, "Wrong alignment on UBasePowerSubAnimInstance");
static_assert(sizeof(UBasePowerSubAnimInstance) == 0x000560, "Wrong size on UBasePowerSubAnimInstance");
static_assert(offsetof(UBasePowerSubAnimInstance, _isUsingPower) == 0x000550, "Member 'UBasePowerSubAnimInstance::_isUsingPower' has a wrong offset!");

// Class DBDAnimation.BreathingSurvivorSubAnimInstance
// 0x0010 (0x0560 - 0x0550)
class UBreathingSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isDead;                                           // 0x0548(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_549[0x7];                                      // 0x0549(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          _breathing;                                        // 0x0550(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreathingSurvivorSubAnimInstance">();
	}
	static class UBreathingSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBreathingSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UBreathingSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UBreathingSurvivorSubAnimInstance");
static_assert(sizeof(UBreathingSurvivorSubAnimInstance) == 0x000560, "Wrong size on UBreathingSurvivorSubAnimInstance");
static_assert(offsetof(UBreathingSurvivorSubAnimInstance, _isDead) == 0x000548, "Member 'UBreathingSurvivorSubAnimInstance::_isDead' has a wrong offset!");
static_assert(offsetof(UBreathingSurvivorSubAnimInstance, _breathing) == 0x000550, "Member 'UBreathingSurvivorSubAnimInstance::_breathing' has a wrong offset!");

// Class DBDAnimation.ChestAnimInstance
// 0x0020 (0x02E0 - 0x02C0)
class UChestAnimInstance final : public UAnimInstance
{
public:
	class ASearchable*                            _owningChest;                                      // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOpen;                                           // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingPriedOpen;                                 // 0x02C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CA[0xE];                                      // 0x02CA(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _openChestInteraction;                             // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnBeingPriedOpenStarted(class ADBDPlayer* player);
	void OnBeingPriedOpenStopped();
	void OnSearchedChanged(bool searched);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChestAnimInstance">();
	}
	static class UChestAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChestAnimInstance>();
	}
};
static_assert(alignof(UChestAnimInstance) == 0x000010, "Wrong alignment on UChestAnimInstance");
static_assert(sizeof(UChestAnimInstance) == 0x0002E0, "Wrong size on UChestAnimInstance");
static_assert(offsetof(UChestAnimInstance, _owningChest) == 0x0002C0, "Member 'UChestAnimInstance::_owningChest' has a wrong offset!");
static_assert(offsetof(UChestAnimInstance, _isOpen) == 0x0002C8, "Member 'UChestAnimInstance::_isOpen' has a wrong offset!");
static_assert(offsetof(UChestAnimInstance, _isBeingPriedOpen) == 0x0002C9, "Member 'UChestAnimInstance::_isBeingPriedOpen' has a wrong offset!");
static_assert(offsetof(UChestAnimInstance, _openChestInteraction) == 0x0002D8, "Member 'UChestAnimInstance::_openChestInteraction' has a wrong offset!");

// Class DBDAnimation.CrowAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class UCrowAnimInstance final : public UAnimInstance
{
public:
	bool                                          _shouldTakeOff;                                    // 0x02C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorldRunawayMeshComponent*             _crow;                                             // 0x02C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrowAnimInstance">();
	}
	static class UCrowAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrowAnimInstance>();
	}
};
static_assert(alignof(UCrowAnimInstance) == 0x000010, "Wrong alignment on UCrowAnimInstance");
static_assert(sizeof(UCrowAnimInstance) == 0x0002D0, "Wrong size on UCrowAnimInstance");
static_assert(offsetof(UCrowAnimInstance, _shouldTakeOff) == 0x0002C0, "Member 'UCrowAnimInstance::_shouldTakeOff' has a wrong offset!");
static_assert(offsetof(UCrowAnimInstance, _crow) == 0x0002C8, "Member 'UCrowAnimInstance::_crow' has a wrong offset!");

// Class DBDAnimation.CustomizationAnimationSelector
// 0x0068 (0x0098 - 0x0030)
class UCustomizationAnimationSelector final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             _customizationAnimationMappings;                   // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x38];                                      // 0x0050(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomizedSkeletalMesh*                _customizedSkeletalMesh;                           // 0x0088(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationAnimationSelector">();
	}
	static class UCustomizationAnimationSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationAnimationSelector>();
	}
};
static_assert(alignof(UCustomizationAnimationSelector) == 0x000008, "Wrong alignment on UCustomizationAnimationSelector");
static_assert(sizeof(UCustomizationAnimationSelector) == 0x000098, "Wrong size on UCustomizationAnimationSelector");
static_assert(offsetof(UCustomizationAnimationSelector, _customizationAnimationMappings) == 0x000048, "Member 'UCustomizationAnimationSelector::_customizationAnimationMappings' has a wrong offset!");
static_assert(offsetof(UCustomizationAnimationSelector, _customizedSkeletalMesh) == 0x000088, "Member 'UCustomizationAnimationSelector::_customizedSkeletalMesh' has a wrong offset!");

// Class DBDAnimation.DynamicAccessoryAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class UDynamicAccessoryAnimInstance : public UAnimInstance
{
public:
	bool                                          _isInMenu;                                         // 0x02C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInGame;                                         // 0x02C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPoseableHusk;                                   // 0x02C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C3[0x1];                                      // 0x02C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class USkeletalMeshComponent>  _masterMesh;                                       // 0x02C4(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicAccessoryAnimInstance">();
	}
	static class UDynamicAccessoryAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicAccessoryAnimInstance>();
	}
};
static_assert(alignof(UDynamicAccessoryAnimInstance) == 0x000010, "Wrong alignment on UDynamicAccessoryAnimInstance");
static_assert(sizeof(UDynamicAccessoryAnimInstance) == 0x0002D0, "Wrong size on UDynamicAccessoryAnimInstance");
static_assert(offsetof(UDynamicAccessoryAnimInstance, _isInMenu) == 0x0002C0, "Member 'UDynamicAccessoryAnimInstance::_isInMenu' has a wrong offset!");
static_assert(offsetof(UDynamicAccessoryAnimInstance, _isInGame) == 0x0002C1, "Member 'UDynamicAccessoryAnimInstance::_isInGame' has a wrong offset!");
static_assert(offsetof(UDynamicAccessoryAnimInstance, _isPoseableHusk) == 0x0002C2, "Member 'UDynamicAccessoryAnimInstance::_isPoseableHusk' has a wrong offset!");
static_assert(offsetof(UDynamicAccessoryAnimInstance, _masterMesh) == 0x0002C4, "Member 'UDynamicAccessoryAnimInstance::_masterMesh' has a wrong offset!");

// Class DBDAnimation.EntityAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class UEntityAnimInstance final : public UAnimInstance
{
public:
	bool                                          _isStruggling;                                     // 0x02C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _strugglePercent;                                  // 0x02C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityAnimInstance">();
	}
	static class UEntityAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityAnimInstance>();
	}
};
static_assert(alignof(UEntityAnimInstance) == 0x000010, "Wrong alignment on UEntityAnimInstance");
static_assert(sizeof(UEntityAnimInstance) == 0x0002D0, "Wrong size on UEntityAnimInstance");
static_assert(offsetof(UEntityAnimInstance, _isStruggling) == 0x0002C0, "Member 'UEntityAnimInstance::_isStruggling' has a wrong offset!");
static_assert(offsetof(UEntityAnimInstance, _strugglePercent) == 0x0002C4, "Member 'UEntityAnimInstance::_strugglePercent' has a wrong offset!");

// Class DBDAnimation.FaceCorrectionSurvivorSubAnimInstance
// 0x0000 (0x0550 - 0x0550)
class UFaceCorrectionSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isIdle;                                           // 0x0548(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFreddyMori;                                     // 0x0549(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInCloset;                                       // 0x054A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isEdgeCase;                                       // 0x054B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInjured;                                        // 0x054C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHealingOthers;                                  // 0x054D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x054E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54F[0x1];                                      // 0x054F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FaceCorrectionSurvivorSubAnimInstance">();
	}
	static class UFaceCorrectionSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFaceCorrectionSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UFaceCorrectionSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UFaceCorrectionSurvivorSubAnimInstance");
static_assert(sizeof(UFaceCorrectionSurvivorSubAnimInstance) == 0x000550, "Wrong size on UFaceCorrectionSurvivorSubAnimInstance");
static_assert(offsetof(UFaceCorrectionSurvivorSubAnimInstance, _isIdle) == 0x000548, "Member 'UFaceCorrectionSurvivorSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UFaceCorrectionSurvivorSubAnimInstance, _isFreddyMori) == 0x000549, "Member 'UFaceCorrectionSurvivorSubAnimInstance::_isFreddyMori' has a wrong offset!");
static_assert(offsetof(UFaceCorrectionSurvivorSubAnimInstance, _isInCloset) == 0x00054A, "Member 'UFaceCorrectionSurvivorSubAnimInstance::_isInCloset' has a wrong offset!");
static_assert(offsetof(UFaceCorrectionSurvivorSubAnimInstance, _isEdgeCase) == 0x00054B, "Member 'UFaceCorrectionSurvivorSubAnimInstance::_isEdgeCase' has a wrong offset!");
static_assert(offsetof(UFaceCorrectionSurvivorSubAnimInstance, _isInjured) == 0x00054C, "Member 'UFaceCorrectionSurvivorSubAnimInstance::_isInjured' has a wrong offset!");
static_assert(offsetof(UFaceCorrectionSurvivorSubAnimInstance, _isHealingOthers) == 0x00054D, "Member 'UFaceCorrectionSurvivorSubAnimInstance::_isHealingOthers' has a wrong offset!");
static_assert(offsetof(UFaceCorrectionSurvivorSubAnimInstance, _isCrouched) == 0x00054E, "Member 'UFaceCorrectionSurvivorSubAnimInstance::_isCrouched' has a wrong offset!");

// Class DBDAnimation.GeneratorAnimInstance
// 0x0010 (0x02E0 - 0x02D0)
class UGeneratorAnimInstance final : public USleepingAnimInstance
{
public:
	class AGenerator*                             _owningGenerator;                                  // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _rushFailed;                                       // 0x02D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActivated;                                      // 0x02D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D2[0x2];                                      // 0x02D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _percentComplete;                                  // 0x02D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSkillCheckSuccess(bool success);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorAnimInstance">();
	}
	static class UGeneratorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorAnimInstance>();
	}
};
static_assert(alignof(UGeneratorAnimInstance) == 0x000010, "Wrong alignment on UGeneratorAnimInstance");
static_assert(sizeof(UGeneratorAnimInstance) == 0x0002E0, "Wrong size on UGeneratorAnimInstance");
static_assert(offsetof(UGeneratorAnimInstance, _owningGenerator) == 0x0002C8, "Member 'UGeneratorAnimInstance::_owningGenerator' has a wrong offset!");
static_assert(offsetof(UGeneratorAnimInstance, _rushFailed) == 0x0002D0, "Member 'UGeneratorAnimInstance::_rushFailed' has a wrong offset!");
static_assert(offsetof(UGeneratorAnimInstance, _isActivated) == 0x0002D1, "Member 'UGeneratorAnimInstance::_isActivated' has a wrong offset!");
static_assert(offsetof(UGeneratorAnimInstance, _percentComplete) == 0x0002D4, "Member 'UGeneratorAnimInstance::_percentComplete' has a wrong offset!");

// Class DBDAnimation.HatchAnimInstance
// 0x0000 (0x02D0 - 0x02D0)
class UHatchAnimInstance final : public USleepingAnimInstance
{
public:
	bool                                          _isOpen;                                           // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HatchAnimInstance">();
	}
	static class UHatchAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHatchAnimInstance>();
	}
};
static_assert(alignof(UHatchAnimInstance) == 0x000010, "Wrong alignment on UHatchAnimInstance");
static_assert(sizeof(UHatchAnimInstance) == 0x0002D0, "Wrong size on UHatchAnimInstance");
static_assert(offsetof(UHatchAnimInstance, _isOpen) == 0x0002C8, "Member 'UHatchAnimInstance::_isOpen' has a wrong offset!");

// Class DBDAnimation.HealSurvivorSubAnimInstance
// 0x0050 (0x05A0 - 0x0550)
class UHealSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_548[0x40];                                     // 0x0548(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isHealingACrawlingTarget;                         // 0x0588(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHealingOtherNoMedkit;                           // 0x0589(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHealingOtherMedkit;                             // 0x058A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHealingSelfNoMedkit;                            // 0x058B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHealingSelfMedkit;                              // 0x058C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isWakingUpOther;                                  // 0x058D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingHealed;                                    // 0x058E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingMended;                                    // 0x058F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMendingOther;                                   // 0x0590(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasSkillCheckFailed;                              // 0x0591(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x0592(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasHealerSkillCheckFailed;                        // 0x0593(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_594[0xC];                                      // 0x0594(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHealerSkillCheckResponseAesthetic(bool success, class ADBDPlayer* healer);
	void ResetHealerSkillCheckFailed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealSurvivorSubAnimInstance">();
	}
	static class UHealSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UHealSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UHealSurvivorSubAnimInstance");
static_assert(sizeof(UHealSurvivorSubAnimInstance) == 0x0005A0, "Wrong size on UHealSurvivorSubAnimInstance");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isHealingACrawlingTarget) == 0x000588, "Member 'UHealSurvivorSubAnimInstance::_isHealingACrawlingTarget' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isHealingOtherNoMedkit) == 0x000589, "Member 'UHealSurvivorSubAnimInstance::_isHealingOtherNoMedkit' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isHealingOtherMedkit) == 0x00058A, "Member 'UHealSurvivorSubAnimInstance::_isHealingOtherMedkit' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isHealingSelfNoMedkit) == 0x00058B, "Member 'UHealSurvivorSubAnimInstance::_isHealingSelfNoMedkit' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isHealingSelfMedkit) == 0x00058C, "Member 'UHealSurvivorSubAnimInstance::_isHealingSelfMedkit' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isWakingUpOther) == 0x00058D, "Member 'UHealSurvivorSubAnimInstance::_isWakingUpOther' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isBeingHealed) == 0x00058E, "Member 'UHealSurvivorSubAnimInstance::_isBeingHealed' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isBeingMended) == 0x00058F, "Member 'UHealSurvivorSubAnimInstance::_isBeingMended' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isMendingOther) == 0x000590, "Member 'UHealSurvivorSubAnimInstance::_isMendingOther' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _hasSkillCheckFailed) == 0x000591, "Member 'UHealSurvivorSubAnimInstance::_hasSkillCheckFailed' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _isCrawling) == 0x000592, "Member 'UHealSurvivorSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UHealSurvivorSubAnimInstance, _hasHealerSkillCheckFailed) == 0x000593, "Member 'UHealSurvivorSubAnimInstance::_hasHealerSkillCheckFailed' has a wrong offset!");

// Class DBDAnimation.InteractionSurvivorSubAnimInstance
// 0x0040 (0x0590 - 0x0550)
class UInteractionSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isAgainstSmallKiller;                             // 0x0548(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInsideCloset;                                   // 0x0549(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingCarried;                                   // 0x054A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHooked;                                         // 0x054B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSacrificeStruggling;                            // 0x054C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54D[0x3];                                      // 0x054D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _sacrificeStrugglePercent;                         // 0x0550(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _selfUnhookFailed;                                 // 0x0554(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionAnimation                         _interactionAnimation;                             // 0x0555(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_556[0x2];                                      // 0x0556(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _snapPosition;                                     // 0x0558(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInteractingWithEscapeDoor;                      // 0x0564(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_565[0x2B];                                     // 0x0565(0x002B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionSurvivorSubAnimInstance">();
	}
	static class UInteractionSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UInteractionSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UInteractionSurvivorSubAnimInstance");
static_assert(sizeof(UInteractionSurvivorSubAnimInstance) == 0x000590, "Wrong size on UInteractionSurvivorSubAnimInstance");
static_assert(offsetof(UInteractionSurvivorSubAnimInstance, _isAgainstSmallKiller) == 0x000548, "Member 'UInteractionSurvivorSubAnimInstance::_isAgainstSmallKiller' has a wrong offset!");
static_assert(offsetof(UInteractionSurvivorSubAnimInstance, _isInsideCloset) == 0x000549, "Member 'UInteractionSurvivorSubAnimInstance::_isInsideCloset' has a wrong offset!");
static_assert(offsetof(UInteractionSurvivorSubAnimInstance, _isBeingCarried) == 0x00054A, "Member 'UInteractionSurvivorSubAnimInstance::_isBeingCarried' has a wrong offset!");
static_assert(offsetof(UInteractionSurvivorSubAnimInstance, _isHooked) == 0x00054B, "Member 'UInteractionSurvivorSubAnimInstance::_isHooked' has a wrong offset!");
static_assert(offsetof(UInteractionSurvivorSubAnimInstance, _isSacrificeStruggling) == 0x00054C, "Member 'UInteractionSurvivorSubAnimInstance::_isSacrificeStruggling' has a wrong offset!");
static_assert(offsetof(UInteractionSurvivorSubAnimInstance, _sacrificeStrugglePercent) == 0x000550, "Member 'UInteractionSurvivorSubAnimInstance::_sacrificeStrugglePercent' has a wrong offset!");
static_assert(offsetof(UInteractionSurvivorSubAnimInstance, _selfUnhookFailed) == 0x000554, "Member 'UInteractionSurvivorSubAnimInstance::_selfUnhookFailed' has a wrong offset!");
static_assert(offsetof(UInteractionSurvivorSubAnimInstance, _interactionAnimation) == 0x000555, "Member 'UInteractionSurvivorSubAnimInstance::_interactionAnimation' has a wrong offset!");
static_assert(offsetof(UInteractionSurvivorSubAnimInstance, _snapPosition) == 0x000558, "Member 'UInteractionSurvivorSubAnimInstance::_snapPosition' has a wrong offset!");
static_assert(offsetof(UInteractionSurvivorSubAnimInstance, _isInteractingWithEscapeDoor) == 0x000564, "Member 'UInteractionSurvivorSubAnimInstance::_isInteractingWithEscapeDoor' has a wrong offset!");

// Class DBDAnimation.KillerAnimInstance
// 0x00B0 (0x0600 - 0x0550)
class UKillerAnimInstance : public UBaseKillerAnimInstance
{
public:
	struct FVector                                _leftHandIKLocationFPV;                            // 0x0550(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightHandIKLocationFPV;                           // 0x055C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAnyMontagePlaying;                              // 0x0568(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCarrying;                                       // 0x0569(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_56A[0x2];                                      // 0x056A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _firstPersonCarryOffset;                           // 0x056C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _firstPersonCarryOffsetLookingDown;                // 0x0578(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInAir;                                          // 0x0584(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSpectator;                                      // 0x0585(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x0586(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_587[0x1];                                      // 0x0587(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _animDirection;                                    // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animSpeed;                                        // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animPitch;                                        // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animYaw;                                          // 0x0594(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisHeight;                                     // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _idleTime;                                         // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _directionSwitch;                                  // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttacking;                                      // 0x05A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPlayingAnyMontage;                              // 0x05A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isKilling;                                        // 0x05A6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A7[0x1];                                      // 0x05A7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _leftClearFrontSpaceVector;                        // 0x05A8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightClearFrontSpaceVector;                       // 0x05B4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _velocity;                                         // 0x05C0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightFootEffectorLocation;                        // 0x05CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftFootEffectorLocation;                         // 0x05D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionAnimation                         _interactionType;                                  // 0x05E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E5[0x3];                                      // 0x05E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmIKSensorComponent*                  _armIKSensorComponent;                             // 0x05E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackSubstate                               _attackState;                                      // 0x05F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F1[0x3];                                      // 0x05F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _forwardVelocity;                                  // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lateralVelocity;                                  // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5FC[0x4];                                      // 0x05FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetWeaponCustomizationId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAnimInstance">();
	}
	static class UKillerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerAnimInstance>();
	}
};
static_assert(alignof(UKillerAnimInstance) == 0x000010, "Wrong alignment on UKillerAnimInstance");
static_assert(sizeof(UKillerAnimInstance) == 0x000600, "Wrong size on UKillerAnimInstance");
static_assert(offsetof(UKillerAnimInstance, _leftHandIKLocationFPV) == 0x000550, "Member 'UKillerAnimInstance::_leftHandIKLocationFPV' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _rightHandIKLocationFPV) == 0x00055C, "Member 'UKillerAnimInstance::_rightHandIKLocationFPV' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _isAnyMontagePlaying) == 0x000568, "Member 'UKillerAnimInstance::_isAnyMontagePlaying' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _isCarrying) == 0x000569, "Member 'UKillerAnimInstance::_isCarrying' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _firstPersonCarryOffset) == 0x00056C, "Member 'UKillerAnimInstance::_firstPersonCarryOffset' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _firstPersonCarryOffsetLookingDown) == 0x000578, "Member 'UKillerAnimInstance::_firstPersonCarryOffsetLookingDown' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _isInAir) == 0x000584, "Member 'UKillerAnimInstance::_isInAir' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _isSpectator) == 0x000585, "Member 'UKillerAnimInstance::_isSpectator' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _isIdle) == 0x000586, "Member 'UKillerAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _animDirection) == 0x000588, "Member 'UKillerAnimInstance::_animDirection' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _animSpeed) == 0x00058C, "Member 'UKillerAnimInstance::_animSpeed' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _animPitch) == 0x000590, "Member 'UKillerAnimInstance::_animPitch' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _animYaw) == 0x000594, "Member 'UKillerAnimInstance::_animYaw' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _pelvisHeight) == 0x000598, "Member 'UKillerAnimInstance::_pelvisHeight' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _idleTime) == 0x00059C, "Member 'UKillerAnimInstance::_idleTime' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _directionSwitch) == 0x0005A0, "Member 'UKillerAnimInstance::_directionSwitch' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _isAttacking) == 0x0005A4, "Member 'UKillerAnimInstance::_isAttacking' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _isPlayingAnyMontage) == 0x0005A5, "Member 'UKillerAnimInstance::_isPlayingAnyMontage' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _isKilling) == 0x0005A6, "Member 'UKillerAnimInstance::_isKilling' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _leftClearFrontSpaceVector) == 0x0005A8, "Member 'UKillerAnimInstance::_leftClearFrontSpaceVector' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _rightClearFrontSpaceVector) == 0x0005B4, "Member 'UKillerAnimInstance::_rightClearFrontSpaceVector' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _velocity) == 0x0005C0, "Member 'UKillerAnimInstance::_velocity' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _rightFootEffectorLocation) == 0x0005CC, "Member 'UKillerAnimInstance::_rightFootEffectorLocation' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _leftFootEffectorLocation) == 0x0005D8, "Member 'UKillerAnimInstance::_leftFootEffectorLocation' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _interactionType) == 0x0005E4, "Member 'UKillerAnimInstance::_interactionType' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _armIKSensorComponent) == 0x0005E8, "Member 'UKillerAnimInstance::_armIKSensorComponent' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _attackState) == 0x0005F0, "Member 'UKillerAnimInstance::_attackState' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _forwardVelocity) == 0x0005F4, "Member 'UKillerAnimInstance::_forwardVelocity' has a wrong offset!");
static_assert(offsetof(UKillerAnimInstance, _lateralVelocity) == 0x0005F8, "Member 'UKillerAnimInstance::_lateralVelocity' has a wrong offset!");

// Class DBDAnimation.KillerAttackSubAnimInstance
// 0x0010 (0x0620 - 0x0610)
#pragma pack(push, 0x1)
class alignas(0x10) UKillerAttackSubAnimInstance : public UBaseKillerAttackSubAnimInstance
{
public:
	bool                                          _isCarrying;                                       // 0x0610(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActive;                                         // 0x0611(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_612[0x6];                                      // 0x0612(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAttackSubAnimInstance">();
	}
	static class UKillerAttackSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerAttackSubAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UKillerAttackSubAnimInstance) == 0x000010, "Wrong alignment on UKillerAttackSubAnimInstance");
static_assert(sizeof(UKillerAttackSubAnimInstance) == 0x000620, "Wrong size on UKillerAttackSubAnimInstance");
static_assert(offsetof(UKillerAttackSubAnimInstance, _isCarrying) == 0x000610, "Member 'UKillerAttackSubAnimInstance::_isCarrying' has a wrong offset!");
static_assert(offsetof(UKillerAttackSubAnimInstance, _isActive) == 0x000611, "Member 'UKillerAttackSubAnimInstance::_isActive' has a wrong offset!");

// Class DBDAnimation.KillerLocomotionSubAnimInstance
// 0x00B0 (0x0600 - 0x0550)
class UKillerLocomotionSubAnimInstance final : public UBaseKillerAnimInstance
{
public:
	class UAnimSequence*                          _landLightTPV;                                     // 0x0550(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _landLightFPV;                                     // 0x0558(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace1D*                          _BSLandTPV;                                        // 0x0560(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace1D*                          _BSLandFPV;                                        // 0x0568(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _walkToFallTPV;                                    // 0x0570(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _walkToFallFPV;                                    // 0x0578(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _carryIdleTPV;                                     // 0x0580(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _carryIdleFPV;                                     // 0x0588(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _fallingTPV;                                       // 0x0590(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _fallingFPV;                                       // 0x0598(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _landLight;                                        // 0x05A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlendSpace1D*                          _BSLand;                                           // 0x05A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _walkToFall;                                       // 0x05B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _carryIdle;                                        // 0x05B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _falling;                                          // 0x05C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isVaultingToFall;                                 // 0x05C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EIntroState                                   _introState;                                       // 0x05C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5CA[0x6];                                      // 0x05CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isVaultingToFallState;                            // 0x05D0(0x0030)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerLocomotionSubAnimInstance">();
	}
	static class UKillerLocomotionSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerLocomotionSubAnimInstance>();
	}
};
static_assert(alignof(UKillerLocomotionSubAnimInstance) == 0x000010, "Wrong alignment on UKillerLocomotionSubAnimInstance");
static_assert(sizeof(UKillerLocomotionSubAnimInstance) == 0x000600, "Wrong size on UKillerLocomotionSubAnimInstance");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _landLightTPV) == 0x000550, "Member 'UKillerLocomotionSubAnimInstance::_landLightTPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _landLightFPV) == 0x000558, "Member 'UKillerLocomotionSubAnimInstance::_landLightFPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _BSLandTPV) == 0x000560, "Member 'UKillerLocomotionSubAnimInstance::_BSLandTPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _BSLandFPV) == 0x000568, "Member 'UKillerLocomotionSubAnimInstance::_BSLandFPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _walkToFallTPV) == 0x000570, "Member 'UKillerLocomotionSubAnimInstance::_walkToFallTPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _walkToFallFPV) == 0x000578, "Member 'UKillerLocomotionSubAnimInstance::_walkToFallFPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _carryIdleTPV) == 0x000580, "Member 'UKillerLocomotionSubAnimInstance::_carryIdleTPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _carryIdleFPV) == 0x000588, "Member 'UKillerLocomotionSubAnimInstance::_carryIdleFPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _fallingTPV) == 0x000590, "Member 'UKillerLocomotionSubAnimInstance::_fallingTPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _fallingFPV) == 0x000598, "Member 'UKillerLocomotionSubAnimInstance::_fallingFPV' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _landLight) == 0x0005A0, "Member 'UKillerLocomotionSubAnimInstance::_landLight' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _BSLand) == 0x0005A8, "Member 'UKillerLocomotionSubAnimInstance::_BSLand' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _walkToFall) == 0x0005B0, "Member 'UKillerLocomotionSubAnimInstance::_walkToFall' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _carryIdle) == 0x0005B8, "Member 'UKillerLocomotionSubAnimInstance::_carryIdle' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _falling) == 0x0005C0, "Member 'UKillerLocomotionSubAnimInstance::_falling' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _isVaultingToFall) == 0x0005C8, "Member 'UKillerLocomotionSubAnimInstance::_isVaultingToFall' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _introState) == 0x0005C9, "Member 'UKillerLocomotionSubAnimInstance::_introState' has a wrong offset!");
static_assert(offsetof(UKillerLocomotionSubAnimInstance, _isVaultingToFallState) == 0x0005D0, "Member 'UKillerLocomotionSubAnimInstance::_isVaultingToFallState' has a wrong offset!");

// Class DBDAnimation.KillerSpecificSurvivorAnimationPicker
// 0x0018 (0x00D0 - 0x00B8)
class UKillerSpecificSurvivorAnimationPicker final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAnimInstance>              _killerSpecificAnimInstanceClass;                  // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             _killerSpecificSurvivorAnimationDB;                // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerSpecificSurvivorAnimationPicker">();
	}
	static class UKillerSpecificSurvivorAnimationPicker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerSpecificSurvivorAnimationPicker>();
	}
};
static_assert(alignof(UKillerSpecificSurvivorAnimationPicker) == 0x000008, "Wrong alignment on UKillerSpecificSurvivorAnimationPicker");
static_assert(sizeof(UKillerSpecificSurvivorAnimationPicker) == 0x0000D0, "Wrong size on UKillerSpecificSurvivorAnimationPicker");
static_assert(offsetof(UKillerSpecificSurvivorAnimationPicker, _killerSpecificAnimInstanceClass) == 0x0000C0, "Member 'UKillerSpecificSurvivorAnimationPicker::_killerSpecificAnimInstanceClass' has a wrong offset!");
static_assert(offsetof(UKillerSpecificSurvivorAnimationPicker, _killerSpecificSurvivorAnimationDB) == 0x0000C8, "Member 'UKillerSpecificSurvivorAnimationPicker::_killerSpecificSurvivorAnimationDB' has a wrong offset!");

// Class DBDAnimation.LegIKSurvivorSubAnimInstance
// 0x0100 (0x0650 - 0x0550)
class ULegIKSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	struct FVector                                _leftFootOffset;                                   // 0x0548(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightFootOffset;                                  // 0x0554(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _pelvisOffset;                                     // 0x0560(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x056C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x056D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_56E[0x2];                                      // 0x056E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               _rightFootDeltaRotator;                            // 0x0570(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _leftFootDeltaRotator;                             // 0x057C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAnimCollection*                        AnimCollection;                                    // 0x0588(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _floorJoint;                                       // 0x0590(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _pelvisOffsetTreshold;                             // 0x059C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatRange                            _pelvisOffsetRange;                                // 0x05A0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatRange                            _pelvisOffsetRangeCrouched;                        // 0x05B0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _pelvisOffsetInterpolationSpeed;                   // 0x05C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatRange                            _footOffsetRange;                                  // 0x05C4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatRange                            _footOffsetRangeCrouched;                          // 0x05D4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _footOffsetInterpolationSpeed;                     // 0x05E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFloatRange                            _footPitchDeltaRange;                              // 0x05E8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseGroundDetectorComponent*           _leftFootGroundDetector;                           // 0x05F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseGroundDetectorComponent*           _rightFootGroundDetector;                          // 0x0600(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         maxLocalHeightForPlanting;                         // 0x0608(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60C[0x3C];                                     // 0x060C(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocomotionPredictor*                   _locomotionPredictor;                              // 0x0648(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LegIKSurvivorSubAnimInstance">();
	}
	static class ULegIKSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULegIKSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(ULegIKSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on ULegIKSurvivorSubAnimInstance");
static_assert(sizeof(ULegIKSurvivorSubAnimInstance) == 0x000650, "Wrong size on ULegIKSurvivorSubAnimInstance");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _leftFootOffset) == 0x000548, "Member 'ULegIKSurvivorSubAnimInstance::_leftFootOffset' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _rightFootOffset) == 0x000554, "Member 'ULegIKSurvivorSubAnimInstance::_rightFootOffset' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _pelvisOffset) == 0x000560, "Member 'ULegIKSurvivorSubAnimInstance::_pelvisOffset' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _isIdle) == 0x00056C, "Member 'ULegIKSurvivorSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _isCrouched) == 0x00056D, "Member 'ULegIKSurvivorSubAnimInstance::_isCrouched' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _rightFootDeltaRotator) == 0x000570, "Member 'ULegIKSurvivorSubAnimInstance::_rightFootDeltaRotator' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _leftFootDeltaRotator) == 0x00057C, "Member 'ULegIKSurvivorSubAnimInstance::_leftFootDeltaRotator' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, AnimCollection) == 0x000588, "Member 'ULegIKSurvivorSubAnimInstance::AnimCollection' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _floorJoint) == 0x000590, "Member 'ULegIKSurvivorSubAnimInstance::_floorJoint' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _pelvisOffsetTreshold) == 0x00059C, "Member 'ULegIKSurvivorSubAnimInstance::_pelvisOffsetTreshold' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _pelvisOffsetRange) == 0x0005A0, "Member 'ULegIKSurvivorSubAnimInstance::_pelvisOffsetRange' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _pelvisOffsetRangeCrouched) == 0x0005B0, "Member 'ULegIKSurvivorSubAnimInstance::_pelvisOffsetRangeCrouched' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _pelvisOffsetInterpolationSpeed) == 0x0005C0, "Member 'ULegIKSurvivorSubAnimInstance::_pelvisOffsetInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _footOffsetRange) == 0x0005C4, "Member 'ULegIKSurvivorSubAnimInstance::_footOffsetRange' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _footOffsetRangeCrouched) == 0x0005D4, "Member 'ULegIKSurvivorSubAnimInstance::_footOffsetRangeCrouched' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _footOffsetInterpolationSpeed) == 0x0005E4, "Member 'ULegIKSurvivorSubAnimInstance::_footOffsetInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _footPitchDeltaRange) == 0x0005E8, "Member 'ULegIKSurvivorSubAnimInstance::_footPitchDeltaRange' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _leftFootGroundDetector) == 0x0005F8, "Member 'ULegIKSurvivorSubAnimInstance::_leftFootGroundDetector' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _rightFootGroundDetector) == 0x000600, "Member 'ULegIKSurvivorSubAnimInstance::_rightFootGroundDetector' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, maxLocalHeightForPlanting) == 0x000608, "Member 'ULegIKSurvivorSubAnimInstance::maxLocalHeightForPlanting' has a wrong offset!");
static_assert(offsetof(ULegIKSurvivorSubAnimInstance, _locomotionPredictor) == 0x000648, "Member 'ULegIKSurvivorSubAnimInstance::_locomotionPredictor' has a wrong offset!");

// Class DBDAnimation.LocomotionLookAtSurvivorSubAnimInstance
// 0x0070 (0x05C0 - 0x0550)
class ULocomotionLookAtSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isHealthy;                                        // 0x0548(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingAimItem;                                   // 0x0549(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54A[0x2];                                      // 0x054A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _aimOffsetPitch;                                   // 0x054C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYaw;                                     // 0x0550(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawInterpolated;                         // 0x0554(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _allowLookAt;                                      // 0x0558(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDrasticAimOffsetYawChangeDetected;              // 0x0559(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55A[0x2];                                      // 0x055A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _aimOffsetYawInterpolationSpeed;                   // 0x055C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawDeadzoneStart;                        // 0x0560(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawClampValue;                           // 0x0564(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawDrasticChangeUpperLimit;              // 0x0568(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawDrasticChangeLowerLimit;              // 0x056C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawDrasticChangeInterpolationSpeed;      // 0x0570(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_574[0x4];                                      // 0x0574(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _aimOffsetYawInterpolateEaseIn;                    // 0x0578(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _aimOffsetYawInterpolateEaseOut;                   // 0x0580(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawInterpolationEaseInLength;            // 0x0588(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawInterpolationEaseOutDistance;         // 0x058C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAimOffsetYawInDeadZone;                         // 0x0590(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_591[0x3];                                      // 0x0591(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _alphaAimOffsetPitchDown;                          // 0x0594(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _alphaAimOffsetPitchCenter;                        // 0x0598(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _alphaAimOffsetPitchUp;                            // 0x059C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A0[0x20];                                     // 0x05A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionLookAtSurvivorSubAnimInstance">();
	}
	static class ULocomotionLookAtSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionLookAtSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(ULocomotionLookAtSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on ULocomotionLookAtSurvivorSubAnimInstance");
static_assert(sizeof(ULocomotionLookAtSurvivorSubAnimInstance) == 0x0005C0, "Wrong size on ULocomotionLookAtSurvivorSubAnimInstance");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _isHealthy) == 0x000548, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_isHealthy' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _isUsingAimItem) == 0x000549, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_isUsingAimItem' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _aimOffsetPitch) == 0x00054C, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_aimOffsetPitch' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _aimOffsetYaw) == 0x000550, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_aimOffsetYaw' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _aimOffsetYawInterpolated) == 0x000554, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_aimOffsetYawInterpolated' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _allowLookAt) == 0x000558, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_allowLookAt' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _isDrasticAimOffsetYawChangeDetected) == 0x000559, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_isDrasticAimOffsetYawChangeDetected' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _aimOffsetYawInterpolationSpeed) == 0x00055C, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_aimOffsetYawInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _aimOffsetYawDeadzoneStart) == 0x000560, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_aimOffsetYawDeadzoneStart' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _aimOffsetYawClampValue) == 0x000564, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_aimOffsetYawClampValue' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _aimOffsetYawDrasticChangeUpperLimit) == 0x000568, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_aimOffsetYawDrasticChangeUpperLimit' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _aimOffsetYawDrasticChangeLowerLimit) == 0x00056C, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_aimOffsetYawDrasticChangeLowerLimit' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _aimOffsetYawDrasticChangeInterpolationSpeed) == 0x000570, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_aimOffsetYawDrasticChangeInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _aimOffsetYawInterpolateEaseIn) == 0x000578, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_aimOffsetYawInterpolateEaseIn' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _aimOffsetYawInterpolateEaseOut) == 0x000580, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_aimOffsetYawInterpolateEaseOut' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _aimOffsetYawInterpolationEaseInLength) == 0x000588, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_aimOffsetYawInterpolationEaseInLength' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _aimOffsetYawInterpolationEaseOutDistance) == 0x00058C, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_aimOffsetYawInterpolationEaseOutDistance' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _isAimOffsetYawInDeadZone) == 0x000590, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_isAimOffsetYawInDeadZone' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _alphaAimOffsetPitchDown) == 0x000594, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_alphaAimOffsetPitchDown' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _alphaAimOffsetPitchCenter) == 0x000598, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_alphaAimOffsetPitchCenter' has a wrong offset!");
static_assert(offsetof(ULocomotionLookAtSurvivorSubAnimInstance, _alphaAimOffsetPitchUp) == 0x00059C, "Member 'ULocomotionLookAtSurvivorSubAnimInstance::_alphaAimOffsetPitchUp' has a wrong offset!");

// Class DBDAnimation.LocomotionPredictor
// 0x0050 (0x0080 - 0x0030)
class ULocomotionPredictor final : public UObject
{
public:
	TMap<class UAnimSequence*, struct FFootBoneData> _animFootData;                                  // 0x0030(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionPredictor">();
	}
	static class ULocomotionPredictor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionPredictor>();
	}
};
static_assert(alignof(ULocomotionPredictor) == 0x000008, "Wrong alignment on ULocomotionPredictor");
static_assert(sizeof(ULocomotionPredictor) == 0x000080, "Wrong size on ULocomotionPredictor");
static_assert(offsetof(ULocomotionPredictor, _animFootData) == 0x000030, "Member 'ULocomotionPredictor::_animFootData' has a wrong offset!");

// Class DBDAnimation.LocomotionSurvivorSubAnimInstance
// 0x00C0 (0x0610 - 0x0550)
class ULocomotionSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isRecoveringWhileCrawling;                        // 0x0548(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isTenacityPerkActive;                             // 0x0549(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54A[0x2];                                      // 0x054A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _wasMovingResetTime;                               // 0x054C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x0550(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldPlayLowerCarryAnimation;                    // 0x0551(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRunning;                                        // 0x0552(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouching;                                      // 0x0553(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x0554(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDead;                                           // 0x0555(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_556[0x2];                                      // 0x0556(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _walkAnimSpeed;                                    // 0x0558(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _walkAnimStartOffset;                              // 0x055C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _walkAnimPlayRateMultiplier;                       // 0x0560(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _wasLastDamageSourceDeepWounds;                    // 0x0564(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_565[0x1];                                      // 0x0565(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isStrafing;                                       // 0x0566(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingDeadHard;                                  // 0x0567(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _direction;                                        // 0x0568(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingAimItem;                                   // 0x056C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingCarried;                                   // 0x056D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_56E[0x2];                                      // 0x056E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _crawlingDirectionWhileMoving;                     // 0x0570(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _crawlMovingJustStopped;                           // 0x0574(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_575[0x3];                                      // 0x0575(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _aimOffsetYawInterpolated;                         // 0x0578(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _allowLookAt;                                      // 0x057C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDrasticAimOffsetYawChangeDetected;              // 0x057D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_57E[0x2];                                      // 0x057E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _lookAtAlphaBlendMultiDown;                        // 0x0580(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lookAtAlphaBlendMultiCenter;                      // 0x0584(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lookAtAlphaBlendMultiUp;                          // 0x0588(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lookAtStandIdleAnimationLength;                   // 0x058C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aimOffsetYawClampValue;                           // 0x0590(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxParadiseWalkCycleOffSet;                       // 0x0594(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_598[0x4];                                      // 0x0598(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minParadiseWalkPlayRateMultiplier;                // 0x059C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A0[0x8];                                      // 0x05A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _lowerCarryAnimationPresenceTags;                  // 0x05A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B8[0x58];                                     // 0x05B8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionSurvivorSubAnimInstance">();
	}
	static class ULocomotionSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(ULocomotionSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on ULocomotionSurvivorSubAnimInstance");
static_assert(sizeof(ULocomotionSurvivorSubAnimInstance) == 0x000610, "Wrong size on ULocomotionSurvivorSubAnimInstance");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isRecoveringWhileCrawling) == 0x000548, "Member 'ULocomotionSurvivorSubAnimInstance::_isRecoveringWhileCrawling' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isTenacityPerkActive) == 0x000549, "Member 'ULocomotionSurvivorSubAnimInstance::_isTenacityPerkActive' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _wasMovingResetTime) == 0x00054C, "Member 'ULocomotionSurvivorSubAnimInstance::_wasMovingResetTime' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isIdle) == 0x000550, "Member 'ULocomotionSurvivorSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _shouldPlayLowerCarryAnimation) == 0x000551, "Member 'ULocomotionSurvivorSubAnimInstance::_shouldPlayLowerCarryAnimation' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isRunning) == 0x000552, "Member 'ULocomotionSurvivorSubAnimInstance::_isRunning' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isCrouching) == 0x000553, "Member 'ULocomotionSurvivorSubAnimInstance::_isCrouching' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isCrawling) == 0x000554, "Member 'ULocomotionSurvivorSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isDead) == 0x000555, "Member 'ULocomotionSurvivorSubAnimInstance::_isDead' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _walkAnimSpeed) == 0x000558, "Member 'ULocomotionSurvivorSubAnimInstance::_walkAnimSpeed' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _walkAnimStartOffset) == 0x00055C, "Member 'ULocomotionSurvivorSubAnimInstance::_walkAnimStartOffset' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _walkAnimPlayRateMultiplier) == 0x000560, "Member 'ULocomotionSurvivorSubAnimInstance::_walkAnimPlayRateMultiplier' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _wasLastDamageSourceDeepWounds) == 0x000564, "Member 'ULocomotionSurvivorSubAnimInstance::_wasLastDamageSourceDeepWounds' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isStrafing) == 0x000566, "Member 'ULocomotionSurvivorSubAnimInstance::_isStrafing' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isUsingDeadHard) == 0x000567, "Member 'ULocomotionSurvivorSubAnimInstance::_isUsingDeadHard' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _direction) == 0x000568, "Member 'ULocomotionSurvivorSubAnimInstance::_direction' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isUsingAimItem) == 0x00056C, "Member 'ULocomotionSurvivorSubAnimInstance::_isUsingAimItem' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isBeingCarried) == 0x00056D, "Member 'ULocomotionSurvivorSubAnimInstance::_isBeingCarried' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _crawlingDirectionWhileMoving) == 0x000570, "Member 'ULocomotionSurvivorSubAnimInstance::_crawlingDirectionWhileMoving' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _crawlMovingJustStopped) == 0x000574, "Member 'ULocomotionSurvivorSubAnimInstance::_crawlMovingJustStopped' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aimOffsetYawInterpolated) == 0x000578, "Member 'ULocomotionSurvivorSubAnimInstance::_aimOffsetYawInterpolated' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _allowLookAt) == 0x00057C, "Member 'ULocomotionSurvivorSubAnimInstance::_allowLookAt' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _isDrasticAimOffsetYawChangeDetected) == 0x00057D, "Member 'ULocomotionSurvivorSubAnimInstance::_isDrasticAimOffsetYawChangeDetected' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lookAtAlphaBlendMultiDown) == 0x000580, "Member 'ULocomotionSurvivorSubAnimInstance::_lookAtAlphaBlendMultiDown' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lookAtAlphaBlendMultiCenter) == 0x000584, "Member 'ULocomotionSurvivorSubAnimInstance::_lookAtAlphaBlendMultiCenter' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lookAtAlphaBlendMultiUp) == 0x000588, "Member 'ULocomotionSurvivorSubAnimInstance::_lookAtAlphaBlendMultiUp' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lookAtStandIdleAnimationLength) == 0x00058C, "Member 'ULocomotionSurvivorSubAnimInstance::_lookAtStandIdleAnimationLength' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _aimOffsetYawClampValue) == 0x000590, "Member 'ULocomotionSurvivorSubAnimInstance::_aimOffsetYawClampValue' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _maxParadiseWalkCycleOffSet) == 0x000594, "Member 'ULocomotionSurvivorSubAnimInstance::_maxParadiseWalkCycleOffSet' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _minParadiseWalkPlayRateMultiplier) == 0x00059C, "Member 'ULocomotionSurvivorSubAnimInstance::_minParadiseWalkPlayRateMultiplier' has a wrong offset!");
static_assert(offsetof(ULocomotionSurvivorSubAnimInstance, _lowerCarryAnimationPresenceTags) == 0x0005A8, "Member 'ULocomotionSurvivorSubAnimInstance::_lowerCarryAnimationPresenceTags' has a wrong offset!");

// Class DBDAnimation.LookAtKillerSubAnimInstance
// 0x0050 (0x0310 - 0x02C0)
class ULookAtKillerSubAnimInstance final : public UAnimInstance
{
public:
	class ADBDPlayer*                             _owningPawn;                                       // 0x02C0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASlasherPlayer*                         _owningKiller;                                     // 0x02C8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _enableDynamics;                                   // 0x02D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _dynamicsAlpha;                                    // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldApplyDynamics;                              // 0x02D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x3];                                      // 0x02D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _playerMaxSpeed;                                   // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animYaw;                                          // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _enableTurnInPlace;                                // 0x02E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldTurnLeft;                                   // 0x02E5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldTurnRight;                                  // 0x02E6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E7[0x1];                                      // 0x02E7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _turnInPlaceThresholdAngle;                        // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _idleNeutralRotationYaw;                           // 0x02EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x02F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1[0x1F];                                     // 0x02F1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetNeutralIdleRotationYaw();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookAtKillerSubAnimInstance">();
	}
	static class ULookAtKillerSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookAtKillerSubAnimInstance>();
	}
};
static_assert(alignof(ULookAtKillerSubAnimInstance) == 0x000010, "Wrong alignment on ULookAtKillerSubAnimInstance");
static_assert(sizeof(ULookAtKillerSubAnimInstance) == 0x000310, "Wrong size on ULookAtKillerSubAnimInstance");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _owningPawn) == 0x0002C0, "Member 'ULookAtKillerSubAnimInstance::_owningPawn' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _owningKiller) == 0x0002C8, "Member 'ULookAtKillerSubAnimInstance::_owningKiller' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _enableDynamics) == 0x0002D0, "Member 'ULookAtKillerSubAnimInstance::_enableDynamics' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _dynamicsAlpha) == 0x0002D4, "Member 'ULookAtKillerSubAnimInstance::_dynamicsAlpha' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _shouldApplyDynamics) == 0x0002D8, "Member 'ULookAtKillerSubAnimInstance::_shouldApplyDynamics' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _playerMaxSpeed) == 0x0002DC, "Member 'ULookAtKillerSubAnimInstance::_playerMaxSpeed' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _animYaw) == 0x0002E0, "Member 'ULookAtKillerSubAnimInstance::_animYaw' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _enableTurnInPlace) == 0x0002E4, "Member 'ULookAtKillerSubAnimInstance::_enableTurnInPlace' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _shouldTurnLeft) == 0x0002E5, "Member 'ULookAtKillerSubAnimInstance::_shouldTurnLeft' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _shouldTurnRight) == 0x0002E6, "Member 'ULookAtKillerSubAnimInstance::_shouldTurnRight' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _turnInPlaceThresholdAngle) == 0x0002E8, "Member 'ULookAtKillerSubAnimInstance::_turnInPlaceThresholdAngle' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _idleNeutralRotationYaw) == 0x0002EC, "Member 'ULookAtKillerSubAnimInstance::_idleNeutralRotationYaw' has a wrong offset!");
static_assert(offsetof(ULookAtKillerSubAnimInstance, _isIdle) == 0x0002F0, "Member 'ULookAtKillerSubAnimInstance::_isIdle' has a wrong offset!");

// Class DBDAnimation.LookAtTargetKillerSubAnimInstance
// 0x01C0 (0x0710 - 0x0550)
class ULookAtTargetKillerSubAnimInstance final : public UBaseKillerAnimInstance
{
public:
	float                                         _maxDistanceForTargetDetection;                    // 0x0550(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _headSocket;                                       // 0x0554(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rootSocket;                                       // 0x0560(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _preferredMinLookAtTime;                           // 0x056C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _distanceScoreFactor;                              // 0x0570(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _angleScoreFactor;                                 // 0x0574(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sameTargetScoreFactor;                            // 0x0578(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawToTarget;                                      // 0x057C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pitchToTarget;                                    // 0x0580(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasVisibleTarget;                                 // 0x0584(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_585[0x18B];                                    // 0x0585(0x018B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChaseEnded(class ADBDPlayer* target, float chaseTime);
	void OnChaseStarted(class ADBDPlayer* target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookAtTargetKillerSubAnimInstance">();
	}
	static class ULookAtTargetKillerSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookAtTargetKillerSubAnimInstance>();
	}
};
static_assert(alignof(ULookAtTargetKillerSubAnimInstance) == 0x000010, "Wrong alignment on ULookAtTargetKillerSubAnimInstance");
static_assert(sizeof(ULookAtTargetKillerSubAnimInstance) == 0x000710, "Wrong size on ULookAtTargetKillerSubAnimInstance");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _maxDistanceForTargetDetection) == 0x000550, "Member 'ULookAtTargetKillerSubAnimInstance::_maxDistanceForTargetDetection' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _headSocket) == 0x000554, "Member 'ULookAtTargetKillerSubAnimInstance::_headSocket' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _rootSocket) == 0x000560, "Member 'ULookAtTargetKillerSubAnimInstance::_rootSocket' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _preferredMinLookAtTime) == 0x00056C, "Member 'ULookAtTargetKillerSubAnimInstance::_preferredMinLookAtTime' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _distanceScoreFactor) == 0x000570, "Member 'ULookAtTargetKillerSubAnimInstance::_distanceScoreFactor' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _angleScoreFactor) == 0x000574, "Member 'ULookAtTargetKillerSubAnimInstance::_angleScoreFactor' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _sameTargetScoreFactor) == 0x000578, "Member 'ULookAtTargetKillerSubAnimInstance::_sameTargetScoreFactor' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _yawToTarget) == 0x00057C, "Member 'ULookAtTargetKillerSubAnimInstance::_yawToTarget' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _pitchToTarget) == 0x000580, "Member 'ULookAtTargetKillerSubAnimInstance::_pitchToTarget' has a wrong offset!");
static_assert(offsetof(ULookAtTargetKillerSubAnimInstance, _hasVisibleTarget) == 0x000584, "Member 'ULookAtTargetKillerSubAnimInstance::_hasVisibleTarget' has a wrong offset!");

// Class DBDAnimation.LookAtThreatSurvivorSubAnimInstance
// 0x0160 (0x06B0 - 0x0550)
class ULookAtThreatSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	float                                         _maxDistanceForThreatDetection;                    // 0x0548(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _headSocket;                                       // 0x054C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _rootSocket;                                       // 0x0558(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawToThreat;                                      // 0x0564(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pitchToThreat;                                    // 0x0568(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isVisibleThreat;                                  // 0x056C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_56D[0x143];                                    // 0x056D(0x0143)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LookAtThreatSurvivorSubAnimInstance">();
	}
	static class ULookAtThreatSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULookAtThreatSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(ULookAtThreatSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on ULookAtThreatSurvivorSubAnimInstance");
static_assert(sizeof(ULookAtThreatSurvivorSubAnimInstance) == 0x0006B0, "Wrong size on ULookAtThreatSurvivorSubAnimInstance");
static_assert(offsetof(ULookAtThreatSurvivorSubAnimInstance, _maxDistanceForThreatDetection) == 0x000548, "Member 'ULookAtThreatSurvivorSubAnimInstance::_maxDistanceForThreatDetection' has a wrong offset!");
static_assert(offsetof(ULookAtThreatSurvivorSubAnimInstance, _headSocket) == 0x00054C, "Member 'ULookAtThreatSurvivorSubAnimInstance::_headSocket' has a wrong offset!");
static_assert(offsetof(ULookAtThreatSurvivorSubAnimInstance, _rootSocket) == 0x000558, "Member 'ULookAtThreatSurvivorSubAnimInstance::_rootSocket' has a wrong offset!");
static_assert(offsetof(ULookAtThreatSurvivorSubAnimInstance, _yawToThreat) == 0x000564, "Member 'ULookAtThreatSurvivorSubAnimInstance::_yawToThreat' has a wrong offset!");
static_assert(offsetof(ULookAtThreatSurvivorSubAnimInstance, _pitchToThreat) == 0x000568, "Member 'ULookAtThreatSurvivorSubAnimInstance::_pitchToThreat' has a wrong offset!");
static_assert(offsetof(ULookAtThreatSurvivorSubAnimInstance, _isVisibleThreat) == 0x00056C, "Member 'ULookAtThreatSurvivorSubAnimInstance::_isVisibleThreat' has a wrong offset!");

// Class DBDAnimation.MeshRotationCorrectionSubAnimInstance
// 0x0020 (0x0570 - 0x0550)
class UMeshRotationCorrectionSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	float                                         _rotationInterpSpeed;                              // 0x0548(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x054C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54D[0x3];                                      // 0x054D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               _toSlopeRotation;                                  // 0x0550(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_55C[0x4];                                      // 0x055C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterMovementComponent*            _movementComponent;                                // 0x0560(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeshRotationCorrectionSubAnimInstance">();
	}
	static class UMeshRotationCorrectionSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeshRotationCorrectionSubAnimInstance>();
	}
};
static_assert(alignof(UMeshRotationCorrectionSubAnimInstance) == 0x000010, "Wrong alignment on UMeshRotationCorrectionSubAnimInstance");
static_assert(sizeof(UMeshRotationCorrectionSubAnimInstance) == 0x000570, "Wrong size on UMeshRotationCorrectionSubAnimInstance");
static_assert(offsetof(UMeshRotationCorrectionSubAnimInstance, _rotationInterpSpeed) == 0x000548, "Member 'UMeshRotationCorrectionSubAnimInstance::_rotationInterpSpeed' has a wrong offset!");
static_assert(offsetof(UMeshRotationCorrectionSubAnimInstance, _isCrawling) == 0x00054C, "Member 'UMeshRotationCorrectionSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UMeshRotationCorrectionSubAnimInstance, _toSlopeRotation) == 0x000550, "Member 'UMeshRotationCorrectionSubAnimInstance::_toSlopeRotation' has a wrong offset!");
static_assert(offsetof(UMeshRotationCorrectionSubAnimInstance, _movementComponent) == 0x000560, "Member 'UMeshRotationCorrectionSubAnimInstance::_movementComponent' has a wrong offset!");

// Class DBDAnimation.OpenChestSurvivorSubAnimInstance
// 0x0020 (0x0570 - 0x0550)
class UOpenChestSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _isInteractingWithChest;                           // 0x0548(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_549[0x3];                                      // 0x0549(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _interactionPhase;                                 // 0x054C(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInteractingWithOpenChest;                       // 0x0558(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_559[0x3];                                      // 0x0559(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _snapPosition;                                     // 0x055C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isVomiting;                                       // 0x0568(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_569[0x7];                                      // 0x0569(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpenChestSurvivorSubAnimInstance">();
	}
	static class UOpenChestSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpenChestSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UOpenChestSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UOpenChestSurvivorSubAnimInstance");
static_assert(sizeof(UOpenChestSurvivorSubAnimInstance) == 0x000570, "Wrong size on UOpenChestSurvivorSubAnimInstance");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _isInteractingWithChest) == 0x000548, "Member 'UOpenChestSurvivorSubAnimInstance::_isInteractingWithChest' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _interactionPhase) == 0x00054C, "Member 'UOpenChestSurvivorSubAnimInstance::_interactionPhase' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _isInteractingWithOpenChest) == 0x000558, "Member 'UOpenChestSurvivorSubAnimInstance::_isInteractingWithOpenChest' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _snapPosition) == 0x00055C, "Member 'UOpenChestSurvivorSubAnimInstance::_snapPosition' has a wrong offset!");
static_assert(offsetof(UOpenChestSurvivorSubAnimInstance, _isVomiting) == 0x000568, "Member 'UOpenChestSurvivorSubAnimInstance::_isVomiting' has a wrong offset!");

// Class DBDAnimation.PalletAnimInstance
// 0x0020 (0x02F0 - 0x02D0)
class UPalletAnimInstance final : public USleepingAnimInstance
{
public:
	bool                                          _isPulledDown;                                     // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingPulledUp;                                  // 0x02C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingDestroyed;                                 // 0x02CA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CB[0x1];                                      // 0x02CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _isBeingDestroyedPlayRate;                         // 0x02CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimSequenceSelector                  _destroyPalletAnim;                                // 0x02D0(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeingDestroyedStarted(class ADBDPlayer* player);
	void OnBeingDestroyedStopped();
	void OnBeingPulledUpStarted(class ADBDPlayer* player);
	void OnBeingPulledUpStopped();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletAnimInstance">();
	}
	static class UPalletAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalletAnimInstance>();
	}
};
static_assert(alignof(UPalletAnimInstance) == 0x000010, "Wrong alignment on UPalletAnimInstance");
static_assert(sizeof(UPalletAnimInstance) == 0x0002F0, "Wrong size on UPalletAnimInstance");
static_assert(offsetof(UPalletAnimInstance, _isPulledDown) == 0x0002C8, "Member 'UPalletAnimInstance::_isPulledDown' has a wrong offset!");
static_assert(offsetof(UPalletAnimInstance, _isBeingPulledUp) == 0x0002C9, "Member 'UPalletAnimInstance::_isBeingPulledUp' has a wrong offset!");
static_assert(offsetof(UPalletAnimInstance, _isBeingDestroyed) == 0x0002CA, "Member 'UPalletAnimInstance::_isBeingDestroyed' has a wrong offset!");
static_assert(offsetof(UPalletAnimInstance, _isBeingDestroyedPlayRate) == 0x0002CC, "Member 'UPalletAnimInstance::_isBeingDestroyedPlayRate' has a wrong offset!");
static_assert(offsetof(UPalletAnimInstance, _destroyPalletAnim) == 0x0002D0, "Member 'UPalletAnimInstance::_destroyPalletAnim' has a wrong offset!");

// Class DBDAnimation.RepairGeneratorSubAnimInstance
// 0x0090 (0x0350 - 0x02C0)
class URepairGeneratorSubAnimInstance final : public UAnimInstance
{
public:
	class AGenerator*                             _owningGenerator;                                  // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingRepaired;                                  // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          _repairingSurvivor;                                // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _animSequence;                                     // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _interactionTag;                                   // 0x02E0(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _currentAnimId;                                    // 0x02EC(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FGameplayTag, class UAnimSequence*> _taggedAnimSequences;                            // 0x02F8(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RepairGeneratorSubAnimInstance">();
	}
	static class URepairGeneratorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URepairGeneratorSubAnimInstance>();
	}
};
static_assert(alignof(URepairGeneratorSubAnimInstance) == 0x000010, "Wrong alignment on URepairGeneratorSubAnimInstance");
static_assert(sizeof(URepairGeneratorSubAnimInstance) == 0x000350, "Wrong size on URepairGeneratorSubAnimInstance");
static_assert(offsetof(URepairGeneratorSubAnimInstance, _owningGenerator) == 0x0002C0, "Member 'URepairGeneratorSubAnimInstance::_owningGenerator' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSubAnimInstance, _isBeingRepaired) == 0x0002C8, "Member 'URepairGeneratorSubAnimInstance::_isBeingRepaired' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSubAnimInstance, _repairingSurvivor) == 0x0002D0, "Member 'URepairGeneratorSubAnimInstance::_repairingSurvivor' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSubAnimInstance, _animSequence) == 0x0002D8, "Member 'URepairGeneratorSubAnimInstance::_animSequence' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSubAnimInstance, _interactionTag) == 0x0002E0, "Member 'URepairGeneratorSubAnimInstance::_interactionTag' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSubAnimInstance, _currentAnimId) == 0x0002EC, "Member 'URepairGeneratorSubAnimInstance::_currentAnimId' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSubAnimInstance, _taggedAnimSequences) == 0x0002F8, "Member 'URepairGeneratorSubAnimInstance::_taggedAnimSequences' has a wrong offset!");

// Class DBDAnimation.RepairGeneratorSurvivorSubAnimInstance
// 0x0070 (0x05C0 - 0x0550)
class URepairGeneratorSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_548[0x48];                                     // 0x0548(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _snapPosition;                                     // 0x0590(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _side;                                             // 0x059C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _repairAnimIndex;                                  // 0x05A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A4[0xC];                                      // 0x05A4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isRepairingGenerator;                             // 0x05B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _rightFootDown;                                    // 0x05B1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B2[0x2];                                      // 0x05B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _animSequenceVariationCount;                       // 0x05B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isVomiting;                                       // 0x05B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasSkillCheckFailed;                              // 0x05B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isS34P01Accumulating;                             // 0x05BA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5BB[0x5];                                      // 0x05BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RepairGeneratorSurvivorSubAnimInstance">();
	}
	static class URepairGeneratorSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URepairGeneratorSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(URepairGeneratorSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on URepairGeneratorSurvivorSubAnimInstance");
static_assert(sizeof(URepairGeneratorSurvivorSubAnimInstance) == 0x0005C0, "Wrong size on URepairGeneratorSurvivorSubAnimInstance");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _snapPosition) == 0x000590, "Member 'URepairGeneratorSurvivorSubAnimInstance::_snapPosition' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _side) == 0x00059C, "Member 'URepairGeneratorSurvivorSubAnimInstance::_side' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _repairAnimIndex) == 0x0005A0, "Member 'URepairGeneratorSurvivorSubAnimInstance::_repairAnimIndex' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _isRepairingGenerator) == 0x0005B0, "Member 'URepairGeneratorSurvivorSubAnimInstance::_isRepairingGenerator' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _rightFootDown) == 0x0005B1, "Member 'URepairGeneratorSurvivorSubAnimInstance::_rightFootDown' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _animSequenceVariationCount) == 0x0005B4, "Member 'URepairGeneratorSurvivorSubAnimInstance::_animSequenceVariationCount' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _isVomiting) == 0x0005B8, "Member 'URepairGeneratorSurvivorSubAnimInstance::_isVomiting' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _hasSkillCheckFailed) == 0x0005B9, "Member 'URepairGeneratorSurvivorSubAnimInstance::_hasSkillCheckFailed' has a wrong offset!");
static_assert(offsetof(URepairGeneratorSurvivorSubAnimInstance, _isS34P01Accumulating) == 0x0005BA, "Member 'URepairGeneratorSurvivorSubAnimInstance::_isS34P01Accumulating' has a wrong offset!");

// Class DBDAnimation.SabotageSurvivorSubAnimInstance
// 0x0040 (0x0590 - 0x0550)
class USabotageSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_548[0x40];                                     // 0x0548(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isSabotaging;                                     // 0x0588(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasSkillCheckFailed;                              // 0x0589(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58A[0x6];                                      // 0x058A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SabotageSurvivorSubAnimInstance">();
	}
	static class USabotageSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USabotageSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(USabotageSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on USabotageSurvivorSubAnimInstance");
static_assert(sizeof(USabotageSurvivorSubAnimInstance) == 0x000590, "Wrong size on USabotageSurvivorSubAnimInstance");
static_assert(offsetof(USabotageSurvivorSubAnimInstance, _isSabotaging) == 0x000588, "Member 'USabotageSurvivorSubAnimInstance::_isSabotaging' has a wrong offset!");
static_assert(offsetof(USabotageSurvivorSubAnimInstance, _hasSkillCheckFailed) == 0x000589, "Member 'USabotageSurvivorSubAnimInstance::_hasSkillCheckFailed' has a wrong offset!");

// Class DBDAnimation.ScreamSurvivorSubAnimInstance
// 0x0000 (0x0550 - 0x0550)
class UScreamSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	bool                                          _screamTrigger;                                    // 0x0548(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_549[0x7];                                      // 0x0549(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetScreamTrigger();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreamSurvivorSubAnimInstance">();
	}
	static class UScreamSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreamSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UScreamSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UScreamSurvivorSubAnimInstance");
static_assert(sizeof(UScreamSurvivorSubAnimInstance) == 0x000550, "Wrong size on UScreamSurvivorSubAnimInstance");
static_assert(offsetof(UScreamSurvivorSubAnimInstance, _screamTrigger) == 0x000548, "Member 'UScreamSurvivorSubAnimInstance::_screamTrigger' has a wrong offset!");

// Class DBDAnimation.SkillCheckFailureTracker
// 0x0000 (0x0000 - 0x0000)
class ISkillCheckFailureTracker final
{
public:
	void OnSkillCheckFailed(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void ResetSkillCheckFailed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillCheckFailureTracker">();
	}
	static class ISkillCheckFailureTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISkillCheckFailureTracker>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISkillCheckFailureTracker) == 0x000001, "Wrong alignment on ISkillCheckFailureTracker");
static_assert(sizeof(ISkillCheckFailureTracker) == 0x000001, "Wrong size on ISkillCheckFailureTracker");

// Class DBDAnimation.SurvivorAimableArmSensor
// 0x0038 (0x0170 - 0x0138)
class USurvivorAimableArmSensor final : public UArmIKSensorComponent
{
public:
	uint8                                         Pad_138[0x10];                                     // 0x0138(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ACollectable*                           _aimableCollectable;                               // 0x0148(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimableComponent*                      _aimable;                                          // 0x0150(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x18];                                     // 0x0158(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAimableArmSensor">();
	}
	static class USurvivorAimableArmSensor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAimableArmSensor>();
	}
};
static_assert(alignof(USurvivorAimableArmSensor) == 0x000008, "Wrong alignment on USurvivorAimableArmSensor");
static_assert(sizeof(USurvivorAimableArmSensor) == 0x000170, "Wrong size on USurvivorAimableArmSensor");
static_assert(offsetof(USurvivorAimableArmSensor, _aimableCollectable) == 0x000148, "Member 'USurvivorAimableArmSensor::_aimableCollectable' has a wrong offset!");
static_assert(offsetof(USurvivorAimableArmSensor, _aimable) == 0x000150, "Member 'USurvivorAimableArmSensor::_aimable' has a wrong offset!");

// Class DBDAnimation.SurvivorAimableSubAnimInstance
// 0x0030 (0x0580 - 0x0550)
class USurvivorAimableSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	float                                         _pitch;                                            // 0x0548(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingAimItem;                                 // 0x054C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAiming;                                         // 0x054D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54E[0x2];                                      // 0x054E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _isAimingAlpha;                                    // 0x0550(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _aimPoint;                                         // 0x0554(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _shoulderToCollisionDistance;                      // 0x0560(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_564[0x1C];                                     // 0x0564(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAimableSubAnimInstance">();
	}
	static class USurvivorAimableSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAimableSubAnimInstance>();
	}
};
static_assert(alignof(USurvivorAimableSubAnimInstance) == 0x000010, "Wrong alignment on USurvivorAimableSubAnimInstance");
static_assert(sizeof(USurvivorAimableSubAnimInstance) == 0x000580, "Wrong size on USurvivorAimableSubAnimInstance");
static_assert(offsetof(USurvivorAimableSubAnimInstance, _pitch) == 0x000548, "Member 'USurvivorAimableSubAnimInstance::_pitch' has a wrong offset!");
static_assert(offsetof(USurvivorAimableSubAnimInstance, _isHoldingAimItem) == 0x00054C, "Member 'USurvivorAimableSubAnimInstance::_isHoldingAimItem' has a wrong offset!");
static_assert(offsetof(USurvivorAimableSubAnimInstance, _isAiming) == 0x00054D, "Member 'USurvivorAimableSubAnimInstance::_isAiming' has a wrong offset!");
static_assert(offsetof(USurvivorAimableSubAnimInstance, _isAimingAlpha) == 0x000550, "Member 'USurvivorAimableSubAnimInstance::_isAimingAlpha' has a wrong offset!");
static_assert(offsetof(USurvivorAimableSubAnimInstance, _aimPoint) == 0x000554, "Member 'USurvivorAimableSubAnimInstance::_aimPoint' has a wrong offset!");
static_assert(offsetof(USurvivorAimableSubAnimInstance, _shoulderToCollisionDistance) == 0x000560, "Member 'USurvivorAimableSubAnimInstance::_shoulderToCollisionDistance' has a wrong offset!");

// Class DBDAnimation.SurvivorAnimInstance
// 0x0110 (0x0660 - 0x0550)
class USurvivorAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	class ACamperPlayer*                          CamperPlayer;                                      // 0x0548(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHooked;                                          // 0x0550(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSacrificeStruggling;                             // 0x0551(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_552[0x6];                                      // 0x0552(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           MontageMadnessTierUp;                              // 0x0558(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAnimCompositeBase*>             ArrayCarryAttackMontage;                           // 0x0560(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EIntroState                                   _introState;                                       // 0x0570(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFrightScreaming;                                // 0x0571(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBeingCarried;                                    // 0x0572(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBeingPutOnHook;                                  // 0x0573(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCrouched;                                        // 0x0574(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECamperGuidedAction                           GuidedAction;                                      // 0x0575(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCrawling;                                        // 0x0576(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDead;                                            // 0x0577(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpeed;                                          // 0x0578(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInsideCloset;                                    // 0x057C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_57D[0x3];                                      // 0x057D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IsPlayingMadnessTierUpWeight;                      // 0x0580(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBeingKilled;                                     // 0x0584(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBeingHealed;                                     // 0x0585(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCarryAttackSucess;                               // 0x0586(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUsingAimItem;                                    // 0x0587(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingAimItem;                                  // 0x0588(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AllowLookAt;                                       // 0x0589(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58A[0x2];                                      // 0x058A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DropStaggerTimeLeft;                               // 0x058C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RightArmIKAlpha;                                   // 0x0590(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_594[0xC];                                      // 0x0594(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RightHandIKTransform;                              // 0x05A0(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          Strafe;                                            // 0x05D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInteracting;                                     // 0x05D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Injured;                                           // 0x05D2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionAnimation                         InteractionType;                                   // 0x05D3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionAnimation                         PreviousInteractionType;                           // 0x05D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSlasherInFPV;                                    // 0x05D5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D6[0x2];                                      // 0x05D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CarriedAlpha;                                      // 0x05D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingHandleItem;                               // 0x05DC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingSmallItem;                                // 0x05DD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingFirecracker;                              // 0x05DE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingFlashbang;                                // 0x05DF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingVaccine;                                  // 0x05E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingAnyItem;                                  // 0x05E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingLamentConfiguration;                      // 0x05E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingFragileObject;                            // 0x05E3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHoldingSprayObject;                              // 0x05E4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsArmOverrideDisabled;                             // 0x05E5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          InAir;                                             // 0x05E6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E7[0x1];                                      // 0x05E7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _walkAnimSpeed;                                    // 0x05E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Direction;                                         // 0x05EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Pitch;                                             // 0x05F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Yaw;                                               // 0x05F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RightFootEffectorLocation;                         // 0x05F8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LeftFootEffectorLocation;                          // 0x0604(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Idle;                                              // 0x0610(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HasAnyMontagePlaying;                              // 0x0611(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_612[0x2];                                      // 0x0612(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentlyPlayerMontageId;                          // 0x0614(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBeingCarriedByTheSpirit;                         // 0x0620(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBeingCarriedByTheNightmare;                      // 0x0621(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBeingCarriedByThePig;                            // 0x0622(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBeingCarriedByTheHag;                            // 0x0623(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBeingCarriedByTheLegion;                         // 0x0624(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBeingCarriedByTheGhostFace;                      // 0x0625(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUsingDeadHard;                                   // 0x0626(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsPlayingWakeUpOther;                              // 0x0627(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsPlayingFreddyMori;                               // 0x0628(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HasLinkInput;                                      // 0x0629(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMale;                                           // 0x062A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62B[0x35];                                     // 0x062B(0x0035)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAudioRepairRateRadius(int32 distance);
	void OnInfectiousFrightScream();
	void SetAudioRummageAkEvent(class FName distance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAnimInstance">();
	}
	static class USurvivorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAnimInstance>();
	}
};
static_assert(alignof(USurvivorAnimInstance) == 0x000010, "Wrong alignment on USurvivorAnimInstance");
static_assert(sizeof(USurvivorAnimInstance) == 0x000660, "Wrong size on USurvivorAnimInstance");
static_assert(offsetof(USurvivorAnimInstance, CamperPlayer) == 0x000548, "Member 'USurvivorAnimInstance::CamperPlayer' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHooked) == 0x000550, "Member 'USurvivorAnimInstance::IsHooked' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsSacrificeStruggling) == 0x000551, "Member 'USurvivorAnimInstance::IsSacrificeStruggling' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, MontageMadnessTierUp) == 0x000558, "Member 'USurvivorAnimInstance::MontageMadnessTierUp' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, ArrayCarryAttackMontage) == 0x000560, "Member 'USurvivorAnimInstance::ArrayCarryAttackMontage' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, _introState) == 0x000570, "Member 'USurvivorAnimInstance::_introState' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, _isFrightScreaming) == 0x000571, "Member 'USurvivorAnimInstance::_isFrightScreaming' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsBeingCarried) == 0x000572, "Member 'USurvivorAnimInstance::IsBeingCarried' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsBeingPutOnHook) == 0x000573, "Member 'USurvivorAnimInstance::IsBeingPutOnHook' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsCrouched) == 0x000574, "Member 'USurvivorAnimInstance::IsCrouched' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, GuidedAction) == 0x000575, "Member 'USurvivorAnimInstance::GuidedAction' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsCrawling) == 0x000576, "Member 'USurvivorAnimInstance::IsCrawling' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsDead) == 0x000577, "Member 'USurvivorAnimInstance::IsDead' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, MaxSpeed) == 0x000578, "Member 'USurvivorAnimInstance::MaxSpeed' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsInsideCloset) == 0x00057C, "Member 'USurvivorAnimInstance::IsInsideCloset' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsPlayingMadnessTierUpWeight) == 0x000580, "Member 'USurvivorAnimInstance::IsPlayingMadnessTierUpWeight' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsBeingKilled) == 0x000584, "Member 'USurvivorAnimInstance::IsBeingKilled' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsBeingHealed) == 0x000585, "Member 'USurvivorAnimInstance::IsBeingHealed' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsCarryAttackSucess) == 0x000586, "Member 'USurvivorAnimInstance::IsCarryAttackSucess' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsUsingAimItem) == 0x000587, "Member 'USurvivorAnimInstance::IsUsingAimItem' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingAimItem) == 0x000588, "Member 'USurvivorAnimInstance::IsHoldingAimItem' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, AllowLookAt) == 0x000589, "Member 'USurvivorAnimInstance::AllowLookAt' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, DropStaggerTimeLeft) == 0x00058C, "Member 'USurvivorAnimInstance::DropStaggerTimeLeft' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, RightArmIKAlpha) == 0x000590, "Member 'USurvivorAnimInstance::RightArmIKAlpha' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, RightHandIKTransform) == 0x0005A0, "Member 'USurvivorAnimInstance::RightHandIKTransform' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, Strafe) == 0x0005D0, "Member 'USurvivorAnimInstance::Strafe' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsInteracting) == 0x0005D1, "Member 'USurvivorAnimInstance::IsInteracting' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, Injured) == 0x0005D2, "Member 'USurvivorAnimInstance::Injured' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, InteractionType) == 0x0005D3, "Member 'USurvivorAnimInstance::InteractionType' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, PreviousInteractionType) == 0x0005D4, "Member 'USurvivorAnimInstance::PreviousInteractionType' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsSlasherInFPV) == 0x0005D5, "Member 'USurvivorAnimInstance::IsSlasherInFPV' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, CarriedAlpha) == 0x0005D8, "Member 'USurvivorAnimInstance::CarriedAlpha' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingHandleItem) == 0x0005DC, "Member 'USurvivorAnimInstance::IsHoldingHandleItem' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingSmallItem) == 0x0005DD, "Member 'USurvivorAnimInstance::IsHoldingSmallItem' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingFirecracker) == 0x0005DE, "Member 'USurvivorAnimInstance::IsHoldingFirecracker' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingFlashbang) == 0x0005DF, "Member 'USurvivorAnimInstance::IsHoldingFlashbang' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingVaccine) == 0x0005E0, "Member 'USurvivorAnimInstance::IsHoldingVaccine' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingAnyItem) == 0x0005E1, "Member 'USurvivorAnimInstance::IsHoldingAnyItem' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingLamentConfiguration) == 0x0005E2, "Member 'USurvivorAnimInstance::IsHoldingLamentConfiguration' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingFragileObject) == 0x0005E3, "Member 'USurvivorAnimInstance::IsHoldingFragileObject' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsHoldingSprayObject) == 0x0005E4, "Member 'USurvivorAnimInstance::IsHoldingSprayObject' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsArmOverrideDisabled) == 0x0005E5, "Member 'USurvivorAnimInstance::IsArmOverrideDisabled' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, InAir) == 0x0005E6, "Member 'USurvivorAnimInstance::InAir' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, _walkAnimSpeed) == 0x0005E8, "Member 'USurvivorAnimInstance::_walkAnimSpeed' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, Direction) == 0x0005EC, "Member 'USurvivorAnimInstance::Direction' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, Pitch) == 0x0005F0, "Member 'USurvivorAnimInstance::Pitch' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, Yaw) == 0x0005F4, "Member 'USurvivorAnimInstance::Yaw' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, RightFootEffectorLocation) == 0x0005F8, "Member 'USurvivorAnimInstance::RightFootEffectorLocation' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, LeftFootEffectorLocation) == 0x000604, "Member 'USurvivorAnimInstance::LeftFootEffectorLocation' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, Idle) == 0x000610, "Member 'USurvivorAnimInstance::Idle' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, HasAnyMontagePlaying) == 0x000611, "Member 'USurvivorAnimInstance::HasAnyMontagePlaying' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, CurrentlyPlayerMontageId) == 0x000614, "Member 'USurvivorAnimInstance::CurrentlyPlayerMontageId' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsBeingCarriedByTheSpirit) == 0x000620, "Member 'USurvivorAnimInstance::IsBeingCarriedByTheSpirit' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsBeingCarriedByTheNightmare) == 0x000621, "Member 'USurvivorAnimInstance::IsBeingCarriedByTheNightmare' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsBeingCarriedByThePig) == 0x000622, "Member 'USurvivorAnimInstance::IsBeingCarriedByThePig' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsBeingCarriedByTheHag) == 0x000623, "Member 'USurvivorAnimInstance::IsBeingCarriedByTheHag' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsBeingCarriedByTheLegion) == 0x000624, "Member 'USurvivorAnimInstance::IsBeingCarriedByTheLegion' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsBeingCarriedByTheGhostFace) == 0x000625, "Member 'USurvivorAnimInstance::IsBeingCarriedByTheGhostFace' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsUsingDeadHard) == 0x000626, "Member 'USurvivorAnimInstance::IsUsingDeadHard' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsPlayingWakeUpOther) == 0x000627, "Member 'USurvivorAnimInstance::IsPlayingWakeUpOther' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, IsPlayingFreddyMori) == 0x000628, "Member 'USurvivorAnimInstance::IsPlayingFreddyMori' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, HasLinkInput) == 0x000629, "Member 'USurvivorAnimInstance::HasLinkInput' has a wrong offset!");
static_assert(offsetof(USurvivorAnimInstance, _isMale) == 0x00062A, "Member 'USurvivorAnimInstance::_isMale' has a wrong offset!");

// Class DBDAnimation.WakerObjectAnimInstance
// 0x0040 (0x0300 - 0x02C0)
class UWakerObjectAnimInstance final : public UAnimInstance
{
public:
	float                                         _reappearTimerCooldown;                            // 0x02C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _wakeUpCharge;                                     // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _chargeStarted;                                    // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _interactionComplete;                              // 0x02C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _outEnd;                                           // 0x02CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _reset;                                            // 0x02CB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _inEnd;                                            // 0x02CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _wakerObjectStarted;                               // 0x02CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _respawnEnd;                                       // 0x02CE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _cancelEnd;                                        // 0x02CF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x30];                                     // 0x02D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReappear();
	void ResetReappearTimer();

	class AWakerObject* GetWakerObject() const;
	float GetWakerObjectCharge() const;
	bool GetWakerObjectChargeComplete() const;
	bool GetWakerObjectStarted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WakerObjectAnimInstance">();
	}
	static class UWakerObjectAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWakerObjectAnimInstance>();
	}
};
static_assert(alignof(UWakerObjectAnimInstance) == 0x000010, "Wrong alignment on UWakerObjectAnimInstance");
static_assert(sizeof(UWakerObjectAnimInstance) == 0x000300, "Wrong size on UWakerObjectAnimInstance");
static_assert(offsetof(UWakerObjectAnimInstance, _reappearTimerCooldown) == 0x0002C0, "Member 'UWakerObjectAnimInstance::_reappearTimerCooldown' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _wakeUpCharge) == 0x0002C4, "Member 'UWakerObjectAnimInstance::_wakeUpCharge' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _chargeStarted) == 0x0002C8, "Member 'UWakerObjectAnimInstance::_chargeStarted' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _interactionComplete) == 0x0002C9, "Member 'UWakerObjectAnimInstance::_interactionComplete' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _outEnd) == 0x0002CA, "Member 'UWakerObjectAnimInstance::_outEnd' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _reset) == 0x0002CB, "Member 'UWakerObjectAnimInstance::_reset' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _inEnd) == 0x0002CC, "Member 'UWakerObjectAnimInstance::_inEnd' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _wakerObjectStarted) == 0x0002CD, "Member 'UWakerObjectAnimInstance::_wakerObjectStarted' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _respawnEnd) == 0x0002CE, "Member 'UWakerObjectAnimInstance::_respawnEnd' has a wrong offset!");
static_assert(offsetof(UWakerObjectAnimInstance, _cancelEnd) == 0x0002CF, "Member 'UWakerObjectAnimInstance::_cancelEnd' has a wrong offset!");

}

