#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDGameplay

#include "Basic.hpp"

#include "DBDGameplay_classes.hpp"
#include "DBDGameplay_parameters.hpp"


namespace SDK
{

// Function DBDGameplay.BaseHusk.Cosmetic_InitializeSkeletalMesh
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseHusk::Cosmetic_InitializeSkeletalMesh(class USkeletalMeshComponent* mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseHusk", "Cosmetic_InitializeSkeletalMesh");

	Params::BaseHusk_Cosmetic_InitializeSkeletalMesh Parms{};

	Parms.mesh = mesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.BaseHusk.InitializeHusk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomizedSkeletalMesh*          customizedSkeletalMeshToCopy                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseHusk::InitializeHusk(class UCustomizedSkeletalMesh* customizedSkeletalMeshToCopy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseHusk", "InitializeHusk");

	Params::BaseHusk_InitializeHusk Parms{};

	Parms.customizedSkeletalMeshToCopy = customizedSkeletalMeshToCopy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BaseHusk.SetHuskVisibility
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseHusk::SetHuskVisibility(bool visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseHusk", "SetHuskVisibility");

	Params::BaseHusk_SetHuskVisibility Parms{};

	Parms.visible = visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BaseHusk.SetScalarParameterOnAllChildrenMeshes
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             parameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseHusk::SetScalarParameterOnAllChildrenMeshes(class FName parameterName, float value, class USkeletalMeshComponent* mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseHusk", "SetScalarParameterOnAllChildrenMeshes");

	Params::BaseHusk_SetScalarParameterOnAllChildrenMeshes Parms{};

	Parms.parameterName = parameterName;
	Parms.value = value;
	Parms.mesh = mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PoseableHusk.CapturePose
// (Final, Native, Public, BlueprintCallable)

void APoseableHusk::CapturePose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableHusk", "CapturePose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PoseableHusk.Cosmetic_OnAnimationPoseCaptured
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void APoseableHusk::Cosmetic_OnAnimationPoseCaptured()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableHusk", "Cosmetic_OnAnimationPoseCaptured");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.PoseableHusk.OnActiveStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APoseableHusk::OnActiveStateChanged(bool isActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableHusk", "OnActiveStateChanged");

	Params::PoseableHusk_OnActiveStateChanged Parms{};

	Parms.isActive = isActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.PoseableHusk.SetIsActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APoseableHusk::SetIsActive(bool isActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableHusk", "SetIsActive");

	Params::PoseableHusk_SetIsActive Parms{};

	Parms.isActive = isActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PoseableHusk.GetIsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APoseableHusk::GetIsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseableHusk", "GetIsActive");

	Params::PoseableHusk_GetIsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.AimableComponent.SetMaxAimDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   maxAimDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimableComponent::SetMaxAimDistance(float maxAimDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimableComponent", "SetMaxAimDistance");

	Params::AimableComponent_SetMaxAimDistance Parms{};

	Parms.maxAimDistance = maxAimDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimableComponent.SetOcclusionIgnoredActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            ignoredActors                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UAimableComponent::SetOcclusionIgnoredActors(const TArray<class AActor*>& ignoredActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimableComponent", "SetOcclusionIgnoredActors");

	Params::AimableComponent_SetOcclusionIgnoredActors Parms{};

	Parms.ignoredActors = std::move(ignoredActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimableComponent.SetProcessors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class UAimPointProcessor*>&processors                                             (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAimableComponent::SetProcessors(const TArray<class UAimPointProcessor*>& processors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimableComponent", "SetProcessors");

	Params::AimableComponent_SetProcessors Parms{};

	Parms.processors = std::move(processors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AISense_Terror.ReportTerrorEvent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          worldContextObj                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTerrorRadiusEmitterComponent*    terrorEmitter                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAISense_Terror::ReportTerrorEvent(class UObject* worldContextObj, const struct FVector& location, class AActor* instigator, class UTerrorRadiusEmitterComponent* terrorEmitter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AISense_Terror", "ReportTerrorEvent");

	Params::AISense_Terror_ReportTerrorEvent Parms{};

	Parms.worldContextObj = worldContextObj;
	Parms.location = std::move(location);
	Parms.instigator = instigator;
	Parms.terrorEmitter = terrorEmitter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PowerChargeComponent.OnCurrentChargeChanged
// (Final, Native, Private)
// Parameters:
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPowerChargeComponent::OnCurrentChargeChanged(float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerChargeComponent", "OnCurrentChargeChanged");

	Params::PowerChargeComponent_OnCurrentChargeChanged Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PowerChargeComponent.OnRep_CurrentCharge
// (Final, Native, Private)

void UPowerChargeComponent::OnRep_CurrentCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerChargeComponent", "OnRep_CurrentCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseAmplitude
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             amplitude                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetBaseInaccuracyNoiseAmplitude(const float amplitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetBaseInaccuracyNoiseAmplitude");

	Params::AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude Parms{};

	Parms.amplitude = amplitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseFrequency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             frequency                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetBaseInaccuracyNoiseFrequency(const float frequency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetBaseInaccuracyNoiseFrequency");

	Params::AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency Parms{};

	Parms.frequency = frequency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseOctaveCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             octaveCount                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetBaseInaccuracyNoiseOctaveCount(const int32 octaveCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetBaseInaccuracyNoiseOctaveCount");

	Params::AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount Parms{};

	Parms.octaveCount = octaveCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoisePersistence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             noisePersistence                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetBaseInaccuracyNoisePersistence(const float noisePersistence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetBaseInaccuracyNoisePersistence");

	Params::AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence Parms{};

	Parms.noisePersistence = noisePersistence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetNoiseAmplitudeMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetNoiseAmplitudeMultiplier(const float multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetNoiseAmplitudeMultiplier");

	Params::AimPointPerlinNoise_SetNoiseAmplitudeMultiplier Parms{};

	Parms.multiplier = multiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AimPointPerlinNoise.SetNoiseFrequencyMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAimPointPerlinNoise::SetNoiseFrequencyMultiplier(const float multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimPointPerlinNoise", "SetNoiseFrequencyMultiplier");

	Params::AimPointPerlinNoise_SetNoiseFrequencyMultiplier Parms{};

	Parms.multiplier = multiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RangeToActorsTrackerComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void URangeToActorsTrackerComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangeToActorsTrackerComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AuraOverriderComponent.ForceShowAura
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isAlwaysVisible                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             minimumOutlineDistance                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuraOverriderComponent::ForceShowAura(const class AActor* actor, const struct FLinearColor& color, bool isAlwaysVisible, const float minimumOutlineDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuraOverriderComponent", "ForceShowAura");

	Params::AuraOverriderComponent_ForceShowAura Parms{};

	Parms.actor = actor;
	Parms.color = std::move(color);
	Parms.isAlwaysVisible = isAlwaysVisible;
	Parms.minimumOutlineDistance = minimumOutlineDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.AuraOverriderComponent.ResetAura
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuraOverriderComponent::ResetAura(const class AActor* actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuraOverriderComponent", "ResetAura");

	Params::AuraOverriderComponent_ResetAura Parms{};

	Parms.actor = actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.BaseActorAttackableComponent.HitWithProjectile
// (Native, Public, BlueprintCallable)
// Parameters:
// class ABaseProjectile*                  projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseActorAttackableComponent::HitWithProjectile(class ABaseProjectile* projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseActorAttackableComponent", "HitWithProjectile");

	Params::BaseActorAttackableComponent_HitWithProjectile Parms{};

	Parms.projectile = projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightTargetFXComponent.OnIsLitChanged
// (Final, Native, Private)
// Parameters:
// bool                                    isLit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlashlightTargetFXComponent::OnIsLitChanged(bool isLit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightTargetFXComponent", "OnIsLitChanged");

	Params::FlashlightTargetFXComponent_OnIsLitChanged Parms{};

	Parms.isLit = isLit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.CamperFootstepCreatorComponent.OnLoudNoiseTriggered
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           originator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigatingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    shouldTrack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  audibleRange                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isQuickAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isDeceivingNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperFootstepCreatorComponent::OnLoudNoiseTriggered(class AActor* originator, class AActor* instigatingActor, const struct FVector& location, bool shouldTrack, float* audibleRange, bool isQuickAction, bool isDeceivingNoise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperFootstepCreatorComponent", "OnLoudNoiseTriggered");

	Params::CamperFootstepCreatorComponent_OnLoudNoiseTriggered Parms{};

	Parms.originator = originator;
	Parms.instigatingActor = instigatingActor;
	Parms.location = std::move(location);
	Parms.shouldTrack = shouldTrack;
	Parms.isQuickAction = isQuickAction;
	Parms.isDeceivingNoise = isDeceivingNoise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (audibleRange != nullptr)
		*audibleRange = Parms.audibleRange;
}


// Function DBDGameplay.CollectableComponentUtilities.GetCollector
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            component                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UCollectableComponentUtilities::GetCollector(const class UActorComponent* component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CollectableComponentUtilities", "GetCollector");

	Params::CollectableComponentUtilities_GetCollector Parms{};

	Parms.component = component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.DebugIndicator.SetColor
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FLinearColor&              color                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADebugIndicator::SetColor(const struct FLinearColor& color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugIndicator", "SetColor");

	Params::DebugIndicator_SetColor Parms{};

	Parms.color = std::move(color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.DebugIndicator.SetVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              visible                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADebugIndicator::SetVisible(const bool visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugIndicator", "SetVisible");

	Params::DebugIndicator_SetVisible Parms{};

	Parms.visible = visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.DecoySlasherComponent.CopyCustomizationFromSlasher
// (Final, Native, Private)

void UDecoySlasherComponent::CopyCustomizationFromSlasher()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecoySlasherComponent", "CopyCustomizationFromSlasher");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.DecoySlasherComponent.DoPostVFXUpdates
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UDecoySlasherComponent::DoPostVFXUpdates(const struct FVector& location, const struct FRotator& rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecoySlasherComponent", "DoPostVFXUpdates");

	Params::DecoySlasherComponent_DoPostVFXUpdates Parms{};

	Parms.location = std::move(location);
	Parms.rotation = std::move(rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.DecoySlasherComponent.OnRealSlasherTerrorRadiusChanged
// (Final, Native, Private)
// Parameters:
// float                                   newValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecoySlasherComponent::OnRealSlasherTerrorRadiusChanged(float newValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecoySlasherComponent", "OnRealSlasherTerrorRadiusChanged");

	Params::DecoySlasherComponent_OnRealSlasherTerrorRadiusChanged Parms{};

	Parms.newValue = newValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.DecoySlasherComponent.SetDecoyIsActive
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    isActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    visibleRedGlow                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecoySlasherComponent::SetDecoyIsActive(bool isActive, const struct FVector& location, const struct FRotator& rotation, bool visibleRedGlow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecoySlasherComponent", "SetDecoyIsActive");

	Params::DecoySlasherComponent_SetDecoyIsActive Parms{};

	Parms.isActive = isActive;
	Parms.location = std::move(location);
	Parms.rotation = std::move(rotation);
	Parms.visibleRedGlow = visibleRedGlow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.DecoySlasherComponent.GetRealSlasher
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASlasherPlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASlasherPlayer* UDecoySlasherComponent::GetRealSlasher() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecoySlasherComponent", "GetRealSlasher");

	Params::DecoySlasherComponent_GetRealSlasher Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.DecoySlasherComponent.IsDecoyActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDecoySlasherComponent::IsDecoyActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecoySlasherComponent", "IsDecoyActive");

	Params::DecoySlasherComponent_IsDecoyActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.EtherealComponent.OnRep_OnIsEtherealChanged
// (Final, Native, Private)

void UEtherealComponent::OnRep_OnIsEtherealChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EtherealComponent", "OnRep_OnIsEtherealChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.EtherealComponent.Server_SetIsEthereal
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// float                                   timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ethereal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEtherealComponent::Server_SetIsEthereal(float timestamp, bool ethereal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EtherealComponent", "Server_SetIsEthereal");

	Params::EtherealComponent_Server_SetIsEthereal Parms{};

	Parms.timestamp = timestamp;
	Parms.ethereal = ethereal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.RangeToActorsTrackerStrategy.OnInRangeToTrackedActorsChanged
// (Final, Native, Private)
// Parameters:
// const bool                              inRange                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URangeToActorsTrackerStrategy::OnInRangeToTrackedActorsChanged(const bool inRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangeToActorsTrackerStrategy", "OnInRangeToTrackedActorsChanged");

	Params::RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged Parms{};

	Parms.inRange = inRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FadeComponent.GetFadePercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFadeComponent::GetFadePercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FadeComponent", "GetFadePercent");

	Params::FadeComponent_GetFadePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.Flashlight.GetSpotlightComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USpotLightComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USpotLightComponent* AFlashlight::GetSpotlightComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Flashlight", "GetSpotlightComponent");

	Params::Flashlight_GetSpotlightComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightableComponent.IsLit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlashlightableComponent::IsLit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightableComponent", "IsLit");

	Params::FlashlightableComponent_IsLit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightComponent.OnRep_IsOwnerLagging
// (Final, Native, Private)

void UFlashlightComponent::OnRep_IsOwnerLagging()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "OnRep_IsOwnerLagging");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightComponent.OnRep_ReplicatedLitFlashlightables
// (Final, Native, Private)

void UFlashlightComponent::OnRep_ReplicatedLitFlashlightables()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "OnRep_ReplicatedLitFlashlightables");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightComponent.Server_SetAndUpdateAutonomousLitFlashlightables
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const TArray<class UFlashlightableComponent*>&newLitFlashlightables                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UFlashlightComponent::Server_SetAndUpdateAutonomousLitFlashlightables(const TArray<class UFlashlightableComponent*>& newLitFlashlightables)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "Server_SetAndUpdateAutonomousLitFlashlightables");

	Params::FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables Parms{};

	Parms.newLitFlashlightables = std::move(newLitFlashlightables);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightComponent.TurnOff
// (Final, Native, Public, BlueprintCallable)

void UFlashlightComponent::TurnOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "TurnOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightComponent.TurnOn
// (Final, Native, Public, BlueprintCallable)

void UFlashlightComponent::TurnOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "TurnOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightComponent.GetEffectiveBlindnessDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightComponent::GetEffectiveBlindnessDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "GetEffectiveBlindnessDuration");

	Params::FlashlightComponent_GetEffectiveBlindnessDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightComponent.GetEffectiveTimeToBlindModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightComponent::GetEffectiveTimeToBlindModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "GetEffectiveTimeToBlindModifier");

	Params::FlashlightComponent_GetEffectiveTimeToBlindModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightComponent.IsOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlashlightComponent::IsOn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightComponent", "IsOn");

	Params::FlashlightComponent_IsOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightConeComponent.GetEffectiveConeHalfAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightConeComponent::GetEffectiveConeHalfAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightConeComponent", "GetEffectiveConeHalfAngle");

	Params::FlashlightConeComponent_GetEffectiveConeHalfAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightConeComponent.GetEffectiveConeLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightConeComponent::GetEffectiveConeLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightConeComponent", "GetEffectiveConeLength");

	Params::FlashlightConeComponent_GetEffectiveConeLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightConeComponent.GetOcclusionDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightConeComponent::GetOcclusionDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightConeComponent", "GetOcclusionDistance");

	Params::FlashlightConeComponent_GetOcclusionDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FlashlightFXComponent.OnCollectedEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       collector                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlashlightFXComponent::OnCollectedEvent(class ADBDPlayer* collector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnCollectedEvent");

	Params::FlashlightFXComponent_OnCollectedEvent Parms{};

	Parms.collector = collector;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.FlashlightFXComponent.OnCollectorLocallyObservedChangedEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isLocallyObserved                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlashlightFXComponent::OnCollectorLocallyObservedChangedEvent(bool isLocallyObserved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnCollectorLocallyObservedChangedEvent");

	Params::FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent Parms{};

	Parms.isLocallyObserved = isLocallyObserved;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.FlashlightFXComponent.OnDroppedEvent
// (Event, Protected, BlueprintEvent)

void UFlashlightFXComponent::OnDroppedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnDroppedEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.FlashlightFXComponent.OnStartEvent
// (Event, Protected, BlueprintEvent)

void UFlashlightFXComponent::OnStartEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnStartEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.FlashlightFXComponent.OnStopEvent
// (Event, Protected, BlueprintEvent)

void UFlashlightFXComponent::OnStopEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnStopEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.FlashlightFXComponent.OnTurnedOff
// (Final, Native, Private)

void UFlashlightFXComponent::OnTurnedOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnTurnedOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightFXComponent.OnTurnedOn
// (Final, Native, Private)

void UFlashlightFXComponent::OnTurnedOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "OnTurnedOn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightFXComponent.PostUpdateEvent
// (Event, Protected, BlueprintEvent)

void UFlashlightFXComponent::PostUpdateEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "PostUpdateEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DBDGameplay.FlashlightFXComponent.UpdateConeEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   halfAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlashlightFXComponent::UpdateConeEvent(float length, float halfAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "UpdateConeEvent");

	Params::FlashlightFXComponent_UpdateConeEvent Parms{};

	Parms.length = length;
	Parms.halfAngle = halfAngle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DBDGameplay.FlashlightFXComponent.UpdateFXTargets
// (Final, Native, Private)

void UFlashlightFXComponent::UpdateFXTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "UpdateFXTargets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FlashlightFXComponent.GetBlindingSuccessRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFlashlightFXComponent::GetBlindingSuccessRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashlightFXComponent", "GetBlindingSuccessRatio");

	Params::FlashlightFXComponent_GetBlindingSuccessRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.FootstepManagerComponent.OnUpdateCreatorFootsteps
// (Final, Native, Public)
// Parameters:
// class UFootstepCreatorComponent*        creator                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFootstepManagerComponent::OnUpdateCreatorFootsteps(class UFootstepCreatorComponent* creator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootstepManagerComponent", "OnUpdateCreatorFootsteps");

	Params::FootstepManagerComponent_OnUpdateCreatorFootsteps Parms{};

	Parms.creator = creator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FootstepManagerComponent.OnUpdateObserverFootsteps
// (Final, Native, Public)

void UFootstepManagerComponent::OnUpdateObserverFootsteps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootstepManagerComponent", "OnUpdateObserverFootsteps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.FootstepManagerComponent.TriggerSpawnFootstep
// (Final, Native, Public, HasDefaults)
// Parameters:
// class UFootstepCreatorComponent*        originatorComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFootstepManagerComponent::TriggerSpawnFootstep(class UFootstepCreatorComponent* originatorComponent, const struct FVector& location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootstepManagerComponent", "TriggerSpawnFootstep");

	Params::FootstepManagerComponent_TriggerSpawnFootstep Parms{};

	Parms.originatorComponent = originatorComponent;
	Parms.location = std::move(location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.InteractionStarterComponent.OnInteractionStarted
// (Final, Native, Private)

void UInteractionStarterComponent::OnInteractionStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionStarterComponent", "OnInteractionStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.InteractionStarterComponent.OnRep_ShouldStartInteraction
// (Final, Native, Private)

void UInteractionStarterComponent::OnRep_ShouldStartInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionStarterComponent", "OnRep_ShouldStartInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerInstinctComponent.GetParticleSystem
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraComponent* UKillerInstinctComponent::GetParticleSystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerInstinctComponent", "GetParticleSystem");

	Params::KillerInstinctComponent_GetParticleSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.KillerInstinctComponent.OnKillerLocallyObservedChanged
// (Final, Native, Private)
// Parameters:
// bool                                    locallyObserved                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerInstinctComponent::OnKillerLocallyObservedChanged(bool locallyObserved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerInstinctComponent", "OnKillerLocallyObservedChanged");

	Params::KillerInstinctComponent_OnKillerLocallyObservedChanged Parms{};

	Parms.locallyObserved = locallyObserved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerInstinctComponent.SetParticleSystem
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                particleSystemComponent                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerInstinctComponent::SetParticleSystem(class UNiagaraComponent* particleSystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerInstinctComponent", "SetParticleSystem");

	Params::KillerInstinctComponent_SetParticleSystem Parms{};

	Parms.particleSystemComponent = particleSystemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.KillerInstinctComponent.IsOwnerInKillerInstinctRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKillerInstinctComponent::IsOwnerInKillerInstinctRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerInstinctComponent", "IsOwnerInKillerInstinctRadius");

	Params::KillerInstinctComponent_IsOwnerInKillerInstinctRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.LullabyFeedbackComponent.OnSlasherSet
// (Final, Native, Private)
// Parameters:
// class ASlasherPlayer*                   killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULullabyFeedbackComponent::OnSlasherSet(class ASlasherPlayer* killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LullabyFeedbackComponent", "OnSlasherSet");

	Params::LullabyFeedbackComponent_OnSlasherSet Parms{};

	Parms.killer = killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.MapCollectable.GetActorKnowledgeCollection
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UActorKnowledgeCollection*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorKnowledgeCollection* AMapCollectable::GetActorKnowledgeCollection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapCollectable", "GetActorKnowledgeCollection");

	Params::MapCollectable_GetActorKnowledgeCollection Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DBDGameplay.MapCollectable.GetChargeableComponent
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UChargeableComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableComponent* AMapCollectable::GetChargeableComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapCollectable", "GetChargeableComponent");

	Params::MapCollectable_GetChargeableComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DBDGameplay.MapCollectable.GetChargerComponent
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UChargerComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargerComponent* AMapCollectable::GetChargerComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapCollectable", "GetChargerComponent");

	Params::MapCollectable_GetChargerComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DBDGameplay.Medkit.Authority_ConsumeIfNotInteracting
// (Final, Native, Protected)

void AMedkit::Authority_ConsumeIfNotInteracting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "Authority_ConsumeIfNotInteracting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Medkit.Authority_OnAnyOngoingInteractionChanged
// (Final, Native, Protected)
// Parameters:
// const bool                              isInteracting                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMedkit::Authority_OnAnyOngoingInteractionChanged(const bool isInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "Authority_OnAnyOngoingInteractionChanged");

	Params::Medkit_Authority_OnAnyOngoingInteractionChanged Parms{};

	Parms.isInteracting = isInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Medkit.Authority_OnChargeStateChange
// (Final, Native, Protected)
// Parameters:
// const bool                              empty                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMedkit::Authority_OnChargeStateChange(const bool empty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "Authority_OnChargeStateChange");

	Params::Medkit_Authority_OnChargeStateChange Parms{};

	Parms.empty = empty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Medkit.OnMedkitHealedCamper
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       healedPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMedkit::OnMedkitHealedCamper(class ADBDPlayer* healedPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "OnMedkitHealedCamper");

	Params::Medkit_OnMedkitHealedCamper Parms{};

	Parms.healedPlayer = healedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Medkit.UseCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMedkit::UseCharge(float seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "UseCharge");

	Params::Medkit_UseCharge Parms{};

	Parms.seconds = seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.Medkit.GetCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMedkit::GetCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "GetCharge");

	Params::Medkit_GetCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.Medkit.GetChargeMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMedkit::GetChargeMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "GetChargeMultiplier");

	Params::Medkit_GetChargeMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.Medkit.HasCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMedkit::HasCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Medkit", "HasCharge");

	Params::Medkit_HasCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.MoveToGroundComponent.MoveOwnerToGround
// (Final, Native, Private)

void UMoveToGroundComponent::MoveOwnerToGround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveToGroundComponent", "MoveOwnerToGround");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.NearestOutsideMapBoundsLocator.Client_InitializeAkLimitPointEvent
// (Final, Native, Private)

void UNearestOutsideMapBoundsLocator::Client_InitializeAkLimitPointEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NearestOutsideMapBoundsLocator", "Client_InitializeAkLimitPointEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.NearestOutsideMapBoundsLocator.OnGameBegin
// (Final, Native, Private)

void UNearestOutsideMapBoundsLocator::OnGameBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NearestOutsideMapBoundsLocator", "OnGameBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.NearestOutsideMapBoundsLocator.OnGameEnd
// (Final, Native, Private)
// Parameters:
// EEndGameReason                          endGameReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNearestOutsideMapBoundsLocator::OnGameEnd(EEndGameReason endGameReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NearestOutsideMapBoundsLocator", "OnGameEnd");

	Params::NearestOutsideMapBoundsLocator_OnGameEnd Parms{};

	Parms.endGameReason = endGameReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerInteractionListenerComponent.ListenToInteractionEnd
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              interactionSemantic                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)>&interactionDelegate                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::ListenToInteractionEnd(class ADBDPlayer* player, const struct FGameplayTag& interactionSemantic, const TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)>& interactionDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "ListenToInteractionEnd");

	Params::PlayerInteractionListenerComponent_ListenToInteractionEnd Parms{};

	Parms.player = player;
	Parms.interactionSemantic = std::move(interactionSemantic);
	Parms.interactionDelegate = interactionDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerInteractionListenerComponent.ListenToInteractionStart
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              interactionSemantic                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)>&interactionDelegate                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::ListenToInteractionStart(class ADBDPlayer* player, const struct FGameplayTag& interactionSemantic, const TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)>& interactionDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "ListenToInteractionStart");

	Params::PlayerInteractionListenerComponent_ListenToInteractionStart Parms{};

	Parms.player = player;
	Parms.interactionSemantic = std::move(interactionSemantic);
	Parms.interactionDelegate = interactionDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerInteractionListenerComponent.OnActorDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           destroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::OnActorDestroyed(class AActor* destroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "OnActorDestroyed");

	Params::PlayerInteractionListenerComponent_OnActorDestroyed Parms{};

	Parms.destroyedActor = destroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerInteractionListenerComponent.UnlistenToInteractionEnd
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              interactionSemantic                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::UnlistenToInteractionEnd(class ADBDPlayer* player, const struct FGameplayTag& interactionSemantic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "UnlistenToInteractionEnd");

	Params::PlayerInteractionListenerComponent_UnlistenToInteractionEnd Parms{};

	Parms.player = player;
	Parms.interactionSemantic = std::move(interactionSemantic);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerInteractionListenerComponent.UnlistenToInteractionStart
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              interactionSemantic                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionListenerComponent::UnlistenToInteractionStart(class ADBDPlayer* player, const struct FGameplayTag& interactionSemantic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionListenerComponent", "UnlistenToInteractionStart");

	Params::PlayerInteractionListenerComponent_UnlistenToInteractionStart Parms{};

	Parms.player = player;
	Parms.interactionSemantic = std::move(interactionSemantic);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyGamepadPitchScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             adjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyGamepadPitchScaleMultiplier(class ADBDPlayer* player, const float multiplier, const float adjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyGamepadPitchScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier Parms{};

	Parms.player = player;
	Parms.multiplier = multiplier;
	Parms.adjustmentTime = adjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyGamepadYawScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             adjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyGamepadYawScaleMultiplier(class ADBDPlayer* player, const float multiplier, const float adjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyGamepadYawScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier Parms{};

	Parms.player = player;
	Parms.multiplier = multiplier;
	Parms.adjustmentTime = adjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyMousePitchScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             adjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyMousePitchScaleMultiplier(class ADBDPlayer* player, const float multiplier, const float adjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyMousePitchScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier Parms{};

	Parms.player = player;
	Parms.multiplier = multiplier;
	Parms.adjustmentTime = adjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyMouseYawScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             adjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyMouseYawScaleMultiplier(class ADBDPlayer* player, const float multiplier, const float adjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyMouseYawScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier Parms{};

	Parms.player = player;
	Parms.multiplier = multiplier;
	Parms.adjustmentTime = adjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyPitchScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             adjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyPitchScaleMultiplier(class ADBDPlayer* player, const float multiplier, const float adjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyPitchScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier Parms{};

	Parms.player = player;
	Parms.multiplier = multiplier;
	Parms.adjustmentTime = adjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyRotationScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             adjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyRotationScaleMultiplier(class ADBDPlayer* player, const float multiplier, const float adjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyRotationScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier Parms{};

	Parms.player = player;
	Parms.multiplier = multiplier;
	Parms.adjustmentTime = adjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyYawScaleMultiplier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             adjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ApplyYawScaleMultiplier(class ADBDPlayer* player, const float multiplier, const float adjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ApplyYawScaleMultiplier");

	Params::PlayerMovementUtilities_Local_ApplyYawScaleMultiplier Parms{};

	Parms.player = player;
	Parms.multiplier = multiplier;
	Parms.adjustmentTime = adjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ResetGamepadLookCurves
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ResetGamepadLookCurves(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ResetGamepadLookCurves");

	Params::PlayerMovementUtilities_Local_ResetGamepadLookCurves Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_ResetRotationScale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             adjustmentTime                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_ResetRotationScale(class ADBDPlayer* player, const float adjustmentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_ResetRotationScale");

	Params::PlayerMovementUtilities_Local_ResetRotationScale Parms{};

	Parms.player = player;
	Parms.adjustmentTime = adjustmentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_SetGamepadPitchCurve
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      curve                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_SetGamepadPitchCurve(class ADBDPlayer* player, class UCurveFloat* curve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_SetGamepadPitchCurve");

	Params::PlayerMovementUtilities_Local_SetGamepadPitchCurve Parms{};

	Parms.player = player;
	Parms.curve = curve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PlayerMovementUtilities.Local_SetGamepadYawCurve
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      curve                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerMovementUtilities::Local_SetGamepadYawCurve(class ADBDPlayer* player, class UCurveFloat* curve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerMovementUtilities", "Local_SetGamepadYawCurve");

	Params::PlayerMovementUtilities_Local_SetGamepadYawCurve Parms{};

	Parms.player = player;
	Parms.curve = curve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.PowerToggleComponent.OnRep_IsInPower
// (Final, Native, Private, Const)

void UPowerToggleComponent::OnRep_IsInPower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerToggleComponent", "OnRep_IsInPower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.RemoveEmitterFromList
// (Final, Native, Public, BlueprintCallable)

void UTerrorRadiusEmitterComponent::RemoveEmitterFromList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "RemoveEmitterFromList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.SetEmitterActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusEmitterComponent::SetEmitterActive(bool active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "SetEmitterActive");

	Params::TerrorRadiusEmitterComponent_SetEmitterActive Parms{};

	Parms.active = active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.SetImitatesAudioOnly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    imitatesAudioOnly                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusEmitterComponent::SetImitatesAudioOnly(bool imitatesAudioOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "SetImitatesAudioOnly");

	Params::TerrorRadiusEmitterComponent_SetImitatesAudioOnly Parms{};

	Parms.imitatesAudioOnly = imitatesAudioOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.SetIsFakeTerrorRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusEmitterComponent::SetIsFakeTerrorRadius(bool value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "SetIsFakeTerrorRadius");

	Params::TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.SetSimulatedFixedDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusEmitterComponent::SetSimulatedFixedDistance(float distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "SetSimulatedFixedDistance");

	Params::TerrorRadiusEmitterComponent_SetSimulatedFixedDistance Parms{};

	Parms.distance = distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.SetTerrorRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusEmitterComponent::SetTerrorRadius(float radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "SetTerrorRadius");

	Params::TerrorRadiusEmitterComponent_SetTerrorRadius Parms{};

	Parms.radius = radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.GetImitatesAudioOnly
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTerrorRadiusEmitterComponent::GetImitatesAudioOnly() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "GetImitatesAudioOnly");

	Params::TerrorRadiusEmitterComponent_GetImitatesAudioOnly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.GetIsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTerrorRadiusEmitterComponent::GetIsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "GetIsActive");

	Params::TerrorRadiusEmitterComponent_GetIsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.GetRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTerrorRadiusEmitterComponent::GetRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "GetRadius");

	Params::TerrorRadiusEmitterComponent_GetRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.GetSimulatedFixedDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTerrorRadiusEmitterComponent::GetSimulatedFixedDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "GetSimulatedFixedDistance");

	Params::TerrorRadiusEmitterComponent_GetSimulatedFixedDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusEmitterComponent.IsInTerrorRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTerrorRadiusReceiverComponent*   receiver                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTerrorRadiusEmitterComponent::IsInTerrorRadius(class UTerrorRadiusReceiverComponent* receiver) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusEmitterComponent", "IsInTerrorRadius");

	Params::TerrorRadiusEmitterComponent_IsInTerrorRadius Parms{};

	Parms.receiver = receiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.SlasherTerrorRadiusEmitterComponent.SetBaseTerrorRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   baseTerrorRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              progressive                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlasherTerrorRadiusEmitterComponent::SetBaseTerrorRadius(float baseTerrorRadius, const bool progressive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherTerrorRadiusEmitterComponent", "SetBaseTerrorRadius");

	Params::SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius Parms{};

	Parms.baseTerrorRadius = baseTerrorRadius;
	Parms.progressive = progressive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.StruggleComponent.Authority_TryActivateSkillCheck
// (Final, Native, Private)

void UStruggleComponent::Authority_TryActivateSkillCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StruggleComponent", "Authority_TryActivateSkillCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.StruggleComponent.OnSkillCheckEnd
// (Final, Native, Private)
// Parameters:
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStruggleComponent::OnSkillCheckEnd(bool hadInput, bool success, bool bonus, ESkillCheckCustomType type, class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StruggleComponent", "OnSkillCheckEnd");

	Params::StruggleComponent_OnSkillCheckEnd Parms{};

	Parms.hadInput = hadInput;
	Parms.success = success;
	Parms.bonus = bonus;
	Parms.type = type;
	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.TerrorRadiusEmitterFunctionLibrary.GetActiveFakeTerrorRadiusEmittersCount
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTerrorRadiusEmitterFunctionLibrary::GetActiveFakeTerrorRadiusEmittersCount(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TerrorRadiusEmitterFunctionLibrary", "GetActiveFakeTerrorRadiusEmittersCount");

	Params::TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusReceiverComponent.IsInTerrorRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTerrorRadiusReceiverComponent::IsInTerrorRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusReceiverComponent", "IsInTerrorRadius");

	Params::TerrorRadiusReceiverComponent_IsInTerrorRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusReceiverComponent.IsInTerrorRadiusRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTerrorRadiusReceiverComponent::IsInTerrorRadiusRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusReceiverComponent", "IsInTerrorRadiusRange");

	Params::TerrorRadiusReceiverComponent_IsInTerrorRadiusRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.TerrorRadiusScreenIndicatorComponent.OnHeartStateChanged
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              heartState                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusScreenIndicatorComponent::OnHeartStateChanged(const struct FGameplayTag& heartState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusScreenIndicatorComponent", "OnHeartStateChanged");

	Params::TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged Parms{};

	Parms.heartState = std::move(heartState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.Authority_AddWiggleCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   chargeAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::Authority_AddWiggleCharge(float chargeAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "Authority_AddWiggleCharge");

	Params::WiggleComponent_Authority_AddWiggleCharge Parms{};

	Parms.chargeAmount = chargeAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.Authority_TutorialEndWiggle
// (Final, Native, Public, BlueprintCallable)

void UWiggleComponent::Authority_TutorialEndWiggle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "Authority_TutorialEndWiggle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnHideWiggleSkillCheck
// (Final, Native, Private)
// Parameters:
// ESkillCheckCustomType                   type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::OnHideWiggleSkillCheck(ESkillCheckCustomType type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnHideWiggleSkillCheck");

	Params::WiggleComponent_OnHideWiggleSkillCheck Parms{};

	Parms.type = type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnKeyBindingsChanged
// (Final, Native, Private)

void UWiggleComponent::OnKeyBindingsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnKeyBindingsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UWiggleComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnPickedUpSkillCheckEnd
// (Final, Native, Private)
// Parameters:
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::OnPickedUpSkillCheckEnd(bool hadInput, bool success, bool bonus, ESkillCheckCustomType type, class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnPickedUpSkillCheckEnd");

	Params::WiggleComponent_OnPickedUpSkillCheckEnd Parms{};

	Parms.hadInput = hadInput;
	Parms.success = success;
	Parms.bonus = bonus;
	Parms.type = type;
	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnPlayerPickedUpEnd
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       picker                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::OnPlayerPickedUpEnd(class ADBDPlayer* picker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnPlayerPickedUpEnd");

	Params::WiggleComponent_OnPlayerPickedUpEnd Parms{};

	Parms.picker = picker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnPlayerPickedUpStart
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       picker                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::OnPlayerPickedUpStart(class ADBDPlayer* picker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnPlayerPickedUpStart");

	Params::WiggleComponent_OnPlayerPickedUpStart Parms{};

	Parms.picker = picker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnWiggleEnd
// (Final, Native, Private)

void UWiggleComponent::OnWiggleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnWiggleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnWiggleInput
// (Final, Native, Private)

void UWiggleComponent::OnWiggleInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnWiggleInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.OnWiggleSkillCheckEnd
// (Final, Native, Private)
// Parameters:
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::OnWiggleSkillCheckEnd(bool hadInput, bool success, bool bonus, ESkillCheckCustomType type, class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "OnWiggleSkillCheckEnd");

	Params::WiggleComponent_OnWiggleSkillCheckEnd Parms{};

	Parms.hadInput = hadInput;
	Parms.success = success;
	Parms.bonus = bonus;
	Parms.type = type;
	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.Server_OnWiggleEnd
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UWiggleComponent::Server_OnWiggleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "Server_OnWiggleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.DBD_SetWiggleProgress
// (Final, Exec, Native, Public, Const)
// Parameters:
// const float                             progressPercent                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleComponent::DBD_SetWiggleProgress(const float progressPercent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "DBD_SetWiggleProgress");

	Params::WiggleComponent_DBD_SetWiggleProgress Parms{};

	Parms.progressPercent = progressPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleComponent.GetWiggleChargeable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UChargeableComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableComponent* UWiggleComponent::GetWiggleChargeable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleComponent", "GetWiggleChargeable");

	Params::WiggleComponent_GetWiggleChargeable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DBDGameplay.WiggleFreeComponent.Authority_OnChargeableCompleteEvent
// (Final, Native, Private, HasOutParams)
// Parameters:
// bool                                    completed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            instigatorsForCompletion                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UWiggleFreeComponent::Authority_OnChargeableCompleteEvent(bool completed, const TArray<class AActor*>& instigatorsForCompletion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleFreeComponent", "Authority_OnChargeableCompleteEvent");

	Params::WiggleFreeComponent_Authority_OnChargeableCompleteEvent Parms{};

	Parms.completed = completed;
	Parms.instigatorsForCompletion = std::move(instigatorsForCompletion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleFreeComponent.Authority_OnLevelReadyToPlay
// (Final, Native, Private)

void UWiggleFreeComponent::Authority_OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleFreeComponent", "Authority_OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleFreeComponent.Authority_OnPlayerPickedUpEnd
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       picker                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleFreeComponent::Authority_OnPlayerPickedUpEnd(class ADBDPlayer* picker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleFreeComponent", "Authority_OnPlayerPickedUpEnd");

	Params::WiggleFreeComponent_Authority_OnPlayerPickedUpEnd Parms{};

	Parms.picker = picker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleFreeComponent.Authority_OnWiggleEnd
// (Final, Native, Private)

void UWiggleFreeComponent::Authority_OnWiggleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleFreeComponent", "Authority_OnWiggleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.OnHideWiggleSkillCheck
// (Final, Native, Private)
// Parameters:
// ESkillCheckCustomType                   type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::OnHideWiggleSkillCheck(ESkillCheckCustomType type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "OnHideWiggleSkillCheck");

	Params::WiggleMotionComponent_OnHideWiggleSkillCheck Parms{};

	Parms.type = type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.OnSurvivorPickedUp
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::OnSurvivorPickedUp(class ADBDPlayer* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "OnSurvivorPickedUp");

	Params::WiggleMotionComponent_OnSurvivorPickedUp Parms{};

	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.OnSurvivorRemoved
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::OnSurvivorRemoved(class ADBDPlayer* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "OnSurvivorRemoved");

	Params::WiggleMotionComponent_OnSurvivorRemoved Parms{};

	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.OnWiggleSkillCheckEnd
// (Final, Native, Private)
// Parameters:
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::OnWiggleSkillCheckEnd(bool hadInput, bool success, bool bonus, ESkillCheckCustomType type, class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "OnWiggleSkillCheckEnd");

	Params::WiggleMotionComponent_OnWiggleSkillCheckEnd Parms{};

	Parms.hadInput = hadInput;
	Parms.success = success;
	Parms.bonus = bonus;
	Parms.type = type;
	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.Server_SetIsBeingWiggled
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const bool                              isBeingWiggled                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::Server_SetIsBeingWiggled(const bool isBeingWiggled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "Server_SetIsBeingWiggled");

	Params::WiggleMotionComponent_Server_SetIsBeingWiggled Parms{};

	Parms.isBeingWiggled = isBeingWiggled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DBDGameplay.WiggleMotionComponent.SetIsBeingWiggled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              isBeingWiggled                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWiggleMotionComponent::SetIsBeingWiggled(const bool isBeingWiggled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleMotionComponent", "SetIsBeingWiggled");

	Params::WiggleMotionComponent_SetIsBeingWiggled Parms{};

	Parms.isBeingWiggled = isBeingWiggled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

