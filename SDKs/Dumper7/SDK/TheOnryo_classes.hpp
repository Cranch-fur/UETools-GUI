#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheOnryo

#include "Basic.hpp"

#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDCompetence_structs.hpp"
#include "DBDCompetence_classes.hpp"
#include "Engine_classes.hpp"
#include "DBDInteraction_classes.hpp"
#include "StatSystem_structs.hpp"
#include "DataTableUtilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "SystemUtilities_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "QueryService_structs.hpp"
#include "Competence_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "DBDCosmetic_classes.hpp"
#include "TheOnryo_structs.hpp"


namespace SDK
{

// Class TheOnryo.Addon_K27Power_12
// 0x0008 (0x02C0 - 0x02B8)
class UAddon_K27Power_12 final : public UItemAddon
{
public:
	float                                         _condemnStackNumber;                               // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _onlyGiveStackForHealingFromInjuredToHealthy;      // 0x02BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2BD[0x3];                                      // 0x02BD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K27Power_12">();
	}
	static class UAddon_K27Power_12* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K27Power_12>();
	}
};
static_assert(alignof(UAddon_K27Power_12) == 0x000008, "Wrong alignment on UAddon_K27Power_12");
static_assert(sizeof(UAddon_K27Power_12) == 0x0002C0, "Wrong size on UAddon_K27Power_12");
static_assert(offsetof(UAddon_K27Power_12, _condemnStackNumber) == 0x0002B8, "Member 'UAddon_K27Power_12::_condemnStackNumber' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_12, _onlyGiveStackForHealingFromInjuredToHealthy) == 0x0002BC, "Member 'UAddon_K27Power_12::_onlyGiveStackForHealingFromInjuredToHealthy' has a wrong offset!");

// Class TheOnryo.Addon_K27Power_16
// 0x0038 (0x0300 - 0x02C8)
class UAddon_K27Power_16 final : public UOnEventBaseAddon
{
public:
	float                                         _distanceOfSightFromSurvivorToKiller;              // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _survivorScreamRevealDuration;                     // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _revealAuraToKillerEffectClass;                    // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK27Addon_16_ScreamRevealComponent> _screamRevealComponentClass;               // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UK27Addon_16_ScreamRevealComponent>> _cachedScreamRevealComponents;  // 0x02E0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K27Power_16">();
	}
	static class UAddon_K27Power_16* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K27Power_16>();
	}
};
static_assert(alignof(UAddon_K27Power_16) == 0x000008, "Wrong alignment on UAddon_K27Power_16");
static_assert(sizeof(UAddon_K27Power_16) == 0x000300, "Wrong size on UAddon_K27Power_16");
static_assert(offsetof(UAddon_K27Power_16, _distanceOfSightFromSurvivorToKiller) == 0x0002C8, "Member 'UAddon_K27Power_16::_distanceOfSightFromSurvivorToKiller' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_16, _survivorScreamRevealDuration) == 0x0002CC, "Member 'UAddon_K27Power_16::_survivorScreamRevealDuration' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_16, _revealAuraToKillerEffectClass) == 0x0002D0, "Member 'UAddon_K27Power_16::_revealAuraToKillerEffectClass' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_16, _screamRevealComponentClass) == 0x0002D8, "Member 'UAddon_K27Power_16::_screamRevealComponentClass' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_16, _cachedScreamRevealComponents) == 0x0002E0, "Member 'UAddon_K27Power_16::_cachedScreamRevealComponents' has a wrong offset!");

// Class TheOnryo.Addon_K27Power_17
// 0x0010 (0x02D8 - 0x02C8)
class UAddon_K27Power_17 final : public UOnEventBaseAddon
{
public:
	TSubclassOf<class UStatusEffect>              _survivorImposedEffectClass;                       // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorInRangeDistance;                          // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hinderedSeconds;                                  // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K27Power_17">();
	}
	static class UAddon_K27Power_17* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K27Power_17>();
	}
};
static_assert(alignof(UAddon_K27Power_17) == 0x000008, "Wrong alignment on UAddon_K27Power_17");
static_assert(sizeof(UAddon_K27Power_17) == 0x0002D8, "Wrong size on UAddon_K27Power_17");
static_assert(offsetof(UAddon_K27Power_17, _survivorImposedEffectClass) == 0x0002C8, "Member 'UAddon_K27Power_17::_survivorImposedEffectClass' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_17, _survivorInRangeDistance) == 0x0002D0, "Member 'UAddon_K27Power_17::_survivorInRangeDistance' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_17, _hinderedSeconds) == 0x0002D4, "Member 'UAddon_K27Power_17::_hinderedSeconds' has a wrong offset!");

// Class TheOnryo.Addon_K27Power_18
// 0x0000 (0x02B8 - 0x02B8)
class UAddon_K27Power_18 final : public UItemAddon
{
public:
	void Authority_OnIntroCompleted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K27Power_18">();
	}
	static class UAddon_K27Power_18* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K27Power_18>();
	}
};
static_assert(alignof(UAddon_K27Power_18) == 0x000008, "Wrong alignment on UAddon_K27Power_18");
static_assert(sizeof(UAddon_K27Power_18) == 0x0002B8, "Wrong size on UAddon_K27Power_18");

// Class TheOnryo.Addon_K27Power_19
// 0x0020 (0x02E8 - 0x02C8)
class UAddon_K27Power_19 final : public UOnEventBaseAddon
{
public:
	float                                         _distanceFromSurvivorToTVToRevealAura;             // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _heightOffsetLowerBoundToRevealAura;               // 0x02CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _heightOffsetUpperBoundToRevealAura;               // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorAuraRevealDuration;                       // 0x02D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _revealSurvivorsAroundPoweredTVs;                  // 0x02D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _revealSurvivorsAroundTurnedOffTVs;                // 0x02D9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DA[0x6];                                      // 0x02DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _timedRevealToKillerEffect;                        // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K27Power_19">();
	}
	static class UAddon_K27Power_19* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K27Power_19>();
	}
};
static_assert(alignof(UAddon_K27Power_19) == 0x000008, "Wrong alignment on UAddon_K27Power_19");
static_assert(sizeof(UAddon_K27Power_19) == 0x0002E8, "Wrong size on UAddon_K27Power_19");
static_assert(offsetof(UAddon_K27Power_19, _distanceFromSurvivorToTVToRevealAura) == 0x0002C8, "Member 'UAddon_K27Power_19::_distanceFromSurvivorToTVToRevealAura' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_19, _heightOffsetLowerBoundToRevealAura) == 0x0002CC, "Member 'UAddon_K27Power_19::_heightOffsetLowerBoundToRevealAura' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_19, _heightOffsetUpperBoundToRevealAura) == 0x0002D0, "Member 'UAddon_K27Power_19::_heightOffsetUpperBoundToRevealAura' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_19, _survivorAuraRevealDuration) == 0x0002D4, "Member 'UAddon_K27Power_19::_survivorAuraRevealDuration' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_19, _revealSurvivorsAroundPoweredTVs) == 0x0002D8, "Member 'UAddon_K27Power_19::_revealSurvivorsAroundPoweredTVs' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_19, _revealSurvivorsAroundTurnedOffTVs) == 0x0002D9, "Member 'UAddon_K27Power_19::_revealSurvivorsAroundTurnedOffTVs' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_19, _timedRevealToKillerEffect) == 0x0002E0, "Member 'UAddon_K27Power_19::_timedRevealToKillerEffect' has a wrong offset!");

// Class TheOnryo.Addon_K27Power_20
// 0x0018 (0x02D0 - 0x02B8)
class UAddon_K27Power_20 final : public UItemAddon
{
public:
	TArray<class AOnryoTelevision*>               _lastTurnedOffTelevisionsByOnryo;                  // 0x02B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         _numberOfTVsToTurnOn;                              // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_OnAddonTriggered(const bool televisionsWerePowered);
	void Cosmetic_OnAddonTriggered(const bool televisionsWerePowered, const class ASlasherPlayer* killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K27Power_20">();
	}
	static class UAddon_K27Power_20* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K27Power_20>();
	}
};
static_assert(alignof(UAddon_K27Power_20) == 0x000008, "Wrong alignment on UAddon_K27Power_20");
static_assert(sizeof(UAddon_K27Power_20) == 0x0002D0, "Wrong size on UAddon_K27Power_20");
static_assert(offsetof(UAddon_K27Power_20, _lastTurnedOffTelevisionsByOnryo) == 0x0002B8, "Member 'UAddon_K27Power_20::_lastTurnedOffTelevisionsByOnryo' has a wrong offset!");
static_assert(offsetof(UAddon_K27Power_20, _numberOfTVsToTurnOn) == 0x0002C8, "Member 'UAddon_K27Power_20::_numberOfTVsToTurnOn' has a wrong offset!");

// Class TheOnryo.BaseManifestInteraction
// 0x0000 (0x0780 - 0x0780)
class UBaseManifestInteraction : public UBasicChargeableInteraction
{
public:
	class UManifestationComponent*                _manifestationComponent;                           // 0x0778(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_OnInteractionCancelled(class ADBDPlayer* onryo);
	void Cosmetic_OnInteractionStarted(class ADBDPlayer* onryo);
	void Cosmetic_OnInteractionSucceeded(class ADBDPlayer* onryo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseManifestInteraction">();
	}
	static class UBaseManifestInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseManifestInteraction>();
	}
};
static_assert(alignof(UBaseManifestInteraction) == 0x000010, "Wrong alignment on UBaseManifestInteraction");
static_assert(sizeof(UBaseManifestInteraction) == 0x000780, "Wrong size on UBaseManifestInteraction");
static_assert(offsetof(UBaseManifestInteraction, _manifestationComponent) == 0x000778, "Member 'UBaseManifestInteraction::_manifestationComponent' has a wrong offset!");

// Class TheOnryo.CondemnedComponent
// 0x0330 (0x03E8 - 0x00B8)
class UCondemnedComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x68];                                      // 0x00B8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxCondemnedLevel;                                // 0x0120(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _killerInstinctRevealDurationOnFullyCondemned;     // 0x0148(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _stacksOnTurnOffTV;                                // 0x0170(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _stacksOnRetrieveVHS;                              // 0x0198(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _stacksRemovedOnInsert;                            // 0x01C0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _minDistanceForSelectedTV;                         // 0x01E8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxDistanceForSelectedTV;                         // 0x0210(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _timePerCondemnStack;                              // 0x0238(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _analyticScoreTag;                                 // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _condemnedLevel;                                   // 0x02C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isHoldingVHS;                                     // 0x02CC(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CD[0x3B];                                     // 0x02CD(0x003B)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _condemnKillerInstinctEffect;                      // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x18];                                     // 0x0310(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _reactivateCondemnProgressEvents;                  // 0x0328(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	class FName                                   _tapeItemId;                                       // 0x0338(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_344[0x34];                                     // 0x0344(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _rangeToStopCondemnProgressAfterChase;             // 0x0378(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _timeAwayFromKillerToResumeCondemn;                // 0x03A0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x20];                                     // 0x03C8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_SetCondemnedLevel(const float level);
	void DBD_SetCondemnMoriableAndDownAllSurvivors();
	void OnKillerSet(class ASlasherPlayer* killer);
	void OnRep_CondemnedLevel(const float previousValue);
	void OnRep_HoldingVHS();

	float GetCondemnedLevel() const;
	float GetCondemnedPercent() const;
	bool IsCondemned() const;
	bool IsFullyCondemned() const;
	bool IsHoldingVHS() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CondemnedComponent">();
	}
	static class UCondemnedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCondemnedComponent>();
	}
};
static_assert(alignof(UCondemnedComponent) == 0x000008, "Wrong alignment on UCondemnedComponent");
static_assert(sizeof(UCondemnedComponent) == 0x0003E8, "Wrong size on UCondemnedComponent");
static_assert(offsetof(UCondemnedComponent, _maxCondemnedLevel) == 0x000120, "Member 'UCondemnedComponent::_maxCondemnedLevel' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _killerInstinctRevealDurationOnFullyCondemned) == 0x000148, "Member 'UCondemnedComponent::_killerInstinctRevealDurationOnFullyCondemned' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _stacksOnTurnOffTV) == 0x000170, "Member 'UCondemnedComponent::_stacksOnTurnOffTV' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _stacksOnRetrieveVHS) == 0x000198, "Member 'UCondemnedComponent::_stacksOnRetrieveVHS' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _stacksRemovedOnInsert) == 0x0001C0, "Member 'UCondemnedComponent::_stacksRemovedOnInsert' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _minDistanceForSelectedTV) == 0x0001E8, "Member 'UCondemnedComponent::_minDistanceForSelectedTV' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _maxDistanceForSelectedTV) == 0x000210, "Member 'UCondemnedComponent::_maxDistanceForSelectedTV' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _timePerCondemnStack) == 0x000238, "Member 'UCondemnedComponent::_timePerCondemnStack' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _analyticScoreTag) == 0x0002B8, "Member 'UCondemnedComponent::_analyticScoreTag' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _condemnedLevel) == 0x0002C8, "Member 'UCondemnedComponent::_condemnedLevel' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _isHoldingVHS) == 0x0002CC, "Member 'UCondemnedComponent::_isHoldingVHS' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _condemnKillerInstinctEffect) == 0x000308, "Member 'UCondemnedComponent::_condemnKillerInstinctEffect' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _reactivateCondemnProgressEvents) == 0x000328, "Member 'UCondemnedComponent::_reactivateCondemnProgressEvents' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _tapeItemId) == 0x000338, "Member 'UCondemnedComponent::_tapeItemId' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _rangeToStopCondemnProgressAfterChase) == 0x000378, "Member 'UCondemnedComponent::_rangeToStopCondemnProgressAfterChase' has a wrong offset!");
static_assert(offsetof(UCondemnedComponent, _timeAwayFromKillerToResumeCondemn) == 0x0003A0, "Member 'UCondemnedComponent::_timeAwayFromKillerToResumeCondemn' has a wrong offset!");

// Class TheOnryo.CondemnMoriInteraction
// 0x0000 (0x07D0 - 0x07D0)
class UCondemnMoriInteraction final : public UKillInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CondemnMoriInteraction">();
	}
	static class UCondemnMoriInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCondemnMoriInteraction>();
	}
};
static_assert(alignof(UCondemnMoriInteraction) == 0x000010, "Wrong alignment on UCondemnMoriInteraction");
static_assert(sizeof(UCondemnMoriInteraction) == 0x0007D0, "Wrong size on UCondemnMoriInteraction");

// Class TheOnryo.SurvivorTelevisionInteraction
// 0x0000 (0x0780 - 0x0780)
class USurvivorTelevisionInteraction : public UBasicChargeableInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorTelevisionInteraction">();
	}
	static class USurvivorTelevisionInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorTelevisionInteraction>();
	}
};
static_assert(alignof(USurvivorTelevisionInteraction) == 0x000010, "Wrong alignment on USurvivorTelevisionInteraction");
static_assert(sizeof(USurvivorTelevisionInteraction) == 0x000780, "Wrong size on USurvivorTelevisionInteraction");

// Class TheOnryo.InsertVHS
// 0x0000 (0x0780 - 0x0780)
class UInsertVHS final : public USurvivorTelevisionInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InsertVHS">();
	}
	static class UInsertVHS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInsertVHS>();
	}
};
static_assert(alignof(UInsertVHS) == 0x000010, "Wrong alignment on UInsertVHS");
static_assert(sizeof(UInsertVHS) == 0x000780, "Wrong size on UInsertVHS");

// Class TheOnryo.K27Addon_16_ScreamRevealComponent
// 0x0008 (0x00C0 - 0x00B8)
class UK27Addon_16_ScreamRevealComponent final : public UActorComponent
{
public:
	bool                                          _authorityHasRequestedSurvivorScreamConfirmation;  // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _screamDuration;                                   // 0x00BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BP_RevealAndMakeSurvivorScream(class ADBDPlayer* survivorPlayer, const float screamRevealDuration);
	void Client_QueryIsKillerInSurvivorView();
	void Multicast_RevealAndMakeSurvivorScream(const float screamRevealDuration);
	void Server_ConfirmKillerIsInViewValidation(bool isKillerInView);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K27Addon_16_ScreamRevealComponent">();
	}
	static class UK27Addon_16_ScreamRevealComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK27Addon_16_ScreamRevealComponent>();
	}
};
static_assert(alignof(UK27Addon_16_ScreamRevealComponent) == 0x000008, "Wrong alignment on UK27Addon_16_ScreamRevealComponent");
static_assert(sizeof(UK27Addon_16_ScreamRevealComponent) == 0x0000C0, "Wrong size on UK27Addon_16_ScreamRevealComponent");
static_assert(offsetof(UK27Addon_16_ScreamRevealComponent, _authorityHasRequestedSurvivorScreamConfirmation) == 0x0000B8, "Member 'UK27Addon_16_ScreamRevealComponent::_authorityHasRequestedSurvivorScreamConfirmation' has a wrong offset!");
static_assert(offsetof(UK27Addon_16_ScreamRevealComponent, _screamDuration) == 0x0000BC, "Member 'UK27Addon_16_ScreamRevealComponent::_screamDuration' has a wrong offset!");

// Class TheOnryo.K27P01
// 0x0018 (0x03E0 - 0x03C8)
class UK27P01 final : public UPerk
{
public:
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _survivorAuraRevealDuration[0x3];                  // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorUnhookedOffScourgeHook(const struct FGameEventData& gameEventData);

	const float GetAuraRevealDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K27P01">();
	}
	static class UK27P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK27P01>();
	}
};
static_assert(alignof(UK27P01) == 0x000008, "Wrong alignment on UK27P01");
static_assert(sizeof(UK27P01) == 0x0003E0, "Wrong size on UK27P01");
static_assert(offsetof(UK27P01, _survivorAuraRevealDuration) == 0x0003D0, "Member 'UK27P01::_survivorAuraRevealDuration' has a wrong offset!");

// Class TheOnryo.K27P02
// 0x00B8 (0x0480 - 0x03C8)
class UK27P02 final : public UPerk
{
public:
	float                                         _activePerkDuration[0x3];                          // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _regressionModifier[0x3];                          // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AGenerator*, struct FFastTimer>    _authority_affectedGeneratorsAndActiveTimers;      // 0x03E0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class AGenerator*, uint64>               _gameplayModifierHandles;                          // 0x0430(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void Cosmetic_ShowBubbleNotification(const class AGenerator* triggeringGenerator);
	void Multicast_AddGeneratorAura(class AGenerator* generator);
	void Multicast_ShowBubbleNotification(class AGenerator* triggeringGenerator);

	float GetActivationTimeAtLevel() const;
	float GetRegressionModifierAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K27P02">();
	}
	static class UK27P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK27P02>();
	}
};
static_assert(alignof(UK27P02) == 0x000008, "Wrong alignment on UK27P02");
static_assert(sizeof(UK27P02) == 0x000480, "Wrong size on UK27P02");
static_assert(offsetof(UK27P02, _activePerkDuration) == 0x0003C8, "Member 'UK27P02::_activePerkDuration' has a wrong offset!");
static_assert(offsetof(UK27P02, _regressionModifier) == 0x0003D4, "Member 'UK27P02::_regressionModifier' has a wrong offset!");
static_assert(offsetof(UK27P02, _authority_affectedGeneratorsAndActiveTimers) == 0x0003E0, "Member 'UK27P02::_authority_affectedGeneratorsAndActiveTimers' has a wrong offset!");
static_assert(offsetof(UK27P02, _gameplayModifierHandles) == 0x000430, "Member 'UK27P02::_gameplayModifierHandles' has a wrong offset!");

// Class TheOnryo.K27P03
// 0x00C8 (0x0490 - 0x03C8)
class UK27P03 final : public UPerk
{
public:
	struct FLinearColor                           _generatorBlockedAuraColorForKiller;               // 0x03C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _generatorProgressionActivation[0x3];              // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _generatorBlockedDuration[0x3];                    // 0x03E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class AGenerator>, struct FFastTimer> _authority_blockedGeneratorsAndTimeToUnblock; // 0x03F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class ACamperPlayer>, TWeakObjectPtr<class AGenerator>> _authority_affectedRepairersAndTheirGenerators; // 0x0440(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void Multicast_HighlightBlockedGeneratorForKiller(class AGenerator* generator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K27P03">();
	}
	static class UK27P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK27P03>();
	}
};
static_assert(alignof(UK27P03) == 0x000008, "Wrong alignment on UK27P03");
static_assert(sizeof(UK27P03) == 0x000490, "Wrong size on UK27P03");
static_assert(offsetof(UK27P03, _generatorBlockedAuraColorForKiller) == 0x0003C8, "Member 'UK27P03::_generatorBlockedAuraColorForKiller' has a wrong offset!");
static_assert(offsetof(UK27P03, _generatorProgressionActivation) == 0x0003D8, "Member 'UK27P03::_generatorProgressionActivation' has a wrong offset!");
static_assert(offsetof(UK27P03, _generatorBlockedDuration) == 0x0003E4, "Member 'UK27P03::_generatorBlockedDuration' has a wrong offset!");
static_assert(offsetof(UK27P03, _authority_blockedGeneratorsAndTimeToUnblock) == 0x0003F0, "Member 'UK27P03::_authority_blockedGeneratorsAndTimeToUnblock' has a wrong offset!");
static_assert(offsetof(UK27P03, _authority_affectedRepairersAndTheirGenerators) == 0x000440, "Member 'UK27P03::_authority_affectedRepairersAndTheirGenerators' has a wrong offset!");

// Class TheOnryo.ManifestationComponent
// 0x03E0 (0x0498 - 0x00B8)
class UManifestationComponent final : public UActorComponent
{
public:
	struct FTunableStat                           _lingeringFlickerDuration;                         // 0x00B8(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxTrackedTimeSinceManifest;                      // 0x0138(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _manifestInteractionUndetectableLingerTime;        // 0x0160(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _teleportManifestUndetectableLingeringDuration;    // 0x01E0(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _lingeringUndetectableDurationFromOtherSources;    // 0x0260(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _scorePercent;                                     // 0x02E0(0x0088)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x28];                                     // 0x0368(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UOnryoVisibilityComponent*              _onryoVisibilityComponent;                         // 0x0390(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UOnryoVisibilityComponent>  _onryoVisibilityComponentClass;                    // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isManifested;                                     // 0x03A0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A1[0x3];                                      // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _lingeringUndetectableEndTimeStamp;                // 0x03A4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0xF0];                                     // 0x03A8(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnMoriStarted();
	void Multicast_OnManifestationChanged(const bool isManifested, const bool isImmediateManifest);
	void Multicast_OnManifestationTransitionComplete();
	void OnLingeringUndetectableTimerCompleted();
	void OnRep_IsManifested();
	void OnRep_LingeringUndetectableEndTimeStamp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManifestationComponent">();
	}
	static class UManifestationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UManifestationComponent>();
	}
};
static_assert(alignof(UManifestationComponent) == 0x000008, "Wrong alignment on UManifestationComponent");
static_assert(sizeof(UManifestationComponent) == 0x000498, "Wrong size on UManifestationComponent");
static_assert(offsetof(UManifestationComponent, _lingeringFlickerDuration) == 0x0000B8, "Member 'UManifestationComponent::_lingeringFlickerDuration' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _maxTrackedTimeSinceManifest) == 0x000138, "Member 'UManifestationComponent::_maxTrackedTimeSinceManifest' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _manifestInteractionUndetectableLingerTime) == 0x000160, "Member 'UManifestationComponent::_manifestInteractionUndetectableLingerTime' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _teleportManifestUndetectableLingeringDuration) == 0x0001E0, "Member 'UManifestationComponent::_teleportManifestUndetectableLingeringDuration' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _lingeringUndetectableDurationFromOtherSources) == 0x000260, "Member 'UManifestationComponent::_lingeringUndetectableDurationFromOtherSources' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _scorePercent) == 0x0002E0, "Member 'UManifestationComponent::_scorePercent' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _onryoVisibilityComponent) == 0x000390, "Member 'UManifestationComponent::_onryoVisibilityComponent' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _onryoVisibilityComponentClass) == 0x000398, "Member 'UManifestationComponent::_onryoVisibilityComponentClass' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _isManifested) == 0x0003A0, "Member 'UManifestationComponent::_isManifested' has a wrong offset!");
static_assert(offsetof(UManifestationComponent, _lingeringUndetectableEndTimeStamp) == 0x0003A4, "Member 'UManifestationComponent::_lingeringUndetectableEndTimeStamp' has a wrong offset!");

// Class TheOnryo.ManifestInteraction
// 0x0010 (0x0790 - 0x0780)
class UManifestInteraction final : public UBaseManifestInteraction
{
public:
	class UCurveFloat*                            _postManifestSpeedCurve;                           // 0x0780(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _postManifestSpeedCurveDuration;                   // 0x0788(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78C[0x4];                                      // 0x078C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManifestInteraction">();
	}
	static class UManifestInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UManifestInteraction>();
	}
};
static_assert(alignof(UManifestInteraction) == 0x000010, "Wrong alignment on UManifestInteraction");
static_assert(sizeof(UManifestInteraction) == 0x000790, "Wrong size on UManifestInteraction");
static_assert(offsetof(UManifestInteraction, _postManifestSpeedCurve) == 0x000780, "Member 'UManifestInteraction::_postManifestSpeedCurve' has a wrong offset!");
static_assert(offsetof(UManifestInteraction, _postManifestSpeedCurveDuration) == 0x000788, "Member 'UManifestInteraction::_postManifestSpeedCurveDuration' has a wrong offset!");

// Class TheOnryo.NearPoweredTelevisionWithLingerTime
// 0x0098 (0x0180 - 0x00E8)
class UNearPoweredTelevisionWithLingerTime final : public UEventDrivenModifierCondition
{
public:
	float                                         _distanceFromTelevision;                           // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lingerDuration;                                   // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FActorPairQueryHeightRange             _heightRange;                                      // 0x00F0(0x0008)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x88];                                      // 0x00F8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

	float GetPercentRemainingDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NearPoweredTelevisionWithLingerTime">();
	}
	static class UNearPoweredTelevisionWithLingerTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNearPoweredTelevisionWithLingerTime>();
	}
};
static_assert(alignof(UNearPoweredTelevisionWithLingerTime) == 0x000008, "Wrong alignment on UNearPoweredTelevisionWithLingerTime");
static_assert(sizeof(UNearPoweredTelevisionWithLingerTime) == 0x000180, "Wrong size on UNearPoweredTelevisionWithLingerTime");
static_assert(offsetof(UNearPoweredTelevisionWithLingerTime, _distanceFromTelevision) == 0x0000E8, "Member 'UNearPoweredTelevisionWithLingerTime::_distanceFromTelevision' has a wrong offset!");
static_assert(offsetof(UNearPoweredTelevisionWithLingerTime, _lingerDuration) == 0x0000EC, "Member 'UNearPoweredTelevisionWithLingerTime::_lingerDuration' has a wrong offset!");
static_assert(offsetof(UNearPoweredTelevisionWithLingerTime, _heightRange) == 0x0000F0, "Member 'UNearPoweredTelevisionWithLingerTime::_heightRange' has a wrong offset!");

// Class TheOnryo.OnryoAfterImageComponent
// 0x00C8 (0x0180 - 0x00B8)
class UOnryoAfterImageComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xC1];                                      // 0x00B8(0x00C1)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hideAfterImageDuringInteractions;                 // 0x0179(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17A[0x6];                                      // 0x017A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShouldShowAfterImageChanged(bool shouldBeVisible);

	class ASlasherPlayer* GetKiller() const;
	bool IsAttacking() const;
	bool IsInteracting() const;
	bool IsOnryoInvisible() const;
	bool ShouldShowAfterImage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoAfterImageComponent">();
	}
	static class UOnryoAfterImageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoAfterImageComponent>();
	}
};
static_assert(alignof(UOnryoAfterImageComponent) == 0x000008, "Wrong alignment on UOnryoAfterImageComponent");
static_assert(sizeof(UOnryoAfterImageComponent) == 0x000180, "Wrong size on UOnryoAfterImageComponent");
static_assert(offsetof(UOnryoAfterImageComponent, _hideAfterImageDuringInteractions) == 0x000179, "Member 'UOnryoAfterImageComponent::_hideAfterImageDuringInteractions' has a wrong offset!");

// Class TheOnryo.OnryoAnimInstance
// 0x0030 (0x0630 - 0x0600)
class UOnryoAnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isTeleporting;                                    // 0x0600(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isStartingUpTeleport;                             // 0x0601(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_602[0x2];                                      // 0x0602(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _teleportStartUpDuration;                          // 0x0604(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawlingOutOfTV;                                // 0x0608(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_609[0x3];                                      // 0x0609(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _crawlingOutDuration;                              // 0x060C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isTeleportCancelled;                              // 0x0610(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_611[0x3];                                      // 0x0611(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _teleportCancelledDuration;                        // 0x0614(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isEnteringManifest;                               // 0x0618(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isExitingManifest;                                // 0x0619(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInOtherWorld;                                   // 0x061A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61B[0x15];                                     // 0x061B(0x0015)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoAnimInstance">();
	}
	static class UOnryoAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoAnimInstance>();
	}
};
static_assert(alignof(UOnryoAnimInstance) == 0x000010, "Wrong alignment on UOnryoAnimInstance");
static_assert(sizeof(UOnryoAnimInstance) == 0x000630, "Wrong size on UOnryoAnimInstance");
static_assert(offsetof(UOnryoAnimInstance, _isTeleporting) == 0x000600, "Member 'UOnryoAnimInstance::_isTeleporting' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _isStartingUpTeleport) == 0x000601, "Member 'UOnryoAnimInstance::_isStartingUpTeleport' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _teleportStartUpDuration) == 0x000604, "Member 'UOnryoAnimInstance::_teleportStartUpDuration' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _isCrawlingOutOfTV) == 0x000608, "Member 'UOnryoAnimInstance::_isCrawlingOutOfTV' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _crawlingOutDuration) == 0x00060C, "Member 'UOnryoAnimInstance::_crawlingOutDuration' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _isTeleportCancelled) == 0x000610, "Member 'UOnryoAnimInstance::_isTeleportCancelled' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _teleportCancelledDuration) == 0x000614, "Member 'UOnryoAnimInstance::_teleportCancelledDuration' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _isEnteringManifest) == 0x000618, "Member 'UOnryoAnimInstance::_isEnteringManifest' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _isExitingManifest) == 0x000619, "Member 'UOnryoAnimInstance::_isExitingManifest' has a wrong offset!");
static_assert(offsetof(UOnryoAnimInstance, _isInOtherWorld) == 0x00061A, "Member 'UOnryoAnimInstance::_isInOtherWorld' has a wrong offset!");

// Class TheOnryo.OnryoFXInterface
// 0x0000 (0x0000 - 0x0000)
class IOnryoFXInterface final
{
public:
	void Cosmetic_OnChargeManifestCancelled();
	void Cosmetic_OnChargeManifestStart();
	void Cosmetic_OnChargeManifestSuccess();
	void Cosmetic_OnChargeUnmanifestCancelled();
	void Cosmetic_OnChargeUnmanifestStart();
	void Cosmetic_OnChargeUnmanifestSuccess();
	void Cosmetic_OnKillerVisibilityChanged(bool isVisible, bool isFlickering, bool isManifested, bool isInvisibleDueToOutOfVisibiltyRange, bool force);
	void Cosmetic_OnManifestStateChanged(bool isManifested, const bool isImmediateManifest);
	void Cosmetic_OnTeleportCancelled();
	void Cosmetic_OnTeleportFinished();
	void Cosmetic_OnTeleportStart();
	void Cosmetic_OnTeleportSuccess();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoFXInterface">();
	}
	static class IOnryoFXInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOnryoFXInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOnryoFXInterface) == 0x000001, "Wrong alignment on IOnryoFXInterface");
static_assert(sizeof(IOnryoFXInterface) == 0x000001, "Wrong size on IOnryoFXInterface");

// Class TheOnryo.OnryoPower
// 0x00E0 (0x0590 - 0x04B0)
class AOnryoPower final : public ACollectable
{
public:
	TSubclassOf<class UCondemnedComponent>        _condemnedComponentClass;                          // 0x04B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UManifestationComponent>    _manifestationComponentClass;                      // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FStatusEffectSpawnData>         _effects;                                          // 0x04C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FPlayerStatusEffectSpawnerHelper       _effectSpawner;                                    // 0x04D0(0x0088)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOnryoTeleportTargeterComponent*        _televisionTargeter;                               // 0x0560(0x0008)(Edit, ExportObject, Net, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UManifestationComponent*                _manifestationComponent;                           // 0x0568(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AOnryoTelevision*>               _televisions;                                      // 0x0570(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TSubclassOf<class AOnryoTelevision>           _televisionClass;                                  // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDefinition*                 _onryoPowerCooldownInteraction;                    // 0x0588(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PowerCooldownEnd_Cosmetic();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoPower">();
	}
	static class AOnryoPower* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOnryoPower>();
	}
};
static_assert(alignof(AOnryoPower) == 0x000008, "Wrong alignment on AOnryoPower");
static_assert(sizeof(AOnryoPower) == 0x000590, "Wrong size on AOnryoPower");
static_assert(offsetof(AOnryoPower, _condemnedComponentClass) == 0x0004B0, "Member 'AOnryoPower::_condemnedComponentClass' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _manifestationComponentClass) == 0x0004B8, "Member 'AOnryoPower::_manifestationComponentClass' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _effects) == 0x0004C0, "Member 'AOnryoPower::_effects' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _effectSpawner) == 0x0004D0, "Member 'AOnryoPower::_effectSpawner' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _televisionTargeter) == 0x000560, "Member 'AOnryoPower::_televisionTargeter' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _manifestationComponent) == 0x000568, "Member 'AOnryoPower::_manifestationComponent' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _televisions) == 0x000570, "Member 'AOnryoPower::_televisions' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _televisionClass) == 0x000580, "Member 'AOnryoPower::_televisionClass' has a wrong offset!");
static_assert(offsetof(AOnryoPower, _onryoPowerCooldownInteraction) == 0x000588, "Member 'AOnryoPower::_onryoPowerCooldownInteraction' has a wrong offset!");

// Class TheOnryo.OnryoPowerPresentationComponent
// 0x0020 (0x00D8 - 0x00B8)
class UOnryoPowerPresentationComponent final : public UPresentationItemProgressComponent
{
public:
	class UOnryoTVInitialCooldownStateComponent*  _cooldownState;                                    // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoPowerPresentationComponent">();
	}
	static class UOnryoPowerPresentationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoPowerPresentationComponent>();
	}
};
static_assert(alignof(UOnryoPowerPresentationComponent) == 0x000008, "Wrong alignment on UOnryoPowerPresentationComponent");
static_assert(sizeof(UOnryoPowerPresentationComponent) == 0x0000D8, "Wrong size on UOnryoPowerPresentationComponent");
static_assert(offsetof(UOnryoPowerPresentationComponent, _cooldownState) == 0x0000B8, "Member 'UOnryoPowerPresentationComponent::_cooldownState' has a wrong offset!");

// Class TheOnryo.OnryoSurvivorCosmeticHelperActor
// 0x0070 (0x02D8 - 0x0268)
class AOnryoSurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	class UCondemnedComponent*                    _condemnedComponent;                               // 0x0268(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x68];                                     // 0x0270(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnCarryEnd(class ACamperPlayer* camper);
	void Cosmetic_OnCarryStart(class ACamperPlayer* camper);
	void Cosmetic_OnDamageStateChanged(ECamperDamageState oldDamageState, ECamperDamageState newDamageState);
	void Cosmetic_OnGainCondemnStack(class ACamperPlayer* camper, float currentStacks);
	void Cosmetic_OnHookedChanged();
	void Cosmetic_OnLightingSet(class ABaseSky* lighting);
	void Cosmetic_OnLoseCondemnStack(class ACamperPlayer* camper, float currentStacks);
	void Cosmetic_OnLoseTape(class ACamperPlayer* camper);
	void Cosmetic_OnReceiveTape(class ACamperPlayer* camper);

	class UCondemnedComponent* GetCondemnedComponent() const;
	class UGameplayTagContainerComponent* GetObjectState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoSurvivorCosmeticHelperActor">();
	}
	static class AOnryoSurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOnryoSurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AOnryoSurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AOnryoSurvivorCosmeticHelperActor");
static_assert(sizeof(AOnryoSurvivorCosmeticHelperActor) == 0x0002D8, "Wrong size on AOnryoSurvivorCosmeticHelperActor");
static_assert(offsetof(AOnryoSurvivorCosmeticHelperActor, _condemnedComponent) == 0x000268, "Member 'AOnryoSurvivorCosmeticHelperActor::_condemnedComponent' has a wrong offset!");

// Class TheOnryo.OnryoTeleportInteraction
// 0x0180 (0x0900 - 0x0780)
class UOnryoTeleportInteraction final : public UBasicChargeableInteraction
{
public:
	class ASlasherPlayer*                         _cachedOwningKiller;                               // 0x0778(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOnryoTelevision*                       _currentTargetTelevision;                          // 0x0780(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_788[0x8];                                      // 0x0788(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _teleportExitAnimDuration;                         // 0x0790(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _teleportCancelledAnimDuration;                    // 0x07B8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _rangeToApplyCondemn;                              // 0x07E0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _postTeleportSpeedDuration;                        // 0x0808(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _postTeleportSpeedCurve;                           // 0x0830(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FStatProperty                          _scorePercent;                                     // 0x0838(0x0088)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _postTeleportAlternateSpeedCurve;                  // 0x08C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _offsetHeight;                                     // 0x08C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _raycastLength;                                    // 0x08CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UConeAroundDirectionCameraStrategy> _cameraStrategyClass;                      // 0x08D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _cameraMaximumAngleFactorCurve;                    // 0x08D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8E0[0x10];                                     // 0x08E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UConeAroundDirectionCameraStrategy*     _cameraStrategy;                                   // 0x08F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8F8[0x8];                                      // 0x08F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoTeleportInteraction">();
	}
	static class UOnryoTeleportInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoTeleportInteraction>();
	}
};
static_assert(alignof(UOnryoTeleportInteraction) == 0x000010, "Wrong alignment on UOnryoTeleportInteraction");
static_assert(sizeof(UOnryoTeleportInteraction) == 0x000900, "Wrong size on UOnryoTeleportInteraction");
static_assert(offsetof(UOnryoTeleportInteraction, _cachedOwningKiller) == 0x000778, "Member 'UOnryoTeleportInteraction::_cachedOwningKiller' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _currentTargetTelevision) == 0x000780, "Member 'UOnryoTeleportInteraction::_currentTargetTelevision' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _teleportExitAnimDuration) == 0x000790, "Member 'UOnryoTeleportInteraction::_teleportExitAnimDuration' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _teleportCancelledAnimDuration) == 0x0007B8, "Member 'UOnryoTeleportInteraction::_teleportCancelledAnimDuration' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _rangeToApplyCondemn) == 0x0007E0, "Member 'UOnryoTeleportInteraction::_rangeToApplyCondemn' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _postTeleportSpeedDuration) == 0x000808, "Member 'UOnryoTeleportInteraction::_postTeleportSpeedDuration' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _postTeleportSpeedCurve) == 0x000830, "Member 'UOnryoTeleportInteraction::_postTeleportSpeedCurve' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _scorePercent) == 0x000838, "Member 'UOnryoTeleportInteraction::_scorePercent' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _postTeleportAlternateSpeedCurve) == 0x0008C0, "Member 'UOnryoTeleportInteraction::_postTeleportAlternateSpeedCurve' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _offsetHeight) == 0x0008C8, "Member 'UOnryoTeleportInteraction::_offsetHeight' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _raycastLength) == 0x0008CC, "Member 'UOnryoTeleportInteraction::_raycastLength' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _cameraStrategyClass) == 0x0008D0, "Member 'UOnryoTeleportInteraction::_cameraStrategyClass' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _cameraMaximumAngleFactorCurve) == 0x0008D8, "Member 'UOnryoTeleportInteraction::_cameraMaximumAngleFactorCurve' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportInteraction, _cameraStrategy) == 0x0008F0, "Member 'UOnryoTeleportInteraction::_cameraStrategy' has a wrong offset!");

// Class TheOnryo.OnryoTelevision
// 0x0318 (0x0640 - 0x0328)
class AOnryoTelevision final : public AInteractable
{
public:
	uint8                                         Pad_328[0x18];                                     // 0x0328(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _teleportPosition;                                 // 0x0340(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isKillerInOtherWorld;                             // 0x0348(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTelevisionOutlineUpdateStrategy*       _televisionOutlineUpdateStrategy;                  // 0x0350(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalPlayerTrackerComponent*           _localPlayerTracker;                               // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapActorComponent*                     _mapActorComponent;                                // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOnryoTVAutoPowerComponent*             _autoPowerComponent;                               // 0x0368(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ADBDPlayer*>                     _survivorsThatCanInsertTape;                       // 0x0370(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x38];                                     // 0x0380(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isPowered;                                        // 0x03B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B9[0x17];                                     // 0x03B9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ADBDPlayer*>                       _nearbySurvivorsWithoutTape;                       // 0x03D0(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x50];                                     // 0x0420(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _distanceNearTVWithoutTape;                        // 0x0470(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _survivorTurnOffTVDuration;                        // 0x0498(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _teleportTurnOffDuration;                          // 0x0518(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _survivorInsertTapeTurnOffDuration;                // 0x0598(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _shouldRepowerOtherTelevisionsWhenAllTurnedOff;    // 0x0618(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnRepowerTimerDone();
	void Cosmetic_OnCamperCanInsertTapeChanged(const bool canInsertTape);
	void Cosmetic_OnStatusEffectZoneVFXActiveChanged(bool active);
	void Cosmetic_OnTeleportCancelled();
	void Cosmetic_OnTeleportCompleted();
	void Cosmetic_OnTeleportStarted();
	void Cosmetic_OnTelevisionCosmeticStateChanged(ETelevisionCosmeticState nextState, ETelevisionCosmeticState previousState);
	void Cosmetic_OnTVSelectedByLocalSurvivor(class ADBDPlayer* survivor);
	void Cosmetic_SetIsTeleportTarget(bool target);
	void OnCosmeticTransitionStateFinished();
	void OnKillerSet(class ASlasherPlayer* killer);
	void OnLocallyObservedChanged();
	void OnRep_IsPowered(bool previousIsPowered);
	void OnRep_SurvivorsThatCanInsertTape();

	ETelevisionCosmeticState GetTelevisionCosmeticState() const;
	bool IsAnySurvivorWithoutTapeNearby() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoTelevision">();
	}
	static class AOnryoTelevision* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOnryoTelevision>();
	}
};
static_assert(alignof(AOnryoTelevision) == 0x000008, "Wrong alignment on AOnryoTelevision");
static_assert(sizeof(AOnryoTelevision) == 0x000640, "Wrong size on AOnryoTelevision");
static_assert(offsetof(AOnryoTelevision, _teleportPosition) == 0x000340, "Member 'AOnryoTelevision::_teleportPosition' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _isKillerInOtherWorld) == 0x000348, "Member 'AOnryoTelevision::_isKillerInOtherWorld' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _televisionOutlineUpdateStrategy) == 0x000350, "Member 'AOnryoTelevision::_televisionOutlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _localPlayerTracker) == 0x000358, "Member 'AOnryoTelevision::_localPlayerTracker' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _mapActorComponent) == 0x000360, "Member 'AOnryoTelevision::_mapActorComponent' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _autoPowerComponent) == 0x000368, "Member 'AOnryoTelevision::_autoPowerComponent' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _survivorsThatCanInsertTape) == 0x000370, "Member 'AOnryoTelevision::_survivorsThatCanInsertTape' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _isPowered) == 0x0003B8, "Member 'AOnryoTelevision::_isPowered' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _nearbySurvivorsWithoutTape) == 0x0003D0, "Member 'AOnryoTelevision::_nearbySurvivorsWithoutTape' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _distanceNearTVWithoutTape) == 0x000470, "Member 'AOnryoTelevision::_distanceNearTVWithoutTape' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _survivorTurnOffTVDuration) == 0x000498, "Member 'AOnryoTelevision::_survivorTurnOffTVDuration' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _teleportTurnOffDuration) == 0x000518, "Member 'AOnryoTelevision::_teleportTurnOffDuration' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _survivorInsertTapeTurnOffDuration) == 0x000598, "Member 'AOnryoTelevision::_survivorInsertTapeTurnOffDuration' has a wrong offset!");
static_assert(offsetof(AOnryoTelevision, _shouldRepowerOtherTelevisionsWhenAllTurnedOff) == 0x000618, "Member 'AOnryoTelevision::_shouldRepowerOtherTelevisionsWhenAllTurnedOff' has a wrong offset!");

// Class TheOnryo.OnryoTVAutoPowerComponent
// 0x0018 (0x00D0 - 0x00B8)
class UOnryoTVAutoPowerComponent final : public UActorComponent
{
public:
	TSubclassOf<class UOnryoTVInitialCooldownStateComponent> _cooldownStateClass;                    // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _powerTVOnBeginPlay;                               // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0xF];                                       // 0x00C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoTVAutoPowerComponent">();
	}
	static class UOnryoTVAutoPowerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoTVAutoPowerComponent>();
	}
};
static_assert(alignof(UOnryoTVAutoPowerComponent) == 0x000008, "Wrong alignment on UOnryoTVAutoPowerComponent");
static_assert(sizeof(UOnryoTVAutoPowerComponent) == 0x0000D0, "Wrong size on UOnryoTVAutoPowerComponent");
static_assert(offsetof(UOnryoTVAutoPowerComponent, _cooldownStateClass) == 0x0000B8, "Member 'UOnryoTVAutoPowerComponent::_cooldownStateClass' has a wrong offset!");
static_assert(offsetof(UOnryoTVAutoPowerComponent, _powerTVOnBeginPlay) == 0x0000C0, "Member 'UOnryoTVAutoPowerComponent::_powerTVOnBeginPlay' has a wrong offset!");

// Class TheOnryo.OnryoTVInitialCooldownStateComponent
// 0x0050 (0x0108 - 0x00B8)
class UOnryoTVInitialCooldownStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _initialTVCooldown;                                // 0x00D0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTimerObject*                           _cooldownTimer;                                    // 0x00F8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isDone;                                           // 0x0100(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_TryStartCooldown();
	void OnCooldownDone();
	void OnRep_IsDone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoTVInitialCooldownStateComponent">();
	}
	static class UOnryoTVInitialCooldownStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoTVInitialCooldownStateComponent>();
	}
};
static_assert(alignof(UOnryoTVInitialCooldownStateComponent) == 0x000008, "Wrong alignment on UOnryoTVInitialCooldownStateComponent");
static_assert(sizeof(UOnryoTVInitialCooldownStateComponent) == 0x000108, "Wrong size on UOnryoTVInitialCooldownStateComponent");
static_assert(offsetof(UOnryoTVInitialCooldownStateComponent, _initialTVCooldown) == 0x0000D0, "Member 'UOnryoTVInitialCooldownStateComponent::_initialTVCooldown' has a wrong offset!");
static_assert(offsetof(UOnryoTVInitialCooldownStateComponent, _cooldownTimer) == 0x0000F8, "Member 'UOnryoTVInitialCooldownStateComponent::_cooldownTimer' has a wrong offset!");
static_assert(offsetof(UOnryoTVInitialCooldownStateComponent, _isDone) == 0x000100, "Member 'UOnryoTVInitialCooldownStateComponent::_isDone' has a wrong offset!");

// Class TheOnryo.OnryoUnmanifestCooldownInteraction
// 0x0030 (0x0650 - 0x0620)
class UOnryoUnmanifestCooldownInteraction final : public UInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _onryoPowerCooldownTime;                           // 0x0618(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _playedCooldownSpeedCurve;                         // 0x0640(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOnryoPower(class AOnryoPower* onryoPower);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoUnmanifestCooldownInteraction">();
	}
	static class UOnryoUnmanifestCooldownInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoUnmanifestCooldownInteraction>();
	}
};
static_assert(alignof(UOnryoUnmanifestCooldownInteraction) == 0x000010, "Wrong alignment on UOnryoUnmanifestCooldownInteraction");
static_assert(sizeof(UOnryoUnmanifestCooldownInteraction) == 0x000650, "Wrong size on UOnryoUnmanifestCooldownInteraction");
static_assert(offsetof(UOnryoUnmanifestCooldownInteraction, _onryoPowerCooldownTime) == 0x000618, "Member 'UOnryoUnmanifestCooldownInteraction::_onryoPowerCooldownTime' has a wrong offset!");
static_assert(offsetof(UOnryoUnmanifestCooldownInteraction, _playedCooldownSpeedCurve) == 0x000640, "Member 'UOnryoUnmanifestCooldownInteraction::_playedCooldownSpeedCurve' has a wrong offset!");

// Class TheOnryo.OnryoVisibilityComponent
// 0x0158 (0x0210 - 0x00B8)
class UOnryoVisibilityComponent final : public UActorComponent
{
public:
	bool                                          _isKillerVisible;                                  // 0x00B8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInKillerSightRange;                             // 0x00B9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _killerRevealingStateTags;                         // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _killerVisibleMaxDistance;                         // 0x00D0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EFlickerType, struct FFlickerSettings>   _flickerSettings;                                  // 0x00F8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x1];                                      // 0x0148(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isInIntroPhase;                                   // 0x0149(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isManifested;                                     // 0x014A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInManifestingTransition;                        // 0x014B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14C[0xC4];                                     // 0x014C(0x00C4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_OnManifestationStateChanged(const bool isManifested, const bool isImmediateManifest);
	void OnIntroCompleted();
	void OnKillerInSurvivorSightRangeChanged(const bool inRange);
	void OnLocallyObservedChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoVisibilityComponent">();
	}
	static class UOnryoVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoVisibilityComponent>();
	}
};
static_assert(alignof(UOnryoVisibilityComponent) == 0x000008, "Wrong alignment on UOnryoVisibilityComponent");
static_assert(sizeof(UOnryoVisibilityComponent) == 0x000210, "Wrong size on UOnryoVisibilityComponent");
static_assert(offsetof(UOnryoVisibilityComponent, _isKillerVisible) == 0x0000B8, "Member 'UOnryoVisibilityComponent::_isKillerVisible' has a wrong offset!");
static_assert(offsetof(UOnryoVisibilityComponent, _isInKillerSightRange) == 0x0000B9, "Member 'UOnryoVisibilityComponent::_isInKillerSightRange' has a wrong offset!");
static_assert(offsetof(UOnryoVisibilityComponent, _killerRevealingStateTags) == 0x0000C0, "Member 'UOnryoVisibilityComponent::_killerRevealingStateTags' has a wrong offset!");
static_assert(offsetof(UOnryoVisibilityComponent, _killerVisibleMaxDistance) == 0x0000D0, "Member 'UOnryoVisibilityComponent::_killerVisibleMaxDistance' has a wrong offset!");
static_assert(offsetof(UOnryoVisibilityComponent, _flickerSettings) == 0x0000F8, "Member 'UOnryoVisibilityComponent::_flickerSettings' has a wrong offset!");
static_assert(offsetof(UOnryoVisibilityComponent, _isInIntroPhase) == 0x000149, "Member 'UOnryoVisibilityComponent::_isInIntroPhase' has a wrong offset!");
static_assert(offsetof(UOnryoVisibilityComponent, _isManifested) == 0x00014A, "Member 'UOnryoVisibilityComponent::_isManifested' has a wrong offset!");
static_assert(offsetof(UOnryoVisibilityComponent, _isInManifestingTransition) == 0x00014B, "Member 'UOnryoVisibilityComponent::_isInManifestingTransition' has a wrong offset!");

// Class TheOnryo.RetrieveVHS
// 0x0000 (0x0780 - 0x0780)
class URetrieveVHS final : public USurvivorTelevisionInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RetrieveVHS">();
	}
	static class URetrieveVHS* GetDefaultObj()
	{
		return GetDefaultObjImpl<URetrieveVHS>();
	}
};
static_assert(alignof(URetrieveVHS) == 0x000010, "Wrong alignment on URetrieveVHS");
static_assert(sizeof(URetrieveVHS) == 0x000780, "Wrong size on URetrieveVHS");

// Class TheOnryo.S30P01
// 0x0010 (0x03D8 - 0x03C8)
class US30P01 final : public UPerk
{
public:
	float                                         _perkEffectActiveDuration[0x3];                    // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S30P01">();
	}
	static class US30P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<US30P01>();
	}
};
static_assert(alignof(US30P01) == 0x000008, "Wrong alignment on US30P01");
static_assert(sizeof(US30P01) == 0x0003D8, "Wrong size on US30P01");
static_assert(offsetof(US30P01, _perkEffectActiveDuration) == 0x0003C8, "Member 'US30P01::_perkEffectActiveDuration' has a wrong offset!");

// Class TheOnryo.S30P02
// 0x0048 (0x0410 - 0x03C8)
class US30P02 final : public UPerk
{
public:
	float                                         _auraReadingDistance[0x3];                         // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _healingOthersBonus[0x3];                          // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x10];                                     // 0x03E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _revealAuraStatusEffectToImpose;                   // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _showHUDIconStatusEffectToImpose;                  // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  _imposedShowHUDIconStatusEffects;                  // 0x0400(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	const float GetHealingOthersBonus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S30P02">();
	}
	static class US30P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<US30P02>();
	}
};
static_assert(alignof(US30P02) == 0x000008, "Wrong alignment on US30P02");
static_assert(sizeof(US30P02) == 0x000410, "Wrong size on US30P02");
static_assert(offsetof(US30P02, _auraReadingDistance) == 0x0003C8, "Member 'US30P02::_auraReadingDistance' has a wrong offset!");
static_assert(offsetof(US30P02, _healingOthersBonus) == 0x0003D4, "Member 'US30P02::_healingOthersBonus' has a wrong offset!");
static_assert(offsetof(US30P02, _revealAuraStatusEffectToImpose) == 0x0003F0, "Member 'US30P02::_revealAuraStatusEffectToImpose' has a wrong offset!");
static_assert(offsetof(US30P02, _showHUDIconStatusEffectToImpose) == 0x0003F8, "Member 'US30P02::_showHUDIconStatusEffectToImpose' has a wrong offset!");
static_assert(offsetof(US30P02, _imposedShowHUDIconStatusEffects) == 0x000400, "Member 'US30P02::_imposedShowHUDIconStatusEffects' has a wrong offset!");

// Class TheOnryo.S30P03
// 0x0010 (0x0490 - 0x0480)
class US30P03 final : public UBoonPerk
{
public:
	float                                         _hasteLingerDuration[0x3];                         // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S30P03">();
	}
	static class US30P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<US30P03>();
	}
};
static_assert(alignof(US30P03) == 0x000008, "Wrong alignment on US30P03");
static_assert(sizeof(US30P03) == 0x000490, "Wrong size on US30P03");
static_assert(offsetof(US30P03, _hasteLingerDuration) == 0x000480, "Member 'US30P03::_hasteLingerDuration' has a wrong offset!");

// Class TheOnryo.TelevisionIterativeWeightAdjustmentStrategy
// 0x0060 (0x0090 - 0x0030)
class UTelevisionIterativeWeightAdjustmentStrategy final : public UIterativeWeightAdjustmentStrategy
{
public:
	TArray<class USceneComponent*>                _unmatchedGenerators;                              // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UActorSpawner*>                  _selectedSpawners;                                 // 0x0040(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _penaltyFromDistanceToClosestTelevision;           // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _penaltyFromDistanceToClosestTelevisionWhenGeneratorHasOtherTelevisionNearby; // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _scoreFromDistanceFromClosestGenerator;            // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _generatorCloseToTelevisionDistanceThreshold;      // 0x0068(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TelevisionIterativeWeightAdjustmentStrategy">();
	}
	static class UTelevisionIterativeWeightAdjustmentStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTelevisionIterativeWeightAdjustmentStrategy>();
	}
};
static_assert(alignof(UTelevisionIterativeWeightAdjustmentStrategy) == 0x000008, "Wrong alignment on UTelevisionIterativeWeightAdjustmentStrategy");
static_assert(sizeof(UTelevisionIterativeWeightAdjustmentStrategy) == 0x000090, "Wrong size on UTelevisionIterativeWeightAdjustmentStrategy");
static_assert(offsetof(UTelevisionIterativeWeightAdjustmentStrategy, _unmatchedGenerators) == 0x000030, "Member 'UTelevisionIterativeWeightAdjustmentStrategy::_unmatchedGenerators' has a wrong offset!");
static_assert(offsetof(UTelevisionIterativeWeightAdjustmentStrategy, _selectedSpawners) == 0x000040, "Member 'UTelevisionIterativeWeightAdjustmentStrategy::_selectedSpawners' has a wrong offset!");
static_assert(offsetof(UTelevisionIterativeWeightAdjustmentStrategy, _penaltyFromDistanceToClosestTelevision) == 0x000050, "Member 'UTelevisionIterativeWeightAdjustmentStrategy::_penaltyFromDistanceToClosestTelevision' has a wrong offset!");
static_assert(offsetof(UTelevisionIterativeWeightAdjustmentStrategy, _penaltyFromDistanceToClosestTelevisionWhenGeneratorHasOtherTelevisionNearby) == 0x000058, "Member 'UTelevisionIterativeWeightAdjustmentStrategy::_penaltyFromDistanceToClosestTelevisionWhenGeneratorHasOtherTelevisionNearby' has a wrong offset!");
static_assert(offsetof(UTelevisionIterativeWeightAdjustmentStrategy, _scoreFromDistanceFromClosestGenerator) == 0x000060, "Member 'UTelevisionIterativeWeightAdjustmentStrategy::_scoreFromDistanceFromClosestGenerator' has a wrong offset!");
static_assert(offsetof(UTelevisionIterativeWeightAdjustmentStrategy, _generatorCloseToTelevisionDistanceThreshold) == 0x000068, "Member 'UTelevisionIterativeWeightAdjustmentStrategy::_generatorCloseToTelevisionDistanceThreshold' has a wrong offset!");

// Class TheOnryo.TelevisionOutlineUpdateStrategy
// 0x0070 (0x0130 - 0x00C0)
class UTelevisionOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _survivorAuraColor;                                // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _slasherPoweredColor;                              // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _revealedByMapColor;                               // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _slasherUnpoweredDefaultColor;                     // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _slasherUnpoweredVisibleColor;                     // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _slasherTeleportTargetColor;                       // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TelevisionOutlineUpdateStrategy">();
	}
	static class UTelevisionOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTelevisionOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UTelevisionOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UTelevisionOutlineUpdateStrategy");
static_assert(sizeof(UTelevisionOutlineUpdateStrategy) == 0x000130, "Wrong size on UTelevisionOutlineUpdateStrategy");
static_assert(offsetof(UTelevisionOutlineUpdateStrategy, _survivorAuraColor) == 0x0000C0, "Member 'UTelevisionOutlineUpdateStrategy::_survivorAuraColor' has a wrong offset!");
static_assert(offsetof(UTelevisionOutlineUpdateStrategy, _slasherPoweredColor) == 0x0000D0, "Member 'UTelevisionOutlineUpdateStrategy::_slasherPoweredColor' has a wrong offset!");
static_assert(offsetof(UTelevisionOutlineUpdateStrategy, _revealedByMapColor) == 0x0000E0, "Member 'UTelevisionOutlineUpdateStrategy::_revealedByMapColor' has a wrong offset!");
static_assert(offsetof(UTelevisionOutlineUpdateStrategy, _slasherUnpoweredDefaultColor) == 0x0000F0, "Member 'UTelevisionOutlineUpdateStrategy::_slasherUnpoweredDefaultColor' has a wrong offset!");
static_assert(offsetof(UTelevisionOutlineUpdateStrategy, _slasherUnpoweredVisibleColor) == 0x000100, "Member 'UTelevisionOutlineUpdateStrategy::_slasherUnpoweredVisibleColor' has a wrong offset!");
static_assert(offsetof(UTelevisionOutlineUpdateStrategy, _slasherTeleportTargetColor) == 0x000110, "Member 'UTelevisionOutlineUpdateStrategy::_slasherTeleportTargetColor' has a wrong offset!");

// Class TheOnryo.OnryoTeleportTargeterComponent
// 0x0078 (0x0130 - 0x00B8)
class UOnryoTeleportTargeterComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _maximumTeleportAngle;                             // 0x00B8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOnryoTelevision*                       _replicatedTargetTelevision;                       // 0x00E0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOnryoTelevision*                       _localTargetTelevision;                            // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOnryoTelevision*                       _previousTarget;                                   // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _targetUpdateInterval;                             // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC[0x34];                                      // 0x00FC(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TargetTelevision();
	void Server_SetTeleportTarget(class AOnryoTelevision* tv);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnryoTeleportTargeterComponent">();
	}
	static class UOnryoTeleportTargeterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnryoTeleportTargeterComponent>();
	}
};
static_assert(alignof(UOnryoTeleportTargeterComponent) == 0x000008, "Wrong alignment on UOnryoTeleportTargeterComponent");
static_assert(sizeof(UOnryoTeleportTargeterComponent) == 0x000130, "Wrong size on UOnryoTeleportTargeterComponent");
static_assert(offsetof(UOnryoTeleportTargeterComponent, _maximumTeleportAngle) == 0x0000B8, "Member 'UOnryoTeleportTargeterComponent::_maximumTeleportAngle' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportTargeterComponent, _replicatedTargetTelevision) == 0x0000E0, "Member 'UOnryoTeleportTargeterComponent::_replicatedTargetTelevision' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportTargeterComponent, _localTargetTelevision) == 0x0000E8, "Member 'UOnryoTeleportTargeterComponent::_localTargetTelevision' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportTargeterComponent, _previousTarget) == 0x0000F0, "Member 'UOnryoTeleportTargeterComponent::_previousTarget' has a wrong offset!");
static_assert(offsetof(UOnryoTeleportTargeterComponent, _targetUpdateInterval) == 0x0000F8, "Member 'UOnryoTeleportTargeterComponent::_targetUpdateInterval' has a wrong offset!");

// Class TheOnryo.TurnOffTV
// 0x0000 (0x0780 - 0x0780)
class UTurnOffTV final : public USurvivorTelevisionInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TurnOffTV">();
	}
	static class UTurnOffTV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTurnOffTV>();
	}
};
static_assert(alignof(UTurnOffTV) == 0x000010, "Wrong alignment on UTurnOffTV");
static_assert(sizeof(UTurnOffTV) == 0x000780, "Wrong size on UTurnOffTV");

// Class TheOnryo.UnmanifestInteraction
// 0x0010 (0x0790 - 0x0780)
class UUnmanifestInteraction final : public UBaseManifestInteraction
{
public:
	uint8                                         Pad_780[0x10];                                     // 0x0780(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOnryoPower(class AOnryoPower* onryoPower);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnmanifestInteraction">();
	}
	static class UUnmanifestInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnmanifestInteraction>();
	}
};
static_assert(alignof(UUnmanifestInteraction) == 0x000010, "Wrong alignment on UUnmanifestInteraction");
static_assert(sizeof(UUnmanifestInteraction) == 0x000790, "Wrong size on UUnmanifestInteraction");

}

