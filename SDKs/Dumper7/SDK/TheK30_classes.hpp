#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK30

#include "Basic.hpp"

#include "DBDInteraction_classes.hpp"
#include "StatSystem_structs.hpp"
#include "DBDBots_classes.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "DBDCompetence_classes.hpp"
#include "Engine_classes.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "NetworkUtilities_structs.hpp"
#include "AnimationUtilities_structs.hpp"
#include "TheK30_structs.hpp"
#include "DBDAnimation_classes.hpp"
#include "DBDCosmetic_classes.hpp"
#include "Competence_classes.hpp"
#include "GameplayTagUtilities_structs.hpp"


namespace SDK
{

// Class TheK30.BTService_FindObject_GuardFlag
// 0x0000 (0x00C0 - 0x00C0)
class UBTService_FindObject_GuardFlag final : public UBTService_FindObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindObject_GuardFlag">();
	}
	static class UBTService_FindObject_GuardFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindObject_GuardFlag>();
	}
};
static_assert(alignof(UBTService_FindObject_GuardFlag) == 0x000008, "Wrong alignment on UBTService_FindObject_GuardFlag");
static_assert(sizeof(UBTService_FindObject_GuardFlag) == 0x0000C0, "Wrong size on UBTService_FindObject_GuardFlag");

// Class TheK30.DrawPatrolPathInteraction
// 0x01A0 (0x0920 - 0x0780)
class UDrawPatrolPathInteraction final : public UBasicChargeableInteraction
{
public:
	TMulticastInlineDelegate<void(bool isCharging, bool isChargeCompleted)> OnChargeStateChanged;    // 0x0778(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_788[0x38];                                     // 0x0788(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSecondaryInteractionProperties        _giveOrderProperties;                              // 0x07C0(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSecondaryInteractionProperties        _releaseInteractionProperties;                     // 0x07F8(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maximumInteractionDuration;                       // 0x0830(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pathLengthWarningPercent;                         // 0x0858(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pathDrawingDurationWarningPercent;                // 0x0880(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _postPowerHasteClass;                              // 0x08A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _postPowerHasteValue;                              // 0x08B0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _hasteDurationByPathLength;                        // 0x08D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8E0[0x40];                                     // 0x08E0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCancellationTimerCompleted();
	void Server_SendOrder(class AInteractable* target);
	void Server_StartPatrol();
	void SetIsCharging(bool isCharging);

	bool IsChargeCompleted() const;
	bool IsCharging() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DrawPatrolPathInteraction">();
	}
	static class UDrawPatrolPathInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDrawPatrolPathInteraction>();
	}
};
static_assert(alignof(UDrawPatrolPathInteraction) == 0x000010, "Wrong alignment on UDrawPatrolPathInteraction");
static_assert(sizeof(UDrawPatrolPathInteraction) == 0x000920, "Wrong size on UDrawPatrolPathInteraction");
static_assert(offsetof(UDrawPatrolPathInteraction, OnChargeStateChanged) == 0x000778, "Member 'UDrawPatrolPathInteraction::OnChargeStateChanged' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _giveOrderProperties) == 0x0007C0, "Member 'UDrawPatrolPathInteraction::_giveOrderProperties' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _releaseInteractionProperties) == 0x0007F8, "Member 'UDrawPatrolPathInteraction::_releaseInteractionProperties' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _maximumInteractionDuration) == 0x000830, "Member 'UDrawPatrolPathInteraction::_maximumInteractionDuration' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _pathLengthWarningPercent) == 0x000858, "Member 'UDrawPatrolPathInteraction::_pathLengthWarningPercent' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _pathDrawingDurationWarningPercent) == 0x000880, "Member 'UDrawPatrolPathInteraction::_pathDrawingDurationWarningPercent' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _postPowerHasteClass) == 0x0008A8, "Member 'UDrawPatrolPathInteraction::_postPowerHasteClass' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _postPowerHasteValue) == 0x0008B0, "Member 'UDrawPatrolPathInteraction::_postPowerHasteValue' has a wrong offset!");
static_assert(offsetof(UDrawPatrolPathInteraction, _hasteDurationByPathLength) == 0x0008D8, "Member 'UDrawPatrolPathInteraction::_hasteDurationByPathLength' has a wrong offset!");

// Class TheK30.FloatingCameraNavigationComponent
// 0x01B8 (0x0270 - 0x00B8)
class UFloatingCameraNavigationComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UObjectPlacerComponent>  _ownerObjectPlacer;                                // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _snappingDistance;                                 // 0x00D8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _previewSnappingTime;                              // 0x0100(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _drawPathModeYawInputLimit;                        // 0x0128(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _floatingCameraMaxSpeed;                           // 0x0150(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _floatingCameraAccelerationMultiplier;             // 0x01D0(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _strafeMovementSpeedMultiplier;                    // 0x01F8(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ADBDPlayer>              _playerOwner;                                      // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x48];                                     // 0x0228(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_EnableWalkOffLegdes(bool isEnabled);
	void Server_EnableWalkOffLegdes(bool isEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloatingCameraNavigationComponent">();
	}
	static class UFloatingCameraNavigationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloatingCameraNavigationComponent>();
	}
};
static_assert(alignof(UFloatingCameraNavigationComponent) == 0x000008, "Wrong alignment on UFloatingCameraNavigationComponent");
static_assert(sizeof(UFloatingCameraNavigationComponent) == 0x000270, "Wrong size on UFloatingCameraNavigationComponent");
static_assert(offsetof(UFloatingCameraNavigationComponent, _ownerObjectPlacer) == 0x0000D0, "Member 'UFloatingCameraNavigationComponent::_ownerObjectPlacer' has a wrong offset!");
static_assert(offsetof(UFloatingCameraNavigationComponent, _snappingDistance) == 0x0000D8, "Member 'UFloatingCameraNavigationComponent::_snappingDistance' has a wrong offset!");
static_assert(offsetof(UFloatingCameraNavigationComponent, _previewSnappingTime) == 0x000100, "Member 'UFloatingCameraNavigationComponent::_previewSnappingTime' has a wrong offset!");
static_assert(offsetof(UFloatingCameraNavigationComponent, _drawPathModeYawInputLimit) == 0x000128, "Member 'UFloatingCameraNavigationComponent::_drawPathModeYawInputLimit' has a wrong offset!");
static_assert(offsetof(UFloatingCameraNavigationComponent, _floatingCameraMaxSpeed) == 0x000150, "Member 'UFloatingCameraNavigationComponent::_floatingCameraMaxSpeed' has a wrong offset!");
static_assert(offsetof(UFloatingCameraNavigationComponent, _floatingCameraAccelerationMultiplier) == 0x0001D0, "Member 'UFloatingCameraNavigationComponent::_floatingCameraAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UFloatingCameraNavigationComponent, _strafeMovementSpeedMultiplier) == 0x0001F8, "Member 'UFloatingCameraNavigationComponent::_strafeMovementSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UFloatingCameraNavigationComponent, _playerOwner) == 0x000220, "Member 'UFloatingCameraNavigationComponent::_playerOwner' has a wrong offset!");

// Class TheK30.GuardAttackableComponent
// 0x0000 (0x00B8 - 0x00B8)
class UGuardAttackableComponent final : public UAttackableComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardAttackableComponent">();
	}
	static class UGuardAttackableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardAttackableComponent>();
	}
};
static_assert(alignof(UGuardAttackableComponent) == 0x000008, "Wrong alignment on UGuardAttackableComponent");
static_assert(sizeof(UGuardAttackableComponent) == 0x0000B8, "Wrong size on UGuardAttackableComponent");

// Class TheK30.GuardAttackComponent
// 0x0088 (0x0140 - 0x00B8)
class UGuardAttackComponent final : public UActorComponent
{
public:
	TSubclassOf<class UStatusEffect>              _killerInstinctEffectClass;                        // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _killerInstinctEffectDuration;                     // 0x00C0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDetectionZone                                _detectionZoneToUse;                               // 0x00E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TWeakObjectPtr<class ACamperPlayer>>     _survivorsInZone;                                  // 0x00F0(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardAttackComponent">();
	}
	static class UGuardAttackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardAttackComponent>();
	}
};
static_assert(alignof(UGuardAttackComponent) == 0x000008, "Wrong alignment on UGuardAttackComponent");
static_assert(sizeof(UGuardAttackComponent) == 0x000140, "Wrong size on UGuardAttackComponent");
static_assert(offsetof(UGuardAttackComponent, _killerInstinctEffectClass) == 0x0000B8, "Member 'UGuardAttackComponent::_killerInstinctEffectClass' has a wrong offset!");
static_assert(offsetof(UGuardAttackComponent, _killerInstinctEffectDuration) == 0x0000C0, "Member 'UGuardAttackComponent::_killerInstinctEffectDuration' has a wrong offset!");
static_assert(offsetof(UGuardAttackComponent, _detectionZoneToUse) == 0x0000E8, "Member 'UGuardAttackComponent::_detectionZoneToUse' has a wrong offset!");
static_assert(offsetof(UGuardAttackComponent, _survivorsInZone) == 0x0000F0, "Member 'UGuardAttackComponent::_survivorsInZone' has a wrong offset!");

// Class TheK30.GuardOrderBase
// 0x0010 (0x0630 - 0x0620)
class UGuardOrderBase : public UInteractionDefinition
{
public:
	bool                                          _shouldWaitForCurrentInteraction;                  // 0x0618(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_619[0x3];                                      // 0x0619(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _explodeInteractableAnimNotifyID;                  // 0x061C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_628[0x8];                                      // 0x0628(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardOrderBase">();
	}
	static class UGuardOrderBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardOrderBase>();
	}
};
static_assert(alignof(UGuardOrderBase) == 0x000010, "Wrong alignment on UGuardOrderBase");
static_assert(sizeof(UGuardOrderBase) == 0x000630, "Wrong size on UGuardOrderBase");
static_assert(offsetof(UGuardOrderBase, _shouldWaitForCurrentInteraction) == 0x000618, "Member 'UGuardOrderBase::_shouldWaitForCurrentInteraction' has a wrong offset!");
static_assert(offsetof(UGuardOrderBase, _explodeInteractableAnimNotifyID) == 0x00061C, "Member 'UGuardOrderBase::_explodeInteractableAnimNotifyID' has a wrong offset!");

// Class TheK30.GuardBreakPallet
// 0x0000 (0x0630 - 0x0630)
class UGuardBreakPallet final : public UGuardOrderBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardBreakPallet">();
	}
	static class UGuardBreakPallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardBreakPallet>();
	}
};
static_assert(alignof(UGuardBreakPallet) == 0x000010, "Wrong alignment on UGuardBreakPallet");
static_assert(sizeof(UGuardBreakPallet) == 0x000630, "Wrong size on UGuardBreakPallet");

// Class TheK30.GuardBreakWall
// 0x0000 (0x0630 - 0x0630)
class UGuardBreakWall final : public UGuardOrderBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardBreakWall">();
	}
	static class UGuardBreakWall* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardBreakWall>();
	}
};
static_assert(alignof(UGuardBreakWall) == 0x000010, "Wrong alignment on UGuardBreakWall");
static_assert(sizeof(UGuardBreakWall) == 0x000630, "Wrong size on UGuardBreakWall");

// Class TheK30.GuardController
// 0x0078 (0x0798 - 0x0720)
class AGuardController final : public ADBDAIBTController
{
public:
	uint8                                         Pad_720[0x8];                                      // 0x0720(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _cannotHuntWhileIdleTags;                          // 0x0728(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FName                                   _isPatrollingKey;                                  // 0x0738(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _patrolDestinationKey;                             // 0x0744(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _patrolUseDirectPathKey;                           // 0x0750(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _isHuntingKey;                                     // 0x075C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _huntedSurvivorKey;                                // 0x0768(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _huntDestinationKey;                               // 0x0774(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _huntUseDirectPathKey;                             // 0x0780(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _huntShouldSearchLockerKey;                        // 0x078C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnLoudNoiseTriggered(class AActor* originator, class AActor* instigatingActor, const struct FVector& location, bool shouldTrack, float* audibleRange, bool isQuickAction, bool isDeceivingNoise);
	void OnTargetPerceptionUpdated(class AActor* actor, const struct FAIStimulus& stimulus);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardController">();
	}
	static class AGuardController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGuardController>();
	}
};
static_assert(alignof(AGuardController) == 0x000008, "Wrong alignment on AGuardController");
static_assert(sizeof(AGuardController) == 0x000798, "Wrong size on AGuardController");
static_assert(offsetof(AGuardController, _cannotHuntWhileIdleTags) == 0x000728, "Member 'AGuardController::_cannotHuntWhileIdleTags' has a wrong offset!");
static_assert(offsetof(AGuardController, _isPatrollingKey) == 0x000738, "Member 'AGuardController::_isPatrollingKey' has a wrong offset!");
static_assert(offsetof(AGuardController, _patrolDestinationKey) == 0x000744, "Member 'AGuardController::_patrolDestinationKey' has a wrong offset!");
static_assert(offsetof(AGuardController, _patrolUseDirectPathKey) == 0x000750, "Member 'AGuardController::_patrolUseDirectPathKey' has a wrong offset!");
static_assert(offsetof(AGuardController, _isHuntingKey) == 0x00075C, "Member 'AGuardController::_isHuntingKey' has a wrong offset!");
static_assert(offsetof(AGuardController, _huntedSurvivorKey) == 0x000768, "Member 'AGuardController::_huntedSurvivorKey' has a wrong offset!");
static_assert(offsetof(AGuardController, _huntDestinationKey) == 0x000774, "Member 'AGuardController::_huntDestinationKey' has a wrong offset!");
static_assert(offsetof(AGuardController, _huntUseDirectPathKey) == 0x000780, "Member 'AGuardController::_huntUseDirectPathKey' has a wrong offset!");
static_assert(offsetof(AGuardController, _huntShouldSearchLockerKey) == 0x00078C, "Member 'AGuardController::_huntShouldSearchLockerKey' has a wrong offset!");

// Class TheK30.GuardDamageGenerator
// 0x0000 (0x0630 - 0x0630)
class UGuardDamageGenerator final : public UGuardOrderBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardDamageGenerator">();
	}
	static class UGuardDamageGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardDamageGenerator>();
	}
};
static_assert(alignof(UGuardDamageGenerator) == 0x000010, "Wrong alignment on UGuardDamageGenerator");
static_assert(sizeof(UGuardDamageGenerator) == 0x000630, "Wrong size on UGuardDamageGenerator");

// Class TheK30.GuardFlag
// 0x00E0 (0x0310 - 0x0230)
class AGuardFlag final : public AActor
{
public:
	class UPrimitiveComponent*                    _flagPickupHitbox;                                 // 0x0230(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AKnightGuard*                           _owningGuard;                                      // 0x0238(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _huntedSurvivor;                                   // 0x0240(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _flagPickupEnduranceEffectClass;                   // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _flagPickupEnduranceDuration;                      // 0x0250(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _flagPickupHasteEffectClass;                       // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _flagPickupHasteDuration;                          // 0x0280(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _flagPickupHasteModifier;                          // 0x02A8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x38];                                     // 0x02D0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _clientHuntedSurvivor;                             // 0x0308(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnBeginOverlap(class UPrimitiveComponent* overlappedComponent, class AActor* other, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& hitResult);
	void Cosmetic_OnFlagActivationTimerCompleted();
	void Cosmetic_OnFlagDisappearDueToHuntEnding(class ADBDPlayer* previouslyHuntedSurvivor);
	void Cosmetic_OnFlagSpawned(float activationTimerDuration);
	void Cosmetic_OnSurvivorCapturedFlag(class ADBDPlayer* previouslyHuntedSurvivor);
	void Multicast_OnCamperCapturedFlag(class ADBDPlayer* huntedSurvivor);
	void OnRep_HuntedSurvivor();

	float GetActivationTimeLeft() const;
	class ADBDPlayer* GetHuntedSurvivor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardFlag">();
	}
	static class AGuardFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGuardFlag>();
	}
};
static_assert(alignof(AGuardFlag) == 0x000008, "Wrong alignment on AGuardFlag");
static_assert(sizeof(AGuardFlag) == 0x000310, "Wrong size on AGuardFlag");
static_assert(offsetof(AGuardFlag, _flagPickupHitbox) == 0x000230, "Member 'AGuardFlag::_flagPickupHitbox' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _owningGuard) == 0x000238, "Member 'AGuardFlag::_owningGuard' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _huntedSurvivor) == 0x000240, "Member 'AGuardFlag::_huntedSurvivor' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _flagPickupEnduranceEffectClass) == 0x000248, "Member 'AGuardFlag::_flagPickupEnduranceEffectClass' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _flagPickupEnduranceDuration) == 0x000250, "Member 'AGuardFlag::_flagPickupEnduranceDuration' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _flagPickupHasteEffectClass) == 0x000278, "Member 'AGuardFlag::_flagPickupHasteEffectClass' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _flagPickupHasteDuration) == 0x000280, "Member 'AGuardFlag::_flagPickupHasteDuration' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _flagPickupHasteModifier) == 0x0002A8, "Member 'AGuardFlag::_flagPickupHasteModifier' has a wrong offset!");
static_assert(offsetof(AGuardFlag, _clientHuntedSurvivor) == 0x000308, "Member 'AGuardFlag::_clientHuntedSurvivor' has a wrong offset!");

// Class TheK30.GuardFlagOUtlineUpdateStrategy
// 0x0020 (0x00E0 - 0x00C0)
class UGuardFlagOUtlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _killerColor;                                      // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _survivorColor;                                    // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardFlagOUtlineUpdateStrategy">();
	}
	static class UGuardFlagOUtlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardFlagOUtlineUpdateStrategy>();
	}
};
static_assert(alignof(UGuardFlagOUtlineUpdateStrategy) == 0x000008, "Wrong alignment on UGuardFlagOUtlineUpdateStrategy");
static_assert(sizeof(UGuardFlagOUtlineUpdateStrategy) == 0x0000E0, "Wrong size on UGuardFlagOUtlineUpdateStrategy");
static_assert(offsetof(UGuardFlagOUtlineUpdateStrategy, _killerColor) == 0x0000C0, "Member 'UGuardFlagOUtlineUpdateStrategy::_killerColor' has a wrong offset!");
static_assert(offsetof(UGuardFlagOUtlineUpdateStrategy, _survivorColor) == 0x0000D0, "Member 'UGuardFlagOUtlineUpdateStrategy::_survivorColor' has a wrong offset!");

// Class TheK30.GuardHuntComponent
// 0x00D0 (0x0188 - 0x00B8)
class UGuardHuntComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(float completionProgress)> OnGuardPhaseProgressUpdate;             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x24];                                      // 0x00C8(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxPathingDetourLength;                           // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _distanceBeforeGoingToNextWaypoint;                // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _distanceBeforeGoingToNextWaypointOffNavmesh;      // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _distanceFromLockerToClearWaypoints;               // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _underWaypointZDistance;                           // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSpeedBasedNetSyncedValue              _huntTimeLeft;                                     // 0x0100(0x0038)(Net, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACamperPlayer*                          _huntedSurvivor;                                   // 0x0138(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x4];                                      // 0x0140(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _huntStartingLocation;                             // 0x0144(0x000C)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x20];                                     // 0x0150(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _speedConsideredStuck;                             // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timeStuckToResetPathing;                          // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x10];                                     // 0x0178(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCamperInjuredOrDowned(const struct FGameplayTag& gameplayTag, const struct FGameEventData& gameEventData);
	void Authority_OnCamperUnhooked(const struct FGameplayTag& gameplayTag, const struct FGameEventData& gameEventData);
	void OnRep_HuntedSurvivor(class ACamperPlayer* previousChasedSurvivor);
	void OnRep_HuntStartingLocation();

	class ACamperPlayer* GetHuntedSurvivor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardHuntComponent">();
	}
	static class UGuardHuntComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardHuntComponent>();
	}
};
static_assert(alignof(UGuardHuntComponent) == 0x000008, "Wrong alignment on UGuardHuntComponent");
static_assert(sizeof(UGuardHuntComponent) == 0x000188, "Wrong size on UGuardHuntComponent");
static_assert(offsetof(UGuardHuntComponent, OnGuardPhaseProgressUpdate) == 0x0000B8, "Member 'UGuardHuntComponent::OnGuardPhaseProgressUpdate' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _maxPathingDetourLength) == 0x0000EC, "Member 'UGuardHuntComponent::_maxPathingDetourLength' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _distanceBeforeGoingToNextWaypoint) == 0x0000F0, "Member 'UGuardHuntComponent::_distanceBeforeGoingToNextWaypoint' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _distanceBeforeGoingToNextWaypointOffNavmesh) == 0x0000F4, "Member 'UGuardHuntComponent::_distanceBeforeGoingToNextWaypointOffNavmesh' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _distanceFromLockerToClearWaypoints) == 0x0000F8, "Member 'UGuardHuntComponent::_distanceFromLockerToClearWaypoints' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _underWaypointZDistance) == 0x0000FC, "Member 'UGuardHuntComponent::_underWaypointZDistance' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _huntTimeLeft) == 0x000100, "Member 'UGuardHuntComponent::_huntTimeLeft' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _huntedSurvivor) == 0x000138, "Member 'UGuardHuntComponent::_huntedSurvivor' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _huntStartingLocation) == 0x000144, "Member 'UGuardHuntComponent::_huntStartingLocation' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _speedConsideredStuck) == 0x000170, "Member 'UGuardHuntComponent::_speedConsideredStuck' has a wrong offset!");
static_assert(offsetof(UGuardHuntComponent, _timeStuckToResetPathing) == 0x000174, "Member 'UGuardHuntComponent::_timeStuckToResetPathing' has a wrong offset!");

// Class TheK30.GuardHuntTeleport
// 0x0030 (0x0650 - 0x0620)
class UGuardHuntTeleport final : public UInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _huntStartUpDuration;                              // 0x0618(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _huntStartUpDurationPathLengthMultiplier;          // 0x0640(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardHuntTeleport">();
	}
	static class UGuardHuntTeleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardHuntTeleport>();
	}
};
static_assert(alignof(UGuardHuntTeleport) == 0x000010, "Wrong alignment on UGuardHuntTeleport");
static_assert(sizeof(UGuardHuntTeleport) == 0x000650, "Wrong size on UGuardHuntTeleport");
static_assert(offsetof(UGuardHuntTeleport, _huntStartUpDuration) == 0x000618, "Member 'UGuardHuntTeleport::_huntStartUpDuration' has a wrong offset!");
static_assert(offsetof(UGuardHuntTeleport, _huntStartUpDurationPathLengthMultiplier) == 0x000640, "Member 'UGuardHuntTeleport::_huntStartUpDurationPathLengthMultiplier' has a wrong offset!");

// Class TheK30.GuardInteractable
// 0x0008 (0x0350 - 0x0348)
class AGuardInteractable final : public APlayerInteractable
{
public:
	class UInteractionDefinition*                 _startHuntInteraction;                             // 0x0348(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardInteractable">();
	}
	static class AGuardInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGuardInteractable>();
	}
};
static_assert(alignof(AGuardInteractable) == 0x000008, "Wrong alignment on AGuardInteractable");
static_assert(sizeof(AGuardInteractable) == 0x000350, "Wrong size on AGuardInteractable");
static_assert(offsetof(AGuardInteractable, _startHuntInteraction) == 0x000348, "Member 'AGuardInteractable::_startHuntInteraction' has a wrong offset!");

// Class TheK30.GuardOutlineUpdateStrategy
// 0x0010 (0x00D0 - 0x00C0)
class UGuardOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _killerColor;                                      // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardOutlineUpdateStrategy">();
	}
	static class UGuardOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UGuardOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UGuardOutlineUpdateStrategy");
static_assert(sizeof(UGuardOutlineUpdateStrategy) == 0x0000D0, "Wrong size on UGuardOutlineUpdateStrategy");
static_assert(offsetof(UGuardOutlineUpdateStrategy, _killerColor) == 0x0000C0, "Member 'UGuardOutlineUpdateStrategy::_killerColor' has a wrong offset!");

// Class TheK30.GuardPatrolComponent
// 0x0120 (0x01D8 - 0x00B8)
class UGuardPatrolComponent final : public UActorComponent
{
public:
	uint8                                         _currentDirection;                                 // 0x00B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x17];                                      // 0x00B9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _patrolPathLength;                                 // 0x00D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInPatrolStartup;                                // 0x00D4(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isPatrolling;                                     // 0x00D5(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpeedBasedNetSyncedValue              _patrolTimeLeft;                                   // 0x00D8(0x0038)(Net, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x30];                                     // 0x0110(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _patrolTotalDuration;                              // 0x0140(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _distanceBeforeHeadingToNextNode;                  // 0x0144(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _spawningVisionAngle;                              // 0x0150(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _patrollingVisionAngle;                            // 0x0178(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _timeToInterpolateVisionRadius;                    // 0x01A0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _detectionRadiusInterpolationDurationPathLengthMultiplier; // 0x01C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _detectionRadiusPathLenghtMultiplier;              // 0x01D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_IsPatrolling();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardPatrolComponent">();
	}
	static class UGuardPatrolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardPatrolComponent>();
	}
};
static_assert(alignof(UGuardPatrolComponent) == 0x000008, "Wrong alignment on UGuardPatrolComponent");
static_assert(sizeof(UGuardPatrolComponent) == 0x0001D8, "Wrong size on UGuardPatrolComponent");
static_assert(offsetof(UGuardPatrolComponent, _currentDirection) == 0x0000B8, "Member 'UGuardPatrolComponent::_currentDirection' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _patrolPathLength) == 0x0000D0, "Member 'UGuardPatrolComponent::_patrolPathLength' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _isInPatrolStartup) == 0x0000D4, "Member 'UGuardPatrolComponent::_isInPatrolStartup' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _isPatrolling) == 0x0000D5, "Member 'UGuardPatrolComponent::_isPatrolling' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _patrolTimeLeft) == 0x0000D8, "Member 'UGuardPatrolComponent::_patrolTimeLeft' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _patrolTotalDuration) == 0x000140, "Member 'UGuardPatrolComponent::_patrolTotalDuration' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _distanceBeforeHeadingToNextNode) == 0x000144, "Member 'UGuardPatrolComponent::_distanceBeforeHeadingToNextNode' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _spawningVisionAngle) == 0x000150, "Member 'UGuardPatrolComponent::_spawningVisionAngle' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _patrollingVisionAngle) == 0x000178, "Member 'UGuardPatrolComponent::_patrollingVisionAngle' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _timeToInterpolateVisionRadius) == 0x0001A0, "Member 'UGuardPatrolComponent::_timeToInterpolateVisionRadius' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _detectionRadiusInterpolationDurationPathLengthMultiplier) == 0x0001C8, "Member 'UGuardPatrolComponent::_detectionRadiusInterpolationDurationPathLengthMultiplier' has a wrong offset!");
static_assert(offsetof(UGuardPatrolComponent, _detectionRadiusPathLenghtMultiplier) == 0x0001D0, "Member 'UGuardPatrolComponent::_detectionRadiusPathLenghtMultiplier' has a wrong offset!");

// Class TheK30.GuardPullSurvivorOutOfLocker
// 0x0070 (0x06C0 - 0x0650)
class UGuardPullSurvivorOutOfLocker final : public UBaseLockerInteraction
{
public:
	class ACamperPlayer*                          _targetSurvivor;                                   // 0x0648(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAnimationMontageDescriptor            _healthySurvivorUpdateMontage;                     // 0x0650(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FAnimationMontageDescriptor            _injuredSurvivorUpdateMontage;                     // 0x0670(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _pullOutOfLockerDuration;                          // 0x0690(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B8[0x8];                                      // 0x06B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardPullSurvivorOutOfLocker">();
	}
	static class UGuardPullSurvivorOutOfLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardPullSurvivorOutOfLocker>();
	}
};
static_assert(alignof(UGuardPullSurvivorOutOfLocker) == 0x000010, "Wrong alignment on UGuardPullSurvivorOutOfLocker");
static_assert(sizeof(UGuardPullSurvivorOutOfLocker) == 0x0006C0, "Wrong size on UGuardPullSurvivorOutOfLocker");
static_assert(offsetof(UGuardPullSurvivorOutOfLocker, _targetSurvivor) == 0x000648, "Member 'UGuardPullSurvivorOutOfLocker::_targetSurvivor' has a wrong offset!");
static_assert(offsetof(UGuardPullSurvivorOutOfLocker, _healthySurvivorUpdateMontage) == 0x000650, "Member 'UGuardPullSurvivorOutOfLocker::_healthySurvivorUpdateMontage' has a wrong offset!");
static_assert(offsetof(UGuardPullSurvivorOutOfLocker, _injuredSurvivorUpdateMontage) == 0x000670, "Member 'UGuardPullSurvivorOutOfLocker::_injuredSurvivorUpdateMontage' has a wrong offset!");
static_assert(offsetof(UGuardPullSurvivorOutOfLocker, _pullOutOfLockerDuration) == 0x000690, "Member 'UGuardPullSurvivorOutOfLocker::_pullOutOfLockerDuration' has a wrong offset!");

// Class TheK30.GuardSlowingZone
// 0x0000 (0x0230 - 0x0230)
class AGuardSlowingZone : public AActor
{
public:
	void OnZoneBeginOverlap(class AActor* overlappedActor, class AActor* otherActor);
	void OnZoneEndOverlap(class AActor* overlappedActor, class AActor* otherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardSlowingZone">();
	}
	static class AGuardSlowingZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGuardSlowingZone>();
	}
};
static_assert(alignof(AGuardSlowingZone) == 0x000008, "Wrong alignment on AGuardSlowingZone");
static_assert(sizeof(AGuardSlowingZone) == 0x000230, "Wrong size on AGuardSlowingZone");

// Class TheK30.GuardPalletSlowingZone
// 0x0008 (0x0238 - 0x0230)
class AGuardPalletSlowingZone final : public AGuardSlowingZone
{
public:
	class APallet*                                _linkedPallet;                                     // 0x0230(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_LinkedPallet();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardPalletSlowingZone">();
	}
	static class AGuardPalletSlowingZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGuardPalletSlowingZone>();
	}
};
static_assert(alignof(AGuardPalletSlowingZone) == 0x000008, "Wrong alignment on AGuardPalletSlowingZone");
static_assert(sizeof(AGuardPalletSlowingZone) == 0x000238, "Wrong size on AGuardPalletSlowingZone");
static_assert(offsetof(AGuardPalletSlowingZone, _linkedPallet) == 0x000230, "Member 'AGuardPalletSlowingZone::_linkedPallet' has a wrong offset!");

// Class TheK30.K30BaseStatusEffectAddon
// 0x0020 (0x02D8 - 0x02B8)
class UK30BaseStatusEffectAddon : public UItemAddon
{
public:
	TArray<TSubclassOf<class UStatusEffect>>      _baseStatusEffectClasses;                          // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         _lifetime;                                         // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _customParam;                                      // 0x02CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldDisplay;                                    // 0x02D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30BaseStatusEffectAddon">();
	}
	static class UK30BaseStatusEffectAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30BaseStatusEffectAddon>();
	}
};
static_assert(alignof(UK30BaseStatusEffectAddon) == 0x000008, "Wrong alignment on UK30BaseStatusEffectAddon");
static_assert(sizeof(UK30BaseStatusEffectAddon) == 0x0002D8, "Wrong size on UK30BaseStatusEffectAddon");
static_assert(offsetof(UK30BaseStatusEffectAddon, _baseStatusEffectClasses) == 0x0002B8, "Member 'UK30BaseStatusEffectAddon::_baseStatusEffectClasses' has a wrong offset!");
static_assert(offsetof(UK30BaseStatusEffectAddon, _lifetime) == 0x0002C8, "Member 'UK30BaseStatusEffectAddon::_lifetime' has a wrong offset!");
static_assert(offsetof(UK30BaseStatusEffectAddon, _customParam) == 0x0002CC, "Member 'UK30BaseStatusEffectAddon::_customParam' has a wrong offset!");
static_assert(offsetof(UK30BaseStatusEffectAddon, _shouldDisplay) == 0x0002D0, "Member 'UK30BaseStatusEffectAddon::_shouldDisplay' has a wrong offset!");

// Class TheK30.K30InflictStatusOnEndHuntAddon
// 0x0010 (0x02E8 - 0x02D8)
class UK30InflictStatusOnEndHuntAddon : public UK30BaseStatusEffectAddon
{
public:
	TArray<EGuardHuntEndReason>                   _huntEndReasonsToApplyEffect;                      // 0x02D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void Authority_OnEndHunt(class ADBDPlayer* player, EGuardHuntEndReason huntEndReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30InflictStatusOnEndHuntAddon">();
	}
	static class UK30InflictStatusOnEndHuntAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30InflictStatusOnEndHuntAddon>();
	}
};
static_assert(alignof(UK30InflictStatusOnEndHuntAddon) == 0x000008, "Wrong alignment on UK30InflictStatusOnEndHuntAddon");
static_assert(sizeof(UK30InflictStatusOnEndHuntAddon) == 0x0002E8, "Wrong size on UK30InflictStatusOnEndHuntAddon");
static_assert(offsetof(UK30InflictStatusOnEndHuntAddon, _huntEndReasonsToApplyEffect) == 0x0002D8, "Member 'UK30InflictStatusOnEndHuntAddon::_huntEndReasonsToApplyEffect' has a wrong offset!");

// Class TheK30.K30Addon14
// 0x0008 (0x02F0 - 0x02E8)
class UK30Addon14 final : public UK30InflictStatusOnEndHuntAddon
{
public:
	int32                                         _numberOfEscapesBeforeEffect;                      // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30Addon14">();
	}
	static class UK30Addon14* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30Addon14>();
	}
};
static_assert(alignof(UK30Addon14) == 0x000008, "Wrong alignment on UK30Addon14");
static_assert(sizeof(UK30Addon14) == 0x0002F0, "Wrong size on UK30Addon14");
static_assert(offsetof(UK30Addon14, _numberOfEscapesBeforeEffect) == 0x0002E8, "Member 'UK30Addon14::_numberOfEscapesBeforeEffect' has a wrong offset!");

// Class TheK30.K30ApplyStatusOnWakeUpAddon
// 0x0008 (0x02E0 - 0x02D8)
class UK30ApplyStatusOnWakeUpAddon : public UK30BaseStatusEffectAddon
{
public:
	TSubclassOf<class AKnightGuard>               _applicableGuard;                                  // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Authority_OnWakeUp(class AKnightGuard* currentGuard);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30ApplyStatusOnWakeUpAddon">();
	}
	static class UK30ApplyStatusOnWakeUpAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30ApplyStatusOnWakeUpAddon>();
	}
};
static_assert(alignof(UK30ApplyStatusOnWakeUpAddon) == 0x000008, "Wrong alignment on UK30ApplyStatusOnWakeUpAddon");
static_assert(sizeof(UK30ApplyStatusOnWakeUpAddon) == 0x0002E0, "Wrong size on UK30ApplyStatusOnWakeUpAddon");
static_assert(offsetof(UK30ApplyStatusOnWakeUpAddon, _applicableGuard) == 0x0002D8, "Member 'UK30ApplyStatusOnWakeUpAddon::_applicableGuard' has a wrong offset!");

// Class TheK30.K30Addon16
// 0x0000 (0x02E0 - 0x02E0)
class UK30Addon16 final : public UK30ApplyStatusOnWakeUpAddon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30Addon16">();
	}
	static class UK30Addon16* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30Addon16>();
	}
};
static_assert(alignof(UK30Addon16) == 0x000008, "Wrong alignment on UK30Addon16");
static_assert(sizeof(UK30Addon16) == 0x0002E0, "Wrong size on UK30Addon16");

// Class TheK30.K30Addon17
// 0x0010 (0x02F0 - 0x02E0)
class UK30Addon17 final : public UK30ApplyStatusOnWakeUpAddon
{
public:
	TSubclassOf<class UStatusEffect>              _revealAuraToKillerEffectClass;                    // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _distanceForScreams;                               // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_RevealAndMakeSurvivorScream(class ADBDPlayer* survivorPlayer, const float screamRevealDuration);
	void Multicast_OnMakeSurvivorScream(class ADBDPlayer* player, const float lifetime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30Addon17">();
	}
	static class UK30Addon17* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30Addon17>();
	}
};
static_assert(alignof(UK30Addon17) == 0x000008, "Wrong alignment on UK30Addon17");
static_assert(sizeof(UK30Addon17) == 0x0002F0, "Wrong size on UK30Addon17");
static_assert(offsetof(UK30Addon17, _revealAuraToKillerEffectClass) == 0x0002E0, "Member 'UK30Addon17::_revealAuraToKillerEffectClass' has a wrong offset!");
static_assert(offsetof(UK30Addon17, _distanceForScreams) == 0x0002E8, "Member 'UK30Addon17::_distanceForScreams' has a wrong offset!");

// Class TheK30.K30Addon19
// 0x0010 (0x02F0 - 0x02E0)
class UK30Addon19 final : public UK30ApplyStatusOnWakeUpAddon
{
public:
	int32                                         _numberOfSummonsBeforeEffect;                      // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _distanceThresholdForEffect;                       // 0x02E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30Addon19">();
	}
	static class UK30Addon19* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30Addon19>();
	}
};
static_assert(alignof(UK30Addon19) == 0x000008, "Wrong alignment on UK30Addon19");
static_assert(sizeof(UK30Addon19) == 0x0002F0, "Wrong size on UK30Addon19");
static_assert(offsetof(UK30Addon19, _numberOfSummonsBeforeEffect) == 0x0002E0, "Member 'UK30Addon19::_numberOfSummonsBeforeEffect' has a wrong offset!");
static_assert(offsetof(UK30Addon19, _distanceThresholdForEffect) == 0x0002E4, "Member 'UK30Addon19::_distanceThresholdForEffect' has a wrong offset!");

// Class TheK30.K30Addon20
// 0x0038 (0x0310 - 0x02D8)
class UK30Addon20 final : public UK30BaseStatusEffectAddon
{
public:
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AWindow*>                        _blockedWindows;                                   // 0x02E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _huntedSurvivor;                                   // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _gateBlockerEffectClass;                           // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _trailPassThroughWindowBlockTime;                  // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnEndHunt(class ADBDPlayer* player, EGuardHuntEndReason huntEndReason);
	void Authority_OnHuntedSurvivorVault(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Authority_OnStartHunt(class ADBDPlayer* player);
	void Authority_OnTrailCameraGoThroughWindow(class AWindow* window);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30Addon20">();
	}
	static class UK30Addon20* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30Addon20>();
	}
};
static_assert(alignof(UK30Addon20) == 0x000008, "Wrong alignment on UK30Addon20");
static_assert(sizeof(UK30Addon20) == 0x000310, "Wrong size on UK30Addon20");
static_assert(offsetof(UK30Addon20, _blockedWindows) == 0x0002E8, "Member 'UK30Addon20::_blockedWindows' has a wrong offset!");
static_assert(offsetof(UK30Addon20, _huntedSurvivor) == 0x0002F8, "Member 'UK30Addon20::_huntedSurvivor' has a wrong offset!");
static_assert(offsetof(UK30Addon20, _gateBlockerEffectClass) == 0x000300, "Member 'UK30Addon20::_gateBlockerEffectClass' has a wrong offset!");
static_assert(offsetof(UK30Addon20, _trailPassThroughWindowBlockTime) == 0x000308, "Member 'UK30Addon20::_trailPassThroughWindowBlockTime' has a wrong offset!");

// Class TheK30.K30AnimInstance
// 0x0010 (0x0610 - 0x0600)
class UK30AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isChargingPower;                                  // 0x0600(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSnapping;                                       // 0x0601(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDrawingPath;                                    // 0x0602(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_603[0xD];                                      // 0x0603(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30AnimInstance">();
	}
	static class UK30AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30AnimInstance>();
	}
};
static_assert(alignof(UK30AnimInstance) == 0x000010, "Wrong alignment on UK30AnimInstance");
static_assert(sizeof(UK30AnimInstance) == 0x000610, "Wrong size on UK30AnimInstance");
static_assert(offsetof(UK30AnimInstance, _isChargingPower) == 0x000600, "Member 'UK30AnimInstance::_isChargingPower' has a wrong offset!");
static_assert(offsetof(UK30AnimInstance, _isSnapping) == 0x000601, "Member 'UK30AnimInstance::_isSnapping' has a wrong offset!");
static_assert(offsetof(UK30AnimInstance, _isDrawingPath) == 0x000602, "Member 'UK30AnimInstance::_isDrawingPath' has a wrong offset!");

// Class TheK30.K30CheatComponent
// 0x0008 (0x00C0 - 0x00B8)
class UK30CheatComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_K30SetNextGuardIndex(int32 nextGuardIndex);
	void DBD_K30SetPatrolAndHuntDuration(float secondsToPatrol);
	void DBD_K30ToggleGuardAttackDespawn(int32 despawnOnAttack);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30CheatComponent">();
	}
	static class UK30CheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30CheatComponent>();
	}
};
static_assert(alignof(UK30CheatComponent) == 0x000008, "Wrong alignment on UK30CheatComponent");
static_assert(sizeof(UK30CheatComponent) == 0x0000C0, "Wrong size on UK30CheatComponent");

// Class TheK30.K30InflictStatusOnDetectedAddon
// 0x0000 (0x02D8 - 0x02D8)
class UK30InflictStatusOnDetectedAddon final : public UK30BaseStatusEffectAddon
{
public:
	void Authority_OnDetected(class ADBDPlayer* player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30InflictStatusOnDetectedAddon">();
	}
	static class UK30InflictStatusOnDetectedAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30InflictStatusOnDetectedAddon>();
	}
};
static_assert(alignof(UK30InflictStatusOnDetectedAddon) == 0x000008, "Wrong alignment on UK30InflictStatusOnDetectedAddon");
static_assert(sizeof(UK30InflictStatusOnDetectedAddon) == 0x0002D8, "Wrong size on UK30InflictStatusOnDetectedAddon");

// Class TheK30.K30InflictStatusOnGuardHitAddon
// 0x0000 (0x02D8 - 0x02D8)
class UK30InflictStatusOnGuardHitAddon final : public UK30BaseStatusEffectAddon
{
public:
	void Authority_OnGuardHit(class ADBDPlayer* player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30InflictStatusOnGuardHitAddon">();
	}
	static class UK30InflictStatusOnGuardHitAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30InflictStatusOnGuardHitAddon>();
	}
};
static_assert(alignof(UK30InflictStatusOnGuardHitAddon) == 0x000008, "Wrong alignment on UK30InflictStatusOnGuardHitAddon");
static_assert(sizeof(UK30InflictStatusOnGuardHitAddon) == 0x0002D8, "Wrong size on UK30InflictStatusOnGuardHitAddon");

// Class TheK30.K30KnightHuskOutlineUpdateStrategy
// 0x0010 (0x00D0 - 0x00C0)
class UK30KnightHuskOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30KnightHuskOutlineUpdateStrategy">();
	}
	static class UK30KnightHuskOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30KnightHuskOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK30KnightHuskOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK30KnightHuskOutlineUpdateStrategy");
static_assert(sizeof(UK30KnightHuskOutlineUpdateStrategy) == 0x0000D0, "Wrong size on UK30KnightHuskOutlineUpdateStrategy");

// Class TheK30.K30P01
// 0x0020 (0x03E8 - 0x03C8)
class UK30P01 final : public UPerk
{
public:
	float                                         _revealRange;                                      // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _revealToKillerEffectClass;                        // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _revealDuration[0x3];                              // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30P01">();
	}
	static class UK30P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30P01>();
	}
};
static_assert(alignof(UK30P01) == 0x000008, "Wrong alignment on UK30P01");
static_assert(sizeof(UK30P01) == 0x0003E8, "Wrong size on UK30P01");
static_assert(offsetof(UK30P01, _revealRange) == 0x0003C8, "Member 'UK30P01::_revealRange' has a wrong offset!");
static_assert(offsetof(UK30P01, _revealToKillerEffectClass) == 0x0003D0, "Member 'UK30P01::_revealToKillerEffectClass' has a wrong offset!");
static_assert(offsetof(UK30P01, _revealDuration) == 0x0003D8, "Member 'UK30P01::_revealDuration' has a wrong offset!");

// Class TheK30.K30P02
// 0x0040 (0x0488 - 0x0448)
class UK30P02 final : public UHexPerk
{
public:
	class ADBDPlayer*                             _cursedPlayer;                                     // 0x0448(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  _activeStatusEffects;                              // 0x0450(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _screamEffectClass;                                // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _screamLoudNoiseDuration;                          // 0x0468(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _screamRevealAuraToKillerEffectClass;              // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _screamRevealAuraToKillerDuration;                 // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _screamInterval[0x3];                              // 0x047C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnSurvivorFirstScream(class ADBDPlayer* player);
	void Authority_OnTotemStateChanged(const ETotemState oldState, const ETotemState newState);
	void Authority_UncursePlayer();

	const float GetScreamInterval() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30P02">();
	}
	static class UK30P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30P02>();
	}
};
static_assert(alignof(UK30P02) == 0x000008, "Wrong alignment on UK30P02");
static_assert(sizeof(UK30P02) == 0x000488, "Wrong size on UK30P02");
static_assert(offsetof(UK30P02, _cursedPlayer) == 0x000448, "Member 'UK30P02::_cursedPlayer' has a wrong offset!");
static_assert(offsetof(UK30P02, _activeStatusEffects) == 0x000450, "Member 'UK30P02::_activeStatusEffects' has a wrong offset!");
static_assert(offsetof(UK30P02, _screamEffectClass) == 0x000460, "Member 'UK30P02::_screamEffectClass' has a wrong offset!");
static_assert(offsetof(UK30P02, _screamLoudNoiseDuration) == 0x000468, "Member 'UK30P02::_screamLoudNoiseDuration' has a wrong offset!");
static_assert(offsetof(UK30P02, _screamRevealAuraToKillerEffectClass) == 0x000470, "Member 'UK30P02::_screamRevealAuraToKillerEffectClass' has a wrong offset!");
static_assert(offsetof(UK30P02, _screamRevealAuraToKillerDuration) == 0x000478, "Member 'UK30P02::_screamRevealAuraToKillerDuration' has a wrong offset!");
static_assert(offsetof(UK30P02, _screamInterval) == 0x00047C, "Member 'UK30P02::_screamInterval' has a wrong offset!");

// Class TheK30.K30P02ScreamStatusEffect
// 0x0080 (0x03D0 - 0x0350)
class UK30P02ScreamStatusEffect final : public UStatusEffect
{
public:
	uint8                                         Pad_350[0x28];                                     // 0x0350(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _screamingPlayerRevealAuraEffectClass;             // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  _screamPreventingTags;                             // 0x0380(0x0020)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x30];                                     // 0x03A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_MakeSurvivorScream(class ADBDPlayer* survivorPlayer, const float screamRevealDuration);
	void Multicast_MakePlayerScream(const float screamRevealDuration);

	float GetTimerDuration() const;
	float GetTimerElapsedTime() const;
	float GetTimerRemainingTime() const;
	bool IsTimerActive() const;
	bool IsTimerPaused() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30P02ScreamStatusEffect">();
	}
	static class UK30P02ScreamStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30P02ScreamStatusEffect>();
	}
};
static_assert(alignof(UK30P02ScreamStatusEffect) == 0x000008, "Wrong alignment on UK30P02ScreamStatusEffect");
static_assert(sizeof(UK30P02ScreamStatusEffect) == 0x0003D0, "Wrong size on UK30P02ScreamStatusEffect");
static_assert(offsetof(UK30P02ScreamStatusEffect, _screamingPlayerRevealAuraEffectClass) == 0x000378, "Member 'UK30P02ScreamStatusEffect::_screamingPlayerRevealAuraEffectClass' has a wrong offset!");
static_assert(offsetof(UK30P02ScreamStatusEffect, _screamPreventingTags) == 0x000380, "Member 'UK30P02ScreamStatusEffect::_screamPreventingTags' has a wrong offset!");

// Class TheK30.K30P03
// 0x0010 (0x03D8 - 0x03C8)
class UK30P03 final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _exposedEffectClass;                               // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cooldownTime;                                     // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30P03">();
	}
	static class UK30P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30P03>();
	}
};
static_assert(alignof(UK30P03) == 0x000008, "Wrong alignment on UK30P03");
static_assert(sizeof(UK30P03) == 0x0003D8, "Wrong size on UK30P03");
static_assert(offsetof(UK30P03, _exposedEffectClass) == 0x0003C8, "Member 'UK30P03::_exposedEffectClass' has a wrong offset!");
static_assert(offsetof(UK30P03, _cooldownTime) == 0x0003D0, "Member 'UK30P03::_cooldownTime' has a wrong offset!");

// Class TheK30.K30Power
// 0x0350 (0x0800 - 0x04B0)
class alignas(0x10) AK30Power final : public ACollectable
{
public:
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnMoriBegin;                                       // 0x04B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMoriEnd;                                         // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EPowerState previousState, EPowerState newState)> OnPowerStateChanged; // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E8[0x30];                                     // 0x04E8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractor*                            _interactor;                                       // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDrawPatrolPathInteraction*             _drawPathInteraction;                              // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKnightOrderComponent*                  _orderComponent;                                   // 0x0528(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_530[0x48];                                     // 0x0530(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AKnightGuard*>                   _guards;                                           // 0x0578(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AKnightGuard>>       _guardClasses;                                     // 0x0588(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _drawPathStatusEffectClass;                        // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _hideSurvivorVFXEffectClass;                       // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _immuneToBlindEffectClass;                         // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class APoseableHusk>              _knightHuskClass;                                  // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AGuardPalletSlowingZone>    _palletSlowingZoneClass;                           // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AGuardSlowingZone>          _vaultSlowingZoneClass;                            // 0x05C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UK30SurvivorStatusComponent> _k30SurvivorStatusComponentClass;                 // 0x05C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGuardPullSurvivorOutOfLocker> _pullSurvivorOutOfLockerInteractionClass;       // 0x05D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APoseableHusk*                          _knightHusk;                                       // 0x05D8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     _drawPathIndicatorClass;                           // 0x05E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _drawPathIndicator;                                // 0x05E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPatrolTrailComponent*                  _patrolTrailComponent;                             // 0x05F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFloatingCameraNavigationComponent*     _floatingCameraNavigationComponent;                // 0x05F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK30PowerPresentationComponent*         _powerPresentationComponent;                       // 0x0600(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_608[0x8];                                      // 0x0608(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerInteractionHandler*              _interactionHandler;                               // 0x0610(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         _currentGuardIndex;                                // 0x0618(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         _nextGuardIndex;                                   // 0x0619(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_61A[0x6E];                                     // 0x061A(0x006E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _lookAtPreviewSpeed;                               // 0x0688(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _maxPathLength;                                    // 0x06B0(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _remainingPathLengthPercent;                       // 0x0730(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_734[0x4];                                      // 0x0734(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _powerReadyDelay;                                  // 0x0738(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _isVisibleDuringPathCreationModeTags;              // 0x0760(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pathCreationModeOverFadeInTime;                   // 0x0770(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _enableInteractionAfterTeleportationDelay;         // 0x0798(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79C[0x64];                                     // 0x079C(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnPathDrawAvailableBegin();
	void Cosmetic_OnPathDrawAvailableEnd();
	void Cosmetic_UpdateRemainingPathLength(float remainingPathLengthPercent);
	void Multicast_OnSnappingStateChanged(bool isSnapping);
	void OnEndOverlapWindow(class UPrimitiveComponent* overlappedComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex);
	void OnInteractionStateChanged(bool isCharging, bool isChargeCompleted);
	void OnOrderTargetChanged();
	void OnRep_KnightHusk();
	void SendPathNearlyEndingWarning();
	void Server_OnSnappingStateChanged(bool isSnapping);

	bool IsChargingPower() const;
	bool IsDrawingPath() const;
	bool IsSnapping() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30Power">();
	}
	static class AK30Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK30Power>();
	}
};
static_assert(alignof(AK30Power) == 0x000010, "Wrong alignment on AK30Power");
static_assert(sizeof(AK30Power) == 0x000800, "Wrong size on AK30Power");
static_assert(offsetof(AK30Power, OnMoriBegin) == 0x0004B8, "Member 'AK30Power::OnMoriBegin' has a wrong offset!");
static_assert(offsetof(AK30Power, OnMoriEnd) == 0x0004C8, "Member 'AK30Power::OnMoriEnd' has a wrong offset!");
static_assert(offsetof(AK30Power, OnPowerStateChanged) == 0x0004D8, "Member 'AK30Power::OnPowerStateChanged' has a wrong offset!");
static_assert(offsetof(AK30Power, _interactor) == 0x000518, "Member 'AK30Power::_interactor' has a wrong offset!");
static_assert(offsetof(AK30Power, _drawPathInteraction) == 0x000520, "Member 'AK30Power::_drawPathInteraction' has a wrong offset!");
static_assert(offsetof(AK30Power, _orderComponent) == 0x000528, "Member 'AK30Power::_orderComponent' has a wrong offset!");
static_assert(offsetof(AK30Power, _guards) == 0x000578, "Member 'AK30Power::_guards' has a wrong offset!");
static_assert(offsetof(AK30Power, _guardClasses) == 0x000588, "Member 'AK30Power::_guardClasses' has a wrong offset!");
static_assert(offsetof(AK30Power, _drawPathStatusEffectClass) == 0x000598, "Member 'AK30Power::_drawPathStatusEffectClass' has a wrong offset!");
static_assert(offsetof(AK30Power, _hideSurvivorVFXEffectClass) == 0x0005A0, "Member 'AK30Power::_hideSurvivorVFXEffectClass' has a wrong offset!");
static_assert(offsetof(AK30Power, _immuneToBlindEffectClass) == 0x0005A8, "Member 'AK30Power::_immuneToBlindEffectClass' has a wrong offset!");
static_assert(offsetof(AK30Power, _knightHuskClass) == 0x0005B0, "Member 'AK30Power::_knightHuskClass' has a wrong offset!");
static_assert(offsetof(AK30Power, _palletSlowingZoneClass) == 0x0005B8, "Member 'AK30Power::_palletSlowingZoneClass' has a wrong offset!");
static_assert(offsetof(AK30Power, _vaultSlowingZoneClass) == 0x0005C0, "Member 'AK30Power::_vaultSlowingZoneClass' has a wrong offset!");
static_assert(offsetof(AK30Power, _k30SurvivorStatusComponentClass) == 0x0005C8, "Member 'AK30Power::_k30SurvivorStatusComponentClass' has a wrong offset!");
static_assert(offsetof(AK30Power, _pullSurvivorOutOfLockerInteractionClass) == 0x0005D0, "Member 'AK30Power::_pullSurvivorOutOfLockerInteractionClass' has a wrong offset!");
static_assert(offsetof(AK30Power, _knightHusk) == 0x0005D8, "Member 'AK30Power::_knightHusk' has a wrong offset!");
static_assert(offsetof(AK30Power, _drawPathIndicatorClass) == 0x0005E0, "Member 'AK30Power::_drawPathIndicatorClass' has a wrong offset!");
static_assert(offsetof(AK30Power, _drawPathIndicator) == 0x0005E8, "Member 'AK30Power::_drawPathIndicator' has a wrong offset!");
static_assert(offsetof(AK30Power, _patrolTrailComponent) == 0x0005F0, "Member 'AK30Power::_patrolTrailComponent' has a wrong offset!");
static_assert(offsetof(AK30Power, _floatingCameraNavigationComponent) == 0x0005F8, "Member 'AK30Power::_floatingCameraNavigationComponent' has a wrong offset!");
static_assert(offsetof(AK30Power, _powerPresentationComponent) == 0x000600, "Member 'AK30Power::_powerPresentationComponent' has a wrong offset!");
static_assert(offsetof(AK30Power, _interactionHandler) == 0x000610, "Member 'AK30Power::_interactionHandler' has a wrong offset!");
static_assert(offsetof(AK30Power, _currentGuardIndex) == 0x000618, "Member 'AK30Power::_currentGuardIndex' has a wrong offset!");
static_assert(offsetof(AK30Power, _nextGuardIndex) == 0x000619, "Member 'AK30Power::_nextGuardIndex' has a wrong offset!");
static_assert(offsetof(AK30Power, _lookAtPreviewSpeed) == 0x000688, "Member 'AK30Power::_lookAtPreviewSpeed' has a wrong offset!");
static_assert(offsetof(AK30Power, _maxPathLength) == 0x0006B0, "Member 'AK30Power::_maxPathLength' has a wrong offset!");
static_assert(offsetof(AK30Power, _remainingPathLengthPercent) == 0x000730, "Member 'AK30Power::_remainingPathLengthPercent' has a wrong offset!");
static_assert(offsetof(AK30Power, _powerReadyDelay) == 0x000738, "Member 'AK30Power::_powerReadyDelay' has a wrong offset!");
static_assert(offsetof(AK30Power, _isVisibleDuringPathCreationModeTags) == 0x000760, "Member 'AK30Power::_isVisibleDuringPathCreationModeTags' has a wrong offset!");
static_assert(offsetof(AK30Power, _pathCreationModeOverFadeInTime) == 0x000770, "Member 'AK30Power::_pathCreationModeOverFadeInTime' has a wrong offset!");
static_assert(offsetof(AK30Power, _enableInteractionAfterTeleportationDelay) == 0x000798, "Member 'AK30Power::_enableInteractionAfterTeleportationDelay' has a wrong offset!");

// Class TheK30.K30PowerPresentationComponent
// 0x0000 (0x00B8 - 0x00B8)
class UK30PowerPresentationComponent final : public UPresentationItemProgressComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30PowerPresentationComponent">();
	}
	static class UK30PowerPresentationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30PowerPresentationComponent>();
	}
};
static_assert(alignof(UK30PowerPresentationComponent) == 0x000008, "Wrong alignment on UK30PowerPresentationComponent");
static_assert(sizeof(UK30PowerPresentationComponent) == 0x0000B8, "Wrong size on UK30PowerPresentationComponent");

// Class TheK30.K30PresentationPowerFadeComponent
// 0x0000 (0x00B8 - 0x00B8)
class UK30PresentationPowerFadeComponent final : public UPresentationPowerFadeComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30PresentationPowerFadeComponent">();
	}
	static class UK30PresentationPowerFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30PresentationPowerFadeComponent>();
	}
};
static_assert(alignof(UK30PresentationPowerFadeComponent) == 0x000008, "Wrong alignment on UK30PresentationPowerFadeComponent");
static_assert(sizeof(UK30PresentationPowerFadeComponent) == 0x0000B8, "Wrong size on UK30PresentationPowerFadeComponent");

// Class TheK30.K30RepeatGuardSpawnAddon
// 0x0008 (0x02C0 - 0x02B8)
class UK30RepeatGuardSpawnAddon final : public UItemAddon
{
public:
	uint8                                         _guardIndexToRepeat;                               // 0x02B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30RepeatGuardSpawnAddon">();
	}
	static class UK30RepeatGuardSpawnAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30RepeatGuardSpawnAddon>();
	}
};
static_assert(alignof(UK30RepeatGuardSpawnAddon) == 0x000008, "Wrong alignment on UK30RepeatGuardSpawnAddon");
static_assert(sizeof(UK30RepeatGuardSpawnAddon) == 0x0002C0, "Wrong size on UK30RepeatGuardSpawnAddon");
static_assert(offsetof(UK30RepeatGuardSpawnAddon, _guardIndexToRepeat) == 0x0002B8, "Member 'UK30RepeatGuardSpawnAddon::_guardIndexToRepeat' has a wrong offset!");

// Class TheK30.K30SurvivorCosmeticHelperActor
// 0x0020 (0x0288 - 0x0268)
class AK30SurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	uint8                                         Pad_268[0x20];                                     // 0x0268(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnHuntBegin();
	void Cosmetic_OnHuntEnd();
	void Cosmetic_OnSurvivorCaptureFlagBuffActivationStateChanged(bool isFlagCaptureBuffActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30SurvivorCosmeticHelperActor">();
	}
	static class AK30SurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK30SurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AK30SurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AK30SurvivorCosmeticHelperActor");
static_assert(sizeof(AK30SurvivorCosmeticHelperActor) == 0x000288, "Wrong size on AK30SurvivorCosmeticHelperActor");

// Class TheK30.K30SurvivorStatusComponent
// 0x0020 (0x00D8 - 0x00B8)
class UK30SurvivorStatusComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          _owningSurvivor;                                   // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ACamperPlayer>           _detectedSurvivor;                                 // 0x00C8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AK30Power>               _k30Power;                                         // 0x00D0(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30SurvivorStatusComponent">();
	}
	static class UK30SurvivorStatusComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30SurvivorStatusComponent>();
	}
};
static_assert(alignof(UK30SurvivorStatusComponent) == 0x000008, "Wrong alignment on UK30SurvivorStatusComponent");
static_assert(sizeof(UK30SurvivorStatusComponent) == 0x0000D8, "Wrong size on UK30SurvivorStatusComponent");
static_assert(offsetof(UK30SurvivorStatusComponent, _owningSurvivor) == 0x0000C0, "Member 'UK30SurvivorStatusComponent::_owningSurvivor' has a wrong offset!");
static_assert(offsetof(UK30SurvivorStatusComponent, _detectedSurvivor) == 0x0000C8, "Member 'UK30SurvivorStatusComponent::_detectedSurvivor' has a wrong offset!");
static_assert(offsetof(UK30SurvivorStatusComponent, _k30Power) == 0x0000D0, "Member 'UK30SurvivorStatusComponent::_k30Power' has a wrong offset!");

// Class TheK30.K30Utilities
// 0x0000 (0x0030 - 0x0030)
class UK30Utilities final : public UBlueprintFunctionLibrary
{
public:
	static class AKnightGuard* GetCurrentGuard(const class AActor* theK30);
	static int32 GetCurrentGuardIndex(const class AActor* theK30);
	static class AK30Power* GetK30Power(const class AActor* theK30);
	static class AKnightGuard* GetNextGuard(const class AActor* theK30);
	static int32 GetNextGuardIndex(const class AActor* theK30);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30Utilities">();
	}
	static class UK30Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30Utilities>();
	}
};
static_assert(alignof(UK30Utilities) == 0x000008, "Wrong alignment on UK30Utilities");
static_assert(sizeof(UK30Utilities) == 0x000030, "Wrong size on UK30Utilities");

// Class TheK30.KnightGuard
// 0x05F0 (0x1750 - 0x1160)
class AKnightGuard final : public ADBDPlayer
{
public:
	uint8                                         Pad_1158[0x60];                                    // 0x1158(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _attackZonePivot;                                  // 0x11B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C0[0x8];                                     // 0x11C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _guardNoiseEventTimeInterval;                      // 0x11C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _guardNoiseEventRange;                             // 0x11CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActive;                                         // 0x11D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11D1[0x7];                                     // 0x11D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ASlasherPlayer*                         _owningKiller;                                     // 0x11D8(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK30Power*                              _killerPower;                                      // 0x11E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AGuardFlag>                 _flagClass;                                        // 0x11E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGuardFlag*                             _guardFlag;                                        // 0x11F0(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGuardAttackComponent>      _attackComponentClass;                             // 0x11F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGuardAttackComponent*                  _attackComponent;                                  // 0x1200(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGuardAttackableComponent*              _attackableComponent;                              // 0x1208(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      _attackableCapsule;                                // 0x1210(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGuardHuntComponent>        _huntComponentClass;                               // 0x1218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGuardHuntComponent*                    _huntComponent;                                    // 0x1220(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGuardPatrolComponent>      _patrolComponentClass;                             // 0x1228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGuardPatrolComponent*                  _patrolComponent;                                  // 0x1230(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AGuardController>           _controllerClass;                                  // 0x1238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationMontageSlave*                 _animationFollower;                                // 0x1240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _gravityScale;                                     // 0x1248(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _patrolMovementSpeed;                              // 0x1270(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _patrolStartupDelay;                               // 0x12F0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _patrolDuration;                                   // 0x1318(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _huntMovementSpeed;                                // 0x1398(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _huntDuration;                                     // 0x13C0(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _orderDuration;                                    // 0x1440(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _flagActivationTime;                               // 0x14C0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _shouldInflictBleed;                               // 0x14E8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _spawningVisionRange;                              // 0x1510(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _patrollingVisionRange;                            // 0x1538(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _palletAndVaultsSlowedDownSpeed;                   // 0x15B8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _palletAndVaultsSlowDownDuration;                  // 0x15E0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _immediateGeneratorRegressionPercent;              // 0x1608(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _huntAuraVisibilityMinDistanceToKiller;            // 0x1630(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _guardHitSurvivorScoreEvent;                       // 0x1658(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _guardDetectSurvivorScoreEvent;                    // 0x1664(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _guardBreakInteractableEvent;                      // 0x1670(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _guardChaseEndedEvent;                             // 0x167C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1688[0x4];                                     // 0x1688(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _guardAnimTag;                                     // 0x168C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1698[0x60];                                    // 0x1698(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           _overlappingSurvivorsAndVaults;                    // 0x16F8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_1748[0x8];                                     // 0x1748(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_HideGuard();
	void Cosmetic_HuntChaseStarted();
	void Cosmetic_OnGuardVisionRadiusChanged(bool isVisible, float radius, float angle);
	void Cosmetic_OnHuntEnded(EGuardHuntEndReason reason);
	void Cosmetic_OnHuntTeleportStarted(float duration);
	void Cosmetic_OnOrderEnded();
	void Cosmetic_OnOrderStarted();
	void Cosmetic_OnPatrolEnded(class ADBDPlayer* foundSurvivor);
	void Cosmetic_OnPatrolStarted();
	void Cosmetic_ShowGuard();
	void Cosmetic_StartOverlappingVaultOrSurvivor();
	void Cosmetic_StopOverlappingVaultOrSurvivor();
	void Multicast_CosmeticHuntEnded(EGuardHuntEndReason reason);
	void Multicast_OnOrderEnded();
	void Multicast_OnPatrolEnded(class ADBDPlayer* foundSurvivor);
	void OnRep_IsActive(bool previousIsActive);
	void OnRep_OwningKiller();

	class ASlasherPlayer* GetOwningKiller() const;
	class UGuardPatrolComponent* GetPatrolComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnightGuard">();
	}
	static class AKnightGuard* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKnightGuard>();
	}
};
static_assert(alignof(AKnightGuard) == 0x000010, "Wrong alignment on AKnightGuard");
static_assert(sizeof(AKnightGuard) == 0x001750, "Wrong size on AKnightGuard");
static_assert(offsetof(AKnightGuard, _attackZonePivot) == 0x0011B8, "Member 'AKnightGuard::_attackZonePivot' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _guardNoiseEventTimeInterval) == 0x0011C8, "Member 'AKnightGuard::_guardNoiseEventTimeInterval' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _guardNoiseEventRange) == 0x0011CC, "Member 'AKnightGuard::_guardNoiseEventRange' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _isActive) == 0x0011D0, "Member 'AKnightGuard::_isActive' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _owningKiller) == 0x0011D8, "Member 'AKnightGuard::_owningKiller' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _killerPower) == 0x0011E0, "Member 'AKnightGuard::_killerPower' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _flagClass) == 0x0011E8, "Member 'AKnightGuard::_flagClass' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _guardFlag) == 0x0011F0, "Member 'AKnightGuard::_guardFlag' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _attackComponentClass) == 0x0011F8, "Member 'AKnightGuard::_attackComponentClass' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _attackComponent) == 0x001200, "Member 'AKnightGuard::_attackComponent' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _attackableComponent) == 0x001208, "Member 'AKnightGuard::_attackableComponent' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _attackableCapsule) == 0x001210, "Member 'AKnightGuard::_attackableCapsule' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _huntComponentClass) == 0x001218, "Member 'AKnightGuard::_huntComponentClass' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _huntComponent) == 0x001220, "Member 'AKnightGuard::_huntComponent' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _patrolComponentClass) == 0x001228, "Member 'AKnightGuard::_patrolComponentClass' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _patrolComponent) == 0x001230, "Member 'AKnightGuard::_patrolComponent' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _controllerClass) == 0x001238, "Member 'AKnightGuard::_controllerClass' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _animationFollower) == 0x001240, "Member 'AKnightGuard::_animationFollower' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _gravityScale) == 0x001248, "Member 'AKnightGuard::_gravityScale' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _patrolMovementSpeed) == 0x001270, "Member 'AKnightGuard::_patrolMovementSpeed' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _patrolStartupDelay) == 0x0012F0, "Member 'AKnightGuard::_patrolStartupDelay' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _patrolDuration) == 0x001318, "Member 'AKnightGuard::_patrolDuration' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _huntMovementSpeed) == 0x001398, "Member 'AKnightGuard::_huntMovementSpeed' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _huntDuration) == 0x0013C0, "Member 'AKnightGuard::_huntDuration' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _orderDuration) == 0x001440, "Member 'AKnightGuard::_orderDuration' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _flagActivationTime) == 0x0014C0, "Member 'AKnightGuard::_flagActivationTime' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _shouldInflictBleed) == 0x0014E8, "Member 'AKnightGuard::_shouldInflictBleed' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _spawningVisionRange) == 0x001510, "Member 'AKnightGuard::_spawningVisionRange' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _patrollingVisionRange) == 0x001538, "Member 'AKnightGuard::_patrollingVisionRange' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _palletAndVaultsSlowedDownSpeed) == 0x0015B8, "Member 'AKnightGuard::_palletAndVaultsSlowedDownSpeed' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _palletAndVaultsSlowDownDuration) == 0x0015E0, "Member 'AKnightGuard::_palletAndVaultsSlowDownDuration' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _immediateGeneratorRegressionPercent) == 0x001608, "Member 'AKnightGuard::_immediateGeneratorRegressionPercent' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _huntAuraVisibilityMinDistanceToKiller) == 0x001630, "Member 'AKnightGuard::_huntAuraVisibilityMinDistanceToKiller' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _guardHitSurvivorScoreEvent) == 0x001658, "Member 'AKnightGuard::_guardHitSurvivorScoreEvent' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _guardDetectSurvivorScoreEvent) == 0x001664, "Member 'AKnightGuard::_guardDetectSurvivorScoreEvent' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _guardBreakInteractableEvent) == 0x001670, "Member 'AKnightGuard::_guardBreakInteractableEvent' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _guardChaseEndedEvent) == 0x00167C, "Member 'AKnightGuard::_guardChaseEndedEvent' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _guardAnimTag) == 0x00168C, "Member 'AKnightGuard::_guardAnimTag' has a wrong offset!");
static_assert(offsetof(AKnightGuard, _overlappingSurvivorsAndVaults) == 0x0016F8, "Member 'AKnightGuard::_overlappingSurvivorsAndVaults' has a wrong offset!");

// Class TheK30.GuardAnimInstance
// 0x0020 (0x0560 - 0x0540)
class UGuardAnimInstance final : public UPlayerAnimInstance
{
public:
	class AKnightGuard*                           _owningGuard;                                      // 0x0540(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _forwardVelocity;                                  // 0x0548(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lateralVelocity;                                  // 0x054C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animSpeed;                                        // 0x0550(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animDirection;                                    // 0x0554(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActive;                                         // 0x0558(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPatrolling;                                     // 0x0559(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPatrollingForward;                              // 0x055A(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHunting;                                        // 0x055B(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isTeleporting;                                    // 0x055C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55D[0x3];                                      // 0x055D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuardAnimInstance">();
	}
	static class UGuardAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGuardAnimInstance>();
	}
};
static_assert(alignof(UGuardAnimInstance) == 0x000010, "Wrong alignment on UGuardAnimInstance");
static_assert(sizeof(UGuardAnimInstance) == 0x000560, "Wrong size on UGuardAnimInstance");
static_assert(offsetof(UGuardAnimInstance, _owningGuard) == 0x000540, "Member 'UGuardAnimInstance::_owningGuard' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _forwardVelocity) == 0x000548, "Member 'UGuardAnimInstance::_forwardVelocity' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _lateralVelocity) == 0x00054C, "Member 'UGuardAnimInstance::_lateralVelocity' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _animSpeed) == 0x000550, "Member 'UGuardAnimInstance::_animSpeed' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _animDirection) == 0x000554, "Member 'UGuardAnimInstance::_animDirection' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _isActive) == 0x000558, "Member 'UGuardAnimInstance::_isActive' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _isPatrolling) == 0x000559, "Member 'UGuardAnimInstance::_isPatrolling' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _isPatrollingForward) == 0x00055A, "Member 'UGuardAnimInstance::_isPatrollingForward' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _isHunting) == 0x00055B, "Member 'UGuardAnimInstance::_isHunting' has a wrong offset!");
static_assert(offsetof(UGuardAnimInstance, _isTeleporting) == 0x00055C, "Member 'UGuardAnimInstance::_isTeleporting' has a wrong offset!");

// Class TheK30.KnightGuardStateMachine
// 0x0000 (0x0130 - 0x0130)
class UKnightGuardStateMachine final : public UPlayerStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnightGuardStateMachine">();
	}
	static class UKnightGuardStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKnightGuardStateMachine>();
	}
};
static_assert(alignof(UKnightGuardStateMachine) == 0x000010, "Wrong alignment on UKnightGuardStateMachine");
static_assert(sizeof(UKnightGuardStateMachine) == 0x000130, "Wrong size on UKnightGuardStateMachine");

// Class TheK30.KnightHuskStunnableComponent
// 0x0008 (0x00C0 - 0x00B8)
class UKnightHuskStunnableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnightHuskStunnableComponent">();
	}
	static class UKnightHuskStunnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKnightHuskStunnableComponent>();
	}
};
static_assert(alignof(UKnightHuskStunnableComponent) == 0x000008, "Wrong alignment on UKnightHuskStunnableComponent");
static_assert(sizeof(UKnightHuskStunnableComponent) == 0x0000C0, "Wrong size on UKnightHuskStunnableComponent");

// Class TheK30.KnightOrderComponent
// 0x0138 (0x01F0 - 0x00B8)
class UKnightOrderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AInteractable*>                  _possiblyTargetableObjects;                        // 0x00C8(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AInteractable*>                  _targetableObjects;                                // 0x00D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _targetedColor;                                    // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _showTargetableAura;                               // 0x00F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _targetableColor;                                  // 0x00FC(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _showTargetableVFXWhilePowerIsReady;               // 0x010C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AInteractable*                          _currentTarget;                                    // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AInteractable*                          _orderTarget;                                      // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDefinition*                 _bestInteraction;                                  // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDefinition*                 _currentInteraction;                               // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AKnightGuard*                           _guardWaitingForInteraction;                       // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x38];                                     // 0x0138(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _targetingRange;                                   // 0x0170(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _palletOrderClass;                                 // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _killerBreakPalletClass;                           // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _generatorOrderClass;                              // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _killerBreakGeneratorClass;                        // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _breakableOrderClass;                              // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _killerBreakBreakableClass;                        // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _updateRate;                                       // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxTargetingAngle;                                // 0x01CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _downRaycastLength;                                // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D4[0x1C];                                     // 0x01D4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnNewTargetSelected(class AInteractable* newTarget, class AInteractable* oldTarget);
	void Cosmetic_OnTargetableObjectsChanged(class AInteractable* object, bool isTargetable);
	void OnCurrentInteractionFinished();
	void OnGameEventDispatched(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnightOrderComponent">();
	}
	static class UKnightOrderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKnightOrderComponent>();
	}
};
static_assert(alignof(UKnightOrderComponent) == 0x000008, "Wrong alignment on UKnightOrderComponent");
static_assert(sizeof(UKnightOrderComponent) == 0x0001F0, "Wrong size on UKnightOrderComponent");
static_assert(offsetof(UKnightOrderComponent, _possiblyTargetableObjects) == 0x0000C8, "Member 'UKnightOrderComponent::_possiblyTargetableObjects' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _targetableObjects) == 0x0000D8, "Member 'UKnightOrderComponent::_targetableObjects' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _targetedColor) == 0x0000E8, "Member 'UKnightOrderComponent::_targetedColor' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _showTargetableAura) == 0x0000F8, "Member 'UKnightOrderComponent::_showTargetableAura' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _targetableColor) == 0x0000FC, "Member 'UKnightOrderComponent::_targetableColor' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _showTargetableVFXWhilePowerIsReady) == 0x00010C, "Member 'UKnightOrderComponent::_showTargetableVFXWhilePowerIsReady' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _currentTarget) == 0x000110, "Member 'UKnightOrderComponent::_currentTarget' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _orderTarget) == 0x000118, "Member 'UKnightOrderComponent::_orderTarget' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _bestInteraction) == 0x000120, "Member 'UKnightOrderComponent::_bestInteraction' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _currentInteraction) == 0x000128, "Member 'UKnightOrderComponent::_currentInteraction' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _guardWaitingForInteraction) == 0x000130, "Member 'UKnightOrderComponent::_guardWaitingForInteraction' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _targetingRange) == 0x000170, "Member 'UKnightOrderComponent::_targetingRange' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _palletOrderClass) == 0x000198, "Member 'UKnightOrderComponent::_palletOrderClass' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _killerBreakPalletClass) == 0x0001A0, "Member 'UKnightOrderComponent::_killerBreakPalletClass' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _generatorOrderClass) == 0x0001A8, "Member 'UKnightOrderComponent::_generatorOrderClass' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _killerBreakGeneratorClass) == 0x0001B0, "Member 'UKnightOrderComponent::_killerBreakGeneratorClass' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _breakableOrderClass) == 0x0001B8, "Member 'UKnightOrderComponent::_breakableOrderClass' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _killerBreakBreakableClass) == 0x0001C0, "Member 'UKnightOrderComponent::_killerBreakBreakableClass' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _updateRate) == 0x0001C8, "Member 'UKnightOrderComponent::_updateRate' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _maxTargetingAngle) == 0x0001CC, "Member 'UKnightOrderComponent::_maxTargetingAngle' has a wrong offset!");
static_assert(offsetof(UKnightOrderComponent, _downRaycastLength) == 0x0001D0, "Member 'UKnightOrderComponent::_downRaycastLength' has a wrong offset!");

// Class TheK30.NavigationQueryFilter_Guard
// 0x0000 (0x0070 - 0x0070)
class UNavigationQueryFilter_Guard final : public UNavigationQueryFilter_Player
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_Guard">();
	}
	static class UNavigationQueryFilter_Guard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_Guard>();
	}
};
static_assert(alignof(UNavigationQueryFilter_Guard) == 0x000008, "Wrong alignment on UNavigationQueryFilter_Guard");
static_assert(sizeof(UNavigationQueryFilter_Guard) == 0x000070, "Wrong size on UNavigationQueryFilter_Guard");

// Class TheK30.NearUndestroyedPallet
// 0x0058 (0x0148 - 0x00F0)
class UNearUndestroyedPallet : public URangeBasedCondition
{
public:
	uint8                                         Pad_F0[0x58];                                      // 0x00F0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NearUndestroyedPallet">();
	}
	static class UNearUndestroyedPallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNearUndestroyedPallet>();
	}
};
static_assert(alignof(UNearUndestroyedPallet) == 0x000008, "Wrong alignment on UNearUndestroyedPallet");
static_assert(sizeof(UNearUndestroyedPallet) == 0x000148, "Wrong size on UNearUndestroyedPallet");

// Class TheK30.NearFallenPallet
// 0x0000 (0x0148 - 0x0148)
class UNearFallenPallet final : public UNearUndestroyedPallet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NearFallenPallet">();
	}
	static class UNearFallenPallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNearFallenPallet>();
	}
};
static_assert(alignof(UNearFallenPallet) == 0x000008, "Wrong alignment on UNearFallenPallet");
static_assert(sizeof(UNearFallenPallet) == 0x000148, "Wrong size on UNearFallenPallet");

// Class TheK30.PatrolTrailComponent
// 0x00E8 (0x01A0 - 0x00B8)
class UPatrolTrailComponent final : public UActorComponent
{
public:
	struct FTrailData                             _trail;                                            // 0x00B8(0x0030)(Net, NativeAccessSpecifierPrivate)
	struct FTrailSettings                         _trailSettings;                                    // 0x00E8(0x0068)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x10];                                     // 0x0150(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         clearPathNodeDelay;                                // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_164[0x3C];                                     // 0x0164(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_StartRecordingTrail();
	void Authority_StopRecordingTrail();

	bool DoesTrailExist() const;
	float GetCurrentTrailLength() const;
	class ATrailNode* GetFirstNode() const;
	class ATrailNode* GetLastNode() const;
	struct FVector GetLastPosition() const;
	class ATrailNode* GetNextNode(class ATrailNode* currentNode) const;
	class ATrailNode* GetPreviousNode(class ATrailNode* currentNode) const;
	bool IsTrailCompleted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PatrolTrailComponent">();
	}
	static class UPatrolTrailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPatrolTrailComponent>();
	}
};
static_assert(alignof(UPatrolTrailComponent) == 0x000008, "Wrong alignment on UPatrolTrailComponent");
static_assert(sizeof(UPatrolTrailComponent) == 0x0001A0, "Wrong size on UPatrolTrailComponent");
static_assert(offsetof(UPatrolTrailComponent, _trail) == 0x0000B8, "Member 'UPatrolTrailComponent::_trail' has a wrong offset!");
static_assert(offsetof(UPatrolTrailComponent, _trailSettings) == 0x0000E8, "Member 'UPatrolTrailComponent::_trailSettings' has a wrong offset!");
static_assert(offsetof(UPatrolTrailComponent, clearPathNodeDelay) == 0x000160, "Member 'UPatrolTrailComponent::clearPathNodeDelay' has a wrong offset!");

// Class TheK30.S34P01
// 0x0140 (0x0508 - 0x03C8)
class US34P01 final : public UPerk
{
public:
	class UChargeStrategy*                        _chargeStrategyWhenActive;                         // 0x03C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableInteractionDefinition*       _redirectedInteraction;                            // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSecondaryInteractionProperties        _startAccumulateSecondaryActionProperties;         // 0x03D8(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSecondaryInteractionProperties        _useTokensSecondaryActionProperties;               // 0x0410(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_448[0x30];                                     // 0x0448(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isPerkActive;                                     // 0x0478(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_479[0x7];                                      // 0x0479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isAccumulatingTokens;                             // 0x0480(0x0030)(Net, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x4];                                      // 0x04B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _initialCountdownTime[0x3];                        // 0x04B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _accumulatedPercentMultiplier;                     // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C4[0x44];                                     // 0x04C4(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnAccumulateRedirectedCharge(const float chargeAmount, const float maxCharge);
	void Authority_OnSkillCheckResponse(bool success, bool bonus, class ADBDPlayer* player, bool triggerLoudNoise, bool hadInput, ESkillCheckCustomType type, float chargeChange);
	void Cosmetic_OnFullCharge(class ADBDPlayer* owningPlayer);
	void Cosmetic_OnStartChargingPerk(class ADBDPlayer* owningPlayer);
	void Cosmetic_OnStopChargingPerk(class ADBDPlayer* owningPlayer);
	void Cosmetic_OnUseCharge(class ADBDPlayer* owningPlayer);
	void Multicast_OnUseTokens();
	void OnDamageStateChanged(ECamperDamageState oldDamageState, ECamperDamageState currentDamageState);
	void OnRep_IsAccumulatingTokens();
	void OnRep_IsPerkActive();
	void Server_AbilityTwoPressed(bool isPressed);

	float GetInitialCountdownAtLevel() const;
	bool IsPerkActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S34P01">();
	}
	static class US34P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<US34P01>();
	}
};
static_assert(alignof(US34P01) == 0x000008, "Wrong alignment on US34P01");
static_assert(sizeof(US34P01) == 0x000508, "Wrong size on US34P01");
static_assert(offsetof(US34P01, _chargeStrategyWhenActive) == 0x0003C8, "Member 'US34P01::_chargeStrategyWhenActive' has a wrong offset!");
static_assert(offsetof(US34P01, _redirectedInteraction) == 0x0003D0, "Member 'US34P01::_redirectedInteraction' has a wrong offset!");
static_assert(offsetof(US34P01, _startAccumulateSecondaryActionProperties) == 0x0003D8, "Member 'US34P01::_startAccumulateSecondaryActionProperties' has a wrong offset!");
static_assert(offsetof(US34P01, _useTokensSecondaryActionProperties) == 0x000410, "Member 'US34P01::_useTokensSecondaryActionProperties' has a wrong offset!");
static_assert(offsetof(US34P01, _isPerkActive) == 0x000478, "Member 'US34P01::_isPerkActive' has a wrong offset!");
static_assert(offsetof(US34P01, _isAccumulatingTokens) == 0x000480, "Member 'US34P01::_isAccumulatingTokens' has a wrong offset!");
static_assert(offsetof(US34P01, _initialCountdownTime) == 0x0004B4, "Member 'US34P01::_initialCountdownTime' has a wrong offset!");
static_assert(offsetof(US34P01, _accumulatedPercentMultiplier) == 0x0004C0, "Member 'US34P01::_accumulatedPercentMultiplier' has a wrong offset!");

// Class TheK30.S34P02
// 0x0008 (0x03D0 - 0x03C8)
class US34P02 final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _revealKillerStatusClass;                          // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S34P02">();
	}
	static class US34P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<US34P02>();
	}
};
static_assert(alignof(US34P02) == 0x000008, "Wrong alignment on US34P02");
static_assert(sizeof(US34P02) == 0x0003D0, "Wrong size on US34P02");
static_assert(offsetof(US34P02, _revealKillerStatusClass) == 0x0003C8, "Member 'US34P02::_revealKillerStatusClass' has a wrong offset!");

// Class TheK30.S34P03
// 0x00D0 (0x0498 - 0x03C8)
class US34P03 final : public UPerk
{
public:
	TArray<class AGenerator*>                     _generatorsInRange;                                // 0x03C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class ADBDPlayer*, class UStatusEffect*> _activeStatusEffects;                              // 0x03D8(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x50];                                     // 0x0428(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _generatorRangeFromPlayer;                         // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _repairSpeedModifierClass;                         // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _repairSpeedValues[0x3];                           // 0x0488(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetGeneratorRangeFromPlayer() const;
	float GetRepairSpeedAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S34P03">();
	}
	static class US34P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<US34P03>();
	}
};
static_assert(alignof(US34P03) == 0x000008, "Wrong alignment on US34P03");
static_assert(sizeof(US34P03) == 0x000498, "Wrong size on US34P03");
static_assert(offsetof(US34P03, _generatorsInRange) == 0x0003C8, "Member 'US34P03::_generatorsInRange' has a wrong offset!");
static_assert(offsetof(US34P03, _activeStatusEffects) == 0x0003D8, "Member 'US34P03::_activeStatusEffects' has a wrong offset!");
static_assert(offsetof(US34P03, _generatorRangeFromPlayer) == 0x000478, "Member 'US34P03::_generatorRangeFromPlayer' has a wrong offset!");
static_assert(offsetof(US34P03, _repairSpeedModifierClass) == 0x000480, "Member 'US34P03::_repairSpeedModifierClass' has a wrong offset!");
static_assert(offsetof(US34P03, _repairSpeedValues) == 0x000488, "Member 'US34P03::_repairSpeedValues' has a wrong offset!");

// Class TheK30.TrailNode
// 0x0010 (0x0240 - 0x0230)
class ATrailNode final : public AActor
{
public:
	struct FVector                                PreviousNodePosition;                              // 0x0230(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_UpdateTrail();
	void Cosmetic_PrepareForRemoval();
	void OnRep_PreviousNodePosition();

	bool IsFirstNode() const;
	bool IsOwnerLocallyObserved() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrailNode">();
	}
	static class ATrailNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrailNode>();
	}
};
static_assert(alignof(ATrailNode) == 0x000008, "Wrong alignment on ATrailNode");
static_assert(sizeof(ATrailNode) == 0x000240, "Wrong size on ATrailNode");
static_assert(offsetof(ATrailNode, PreviousNodePosition) == 0x000230, "Member 'ATrailNode::PreviousNodePosition' has a wrong offset!");

}

