#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Projectile

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "Projectile_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class Projectile.DBDProjectileMovementComponent
// 0x0080 (0x0260 - 0x01E0)
class UDBDProjectileMovementComponent : public UProjectileMovementComponent
{
public:
	uint8                                         Pad_1E0[0x18];                                     // 0x01E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UPrimitiveComponent* primitiveComponent, const struct FHitResult& hitResult)> OnComponentToSweepCollisionBP; // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x18];                                     // 0x0208(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FComponentSweepInfo>            _componentsToSweep;                                // 0x0220(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FVector                                _previousPosition;                                 // 0x0230(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _cachedUpdatedComponent;                           // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _initialLocation;                                  // 0x0248(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _distanceTravelled;                                // 0x0254(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasMaximumDistance;                               // 0x0258(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maximumTravelDistance;                            // 0x025C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddComponentToSweep(class UPrimitiveComponent* component);

	const struct FVector GetPreviousLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDProjectileMovementComponent">();
	}
	static class UDBDProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDProjectileMovementComponent>();
	}
};
static_assert(alignof(UDBDProjectileMovementComponent) == 0x000010, "Wrong alignment on UDBDProjectileMovementComponent");
static_assert(sizeof(UDBDProjectileMovementComponent) == 0x000260, "Wrong size on UDBDProjectileMovementComponent");
static_assert(offsetof(UDBDProjectileMovementComponent, OnComponentToSweepCollisionBP) == 0x0001F8, "Member 'UDBDProjectileMovementComponent::OnComponentToSweepCollisionBP' has a wrong offset!");
static_assert(offsetof(UDBDProjectileMovementComponent, _componentsToSweep) == 0x000220, "Member 'UDBDProjectileMovementComponent::_componentsToSweep' has a wrong offset!");
static_assert(offsetof(UDBDProjectileMovementComponent, _previousPosition) == 0x000230, "Member 'UDBDProjectileMovementComponent::_previousPosition' has a wrong offset!");
static_assert(offsetof(UDBDProjectileMovementComponent, _cachedUpdatedComponent) == 0x000240, "Member 'UDBDProjectileMovementComponent::_cachedUpdatedComponent' has a wrong offset!");
static_assert(offsetof(UDBDProjectileMovementComponent, _initialLocation) == 0x000248, "Member 'UDBDProjectileMovementComponent::_initialLocation' has a wrong offset!");
static_assert(offsetof(UDBDProjectileMovementComponent, _distanceTravelled) == 0x000254, "Member 'UDBDProjectileMovementComponent::_distanceTravelled' has a wrong offset!");
static_assert(offsetof(UDBDProjectileMovementComponent, _hasMaximumDistance) == 0x000258, "Member 'UDBDProjectileMovementComponent::_hasMaximumDistance' has a wrong offset!");
static_assert(offsetof(UDBDProjectileMovementComponent, _maximumTravelDistance) == 0x00025C, "Member 'UDBDProjectileMovementComponent::_maximumTravelDistance' has a wrong offset!");

// Class Projectile.PhysicsBasedProjectileMovementComponent
// 0x0000 (0x0260 - 0x0260)
class UPhysicsBasedProjectileMovementComponent : public UDBDProjectileMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsBasedProjectileMovementComponent">();
	}
	static class UPhysicsBasedProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPhysicsBasedProjectileMovementComponent>();
	}
};
static_assert(alignof(UPhysicsBasedProjectileMovementComponent) == 0x000010, "Wrong alignment on UPhysicsBasedProjectileMovementComponent");
static_assert(sizeof(UPhysicsBasedProjectileMovementComponent) == 0x000260, "Wrong size on UPhysicsBasedProjectileMovementComponent");

// Class Projectile.BaseProjectile
// 0x0080 (0x02B0 - 0x0230)
class ABaseProjectile : public AActor
{
public:
	float                                         OnImpactAINoiseEventRange;                         // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x44];                                     // 0x0234(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _multicastLaunch;                                  // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _allowMultipleHits;                                // 0x0279(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27A[0x6];                                      // 0x027A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _semanticGameplayTags;                             // 0x0280(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          _notifyClientOfServerHitValidationResult;          // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseProjectileReplicationComponent*    _replicationComponent;                             // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool Authority_TryDetectCollision(const struct FImpactInfo& impactInfo, bool force);
	bool IsValidImpactDetection(const struct FImpactInfo& impactInfo);
	bool IsValidPlayerDetection(const struct FImpactInfo& impactInfo);
	bool Local_OnPlayerDetected(const struct FImpactInfo& impactInfo, const struct FVector& projectileLocation);
	bool Local_SweepImpactCollision(const struct FVector& start, const struct FVector& end, const struct FRotator& colliderRotation, struct FHitResult* outHit);
	bool Local_TryDetectCollision(const struct FImpactInfo& impactInfo, bool force);
	void OnDetectCollision(const struct FImpactInfo& impactInfo);
	void OnDetectPlayer(const struct FImpactInfo& impactInfo);
	void OnLaunch(const struct FLaunchInfo& launchInfo, bool hasImpactOnLaunch);
	void OnSetActive(const bool active);

	float GetAddLauncherVeloctyFactor() const;
	class UPrimitiveComponent* GetImpactPrimitiveComponent() const;
	class UBaseProjectileLauncher* GetLauncher() const;
	bool IsOwningPawnLocallyControlled() const;
	bool SphereTraceSingle(const struct FVector& start, const struct FVector& end, class USphereComponent* sphere, struct FHitResult* outHitResult) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseProjectile">();
	}
	static class ABaseProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseProjectile>();
	}
};
static_assert(alignof(ABaseProjectile) == 0x000008, "Wrong alignment on ABaseProjectile");
static_assert(sizeof(ABaseProjectile) == 0x0002B0, "Wrong size on ABaseProjectile");
static_assert(offsetof(ABaseProjectile, OnImpactAINoiseEventRange) == 0x000230, "Member 'ABaseProjectile::OnImpactAINoiseEventRange' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, _multicastLaunch) == 0x000278, "Member 'ABaseProjectile::_multicastLaunch' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, _allowMultipleHits) == 0x000279, "Member 'ABaseProjectile::_allowMultipleHits' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, _semanticGameplayTags) == 0x000280, "Member 'ABaseProjectile::_semanticGameplayTags' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, _notifyClientOfServerHitValidationResult) == 0x0002A0, "Member 'ABaseProjectile::_notifyClientOfServerHitValidationResult' has a wrong offset!");
static_assert(offsetof(ABaseProjectile, _replicationComponent) == 0x0002A8, "Member 'ABaseProjectile::_replicationComponent' has a wrong offset!");

// Class Projectile.SingleProjectileProviderComponent
// 0x0030 (0x00E8 - 0x00B8)
class USingleProjectileProviderComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseProjectile>            _projectileClass;                                  // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABaseProjectile*                        _projectile;                                       // 0x00C8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Projectile();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SingleProjectileProviderComponent">();
	}
	static class USingleProjectileProviderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USingleProjectileProviderComponent>();
	}
};
static_assert(alignof(USingleProjectileProviderComponent) == 0x000008, "Wrong alignment on USingleProjectileProviderComponent");
static_assert(sizeof(USingleProjectileProviderComponent) == 0x0000E8, "Wrong size on USingleProjectileProviderComponent");
static_assert(offsetof(USingleProjectileProviderComponent, _projectileClass) == 0x0000C0, "Member 'USingleProjectileProviderComponent::_projectileClass' has a wrong offset!");
static_assert(offsetof(USingleProjectileProviderComponent, _projectile) == 0x0000C8, "Member 'USingleProjectileProviderComponent::_projectile' has a wrong offset!");

// Class Projectile.BaseProjectileReplicationComponent
// 0x0000 (0x00B8 - 0x00B8)
class UBaseProjectileReplicationComponent : public UActorComponent
{
public:
	void Client_LaunchRefusedByServer(class ABaseProjectile* projectile);
	void Client_ReceiveDetectPlayerValidation(class ABaseProjectile* projectile, bool success);
	void Multicast_DetectImpact(class ABaseProjectile* projectile, const struct FImpactInfo& impactInfo);
	void Multicast_DetectPlayer(class ABaseProjectile* projectile, const struct FImpactInfo& impactInfo);
	void Multicast_OnLaunch(class ABaseProjectile* projectile, const struct FLaunchInfo& launchInfo);
	void Multicast_OnLaunchWithImpact(class ABaseProjectile* projectile, const struct FLaunchInfo& launchInfo, const struct FImpactInfo& impactInfo);
	void Multicast_SendAuthorityDetectPlayer(class ABaseProjectile* projectile, const struct FImpactInfo& impactInfo);
	void Server_TryDetectPlayer(class ABaseProjectile* projectile, const struct FImpactInfo& impactInfo, const struct FVector_NetQuantize100& projectileLocation, const struct FVector_NetQuantize10& projectileRotation, const float targetLocationTimestamp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseProjectileReplicationComponent">();
	}
	static class UBaseProjectileReplicationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseProjectileReplicationComponent>();
	}
};
static_assert(alignof(UBaseProjectileReplicationComponent) == 0x000008, "Wrong alignment on UBaseProjectileReplicationComponent");
static_assert(sizeof(UBaseProjectileReplicationComponent) == 0x0000B8, "Wrong size on UBaseProjectileReplicationComponent");

// Class Projectile.PhysicsBasedProjectile
// 0x0008 (0x02B8 - 0x02B0)
class APhysicsBasedProjectile : public ABaseProjectile
{
public:
	class UPhysicsBasedProjectileMovementComponent* Movement;                                        // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhysicsBasedProjectile">();
	}
	static class APhysicsBasedProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<APhysicsBasedProjectile>();
	}
};
static_assert(alignof(APhysicsBasedProjectile) == 0x000008, "Wrong alignment on APhysicsBasedProjectile");
static_assert(sizeof(APhysicsBasedProjectile) == 0x0002B8, "Wrong size on APhysicsBasedProjectile");
static_assert(offsetof(APhysicsBasedProjectile, Movement) == 0x0002B0, "Member 'APhysicsBasedProjectile::Movement' has a wrong offset!");

// Class Projectile.BaseProjectileLauncher
// 0x00C8 (0x0180 - 0x00B8)
class UBaseProjectileLauncher : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _requireLaunchImpactDetection;                     // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasInfiniteAmmunition;                            // 0x00E9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EA[0x6];                                       // 0x00EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABaseProjectile>            ProjectileClass;                                   // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _ammo;                                             // 0x00F8(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxAmmo;                                          // 0x00FC(0x0004)(Edit, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canLaunchWhileOutOfAmmo;                          // 0x0100(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x2F];                                     // 0x0101(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseProjectile*                        _debugProjectile;                                  // 0x0130(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x40];                                     // 0x0138(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseProjectileReplicationComponent*    _projectileReplicationComponent;                   // 0x0178(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_AddMaxAmmo(int32 ammoToAdd);
	void Authority_Launch();
	void Authority_Reload();
	void Authority_ReturnAmmoUnits(int32 amountOfAmmoUnitsReturned);
	void Authority_SetMaxAmmo(int32 newMaxAmmo, bool isMaxAmmoImmutable);
	void Cosmetic_OnOutOfAmmo();
	void Local_Launch();
	void OnLaunch(const struct FLaunchInfo& launchInfo, class ABaseProjectile* projectile);
	void OnRep_Ammo(int32 oldAmmo);
	void OnRep_MaxAmmo(int32 oldMaxAmmo);
	void Server_Launch(const struct FLaunchInfo& launchInfo, class ABaseProjectile* projectile);
	void Server_LaunchWithImpact(const struct FLaunchInfo& launchInfo, const struct FImpactInfo& impactInfo, class ABaseProjectile* projectile);
	void SetProjectileProvider(TScriptInterface<class IProjectileProvider> projectileProvider);
	void SetProjectileVar(class FName varName, float value);

	int32 GetAmmo() const;
	struct FVector GetLaunchDirection() const;
	struct FVector GetLaunchDirectionAtViewAndThrowPowerRatio(const struct FRotator& viewRotation, float throwPowerRatio) const;
	struct FVector GetLaunchPosition() const;
	float GetLaunchSpeed() const;
	float GetLaunchSpeedAtThrowPowerRatio(float throwPowerRatio) const;
	class APawn* GetOwningPawn() const;
	class ABaseProjectile* GetProjectileToLaunch() const;
	bool HasAuthority() const;
	bool HasProjectile() const;
	bool IsAmmoFull() const;
	bool IsLocallyControlled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseProjectileLauncher">();
	}
	static class UBaseProjectileLauncher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseProjectileLauncher>();
	}
};
static_assert(alignof(UBaseProjectileLauncher) == 0x000008, "Wrong alignment on UBaseProjectileLauncher");
static_assert(sizeof(UBaseProjectileLauncher) == 0x000180, "Wrong size on UBaseProjectileLauncher");
static_assert(offsetof(UBaseProjectileLauncher, _requireLaunchImpactDetection) == 0x0000E8, "Member 'UBaseProjectileLauncher::_requireLaunchImpactDetection' has a wrong offset!");
static_assert(offsetof(UBaseProjectileLauncher, _hasInfiniteAmmunition) == 0x0000E9, "Member 'UBaseProjectileLauncher::_hasInfiniteAmmunition' has a wrong offset!");
static_assert(offsetof(UBaseProjectileLauncher, ProjectileClass) == 0x0000F0, "Member 'UBaseProjectileLauncher::ProjectileClass' has a wrong offset!");
static_assert(offsetof(UBaseProjectileLauncher, _ammo) == 0x0000F8, "Member 'UBaseProjectileLauncher::_ammo' has a wrong offset!");
static_assert(offsetof(UBaseProjectileLauncher, _maxAmmo) == 0x0000FC, "Member 'UBaseProjectileLauncher::_maxAmmo' has a wrong offset!");
static_assert(offsetof(UBaseProjectileLauncher, _canLaunchWhileOutOfAmmo) == 0x000100, "Member 'UBaseProjectileLauncher::_canLaunchWhileOutOfAmmo' has a wrong offset!");
static_assert(offsetof(UBaseProjectileLauncher, _debugProjectile) == 0x000130, "Member 'UBaseProjectileLauncher::_debugProjectile' has a wrong offset!");
static_assert(offsetof(UBaseProjectileLauncher, _projectileReplicationComponent) == 0x000178, "Member 'UBaseProjectileLauncher::_projectileReplicationComponent' has a wrong offset!");

// Class Projectile.AuthoritativePoolProjectileProviderAdapter
// 0x0010 (0x0040 - 0x0030)
class UAuthoritativePoolProjectileProviderAdapter final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAuthoritativeActorPoolComponent*       _pool;                                             // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Init(class UAuthoritativeActorPoolComponent* pool);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthoritativePoolProjectileProviderAdapter">();
	}
	static class UAuthoritativePoolProjectileProviderAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthoritativePoolProjectileProviderAdapter>();
	}
};
static_assert(alignof(UAuthoritativePoolProjectileProviderAdapter) == 0x000008, "Wrong alignment on UAuthoritativePoolProjectileProviderAdapter");
static_assert(sizeof(UAuthoritativePoolProjectileProviderAdapter) == 0x000040, "Wrong size on UAuthoritativePoolProjectileProviderAdapter");
static_assert(offsetof(UAuthoritativePoolProjectileProviderAdapter, _pool) == 0x000038, "Member 'UAuthoritativePoolProjectileProviderAdapter::_pool' has a wrong offset!");

// Class Projectile.ProjectileProvider
// 0x0000 (0x0000 - 0x0000)
class IProjectileProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileProvider">();
	}
	static class IProjectileProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProjectileProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IProjectileProvider) == 0x000001, "Wrong alignment on IProjectileProvider");
static_assert(sizeof(IProjectileProvider) == 0x000001, "Wrong size on IProjectileProvider");

}

