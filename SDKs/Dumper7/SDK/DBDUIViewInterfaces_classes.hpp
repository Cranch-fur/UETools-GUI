#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDUIViewInterfaces

#include "Basic.hpp"

#include "DBDUIViewInterfaces_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class DBDUIViewInterfaces.AddonViewInterface
// 0x0000 (0x0000 - 0x0000)
class IAddonViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FAddonViewData& baseLoadoutPartViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AddonViewInterface">();
	}
	static class IAddonViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAddonViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAddonViewInterface) == 0x000001, "Wrong alignment on IAddonViewInterface");
static_assert(sizeof(IAddonViewInterface) == 0x000001, "Wrong size on IAddonViewInterface");

// Class DBDUIViewInterfaces.ArchiveCompendiumViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveCompendiumViewInterface final
{
public:
	void SetPastTomesViewData(const TArray<struct FCompendiumButtonData>& pastStoryButtonData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveCompendiumViewInterface">();
	}
	static class IArchiveCompendiumViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveCompendiumViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveCompendiumViewInterface) == 0x000001, "Wrong alignment on IArchiveCompendiumViewInterface");
static_assert(sizeof(IArchiveCompendiumViewInterface) == 0x000001, "Wrong size on IArchiveCompendiumViewInterface");

// Class DBDUIViewInterfaces.ArchiveEditorViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveEditorViewInterface final
{
public:
	void DisplayEditorSaving(const class FString& path);
	void InitEditor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveEditorViewInterface">();
	}
	static class IArchiveEditorViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveEditorViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveEditorViewInterface) == 0x000001, "Wrong alignment on IArchiveEditorViewInterface");
static_assert(sizeof(IArchiveEditorViewInterface) == 0x000001, "Wrong size on IArchiveEditorViewInterface");

// Class DBDUIViewInterfaces.ArchiveImageViewerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveImageViewerViewInterface final
{
public:
	void SetTextVisibility(bool visible);
	void SetVoiceOverAutoplay(bool voiceOverAutoplay);
	void SetVoiceOverPlaying(bool voiceOverPlaying);
	void UpdateContent(const struct FArchivesVignetteEntryViewData& data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveImageViewerViewInterface">();
	}
	static class IArchiveImageViewerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveImageViewerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveImageViewerViewInterface) == 0x000001, "Wrong alignment on IArchiveImageViewerViewInterface");
static_assert(sizeof(IArchiveImageViewerViewInterface) == 0x000001, "Wrong size on IArchiveImageViewerViewInterface");

// Class DBDUIViewInterfaces.ArchiveJournalViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveJournalViewInterface final
{
public:
	void OnImageViewerVoiceOverAutoplay(bool autoplay);
	void OnImageViewerVoiceOverPlayed();
	void SetCinematicButtonsEnabled(bool enabled);
	void SetEntryData(const struct FArchivesVignetteEntryViewData& entryViewData);
	void SetVignetteData(const struct FArchivesVignetteViewData& vignetteViewData);
	void SetVignetteInputsEnabled(bool enabled);
	void SetVignetteList(const TArray<struct FArchivesVignetteViewData>& vignetteDataList);
	void SetVoiceOverAutoplay(bool voiceOverAutoplay);
	void SetVoiceOverPlaying(bool voiceOverPlaying);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveJournalViewInterface">();
	}
	static class IArchiveJournalViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveJournalViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveJournalViewInterface) == 0x000001, "Wrong alignment on IArchiveJournalViewInterface");
static_assert(sizeof(IArchiveJournalViewInterface) == 0x000001, "Wrong size on IArchiveJournalViewInterface");

// Class DBDUIViewInterfaces.ArchiveLevelProgressionViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveLevelProgressionViewInterface final
{
public:
	void GoToNextLevel(int32 levelIndex);
	void PlayRewardsAnimation();
	void SetActiveLevel(int32 levelIndex, bool performAction);
	void SetLevelSelectorEnabled(const bool enabled);
	void SetLevelSelectorVisibility(bool isVisible);
	void SetRewardsContainerVisibility(bool isVisible);
	void SetTomeLevelsData(const TArray<class UArchiveStoryLevelViewData*>& levelsData, int32 selectedLevel);
	void SetTomeRewardsData(const TArray<struct FRewardWrapperViewData>& rewardsData, bool areLocked);
	void UpdateLevelStatus(int32 level, EArchivesStoryLevelStatus status);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveLevelProgressionViewInterface">();
	}
	static class IArchiveLevelProgressionViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveLevelProgressionViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveLevelProgressionViewInterface) == 0x000001, "Wrong alignment on IArchiveLevelProgressionViewInterface");
static_assert(sizeof(IArchiveLevelProgressionViewInterface) == 0x000001, "Wrong size on IArchiveLevelProgressionViewInterface");

// Class DBDUIViewInterfaces.ArchiveStoryLevelViewData
// 0x0010 (0x0040 - 0x0030)
class UArchiveStoryLevelViewData final : public UObject
{
public:
	int32                                         Level;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArchivesStoryLevelStatus                     Status;                                            // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              StartDate;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveStoryLevelViewData">();
	}
	static class UArchiveStoryLevelViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchiveStoryLevelViewData>();
	}
};
static_assert(alignof(UArchiveStoryLevelViewData) == 0x000008, "Wrong alignment on UArchiveStoryLevelViewData");
static_assert(sizeof(UArchiveStoryLevelViewData) == 0x000040, "Wrong size on UArchiveStoryLevelViewData");
static_assert(offsetof(UArchiveStoryLevelViewData, Level) == 0x000030, "Member 'UArchiveStoryLevelViewData::Level' has a wrong offset!");
static_assert(offsetof(UArchiveStoryLevelViewData, Status) == 0x000034, "Member 'UArchiveStoryLevelViewData::Status' has a wrong offset!");
static_assert(offsetof(UArchiveStoryLevelViewData, StartDate) == 0x000038, "Member 'UArchiveStoryLevelViewData::StartDate' has a wrong offset!");

// Class DBDUIViewInterfaces.ArchiveMenuViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveMenuViewInterface final
{
public:
	void ClearChallengeReminderData(EPlayerRole role);
	void CloseSlotSelector();
	void HideUI();
	void Init();
	void SetChallengeReminderData(const struct FArchiveChallengeReminderViewData& data, EPlayerRole role, bool needsAnimation, const struct FVector2D& animationOriginalPosition);
	void SetChallengeReminderVisibility(bool isVisible);
	void SetControllerElementsEnabled(bool enabled);
	void SetEventLabel(const class FString& eventLabel);
	void SetInfoButtonEnabled(bool isEnabled);
	void SetInfoButtonVisible(bool isVisible);
	void SetMenuState(EArchiveMenuState menuState);
	void SetQuestNodeHoverEffect(EPlayerRole role, bool isHovered);
	void SetRemainingTime(const class FString& remainingTime, bool isMoreThanWarningThreshold, EArchiveMenuState menuState);
	void SetRemainingTimeVisible(bool isVisible);
	void SetReminderSlotsEnabled(bool enabled);
	void SetSubtitle(const class FText& subtitle);
	void SetSubtitleVisible(bool isVisible);
	void SetTabEnabled(int32 key, bool enabled);
	void SetTabsData(const TArray<struct FTabWidgetData>& tabsData, int32 selectedKey);
	void SetTabSelected(int32 key);
	void SetTabsInputsEnabled(bool enabled);
	void SetTitle(const class FText& title);
	void ShowSlotSelector(const struct FArchiveNodeViewData& data);
	void ShowUI();
	void UpdateBackgroundSkin(const int32 key, const struct FArchiveTomeSkinData& data);

	TScriptInterface<class IArchiveCompendiumViewInterface> GetArchiveCompendiumInterface() const;
	TScriptInterface<class IArchiveRiftViewInterface> GetArchiveRiftInterface() const;
	TScriptInterface<class IArchiveTomeViewInterface> GetArchiveTomeInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveMenuViewInterface">();
	}
	static class IArchiveMenuViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveMenuViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveMenuViewInterface) == 0x000001, "Wrong alignment on IArchiveMenuViewInterface");
static_assert(sizeof(IArchiveMenuViewInterface) == 0x000001, "Wrong size on IArchiveMenuViewInterface");

// Class DBDUIViewInterfaces.BasePopupViewData
// 0x0038 (0x0068 - 0x0030)
class UBasePopupViewData : public UObject
{
public:
	EPopupPriority                                Priority;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0038(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Message;                                           // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePopupViewData">();
	}
	static class UBasePopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePopupViewData>();
	}
};
static_assert(alignof(UBasePopupViewData) == 0x000008, "Wrong alignment on UBasePopupViewData");
static_assert(sizeof(UBasePopupViewData) == 0x000068, "Wrong size on UBasePopupViewData");
static_assert(offsetof(UBasePopupViewData, Priority) == 0x000030, "Member 'UBasePopupViewData::Priority' has a wrong offset!");
static_assert(offsetof(UBasePopupViewData, Title) == 0x000038, "Member 'UBasePopupViewData::Title' has a wrong offset!");
static_assert(offsetof(UBasePopupViewData, Message) == 0x000050, "Member 'UBasePopupViewData::Message' has a wrong offset!");

// Class DBDUIViewInterfaces.GenericPopupViewData
// 0x0188 (0x01F0 - 0x0068)
class UGenericPopupViewData : public UBasePopupViewData
{
public:
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPopupButtonViewData                   ProgressionData;                                   // 0x0070(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPopupButtonViewData                   RegressionData;                                    // 0x00F0(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FPopupButtonViewData                   AlternativeData;                                   // 0x0170(0x0080)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericPopupViewData">();
	}
	static class UGenericPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericPopupViewData>();
	}
};
static_assert(alignof(UGenericPopupViewData) == 0x000010, "Wrong alignment on UGenericPopupViewData");
static_assert(sizeof(UGenericPopupViewData) == 0x0001F0, "Wrong size on UGenericPopupViewData");
static_assert(offsetof(UGenericPopupViewData, ProgressionData) == 0x000070, "Member 'UGenericPopupViewData::ProgressionData' has a wrong offset!");
static_assert(offsetof(UGenericPopupViewData, RegressionData) == 0x0000F0, "Member 'UGenericPopupViewData::RegressionData' has a wrong offset!");
static_assert(offsetof(UGenericPopupViewData, AlternativeData) == 0x000170, "Member 'UGenericPopupViewData::AlternativeData' has a wrong offset!");

// Class DBDUIViewInterfaces.ArchivePassPurchasePopupViewData
// 0x0060 (0x0250 - 0x01F0)
class UArchivePassPurchasePopupViewData final : public UGenericPopupViewData
{
public:
	class FText                                   AvailabilityDates;                                 // 0x01F0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImageTexture;                                      // 0x0208(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 CurrencyType;                                      // 0x0238(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Price;                                             // 0x023C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiscountPercentage;                                // 0x0240(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAffordable;                                      // 0x0244(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_245[0xB];                                      // 0x0245(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivePassPurchasePopupViewData">();
	}
	static class UArchivePassPurchasePopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchivePassPurchasePopupViewData>();
	}
};
static_assert(alignof(UArchivePassPurchasePopupViewData) == 0x000010, "Wrong alignment on UArchivePassPurchasePopupViewData");
static_assert(sizeof(UArchivePassPurchasePopupViewData) == 0x000250, "Wrong size on UArchivePassPurchasePopupViewData");
static_assert(offsetof(UArchivePassPurchasePopupViewData, AvailabilityDates) == 0x0001F0, "Member 'UArchivePassPurchasePopupViewData::AvailabilityDates' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, ImageTexture) == 0x000208, "Member 'UArchivePassPurchasePopupViewData::ImageTexture' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, CurrencyType) == 0x000238, "Member 'UArchivePassPurchasePopupViewData::CurrencyType' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, Price) == 0x00023C, "Member 'UArchivePassPurchasePopupViewData::Price' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, DiscountPercentage) == 0x000240, "Member 'UArchivePassPurchasePopupViewData::DiscountPercentage' has a wrong offset!");
static_assert(offsetof(UArchivePassPurchasePopupViewData, IsAffordable) == 0x000244, "Member 'UArchivePassPurchasePopupViewData::IsAffordable' has a wrong offset!");

// Class DBDUIViewInterfaces.ArchivePassPurchasePopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchivePassPurchasePopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivePassPurchasePopupViewInterface">();
	}
	static class IArchivePassPurchasePopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchivePassPurchasePopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchivePassPurchasePopupViewInterface) == 0x000001, "Wrong alignment on IArchivePassPurchasePopupViewInterface");
static_assert(sizeof(IArchivePassPurchasePopupViewInterface) == 0x000001, "Wrong size on IArchivePassPurchasePopupViewInterface");

// Class DBDUIViewInterfaces.ArchiveQuestMapViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveQuestMapViewInterface final
{
public:
	void Reset();
	void SetLoadingSpinner(bool isLoading);
	void SetQuestMapData(const TArray<struct FArchiveNodeGraphViewData>& nodeDataList, const TArray<struct FArchiveMapPathViewData>& pathDataList, bool needsCascadeAppear);
	void UpdateQuestMapData(const TArray<struct FArchiveNodeGraphViewData>& nodeDataList, const TArray<struct FArchiveMapPathViewData>& pathDataList);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveQuestMapViewInterface">();
	}
	static class IArchiveQuestMapViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveQuestMapViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveQuestMapViewInterface) == 0x000001, "Wrong alignment on IArchiveQuestMapViewInterface");
static_assert(sizeof(IArchiveQuestMapViewInterface) == 0x000001, "Wrong size on IArchiveQuestMapViewInterface");

// Class DBDUIViewInterfaces.ArchiveRiftViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveRiftViewInterface final
{
public:
	void PlayUnlockingAnimation(const struct FArchivesRiftUnlockSequenceData& data);
	void SetData(const struct FArchivesRiftGenericViewData& data);
	void SetLoadingSpinner(bool isLoading);
	void SetMatchmakingSoftlockState(bool isInMatchmakingSoftlock);
	void SetRewardTiersData(const TArray<struct FArchiveRiftTierRewardsViewData>& riftTiersData);
	void SetRiftFragmentTooltipViewData(const struct FCurrencyProgressionTooltipViewData& RiftFragmentTooltipViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveRiftViewInterface">();
	}
	static class IArchiveRiftViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveRiftViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveRiftViewInterface) == 0x000001, "Wrong alignment on IArchiveRiftViewInterface");
static_assert(sizeof(IArchiveRiftViewInterface) == 0x000001, "Wrong size on IArchiveRiftViewInterface");

// Class DBDUIViewInterfaces.ArchiveTierPurchasePopupViewData
// 0x0060 (0x0250 - 0x01F0)
class UArchiveTierPurchasePopupViewData final : public UGenericPopupViewData
{
public:
	TSoftObjectPtr<class UTexture2D>              ImageTexture;                                      // 0x01F0(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTiers;                                          // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentTier;                                       // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECurrencyType                                 CurrencyType;                                      // 0x0228(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UnitPrice;                                         // 0x022C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiscountPercentage;                                // 0x0230(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAffordable;                                      // 0x0234(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235[0x3];                                      // 0x0235(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentWalletAmount;                               // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InitialQuantity;                                   // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstBonusTier;                                    // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastBonusTier;                                     // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBonusTier;                                       // 0x0248(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveTierPurchasePopupViewData">();
	}
	static class UArchiveTierPurchasePopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchiveTierPurchasePopupViewData>();
	}
};
static_assert(alignof(UArchiveTierPurchasePopupViewData) == 0x000010, "Wrong alignment on UArchiveTierPurchasePopupViewData");
static_assert(sizeof(UArchiveTierPurchasePopupViewData) == 0x000250, "Wrong size on UArchiveTierPurchasePopupViewData");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, ImageTexture) == 0x0001F0, "Member 'UArchiveTierPurchasePopupViewData::ImageTexture' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, MaxTiers) == 0x000220, "Member 'UArchiveTierPurchasePopupViewData::MaxTiers' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, CurrentTier) == 0x000224, "Member 'UArchiveTierPurchasePopupViewData::CurrentTier' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, CurrencyType) == 0x000228, "Member 'UArchiveTierPurchasePopupViewData::CurrencyType' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, UnitPrice) == 0x00022C, "Member 'UArchiveTierPurchasePopupViewData::UnitPrice' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, DiscountPercentage) == 0x000230, "Member 'UArchiveTierPurchasePopupViewData::DiscountPercentage' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, IsAffordable) == 0x000234, "Member 'UArchiveTierPurchasePopupViewData::IsAffordable' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, CurrentWalletAmount) == 0x000238, "Member 'UArchiveTierPurchasePopupViewData::CurrentWalletAmount' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, InitialQuantity) == 0x00023C, "Member 'UArchiveTierPurchasePopupViewData::InitialQuantity' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, FirstBonusTier) == 0x000240, "Member 'UArchiveTierPurchasePopupViewData::FirstBonusTier' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, LastBonusTier) == 0x000244, "Member 'UArchiveTierPurchasePopupViewData::LastBonusTier' has a wrong offset!");
static_assert(offsetof(UArchiveTierPurchasePopupViewData, IsBonusTier) == 0x000248, "Member 'UArchiveTierPurchasePopupViewData::IsBonusTier' has a wrong offset!");

// Class DBDUIViewInterfaces.ArchiveTierPurchasePopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveTierPurchasePopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveTierPurchasePopupViewInterface">();
	}
	static class IArchiveTierPurchasePopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveTierPurchasePopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveTierPurchasePopupViewInterface) == 0x000001, "Wrong alignment on IArchiveTierPurchasePopupViewInterface");
static_assert(sizeof(IArchiveTierPurchasePopupViewInterface) == 0x000001, "Wrong size on IArchiveTierPurchasePopupViewInterface");

// Class DBDUIViewInterfaces.ArchiveTomeViewInterface
// 0x0000 (0x0000 - 0x0000)
class IArchiveTomeViewInterface final
{
public:
	void SetMenuState(EArchiveTomeMenuState menuState);
	void SetNotificationVisibility(int32 key, bool hasNotification);
	void SetSideNavTabsData(const TArray<struct FTabWidgetData>& tabsData, int32 selectedKey);
	void SetSideNavTabsEnabled(int32 key, bool isEnabled);
	void SetSideNavTabsVisibility(int32 key, bool isVisible);
	void ToggleEditor(bool isEnabled);
	void UpdateBackgroundSkin(int32 key, class UMaterialInterface* skinMaterail);

	struct FEditorInterfaces GetArchiveEditorInterface() const;
	TScriptInterface<class IArchiveJournalViewInterface> GetArchiveJournalInterface() const;
	TScriptInterface<class IArchiveLevelProgressionViewInterface> GetArchiveLevelProgressionInterface() const;
	TScriptInterface<class IArchiveQuestMapViewInterface> GetArchiveQuestMapInterface() const;
	const EArchiveTomeMenuState GetMenuState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveTomeViewInterface">();
	}
	static class IArchiveTomeViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IArchiveTomeViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IArchiveTomeViewInterface) == 0x000001, "Wrong alignment on IArchiveTomeViewInterface");
static_assert(sizeof(IArchiveTomeViewInterface) == 0x000001, "Wrong size on IArchiveTomeViewInterface");

// Class DBDUIViewInterfaces.BasePopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IBasePopupViewInterface final
{
public:
	void Enter(class UBasePopupViewData* data);
	void Leave();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePopupViewInterface">();
	}
	static class IBasePopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBasePopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IBasePopupViewInterface) == 0x000001, "Wrong alignment on IBasePopupViewInterface");
static_assert(sizeof(IBasePopupViewInterface) == 0x000001, "Wrong size on IBasePopupViewInterface");

// Class DBDUIViewInterfaces.ChallengeTrackerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IChallengeTrackerViewInterface final
{
public:
	void CloseWidget();
	void InitWidgetData(const struct FChallengeTrackerViewData& viewData);
	void OpenWidget();
	void UpdateWidgetProgression(const struct FArchiveNodeObjectiveViewData& progressionData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChallengeTrackerViewInterface">();
	}
	static class IChallengeTrackerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChallengeTrackerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IChallengeTrackerViewInterface) == 0x000001, "Wrong alignment on IChallengeTrackerViewInterface");
static_assert(sizeof(IChallengeTrackerViewInterface) == 0x000001, "Wrong size on IChallengeTrackerViewInterface");

// Class DBDUIViewInterfaces.CoreBaseViewInterface
// 0x0000 (0x0000 - 0x0000)
class ICoreBaseViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreBaseViewInterface">();
	}
	static class ICoreBaseViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICoreBaseViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICoreBaseViewInterface) == 0x000001, "Wrong alignment on ICoreBaseViewInterface");
static_assert(sizeof(ICoreBaseViewInterface) == 0x000001, "Wrong size on ICoreBaseViewInterface");

// Class DBDUIViewInterfaces.CreditsViewInterface
// 0x0000 (0x0000 - 0x0000)
class ICreditsViewInterface final
{
public:
	void ScrollToEnd();
	void ScrollToName(const class FString& name, float delay);
	void SetText(const class FText& text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CreditsViewInterface">();
	}
	static class ICreditsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICreditsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICreditsViewInterface) == 0x000001, "Wrong alignment on ICreditsViewInterface");
static_assert(sizeof(ICreditsViewInterface) == 0x000001, "Wrong size on ICreditsViewInterface");

// Class DBDUIViewInterfaces.DailyRitualsPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IDailyRitualsPopupViewInterface final
{
public:
	void SetAllDailyRitualTilesVisible();
	void SetCanRemoveDailyRitual(const bool canRemoveDailyRitual);
	void SetDailyRitualsData(const TArray<struct FDailyRitualViewData>& dailyRitualsData, bool isAfterTrial);
	void StartAnim();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DailyRitualsPopupViewInterface">();
	}
	static class IDailyRitualsPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDailyRitualsPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDailyRitualsPopupViewInterface) == 0x000001, "Wrong alignment on IDailyRitualsPopupViewInterface");
static_assert(sizeof(IDailyRitualsPopupViewInterface) == 0x000001, "Wrong size on IDailyRitualsPopupViewInterface");

// Class DBDUIViewInterfaces.DisplayStandViewInterface
// 0x0000 (0x0000 - 0x0000)
class IDisplayStandViewInterface final
{
public:
	void SetDragZone(const struct FDisplayStandViewData& layoutData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandViewInterface">();
	}
	static class IDisplayStandViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDisplayStandViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDisplayStandViewInterface) == 0x000001, "Wrong alignment on IDisplayStandViewInterface");
static_assert(sizeof(IDisplayStandViewInterface) == 0x000001, "Wrong size on IDisplayStandViewInterface");

// Class DBDUIViewInterfaces.EndGameCollapseBarViewInterface
// 0x0000 (0x0000 - 0x0000)
class IEndGameCollapseBarViewInterface final
{
public:
	void InitEndGameScenario();
	void SetEndGameScenarioProgressionMode(const bool isSlowMode);
	void SetEndGameScenarioProgressionValue(const float amount);
	void StartEndGameScenario();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameCollapseBarViewInterface">();
	}
	static class IEndGameCollapseBarViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEndGameCollapseBarViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEndGameCollapseBarViewInterface) == 0x000001, "Wrong alignment on IEndGameCollapseBarViewInterface");
static_assert(sizeof(IEndGameCollapseBarViewInterface) == 0x000001, "Wrong size on IEndGameCollapseBarViewInterface");

// Class DBDUIViewInterfaces.EquippedItemViewInterface
// 0x0000 (0x0000 - 0x0000)
class IEquippedItemViewInterface final
{
public:
	void ClearData(bool fullClear);
	void SetActiveState(bool isActive);
	void SetData(const struct FItemBundleViewData& itemBundleData);
	void SetFakeItem(bool isHoldingFakeItem, const TSoftObjectPtr<class UTexture2D>& fakeItemIcon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquippedItemViewInterface">();
	}
	static class IEquippedItemViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEquippedItemViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEquippedItemViewInterface) == 0x000001, "Wrong alignment on IEquippedItemViewInterface");
static_assert(sizeof(IEquippedItemViewInterface) == 0x000001, "Wrong size on IEquippedItemViewInterface");

// Class DBDUIViewInterfaces.EquippedPowerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IEquippedPowerViewInterface final
{
public:
	void ClearData();
	void SetActiveState(bool isActive);
	void SetCarryingMode(const bool isCarrying);
	void SetData(const struct FPowerBundleViewData& powerBundleData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquippedPowerViewInterface">();
	}
	static class IEquippedPowerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEquippedPowerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEquippedPowerViewInterface) == 0x000001, "Wrong alignment on IEquippedPowerViewInterface");
static_assert(sizeof(IEquippedPowerViewInterface) == 0x000001, "Wrong size on IEquippedPowerViewInterface");

// Class DBDUIViewInterfaces.EventEntryPopupViewData
// 0x0080 (0x0270 - 0x01F0)
class UEventEntryPopupViewData final : public UGenericPopupViewData
{
public:
	class FText                                   AvailabilityDates;                                 // 0x01F0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   EventFrameLabel;                                   // 0x0208(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ImageBannerText;                                   // 0x0220(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ImageTexture;                                      // 0x0238(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldShowEventTomeButton;                         // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x7];                                      // 0x0269(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventEntryPopupViewData">();
	}
	static class UEventEntryPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventEntryPopupViewData>();
	}
};
static_assert(alignof(UEventEntryPopupViewData) == 0x000010, "Wrong alignment on UEventEntryPopupViewData");
static_assert(sizeof(UEventEntryPopupViewData) == 0x000270, "Wrong size on UEventEntryPopupViewData");
static_assert(offsetof(UEventEntryPopupViewData, AvailabilityDates) == 0x0001F0, "Member 'UEventEntryPopupViewData::AvailabilityDates' has a wrong offset!");
static_assert(offsetof(UEventEntryPopupViewData, EventFrameLabel) == 0x000208, "Member 'UEventEntryPopupViewData::EventFrameLabel' has a wrong offset!");
static_assert(offsetof(UEventEntryPopupViewData, ImageBannerText) == 0x000220, "Member 'UEventEntryPopupViewData::ImageBannerText' has a wrong offset!");
static_assert(offsetof(UEventEntryPopupViewData, ImageTexture) == 0x000238, "Member 'UEventEntryPopupViewData::ImageTexture' has a wrong offset!");
static_assert(offsetof(UEventEntryPopupViewData, ShouldShowEventTomeButton) == 0x000268, "Member 'UEventEntryPopupViewData::ShouldShowEventTomeButton' has a wrong offset!");

// Class DBDUIViewInterfaces.EventEntryPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IEventEntryPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventEntryPopupViewInterface">();
	}
	static class IEventEntryPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEventEntryPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEventEntryPopupViewInterface) == 0x000001, "Wrong alignment on IEventEntryPopupViewInterface");
static_assert(sizeof(IEventEntryPopupViewInterface) == 0x000001, "Wrong size on IEventEntryPopupViewInterface");

// Class DBDUIViewInterfaces.ExampleViewInterface
// 0x0000 (0x0000 - 0x0000)
class IExampleViewInterface final
{
public:
	void SetExampleProgressRatio(float ratio);
	void SetExampleText(const class FString& text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExampleViewInterface">();
	}
	static class IExampleViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IExampleViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IExampleViewInterface) == 0x000001, "Wrong alignment on IExampleViewInterface");
static_assert(sizeof(IExampleViewInterface) == 0x000001, "Wrong size on IExampleViewInterface");

// Class DBDUIViewInterfaces.ExternalEffectsViewInterface
// 0x0000 (0x0000 - 0x0000)
class IExternalEffectsViewInterface final
{
public:
	void HideExternalAddon(const class FName& itemId);
	void HideExternalPerk(const class FName& itemId);
	void ShowExternalAddon(const struct FAddonViewData& addonViewData);
	void ShowExternalPerk(const struct FPerkViewData& perkViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExternalEffectsViewInterface">();
	}
	static class IExternalEffectsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IExternalEffectsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IExternalEffectsViewInterface) == 0x000001, "Wrong alignment on IExternalEffectsViewInterface");
static_assert(sizeof(IExternalEffectsViewInterface) == 0x000001, "Wrong size on IExternalEffectsViewInterface");

// Class DBDUIViewInterfaces.FearMarketPopupViewData
// 0x0020 (0x0210 - 0x01F0)
class UFearMarketPopupViewData final : public UGenericPopupViewData
{
public:
	class UMenuPerkViewData*                      ItemData;                                          // 0x01F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost;                                              // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BloodpointConversion;                              // 0x01FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPurchased;                                       // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlreadyOwned;                                      // 0x0201(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_202[0x2];                                      // 0x0202(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AvailableTokens;                                   // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208[0x8];                                      // 0x0208(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FearMarketPopupViewData">();
	}
	static class UFearMarketPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFearMarketPopupViewData>();
	}
};
static_assert(alignof(UFearMarketPopupViewData) == 0x000010, "Wrong alignment on UFearMarketPopupViewData");
static_assert(sizeof(UFearMarketPopupViewData) == 0x000210, "Wrong size on UFearMarketPopupViewData");
static_assert(offsetof(UFearMarketPopupViewData, ItemData) == 0x0001F0, "Member 'UFearMarketPopupViewData::ItemData' has a wrong offset!");
static_assert(offsetof(UFearMarketPopupViewData, Cost) == 0x0001F8, "Member 'UFearMarketPopupViewData::Cost' has a wrong offset!");
static_assert(offsetof(UFearMarketPopupViewData, BloodpointConversion) == 0x0001FC, "Member 'UFearMarketPopupViewData::BloodpointConversion' has a wrong offset!");
static_assert(offsetof(UFearMarketPopupViewData, IsPurchased) == 0x000200, "Member 'UFearMarketPopupViewData::IsPurchased' has a wrong offset!");
static_assert(offsetof(UFearMarketPopupViewData, AlreadyOwned) == 0x000201, "Member 'UFearMarketPopupViewData::AlreadyOwned' has a wrong offset!");
static_assert(offsetof(UFearMarketPopupViewData, AvailableTokens) == 0x000204, "Member 'UFearMarketPopupViewData::AvailableTokens' has a wrong offset!");

// Class DBDUIViewInterfaces.FearMarketPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IFearMarketPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FearMarketPopupViewInterface">();
	}
	static class IFearMarketPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFearMarketPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IFearMarketPopupViewInterface) == 0x000001, "Wrong alignment on IFearMarketPopupViewInterface");
static_assert(sizeof(IFearMarketPopupViewInterface) == 0x000001, "Wrong size on IFearMarketPopupViewInterface");

// Class DBDUIViewInterfaces.GameManualViewInterface
// 0x0000 (0x0000 - 0x0000)
class IGameManualViewInterface final
{
public:
	void SetCategoryData(const struct FHelpCategoryData& categoryData, const TArray<struct FHelpTopicData>& topicsData);
	void SetCurrentManualMenuState(const EGameManualMenuState menuState);

	const EGameManualMenuState GetCurrentManualMenuState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameManualViewInterface">();
	}
	static class IGameManualViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGameManualViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGameManualViewInterface) == 0x000001, "Wrong alignment on IGameManualViewInterface");
static_assert(sizeof(IGameManualViewInterface) == 0x000001, "Wrong size on IGameManualViewInterface");

// Class DBDUIViewInterfaces.GenericPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IGenericPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericPopupViewInterface">();
	}
	static class IGenericPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGenericPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGenericPopupViewInterface) == 0x000001, "Wrong alignment on IGenericPopupViewInterface");
static_assert(sizeof(IGenericPopupViewInterface) == 0x000001, "Wrong size on IGenericPopupViewInterface");

// Class DBDUIViewInterfaces.GenericTextInputPopupViewData
// 0x00E0 (0x02D0 - 0x01F0)
class UGenericTextInputPopupViewData final : public UGenericPopupViewData
{
public:
	uint8                                         Pad_1F0[0xE0];                                     // 0x01F0(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericTextInputPopupViewData">();
	}
	static class UGenericTextInputPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericTextInputPopupViewData>();
	}
};
static_assert(alignof(UGenericTextInputPopupViewData) == 0x000010, "Wrong alignment on UGenericTextInputPopupViewData");
static_assert(sizeof(UGenericTextInputPopupViewData) == 0x0002D0, "Wrong size on UGenericTextInputPopupViewData");

// Class DBDUIViewInterfaces.GenericTextInputPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IGenericTextInputPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericTextInputPopupViewInterface">();
	}
	static class IGenericTextInputPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGenericTextInputPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGenericTextInputPopupViewInterface) == 0x000001, "Wrong alignment on IGenericTextInputPopupViewInterface");
static_assert(sizeof(IGenericTextInputPopupViewInterface) == 0x000001, "Wrong size on IGenericTextInputPopupViewInterface");

// Class DBDUIViewInterfaces.HookCountViewInterface
// 0x0000 (0x0000 - 0x0000)
class IHookCountViewInterface final
{
public:
	void ClearData();
	void InitWidget();
	void SetData(const int32 currentHookCount, const int32 maxHookCount, const int32 initialMaxHookCount);
	void SetHookCountVisibility(bool visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HookCountViewInterface">();
	}
	static class IHookCountViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHookCountViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHookCountViewInterface) == 0x000001, "Wrong alignment on IHookCountViewInterface");
static_assert(sizeof(IHookCountViewInterface) == 0x000001, "Wrong size on IHookCountViewInterface");

// Class DBDUIViewInterfaces.HudAlertViewInterface
// 0x0000 (0x0000 - 0x0000)
class IHudAlertViewInterface final
{
public:
	void FadeIn();
	void FadeOut(float delay);
	void SetScoreEventsVisibility(bool visible);
	void ShowScoreAlert(const struct FScoreAlertViewData& data);
	void ShowStatusEffectAlert(const struct FStatusEffectAlertViewData& data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudAlertViewInterface">();
	}
	static class IHudAlertViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudAlertViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHudAlertViewInterface) == 0x000001, "Wrong alignment on IHudAlertViewInterface");
static_assert(sizeof(IHudAlertViewInterface) == 0x000001, "Wrong size on IHudAlertViewInterface");

// Class DBDUIViewInterfaces.HudDirectionalMiniGameViewInterface
// 0x0000 (0x0000 - 0x0000)
class IHudDirectionalMiniGameViewInterface final
{
public:
	void Hide();
	void Init(int32 maxItems);
	void Show(const TArray<EDirectionalInputKey>& directions);
	void UpdateFinalResult(EDirectionalMinigameResult finalResult);
	void UpdateResult(int32 index, bool isSuccessful);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudDirectionalMiniGameViewInterface">();
	}
	static class IHudDirectionalMiniGameViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudDirectionalMiniGameViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHudDirectionalMiniGameViewInterface) == 0x000001, "Wrong alignment on IHudDirectionalMiniGameViewInterface");
static_assert(sizeof(IHudDirectionalMiniGameViewInterface) == 0x000001, "Wrong size on IHudDirectionalMiniGameViewInterface");

// Class DBDUIViewInterfaces.HudObjectivesViewInterface
// 0x0000 (0x0000 - 0x0000)
class IHudObjectivesViewInterface final
{
public:
	void ClearData();
	void ClearHookCountData();
	void EnableEventProgression(bool isEnabled);
	void InitEventProgression(const struct FHudEventProgressionViewData& hudEventProgressionViewData);
	void InitWidget();
	void SetHookCountData(const int32 currentHookCount, const int32 maxHookCount, const int32 initialMaxHookCount);
	void SetHookCountVisibility(bool visible);
	void SetHudObjectiveData(const struct FHudObjectivesViewData& hudObjectiveViewData);
	void UpdateEventBankedProgress(const struct FHudEventProgressionViewData& hudEventProgressionViewData);
	void UpdateEventPendingProgress(const struct FHudEventProgressionViewData& hudEventProgressionViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudObjectivesViewInterface">();
	}
	static class IHudObjectivesViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHudObjectivesViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHudObjectivesViewInterface) == 0x000001, "Wrong alignment on IHudObjectivesViewInterface");
static_assert(sizeof(IHudObjectivesViewInterface) == 0x000001, "Wrong size on IHudObjectivesViewInterface");

// Class DBDUIViewInterfaces.InteractionProgressViewInterface
// 0x0000 (0x0000 - 0x0000)
class IInteractionProgressViewInterface final
{
public:
	void HideInputProgressPrompt();
	void PlayHemorrhageAnimation();
	void SetInputProgressPrompt(const struct FInteractionProgressViewData& data);
	void UpdateInputProgress(const float progress, const float itemCharge);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionProgressViewInterface">();
	}
	static class IInteractionProgressViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractionProgressViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IInteractionProgressViewInterface) == 0x000001, "Wrong alignment on IInteractionProgressViewInterface");
static_assert(sizeof(IInteractionProgressViewInterface) == 0x000001, "Wrong size on IInteractionProgressViewInterface");

// Class DBDUIViewInterfaces.InteractionPromptsContainerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IInteractionPromptsContainerViewInterface final
{
public:
	void AddPrompt(const struct FInteractionPromptViewData& data);
	void RemoveAllPrompts();
	void RemovePrompt(class FName id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionPromptsContainerViewInterface">();
	}
	static class IInteractionPromptsContainerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractionPromptsContainerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IInteractionPromptsContainerViewInterface) == 0x000001, "Wrong alignment on IInteractionPromptsContainerViewInterface");
static_assert(sizeof(IInteractionPromptsContainerViewInterface) == 0x000001, "Wrong size on IInteractionPromptsContainerViewInterface");

// Class DBDUIViewInterfaces.ItemBundleViewInterface
// 0x0000 (0x0000 - 0x0000)
class IItemBundleViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FItemBundleViewData& itemBundleViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBundleViewInterface">();
	}
	static class IItemBundleViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemBundleViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IItemBundleViewInterface) == 0x000001, "Wrong alignment on IItemBundleViewInterface");
static_assert(sizeof(IItemBundleViewInterface) == 0x000001, "Wrong size on IItemBundleViewInterface");

// Class DBDUIViewInterfaces.ItemInteractionViewInterface
// 0x0000 (0x0000 - 0x0000)
class IItemInteractionViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FItemBundleViewData& itemBundleData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemInteractionViewInterface">();
	}
	static class IItemInteractionViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemInteractionViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IItemInteractionViewInterface) == 0x000001, "Wrong alignment on IItemInteractionViewInterface");
static_assert(sizeof(IItemInteractionViewInterface) == 0x000001, "Wrong size on IItemInteractionViewInterface");

// Class DBDUIViewInterfaces.ItemViewInterface
// 0x0000 (0x0000 - 0x0000)
class IItemViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FItemViewData& itemViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemViewInterface">();
	}
	static class IItemViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IItemViewInterface) == 0x000001, "Wrong alignment on IItemViewInterface");
static_assert(sizeof(IItemViewInterface) == 0x000001, "Wrong size on IItemViewInterface");

// Class DBDUIViewInterfaces.LeaningArrowsViewInterface
// 0x0000 (0x0000 - 0x0000)
class ILeaningArrowsViewInterface final
{
public:
	void SetData(const ELeanState& leanState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LeaningArrowsViewInterface">();
	}
	static class ILeaningArrowsViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILeaningArrowsViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILeaningArrowsViewInterface) == 0x000001, "Wrong alignment on ILeaningArrowsViewInterface");
static_assert(sizeof(ILeaningArrowsViewInterface) == 0x000001, "Wrong size on ILeaningArrowsViewInterface");

// Class DBDUIViewInterfaces.LightSensitivityViewInterface
// 0x0000 (0x0000 - 0x0000)
class ILightSensitivityViewInterface final
{
public:
	void StartFadeOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightSensitivityViewInterface">();
	}
	static class ILightSensitivityViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILightSensitivityViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILightSensitivityViewInterface) == 0x000001, "Wrong alignment on ILightSensitivityViewInterface");
static_assert(sizeof(ILightSensitivityViewInterface) == 0x000001, "Wrong size on ILightSensitivityViewInterface");

// Class DBDUIViewInterfaces.LoadoutMenuPopupViewData
// 0x0110 (0x0300 - 0x01F0)
class ULoadoutMenuPopupViewData final : public UGenericPopupViewData
{
public:
	TSoftObjectPtr<class UTexture2D>              LoadoutIcon;                                       // 0x01F0(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId;                                            // 0x0220(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0230(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ParentDisplayName;                                 // 0x0248(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ParentTypeDisplayName;                             // 0x0260(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsParentAvailable;                                 // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0280(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EInventoryItemType                            ItemType;                                          // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0299(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatusEffectType                             StatusEffectType;                                  // 0x029A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29B[0x1];                                      // 0x029B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Subtitle;                                          // 0x02A0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemAvailability                             Availability;                                      // 0x02BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTeachablePerk;                                   // 0x02BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSlasherPerk;                                     // 0x02BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSlasher;                                         // 0x02BF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x02C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsKillSwitch;                                      // 0x02C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2[0x6];                                      // 0x02C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   EventName;                                         // 0x02C8(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FString                                 EventId;                                           // 0x02E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPastEvent;                                       // 0x02F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0xF];                                      // 0x02F1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutMenuPopupViewData">();
	}
	static class ULoadoutMenuPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutMenuPopupViewData>();
	}
};
static_assert(alignof(ULoadoutMenuPopupViewData) == 0x000010, "Wrong alignment on ULoadoutMenuPopupViewData");
static_assert(sizeof(ULoadoutMenuPopupViewData) == 0x000300, "Wrong size on ULoadoutMenuPopupViewData");
static_assert(offsetof(ULoadoutMenuPopupViewData, LoadoutIcon) == 0x0001F0, "Member 'ULoadoutMenuPopupViewData::LoadoutIcon' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, ItemId) == 0x000220, "Member 'ULoadoutMenuPopupViewData::ItemId' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, DisplayName) == 0x000230, "Member 'ULoadoutMenuPopupViewData::DisplayName' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, ParentDisplayName) == 0x000248, "Member 'ULoadoutMenuPopupViewData::ParentDisplayName' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, ParentTypeDisplayName) == 0x000260, "Member 'ULoadoutMenuPopupViewData::ParentTypeDisplayName' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, IsParentAvailable) == 0x000278, "Member 'ULoadoutMenuPopupViewData::IsParentAvailable' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, Description) == 0x000280, "Member 'ULoadoutMenuPopupViewData::Description' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, ItemType) == 0x000298, "Member 'ULoadoutMenuPopupViewData::ItemType' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, Rarity) == 0x000299, "Member 'ULoadoutMenuPopupViewData::Rarity' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, StatusEffectType) == 0x00029A, "Member 'ULoadoutMenuPopupViewData::StatusEffectType' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, Level) == 0x00029C, "Member 'ULoadoutMenuPopupViewData::Level' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, Subtitle) == 0x0002A0, "Member 'ULoadoutMenuPopupViewData::Subtitle' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, StackCount) == 0x0002B8, "Member 'ULoadoutMenuPopupViewData::StackCount' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, Availability) == 0x0002BC, "Member 'ULoadoutMenuPopupViewData::Availability' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, IsTeachablePerk) == 0x0002BD, "Member 'ULoadoutMenuPopupViewData::IsTeachablePerk' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, IsSlasherPerk) == 0x0002BE, "Member 'ULoadoutMenuPopupViewData::IsSlasherPerk' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, IsSlasher) == 0x0002BF, "Member 'ULoadoutMenuPopupViewData::IsSlasher' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, IsLocked) == 0x0002C0, "Member 'ULoadoutMenuPopupViewData::IsLocked' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, IsKillSwitch) == 0x0002C1, "Member 'ULoadoutMenuPopupViewData::IsKillSwitch' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, EventName) == 0x0002C8, "Member 'ULoadoutMenuPopupViewData::EventName' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, EventId) == 0x0002E0, "Member 'ULoadoutMenuPopupViewData::EventId' has a wrong offset!");
static_assert(offsetof(ULoadoutMenuPopupViewData, IsPastEvent) == 0x0002F0, "Member 'ULoadoutMenuPopupViewData::IsPastEvent' has a wrong offset!");

// Class DBDUIViewInterfaces.LoadoutMenuPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class ILoadoutMenuPopupViewInterface final
{
public:
	void SetLoadoutMenuInventoryData(const TArray<class ULoadoutMenuPopupViewData*>& loadoutMenuSlotButtonData, const ELoadoutSlot slotSelected, const bool isNextSlot);
	void SetLoadoutMenuSlotData(const TArray<class ULoadoutMenuPopupViewData*>& loadoutMenuSlotButtonData);
	void SetSelectableCharacters(const TArray<struct FTabWidgetData>& selectableCharacters, const struct FTabWidgetData& selectedCharacterData, const int32 botIndex);
	void SetSelectedInventoryItem(const TArray<int32>& selectedIndex, const bool isUnequip);
	void UpdatePresetData(const TArray<int32>& presetData, const int32 selectedPreset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutMenuPopupViewInterface">();
	}
	static class ILoadoutMenuPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILoadoutMenuPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILoadoutMenuPopupViewInterface) == 0x000001, "Wrong alignment on ILoadoutMenuPopupViewInterface");
static_assert(sizeof(ILoadoutMenuPopupViewInterface) == 0x000001, "Wrong size on ILoadoutMenuPopupViewInterface");

// Class DBDUIViewInterfaces.MatchResultViewInterface
// 0x0000 (0x0000 - 0x0000)
class IMatchResultViewInterface final
{
public:
	void PlayAnimationSequence();
	void UpdateWidget(const struct FMatchResultViewData& data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchResultViewInterface">();
	}
	static class IMatchResultViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMatchResultViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMatchResultViewInterface) == 0x000001, "Wrong alignment on IMatchResultViewInterface");
static_assert(sizeof(IMatchResultViewInterface) == 0x000001, "Wrong size on IMatchResultViewInterface");

// Class DBDUIViewInterfaces.MenuLoadoutPartViewData
// 0x0068 (0x0098 - 0x0030)
class UMenuLoadoutPartViewData : public UObject
{
public:
	class FName                                   ItemId;                                            // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              IconTexture;                                       // 0x0040(0x0030)(Edit, BlueprintVisible, Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   Rarity;                                            // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StackCount;                                        // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ParentDisplayName;                                 // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          IsLocked;                                          // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemAvailability                             Availability;                                      // 0x0091(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsKillSwitchEnabled;                               // 0x0092(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93[0x5];                                       // 0x0093(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuLoadoutPartViewData">();
	}
	static class UMenuLoadoutPartViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuLoadoutPartViewData>();
	}
};
static_assert(alignof(UMenuLoadoutPartViewData) == 0x000008, "Wrong alignment on UMenuLoadoutPartViewData");
static_assert(sizeof(UMenuLoadoutPartViewData) == 0x000098, "Wrong size on UMenuLoadoutPartViewData");
static_assert(offsetof(UMenuLoadoutPartViewData, ItemId) == 0x000030, "Member 'UMenuLoadoutPartViewData::ItemId' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, IconTexture) == 0x000040, "Member 'UMenuLoadoutPartViewData::IconTexture' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, Rarity) == 0x000070, "Member 'UMenuLoadoutPartViewData::Rarity' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, StackCount) == 0x000074, "Member 'UMenuLoadoutPartViewData::StackCount' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, ParentDisplayName) == 0x000078, "Member 'UMenuLoadoutPartViewData::ParentDisplayName' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, IsLocked) == 0x000090, "Member 'UMenuLoadoutPartViewData::IsLocked' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, Availability) == 0x000091, "Member 'UMenuLoadoutPartViewData::Availability' has a wrong offset!");
static_assert(offsetof(UMenuLoadoutPartViewData, IsKillSwitchEnabled) == 0x000092, "Member 'UMenuLoadoutPartViewData::IsKillSwitchEnabled' has a wrong offset!");

// Class DBDUIViewInterfaces.MenuAddonViewData
// 0x0000 (0x0098 - 0x0098)
class UMenuAddonViewData final : public UMenuLoadoutPartViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuAddonViewData">();
	}
	static class UMenuAddonViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuAddonViewData>();
	}
};
static_assert(alignof(UMenuAddonViewData) == 0x000008, "Wrong alignment on UMenuAddonViewData");
static_assert(sizeof(UMenuAddonViewData) == 0x000098, "Wrong size on UMenuAddonViewData");

// Class DBDUIViewInterfaces.MenuItemViewData
// 0x0000 (0x0098 - 0x0098)
class UMenuItemViewData final : public UMenuLoadoutPartViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuItemViewData">();
	}
	static class UMenuItemViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuItemViewData>();
	}
};
static_assert(alignof(UMenuItemViewData) == 0x000008, "Wrong alignment on UMenuItemViewData");
static_assert(sizeof(UMenuItemViewData) == 0x000098, "Wrong size on UMenuItemViewData");

// Class DBDUIViewInterfaces.MenuOfferingViewData
// 0x0000 (0x0098 - 0x0098)
class UMenuOfferingViewData final : public UMenuLoadoutPartViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuOfferingViewData">();
	}
	static class UMenuOfferingViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuOfferingViewData>();
	}
};
static_assert(alignof(UMenuOfferingViewData) == 0x000008, "Wrong alignment on UMenuOfferingViewData");
static_assert(sizeof(UMenuOfferingViewData) == 0x000098, "Wrong size on UMenuOfferingViewData");

// Class DBDUIViewInterfaces.MenuPerkViewData
// 0x0060 (0x00F8 - 0x0098)
class UMenuPerkViewData final : public UMenuLoadoutPartViewData
{
public:
	int32                                         Level;                                             // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x00A0(0x0018)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x00B8(0x0018)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FText                                   EventName;                                         // 0x00D0(0x0018)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class FString                                 EventId;                                           // 0x00E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuPerkViewData">();
	}
	static class UMenuPerkViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuPerkViewData>();
	}
};
static_assert(alignof(UMenuPerkViewData) == 0x000008, "Wrong alignment on UMenuPerkViewData");
static_assert(sizeof(UMenuPerkViewData) == 0x0000F8, "Wrong size on UMenuPerkViewData");
static_assert(offsetof(UMenuPerkViewData, Level) == 0x000098, "Member 'UMenuPerkViewData::Level' has a wrong offset!");
static_assert(offsetof(UMenuPerkViewData, DisplayName) == 0x0000A0, "Member 'UMenuPerkViewData::DisplayName' has a wrong offset!");
static_assert(offsetof(UMenuPerkViewData, Description) == 0x0000B8, "Member 'UMenuPerkViewData::Description' has a wrong offset!");
static_assert(offsetof(UMenuPerkViewData, EventName) == 0x0000D0, "Member 'UMenuPerkViewData::EventName' has a wrong offset!");
static_assert(offsetof(UMenuPerkViewData, EventId) == 0x0000E8, "Member 'UMenuPerkViewData::EventId' has a wrong offset!");

// Class DBDUIViewInterfaces.MenuPowerViewData
// 0x0000 (0x0098 - 0x0098)
class UMenuPowerViewData final : public UMenuLoadoutPartViewData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuPowerViewData">();
	}
	static class UMenuPowerViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuPowerViewData>();
	}
};
static_assert(alignof(UMenuPowerViewData) == 0x000008, "Wrong alignment on UMenuPowerViewData");
static_assert(sizeof(UMenuPowerViewData) == 0x000098, "Wrong size on UMenuPowerViewData");

// Class DBDUIViewInterfaces.OfferingInteractionViewInterface
// 0x0000 (0x0000 - 0x0000)
class IOfferingInteractionViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FOfferingViewData& OfferingData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingInteractionViewInterface">();
	}
	static class IOfferingInteractionViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOfferingInteractionViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOfferingInteractionViewInterface) == 0x000001, "Wrong alignment on IOfferingInteractionViewInterface");
static_assert(sizeof(IOfferingInteractionViewInterface) == 0x000001, "Wrong size on IOfferingInteractionViewInterface");

// Class DBDUIViewInterfaces.OfferingViewInterface
// 0x0000 (0x0000 - 0x0000)
class IOfferingViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FOfferingViewData& offeringViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingViewInterface">();
	}
	static class IOfferingViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOfferingViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOfferingViewInterface) == 0x000001, "Wrong alignment on IOfferingViewInterface");
static_assert(sizeof(IOfferingViewInterface) == 0x000001, "Wrong size on IOfferingViewInterface");

// Class DBDUIViewInterfaces.OnboardingMenuViewInterface
// 0x0000 (0x0000 - 0x0000)
class IOnboardingMenuViewInterface final
{
public:
	void SetBackButtonVisible(bool visible);
	void SetChangeAccountInputSwitcherPlayerNickname(const class FString& playerNickname);
	void SetChangeAccountInputSwitcherVisible(bool visible);
	void SetFirstTimeUserExperience(bool ftue);
	void SetOnboardingMenuState(EOnboardingMenuState menuState);
	void SetQuitGameButtonVisible(bool visible);
	void SetUIEnabled(bool enabled);

	TScriptInterface<class IGameManualViewInterface> GetGameManualInterface() const;
	TScriptInterface<class IOnboardingTutorialViewInterface> GetOnboardingTutorialInterface() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnboardingMenuViewInterface">();
	}
	static class IOnboardingMenuViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOnboardingMenuViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOnboardingMenuViewInterface) == 0x000001, "Wrong alignment on IOnboardingMenuViewInterface");
static_assert(sizeof(IOnboardingMenuViewInterface) == 0x000001, "Wrong size on IOnboardingMenuViewInterface");

// Class DBDUIViewInterfaces.OnboardingTutorialViewInterface
// 0x0000 (0x0000 - 0x0000)
class IOnboardingTutorialViewInterface final
{
public:
	void SetCanShowGoToMainMenuTutorialButton(bool canShowGoToMainMenuTutorialButton);
	void SetIsKillSwitch(bool isKillSwitch);
	void SetProgress(const TArray<struct FOnboardingStepViewData>& progress);
	void SetTutorialProgressionFeedbacks(const class FString& completedStepId, const bool isOnboardingEnabled);
	void SetUIEnabled(bool enabled);
	void StopLoadingSpinner();
	void UpdateProgress(const TArray<struct FOnboardingStepViewData>& before, const TArray<struct FOnboardingStepViewData>& after, const TArray<struct FRewardWrapperViewData>& rewards);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnboardingTutorialViewInterface">();
	}
	static class IOnboardingTutorialViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOnboardingTutorialViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IOnboardingTutorialViewInterface) == 0x000001, "Wrong alignment on IOnboardingTutorialViewInterface");
static_assert(sizeof(IOnboardingTutorialViewInterface) == 0x000001, "Wrong size on IOnboardingTutorialViewInterface");

// Class DBDUIViewInterfaces.PerksContainerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPerksContainerViewInterface final
{
public:
	TScriptInterface<class IPerkViewInterface> GetPerkInterface(int32 index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerksContainerViewInterface">();
	}
	static class IPerksContainerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPerksContainerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPerksContainerViewInterface) == 0x000001, "Wrong alignment on IPerksContainerViewInterface");
static_assert(sizeof(IPerksContainerViewInterface) == 0x000001, "Wrong size on IPerksContainerViewInterface");

// Class DBDUIViewInterfaces.PerkViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPerkViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FPerkViewData& perkViewData);
	void UpdatePerkCooldown(float cooldownValue, bool IsRechargeable, bool IsRechargeableActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkViewInterface">();
	}
	static class IPerkViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPerkViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPerkViewInterface) == 0x000001, "Wrong alignment on IPerkViewInterface");
static_assert(sizeof(IPerkViewInterface) == 0x000001, "Wrong size on IPerkViewInterface");

// Class DBDUIViewInterfaces.PingStatusViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPingStatusViewInterface final
{
public:
	void SetKillerConnectionQualityStatus(const EConnectionQuality& killerConnectionQuality);
	void SetLocalPacketLossStatus(const EConnectionQuality& localPacketLoss);
	void SetLocalPingStatus(const EConnectionQuality& localPing);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingStatusViewInterface">();
	}
	static class IPingStatusViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPingStatusViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPingStatusViewInterface) == 0x000001, "Wrong alignment on IPingStatusViewInterface");
static_assert(sizeof(IPingStatusViewInterface) == 0x000001, "Wrong size on IPingStatusViewInterface");

// Class DBDUIViewInterfaces.PlayerProfileViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPlayerProfileViewInterface final
{
public:
	void FullUpdateCurrency(const struct FCurrencyLabelViewData& viewData);
	void HidePlayerLevel();
	void HidePlayerName();
	void HidePlayerRank();
	void HideUI();
	void HideWallet();
	void SetPlayerName(const class FText& playerNameText);
	void SetWallet(const TArray<struct FCurrencyLabelViewData>& walletData);
	void ShowUI();
	void UpdateWallet(const ECurrencyType type, int32 newBalance, int32 previousBalance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerProfileViewInterface">();
	}
	static class IPlayerProfileViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerProfileViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPlayerProfileViewInterface) == 0x000001, "Wrong alignment on IPlayerProfileViewInterface");
static_assert(sizeof(IPlayerProfileViewInterface) == 0x000001, "Wrong size on IPlayerProfileViewInterface");

// Class DBDUIViewInterfaces.PlayerStatusesContainerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPlayerStatusesContainerViewInterface final
{
public:
	TScriptInterface<class IPlayerStatusViewInterface> GetPlayerStatusInterface(int32 index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStatusesContainerViewInterface">();
	}
	static class IPlayerStatusesContainerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerStatusesContainerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPlayerStatusesContainerViewInterface) == 0x000001, "Wrong alignment on IPlayerStatusesContainerViewInterface");
static_assert(sizeof(IPlayerStatusesContainerViewInterface) == 0x000001, "Wrong size on IPlayerStatusesContainerViewInterface");

// Class DBDUIViewInterfaces.KillerStatusData
// 0x0000 (0x0030 - 0x0030)
class UKillerStatusData : public UObject
{
public:
	bool IsEqual(const class UKillerStatusData* other) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerStatusData">();
	}
	static class UKillerStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerStatusData>();
	}
};
static_assert(alignof(UKillerStatusData) == 0x000008, "Wrong alignment on UKillerStatusData");
static_assert(sizeof(UKillerStatusData) == 0x000030, "Wrong size on UKillerStatusData");

// Class DBDUIViewInterfaces.DoctorStatusData
// 0x0008 (0x0038 - 0x0030)
class UDoctorStatusData final : public UKillerStatusData
{
public:
	EAfflictionLevel                              AfflictionLevel;                                   // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoctorStatusData">();
	}
	static class UDoctorStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoctorStatusData>();
	}
};
static_assert(alignof(UDoctorStatusData) == 0x000008, "Wrong alignment on UDoctorStatusData");
static_assert(sizeof(UDoctorStatusData) == 0x000038, "Wrong size on UDoctorStatusData");
static_assert(offsetof(UDoctorStatusData, AfflictionLevel) == 0x000030, "Member 'UDoctorStatusData::AfflictionLevel' has a wrong offset!");

// Class DBDUIViewInterfaces.ExecutionerStatusData
// 0x0008 (0x0038 - 0x0030)
class UExecutionerStatusData final : public UKillerStatusData
{
public:
	float                                         AgonyProgress;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExecutionerStatusData">();
	}
	static class UExecutionerStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExecutionerStatusData>();
	}
};
static_assert(alignof(UExecutionerStatusData) == 0x000008, "Wrong alignment on UExecutionerStatusData");
static_assert(sizeof(UExecutionerStatusData) == 0x000038, "Wrong size on UExecutionerStatusData");
static_assert(offsetof(UExecutionerStatusData, AgonyProgress) == 0x000030, "Member 'UExecutionerStatusData::AgonyProgress' has a wrong offset!");

// Class DBDUIViewInterfaces.TwinsStatusData
// 0x0008 (0x0038 - 0x0030)
class UTwinsStatusData final : public UKillerStatusData
{
public:
	bool                                          TwinsActive;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinsStatusData">();
	}
	static class UTwinsStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinsStatusData>();
	}
};
static_assert(alignof(UTwinsStatusData) == 0x000008, "Wrong alignment on UTwinsStatusData");
static_assert(sizeof(UTwinsStatusData) == 0x000038, "Wrong size on UTwinsStatusData");
static_assert(offsetof(UTwinsStatusData, TwinsActive) == 0x000030, "Member 'UTwinsStatusData::TwinsActive' has a wrong offset!");

// Class DBDUIViewInterfaces.GhostfaceStatusData
// 0x0008 (0x0038 - 0x0030)
class UGhostfaceStatusData final : public UKillerStatusData
{
public:
	bool                                          IsExposed;                                         // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StalkingProgress;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostfaceStatusData">();
	}
	static class UGhostfaceStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGhostfaceStatusData>();
	}
};
static_assert(alignof(UGhostfaceStatusData) == 0x000008, "Wrong alignment on UGhostfaceStatusData");
static_assert(sizeof(UGhostfaceStatusData) == 0x000038, "Wrong size on UGhostfaceStatusData");
static_assert(offsetof(UGhostfaceStatusData, IsExposed) == 0x000030, "Member 'UGhostfaceStatusData::IsExposed' has a wrong offset!");
static_assert(offsetof(UGhostfaceStatusData, StalkingProgress) == 0x000034, "Member 'UGhostfaceStatusData::StalkingProgress' has a wrong offset!");

// Class DBDUIViewInterfaces.NightmareStatusData
// 0x0010 (0x0040 - 0x0030)
class UNightmareStatusData final : public UKillerStatusData
{
public:
	ESleepingUIState                              SleepingState;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SleepingProgress;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SleepProtectionRemainingDuration;                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NightmareStatusData">();
	}
	static class UNightmareStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNightmareStatusData>();
	}
};
static_assert(alignof(UNightmareStatusData) == 0x000008, "Wrong alignment on UNightmareStatusData");
static_assert(sizeof(UNightmareStatusData) == 0x000040, "Wrong size on UNightmareStatusData");
static_assert(offsetof(UNightmareStatusData, SleepingState) == 0x000030, "Member 'UNightmareStatusData::SleepingState' has a wrong offset!");
static_assert(offsetof(UNightmareStatusData, SleepingProgress) == 0x000034, "Member 'UNightmareStatusData::SleepingProgress' has a wrong offset!");
static_assert(offsetof(UNightmareStatusData, SleepProtectionRemainingDuration) == 0x000038, "Member 'UNightmareStatusData::SleepProtectionRemainingDuration' has a wrong offset!");

// Class DBDUIViewInterfaces.PigStatusData
// 0x0008 (0x0038 - 0x0030)
class UPigStatusData final : public UKillerStatusData
{
public:
	EReverseBearTrapUIState                       ReverseBearTrapState;                              // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimerProgress;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PigStatusData">();
	}
	static class UPigStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPigStatusData>();
	}
};
static_assert(alignof(UPigStatusData) == 0x000008, "Wrong alignment on UPigStatusData");
static_assert(sizeof(UPigStatusData) == 0x000038, "Wrong size on UPigStatusData");
static_assert(offsetof(UPigStatusData, ReverseBearTrapState) == 0x000030, "Member 'UPigStatusData::ReverseBearTrapState' has a wrong offset!");
static_assert(offsetof(UPigStatusData, TimerProgress) == 0x000034, "Member 'UPigStatusData::TimerProgress' has a wrong offset!");

// Class DBDUIViewInterfaces.PlagueStatusData
// 0x0008 (0x0038 - 0x0030)
class UPlagueStatusData final : public UKillerStatusData
{
public:
	ESicknessLevel                                SicknessLevel;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SicknessProgress;                                  // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlagueStatusData">();
	}
	static class UPlagueStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlagueStatusData>();
	}
};
static_assert(alignof(UPlagueStatusData) == 0x000008, "Wrong alignment on UPlagueStatusData");
static_assert(sizeof(UPlagueStatusData) == 0x000038, "Wrong size on UPlagueStatusData");
static_assert(offsetof(UPlagueStatusData, SicknessLevel) == 0x000030, "Member 'UPlagueStatusData::SicknessLevel' has a wrong offset!");
static_assert(offsetof(UPlagueStatusData, SicknessProgress) == 0x000034, "Member 'UPlagueStatusData::SicknessProgress' has a wrong offset!");

// Class DBDUIViewInterfaces.TricksterStatusData
// 0x0010 (0x0040 - 0x0030)
class UTricksterStatusData final : public UKillerStatusData
{
public:
	float                                         CurrentLacerationLevel;                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumLacerationLevel;                            // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDangerousLacerationLevel;                        // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WasRecentlyDamagedByLaceration;                    // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TricksterStatusData">();
	}
	static class UTricksterStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTricksterStatusData>();
	}
};
static_assert(alignof(UTricksterStatusData) == 0x000008, "Wrong alignment on UTricksterStatusData");
static_assert(sizeof(UTricksterStatusData) == 0x000040, "Wrong size on UTricksterStatusData");
static_assert(offsetof(UTricksterStatusData, CurrentLacerationLevel) == 0x000030, "Member 'UTricksterStatusData::CurrentLacerationLevel' has a wrong offset!");
static_assert(offsetof(UTricksterStatusData, MaximumLacerationLevel) == 0x000034, "Member 'UTricksterStatusData::MaximumLacerationLevel' has a wrong offset!");
static_assert(offsetof(UTricksterStatusData, IsDangerousLacerationLevel) == 0x000038, "Member 'UTricksterStatusData::IsDangerousLacerationLevel' has a wrong offset!");
static_assert(offsetof(UTricksterStatusData, WasRecentlyDamagedByLaceration) == 0x000039, "Member 'UTricksterStatusData::WasRecentlyDamagedByLaceration' has a wrong offset!");

// Class DBDUIViewInterfaces.K24StatusData
// 0x0008 (0x0038 - 0x0030)
class UK24StatusData final : public UKillerStatusData
{
public:
	bool                                          IsContaminated;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24StatusData">();
	}
	static class UK24StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24StatusData>();
	}
};
static_assert(alignof(UK24StatusData) == 0x000008, "Wrong alignment on UK24StatusData");
static_assert(sizeof(UK24StatusData) == 0x000038, "Wrong size on UK24StatusData");
static_assert(offsetof(UK24StatusData, IsContaminated) == 0x000030, "Member 'UK24StatusData::IsContaminated' has a wrong offset!");

// Class DBDUIViewInterfaces.K25StatusData
// 0x0008 (0x0038 - 0x0030)
class UK25StatusData final : public UKillerStatusData
{
public:
	float                                         ChainHuntProgressPercentage;                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHoldingLamentConfiguration;                      // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSolvingLamentConfiguration;                      // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K25StatusData">();
	}
	static class UK25StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK25StatusData>();
	}
};
static_assert(alignof(UK25StatusData) == 0x000008, "Wrong alignment on UK25StatusData");
static_assert(sizeof(UK25StatusData) == 0x000038, "Wrong size on UK25StatusData");
static_assert(offsetof(UK25StatusData, ChainHuntProgressPercentage) == 0x000030, "Member 'UK25StatusData::ChainHuntProgressPercentage' has a wrong offset!");
static_assert(offsetof(UK25StatusData, IsHoldingLamentConfiguration) == 0x000034, "Member 'UK25StatusData::IsHoldingLamentConfiguration' has a wrong offset!");
static_assert(offsetof(UK25StatusData, IsSolvingLamentConfiguration) == 0x000035, "Member 'UK25StatusData::IsSolvingLamentConfiguration' has a wrong offset!");

// Class DBDUIViewInterfaces.K26StatusData
// 0x0008 (0x0038 - 0x0030)
class UK26StatusData final : public UKillerStatusData
{
public:
	bool                                          IsCrowAttached;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26StatusData">();
	}
	static class UK26StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26StatusData>();
	}
};
static_assert(alignof(UK26StatusData) == 0x000008, "Wrong alignment on UK26StatusData");
static_assert(sizeof(UK26StatusData) == 0x000038, "Wrong size on UK26StatusData");
static_assert(offsetof(UK26StatusData, IsCrowAttached) == 0x000030, "Member 'UK26StatusData::IsCrowAttached' has a wrong offset!");

// Class DBDUIViewInterfaces.TheOnryoStatusData
// 0x0010 (0x0040 - 0x0030)
class UTheOnryoStatusData final : public UKillerStatusData
{
public:
	bool                                          IsCondemnedActive;                                 // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CondemnedProgress;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFullCondemned;                                   // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHoldingTape;                                     // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TheOnryoStatusData">();
	}
	static class UTheOnryoStatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTheOnryoStatusData>();
	}
};
static_assert(alignof(UTheOnryoStatusData) == 0x000008, "Wrong alignment on UTheOnryoStatusData");
static_assert(sizeof(UTheOnryoStatusData) == 0x000040, "Wrong size on UTheOnryoStatusData");
static_assert(offsetof(UTheOnryoStatusData, IsCondemnedActive) == 0x000030, "Member 'UTheOnryoStatusData::IsCondemnedActive' has a wrong offset!");
static_assert(offsetof(UTheOnryoStatusData, CondemnedProgress) == 0x000034, "Member 'UTheOnryoStatusData::CondemnedProgress' has a wrong offset!");
static_assert(offsetof(UTheOnryoStatusData, IsFullCondemned) == 0x000038, "Member 'UTheOnryoStatusData::IsFullCondemned' has a wrong offset!");
static_assert(offsetof(UTheOnryoStatusData, IsHoldingTape) == 0x000039, "Member 'UTheOnryoStatusData::IsHoldingTape' has a wrong offset!");

// Class DBDUIViewInterfaces.K28StatusData
// 0x0008 (0x0038 - 0x0030)
class UK28StatusData final : public UKillerStatusData
{
public:
	float                                         DayNightCycleProgressPercentage;                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDaytime;                                         // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTransitioningToNighttime;                        // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNighttime;                                       // 0x0036(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTransitioningToDaytime;                          // 0x0037(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K28StatusData">();
	}
	static class UK28StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK28StatusData>();
	}
};
static_assert(alignof(UK28StatusData) == 0x000008, "Wrong alignment on UK28StatusData");
static_assert(sizeof(UK28StatusData) == 0x000038, "Wrong size on UK28StatusData");
static_assert(offsetof(UK28StatusData, DayNightCycleProgressPercentage) == 0x000030, "Member 'UK28StatusData::DayNightCycleProgressPercentage' has a wrong offset!");
static_assert(offsetof(UK28StatusData, IsDaytime) == 0x000034, "Member 'UK28StatusData::IsDaytime' has a wrong offset!");
static_assert(offsetof(UK28StatusData, IsTransitioningToNighttime) == 0x000035, "Member 'UK28StatusData::IsTransitioningToNighttime' has a wrong offset!");
static_assert(offsetof(UK28StatusData, IsNighttime) == 0x000036, "Member 'UK28StatusData::IsNighttime' has a wrong offset!");
static_assert(offsetof(UK28StatusData, IsTransitioningToDaytime) == 0x000037, "Member 'UK28StatusData::IsTransitioningToDaytime' has a wrong offset!");

// Class DBDUIViewInterfaces.K29StatusData
// 0x0008 (0x0038 - 0x0030)
class UK29StatusData final : public UKillerStatusData
{
public:
	float                                         InfectionPercentage;                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInfected;                                        // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInfectionActive;                                 // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInfectionCritical;                               // 0x0036(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37[0x1];                                       // 0x0037(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29StatusData">();
	}
	static class UK29StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29StatusData>();
	}
};
static_assert(alignof(UK29StatusData) == 0x000008, "Wrong alignment on UK29StatusData");
static_assert(sizeof(UK29StatusData) == 0x000038, "Wrong size on UK29StatusData");
static_assert(offsetof(UK29StatusData, InfectionPercentage) == 0x000030, "Member 'UK29StatusData::InfectionPercentage' has a wrong offset!");
static_assert(offsetof(UK29StatusData, IsInfected) == 0x000034, "Member 'UK29StatusData::IsInfected' has a wrong offset!");
static_assert(offsetof(UK29StatusData, IsInfectionActive) == 0x000035, "Member 'UK29StatusData::IsInfectionActive' has a wrong offset!");
static_assert(offsetof(UK29StatusData, IsInfectionCritical) == 0x000036, "Member 'UK29StatusData::IsInfectionCritical' has a wrong offset!");

// Class DBDUIViewInterfaces.K30StatusData
// 0x0008 (0x0038 - 0x0030)
class UK30StatusData final : public UKillerStatusData
{
public:
	float                                         HuntRemainingPercentage;                           // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHuntingSurvivor;                                 // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K30StatusData">();
	}
	static class UK30StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK30StatusData>();
	}
};
static_assert(alignof(UK30StatusData) == 0x000008, "Wrong alignment on UK30StatusData");
static_assert(sizeof(UK30StatusData) == 0x000038, "Wrong size on UK30StatusData");
static_assert(offsetof(UK30StatusData, HuntRemainingPercentage) == 0x000030, "Member 'UK30StatusData::HuntRemainingPercentage' has a wrong offset!");
static_assert(offsetof(UK30StatusData, IsHuntingSurvivor) == 0x000034, "Member 'UK30StatusData::IsHuntingSurvivor' has a wrong offset!");

// Class DBDUIViewInterfaces.K31StatusData
// 0x0010 (0x0040 - 0x0030)
class UK31StatusData final : public UKillerStatusData
{
public:
	float                                         EffectProgressPercentage;                          // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAffectedByEffect;                                // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFullyAffectedByEffect;                           // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsClawTrapped;                                     // 0x0036(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsClawTrapBroadcasting;                            // 0x0037(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClawTrapBatteryPercentage;                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K31StatusData">();
	}
	static class UK31StatusData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK31StatusData>();
	}
};
static_assert(alignof(UK31StatusData) == 0x000008, "Wrong alignment on UK31StatusData");
static_assert(sizeof(UK31StatusData) == 0x000040, "Wrong size on UK31StatusData");
static_assert(offsetof(UK31StatusData, EffectProgressPercentage) == 0x000030, "Member 'UK31StatusData::EffectProgressPercentage' has a wrong offset!");
static_assert(offsetof(UK31StatusData, IsAffectedByEffect) == 0x000034, "Member 'UK31StatusData::IsAffectedByEffect' has a wrong offset!");
static_assert(offsetof(UK31StatusData, IsFullyAffectedByEffect) == 0x000035, "Member 'UK31StatusData::IsFullyAffectedByEffect' has a wrong offset!");
static_assert(offsetof(UK31StatusData, IsClawTrapped) == 0x000036, "Member 'UK31StatusData::IsClawTrapped' has a wrong offset!");
static_assert(offsetof(UK31StatusData, IsClawTrapBroadcasting) == 0x000037, "Member 'UK31StatusData::IsClawTrapBroadcasting' has a wrong offset!");
static_assert(offsetof(UK31StatusData, ClawTrapBatteryPercentage) == 0x000038, "Member 'UK31StatusData::ClawTrapBatteryPercentage' has a wrong offset!");

// Class DBDUIViewInterfaces.PlayerStatusViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPlayerStatusViewInterface final
{
public:
	void ClearData();
	void EnableChasesMode(const bool isChased);
	void HideSurvivorActivity();
	void PlayHookEscapeFailedAnimation();
	void PlayTimerAnimation();
	void SetCampProgress(float value, bool isLocalPlayerAKiller);
	void SetData(const struct FPlayerStatusViewData& data);
	void SetKiller(const struct FGameplayTag& killerTag);
	void SetPlayerNameVisibility(bool visible);
	void SetTimerProgress(float value, bool isDeepWound);
	void ShowSurvivorActivity(const TSoftObjectPtr<class UTexture2D>& activityIcon, const bool shouldDisplayProgress);
	void TriggerAfflictionHit();
	void UpdateSurvivorActivityProgress(const float progress);
	void UpdateSurvivorSpecificPingIcon(const EConnectionQuality& connectionQuality);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStatusViewInterface">();
	}
	static class IPlayerStatusViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerStatusViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPlayerStatusViewInterface) == 0x000001, "Wrong alignment on IPlayerStatusViewInterface");
static_assert(sizeof(IPlayerStatusViewInterface) == 0x000001, "Wrong size on IPlayerStatusViewInterface");

// Class DBDUIViewInterfaces.PowerBundleViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPowerBundleViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FPowerBundleViewData& powerBundleViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerBundleViewInterface">();
	}
	static class IPowerBundleViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPowerBundleViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPowerBundleViewInterface) == 0x000001, "Wrong alignment on IPowerBundleViewInterface");
static_assert(sizeof(IPowerBundleViewInterface) == 0x000001, "Wrong size on IPowerBundleViewInterface");

// Class DBDUIViewInterfaces.PowerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IPowerViewInterface final
{
public:
	void ClearData();
	void SetData(const struct FPowerViewData& powerViewData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerViewInterface">();
	}
	static class IPowerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPowerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPowerViewInterface) == 0x000001, "Wrong alignment on IPowerViewInterface");
static_assert(sizeof(IPowerViewInterface) == 0x000001, "Wrong size on IPowerViewInterface");

// Class DBDUIViewInterfaces.ScreenIndicatorsContainerViewInterface
// 0x0000 (0x0000 - 0x0000)
class IScreenIndicatorsContainerViewInterface final
{
public:
	void RemoveDirectionIndicator(const class FString& id);
	void ShowDirectionIndicator(const struct FScreenIndicatorViewData& data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenIndicatorsContainerViewInterface">();
	}
	static class IScreenIndicatorsContainerViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IScreenIndicatorsContainerViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IScreenIndicatorsContainerViewInterface) == 0x000001, "Wrong alignment on IScreenIndicatorsContainerViewInterface");
static_assert(sizeof(IScreenIndicatorsContainerViewInterface) == 0x000001, "Wrong size on IScreenIndicatorsContainerViewInterface");

// Class DBDUIViewInterfaces.SkillCheckViewInterface
// 0x0000 (0x0000 - 0x0000)
class ISkillCheckViewInterface final
{
public:
	void ApplyScaleFactor(float scale);
	void HideSkillCheck();
	void ShowSkillCheck(const struct FSkillCheckViewData& skillCheckData);
	void ShowSkillCheckFail();
	void ShowSkillCheckSuccess(bool isBonus);
	void UpdatePositionOffset(int32 x, int32 y);
	void UpdateProgress(float value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillCheckViewInterface">();
	}
	static class ISkillCheckViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISkillCheckViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISkillCheckViewInterface) == 0x000001, "Wrong alignment on ISkillCheckViewInterface");
static_assert(sizeof(ISkillCheckViewInterface) == 0x000001, "Wrong size on ISkillCheckViewInterface");

// Class DBDUIViewInterfaces.SpectateBarViewInterface
// 0x0000 (0x0000 - 0x0000)
class ISpectateBarViewInterface final
{
public:
	void SetArrowsVisibility(const bool isVisible);
	void SetSpectateBarVisibility(const bool isVisible);
	void SetSpectatedName(const class FString& playerName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectateBarViewInterface">();
	}
	static class ISpectateBarViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpectateBarViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISpectateBarViewInterface) == 0x000001, "Wrong alignment on ISpectateBarViewInterface");
static_assert(sizeof(ISpectateBarViewInterface) == 0x000001, "Wrong size on ISpectateBarViewInterface");

// Class DBDUIViewInterfaces.StartSequenceViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStartSequenceViewInterface final
{
public:
	void HideStartSequence();
	void ShowStartSequence(const struct FStartSequenceViewData& data);

	bool GetIsStartSequenceVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartSequenceViewInterface">();
	}
	static class IStartSequenceViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStartSequenceViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStartSequenceViewInterface) == 0x000001, "Wrong alignment on IStartSequenceViewInterface");
static_assert(sizeof(IStartSequenceViewInterface) == 0x000001, "Wrong size on IStartSequenceViewInterface");

// Class DBDUIViewInterfaces.StatusEffectViewInterface
// 0x0000 (0x0000 - 0x0000)
class IStatusEffectViewInterface final
{
public:
	void RemoveExistingStatusEffect(const class FName& statusEffectId);
	void ShowActiveStatusEffect(const struct FStatusEffectViewData& statusEffectData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectViewInterface">();
	}
	static class IStatusEffectViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStatusEffectViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStatusEffectViewInterface) == 0x000001, "Wrong alignment on IStatusEffectViewInterface");
static_assert(sizeof(IStatusEffectViewInterface) == 0x000001, "Wrong size on IStatusEffectViewInterface");

// Class DBDUIViewInterfaces.SubtitlesViewInterface
// 0x0000 (0x0000 - 0x0000)
class ISubtitlesViewInterface final
{
public:
	void HideSubtitles();
	void SetConstrainAspectRatioChanged(bool isConstrained, float aspectRatio);
	void SetSubtitlesBackgroundOpacity(ESubtitlesBackgroundOpacity opacity);
	void SetSubtitlesPosition(ESubtitlesPosition position);
	void SetSubtitlesSize(ESubtitlesSize size);
	void ShowSubtitle(const class FText& subtitleText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitlesViewInterface">();
	}
	static class ISubtitlesViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISubtitlesViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISubtitlesViewInterface) == 0x000001, "Wrong alignment on ISubtitlesViewInterface");
static_assert(sizeof(ISubtitlesViewInterface) == 0x000001, "Wrong size on ISubtitlesViewInterface");

// Class DBDUIViewInterfaces.TemplateViewInterface
// 0x0000 (0x0000 - 0x0000)
class ITemplateViewInterface final
{
public:
	void TemplateExampleFunction(const struct FTemplateViewData& templateData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TemplateViewInterface">();
	}
	static class ITemplateViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITemplateViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITemplateViewInterface) == 0x000001, "Wrong alignment on ITemplateViewInterface");
static_assert(sizeof(ITemplateViewInterface) == 0x000001, "Wrong size on ITemplateViewInterface");

// Class DBDUIViewInterfaces.TestBuildFlagViewInterface
// 0x0000 (0x0000 - 0x0000)
class ITestBuildFlagViewInterface final
{
public:
	void UpdateWidget(ETestBuildType testBuildType, ETestBuildFlagPosition testBuildFlagPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestBuildFlagViewInterface">();
	}
	static class ITestBuildFlagViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITestBuildFlagViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITestBuildFlagViewInterface) == 0x000001, "Wrong alignment on ITestBuildFlagViewInterface");
static_assert(sizeof(ITestBuildFlagViewInterface) == 0x000001, "Wrong size on ITestBuildFlagViewInterface");

// Class DBDUIViewInterfaces.TutorialHighlightViewInterface
// 0x0000 (0x0000 - 0x0000)
class ITutorialHighlightViewInterface final
{
public:
	void SetTutorialHighlight(const bool show, const EHudComponent& componentId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialHighlightViewInterface">();
	}
	static class ITutorialHighlightViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITutorialHighlightViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITutorialHighlightViewInterface) == 0x000001, "Wrong alignment on ITutorialHighlightViewInterface");
static_assert(sizeof(ITutorialHighlightViewInterface) == 0x000001, "Wrong size on ITutorialHighlightViewInterface");

// Class DBDUIViewInterfaces.TutorialMysteryNoteViewInterface
// 0x0000 (0x0000 - 0x0000)
class ITutorialMysteryNoteViewInterface final
{
public:
	void HideMysteryNote();
	void ShowMysteryNote(const struct FNotifTutorialPopupViewData& notifData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialMysteryNoteViewInterface">();
	}
	static class ITutorialMysteryNoteViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITutorialMysteryNoteViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITutorialMysteryNoteViewInterface) == 0x000001, "Wrong alignment on ITutorialMysteryNoteViewInterface");
static_assert(sizeof(ITutorialMysteryNoteViewInterface) == 0x000001, "Wrong size on ITutorialMysteryNoteViewInterface");

// Class DBDUIViewInterfaces.TutorialObjectivesViewInterface
// 0x0000 (0x0000 - 0x0000)
class ITutorialObjectivesViewInterface final
{
public:
	void AddTutorialObjective(const class FName& id, const struct FTutorialObjectivesViewData& interactionPromptViewData);
	void CompleteTutorialObjective(const class FName& id, bool removeAfterCompletion);
	void RemoveAllTutorialObjectives();
	void RemoveTutorialObjective(const class FName& id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialObjectivesViewInterface">();
	}
	static class ITutorialObjectivesViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITutorialObjectivesViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITutorialObjectivesViewInterface) == 0x000001, "Wrong alignment on ITutorialObjectivesViewInterface");
static_assert(sizeof(ITutorialObjectivesViewInterface) == 0x000001, "Wrong size on ITutorialObjectivesViewInterface");

// Class DBDUIViewInterfaces.TutorialPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class ITutorialPopupViewInterface final
{
public:
	void HideTutorialPopup(bool playSoundEffect);
	void ShowNotifTutorialPopup(const struct FNotifTutorialPopupViewData& notifTutoData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialPopupViewInterface">();
	}
	static class ITutorialPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITutorialPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITutorialPopupViewInterface) == 0x000001, "Wrong alignment on ITutorialPopupViewInterface");
static_assert(sizeof(ITutorialPopupViewInterface) == 0x000001, "Wrong size on ITutorialPopupViewInterface");

// Class DBDUIViewInterfaces.UIUtilities
// 0x0000 (0x0030 - 0x0030)
class UUIUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void ConvertArchiveCurrentAndMaxProgressionInPercentage(int32& outCurrentProgression, int32& outMaxProgression);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIUtilities">();
	}
	static class UUIUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIUtilities>();
	}
};
static_assert(alignof(UUIUtilities) == 0x000008, "Wrong alignment on UUIUtilities");
static_assert(sizeof(UUIUtilities) == 0x000030, "Wrong size on UUIUtilities");

// Class DBDUIViewInterfaces.UnlockPersonalPerksPopupViewData
// 0x0010 (0x0200 - 0x01F0)
class UUnlockPersonalPerksPopupViewData final : public UGenericPopupViewData
{
public:
	TArray<class UMenuPerkViewData*>              PerksData;                                         // 0x01F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnlockPersonalPerksPopupViewData">();
	}
	static class UUnlockPersonalPerksPopupViewData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnlockPersonalPerksPopupViewData>();
	}
};
static_assert(alignof(UUnlockPersonalPerksPopupViewData) == 0x000010, "Wrong alignment on UUnlockPersonalPerksPopupViewData");
static_assert(sizeof(UUnlockPersonalPerksPopupViewData) == 0x000200, "Wrong size on UUnlockPersonalPerksPopupViewData");
static_assert(offsetof(UUnlockPersonalPerksPopupViewData, PerksData) == 0x0001F0, "Member 'UUnlockPersonalPerksPopupViewData::PerksData' has a wrong offset!");

// Class DBDUIViewInterfaces.UnlockPersonalPerksPopupViewInterface
// 0x0000 (0x0000 - 0x0000)
class IUnlockPersonalPerksPopupViewInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnlockPersonalPerksPopupViewInterface">();
	}
	static class IUnlockPersonalPerksPopupViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUnlockPersonalPerksPopupViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IUnlockPersonalPerksPopupViewInterface) == 0x000001, "Wrong alignment on IUnlockPersonalPerksPopupViewInterface");
static_assert(sizeof(IUnlockPersonalPerksPopupViewInterface) == 0x000001, "Wrong size on IUnlockPersonalPerksPopupViewInterface");

// Class DBDUIViewInterfaces.WatermarkViewInterface
// 0x0000 (0x0000 - 0x0000)
class IWatermarkViewInterface final
{
public:
	void SetSteamValuesText(const class FString& SteamName, const class FString& SteamId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WatermarkViewInterface">();
	}
	static class IWatermarkViewInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWatermarkViewInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IWatermarkViewInterface) == 0x000001, "Wrong alignment on IWatermarkViewInterface");
static_assert(sizeof(IWatermarkViewInterface) == 0x000001, "Wrong size on IWatermarkViewInterface");

}

