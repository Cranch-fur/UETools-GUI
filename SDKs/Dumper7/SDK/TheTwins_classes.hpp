#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheTwins

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "DBDCompetence_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "DataTableUtilities_structs.hpp"
#include "DBDGameplay_classes.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDInteraction_classes.hpp"
#include "StatSystem_structs.hpp"
#include "DBDBots_classes.hpp"
#include "SystemUtilities_structs.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "DBDAnimation_classes.hpp"
#include "TheTwins_structs.hpp"
#include "Competence_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "DBDAttack_classes.hpp"


namespace SDK
{

// Class TheTwins.Addon_K22Power_10
// 0x0000 (0x02C8 - 0x02C8)
class UAddon_K22Power_10 final : public UOnEventBaseAddon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_10">();
	}
	static class UAddon_K22Power_10* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_10>();
	}
};
static_assert(alignof(UAddon_K22Power_10) == 0x000008, "Wrong alignment on UAddon_K22Power_10");
static_assert(sizeof(UAddon_K22Power_10) == 0x0002C8, "Wrong size on UAddon_K22Power_10");

// Class TheTwins.Addon_K22Power_11
// 0x0008 (0x02D0 - 0x02C8)
class UAddon_K22Power_11 final : public USpawnEffectsOnAllSurvivorsBaseAddon
{
public:
	float                                         _increaseRemoveTwinTime;                           // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_11">();
	}
	static class UAddon_K22Power_11* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_11>();
	}
};
static_assert(alignof(UAddon_K22Power_11) == 0x000008, "Wrong alignment on UAddon_K22Power_11");
static_assert(sizeof(UAddon_K22Power_11) == 0x0002D0, "Wrong size on UAddon_K22Power_11");
static_assert(offsetof(UAddon_K22Power_11, _increaseRemoveTwinTime) == 0x0002C8, "Member 'UAddon_K22Power_11::_increaseRemoveTwinTime' has a wrong offset!");

// Class TheTwins.Addon_K22Power_14
// 0x0008 (0x02D0 - 0x02C8)
class UAddon_K22Power_14 final : public UOnEventBaseAddon
{
public:
	float                                         _brokenDuration;                                   // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_14">();
	}
	static class UAddon_K22Power_14* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_14>();
	}
};
static_assert(alignof(UAddon_K22Power_14) == 0x000008, "Wrong alignment on UAddon_K22Power_14");
static_assert(sizeof(UAddon_K22Power_14) == 0x0002D0, "Wrong size on UAddon_K22Power_14");
static_assert(offsetof(UAddon_K22Power_14, _brokenDuration) == 0x0002C8, "Member 'UAddon_K22Power_14::_brokenDuration' has a wrong offset!");

// Class TheTwins.Addon_K22Power_16
// 0x0000 (0x02C8 - 0x02C8)
class UAddon_K22Power_16 final : public UOnEventBaseAddon
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_16">();
	}
	static class UAddon_K22Power_16* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_16>();
	}
};
static_assert(alignof(UAddon_K22Power_16) == 0x000008, "Wrong alignment on UAddon_K22Power_16");
static_assert(sizeof(UAddon_K22Power_16) == 0x0002C8, "Wrong size on UAddon_K22Power_16");

// Class TheTwins.Addon_K22Power_17
// 0x0030 (0x02F8 - 0x02C8)
class UAddon_K22Power_17 final : public USpawnEffectsOnAllSurvivorsBaseAddon
{
public:
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _lingerDuration;                                   // 0x02D0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnTwinSet(class AConjoinedTwin* twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_17">();
	}
	static class UAddon_K22Power_17* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_17>();
	}
};
static_assert(alignof(UAddon_K22Power_17) == 0x000008, "Wrong alignment on UAddon_K22Power_17");
static_assert(sizeof(UAddon_K22Power_17) == 0x0002F8, "Wrong size on UAddon_K22Power_17");
static_assert(offsetof(UAddon_K22Power_17, _lingerDuration) == 0x0002D0, "Member 'UAddon_K22Power_17::_lingerDuration' has a wrong offset!");

// Class TheTwins.Addon_K22Power_18
// 0x0008 (0x02D0 - 0x02C8)
class UAddon_K22Power_18 final : public UOnEventBaseAddon
{
public:
	float                                         _auraRevealedDuration;                             // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_18">();
	}
	static class UAddon_K22Power_18* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_18>();
	}
};
static_assert(alignof(UAddon_K22Power_18) == 0x000008, "Wrong alignment on UAddon_K22Power_18");
static_assert(sizeof(UAddon_K22Power_18) == 0x0002D0, "Wrong size on UAddon_K22Power_18");
static_assert(offsetof(UAddon_K22Power_18, _auraRevealedDuration) == 0x0002C8, "Member 'UAddon_K22Power_18::_auraRevealedDuration' has a wrong offset!");

// Class TheTwins.Addon_K22Power_19
// 0x0010 (0x02D8 - 0x02C8)
class UAddon_K22Power_19 final : public UOnEventBaseAddon
{
public:
	float                                         _undetectableDuration;                             // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _undetectableEffectClass;                          // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_19">();
	}
	static class UAddon_K22Power_19* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_19>();
	}
};
static_assert(alignof(UAddon_K22Power_19) == 0x000008, "Wrong alignment on UAddon_K22Power_19");
static_assert(sizeof(UAddon_K22Power_19) == 0x0002D8, "Wrong size on UAddon_K22Power_19");
static_assert(offsetof(UAddon_K22Power_19, _undetectableDuration) == 0x0002C8, "Member 'UAddon_K22Power_19::_undetectableDuration' has a wrong offset!");
static_assert(offsetof(UAddon_K22Power_19, _undetectableEffectClass) == 0x0002D0, "Member 'UAddon_K22Power_19::_undetectableEffectClass' has a wrong offset!");

// Class TheTwins.Addon_K22Power_20
// 0x0008 (0x02D0 - 0x02C8)
class UAddon_K22Power_20 final : public UOnEventBaseAddon
{
public:
	float                                         _exposedDuration;                                  // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_20">();
	}
	static class UAddon_K22Power_20* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_20>();
	}
};
static_assert(alignof(UAddon_K22Power_20) == 0x000008, "Wrong alignment on UAddon_K22Power_20");
static_assert(sizeof(UAddon_K22Power_20) == 0x0002D0, "Wrong size on UAddon_K22Power_20");
static_assert(offsetof(UAddon_K22Power_20, _exposedDuration) == 0x0002C8, "Member 'UAddon_K22Power_20::_exposedDuration' has a wrong offset!");

// Class TheTwins.Addon_K22Power_8
// 0x0008 (0x02D0 - 0x02C8)
class UAddon_K22Power_8 final : public USpawnEffectsOnAllSurvivorsBaseAddon
{
public:
	float                                         _increaseDestroyTwinTime;                          // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_8">();
	}
	static class UAddon_K22Power_8* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_8>();
	}
};
static_assert(alignof(UAddon_K22Power_8) == 0x000008, "Wrong alignment on UAddon_K22Power_8");
static_assert(sizeof(UAddon_K22Power_8) == 0x0002D0, "Wrong size on UAddon_K22Power_8");
static_assert(offsetof(UAddon_K22Power_8, _increaseDestroyTwinTime) == 0x0002C8, "Member 'UAddon_K22Power_8::_increaseDestroyTwinTime' has a wrong offset!");

// Class TheTwins.Addon_K22Power_9
// 0x0008 (0x02D0 - 0x02C8)
class UAddon_K22Power_9 final : public UOnEventBaseAddon
{
public:
	float                                         _blindnessDuration;                                // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K22Power_9">();
	}
	static class UAddon_K22Power_9* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K22Power_9>();
	}
};
static_assert(alignof(UAddon_K22Power_9) == 0x000008, "Wrong alignment on UAddon_K22Power_9");
static_assert(sizeof(UAddon_K22Power_9) == 0x0002D0, "Wrong size on UAddon_K22Power_9");
static_assert(offsetof(UAddon_K22Power_9, _blindnessDuration) == 0x0002C8, "Member 'UAddon_K22Power_9::_blindnessDuration' has a wrong offset!");

// Class TheTwins.AISkill_FindInteractable_CrushTwin
// 0x0068 (0x0190 - 0x0128)
class UAISkill_FindInteractable_CrushTwin final : public UAISkill_FindInteractable
{
public:
	uint8                                         Pad_128[0xC];                                      // 0x0128(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    _crushVictorGoalWeight;                            // 0x0134(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FAITunableParameter                    _recoveringTimeEstimationErrorMin;                 // 0x0144(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FAITunableParameter                    _recoveringTimeEstimationErrorMax;                 // 0x0154(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _destroyTwinMaxCharge;                             // 0x0168(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_CrushTwin">();
	}
	static class UAISkill_FindInteractable_CrushTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_CrushTwin>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_CrushTwin) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_CrushTwin");
static_assert(sizeof(UAISkill_FindInteractable_CrushTwin) == 0x000190, "Wrong size on UAISkill_FindInteractable_CrushTwin");
static_assert(offsetof(UAISkill_FindInteractable_CrushTwin, _crushVictorGoalWeight) == 0x000134, "Member 'UAISkill_FindInteractable_CrushTwin::_crushVictorGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_CrushTwin, _recoveringTimeEstimationErrorMin) == 0x000144, "Member 'UAISkill_FindInteractable_CrushTwin::_recoveringTimeEstimationErrorMin' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_CrushTwin, _recoveringTimeEstimationErrorMax) == 0x000154, "Member 'UAISkill_FindInteractable_CrushTwin::_recoveringTimeEstimationErrorMax' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_CrushTwin, _destroyTwinMaxCharge) == 0x000168, "Member 'UAISkill_FindInteractable_CrushTwin::_destroyTwinMaxCharge' has a wrong offset!");

// Class TheTwins.AISkill_Interaction_RemoveTwin
// 0x0028 (0x01A8 - 0x0180)
class UAISkill_Interaction_RemoveTwin final : public UAISkill_Interaction
{
public:
	struct FDBDTunableRowHandle                   _removeTwinMaxCharge;                              // 0x0180(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_RemoveTwin">();
	}
	static class UAISkill_Interaction_RemoveTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_RemoveTwin>();
	}
};
static_assert(alignof(UAISkill_Interaction_RemoveTwin) == 0x000008, "Wrong alignment on UAISkill_Interaction_RemoveTwin");
static_assert(sizeof(UAISkill_Interaction_RemoveTwin) == 0x0001A8, "Wrong size on UAISkill_Interaction_RemoveTwin");
static_assert(offsetof(UAISkill_Interaction_RemoveTwin, _removeTwinMaxCharge) == 0x000180, "Member 'UAISkill_Interaction_RemoveTwin::_removeTwinMaxCharge' has a wrong offset!");

// Class TheTwins.Appraisal
// 0x0018 (0x03E0 - 0x03C8)
class UAppraisal final : public UPerk
{
public:
	float                                         _chestSearchSpeedMultiplier[0x3];                  // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0xC];                                      // 0x03D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Appraisal">();
	}
	static class UAppraisal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAppraisal>();
	}
};
static_assert(alignof(UAppraisal) == 0x000008, "Wrong alignment on UAppraisal");
static_assert(sizeof(UAppraisal) == 0x0003E0, "Wrong size on UAppraisal");
static_assert(offsetof(UAppraisal, _chestSearchSpeedMultiplier) == 0x0003C8, "Member 'UAppraisal::_chestSearchSpeedMultiplier' has a wrong offset!");

// Class TheTwins.PossessPlayer
// 0x0030 (0x0770 - 0x0740)
class UPossessPlayer : public UChargeableInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _possessThePlayerMaxCharge;                        // 0x0740(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_768[0x8];                                      // 0x0768(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnPossessCancelled(class ADBDPlayer* player);
	void Cosmetic_OnPossessStart(class ADBDPlayer* player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PossessPlayer">();
	}
	static class UPossessPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPossessPlayer>();
	}
};
static_assert(alignof(UPossessPlayer) == 0x000010, "Wrong alignment on UPossessPlayer");
static_assert(sizeof(UPossessPlayer) == 0x000770, "Wrong size on UPossessPlayer");
static_assert(offsetof(UPossessPlayer, _possessThePlayerMaxCharge) == 0x000740, "Member 'UPossessPlayer::_possessThePlayerMaxCharge' has a wrong offset!");

// Class TheTwins.PossessTheConjoinedTwin
// 0x0060 (0x07D0 - 0x0770)
class UPossessTheConjoinedTwin : public UPossessPlayer
{
public:
	uint8                                         Pad_770[0x60];                                     // 0x0770(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPowerCollected(class ADBDPlayer* collector);
	void OnTwinSet(class AConjoinedTwin* twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PossessTheConjoinedTwin">();
	}
	static class UPossessTheConjoinedTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPossessTheConjoinedTwin>();
	}
};
static_assert(alignof(UPossessTheConjoinedTwin) == 0x000010, "Wrong alignment on UPossessTheConjoinedTwin");
static_assert(sizeof(UPossessTheConjoinedTwin) == 0x0007D0, "Wrong size on UPossessTheConjoinedTwin");

// Class TheTwins.AutoPossessTheConjoinedTwin
// 0x0000 (0x07D0 - 0x07D0)
class UAutoPossessTheConjoinedTwin final : public UPossessTheConjoinedTwin
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoPossessTheConjoinedTwin">();
	}
	static class UAutoPossessTheConjoinedTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoPossessTheConjoinedTwin>();
	}
};
static_assert(alignof(UAutoPossessTheConjoinedTwin) == 0x000010, "Wrong alignment on UAutoPossessTheConjoinedTwin");
static_assert(sizeof(UAutoPossessTheConjoinedTwin) == 0x0007D0, "Wrong size on UAutoPossessTheConjoinedTwin");

// Class TheTwins.BaseTwinInspectLocker
// 0x0030 (0x0680 - 0x0650)
class UBaseTwinInspectLocker : public UBaseLockerInteraction
{
public:
	struct FDBDTunableRowHandle                   _inspectInteractionTime;                           // 0x0648(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_670[0x10];                                     // 0x0670(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseTwinInspectLocker">();
	}
	static class UBaseTwinInspectLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseTwinInspectLocker>();
	}
};
static_assert(alignof(UBaseTwinInspectLocker) == 0x000010, "Wrong alignment on UBaseTwinInspectLocker");
static_assert(sizeof(UBaseTwinInspectLocker) == 0x000680, "Wrong size on UBaseTwinInspectLocker");
static_assert(offsetof(UBaseTwinInspectLocker, _inspectInteractionTime) == 0x000648, "Member 'UBaseTwinInspectLocker::_inspectInteractionTime' has a wrong offset!");

// Class TheTwins.BeingPossessedInteraction
// 0x0090 (0x07D0 - 0x0740)
#pragma pack(push, 0x1)
class alignas(0x10) UBeingPossessedInteraction : public UChargeableInteractionDefinition
{
public:
	struct FTunableStat                           _beingPossessedMaxCharge;                          // 0x0740(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C0[0x8];                                      // 0x07C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BeingPossessedInteraction">();
	}
	static class UBeingPossessedInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBeingPossessedInteraction>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBeingPossessedInteraction) == 0x000010, "Wrong alignment on UBeingPossessedInteraction");
static_assert(sizeof(UBeingPossessedInteraction) == 0x0007D0, "Wrong size on UBeingPossessedInteraction");
static_assert(offsetof(UBeingPossessedInteraction, _beingPossessedMaxCharge) == 0x000740, "Member 'UBeingPossessedInteraction::_beingPossessedMaxCharge' has a wrong offset!");

// Class TheTwins.BrotherBlindFlashlightableLightingStrategy
// 0x0010 (0x0050 - 0x0040)
class UBrotherBlindFlashlightableLightingStrategy final : public UBlindFlashlightableLightingStrategy
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrotherBlindFlashlightableLightingStrategy">();
	}
	static class UBrotherBlindFlashlightableLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrotherBlindFlashlightableLightingStrategy>();
	}
};
static_assert(alignof(UBrotherBlindFlashlightableLightingStrategy) == 0x000008, "Wrong alignment on UBrotherBlindFlashlightableLightingStrategy");
static_assert(sizeof(UBrotherBlindFlashlightableLightingStrategy) == 0x000050, "Wrong size on UBrotherBlindFlashlightableLightingStrategy");

// Class TheTwins.ChargeTwinJumpInteraction
// 0x0150 (0x0890 - 0x0740)
class UChargeTwinJumpInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_740[0x48];                                     // 0x0740(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _chargeJumpMaxCharge;                              // 0x0788(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _interactionViewPitchMax;                          // 0x07B0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _interactionViewPitchMin;                          // 0x07D8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_800[0x28];                                     // 0x0800(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _cancelCooldownTime;                               // 0x0828(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_850[0x40];                                     // 0x0850(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnJumpReadyChanged(class ADBDPlayer* twin, const bool ready);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeTwinJumpInteraction">();
	}
	static class UChargeTwinJumpInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeTwinJumpInteraction>();
	}
};
static_assert(alignof(UChargeTwinJumpInteraction) == 0x000010, "Wrong alignment on UChargeTwinJumpInteraction");
static_assert(sizeof(UChargeTwinJumpInteraction) == 0x000890, "Wrong size on UChargeTwinJumpInteraction");
static_assert(offsetof(UChargeTwinJumpInteraction, _chargeJumpMaxCharge) == 0x000788, "Member 'UChargeTwinJumpInteraction::_chargeJumpMaxCharge' has a wrong offset!");
static_assert(offsetof(UChargeTwinJumpInteraction, _interactionViewPitchMax) == 0x0007B0, "Member 'UChargeTwinJumpInteraction::_interactionViewPitchMax' has a wrong offset!");
static_assert(offsetof(UChargeTwinJumpInteraction, _interactionViewPitchMin) == 0x0007D8, "Member 'UChargeTwinJumpInteraction::_interactionViewPitchMin' has a wrong offset!");
static_assert(offsetof(UChargeTwinJumpInteraction, _cancelCooldownTime) == 0x000828, "Member 'UChargeTwinJumpInteraction::_cancelCooldownTime' has a wrong offset!");

// Class TheTwins.ConjoinedTwin
// 0x01F0 (0x1350 - 0x1160)
class AConjoinedTwin final : public ADBDPlayer
{
public:
	class URangeToActorsTrackerComponent*         _restrictedPossessionAreaTracker;                  // 0x1158(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTwinOutlineUpdateStrategy*             _twinOutlineUpdateStrategy;                        // 0x1160(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _twinLullabyAudioComponent;                        // 0x1168(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKillerBlindingFXComponent*             _twinBlindingFX;                                   // 0x1170(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TwinNoiseRange;                                    // 0x1178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_117C[0x4];                                     // 0x117C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomizedAudioComponent*              _customizedAudio;                                  // 0x1180(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAttackerComponent*                  _attackerComponent;                                // 0x1188(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxWalkSpeed;                                     // 0x1190(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitValidatorComponent*                 _hitValidator;                                     // 0x11B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitValidatorConfigurator*              _hitValidationConfigurator;                        // 0x11C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _gravityScale;                                     // 0x11C8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationMontageSlave*                 _animationFollower;                                // 0x11F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11F8[0x20];                                    // 0x11F8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _revealDurationOnAttached;                         // 0x1218(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTwinFirstPersonViewComponent*          _firstPersonViewComponent;                         // 0x1240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFlashlightableComponent*               _eyesFlashlightable;                               // 0x1248(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlindFlashlightTargetFXComponent*      _blindFlashlightTargetFXComponent;                 // 0x1250(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFirecrackerEffectHandlerComponent*     _firecrackerEffectHandlerComponent;                // 0x1258(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1260[0x8];                                     // 0x1260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFastTimer                             _flashlightBlindEvasionScoreTimer;                 // 0x1268(0x0030)(Transient, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _flashlightEvasionScoreCooldown;                   // 0x1298(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _twinsBloodhoundEffect;                            // 0x12C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _twinsRevealKillerAuraEffect;                      // 0x12C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _twinsDormantKillerInstinctEffect;                 // 0x12D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _twinsRevealAuraOnAttachedToSurvivorEffect;        // 0x12D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _twinsRevealAuraOnRecallReadyEffect;               // 0x12E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _timeDeafenedOnTriggerEffect;                      // 0x12E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTwinPossessNegationEffectComponent*    _twinPossessNegationEffectComponent;               // 0x12F0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12F8[0x58];                                    // 0x12F8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnFirecrackerInRangeBegin(const struct FFirecrackerEffectData& effectData);
	void Cosmetic_OnOnGroundUncontrolledChanged(bool onGroundAndUncontrolled);
	void OnFinishedPlayingEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Server_SendAttackInput(bool pressed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConjoinedTwin">();
	}
	static class AConjoinedTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AConjoinedTwin>();
	}
};
static_assert(alignof(AConjoinedTwin) == 0x000010, "Wrong alignment on AConjoinedTwin");
static_assert(sizeof(AConjoinedTwin) == 0x001350, "Wrong size on AConjoinedTwin");
static_assert(offsetof(AConjoinedTwin, _restrictedPossessionAreaTracker) == 0x001158, "Member 'AConjoinedTwin::_restrictedPossessionAreaTracker' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinOutlineUpdateStrategy) == 0x001160, "Member 'AConjoinedTwin::_twinOutlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinLullabyAudioComponent) == 0x001168, "Member 'AConjoinedTwin::_twinLullabyAudioComponent' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinBlindingFX) == 0x001170, "Member 'AConjoinedTwin::_twinBlindingFX' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, TwinNoiseRange) == 0x001178, "Member 'AConjoinedTwin::TwinNoiseRange' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _customizedAudio) == 0x001180, "Member 'AConjoinedTwin::_customizedAudio' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _attackerComponent) == 0x001188, "Member 'AConjoinedTwin::_attackerComponent' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _maxWalkSpeed) == 0x001190, "Member 'AConjoinedTwin::_maxWalkSpeed' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _hitValidator) == 0x0011B8, "Member 'AConjoinedTwin::_hitValidator' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _hitValidationConfigurator) == 0x0011C0, "Member 'AConjoinedTwin::_hitValidationConfigurator' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _gravityScale) == 0x0011C8, "Member 'AConjoinedTwin::_gravityScale' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _animationFollower) == 0x0011F0, "Member 'AConjoinedTwin::_animationFollower' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _revealDurationOnAttached) == 0x001218, "Member 'AConjoinedTwin::_revealDurationOnAttached' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _firstPersonViewComponent) == 0x001240, "Member 'AConjoinedTwin::_firstPersonViewComponent' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _eyesFlashlightable) == 0x001248, "Member 'AConjoinedTwin::_eyesFlashlightable' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _blindFlashlightTargetFXComponent) == 0x001250, "Member 'AConjoinedTwin::_blindFlashlightTargetFXComponent' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _firecrackerEffectHandlerComponent) == 0x001258, "Member 'AConjoinedTwin::_firecrackerEffectHandlerComponent' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _flashlightBlindEvasionScoreTimer) == 0x001268, "Member 'AConjoinedTwin::_flashlightBlindEvasionScoreTimer' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _flashlightEvasionScoreCooldown) == 0x001298, "Member 'AConjoinedTwin::_flashlightEvasionScoreCooldown' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinsBloodhoundEffect) == 0x0012C0, "Member 'AConjoinedTwin::_twinsBloodhoundEffect' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinsRevealKillerAuraEffect) == 0x0012C8, "Member 'AConjoinedTwin::_twinsRevealKillerAuraEffect' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinsDormantKillerInstinctEffect) == 0x0012D0, "Member 'AConjoinedTwin::_twinsDormantKillerInstinctEffect' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinsRevealAuraOnAttachedToSurvivorEffect) == 0x0012D8, "Member 'AConjoinedTwin::_twinsRevealAuraOnAttachedToSurvivorEffect' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinsRevealAuraOnRecallReadyEffect) == 0x0012E0, "Member 'AConjoinedTwin::_twinsRevealAuraOnRecallReadyEffect' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _timeDeafenedOnTriggerEffect) == 0x0012E8, "Member 'AConjoinedTwin::_timeDeafenedOnTriggerEffect' has a wrong offset!");
static_assert(offsetof(AConjoinedTwin, _twinPossessNegationEffectComponent) == 0x0012F0, "Member 'AConjoinedTwin::_twinPossessNegationEffectComponent' has a wrong offset!");

// Class TheTwins.ConjoinedTwinAnimInstance
// 0x00C0 (0x0600 - 0x0540)
class UConjoinedTwinAnimInstance final : public UPlayerAnimInstance
{
public:
	class AConjoinedTwin*                         _owningConjoinedTwin;                              // 0x0540(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _firstPersonView;                                  // 0x0548(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_549[0x3];                                      // 0x0549(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _forwardVelocity;                                  // 0x054C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lateralVelocity;                                  // 0x0550(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionAnimation                         _interactionType;                                  // 0x0554(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInAir;                                          // 0x0555(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x0556(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_557[0x1];                                      // 0x0557(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _idleTime;                                         // 0x0558(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttacking;                                      // 0x055C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55D[0x3];                                      // 0x055D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDAttackerComponent*                  _attackerComponent;                                // 0x0560(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTwinAttachmentComponent*               _twinAttachmentComponent;                          // 0x0568(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTwinLockerBlockerComponent*            _twinLockerBlockerComponent;                       // 0x0570(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animYaw;                                          // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animPitch;                                        // 0x057C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSpectator;                                      // 0x0580(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_581[0x3];                                      // 0x0581(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _animDirection;                                    // 0x0584(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animSpeed;                                        // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttachedToSister;                               // 0x058C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttachedToSurvivor;                             // 0x058D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttachedToFemaleSurvivor;                       // 0x058E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingTwinJump;                               // 0x058F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPossessing;                                     // 0x0590(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isWakingUpFromPossess;                            // 0x0591(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDormant;                                        // 0x0592(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingAutoPossessedAfterRelease;                 // 0x0593(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttachedToLocker;                               // 0x0594(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackSubstate                               _attackState;                                      // 0x0595(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_596[0x6A];                                     // 0x0596(0x006A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const class AConjoinedTwin* GetOwningConjoinedTwin() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConjoinedTwinAnimInstance">();
	}
	static class UConjoinedTwinAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConjoinedTwinAnimInstance>();
	}
};
static_assert(alignof(UConjoinedTwinAnimInstance) == 0x000010, "Wrong alignment on UConjoinedTwinAnimInstance");
static_assert(sizeof(UConjoinedTwinAnimInstance) == 0x000600, "Wrong size on UConjoinedTwinAnimInstance");
static_assert(offsetof(UConjoinedTwinAnimInstance, _owningConjoinedTwin) == 0x000540, "Member 'UConjoinedTwinAnimInstance::_owningConjoinedTwin' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _firstPersonView) == 0x000548, "Member 'UConjoinedTwinAnimInstance::_firstPersonView' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _forwardVelocity) == 0x00054C, "Member 'UConjoinedTwinAnimInstance::_forwardVelocity' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _lateralVelocity) == 0x000550, "Member 'UConjoinedTwinAnimInstance::_lateralVelocity' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _interactionType) == 0x000554, "Member 'UConjoinedTwinAnimInstance::_interactionType' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isInAir) == 0x000555, "Member 'UConjoinedTwinAnimInstance::_isInAir' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isIdle) == 0x000556, "Member 'UConjoinedTwinAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _idleTime) == 0x000558, "Member 'UConjoinedTwinAnimInstance::_idleTime' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isAttacking) == 0x00055C, "Member 'UConjoinedTwinAnimInstance::_isAttacking' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _attackerComponent) == 0x000560, "Member 'UConjoinedTwinAnimInstance::_attackerComponent' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _twinAttachmentComponent) == 0x000568, "Member 'UConjoinedTwinAnimInstance::_twinAttachmentComponent' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _twinLockerBlockerComponent) == 0x000570, "Member 'UConjoinedTwinAnimInstance::_twinLockerBlockerComponent' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _animYaw) == 0x000578, "Member 'UConjoinedTwinAnimInstance::_animYaw' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _animPitch) == 0x00057C, "Member 'UConjoinedTwinAnimInstance::_animPitch' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isSpectator) == 0x000580, "Member 'UConjoinedTwinAnimInstance::_isSpectator' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _animDirection) == 0x000584, "Member 'UConjoinedTwinAnimInstance::_animDirection' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _animSpeed) == 0x000588, "Member 'UConjoinedTwinAnimInstance::_animSpeed' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isAttachedToSister) == 0x00058C, "Member 'UConjoinedTwinAnimInstance::_isAttachedToSister' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isAttachedToSurvivor) == 0x00058D, "Member 'UConjoinedTwinAnimInstance::_isAttachedToSurvivor' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isAttachedToFemaleSurvivor) == 0x00058E, "Member 'UConjoinedTwinAnimInstance::_isAttachedToFemaleSurvivor' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isChargingTwinJump) == 0x00058F, "Member 'UConjoinedTwinAnimInstance::_isChargingTwinJump' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isPossessing) == 0x000590, "Member 'UConjoinedTwinAnimInstance::_isPossessing' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isWakingUpFromPossess) == 0x000591, "Member 'UConjoinedTwinAnimInstance::_isWakingUpFromPossess' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isDormant) == 0x000592, "Member 'UConjoinedTwinAnimInstance::_isDormant' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isBeingAutoPossessedAfterRelease) == 0x000593, "Member 'UConjoinedTwinAnimInstance::_isBeingAutoPossessedAfterRelease' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _isAttachedToLocker) == 0x000594, "Member 'UConjoinedTwinAnimInstance::_isAttachedToLocker' has a wrong offset!");
static_assert(offsetof(UConjoinedTwinAnimInstance, _attackState) == 0x000595, "Member 'UConjoinedTwinAnimInstance::_attackState' has a wrong offset!");

// Class TheTwins.ConjoinedTwinInteractable
// 0x0028 (0x0370 - 0x0348)
class AConjoinedTwinInteractable final : public APlayerInteractable
{
public:
	class UChargeableComponent*                   _possessKillerChargeable;                          // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _twinBeingPossessedChargeable;                     // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _chargeTwinJumpChargeable;                         // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _removeTwinChargeable;                             // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _destroyTwinChargeable;                            // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConjoinedTwinInteractable">();
	}
	static class AConjoinedTwinInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AConjoinedTwinInteractable>();
	}
};
static_assert(alignof(AConjoinedTwinInteractable) == 0x000008, "Wrong alignment on AConjoinedTwinInteractable");
static_assert(sizeof(AConjoinedTwinInteractable) == 0x000370, "Wrong size on AConjoinedTwinInteractable");
static_assert(offsetof(AConjoinedTwinInteractable, _possessKillerChargeable) == 0x000348, "Member 'AConjoinedTwinInteractable::_possessKillerChargeable' has a wrong offset!");
static_assert(offsetof(AConjoinedTwinInteractable, _twinBeingPossessedChargeable) == 0x000350, "Member 'AConjoinedTwinInteractable::_twinBeingPossessedChargeable' has a wrong offset!");
static_assert(offsetof(AConjoinedTwinInteractable, _chargeTwinJumpChargeable) == 0x000358, "Member 'AConjoinedTwinInteractable::_chargeTwinJumpChargeable' has a wrong offset!");
static_assert(offsetof(AConjoinedTwinInteractable, _removeTwinChargeable) == 0x000360, "Member 'AConjoinedTwinInteractable::_removeTwinChargeable' has a wrong offset!");
static_assert(offsetof(AConjoinedTwinInteractable, _destroyTwinChargeable) == 0x000368, "Member 'AConjoinedTwinInteractable::_destroyTwinChargeable' has a wrong offset!");

// Class TheTwins.ConjoinedTwinStateMachine
// 0x0000 (0x0130 - 0x0130)
class UConjoinedTwinStateMachine final : public UPlayerStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConjoinedTwinStateMachine">();
	}
	static class UConjoinedTwinStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConjoinedTwinStateMachine>();
	}
};
static_assert(alignof(UConjoinedTwinStateMachine) == 0x000010, "Wrong alignment on UConjoinedTwinStateMachine");
static_assert(sizeof(UConjoinedTwinStateMachine) == 0x000130, "Wrong size on UConjoinedTwinStateMachine");

// Class TheTwins.CoupDeGrace
// 0x0020 (0x03E8 - 0x03C8)
class UCoupDeGrace final : public UPerk
{
public:
	float                                         _lungeAttackAddDurationMultiplier[0x3];            // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGenerator*>                     _completedGenerators;                              // 0x03D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoupDeGrace">();
	}
	static class UCoupDeGrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoupDeGrace>();
	}
};
static_assert(alignof(UCoupDeGrace) == 0x000008, "Wrong alignment on UCoupDeGrace");
static_assert(sizeof(UCoupDeGrace) == 0x0003E8, "Wrong size on UCoupDeGrace");
static_assert(offsetof(UCoupDeGrace, _lungeAttackAddDurationMultiplier) == 0x0003C8, "Member 'UCoupDeGrace::_lungeAttackAddDurationMultiplier' has a wrong offset!");
static_assert(offsetof(UCoupDeGrace, _completedGenerators) == 0x0003D8, "Member 'UCoupDeGrace::_completedGenerators' has a wrong offset!");

// Class TheTwins.Deception
// 0x0038 (0x0400 - 0x03C8)
class UDeception final : public UPerk
{
public:
	float                                         _noScratchMarksDuration[0x3];                      // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _perkCooldownDuration[0x3];                        // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _statusEffect;                                     // 0x03E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UManualIconStrategy*                    _iconStrategy;                                     // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwningPlayerFakedEnteringLockerCosmetic();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Deception">();
	}
	static class UDeception* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeception>();
	}
};
static_assert(alignof(UDeception) == 0x000008, "Wrong alignment on UDeception");
static_assert(sizeof(UDeception) == 0x000400, "Wrong size on UDeception");
static_assert(offsetof(UDeception, _noScratchMarksDuration) == 0x0003C8, "Member 'UDeception::_noScratchMarksDuration' has a wrong offset!");
static_assert(offsetof(UDeception, _perkCooldownDuration) == 0x0003D4, "Member 'UDeception::_perkCooldownDuration' has a wrong offset!");
static_assert(offsetof(UDeception, _statusEffect) == 0x0003E0, "Member 'UDeception::_statusEffect' has a wrong offset!");
static_assert(offsetof(UDeception, _iconStrategy) == 0x0003F0, "Member 'UDeception::_iconStrategy' has a wrong offset!");

// Class TheTwins.DestroyTwin
// 0x0070 (0x07B0 - 0x0740)
class UDestroyTwin final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_740[0x40];                                     // 0x0740(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _destroyTwinMaxCharge;                             // 0x0780(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7A8[0x8];                                      // 0x07A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestroyTwin">();
	}
	static class UDestroyTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestroyTwin>();
	}
};
static_assert(alignof(UDestroyTwin) == 0x000010, "Wrong alignment on UDestroyTwin");
static_assert(sizeof(UDestroyTwin) == 0x0007B0, "Wrong size on UDestroyTwin");
static_assert(offsetof(UDestroyTwin, _destroyTwinMaxCharge) == 0x000780, "Member 'UDestroyTwin::_destroyTwinMaxCharge' has a wrong offset!");

// Class TheTwins.Hoarder
// 0x0050 (0x0418 - 0x03C8)
class UHoarder final : public UPerk
{
public:
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ASearchable*>                    _chests;                                           // 0x03D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         _camperInteractItemPickupRevealRange[0x3];         // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _extraChestsSpawned[0x3];                          // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _bubbleIndicatorLifetime[0x3];                     // 0x03F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _showUniqueChestVisualPerState;                    // 0x0404(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_405[0x13];                                     // 0x0405(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Local_ThrowBubbleIndicator(const EPerkInteractionObjectType camperInteractionType, const class AActor* objectActor, const class ACamperPlayer* interactingCamperPlayer);

	float GetBubbleIndicatorLifetime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Hoarder">();
	}
	static class UHoarder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHoarder>();
	}
};
static_assert(alignof(UHoarder) == 0x000008, "Wrong alignment on UHoarder");
static_assert(sizeof(UHoarder) == 0x000418, "Wrong size on UHoarder");
static_assert(offsetof(UHoarder, _chests) == 0x0003D0, "Member 'UHoarder::_chests' has a wrong offset!");
static_assert(offsetof(UHoarder, _camperInteractItemPickupRevealRange) == 0x0003E0, "Member 'UHoarder::_camperInteractItemPickupRevealRange' has a wrong offset!");
static_assert(offsetof(UHoarder, _extraChestsSpawned) == 0x0003EC, "Member 'UHoarder::_extraChestsSpawned' has a wrong offset!");
static_assert(offsetof(UHoarder, _bubbleIndicatorLifetime) == 0x0003F8, "Member 'UHoarder::_bubbleIndicatorLifetime' has a wrong offset!");
static_assert(offsetof(UHoarder, _showUniqueChestVisualPerState) == 0x000404, "Member 'UHoarder::_showUniqueChestVisualPerState' has a wrong offset!");

// Class TheTwins.IsTwinRecallReady
// 0x0008 (0x00F0 - 0x00E8)
class UIsTwinRecallReady final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsTwinRecallReady">();
	}
	static class UIsTwinRecallReady* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsTwinRecallReady>();
	}
};
static_assert(alignof(UIsTwinRecallReady) == 0x000008, "Wrong alignment on UIsTwinRecallReady");
static_assert(sizeof(UIsTwinRecallReady) == 0x0000F0, "Wrong size on UIsTwinRecallReady");

// Class TheTwins.K22AchievementTagTeam
// 0x0018 (0x00D0 - 0x00B8)
class UK22AchievementTagTeam final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K22AchievementTagTeam">();
	}
	static class UK22AchievementTagTeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK22AchievementTagTeam>();
	}
};
static_assert(alignof(UK22AchievementTagTeam) == 0x000008, "Wrong alignment on UK22AchievementTagTeam");
static_assert(sizeof(UK22AchievementTagTeam) == 0x0000D0, "Wrong size on UK22AchievementTagTeam");

// Class TheTwins.K22Power
// 0x0168 (0x0618 - 0x04B0)
class AK22Power final : public ACollectable
{
public:
	uint8                                         Pad_4B0[0x18];                                     // 0x04B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _releaseConjoinedTwinChargeable;                   // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _possessConjoinedTwinChargeable;                   // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0x18];                                     // 0x04D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AConjoinedTwin*                         _conjoinedTwin;                                    // 0x04F0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AConjoinedTwin*                         _conjoinedTwinParadise;                            // 0x04F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPowerChargeComponent*                  _powerCharge;                                      // 0x0500(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK22PowerChargePresentationItemProgressComponent* _powerChargePresentationItemProgress;    // 0x0508(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerMaxCharge;                                   // 0x0510(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AConjoinedTwin>             _conjoinedTwinClass;                               // 0x0538(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_540[0x18];                                     // 0x0540(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _powerRechargeRate;                                // 0x0558(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _timeBeforeAutoDestroy;                            // 0x0580(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _timeBeforeRecallAvailable;                        // 0x05A8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D0[0x48];                                     // 0x05D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnDestroyTwinChargePercentChanged(class UChargeableComponent* chargeableComponent, float percentCompletionChange, float totalPercentComplete);
	void Authority_OnPossessTwinChargePercentChanged(class UChargeableComponent* chargeableComponent, float percentCompletionChange, float totalPercentComplete);
	void OnFirstAttachmentToSister();
	void OnPowerChargeEmpty();
	void OnRep_ConjoinedTwin();

	class AConjoinedTwin* GetConjoinedTwin() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K22Power">();
	}
	static class AK22Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK22Power>();
	}
};
static_assert(alignof(AK22Power) == 0x000008, "Wrong alignment on AK22Power");
static_assert(sizeof(AK22Power) == 0x000618, "Wrong size on AK22Power");
static_assert(offsetof(AK22Power, _releaseConjoinedTwinChargeable) == 0x0004C8, "Member 'AK22Power::_releaseConjoinedTwinChargeable' has a wrong offset!");
static_assert(offsetof(AK22Power, _possessConjoinedTwinChargeable) == 0x0004D0, "Member 'AK22Power::_possessConjoinedTwinChargeable' has a wrong offset!");
static_assert(offsetof(AK22Power, _conjoinedTwin) == 0x0004F0, "Member 'AK22Power::_conjoinedTwin' has a wrong offset!");
static_assert(offsetof(AK22Power, _conjoinedTwinParadise) == 0x0004F8, "Member 'AK22Power::_conjoinedTwinParadise' has a wrong offset!");
static_assert(offsetof(AK22Power, _powerCharge) == 0x000500, "Member 'AK22Power::_powerCharge' has a wrong offset!");
static_assert(offsetof(AK22Power, _powerChargePresentationItemProgress) == 0x000508, "Member 'AK22Power::_powerChargePresentationItemProgress' has a wrong offset!");
static_assert(offsetof(AK22Power, _powerMaxCharge) == 0x000510, "Member 'AK22Power::_powerMaxCharge' has a wrong offset!");
static_assert(offsetof(AK22Power, _conjoinedTwinClass) == 0x000538, "Member 'AK22Power::_conjoinedTwinClass' has a wrong offset!");
static_assert(offsetof(AK22Power, _powerRechargeRate) == 0x000558, "Member 'AK22Power::_powerRechargeRate' has a wrong offset!");
static_assert(offsetof(AK22Power, _timeBeforeAutoDestroy) == 0x000580, "Member 'AK22Power::_timeBeforeAutoDestroy' has a wrong offset!");
static_assert(offsetof(AK22Power, _timeBeforeRecallAvailable) == 0x0005A8, "Member 'AK22Power::_timeBeforeRecallAvailable' has a wrong offset!");

// Class TheTwins.K22PowerChargePresentationItemProgressComponent
// 0x0018 (0x00D0 - 0x00B8)
class UK22PowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	class UPowerChargeComponent*                  _powerChargeComponent;                             // 0x00B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTwinSet(class AConjoinedTwin* twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K22PowerChargePresentationItemProgressComponent">();
	}
	static class UK22PowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK22PowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK22PowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK22PowerChargePresentationItemProgressComponent");
static_assert(sizeof(UK22PowerChargePresentationItemProgressComponent) == 0x0000D0, "Wrong size on UK22PowerChargePresentationItemProgressComponent");
static_assert(offsetof(UK22PowerChargePresentationItemProgressComponent, _powerChargeComponent) == 0x0000B8, "Member 'UK22PowerChargePresentationItemProgressComponent::_powerChargeComponent' has a wrong offset!");

// Class TheTwins.K22ScoreComponent
// 0x0018 (0x00D0 - 0x00B8)
class UK22ScoreComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K22ScoreComponent">();
	}
	static class UK22ScoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK22ScoreComponent>();
	}
};
static_assert(alignof(UK22ScoreComponent) == 0x000008, "Wrong alignment on UK22ScoreComponent");
static_assert(sizeof(UK22ScoreComponent) == 0x0000D0, "Wrong size on UK22ScoreComponent");

// Class TheTwins.KillerBeingPossessedInteraction
// 0x0000 (0x07D0 - 0x07D0)
class UKillerBeingPossessedInteraction final : public UBeingPossessedInteraction
{
public:
	class UCurveFloat*                            _wakeUpSpeedCurve;                                 // 0x07C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerBeingPossessedInteraction">();
	}
	static class UKillerBeingPossessedInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerBeingPossessedInteraction>();
	}
};
static_assert(alignof(UKillerBeingPossessedInteraction) == 0x000010, "Wrong alignment on UKillerBeingPossessedInteraction");
static_assert(sizeof(UKillerBeingPossessedInteraction) == 0x0007D0, "Wrong size on UKillerBeingPossessedInteraction");
static_assert(offsetof(UKillerBeingPossessedInteraction, _wakeUpSpeedCurve) == 0x0007C8, "Member 'UKillerBeingPossessedInteraction::_wakeUpSpeedCurve' has a wrong offset!");

// Class TheTwins.PossessionComponent
// 0x0090 (0x0148 - 0x00B8)
class UPossessionComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x61];                                      // 0x00B8(0x0061)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _startPossessed;                                   // 0x0119(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11A[0x6];                                      // 0x011A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AAIController*                          _emptyController;                                  // 0x0120(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x20];                                     // 0x0128(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_StartStateMachineDriverChangeProcess();
	void Client_WaitForBeingPossessedInteractionToStart();
	void Cosmetic_OnControlledChanged(class ADBDPlayer* player, bool isControlled);
	void CosmeticLocal_OnControlled(class ADBDPlayer* player);
	void CosmeticLocal_OnUncontrolled(class ADBDPlayer* player);
	void Multicast_NotifyPossessionDone();
	void Multicast_StartPossessionOf(class ADBDPlayer* playerToPossess);
	void OnLevelReadyToPlay();
	void Server_NotifyBeingPossessedInteractionStarted();
	void Server_NotifyPossessionDone();
	void Server_StartPossessionOf(class ADBDPlayer* playerToPossess, bool shouldStartBeingPossessedInteraction);

	bool IsDormant() const;
	bool IsPossessed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PossessionComponent">();
	}
	static class UPossessionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPossessionComponent>();
	}
};
static_assert(alignof(UPossessionComponent) == 0x000008, "Wrong alignment on UPossessionComponent");
static_assert(sizeof(UPossessionComponent) == 0x000148, "Wrong size on UPossessionComponent");
static_assert(offsetof(UPossessionComponent, _startPossessed) == 0x000119, "Member 'UPossessionComponent::_startPossessed' has a wrong offset!");
static_assert(offsetof(UPossessionComponent, _emptyController) == 0x000120, "Member 'UPossessionComponent::_emptyController' has a wrong offset!");

// Class TheTwins.KillerPossessionComponent
// 0x0060 (0x01A8 - 0x0148)
class UKillerPossessionComponent final : public UPossessionComponent
{
public:
	bool                                          _shouldDeactivateCollisionsWithSurvivors;          // 0x0148(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_149[0x37];                                     // 0x0149(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _timeBeforeCollisionsDeactivation;                 // 0x0180(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_ShouldDeactivateCollisionsWithSurvivors();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerPossessionComponent">();
	}
	static class UKillerPossessionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerPossessionComponent>();
	}
};
static_assert(alignof(UKillerPossessionComponent) == 0x000008, "Wrong alignment on UKillerPossessionComponent");
static_assert(sizeof(UKillerPossessionComponent) == 0x0001A8, "Wrong size on UKillerPossessionComponent");
static_assert(offsetof(UKillerPossessionComponent, _shouldDeactivateCollisionsWithSurvivors) == 0x000148, "Member 'UKillerPossessionComponent::_shouldDeactivateCollisionsWithSurvivors' has a wrong offset!");
static_assert(offsetof(UKillerPossessionComponent, _timeBeforeCollisionsDeactivation) == 0x000180, "Member 'UKillerPossessionComponent::_timeBeforeCollisionsDeactivation' has a wrong offset!");

// Class TheTwins.PossessNegationEffectComponent
// 0x0018 (0x00D0 - 0x00B8)
class UPossessNegationEffectComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              PlayCantPossessSound;                              // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PossessNegationEffectComponent">();
	}
	static class UPossessNegationEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPossessNegationEffectComponent>();
	}
};
static_assert(alignof(UPossessNegationEffectComponent) == 0x000008, "Wrong alignment on UPossessNegationEffectComponent");
static_assert(sizeof(UPossessNegationEffectComponent) == 0x0000D0, "Wrong size on UPossessNegationEffectComponent");
static_assert(offsetof(UPossessNegationEffectComponent, PlayCantPossessSound) == 0x0000B8, "Member 'UPossessNegationEffectComponent::PlayCantPossessSound' has a wrong offset!");

// Class TheTwins.KillerPossessNegationEffectComponent
// 0x0020 (0x00F0 - 0x00D0)
class UKillerPossessNegationEffectComponent final : public UPossessNegationEffectComponent
{
public:
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTwinSet(class AConjoinedTwin* twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerPossessNegationEffectComponent">();
	}
	static class UKillerPossessNegationEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerPossessNegationEffectComponent>();
	}
};
static_assert(alignof(UKillerPossessNegationEffectComponent) == 0x000008, "Wrong alignment on UKillerPossessNegationEffectComponent");
static_assert(sizeof(UKillerPossessNegationEffectComponent) == 0x0000F0, "Wrong size on UKillerPossessNegationEffectComponent");

// Class TheTwins.Oppression
// 0x0018 (0x03E0 - 0x03C8)
class UOppression final : public UPerk
{
public:
	int32                                         _nbGeneratorsAffectedByPerk[0x3];                  // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _perkCooldown[0x3];                                // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Oppression">();
	}
	static class UOppression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOppression>();
	}
};
static_assert(alignof(UOppression) == 0x000008, "Wrong alignment on UOppression");
static_assert(sizeof(UOppression) == 0x0003E0, "Wrong size on UOppression");
static_assert(offsetof(UOppression, _nbGeneratorsAffectedByPerk) == 0x0003C8, "Member 'UOppression::_nbGeneratorsAffectedByPerk' has a wrong offset!");
static_assert(offsetof(UOppression, _perkCooldown) == 0x0003D4, "Member 'UOppression::_perkCooldown' has a wrong offset!");

// Class TheTwins.PossessTheKiller
// 0x0030 (0x07A0 - 0x0770)
class UPossessTheKiller final : public UPossessPlayer
{
public:
	uint8                                         Pad_770[0x30];                                     // 0x0770(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PossessTheKiller">();
	}
	static class UPossessTheKiller* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPossessTheKiller>();
	}
};
static_assert(alignof(UPossessTheKiller) == 0x000010, "Wrong alignment on UPossessTheKiller");
static_assert(sizeof(UPossessTheKiller) == 0x0007A0, "Wrong size on UPossessTheKiller");

// Class TheTwins.PowerStruggle
// 0x0010 (0x03D8 - 0x03C8)
class UPowerStruggle final : public UPerk
{
public:
	float                                         _wigglePercentToActivatePerk[0x3];                 // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerStruggle">();
	}
	static class UPowerStruggle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerStruggle>();
	}
};
static_assert(alignof(UPowerStruggle) == 0x000008, "Wrong alignment on UPowerStruggle");
static_assert(sizeof(UPowerStruggle) == 0x0003D8, "Wrong size on UPowerStruggle");
static_assert(offsetof(UPowerStruggle, _wigglePercentToActivatePerk) == 0x0003C8, "Member 'UPowerStruggle::_wigglePercentToActivatePerk' has a wrong offset!");

// Class TheTwins.PushTwinOnLockerInteraction
// 0x0060 (0x07A0 - 0x0740)
class UPushTwinOnLockerInteraction final : public UChargeableInteractionDefinition
{
public:
	class UChargeableComponent*                   _pushTwinOnLockerChargeable;                       // 0x0740(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pushTwinOnLockerMaxCharge;                        // 0x0748(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_770[0x30];                                     // 0x0770(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnPlayerInLockerChanged(class ADBDPlayer* previousPlayerInLocker, class ADBDPlayer* newPlayerInLocker);
	void OnRep_PushTwinOnLockerChargeable();
	void OnTwinSet(class AConjoinedTwin* twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PushTwinOnLockerInteraction">();
	}
	static class UPushTwinOnLockerInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPushTwinOnLockerInteraction>();
	}
};
static_assert(alignof(UPushTwinOnLockerInteraction) == 0x000010, "Wrong alignment on UPushTwinOnLockerInteraction");
static_assert(sizeof(UPushTwinOnLockerInteraction) == 0x0007A0, "Wrong size on UPushTwinOnLockerInteraction");
static_assert(offsetof(UPushTwinOnLockerInteraction, _pushTwinOnLockerChargeable) == 0x000740, "Member 'UPushTwinOnLockerInteraction::_pushTwinOnLockerChargeable' has a wrong offset!");
static_assert(offsetof(UPushTwinOnLockerInteraction, _pushTwinOnLockerMaxCharge) == 0x000748, "Member 'UPushTwinOnLockerInteraction::_pushTwinOnLockerMaxCharge' has a wrong offset!");

// Class TheTwins.RecallTwin
// 0x0020 (0x0640 - 0x0620)
class URecallTwin final : public UInteractionDefinition
{
public:
	uint8                                         Pad_618[0x28];                                     // 0x0618(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTwinSet(class AConjoinedTwin* twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecallTwin">();
	}
	static class URecallTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecallTwin>();
	}
};
static_assert(alignof(URecallTwin) == 0x000010, "Wrong alignment on URecallTwin");
static_assert(sizeof(URecallTwin) == 0x000640, "Wrong size on URecallTwin");

// Class TheTwins.ReleaseConjoinedTwin
// 0x0170 (0x08B0 - 0x0740)
class UReleaseConjoinedTwin final : public UChargeableInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _releaseMaxCharge;                                 // 0x0740(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _releaseExitTime;                                  // 0x0768(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7E8[0x34];                                     // 0x07E8(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _releaseAnimationWentToTheEnd;                     // 0x081C(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_81D[0x93];                                     // 0x081D(0x0093)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnReleaseCancelled(class ADBDPlayer* sister, class AConjoinedTwin* brother);
	void Cosmetic_OnReleaseChargeComplete(class ADBDPlayer* sister, class AConjoinedTwin* brother);
	void Cosmetic_OnReleaseTwinInteractionUpdate(class ADBDPlayer* sister, class AConjoinedTwin* brother, float deltaTime);
	void Cosmetic_OnReleaseTwinInteractionUpdateStart(class ADBDPlayer* sister, class AConjoinedTwin* brother);
	void OnKillerStunned(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void OnPowerCollected(class ADBDPlayer* collector);
	void OnRep_ReleaseAnimationWentToTheEnd();
	void OnTwinSet(class AConjoinedTwin* twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReleaseConjoinedTwin">();
	}
	static class UReleaseConjoinedTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReleaseConjoinedTwin>();
	}
};
static_assert(alignof(UReleaseConjoinedTwin) == 0x000010, "Wrong alignment on UReleaseConjoinedTwin");
static_assert(sizeof(UReleaseConjoinedTwin) == 0x0008B0, "Wrong size on UReleaseConjoinedTwin");
static_assert(offsetof(UReleaseConjoinedTwin, _releaseMaxCharge) == 0x000740, "Member 'UReleaseConjoinedTwin::_releaseMaxCharge' has a wrong offset!");
static_assert(offsetof(UReleaseConjoinedTwin, _releaseExitTime) == 0x000768, "Member 'UReleaseConjoinedTwin::_releaseExitTime' has a wrong offset!");
static_assert(offsetof(UReleaseConjoinedTwin, _releaseAnimationWentToTheEnd) == 0x00081C, "Member 'UReleaseConjoinedTwin::_releaseAnimationWentToTheEnd' has a wrong offset!");

// Class TheTwins.RemoveTwin
// 0x0090 (0x07D0 - 0x0740)
class URemoveTwin final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_740[0x30];                                     // 0x0740(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _removeTwinMaxCharge;                              // 0x0770(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _removeTwinExitTime;                               // 0x0798(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _brotherRemoveDistanceFromSurvivor;                // 0x07C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C4[0xC];                                      // 0x07C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRemoveMontageEnd(const struct FAnimationMontageDescriptor& montage, bool interrupted, class ADBDPlayer* destroyingPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveTwin">();
	}
	static class URemoveTwin* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveTwin>();
	}
};
static_assert(alignof(URemoveTwin) == 0x000010, "Wrong alignment on URemoveTwin");
static_assert(sizeof(URemoveTwin) == 0x0007D0, "Wrong size on URemoveTwin");
static_assert(offsetof(URemoveTwin, _removeTwinMaxCharge) == 0x000770, "Member 'URemoveTwin::_removeTwinMaxCharge' has a wrong offset!");
static_assert(offsetof(URemoveTwin, _removeTwinExitTime) == 0x000798, "Member 'URemoveTwin::_removeTwinExitTime' has a wrong offset!");
static_assert(offsetof(URemoveTwin, _brotherRemoveDistanceFromSurvivor) == 0x0007C0, "Member 'URemoveTwin::_brotherRemoveDistanceFromSurvivor' has a wrong offset!");

// Class TheTwins.SisterBlindFlashlightableLightingStrategy
// 0x0030 (0x0070 - 0x0040)
class USisterBlindFlashlightableLightingStrategy final : public UBlindFlashlightableLightingStrategy
{
public:
	uint8                                         Pad_40[0x30];                                      // 0x0040(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTwinSet(class AConjoinedTwin* twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SisterBlindFlashlightableLightingStrategy">();
	}
	static class USisterBlindFlashlightableLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USisterBlindFlashlightableLightingStrategy>();
	}
};
static_assert(alignof(USisterBlindFlashlightableLightingStrategy) == 0x000008, "Wrong alignment on USisterBlindFlashlightableLightingStrategy");
static_assert(sizeof(USisterBlindFlashlightableLightingStrategy) == 0x000070, "Wrong size on USisterBlindFlashlightableLightingStrategy");

// Class TheTwins.TheTwinsCheatComponent
// 0x0000 (0x00B8 - 0x00B8)
class UTheTwinsCheatComponent final : public UActorComponent
{
public:
	void DBD_TwinDestroyTheTwin();
	void Multicast_TrySendThePlayerBackInKiller(class UTwinPossessionComponent* twinPossessionComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TheTwinsCheatComponent">();
	}
	static class UTheTwinsCheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTheTwinsCheatComponent>();
	}
};
static_assert(alignof(UTheTwinsCheatComponent) == 0x000008, "Wrong alignment on UTheTwinsCheatComponent");
static_assert(sizeof(UTheTwinsCheatComponent) == 0x0000B8, "Wrong size on UTheTwinsCheatComponent");

// Class TheTwins.TwinAOELingeringStatusEffect
// 0x00A0 (0x03F8 - 0x0358)
class UTwinAOELingeringStatusEffect final : public UBaseLingeringStatusEffect
{
public:
	struct FTunableStat                           _shriekingRange;                                   // 0x0358(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x20];                                     // 0x03D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnInRangeChanged(const bool inRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinAOELingeringStatusEffect">();
	}
	static class UTwinAOELingeringStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinAOELingeringStatusEffect>();
	}
};
static_assert(alignof(UTwinAOELingeringStatusEffect) == 0x000008, "Wrong alignment on UTwinAOELingeringStatusEffect");
static_assert(sizeof(UTwinAOELingeringStatusEffect) == 0x0003F8, "Wrong size on UTwinAOELingeringStatusEffect");
static_assert(offsetof(UTwinAOELingeringStatusEffect, _shriekingRange) == 0x000358, "Member 'UTwinAOELingeringStatusEffect::_shriekingRange' has a wrong offset!");

// Class TheTwins.TwinAttachmentComponent
// 0x0160 (0x0218 - 0x00B8)
class UTwinAttachmentComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x48];                                      // 0x00B8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _attachedPlayer;                                   // 0x0100(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x58];                                     // 0x0108(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _gateBlockerStatusEffect;                          // 0x0160(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x12];                                     // 0x0168(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasBeenDetachedBySurvivorDamageChanged;           // 0x017A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17B[0x5];                                      // 0x017B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _cantEscapeByGateLingerDuration;                   // 0x0180(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ADBDPlayer*, struct FFastTimer>    _escapeBlockerLingerTimers;                        // 0x01A8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  _notCancelableInteractionTags;                     // 0x01F8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Authority_OnRemoveTwinChargePercentChanged(class UChargeableComponent* chargeableComponent, float percentCompletionChange, float totalPercentComplete);
	void Cosmetic_OnTwinAttachedToSister(class ADBDPlayer* sister, class ADBDPlayer* brother, bool isFirstAttachment);
	void Cosmetic_OnTwinAttachedToSurvivor(class ADBDPlayer* survivor, class ADBDPlayer* brother);
	void Cosmetic_OnTwinDetachedFromSister(class ADBDPlayer* sister, class ADBDPlayer* brother);
	void Cosmetic_OnTwinDetachedFromSurvivor(class ADBDPlayer* survivor, class ADBDPlayer* brother);
	void Multicast_QuickDestroyTwin();
	void OnAttachedSurvivorDamageStateChanged(const ECamperDamageState oldState, const ECamperDamageState newState);
	void OnImmobilizedStateChanged(const ECamperImmobilizeState oldImmobilizeState, const ECamperImmobilizeState newImmobilizeState);
	void OnLevelReadyToPlay();
	void OnMoriMontageEnd(const struct FAnimationMontageDescriptor& montage, bool interrupted);
	void OnRep_AttachedPlayer(class ADBDPlayer* oldAttachedPlayer);

	bool IsAttachedToSister() const;
	bool IsAttachedToSurvivor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinAttachmentComponent">();
	}
	static class UTwinAttachmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinAttachmentComponent>();
	}
};
static_assert(alignof(UTwinAttachmentComponent) == 0x000008, "Wrong alignment on UTwinAttachmentComponent");
static_assert(sizeof(UTwinAttachmentComponent) == 0x000218, "Wrong size on UTwinAttachmentComponent");
static_assert(offsetof(UTwinAttachmentComponent, _attachedPlayer) == 0x000100, "Member 'UTwinAttachmentComponent::_attachedPlayer' has a wrong offset!");
static_assert(offsetof(UTwinAttachmentComponent, _gateBlockerStatusEffect) == 0x000160, "Member 'UTwinAttachmentComponent::_gateBlockerStatusEffect' has a wrong offset!");
static_assert(offsetof(UTwinAttachmentComponent, _hasBeenDetachedBySurvivorDamageChanged) == 0x00017A, "Member 'UTwinAttachmentComponent::_hasBeenDetachedBySurvivorDamageChanged' has a wrong offset!");
static_assert(offsetof(UTwinAttachmentComponent, _cantEscapeByGateLingerDuration) == 0x000180, "Member 'UTwinAttachmentComponent::_cantEscapeByGateLingerDuration' has a wrong offset!");
static_assert(offsetof(UTwinAttachmentComponent, _escapeBlockerLingerTimers) == 0x0001A8, "Member 'UTwinAttachmentComponent::_escapeBlockerLingerTimers' has a wrong offset!");
static_assert(offsetof(UTwinAttachmentComponent, _notCancelableInteractionTags) == 0x0001F8, "Member 'UTwinAttachmentComponent::_notCancelableInteractionTags' has a wrong offset!");

// Class TheTwins.TwinBaseAddon
// 0x0010 (0x02C8 - 0x02B8)
class UTwinBaseAddon final : public UItemAddon
{
public:
	class FName                                   _statusEffectID;                                   // 0x02B8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _customParam;                                      // 0x02C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnTwinSet(class AConjoinedTwin* twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinBaseAddon">();
	}
	static class UTwinBaseAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinBaseAddon>();
	}
};
static_assert(alignof(UTwinBaseAddon) == 0x000008, "Wrong alignment on UTwinBaseAddon");
static_assert(sizeof(UTwinBaseAddon) == 0x0002C8, "Wrong size on UTwinBaseAddon");
static_assert(offsetof(UTwinBaseAddon, _statusEffectID) == 0x0002B8, "Member 'UTwinBaseAddon::_statusEffectID' has a wrong offset!");
static_assert(offsetof(UTwinBaseAddon, _customParam) == 0x0002C4, "Member 'UTwinBaseAddon::_customParam' has a wrong offset!");

// Class TheTwins.TwinBaseKillerInstinctEffect
// 0x0148 (0x0498 - 0x0350)
class UTwinBaseKillerInstinctEffect final : public UStatusEffect
{
public:
	struct FTunableStat                           _lullabyRange;                                     // 0x0350(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _lingerDuration;                                   // 0x03D0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0xA0];                                     // 0x03F8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnInRangeChanged(const bool inRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinBaseKillerInstinctEffect">();
	}
	static class UTwinBaseKillerInstinctEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinBaseKillerInstinctEffect>();
	}
};
static_assert(alignof(UTwinBaseKillerInstinctEffect) == 0x000008, "Wrong alignment on UTwinBaseKillerInstinctEffect");
static_assert(sizeof(UTwinBaseKillerInstinctEffect) == 0x000498, "Wrong size on UTwinBaseKillerInstinctEffect");
static_assert(offsetof(UTwinBaseKillerInstinctEffect, _lullabyRange) == 0x000350, "Member 'UTwinBaseKillerInstinctEffect::_lullabyRange' has a wrong offset!");
static_assert(offsetof(UTwinBaseKillerInstinctEffect, _lingerDuration) == 0x0003D0, "Member 'UTwinBaseKillerInstinctEffect::_lingerDuration' has a wrong offset!");

// Class TheTwins.TwinBeingPossessedInteraction
// 0x0000 (0x07D0 - 0x07D0)
class UTwinBeingPossessedInteraction final : public UBeingPossessedInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinBeingPossessedInteraction">();
	}
	static class UTwinBeingPossessedInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinBeingPossessedInteraction>();
	}
};
static_assert(alignof(UTwinBeingPossessedInteraction) == 0x000010, "Wrong alignment on UTwinBeingPossessedInteraction");
static_assert(sizeof(UTwinBeingPossessedInteraction) == 0x0007D0, "Wrong size on UTwinBeingPossessedInteraction");

// Class TheTwins.TwinCharacterMovementComponent
// 0x0010 (0x0E70 - 0x0E60)
class UTwinCharacterMovementComponent final : public UDBDCharacterMovementComponent
{
public:
	uint8                                         Pad_E60[0x10];                                     // 0x0E60(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinCharacterMovementComponent">();
	}
	static class UTwinCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinCharacterMovementComponent>();
	}
};
static_assert(alignof(UTwinCharacterMovementComponent) == 0x000010, "Wrong alignment on UTwinCharacterMovementComponent");
static_assert(sizeof(UTwinCharacterMovementComponent) == 0x000E70, "Wrong size on UTwinCharacterMovementComponent");

// Class TheTwins.TwinDestructionComponent
// 0x00E8 (0x01A0 - 0x00B8)
class UTwinDestructionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     _huskClass;                                        // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTransform                             _dyingTransform;                                   // 0x00F0(0x0030)(Net, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x70];                                     // 0x0120(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _dyingFromSurvivorTranslation;                     // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_194[0xC];                                      // 0x0194(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnTwinQuickDestroyOver();
	void Cosmetic_OnTwinDestroyedFromKick(class AConjoinedTwin* owningTwin);
	void Cosmetic_OnTwinDestroyedFromSurvivorRemove(class AConjoinedTwin* owningTwin);
	void OnDyingMontageEnd(const struct FAnimationMontageDescriptor& montage, bool interrupted);
	void OnTwinQuickDestroy(class AConjoinedTwin* owningTwin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinDestructionComponent">();
	}
	static class UTwinDestructionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinDestructionComponent>();
	}
};
static_assert(alignof(UTwinDestructionComponent) == 0x000010, "Wrong alignment on UTwinDestructionComponent");
static_assert(sizeof(UTwinDestructionComponent) == 0x0001A0, "Wrong size on UTwinDestructionComponent");
static_assert(offsetof(UTwinDestructionComponent, _huskClass) == 0x0000E8, "Member 'UTwinDestructionComponent::_huskClass' has a wrong offset!");
static_assert(offsetof(UTwinDestructionComponent, _dyingTransform) == 0x0000F0, "Member 'UTwinDestructionComponent::_dyingTransform' has a wrong offset!");
static_assert(offsetof(UTwinDestructionComponent, _dyingFromSurvivorTranslation) == 0x000190, "Member 'UTwinDestructionComponent::_dyingFromSurvivorTranslation' has a wrong offset!");

// Class TheTwins.TwinFirstPersonViewComponent
// 0x0028 (0x00F0 - 0x00C8)
class UTwinFirstPersonViewComponent final : public UFirstPersonViewComponent
{
public:
	uint8                                         Pad_C8[0x28];                                      // 0x00C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinFirstPersonViewComponent">();
	}
	static class UTwinFirstPersonViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinFirstPersonViewComponent>();
	}
};
static_assert(alignof(UTwinFirstPersonViewComponent) == 0x000008, "Wrong alignment on UTwinFirstPersonViewComponent");
static_assert(sizeof(UTwinFirstPersonViewComponent) == 0x0000F0, "Wrong size on UTwinFirstPersonViewComponent");

// Class TheTwins.TwinHuskAnimInstance
// 0x0020 (0x02E0 - 0x02C0)
class UTwinHuskAnimInstance final : public UAnimInstance
{
public:
	bool                                          _isDeadFromSurvivorBack;                           // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  _owningPawn;                                       // 0x02C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTwinHuskStateComponent*                _twinHuskStateComponent;                           // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinHuskAnimInstance">();
	}
	static class UTwinHuskAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinHuskAnimInstance>();
	}
};
static_assert(alignof(UTwinHuskAnimInstance) == 0x000010, "Wrong alignment on UTwinHuskAnimInstance");
static_assert(sizeof(UTwinHuskAnimInstance) == 0x0002E0, "Wrong size on UTwinHuskAnimInstance");
static_assert(offsetof(UTwinHuskAnimInstance, _isDeadFromSurvivorBack) == 0x0002C0, "Member 'UTwinHuskAnimInstance::_isDeadFromSurvivorBack' has a wrong offset!");
static_assert(offsetof(UTwinHuskAnimInstance, _owningPawn) == 0x0002C8, "Member 'UTwinHuskAnimInstance::_owningPawn' has a wrong offset!");
static_assert(offsetof(UTwinHuskAnimInstance, _twinHuskStateComponent) == 0x0002D0, "Member 'UTwinHuskAnimInstance::_twinHuskStateComponent' has a wrong offset!");

// Class TheTwins.TwinHuskStateComponent
// 0x0008 (0x00C0 - 0x00B8)
class UTwinHuskStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsDeadFromSurvivorBack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinHuskStateComponent">();
	}
	static class UTwinHuskStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinHuskStateComponent>();
	}
};
static_assert(alignof(UTwinHuskStateComponent) == 0x000008, "Wrong alignment on UTwinHuskStateComponent");
static_assert(sizeof(UTwinHuskStateComponent) == 0x0000C0, "Wrong size on UTwinHuskStateComponent");

// Class TheTwins.TwinInspectEmptyLocker
// 0x0000 (0x0680 - 0x0680)
class UTwinInspectEmptyLocker final : public UBaseTwinInspectLocker
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinInspectEmptyLocker">();
	}
	static class UTwinInspectEmptyLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinInspectEmptyLocker>();
	}
};
static_assert(alignof(UTwinInspectEmptyLocker) == 0x000010, "Wrong alignment on UTwinInspectEmptyLocker");
static_assert(sizeof(UTwinInspectEmptyLocker) == 0x000680, "Wrong size on UTwinInspectEmptyLocker");

// Class TheTwins.TwinInspectOccupiedLocker
// 0x0000 (0x0680 - 0x0680)
class UTwinInspectOccupiedLocker final : public UBaseTwinInspectLocker
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinInspectOccupiedLocker">();
	}
	static class UTwinInspectOccupiedLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinInspectOccupiedLocker>();
	}
};
static_assert(alignof(UTwinInspectOccupiedLocker) == 0x000010, "Wrong alignment on UTwinInspectOccupiedLocker");
static_assert(sizeof(UTwinInspectOccupiedLocker) == 0x000680, "Wrong size on UTwinInspectOccupiedLocker");

// Class TheTwins.TwinJumpAttack
// 0x00F0 (0x0470 - 0x0380)
class UTwinJumpAttack final : public UPounceAttack
{
public:
	struct FDBDTunableRowHandle                   _jumpVelocity;                                     // 0x0380(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _jumpAngleCurve;                                   // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x30];                                     // 0x03B0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _upDownObstructionAnglePrecision;                  // 0x03E0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _leftRightObstructionAnglePrecision;               // 0x0408(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _authorizedLandingHeight;                          // 0x0430(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x9];                                      // 0x0458(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _shouldTwinHaveJumpObjectType;                     // 0x0461(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_462[0xE];                                      // 0x0462(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_Debug_PrintFinalDecisionOnScreen(bool foundPath);
	void Cosmetic_OnIsForbiddenLandingLocationChanged(bool isForbiddenLocation, class AConjoinedTwin* twin);
	void Cosmetic_OnJumpCooldownChanged(bool isInJumpCooldown, class AConjoinedTwin* owningTwin);
	void Cosmetic_OnJumpLanded(class AConjoinedTwin* owningTwin);
	void Cosmetic_OnJumpObstructed(class AConjoinedTwin* owningTwin, class UPhysicalMaterial* physicalMaterial, const struct FVector& position, const struct FVector& normal);
	void Cosmetic_OnJumpStarted(class AConjoinedTwin* owningTwin);
	void Multicast_AttachToSurvivor(class ADBDPlayer* survivorToAttachTo);
	void Multicast_DestroyTwinOnWrongLanding();
	void Multicast_SetIsForbiddenLandingLocation(bool isForbiddenLocation);
	void OnRep_ShouldTwinHaveJumpObjectType();
	void Server_OnJumpStartTwin();
	void Server_StopJump();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinJumpAttack">();
	}
	static class UTwinJumpAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinJumpAttack>();
	}
};
static_assert(alignof(UTwinJumpAttack) == 0x000010, "Wrong alignment on UTwinJumpAttack");
static_assert(sizeof(UTwinJumpAttack) == 0x000470, "Wrong size on UTwinJumpAttack");
static_assert(offsetof(UTwinJumpAttack, _jumpVelocity) == 0x000380, "Member 'UTwinJumpAttack::_jumpVelocity' has a wrong offset!");
static_assert(offsetof(UTwinJumpAttack, _jumpAngleCurve) == 0x0003A8, "Member 'UTwinJumpAttack::_jumpAngleCurve' has a wrong offset!");
static_assert(offsetof(UTwinJumpAttack, _upDownObstructionAnglePrecision) == 0x0003E0, "Member 'UTwinJumpAttack::_upDownObstructionAnglePrecision' has a wrong offset!");
static_assert(offsetof(UTwinJumpAttack, _leftRightObstructionAnglePrecision) == 0x000408, "Member 'UTwinJumpAttack::_leftRightObstructionAnglePrecision' has a wrong offset!");
static_assert(offsetof(UTwinJumpAttack, _authorizedLandingHeight) == 0x000430, "Member 'UTwinJumpAttack::_authorizedLandingHeight' has a wrong offset!");
static_assert(offsetof(UTwinJumpAttack, _shouldTwinHaveJumpObjectType) == 0x000461, "Member 'UTwinJumpAttack::_shouldTwinHaveJumpObjectType' has a wrong offset!");

// Class TheTwins.TwinJumpAttackOpenSubstate
// 0x00A0 (0x01D0 - 0x0130)
class UTwinJumpAttackOpenSubstate final : public UPounceAttackOpenSubstate
{
public:
	uint8                                         Pad_130[0xA0];                                     // 0x0130(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Local_OnTwinCapsuleHit(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, const struct FVector& normalImpulse, const struct FHitResult& hit);
	void Local_OnTwinOverlapEnter(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinJumpAttackOpenSubstate">();
	}
	static class UTwinJumpAttackOpenSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinJumpAttackOpenSubstate>();
	}
};
static_assert(alignof(UTwinJumpAttackOpenSubstate) == 0x000008, "Wrong alignment on UTwinJumpAttackOpenSubstate");
static_assert(sizeof(UTwinJumpAttackOpenSubstate) == 0x0001D0, "Wrong size on UTwinJumpAttackOpenSubstate");

// Class TheTwins.TwinJumpAttackSuccessSubstate
// 0x0050 (0x0168 - 0x0118)
class UTwinJumpAttackSuccessSubstate final : public UPounceAttackSuccessSubstate
{
public:
	struct FDBDTunableRowHandle                   _jumpSucceedAttachedCooldownTime;                  // 0x0118(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _jumpSucceedNotAttachedCooldownTime;               // 0x0140(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinJumpAttackSuccessSubstate">();
	}
	static class UTwinJumpAttackSuccessSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinJumpAttackSuccessSubstate>();
	}
};
static_assert(alignof(UTwinJumpAttackSuccessSubstate) == 0x000008, "Wrong alignment on UTwinJumpAttackSuccessSubstate");
static_assert(sizeof(UTwinJumpAttackSuccessSubstate) == 0x000168, "Wrong size on UTwinJumpAttackSuccessSubstate");
static_assert(offsetof(UTwinJumpAttackSuccessSubstate, _jumpSucceedAttachedCooldownTime) == 0x000118, "Member 'UTwinJumpAttackSuccessSubstate::_jumpSucceedAttachedCooldownTime' has a wrong offset!");
static_assert(offsetof(UTwinJumpAttackSuccessSubstate, _jumpSucceedNotAttachedCooldownTime) == 0x000140, "Member 'UTwinJumpAttackSuccessSubstate::_jumpSucceedNotAttachedCooldownTime' has a wrong offset!");

// Class TheTwins.TwinJumpAttackMissSubstate
// 0x0000 (0x0120 - 0x0120)
class UTwinJumpAttackMissSubstate final : public UPounceAttackMissSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinJumpAttackMissSubstate">();
	}
	static class UTwinJumpAttackMissSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinJumpAttackMissSubstate>();
	}
};
static_assert(alignof(UTwinJumpAttackMissSubstate) == 0x000008, "Wrong alignment on UTwinJumpAttackMissSubstate");
static_assert(sizeof(UTwinJumpAttackMissSubstate) == 0x000120, "Wrong size on UTwinJumpAttackMissSubstate");

// Class TheTwins.TwinJumpAttackObstructSubstate
// 0x0000 (0x0128 - 0x0128)
class UTwinJumpAttackObstructSubstate final : public UPounceAttackObstructSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinJumpAttackObstructSubstate">();
	}
	static class UTwinJumpAttackObstructSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinJumpAttackObstructSubstate>();
	}
};
static_assert(alignof(UTwinJumpAttackObstructSubstate) == 0x000008, "Wrong alignment on UTwinJumpAttackObstructSubstate");
static_assert(sizeof(UTwinJumpAttackObstructSubstate) == 0x000128, "Wrong size on UTwinJumpAttackObstructSubstate");

// Class TheTwins.TwinJumpAudioMutedEffect
// 0x0000 (0x0350 - 0x0350)
class UTwinJumpAudioMutedEffect final : public UStatusEffect
{
public:
	void Cosmetic_OnTwinMuted();
	void Cosmetic_OnTwinUnmuted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinJumpAudioMutedEffect">();
	}
	static class UTwinJumpAudioMutedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinJumpAudioMutedEffect>();
	}
};
static_assert(alignof(UTwinJumpAudioMutedEffect) == 0x000008, "Wrong alignment on UTwinJumpAudioMutedEffect");
static_assert(sizeof(UTwinJumpAudioMutedEffect) == 0x000350, "Wrong size on UTwinJumpAudioMutedEffect");

// Class TheTwins.TwinJumpTargetVisibleEffect
// 0x0018 (0x0368 - 0x0350)
class UTwinJumpTargetVisibleEffect final : public UStatusEffect
{
public:
	TSubclassOf<class AActor>                     _twinJumpTargetObject;                             // 0x0350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _twinJumpTarget;                                   // 0x0358(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USelectiveVisibilityComponent*          _jumpTargetVisibility;                             // 0x0360(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnHideTargetPosition();
	void OnJumpTargetTick(const struct FVector& location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinJumpTargetVisibleEffect">();
	}
	static class UTwinJumpTargetVisibleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinJumpTargetVisibleEffect>();
	}
};
static_assert(alignof(UTwinJumpTargetVisibleEffect) == 0x000008, "Wrong alignment on UTwinJumpTargetVisibleEffect");
static_assert(sizeof(UTwinJumpTargetVisibleEffect) == 0x000368, "Wrong size on UTwinJumpTargetVisibleEffect");
static_assert(offsetof(UTwinJumpTargetVisibleEffect, _twinJumpTargetObject) == 0x000350, "Member 'UTwinJumpTargetVisibleEffect::_twinJumpTargetObject' has a wrong offset!");
static_assert(offsetof(UTwinJumpTargetVisibleEffect, _twinJumpTarget) == 0x000358, "Member 'UTwinJumpTargetVisibleEffect::_twinJumpTarget' has a wrong offset!");
static_assert(offsetof(UTwinJumpTargetVisibleEffect, _jumpTargetVisibility) == 0x000360, "Member 'UTwinJumpTargetVisibleEffect::_jumpTargetVisibility' has a wrong offset!");

// Class TheTwins.TwinLockerBlockerComponent
// 0x0060 (0x0118 - 0x00B8)
class UTwinLockerBlockerComponent final : public UActorComponent
{
public:
	TArray<TSubclassOf<class UInteractionDefinition>> _interactionClasses;                           // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UInteractionDefinition>> _interactionsToDisableOnLockerClasses;         // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x30];                                      // 0x00E8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnLevelReadyToPlay();
	void Cosmetic_OnTwinOnLockerChanged(bool isOnLocker);
	void OnPlayerInLockerChanged(class ADBDPlayer* previousPlayerInLocker, class ADBDPlayer* newPlayerInLocker);
	void OnPushedMontageEnded(const struct FAnimationMontageDescriptor& montageDescriptor, bool interrupted);
	void OnPushedMontageStarted(const struct FAnimationMontageDescriptor& montageDescriptor, const float rate);
	void OnPushedMontageStopped(const struct FAnimationMontageDescriptor& montageDescriptor);

	bool IsTwinAttachedToLocker() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinLockerBlockerComponent">();
	}
	static class UTwinLockerBlockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinLockerBlockerComponent>();
	}
};
static_assert(alignof(UTwinLockerBlockerComponent) == 0x000008, "Wrong alignment on UTwinLockerBlockerComponent");
static_assert(sizeof(UTwinLockerBlockerComponent) == 0x000118, "Wrong size on UTwinLockerBlockerComponent");
static_assert(offsetof(UTwinLockerBlockerComponent, _interactionClasses) == 0x0000B8, "Member 'UTwinLockerBlockerComponent::_interactionClasses' has a wrong offset!");
static_assert(offsetof(UTwinLockerBlockerComponent, _interactionsToDisableOnLockerClasses) == 0x0000D8, "Member 'UTwinLockerBlockerComponent::_interactionsToDisableOnLockerClasses' has a wrong offset!");

// Class TheTwins.TwinLullabyRangeAdditiveEffect
// 0x0150 (0x04A0 - 0x0350)
class UTwinLullabyRangeAdditiveEffect final : public UStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _defaultTwinLullabyDormantRange;                   // 0x0350(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _twinLullabyDormantRange;                          // 0x0378(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _twinLullabyAttachedRange;                         // 0x03F8(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x28];                                     // 0x0478(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinLullabyRangeAdditiveEffect">();
	}
	static class UTwinLullabyRangeAdditiveEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinLullabyRangeAdditiveEffect>();
	}
};
static_assert(alignof(UTwinLullabyRangeAdditiveEffect) == 0x000008, "Wrong alignment on UTwinLullabyRangeAdditiveEffect");
static_assert(sizeof(UTwinLullabyRangeAdditiveEffect) == 0x0004A0, "Wrong size on UTwinLullabyRangeAdditiveEffect");
static_assert(offsetof(UTwinLullabyRangeAdditiveEffect, _defaultTwinLullabyDormantRange) == 0x000350, "Member 'UTwinLullabyRangeAdditiveEffect::_defaultTwinLullabyDormantRange' has a wrong offset!");
static_assert(offsetof(UTwinLullabyRangeAdditiveEffect, _twinLullabyDormantRange) == 0x000378, "Member 'UTwinLullabyRangeAdditiveEffect::_twinLullabyDormantRange' has a wrong offset!");
static_assert(offsetof(UTwinLullabyRangeAdditiveEffect, _twinLullabyAttachedRange) == 0x0003F8, "Member 'UTwinLullabyRangeAdditiveEffect::_twinLullabyAttachedRange' has a wrong offset!");

// Class TheTwins.TwinOutlineUpdateStrategy
// 0x0050 (0x0110 - 0x00C0)
class UTwinOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _visibleColorForKiller;                            // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x40];                                      // 0x00D0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinOutlineUpdateStrategy">();
	}
	static class UTwinOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UTwinOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UTwinOutlineUpdateStrategy");
static_assert(sizeof(UTwinOutlineUpdateStrategy) == 0x000110, "Wrong size on UTwinOutlineUpdateStrategy");
static_assert(offsetof(UTwinOutlineUpdateStrategy, _visibleColorForKiller) == 0x0000C0, "Member 'UTwinOutlineUpdateStrategy::_visibleColorForKiller' has a wrong offset!");

// Class TheTwins.TwinPlacerComponent
// 0x0010 (0x0280 - 0x0270)
class UTwinPlacerComponent final : public UObjectPlacerComponent
{
public:
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinPlacerComponent">();
	}
	static class UTwinPlacerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinPlacerComponent>();
	}
};
static_assert(alignof(UTwinPlacerComponent) == 0x000010, "Wrong alignment on UTwinPlacerComponent");
static_assert(sizeof(UTwinPlacerComponent) == 0x000280, "Wrong size on UTwinPlacerComponent");

// Class TheTwins.TwinPossessionComponent
// 0x0020 (0x0168 - 0x0148)
class UTwinPossessionComponent final : public UPossessionComponent
{
public:
	uint8                                         Pad_148[0x20];                                     // 0x0148(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinPossessionComponent">();
	}
	static class UTwinPossessionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinPossessionComponent>();
	}
};
static_assert(alignof(UTwinPossessionComponent) == 0x000008, "Wrong alignment on UTwinPossessionComponent");
static_assert(sizeof(UTwinPossessionComponent) == 0x000168, "Wrong size on UTwinPossessionComponent");

// Class TheTwins.TwinPossessNegationEffectComponent
// 0x0020 (0x00F0 - 0x00D0)
class UTwinPossessNegationEffectComponent final : public UPossessNegationEffectComponent
{
public:
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinPossessNegationEffectComponent">();
	}
	static class UTwinPossessNegationEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinPossessNegationEffectComponent>();
	}
};
static_assert(alignof(UTwinPossessNegationEffectComponent) == 0x000008, "Wrong alignment on UTwinPossessNegationEffectComponent");
static_assert(sizeof(UTwinPossessNegationEffectComponent) == 0x0000F0, "Wrong size on UTwinPossessNegationEffectComponent");

// Class TheTwins.TwinRevealAuraOnAttachedToSurvivorStatusEffect
// 0x0000 (0x0380 - 0x0380)
class UTwinRevealAuraOnAttachedToSurvivorStatusEffect final : public UActivateOnEventTimedStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinRevealAuraOnAttachedToSurvivorStatusEffect">();
	}
	static class UTwinRevealAuraOnAttachedToSurvivorStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinRevealAuraOnAttachedToSurvivorStatusEffect>();
	}
};
static_assert(alignof(UTwinRevealAuraOnAttachedToSurvivorStatusEffect) == 0x000008, "Wrong alignment on UTwinRevealAuraOnAttachedToSurvivorStatusEffect");
static_assert(sizeof(UTwinRevealAuraOnAttachedToSurvivorStatusEffect) == 0x000380, "Wrong size on UTwinRevealAuraOnAttachedToSurvivorStatusEffect");

// Class TheTwins.TwinsAnimInstance
// 0x00A0 (0x06A0 - 0x0600)
class UTwinsAnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isDormant;                                        // 0x0600(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasBrotherAttached;                               // 0x0601(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPossessing;                                     // 0x0602(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isWakingUpFromPossess;                            // 0x0603(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAutoPossessingAfterRelease;                     // 0x0604(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_605[0x9B];                                     // 0x0605(0x009B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinsAnimInstance">();
	}
	static class UTwinsAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinsAnimInstance>();
	}
};
static_assert(alignof(UTwinsAnimInstance) == 0x000010, "Wrong alignment on UTwinsAnimInstance");
static_assert(sizeof(UTwinsAnimInstance) == 0x0006A0, "Wrong size on UTwinsAnimInstance");
static_assert(offsetof(UTwinsAnimInstance, _isDormant) == 0x000600, "Member 'UTwinsAnimInstance::_isDormant' has a wrong offset!");
static_assert(offsetof(UTwinsAnimInstance, _hasBrotherAttached) == 0x000601, "Member 'UTwinsAnimInstance::_hasBrotherAttached' has a wrong offset!");
static_assert(offsetof(UTwinsAnimInstance, _isPossessing) == 0x000602, "Member 'UTwinsAnimInstance::_isPossessing' has a wrong offset!");
static_assert(offsetof(UTwinsAnimInstance, _isWakingUpFromPossess) == 0x000603, "Member 'UTwinsAnimInstance::_isWakingUpFromPossess' has a wrong offset!");
static_assert(offsetof(UTwinsAnimInstance, _isAutoPossessingAfterRelease) == 0x000604, "Member 'UTwinsAnimInstance::_isAutoPossessingAfterRelease' has a wrong offset!");

// Class TheTwins.TwinsSurvivorSubAnimInstance
// 0x0040 (0x0590 - 0x0550)
class UTwinsSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isRemovingTwin;                                   // 0x0550(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x0551(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouching;                                      // 0x0552(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_553[0x3D];                                     // 0x0553(0x003D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinsSurvivorSubAnimInstance">();
	}
	static class UTwinsSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinsSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(UTwinsSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on UTwinsSurvivorSubAnimInstance");
static_assert(sizeof(UTwinsSurvivorSubAnimInstance) == 0x000590, "Wrong size on UTwinsSurvivorSubAnimInstance");
static_assert(offsetof(UTwinsSurvivorSubAnimInstance, _isRemovingTwin) == 0x000550, "Member 'UTwinsSurvivorSubAnimInstance::_isRemovingTwin' has a wrong offset!");
static_assert(offsetof(UTwinsSurvivorSubAnimInstance, _isIdle) == 0x000551, "Member 'UTwinsSurvivorSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UTwinsSurvivorSubAnimInstance, _isCrouching) == 0x000552, "Member 'UTwinsSurvivorSubAnimInstance::_isCrouching' has a wrong offset!");

// Class TheTwins.TwinStateHelperComponent
// 0x0030 (0x00E8 - 0x00B8)
class UTwinStateHelperComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinStateHelperComponent">();
	}
	static class UTwinStateHelperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinStateHelperComponent>();
	}
};
static_assert(alignof(UTwinStateHelperComponent) == 0x000008, "Wrong alignment on UTwinStateHelperComponent");
static_assert(sizeof(UTwinStateHelperComponent) == 0x0000E8, "Wrong size on UTwinStateHelperComponent");

// Class TheTwins.TwinStunnableComponent
// 0x0028 (0x00E0 - 0x00B8)
class UTwinStunnableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinStunnableComponent">();
	}
	static class UTwinStunnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinStunnableComponent>();
	}
};
static_assert(alignof(UTwinStunnableComponent) == 0x000008, "Wrong alignment on UTwinStunnableComponent");
static_assert(sizeof(UTwinStunnableComponent) == 0x0000E0, "Wrong size on UTwinStunnableComponent");

// Class TheTwins.TwinSubjectProvider
// 0x0008 (0x0050 - 0x0048)
class UTwinSubjectProvider final : public UModifierSubjectProvider
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ListenToTwinSet(class ASlasherPlayer* killer);
	void OnTwinSet(class AConjoinedTwin* twin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TwinSubjectProvider">();
	}
	static class UTwinSubjectProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTwinSubjectProvider>();
	}
};
static_assert(alignof(UTwinSubjectProvider) == 0x000008, "Wrong alignment on UTwinSubjectProvider");
static_assert(sizeof(UTwinSubjectProvider) == 0x000050, "Wrong size on UTwinSubjectProvider");

}

