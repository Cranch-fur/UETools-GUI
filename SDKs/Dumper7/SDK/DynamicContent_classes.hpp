#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DynamicContent

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_classes.hpp"
#include "DynamicContent_structs.hpp"


namespace SDK
{

// Class DynamicContent.AsyncTaskDownloadCacheImage
// 0x0030 (0x0068 - 0x0038)
class UAsyncTaskDownloadCacheImage final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(class UTexture2DDynamic* Texture)> OnSuccess;                      // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UTexture2DDynamic* Texture)> OnFail;                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 _url;                                              // 0x0058(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskDownloadCacheImage">();
	}
	static class UAsyncTaskDownloadCacheImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskDownloadCacheImage>();
	}
};
static_assert(alignof(UAsyncTaskDownloadCacheImage) == 0x000008, "Wrong alignment on UAsyncTaskDownloadCacheImage");
static_assert(sizeof(UAsyncTaskDownloadCacheImage) == 0x000068, "Wrong size on UAsyncTaskDownloadCacheImage");
static_assert(offsetof(UAsyncTaskDownloadCacheImage, OnSuccess) == 0x000038, "Member 'UAsyncTaskDownloadCacheImage::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAsyncTaskDownloadCacheImage, OnFail) == 0x000048, "Member 'UAsyncTaskDownloadCacheImage::OnFail' has a wrong offset!");
static_assert(offsetof(UAsyncTaskDownloadCacheImage, _url) == 0x000058, "Member 'UAsyncTaskDownloadCacheImage::_url' has a wrong offset!");

// Class DynamicContent.DownloadingTextureTask
// 0x0038 (0x0068 - 0x0030)
class UDownloadingTextureTask final : public UObject
{
public:
	class UAsyncTaskDownloadCacheImage*           _downloadingTask;                                  // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _url;                                              // 0x0038(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2DDynamic*                      _downloadedTexture;                                // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnDownloadFailed(class UTexture2DDynamic* textureDownloaded);
	void OnDownloadSucceeded(class UTexture2DDynamic* textureDownloaded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DownloadingTextureTask">();
	}
	static class UDownloadingTextureTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDownloadingTextureTask>();
	}
};
static_assert(alignof(UDownloadingTextureTask) == 0x000008, "Wrong alignment on UDownloadingTextureTask");
static_assert(sizeof(UDownloadingTextureTask) == 0x000068, "Wrong size on UDownloadingTextureTask");
static_assert(offsetof(UDownloadingTextureTask, _downloadingTask) == 0x000030, "Member 'UDownloadingTextureTask::_downloadingTask' has a wrong offset!");
static_assert(offsetof(UDownloadingTextureTask, _url) == 0x000038, "Member 'UDownloadingTextureTask::_url' has a wrong offset!");
static_assert(offsetof(UDownloadingTextureTask, _downloadedTexture) == 0x000060, "Member 'UDownloadingTextureTask::_downloadedTexture' has a wrong offset!");

// Class DynamicContent.DownloadMultiTextureTask
// 0x0080 (0x00B0 - 0x0030)
class UDownloadMultiTextureTask final : public UObject
{
public:
	TArray<class UDownloadingTextureTask*>        _downloadingTasks;                                 // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UTexture2DDynamic*>   _downloadedTextures;                               // 0x0058(0x0050)(Transient, NativeAccessSpecifierPrivate)
	int32                                         _remainingTasks;                                   // 0x00A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTextureDownloadComplete(class UDownloadingTextureTask* taskCompleted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DownloadMultiTextureTask">();
	}
	static class UDownloadMultiTextureTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDownloadMultiTextureTask>();
	}
};
static_assert(alignof(UDownloadMultiTextureTask) == 0x000008, "Wrong alignment on UDownloadMultiTextureTask");
static_assert(sizeof(UDownloadMultiTextureTask) == 0x0000B0, "Wrong size on UDownloadMultiTextureTask");
static_assert(offsetof(UDownloadMultiTextureTask, _downloadingTasks) == 0x000030, "Member 'UDownloadMultiTextureTask::_downloadingTasks' has a wrong offset!");
static_assert(offsetof(UDownloadMultiTextureTask, _downloadedTextures) == 0x000058, "Member 'UDownloadMultiTextureTask::_downloadedTextures' has a wrong offset!");
static_assert(offsetof(UDownloadMultiTextureTask, _remainingTasks) == 0x0000A8, "Member 'UDownloadMultiTextureTask::_remainingTasks' has a wrong offset!");

// Class DynamicContent.DynamicContentHolder
// 0x01C8 (0x0200 - 0x0038)
class UDynamicContentHolder final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x138];                                     // 0x0038(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLRUTextureCache                       _loadedTextures;                                   // 0x0170(0x0068)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FTaskContainer>                 _currentTasks;                                     // 0x01D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class ULoopBannerProvider*                    _marketingBannerProvider;                          // 0x01E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULoopBannerProvider*                    _eventsBannerProvider;                             // 0x01F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULoadingImagesDataProvider*             _loadingImagesDataProvider;                        // 0x01F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnDownloadingTaskComplete(class UDownloadMultiTextureTask* completeTask);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicContentHolder">();
	}
	static class UDynamicContentHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicContentHolder>();
	}
};
static_assert(alignof(UDynamicContentHolder) == 0x000008, "Wrong alignment on UDynamicContentHolder");
static_assert(sizeof(UDynamicContentHolder) == 0x000200, "Wrong size on UDynamicContentHolder");
static_assert(offsetof(UDynamicContentHolder, _loadedTextures) == 0x000170, "Member 'UDynamicContentHolder::_loadedTextures' has a wrong offset!");
static_assert(offsetof(UDynamicContentHolder, _currentTasks) == 0x0001D8, "Member 'UDynamicContentHolder::_currentTasks' has a wrong offset!");
static_assert(offsetof(UDynamicContentHolder, _marketingBannerProvider) == 0x0001E8, "Member 'UDynamicContentHolder::_marketingBannerProvider' has a wrong offset!");
static_assert(offsetof(UDynamicContentHolder, _eventsBannerProvider) == 0x0001F0, "Member 'UDynamicContentHolder::_eventsBannerProvider' has a wrong offset!");
static_assert(offsetof(UDynamicContentHolder, _loadingImagesDataProvider) == 0x0001F8, "Member 'UDynamicContentHolder::_loadingImagesDataProvider' has a wrong offset!");

// Class DynamicContent.LoadingImagesDataProvider
// 0x0058 (0x0088 - 0x0030)
class ULoadingImagesDataProvider final : public UObject
{
public:
	TMap<class FName, struct FLoadingImages>      _cachedLoadingImages;                              // 0x0030(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UDynamicContentHolder*                  _owningDynamicContentHolder;                       // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingImagesDataProvider">();
	}
	static class ULoadingImagesDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingImagesDataProvider>();
	}
};
static_assert(alignof(ULoadingImagesDataProvider) == 0x000008, "Wrong alignment on ULoadingImagesDataProvider");
static_assert(sizeof(ULoadingImagesDataProvider) == 0x000088, "Wrong size on ULoadingImagesDataProvider");
static_assert(offsetof(ULoadingImagesDataProvider, _cachedLoadingImages) == 0x000030, "Member 'ULoadingImagesDataProvider::_cachedLoadingImages' has a wrong offset!");
static_assert(offsetof(ULoadingImagesDataProvider, _owningDynamicContentHolder) == 0x000080, "Member 'ULoadingImagesDataProvider::_owningDynamicContentHolder' has a wrong offset!");

// Class DynamicContent.LoopBannerProvider
// 0x0018 (0x0048 - 0x0030)
class ULoopBannerProvider final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _currentLoopIndex;                                 // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoopBannerProvider">();
	}
	static class ULoopBannerProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoopBannerProvider>();
	}
};
static_assert(alignof(ULoopBannerProvider) == 0x000008, "Wrong alignment on ULoopBannerProvider");
static_assert(sizeof(ULoopBannerProvider) == 0x000048, "Wrong size on ULoopBannerProvider");
static_assert(offsetof(ULoopBannerProvider, _currentLoopIndex) == 0x000040, "Member 'ULoopBannerProvider::_currentLoopIndex' has a wrong offset!");

}

