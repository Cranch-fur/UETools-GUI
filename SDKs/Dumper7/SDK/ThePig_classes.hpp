#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ThePig

#include "Basic.hpp"

#include "DeadByDaylight_classes.hpp"
#include "Engine_structs.hpp"
#include "NetworkUtilities_structs.hpp"
#include "DBDAttack_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "DataTableUtilities_structs.hpp"


namespace SDK
{

// Class ThePig.Addon_ThePig_JigsawSketch
// 0x0050 (0x0308 - 0x02B8)
class UAddon_ThePig_JigsawSketch final : public UItemAddon
{
public:
	TMap<class ACamperPlayer*, class AGenerator*> _trackedGeneratorRepairs;                          // 0x02B8(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_ThePig_JigsawSketch">();
	}
	static class UAddon_ThePig_JigsawSketch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_ThePig_JigsawSketch>();
	}
};
static_assert(alignof(UAddon_ThePig_JigsawSketch) == 0x000008, "Wrong alignment on UAddon_ThePig_JigsawSketch");
static_assert(sizeof(UAddon_ThePig_JigsawSketch) == 0x000308, "Wrong size on UAddon_ThePig_JigsawSketch");
static_assert(offsetof(UAddon_ThePig_JigsawSketch, _trackedGeneratorRepairs) == 0x0002B8, "Member 'UAddon_ThePig_JigsawSketch::_trackedGeneratorRepairs' has a wrong offset!");

// Class ThePig.AttachReverseBearTrap
// 0x0000 (0x0620 - 0x0620)
class UAttachReverseBearTrap final : public UInteractionDefinition
{
public:
	class ACamperPlayer* GetCamper() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachReverseBearTrap">();
	}
	static class UAttachReverseBearTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttachReverseBearTrap>();
	}
};
static_assert(alignof(UAttachReverseBearTrap) == 0x000010, "Wrong alignment on UAttachReverseBearTrap");
static_assert(sizeof(UAttachReverseBearTrap) == 0x000620, "Wrong size on UAttachReverseBearTrap");

// Class ThePig.DetectivesHunch
// 0x0268 (0x0630 - 0x03C8)
class UDetectivesHunch final : public UPerk
{
public:
	TSet<TSoftClassPtr<class UClass>>             _interactableClasses;                              // 0x03C8(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         _revealRanges[0x3];                                // 0x0418(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _revealDuration;                                   // 0x0424(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FTimerHandle>      _actorToTimerMap;                                  // 0x0428(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x50];                                     // 0x0478(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FObjectFastArray                       _revealedActors;                                   // 0x04C8(0x0148)(Net, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_610[0x20];                                     // 0x0610(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DetectivesHunch">();
	}
	static class UDetectivesHunch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDetectivesHunch>();
	}
};
static_assert(alignof(UDetectivesHunch) == 0x000008, "Wrong alignment on UDetectivesHunch");
static_assert(sizeof(UDetectivesHunch) == 0x000630, "Wrong size on UDetectivesHunch");
static_assert(offsetof(UDetectivesHunch, _interactableClasses) == 0x0003C8, "Member 'UDetectivesHunch::_interactableClasses' has a wrong offset!");
static_assert(offsetof(UDetectivesHunch, _revealRanges) == 0x000418, "Member 'UDetectivesHunch::_revealRanges' has a wrong offset!");
static_assert(offsetof(UDetectivesHunch, _revealDuration) == 0x000424, "Member 'UDetectivesHunch::_revealDuration' has a wrong offset!");
static_assert(offsetof(UDetectivesHunch, _actorToTimerMap) == 0x000428, "Member 'UDetectivesHunch::_actorToTimerMap' has a wrong offset!");
static_assert(offsetof(UDetectivesHunch, _revealedActors) == 0x0004C8, "Member 'UDetectivesHunch::_revealedActors' has a wrong offset!");

// Class ThePig.K11AnimInstance
// 0x0010 (0x0610 - 0x0600)
class UK11AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isAmbushAttack;                                   // 0x0600(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x0601(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouchPressed;                                  // 0x0602(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_603[0xD];                                      // 0x0603(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K11AnimInstance">();
	}
	static class UK11AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK11AnimInstance>();
	}
};
static_assert(alignof(UK11AnimInstance) == 0x000010, "Wrong alignment on UK11AnimInstance");
static_assert(sizeof(UK11AnimInstance) == 0x000610, "Wrong size on UK11AnimInstance");
static_assert(offsetof(UK11AnimInstance, _isAmbushAttack) == 0x000600, "Member 'UK11AnimInstance::_isAmbushAttack' has a wrong offset!");
static_assert(offsetof(UK11AnimInstance, _isCrouched) == 0x000601, "Member 'UK11AnimInstance::_isCrouched' has a wrong offset!");
static_assert(offsetof(UK11AnimInstance, _isCrouchPressed) == 0x000602, "Member 'UK11AnimInstance::_isCrouchPressed' has a wrong offset!");

// Class ThePig.PigAmbushAttack
// 0x0010 (0x0390 - 0x0380)
class UPigAmbushAttack final : public UPounceAttack
{
public:
	uint8                                         Pad_380[0x10];                                     // 0x0380(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PigAmbushAttack">();
	}
	static class UPigAmbushAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPigAmbushAttack>();
	}
};
static_assert(alignof(UPigAmbushAttack) == 0x000010, "Wrong alignment on UPigAmbushAttack");
static_assert(sizeof(UPigAmbushAttack) == 0x000390, "Wrong size on UPigAmbushAttack");

// Class ThePig.PigAmbushAttackOpenSubstate
// 0x0008 (0x0138 - 0x0130)
class UPigAmbushAttackOpenSubstate final : public UPounceAttackOpenSubstate
{
public:
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PigAmbushAttackOpenSubstate">();
	}
	static class UPigAmbushAttackOpenSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPigAmbushAttackOpenSubstate>();
	}
};
static_assert(alignof(UPigAmbushAttackOpenSubstate) == 0x000008, "Wrong alignment on UPigAmbushAttackOpenSubstate");
static_assert(sizeof(UPigAmbushAttackOpenSubstate) == 0x000138, "Wrong size on UPigAmbushAttackOpenSubstate");

// Class ThePig.PigAmbushAttackHittingSubstate
// 0x0000 (0x01A0 - 0x01A0)
class UPigAmbushAttackHittingSubstate final : public UPounceAttackHittingSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PigAmbushAttackHittingSubstate">();
	}
	static class UPigAmbushAttackHittingSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPigAmbushAttackHittingSubstate>();
	}
};
static_assert(alignof(UPigAmbushAttackHittingSubstate) == 0x000008, "Wrong alignment on UPigAmbushAttackHittingSubstate");
static_assert(sizeof(UPigAmbushAttackHittingSubstate) == 0x0001A0, "Wrong size on UPigAmbushAttackHittingSubstate");

// Class ThePig.PigAmbushAttackSuccessSubstate
// 0x0000 (0x0118 - 0x0118)
class UPigAmbushAttackSuccessSubstate final : public UPounceAttackSuccessSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PigAmbushAttackSuccessSubstate">();
	}
	static class UPigAmbushAttackSuccessSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPigAmbushAttackSuccessSubstate>();
	}
};
static_assert(alignof(UPigAmbushAttackSuccessSubstate) == 0x000008, "Wrong alignment on UPigAmbushAttackSuccessSubstate");
static_assert(sizeof(UPigAmbushAttackSuccessSubstate) == 0x000118, "Wrong size on UPigAmbushAttackSuccessSubstate");

// Class ThePig.PigAmbushAttackMissSubstate
// 0x0000 (0x0120 - 0x0120)
class UPigAmbushAttackMissSubstate final : public UPounceAttackMissSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PigAmbushAttackMissSubstate">();
	}
	static class UPigAmbushAttackMissSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPigAmbushAttackMissSubstate>();
	}
};
static_assert(alignof(UPigAmbushAttackMissSubstate) == 0x000008, "Wrong alignment on UPigAmbushAttackMissSubstate");
static_assert(sizeof(UPigAmbushAttackMissSubstate) == 0x000120, "Wrong size on UPigAmbushAttackMissSubstate");

// Class ThePig.PigAmbushAttackObstructSubstate
// 0x0000 (0x0128 - 0x0128)
class UPigAmbushAttackObstructSubstate final : public UPounceAttackObstructSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PigAmbushAttackObstructSubstate">();
	}
	static class UPigAmbushAttackObstructSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPigAmbushAttackObstructSubstate>();
	}
};
static_assert(alignof(UPigAmbushAttackObstructSubstate) == 0x000008, "Wrong alignment on UPigAmbushAttackObstructSubstate");
static_assert(sizeof(UPigAmbushAttackObstructSubstate) == 0x000128, "Wrong size on UPigAmbushAttackObstructSubstate");

// Class ThePig.RBTSurvivorSubAnimInstance
// 0x0040 (0x0590 - 0x0550)
class URBTSurvivorSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_548[0x40];                                     // 0x0548(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isRemovingRBT;                                    // 0x0588(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasSkillCheckFailed;                              // 0x0589(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58A[0x6];                                      // 0x058A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTSurvivorSubAnimInstance">();
	}
	static class URBTSurvivorSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTSurvivorSubAnimInstance>();
	}
};
static_assert(alignof(URBTSurvivorSubAnimInstance) == 0x000010, "Wrong alignment on URBTSurvivorSubAnimInstance");
static_assert(sizeof(URBTSurvivorSubAnimInstance) == 0x000590, "Wrong size on URBTSurvivorSubAnimInstance");
static_assert(offsetof(URBTSurvivorSubAnimInstance, _isRemovingRBT) == 0x000588, "Member 'URBTSurvivorSubAnimInstance::_isRemovingRBT' has a wrong offset!");
static_assert(offsetof(URBTSurvivorSubAnimInstance, _hasSkillCheckFailed) == 0x000589, "Member 'URBTSurvivorSubAnimInstance::_hasSkillCheckFailed' has a wrong offset!");

// Class ThePig.RemoveReverseBearTrapChargeable
// 0x0040 (0x0780 - 0x0740)
class URemoveReverseBearTrapChargeable final : public UChargeableInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _audibleRangeOnSearch;                             // 0x0740(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _timedRevealStatusEffect;                          // 0x0768(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_770[0x10];                                     // 0x0770(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BP_OnFinishWithDetach(class ACamperPlayer* searchingPlayer);
	void BP_OnFinishWithoutDetach(class ACamperPlayer* searchingPlayer);

	bool HasSuccessfullyRemoved() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveReverseBearTrapChargeable">();
	}
	static class URemoveReverseBearTrapChargeable* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveReverseBearTrapChargeable>();
	}
};
static_assert(alignof(URemoveReverseBearTrapChargeable) == 0x000010, "Wrong alignment on URemoveReverseBearTrapChargeable");
static_assert(sizeof(URemoveReverseBearTrapChargeable) == 0x000780, "Wrong size on URemoveReverseBearTrapChargeable");
static_assert(offsetof(URemoveReverseBearTrapChargeable, _audibleRangeOnSearch) == 0x000740, "Member 'URemoveReverseBearTrapChargeable::_audibleRangeOnSearch' has a wrong offset!");
static_assert(offsetof(URemoveReverseBearTrapChargeable, _timedRevealStatusEffect) == 0x000768, "Member 'URemoveReverseBearTrapChargeable::_timedRevealStatusEffect' has a wrong offset!");

}

