#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DeadByDaylight

#include "Basic.hpp"

#include "DeadByDaylight_classes.hpp"
#include "DeadByDaylight_parameters.hpp"


namespace SDK
{

// Function DeadByDaylight.UMGCloseTooltipWidget.HandleCloseTooltipButton
// (Final, Native, Private)

void UUMGCloseTooltipWidget::HandleCloseTooltipButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCloseTooltipWidget", "HandleCloseTooltipButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.CallConsoleCmdOnServer_Server
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const class FString&                    commandLine                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::CallConsoleCmdOnServer_Server(const class FString& commandLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "CallConsoleCmdOnServer_Server");

	Params::DBDPlayerControllerBase_CallConsoleCmdOnServer_Server Parms{};

	Parms.commandLine = std::move(commandLine);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_EACMessageFromServer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const TArray<uint8>&                    message                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Client_EACMessageFromServer(const TArray<uint8>& message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_EACMessageFromServer");

	Params::DBDPlayerControllerBase_Client_EACMessageFromServer Parms{};

	Parms.message = std::move(message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_FinishedPlaying
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void ADBDPlayerControllerBase::Client_FinishedPlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_FinishedPlaying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_GameEnded
// (Net, NetReliable, Native, Event, Public, NetClient)

void ADBDPlayerControllerBase::Client_GameEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_GameEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_RequestPlayerProfile
// (Net, NetReliable, Native, Event, Public, NetClient)

void ADBDPlayerControllerBase::Client_RequestPlayerProfile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_RequestPlayerProfile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_SendLogs
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const TArray<class FString>&            ensures                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Client_SendLogs(const TArray<class FString>& ensures)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_SendLogs");

	Params::DBDPlayerControllerBase_Client_SendLogs Parms{};

	Parms.ensures = std::move(ensures);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_SendServerAuthentication
// (Final, Net, NetReliable, Native, Event, Private, NetClient, NetValidate)
// Parameters:
// const class FString&                    authServerTicket                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint64                                  steamID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  ticketLength                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Client_SendServerAuthentication(const class FString& authServerTicket, uint64 steamID, uint32 ticketLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_SendServerAuthentication");

	Params::DBDPlayerControllerBase_Client_SendServerAuthentication Parms{};

	Parms.authServerTicket = std::move(authServerTicket);
	Parms.steamID = steamID;
	Parms.ticketLength = ticketLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_SendWarning
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    penaltyStarts                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Client_SendWarning(bool penaltyStarts, float seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_SendWarning");

	Params::DBDPlayerControllerBase_Client_SendWarning Parms{};

	Parms.penaltyStarts = penaltyStarts;
	Parms.seconds = seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Client_ValidateServer
// (Net, NetReliable, Native, Event, Public, NetClient)

void ADBDPlayerControllerBase::Client_ValidateServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Client_ValidateServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_BuildFromMap
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    map                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::DBD_BuildFromMap(const class FString& map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_BuildFromMap");

	Params::DBDPlayerControllerBase_DBD_BuildFromMap Parms{};

	Parms.map = std::move(map);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_BuildFromPlayerCount
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::DBD_BuildFromPlayerCount(int32 count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_BuildFromPlayerCount");

	Params::DBDPlayerControllerBase_DBD_BuildFromPlayerCount Parms{};

	Parms.count = count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_BuildFromPremadeMap
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    map                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::DBD_BuildFromPremadeMap(const class FString& map)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_BuildFromPremadeMap");

	Params::DBDPlayerControllerBase_DBD_BuildFromPremadeMap Parms{};

	Parms.map = std::move(map);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_BuildFromSeed
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::DBD_BuildFromSeed(int32 seed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_BuildFromSeed");

	Params::DBDPlayerControllerBase_DBD_BuildFromSeed Parms{};

	Parms.seed = seed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_BuildFromTile
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   matrixX                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   matrixY                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    name                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::DBD_BuildFromTile(int32 matrixX, int32 matrixY, int32 rotation, const class FString& name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_BuildFromTile");

	Params::DBDPlayerControllerBase_DBD_BuildFromTile Parms{};

	Parms.matrixX = matrixX;
	Parms.matrixY = matrixY;
	Parms.rotation = rotation;
	Parms.name = std::move(name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_DebugSendChatMessage
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::DBD_DebugSendChatMessage(const class FString& msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_DebugSendChatMessage");

	Params::DBDPlayerControllerBase_DBD_DebugSendChatMessage Parms{};

	Parms.msg = std::move(msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_FillAllScoreCategories
// (Final, Exec, Native, Public, BlueprintCallable)

void ADBDPlayerControllerBase::DBD_FillAllScoreCategories()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_FillAllScoreCategories");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_FillScoreCategory
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::DBD_FillScoreCategory(int32 category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_FillScoreCategory");

	Params::DBDPlayerControllerBase_DBD_FillScoreCategory Parms{};

	Parms.category = category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_FireTestScore
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::DBD_FireTestScore(int32 category, float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_FireTestScore");

	Params::DBDPlayerControllerBase_DBD_FireTestScore Parms{};

	Parms.category = category;
	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_SetCurrentCharacterPrestigeDatesFuture
// (Final, Exec, Native, Public)

void ADBDPlayerControllerBase::DBD_SetCurrentCharacterPrestigeDatesFuture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_SetCurrentCharacterPrestigeDatesFuture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_SetCurrentCharacterPrestigeDatesNow
// (Final, Exec, Native, Public)

void ADBDPlayerControllerBase::DBD_SetCurrentCharacterPrestigeDatesNow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_SetCurrentCharacterPrestigeDatesNow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_SetCurrentCharacterPrestigeDatesPast
// (Final, Exec, Native, Public)

void ADBDPlayerControllerBase::DBD_SetCurrentCharacterPrestigeDatesPast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_SetCurrentCharacterPrestigeDatesPast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.DBD_UpdateLocalStats
// (Final, Exec, Native, Public, BlueprintCallable)

void ADBDPlayerControllerBase::DBD_UpdateLocalStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "DBD_UpdateLocalStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Server
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    commandLine                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Server(const class FString& commandLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Server");

	Params::DBDPlayerControllerBase_Server Parms{};

	Parms.commandLine = std::move(commandLine);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Server_EACMessageFromClient
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const TArray<uint8>&                    message                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Server_EACMessageFromClient(const TArray<uint8>& message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Server_EACMessageFromClient");

	Params::DBDPlayerControllerBase_Server_EACMessageFromClient Parms{};

	Parms.message = std::move(message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Server_ReceivePlayerProfile
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const struct FPlayerSavedProfileDataShared&savedProfileData                                       (Parm, NativeAccessSpecifierPublic)
// const struct FPlayerLoadoutData&        playerLoadout                                          (Parm, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Server_ReceivePlayerProfile(const struct FPlayerSavedProfileDataShared& savedProfileData, const struct FPlayerLoadoutData& playerLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Server_ReceivePlayerProfile");

	Params::DBDPlayerControllerBase_Server_ReceivePlayerProfile Parms{};

	Parms.savedProfileData = std::move(savedProfileData);
	Parms.playerLoadout = std::move(playerLoadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Server_SendClientAuthentication
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const class FString&                    authClientTicket                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint64                                  steamID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  ticketLength                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Server_SendClientAuthentication(const class FString& authClientTicket, uint64 steamID, uint32 ticketLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Server_SendClientAuthentication");

	Params::DBDPlayerControllerBase_Server_SendClientAuthentication Parms{};

	Parms.authClientTicket = std::move(authClientTicket);
	Parms.steamID = steamID;
	Parms.ticketLength = ticketLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Server_SendMessage
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const class FString&                    message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Server_SendMessage(const class FString& message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Server_SendMessage");

	Params::DBDPlayerControllerBase_Server_SendMessage Parms{};

	Parms.message = std::move(message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Server_SetConsecutiveMatchStreak
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   consecutiveMatch                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Server_SetConsecutiveMatchStreak(int32 consecutiveMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Server_SetConsecutiveMatchStreak");

	Params::DBDPlayerControllerBase_Server_SetConsecutiveMatchStreak Parms{};

	Parms.consecutiveMatch = consecutiveMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerControllerBase.Server_UpdateReplicatedPips
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   pipsToAdd                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerControllerBase::Server_UpdateReplicatedPips(int32 pipsToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerControllerBase", "Server_UpdateReplicatedPips");

	Params::DBDPlayerControllerBase_Server_UpdateReplicatedPips Parms{};

	Parms.pipsToAdd = pipsToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviour.Pause
// (Native, Public)

void UAICharacterBehaviour::Pause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviour", "Pause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviour.Resume
// (Native, Public)

void UAICharacterBehaviour::Resume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviour", "Resume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviour.SetEnable
// (Final, Native, Public)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterBehaviour::SetEnable(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviour", "SetEnable");

	Params::AICharacterBehaviour_SetEnable Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviour.Start
// (Native, Public)

void UAICharacterBehaviour::Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviour", "Start");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviour.Stop
// (Native, Public)

void UAICharacterBehaviour::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviour", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviour.Update
// (Native, Public)
// Parameters:
// float                                   deltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterBehaviour::Update(float deltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviour", "Update");

	Params::AICharacterBehaviour_Update Parms{};

	Parms.deltaTime = deltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviour.IsEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAICharacterBehaviour::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviour", "IsEnabled");

	Params::AICharacterBehaviour_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.AddCondition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UBaseModifierCondition>conditionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBaseModifierCondition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseModifierCondition* UGameplayModifierContainer::AddCondition(TSubclassOf<class UBaseModifierCondition> conditionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "AddCondition");

	Params::GameplayModifierContainer_AddCondition Parms{};

	Parms.conditionType = conditionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.Apply
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::Apply(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "Apply");

	Params::GameplayModifierContainer_Apply Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.GameplayModifierContainer.Authority_ClearActivationTimer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UGameplayModifierContainer::Authority_ClearActivationTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "Authority_ClearActivationTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.Authority_InstantiateGameplayModifierConditions
// (Final, Native, Public, BlueprintCallable)

void UGameplayModifierContainer::Authority_InstantiateGameplayModifierConditions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "Authority_InstantiateGameplayModifierConditions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.Authority_SetActivationTimerPaused
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              paused                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::Authority_SetActivationTimerPaused(const bool paused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "Authority_SetActivationTimerPaused");

	Params::GameplayModifierContainer_Authority_SetActivationTimerPaused Parms{};

	Parms.paused = paused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.Authority_TriggerActivationTimer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   activationTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::Authority_TriggerActivationTimer(float activationTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "Authority_TriggerActivationTimer");

	Params::GameplayModifierContainer_Authority_TriggerActivationTimer Parms{};

	Parms.activationTime = activationTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.ListenToDispatcherGameEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              eventType                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::ListenToDispatcherGameEvent(const struct FGameplayTag& eventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "ListenToDispatcherGameEvent");

	Params::GameplayModifierContainer_ListenToDispatcherGameEvent Parms{};

	Parms.eventType = std::move(eventType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.OnApplyBegin
// (Event, Public, BlueprintEvent)

void UGameplayModifierContainer::OnApplyBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnApplyBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.GameplayModifierContainer.OnApplyEnd
// (Event, Public, BlueprintEvent)

void UGameplayModifierContainer::OnApplyEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnApplyEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.GameplayModifierContainer.OnGameEventDispatched
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::OnGameEventDispatched(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnGameEventDispatched");

	Params::GameplayModifierContainer_OnGameEventDispatched Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.OnInitialized
// (Native, Event, Public, BlueprintEvent)

void UGameplayModifierContainer::OnInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.OnInitialized_Internal
// (Native, Public)

void UGameplayModifierContainer::OnInitialized_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnInitialized_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.OnLevelReadyToPlay
// (Native, Event, Protected, BlueprintEvent)

void UGameplayModifierContainer::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.OnRep_ActivationTimer
// (Final, Native, Private)

void UGameplayModifierContainer::OnRep_ActivationTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnRep_ActivationTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.OnRep_ModifierData
// (Native, Protected)

void UGameplayModifierContainer::OnRep_ModifierData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnRep_ModifierData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.OnRep_TickableConditionsData
// (Final, Native, Protected)

void UGameplayModifierContainer::OnRep_TickableConditionsData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "OnRep_TickableConditionsData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.RemoveAllFlags
// (Final, Native, Public, BlueprintCallable)

void UGameplayModifierContainer::RemoveAllFlags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "RemoveAllFlags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.RemoveAllModifiers
// (Final, Native, Public, BlueprintCallable)

void UGameplayModifierContainer::RemoveAllModifiers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "RemoveAllModifiers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.RemoveModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::RemoveModifier(const struct FGameplayTag& type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "RemoveModifier");

	Params::GameplayModifierContainer_RemoveModifier Parms{};

	Parms.type = std::move(type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.SetFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              flag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    flagValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::SetFlag(const struct FGameplayTag& flag, bool flagValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "SetFlag");

	Params::GameplayModifierContainer_SetFlag Parms{};

	Parms.flag = std::move(flag);
	Parms.flagValue = flagValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.SetModifierValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GameplayModifierValue                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::SetModifierValue(const struct FGameplayTag& type, float GameplayModifierValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "SetModifierValue");

	Params::GameplayModifierContainer_SetModifierValue Parms{};

	Parms.type = std::move(type);
	Parms.GameplayModifierValue = GameplayModifierValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.SetUseApplyFunction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    use                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::SetUseApplyFunction(bool use)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "SetUseApplyFunction");

	Params::GameplayModifierContainer_SetUseApplyFunction Parms{};

	Parms.use = use;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.UnlistenToAllDispatcherGameEvents
// (Final, Native, Protected, BlueprintCallable)

void UGameplayModifierContainer::UnlistenToAllDispatcherGameEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "UnlistenToAllDispatcherGameEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.UnlistenToDispatcherGameEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              eventType                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::UnlistenToDispatcherGameEvent(const struct FGameplayTag& eventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "UnlistenToDispatcherGameEvent");

	Params::GameplayModifierContainer_UnlistenToDispatcherGameEvent Parms{};

	Parms.eventType = std::move(eventType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.UpdateIsApplicable
// (Final, Native, Public, BlueprintCallable)

void UGameplayModifierContainer::UpdateIsApplicable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "UpdateIsApplicable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.FireActiveStatusViewEvent
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// class FName                             statusViewID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             uniqueSourceID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FStatusViewSource&         statusViewSource                                       (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UGameplayModifierContainer::FireActiveStatusViewEvent(class FName statusViewID, class FName uniqueSourceID, const struct FStatusViewSource& statusViewSource) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "FireActiveStatusViewEvent");

	Params::GameplayModifierContainer_FireActiveStatusViewEvent Parms{};

	Parms.statusViewID = statusViewID;
	Parms.uniqueSourceID = uniqueSourceID;
	Parms.statusViewSource = std::move(statusViewSource);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierContainer.GetActivationTimerDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayModifierContainer::GetActivationTimerDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetActivationTimerDuration");

	Params::GameplayModifierContainer_GetActivationTimerDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetActivationTimerElapsedTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayModifierContainer::GetActivationTimerElapsedTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetActivationTimerElapsedTime");

	Params::GameplayModifierContainer_GetActivationTimerElapsedTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetActivationTimerElapsedTimePercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayModifierContainer::GetActivationTimerElapsedTimePercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetActivationTimerElapsedTimePercent");

	Params::GameplayModifierContainer_GetActivationTimerElapsedTimePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetActivationTimerPercentRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayModifierContainer::GetActivationTimerPercentRemaining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetActivationTimerPercentRemaining");

	Params::GameplayModifierContainer_GetActivationTimerPercentRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetActivationTimerRemainingTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayModifierContainer::GetActivationTimerRemainingTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetActivationTimerRemainingTime");

	Params::GameplayModifierContainer_GetActivationTimerRemainingTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetIconFilePathIndex
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayModifierContainer::GetIconFilePathIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetIconFilePathIndex");

	Params::GameplayModifierContainer_GetIconFilePathIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetInventoryItemType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInventoryItemType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInventoryItemType UGameplayModifierContainer::GetInventoryItemType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetInventoryItemType");

	Params::GameplayModifierContainer_GetInventoryItemType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetLevelToDisplay
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayModifierContainer::GetLevelToDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetLevelToDisplay");

	Params::GameplayModifierContainer_GetLevelToDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetModifierValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayModifierContainer::GetModifierValue(const struct FGameplayTag& type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetModifierValue");

	Params::GameplayModifierContainer_GetModifierValue Parms{};

	Parms.type = std::move(type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetOriginatingEffect
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UGameplayModifierContainer*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayModifierContainer* UGameplayModifierContainer::GetOriginatingEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetOriginatingEffect");

	Params::GameplayModifierContainer_GetOriginatingEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetOwningPlayer
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UGameplayModifierContainer::GetOwningPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetOwningPlayer");

	Params::GameplayModifierContainer_GetOwningPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetPercentageFill
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayModifierContainer::GetPercentageFill() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetPercentageFill");

	Params::GameplayModifierContainer_GetPercentageFill Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.GetRemainingLifetime
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayModifierContainer::GetRemainingLifetime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "GetRemainingLifetime");

	Params::GameplayModifierContainer_GetRemainingLifetime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.HasFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              flag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayModifierContainer::HasFlag(const struct FGameplayTag& flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "HasFlag");

	Params::GameplayModifierContainer_HasFlag Parms{};

	Parms.flag = std::move(flag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.HasModifierOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayModifierContainer::HasModifierOfType(const struct FGameplayTag& type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "HasModifierOfType");

	Params::GameplayModifierContainer_HasModifierOfType Parms{};

	Parms.type = std::move(type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.IsActivationTimerActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayModifierContainer::IsActivationTimerActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "IsActivationTimerActive");

	Params::GameplayModifierContainer_IsActivationTimerActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.IsActivationTimerDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayModifierContainer::IsActivationTimerDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "IsActivationTimerDone");

	Params::GameplayModifierContainer_IsActivationTimerDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierContainer.IsStatusViewActive
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayModifierContainer::IsStatusViewActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierContainer", "IsStatusViewActive");

	Params::GameplayModifierContainer_IsStatusViewActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Perk.Authority_DecrementToken
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UPerk::Authority_DecrementToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "Authority_DecrementToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.Authority_IncrementToken
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UPerk::Authority_IncrementToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "Authority_IncrementToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.Authority_SetIsUsable
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerk::Authority_SetIsUsable(bool value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "Authority_SetIsUsable");

	Params::Perk_Authority_SetIsUsable Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.Authority_SetMaxTokenCount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerk::Authority_SetMaxTokenCount(int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "Authority_SetMaxTokenCount");

	Params::Perk_Authority_SetMaxTokenCount Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.Authority_SetTokenCount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerk::Authority_SetTokenCount(int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "Authority_SetTokenCount");

	Params::Perk_Authority_SetTokenCount Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.Authority_TriggerCooldownTimer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const float                             coolddownTime                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerk::Authority_TriggerCooldownTimer(const float coolddownTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "Authority_TriggerCooldownTimer");

	Params::Perk_Authority_TriggerCooldownTimer Parms{};

	Parms.coolddownTime = coolddownTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.Authority_TriggerHudIconTimer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerk::Authority_TriggerHudIconTimer(float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "Authority_TriggerHudIconTimer");

	Params::Perk_Authority_TriggerHudIconTimer Parms{};

	Parms.duration = duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.FireActivePerkEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             percentage                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             chargeCount                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerk::FireActivePerkEvent(const float percentage, const int32 chargeCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "FireActivePerkEvent");

	Params::Perk_FireActivePerkEvent Parms{};

	Parms.percentage = percentage;
	Parms.chargeCount = chargeCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.GetGameplayModifierData
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayModifierData            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayModifierData UPerk::GetGameplayModifierData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "GetGameplayModifierData");

	Params::Perk_GetGameplayModifierData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Perk.OnRep_PerkInitializationData
// (Final, Native, Private)

void UPerk::OnRep_PerkInitializationData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "OnRep_PerkInitializationData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.OnRep_TokenCount
// (Final, Native, Private)
// Parameters:
// int32                                   oldCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerk::OnRep_TokenCount(int32 oldCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "OnRep_TokenCount");

	Params::Perk_OnRep_TokenCount Parms{};

	Parms.oldCount = oldCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.SetIsUsable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerk::SetIsUsable(bool value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "SetIsUsable");

	Params::Perk_SetIsUsable Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.GetCooldownTimer
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTimerObject*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTimerObject* UPerk::GetCooldownTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "GetCooldownTimer");

	Params::Perk_GetCooldownTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Perk.GetHudIconTimerElapsedTimePercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerk::GetHudIconTimerElapsedTimePercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "GetHudIconTimerElapsedTimePercent");

	Params::Perk_GetHudIconTimerElapsedTimePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Perk.GetIsUsable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerk::GetIsUsable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "GetIsUsable");

	Params::Perk_GetIsUsable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Perk.GetMaxTokenCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPerk::GetMaxTokenCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "GetMaxTokenCount");

	Params::Perk_GetMaxTokenCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Perk.GetPerkIconStrategy
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBasePerkIconStrategy*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBasePerkIconStrategy* UPerk::GetPerkIconStrategy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "GetPerkIconStrategy");

	Params::Perk_GetPerkIconStrategy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Perk.GetPerkLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPerk::GetPerkLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "GetPerkLevel");

	Params::Perk_GetPerkLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Perk.GetTokenCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPerk::GetTokenCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "GetTokenCount");

	Params::Perk_GetTokenCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Perk.IsCooldownTimerDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerk::IsCooldownTimerDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "IsCooldownTimerDone");

	Params::Perk_IsCooldownTimerDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Perk.IsHudIconTimerDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerk::IsHudIconTimerDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "IsHudIconTimerDone");

	Params::Perk_IsHudIconTimerDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Perk.OnRep_CooldownTimer
// (Final, Native, Private, Const)

void UPerk::OnRep_CooldownTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "OnRep_CooldownTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Perk.OnRep_IsUsable
// (Final, Native, Private, Const)

void UPerk::OnRep_IsUsable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Perk", "OnRep_IsUsable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TotemBoundPerk.Authority_BindToDullTotems
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    allowAdditionalBoundTotems                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTotemBoundPerk::Authority_BindToDullTotems(bool allowAdditionalBoundTotems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TotemBoundPerk", "Authority_BindToDullTotems");

	Params::TotemBoundPerk_Authority_BindToDullTotems Parms{};

	Parms.allowAdditionalBoundTotems = allowAdditionalBoundTotems;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TotemBoundPerk.Authority_UnbindFromTotem
// (Native, Public)
// Parameters:
// class ATotem*                           aTotemActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTotemBoundPerk::Authority_UnbindFromTotem(class ATotem* aTotemActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TotemBoundPerk", "Authority_UnbindFromTotem");

	Params::TotemBoundPerk_Authority_UnbindFromTotem Parms{};

	Parms.aTotemActor = aTotemActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TotemBoundPerk.OnRep_BoundTotems
// (Final, Native, Private)

void UTotemBoundPerk::OnRep_BoundTotems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TotemBoundPerk", "OnRep_BoundTotems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TotemBoundPerk.GetBoundTotems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ATotem*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ATotem*> UTotemBoundPerk::GetBoundTotems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TotemBoundPerk", "GetBoundTotems");

	Params::TotemBoundPerk_GetBoundTotems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TotemBoundPerk.GetSquaredDistanceToOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     survivor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTotemBoundPerk::GetSquaredDistanceToOwner(const class AActor* survivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TotemBoundPerk", "GetSquaredDistanceToOwner");

	Params::TotemBoundPerk_GetSquaredDistanceToOwner Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TotemBoundPerk.GetTotems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ATotem*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ATotem*> UTotemBoundPerk::GetTotems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TotemBoundPerk", "GetTotems");

	Params::TotemBoundPerk_GetTotems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.AddDisablingTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              tagToAdd                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::AddDisablingTags(const struct FGameplayTag& tagToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "AddDisablingTags");

	Params::InteractionDefinition_AddDisablingTags Parms{};

	Parms.tagToAdd = std::move(tagToAdd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDefinition.AddMutuallyExclusiveInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionDefinition*           interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::AddMutuallyExclusiveInteraction(class UInteractionDefinition* interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "AddMutuallyExclusiveInteraction");

	Params::InteractionDefinition_AddMutuallyExclusiveInteraction Parms{};

	Parms.interaction = interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDefinition.AttachToInteractor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractor*                      interactor                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::AttachToInteractor(class UInteractor* interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "AttachToInteractor");

	Params::InteractionDefinition_AttachToInteractor Parms{};

	Parms.interactor = interactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDefinition.AttachToZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              zone                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::AttachToZone(class UPrimitiveComponent* zone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "AttachToZone");

	Params::InteractionDefinition_AttachToZone Parms{};

	Parms.zone = zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDefinition.Authority_OnInteractionAuthorized
// (BlueprintAuthorityOnly, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::Authority_OnInteractionAuthorized(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "Authority_OnInteractionAuthorized");

	Params::InteractionDefinition_Authority_OnInteractionAuthorized Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.CompleteCharge
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::CompleteCharge(class ADBDPlayer* character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "CompleteCharge");

	Params::InteractionDefinition_CompleteCharge Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDefinition.GetPlayerDependency
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// const class ADBDPlayer*                 interactingPlayer                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UInteractionDefinition::GetPlayerDependency(const class ADBDPlayer* interactingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetPlayerDependency");

	Params::InteractionDefinition_GetPlayerDependency Parms{};

	Parms.interactingPlayer = interactingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionAnimNotifyEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             notifyID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionAnimNotifyEvent(class FName notifyID, class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionAnimNotifyEvent");

	Params::InteractionDefinition_OnInteractionAnimNotifyEvent Parms{};

	Parms.notifyID = notifyID;
	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionCancelled
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionCancelled(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionCancelled");

	Params::InteractionDefinition_OnInteractionCancelled Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionEnterEnd
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionEnterEnd(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionEnterEnd");

	Params::InteractionDefinition_OnInteractionEnterEnd Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionEnterStart
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   actualSnapTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionEnterStart(class ADBDPlayer* player, float actualSnapTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionEnterStart");

	Params::InteractionDefinition_OnInteractionEnterStart Parms{};

	Parms.player = player;
	Parms.actualSnapTime = actualSnapTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionEnterTick
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   deltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionEnterTick(class ADBDPlayer* player, float deltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionEnterTick");

	Params::InteractionDefinition_OnInteractionEnterTick Parms{};

	Parms.player = player;
	Parms.deltaTime = deltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionExitEnd
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionExitEnd(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionExitEnd");

	Params::InteractionDefinition_OnInteractionExitEnd Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionExitStart
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionExitStart(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionExitStart");

	Params::InteractionDefinition_OnInteractionExitStart Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionExitTick
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   deltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionExitTick(class ADBDPlayer* player, float deltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionExitTick");

	Params::InteractionDefinition_OnInteractionExitTick Parms{};

	Parms.player = player;
	Parms.deltaTime = deltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionFinished
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hasInteractionStarted                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionFinished(class ADBDPlayer* player, bool hasInteractionStarted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionFinished");

	Params::InteractionDefinition_OnInteractionFinished Parms{};

	Parms.player = player;
	Parms.hasInteractionStarted = hasInteractionStarted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionInit
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionInit(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionInit");

	Params::InteractionDefinition_OnInteractionInit Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionInterruptEnd
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterruptionDefinition*          currentInterruption                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptingPlayer                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionInterruptEnd(class ADBDPlayer* player, class UInterruptionDefinition* currentInterruption, class ADBDPlayer* interruptingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionInterruptEnd");

	Params::InteractionDefinition_OnInteractionInterruptEnd Parms{};

	Parms.player = player;
	Parms.currentInterruption = currentInterruption;
	Parms.interruptingPlayer = interruptingPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionInterruptStart
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterruptionDefinition*          currentInterruption                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptingPlayer                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionInterruptStart(class ADBDPlayer* player, class UInterruptionDefinition* currentInterruption, class ADBDPlayer* interruptingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionInterruptStart");

	Params::InteractionDefinition_OnInteractionInterruptStart Parms{};

	Parms.player = player;
	Parms.currentInterruption = currentInterruption;
	Parms.interruptingPlayer = interruptingPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionInterruptStarted
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterruptionDefinition*          currentInterruption                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptingPlayer                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionInterruptStarted(class ADBDPlayer* player, class UInterruptionDefinition* currentInterruption, class ADBDPlayer* interruptingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionInterruptStarted");

	Params::InteractionDefinition_OnInteractionInterruptStarted Parms{};

	Parms.player = player;
	Parms.currentInterruption = currentInterruption;
	Parms.interruptingPlayer = interruptingPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionUpdateEnd
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionUpdateEnd(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionUpdateEnd");

	Params::InteractionDefinition_OnInteractionUpdateEnd Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionUpdateMontageReachedMiddle
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionUpdateMontageReachedMiddle(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionUpdateMontageReachedMiddle");

	Params::InteractionDefinition_OnInteractionUpdateMontageReachedMiddle Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionUpdateStart
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionUpdateStart(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionUpdateStart");

	Params::InteractionDefinition_OnInteractionUpdateStart Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInteractionUpdateTick
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   deltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInteractionUpdateTick(class ADBDPlayer* player, float deltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInteractionUpdateTick");

	Params::InteractionDefinition_OnInteractionUpdateTick Parms{};

	Parms.player = player;
	Parms.deltaTime = deltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnInterruptorUpdateStart
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UInterruptionDefinition*          currentInterruption                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptee                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnInterruptorUpdateStart(class UInterruptionDefinition* currentInterruption, class ADBDPlayer* interruptor, class ADBDPlayer* interruptee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnInterruptorUpdateStart");

	Params::InteractionDefinition_OnInterruptorUpdateStart Parms{};

	Parms.currentInterruption = currentInterruption;
	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.OnUpdateMontageStart
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::OnUpdateMontageStart(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "OnUpdateMontageStart");

	Params::InteractionDefinition_OnUpdateMontageStart Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InteractionDefinition.RemoveDisablingTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              tagToRemove                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::RemoveDisablingTags(const struct FGameplayTag& tagToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "RemoveDisablingTags");

	Params::InteractionDefinition_RemoveDisablingTags Parms{};

	Parms.tagToRemove = std::move(tagToRemove);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDefinition.ResetSlashableLocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::ResetSlashableLocation(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "ResetSlashableLocation");

	Params::InteractionDefinition_ResetSlashableLocation Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDefinition.SetSecondaryActionInputType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInputInteractionType                   inputType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::SetSecondaryActionInputType(EInputInteractionType inputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "SetSecondaryActionInputType");

	Params::InteractionDefinition_SetSecondaryActionInputType Parms{};

	Parms.inputType = inputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDefinition.UpdateSlashableLocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDefinition::UpdateSlashableLocation(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "UpdateSlashableLocation");

	Params::InteractionDefinition_UpdateSlashableLocation Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDefinition.CalculateSnapTimeForConstantMaxNormalMovementSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   speedBoost                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::CalculateSnapTimeForConstantMaxNormalMovementSpeed(const class ADBDPlayer* player, float speedBoost) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "CalculateSnapTimeForConstantMaxNormalMovementSpeed");

	Params::InteractionDefinition_CalculateSnapTimeForConstantMaxNormalMovementSpeed Parms{};

	Parms.player = player;
	Parms.speedBoost = speedBoost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.CalculateSnapTimeForConstantSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             speed                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::CalculateSnapTimeForConstantSpeed(const class ADBDPlayer* player, const float speed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "CalculateSnapTimeForConstantSpeed");

	Params::InteractionDefinition_CalculateSnapTimeForConstantSpeed Parms{};

	Parms.player = player;
	Parms.speed = speed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.CanOverrideInteraction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class UInteractionDefinition*     interaction                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::CanOverrideInteraction(const class UInteractionDefinition* interaction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "CanOverrideInteraction");

	Params::InteractionDefinition_CanOverrideInteraction Parms{};

	Parms.interaction = interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.ComparePriorityToInteraction
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class UInteractionDefinition*     interaction                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInteractionComparisonPriority          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInteractionComparisonPriority UInteractionDefinition::ComparePriorityToInteraction(const class UInteractionDefinition* interaction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "ComparePriorityToInteraction");

	Params::InteractionDefinition_ComparePriorityToInteraction Parms{};

	Parms.interaction = interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.DoesPlayerHaveClearPath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::DoesPlayerHaveClearPath(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "DoesPlayerHaveClearPath");

	Params::InteractionDefinition_DoesPlayerHaveClearPath Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetActionSpeedMultiplier
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetActionSpeedMultiplier(const class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetActionSpeedMultiplier");

	Params::InteractionDefinition_GetActionSpeedMultiplier Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetActorHeightDelta
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetActorHeightDelta(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetActorHeightDelta");

	Params::InteractionDefinition_GetActorHeightDelta Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetActorsToIgnoreOverlap
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UInteractionDefinition::GetActorsToIgnoreOverlap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetActorsToIgnoreOverlap");

	Params::InteractionDefinition_GetActorsToIgnoreOverlap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetActualSnapPointPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionDefinition::GetActualSnapPointPosition(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetActualSnapPointPosition");

	Params::InteractionDefinition_GetActualSnapPointPosition Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetActualSnapPointPositionAtStart
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionDefinition::GetActualSnapPointPositionAtStart(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetActualSnapPointPositionAtStart");

	Params::InteractionDefinition_GetActualSnapPointPositionAtStart Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetAllowNavigation
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::GetAllowNavigation(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetAllowNavigation");

	Params::InteractionDefinition_GetAllowNavigation Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetChargePercent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetChargePercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetChargePercent");

	Params::InteractionDefinition_GetChargePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetEnterAnimationPlayBackDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    follower                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMontagePlaybackDefinition       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMontagePlaybackDefinition UInteractionDefinition::GetEnterAnimationPlayBackDefinition(const class ADBDPlayer* player, bool follower) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetEnterAnimationPlayBackDefinition");

	Params::InteractionDefinition_GetEnterAnimationPlayBackDefinition Parms{};

	Parms.player = player;
	Parms.follower = follower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetEnterMontage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimationMontageDescriptor      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAnimationMontageDescriptor UInteractionDefinition::GetEnterMontage(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetEnterMontage");

	Params::InteractionDefinition_GetEnterMontage Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetExitAnimationPlayBackDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    follower                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMontagePlaybackDefinition       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMontagePlaybackDefinition UInteractionDefinition::GetExitAnimationPlayBackDefinition(const class ADBDPlayer* player, bool follower) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetExitAnimationPlayBackDefinition");

	Params::InteractionDefinition_GetExitAnimationPlayBackDefinition Parms{};

	Parms.player = player;
	Parms.follower = follower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetExitAnimationPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetExitAnimationPlayRate(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetExitAnimationPlayRate");

	Params::InteractionDefinition_GetExitAnimationPlayRate Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetExitMontage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimationMontageDescriptor      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAnimationMontageDescriptor UInteractionDefinition::GetExitMontage(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetExitMontage");

	Params::InteractionDefinition_GetExitMontage Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetFocalPointPosition
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionDefinition::GetFocalPointPosition(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetFocalPointPosition");

	Params::InteractionDefinition_GetFocalPointPosition Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetInteractable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInteractable*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractable* UInteractionDefinition::GetInteractable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetInteractable");

	Params::InteractionDefinition_GetInteractable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetInteractionDescriptionText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FText                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const class FText UInteractionDefinition::GetInteractionDescriptionText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetInteractionDescriptionText");

	Params::InteractionDefinition_GetInteractionDescriptionText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetInteractionExitTime
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetInteractionExitTime(const class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetInteractionExitTime");

	Params::InteractionDefinition_GetInteractionExitTime Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetInteractionText
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UInteractionDefinition::GetInteractionText(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetInteractionText");

	Params::InteractionDefinition_GetInteractionText Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetInteractionTime
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetInteractionTime(const class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetInteractionTime");

	Params::InteractionDefinition_GetInteractionTime Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetInteractionTimeMultiplier
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetInteractionTimeMultiplier(const class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetInteractionTimeMultiplier");

	Params::InteractionDefinition_GetInteractionTimeMultiplier Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetInteractor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractor*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractor* UInteractionDefinition::GetInteractor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetInteractor");

	Params::InteractionDefinition_GetInteractor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetInterruptionDefinitions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UInterruptionDefinition*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UInterruptionDefinition*> UInteractionDefinition::GetInterruptionDefinitions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetInterruptionDefinitions");

	Params::InteractionDefinition_GetInterruptionDefinitions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetRotationToSnapPoint
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UInteractionDefinition::GetRotationToSnapPoint(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetRotationToSnapPoint");

	Params::InteractionDefinition_GetRotationToSnapPoint Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetRotationToSnapPointAtStart
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UInteractionDefinition::GetRotationToSnapPointAtStart(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetRotationToSnapPointAtStart");

	Params::InteractionDefinition_GetRotationToSnapPointAtStart Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetSecondaryActionInputType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInputInteractionType UInteractionDefinition::GetSecondaryActionInputType(const class UObject* worldContextObject) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetSecondaryActionInputType");

	Params::InteractionDefinition_GetSecondaryActionInputType Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetSlashableRelativeLocation
// (Native, Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionDefinition::GetSlashableRelativeLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetSlashableRelativeLocation");

	Params::InteractionDefinition_GetSlashableRelativeLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetSnapDistance
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetSnapDistance(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetSnapDistance");

	Params::InteractionDefinition_GetSnapDistance Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetSnapDistanceAtStart
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetSnapDistanceAtStart(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetSnapDistanceAtStart");

	Params::InteractionDefinition_GetSnapDistanceAtStart Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetSnapPointPosition
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionDefinition::GetSnapPointPosition(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetSnapPointPosition");

	Params::InteractionDefinition_GetSnapPointPosition Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetSnapPointPositionAtStart
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInteractionDefinition::GetSnapPointPositionAtStart(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetSnapPointPositionAtStart");

	Params::InteractionDefinition_GetSnapPointPositionAtStart Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetSnapSocketName
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UInteractionDefinition::GetSnapSocketName(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetSnapSocketName");

	Params::InteractionDefinition_GetSnapSocketName Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetSnapTime
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetSnapTime(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetSnapTime");

	Params::InteractionDefinition_GetSnapTime Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetSnapTimeAtStart
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetSnapTimeAtStart(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetSnapTimeAtStart");

	Params::InteractionDefinition_GetSnapTimeAtStart Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetUpdateAnimationPlayBackDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    follower                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMontagePlaybackDefinition       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMontagePlaybackDefinition UInteractionDefinition::GetUpdateAnimationPlayBackDefinition(const class ADBDPlayer* player, bool follower) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetUpdateAnimationPlayBackDefinition");

	Params::InteractionDefinition_GetUpdateAnimationPlayBackDefinition Parms{};

	Parms.player = player;
	Parms.follower = follower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetUpdateAnimationPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionDefinition::GetUpdateAnimationPlayRate(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetUpdateAnimationPlayRate");

	Params::InteractionDefinition_GetUpdateAnimationPlayRate Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.GetUpdateMontage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimationMontageDescriptor      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAnimationMontageDescriptor UInteractionDefinition::GetUpdateMontage(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "GetUpdateMontage");

	Params::InteractionDefinition_GetUpdateMontage Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsCancelable
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsCancelable(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsCancelable");

	Params::InteractionDefinition_IsCancelable Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsCharacterFacingInteractorDirection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsCharacterFacingInteractorDirection(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsCharacterFacingInteractorDirection");

	Params::InteractionDefinition_IsCharacterFacingInteractorDirection Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsInputPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsInputPressed(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsInputPressed");

	Params::InteractionDefinition_IsInputPressed Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsInteractableInPlayerView
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsInteractableInPlayerView(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsInteractableInPlayerView");

	Params::InteractionDefinition_IsInteractableInPlayerView Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsInteractionDone
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsInteractionDone(const class ADBDPlayer* player, EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsInteractionDone");

	Params::InteractionDefinition_IsInteractionDone Parms{};

	Parms.player = player;
	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsInteractionPossible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    performClientCheck                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    performHeightCheck                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsInteractionPossible(const class ADBDPlayer* player, EInputInteractionType interactionType, bool performClientCheck, bool performHeightCheck) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsInteractionPossible");

	Params::InteractionDefinition_IsInteractionPossible Parms{};

	Parms.player = player;
	Parms.interactionType = interactionType;
	Parms.performClientCheck = performClientCheck;
	Parms.performHeightCheck = performHeightCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsInteractionPossibleBP
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsInteractionPossibleBP(const class ADBDPlayer* player, EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsInteractionPossibleBP");

	Params::InteractionDefinition_IsInteractionPossibleBP Parms{};

	Parms.player = player;
	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsInteractionPossibleClient
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsInteractionPossibleClient(const class ADBDPlayer* player, EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsInteractionPossibleClient");

	Params::InteractionDefinition_IsInteractionPossibleClient Parms{};

	Parms.player = player;
	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsInteractionUsingOffering
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsInteractionUsingOffering(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsInteractionUsingOffering");

	Params::InteractionDefinition_IsInteractionUsingOffering Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsInterruptionPossible
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 interruptor                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 interruptee                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInterruptionDefinition*    interruption                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsInterruptionPossible(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee, const class UInterruptionDefinition* interruption) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsInterruptionPossible");

	Params::InteractionDefinition_IsInterruptionPossible Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;
	Parms.interruption = interruption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.IsSupportedCharacterType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::IsSupportedCharacterType(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "IsSupportedCharacterType");

	Params::InteractionDefinition_IsSupportedCharacterType Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDefinition.ShouldStartUpdateMontageDuringEnter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionDefinition::ShouldStartUpdateMontageDuringEnter(const class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDefinition", "ShouldStartUpdateMontageDuringEnter");

	Params::InteractionDefinition_ShouldStartUpdateMontageDuringEnter Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ScreenBase.BroadcastOnHighlightedElementClickedEvent
// (Final, Native, Public)
// Parameters:
// const class FName                       onBoardingID                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenBase::BroadcastOnHighlightedElementClickedEvent(const class FName onBoardingID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "BroadcastOnHighlightedElementClickedEvent");

	Params::ScreenBase_BroadcastOnHighlightedElementClickedEvent Parms{};

	Parms.onBoardingID = onBoardingID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.OnAnimationUpdate
// (Final, Native, Public)
// Parameters:
// int32                                   isAnimationDone                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenBase::OnAnimationUpdate(int32 isAnimationDone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "OnAnimationUpdate");

	Params::ScreenBase_OnAnimationUpdate Parms{};

	Parms.isAnimationDone = isAnimationDone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.OnAnyKey
// (Final, Native, Public)
// Parameters:
// float                                   code                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenBase::OnAnyKey(float code)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "OnAnyKey");

	Params::ScreenBase_OnAnyKey Parms{};

	Parms.code = code;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.OnBack
// (Final, Native, Public)

void UScreenBase::OnBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "OnBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.OnEscape
// (Final, Native, Public)

void UScreenBase::OnEscape()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "OnEscape");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.OnHideVirtualKeyboardRequested
// (Final, Native, Public)

void UScreenBase::OnHideVirtualKeyboardRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "OnHideVirtualKeyboardRequested");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.OnNavKey
// (Final, Native, Public)
// Parameters:
// const class FString&                    navKey                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenBase::OnNavKey(const class FString& navKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "OnNavKey");

	Params::ScreenBase_OnNavKey Parms{};

	Parms.navKey = std::move(navKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.OnStart
// (Final, Native, Public)

void UScreenBase::OnStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "OnStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.OnTextInputMouseClicked
// (Final, Native, Public)
// Parameters:
// bool                                    isPassword                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenBase::OnTextInputMouseClicked(bool isPassword)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "OnTextInputMouseClicked");

	Params::ScreenBase_OnTextInputMouseClicked Parms{};

	Parms.isPassword = isPassword;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenBase.SetFadesOut
// (Final, Native, Public, Const)
// Parameters:
// bool                                    fadesOut                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreenBase::SetFadesOut(bool fadesOut) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenBase", "SetFadesOut");

	Params::ScreenBase_SetFadesOut Parms{};

	Parms.fadesOut = fadesOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaFriendsListScreenUMG.HandleClosedButtonClicked
// (Final, Native, Protected)

void UAtlantaFriendsListScreenUMG::HandleClosedButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaFriendsListScreenUMG", "HandleClosedButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaFriendsListScreenUMG.HandleResearchButtonClicked
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const class FText&                      searchInput                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAtlantaFriendsListScreenUMG::HandleResearchButtonClicked(const class FText& searchInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaFriendsListScreenUMG", "HandleResearchButtonClicked");

	Params::AtlantaFriendsListScreenUMG_HandleResearchButtonClicked Parms{};

	Parms.searchInput = std::move(searchInput);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurveillancePerk.HandleGeneratorIsDamagedChanged
// (Final, Native, Private)
// Parameters:
// class AGenerator*                       generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurveillancePerk::HandleGeneratorIsDamagedChanged(class AGenerator* generator, class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurveillancePerk", "HandleGeneratorIsDamagedChanged");

	Params::SurveillancePerk_HandleGeneratorIsDamagedChanged Parms{};

	Parms.generator = generator;
	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BasePerkIconStrategy.GetDisplayPercent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UPerk*                      perk                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBasePerkIconStrategy::GetDisplayPercent(const class UPerk* perk) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePerkIconStrategy", "GetDisplayPercent");

	Params::BasePerkIconStrategy_GetDisplayPercent Parms{};

	Parms.perk = perk;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BasePerkIconStrategy.GetIsRechargeable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UPerk*                      perk                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBasePerkIconStrategy::GetIsRechargeable(const class UPerk* perk) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePerkIconStrategy", "GetIsRechargeable");

	Params::BasePerkIconStrategy_GetIsRechargeable Parms{};

	Parms.perk = perk;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BasePerkIconStrategy.GetIsRechargeableActive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UPerk*                      perk                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBasePerkIconStrategy::GetIsRechargeableActive(const class UPerk* perk) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePerkIconStrategy", "GetIsRechargeableActive");

	Params::BasePerkIconStrategy_GetIsRechargeableActive Parms{};

	Parms.perk = perk;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SourceBasedOutlineUpdateStrategy.AddRangedReveal
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     sourceActor                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              highlightColor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class ADBDPlayer*>&        affectedCharacters                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USourceBasedOutlineUpdateStrategy::AddRangedReveal(const class UObject* source, const class AActor* sourceActor, const struct FLinearColor& highlightColor, int32 priority, const TArray<class ADBDPlayer*>& affectedCharacters, float range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SourceBasedOutlineUpdateStrategy", "AddRangedReveal");

	Params::SourceBasedOutlineUpdateStrategy_AddRangedReveal Parms{};

	Parms.source = source;
	Parms.sourceActor = sourceActor;
	Parms.highlightColor = std::move(highlightColor);
	Parms.priority = priority;
	Parms.affectedCharacters = std::move(affectedCharacters);
	Parms.range = range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SourceBasedOutlineUpdateStrategy.AddReveal
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              highlightColor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class ADBDPlayer*>&        affectedCharacters                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USourceBasedOutlineUpdateStrategy::AddReveal(const class UObject* source, const struct FLinearColor& highlightColor, int32 priority, const TArray<class ADBDPlayer*>& affectedCharacters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SourceBasedOutlineUpdateStrategy", "AddReveal");

	Params::SourceBasedOutlineUpdateStrategy_AddReveal Parms{};

	Parms.source = source;
	Parms.highlightColor = std::move(highlightColor);
	Parms.priority = priority;
	Parms.affectedCharacters = std::move(affectedCharacters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SourceBasedOutlineUpdateStrategy.AddRevealWithOptions
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              highlightColor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class ADBDPlayer*>&        affectedCharacters                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FRevealOptions&            options                                                (Parm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)

void USourceBasedOutlineUpdateStrategy::AddRevealWithOptions(const class UObject* source, const struct FLinearColor& highlightColor, int32 priority, const TArray<class ADBDPlayer*>& affectedCharacters, const struct FRevealOptions& options)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SourceBasedOutlineUpdateStrategy", "AddRevealWithOptions");

	Params::SourceBasedOutlineUpdateStrategy_AddRevealWithOptions Parms{};

	Parms.source = source;
	Parms.highlightColor = std::move(highlightColor);
	Parms.priority = priority;
	Parms.affectedCharacters = std::move(affectedCharacters);
	Parms.options = std::move(options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SourceBasedOutlineUpdateStrategy.AddTimedAndRangedReveal
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     sourceActor                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              highlightColor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class ADBDPlayer*>&        affectedCharacters                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USourceBasedOutlineUpdateStrategy::AddTimedAndRangedReveal(const class UObject* source, const class AActor* sourceActor, const struct FLinearColor& highlightColor, int32 priority, const TArray<class ADBDPlayer*>& affectedCharacters, float duration, float range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SourceBasedOutlineUpdateStrategy", "AddTimedAndRangedReveal");

	Params::SourceBasedOutlineUpdateStrategy_AddTimedAndRangedReveal Parms{};

	Parms.source = source;
	Parms.sourceActor = sourceActor;
	Parms.highlightColor = std::move(highlightColor);
	Parms.priority = priority;
	Parms.affectedCharacters = std::move(affectedCharacters);
	Parms.duration = duration;
	Parms.range = range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SourceBasedOutlineUpdateStrategy.AddTimedReveal
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              highlightColor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class ADBDPlayer*>&        affectedCharacters                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USourceBasedOutlineUpdateStrategy::AddTimedReveal(const class UObject* source, const struct FLinearColor& highlightColor, int32 priority, const TArray<class ADBDPlayer*>& affectedCharacters, float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SourceBasedOutlineUpdateStrategy", "AddTimedReveal");

	Params::SourceBasedOutlineUpdateStrategy_AddTimedReveal Parms{};

	Parms.source = source;
	Parms.highlightColor = std::move(highlightColor);
	Parms.priority = priority;
	Parms.affectedCharacters = std::move(affectedCharacters);
	Parms.duration = duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SourceBasedOutlineUpdateStrategy.ChangeDefaultColorForSlasher
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FLinearColor&              newColor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USourceBasedOutlineUpdateStrategy::ChangeDefaultColorForSlasher(const struct FLinearColor& newColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SourceBasedOutlineUpdateStrategy", "ChangeDefaultColorForSlasher");

	Params::SourceBasedOutlineUpdateStrategy_ChangeDefaultColorForSlasher Parms{};

	Parms.newColor = std::move(newColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SourceBasedOutlineUpdateStrategy.ChangeDefaultColorForSurvivor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FLinearColor&              newColor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USourceBasedOutlineUpdateStrategy::ChangeDefaultColorForSurvivor(const struct FLinearColor& newColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SourceBasedOutlineUpdateStrategy", "ChangeDefaultColorForSurvivor");

	Params::SourceBasedOutlineUpdateStrategy_ChangeDefaultColorForSurvivor Parms{};

	Parms.newColor = std::move(newColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SourceBasedOutlineUpdateStrategy.RemoveRevealSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USourceBasedOutlineUpdateStrategy::RemoveRevealSource(const class UObject* source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SourceBasedOutlineUpdateStrategy", "RemoveRevealSource");

	Params::SourceBasedOutlineUpdateStrategy_RemoveRevealSource Parms{};

	Parms.source = source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SourceBasedOutlineUpdateStrategy.ResetReveal
// (Final, Native, Public, BlueprintCallable)

void USourceBasedOutlineUpdateStrategy::ResetReveal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SourceBasedOutlineUpdateStrategy", "ResetReveal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyListElementWidget.OnInAnimationFinished
// (Native, Public, BlueprintCallable)

void UUMGTallyListElementWidget::OnInAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyListElementWidget", "OnInAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyListElementWidget.OnPageVisibilityChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    wasInAnimationPlayed                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTallyListElementWidget::OnPageVisibilityChanged(bool isVisible, bool wasInAnimationPlayed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyListElementWidget", "OnPageVisibilityChanged");

	Params::UMGTallyListElementWidget_OnPageVisibilityChanged Parms{};

	Parms.isVisible = isVisible;
	Parms.wasInAnimationPlayed = wasInAnimationPlayed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGTallyListElementWidget.OnPlayInAnimation
// (Event, Public, BlueprintEvent)

void UUMGTallyListElementWidget::OnPlayInAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyListElementWidget", "OnPlayInAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGTallyPlayerLevelWidget.OnSetFinalPlayerXp
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// int32                                   finalXp                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FPlayerLevelData>&  reachedLevels                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FXpBonusData>&      xpBonuses                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FRewardItemData>&   rewardsEarned                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGTallyPlayerLevelWidget::OnSetFinalPlayerXp(int32 finalXp, const TArray<struct FPlayerLevelData>& reachedLevels, const TArray<struct FXpBonusData>& xpBonuses, const TArray<struct FRewardItemData>& rewardsEarned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyPlayerLevelWidget", "OnSetFinalPlayerXp");

	Params::UMGTallyPlayerLevelWidget_OnSetFinalPlayerXp Parms{};

	Parms.finalXp = finalXp;
	Parms.reachedLevels = std::move(reachedLevels);
	Parms.xpBonuses = std::move(xpBonuses);
	Parms.rewardsEarned = std::move(rewardsEarned);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGTallyPlayerLevelWidget.OnSetInitialPlayerXp
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// int32                                   initialXp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlayerLevelData&          initialLevelData                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUMGTallyPlayerLevelWidget::OnSetInitialPlayerXp(int32 initialXp, const struct FPlayerLevelData& initialLevelData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyPlayerLevelWidget", "OnSetInitialPlayerXp");

	Params::UMGTallyPlayerLevelWidget_OnSetInitialPlayerXp Parms{};

	Parms.initialXp = initialXp;
	Parms.initialLevelData = std::move(initialLevelData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGTallyPlayerLevelWidget.GetFinalXp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UUMGTallyPlayerLevelWidget::GetFinalXp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyPlayerLevelWidget", "GetFinalXp");

	Params::UMGTallyPlayerLevelWidget_GetFinalXp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGTallyPlayerLevelWidget.GetInitialXp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UUMGTallyPlayerLevelWidget::GetInitialXp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyPlayerLevelWidget", "GetInitialXp");

	Params::UMGTallyPlayerLevelWidget_GetInitialXp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGTallyPlayerLevelWidget.GetReachedLevels
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FPlayerLevelData>   ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<struct FPlayerLevelData> UUMGTallyPlayerLevelWidget::GetReachedLevels() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyPlayerLevelWidget", "GetReachedLevels");

	Params::UMGTallyPlayerLevelWidget_GetReachedLevels Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGTallyPlayerLevelWidget.GetRewardsEarned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FRewardItemData>    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<struct FRewardItemData> UUMGTallyPlayerLevelWidget::GetRewardsEarned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyPlayerLevelWidget", "GetRewardsEarned");

	Params::UMGTallyPlayerLevelWidget_GetRewardsEarned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGTallyPlayerLevelWidget.GetXpBonuses
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FXpBonusData>       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<struct FXpBonusData> UUMGTallyPlayerLevelWidget::GetXpBonuses() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyPlayerLevelWidget", "GetXpBonuses");

	Params::UMGTallyPlayerLevelWidget_GetXpBonuses Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.ComputeHookStrugglePercent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ACamperPlayer*              hookedCamper                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   hookStruggleThreshold                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDHookUtilities::ComputeHookStrugglePercent(const class ACamperPlayer* hookedCamper, float hookStruggleThreshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "ComputeHookStrugglePercent");

	Params::DBDHookUtilities_ComputeHookStrugglePercent Parms{};

	Parms.hookedCamper = hookedCamper;
	Parms.hookStruggleThreshold = hookStruggleThreshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.IsFreddyHook
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMeatHook*                        targetHook                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDHookUtilities::IsFreddyHook(class AMeatHook* targetHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "IsFreddyHook");

	Params::DBDHookUtilities_IsFreddyHook Parms{};

	Parms.targetHook = targetHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.IsHagHook
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMeatHook*                        targetHook                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDHookUtilities::IsHagHook(class AMeatHook* targetHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "IsHagHook");

	Params::DBDHookUtilities_IsHagHook Parms{};

	Parms.targetHook = targetHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.IsHookOf
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMeatHook*                        targetHook                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              hookTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDHookUtilities::IsHookOf(class AMeatHook* targetHook, const struct FGameplayTag& hookTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "IsHookOf");

	Params::DBDHookUtilities_IsHookOf Parms{};

	Parms.targetHook = targetHook;
	Parms.hookTag = std::move(hookTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.IsHuntressHook
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMeatHook*                        targetHook                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDHookUtilities::IsHuntressHook(class AMeatHook* targetHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "IsHuntressHook");

	Params::DBDHookUtilities_IsHuntressHook Parms{};

	Parms.targetHook = targetHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.IsLegionHook
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMeatHook*                        targetHook                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDHookUtilities::IsLegionHook(class AMeatHook* targetHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "IsLegionHook");

	Params::DBDHookUtilities_IsLegionHook Parms{};

	Parms.targetHook = targetHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.IsNurseHook
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMeatHook*                        targetHook                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDHookUtilities::IsNurseHook(class AMeatHook* targetHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "IsNurseHook");

	Params::DBDHookUtilities_IsNurseHook Parms{};

	Parms.targetHook = targetHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.IsPigHook
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMeatHook*                        targetHook                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDHookUtilities::IsPigHook(class AMeatHook* targetHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "IsPigHook");

	Params::DBDHookUtilities_IsPigHook Parms{};

	Parms.targetHook = targetHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDHookUtilities.IsWraithHook
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AMeatHook*                        targetHook                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDHookUtilities::IsWraithHook(class AMeatHook* targetHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDHookUtilities", "IsWraithHook");

	Params::DBDHookUtilities_IsWraithHook Parms{};

	Parms.targetHook = targetHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ItemModifier.AuthoritySetItemCount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   itemCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemModifier::AuthoritySetItemCount(int32 itemCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "AuthoritySetItemCount");

	Params::ItemModifier_AuthoritySetItemCount Parms{};

	Parms.itemCount = itemCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemModifier.AuthoritySetItemEnergy
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   energy                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemModifier::AuthoritySetItemEnergy(float energy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "AuthoritySetItemEnergy");

	Params::ItemModifier_AuthoritySetItemEnergy Parms{};

	Parms.energy = energy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemModifier.AuthoritySetItemMaxEnergy
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   energy                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemModifier::AuthoritySetItemMaxEnergy(float energy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "AuthoritySetItemMaxEnergy");

	Params::ItemModifier_AuthoritySetItemMaxEnergy Parms{};

	Parms.energy = energy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemModifier.HandleIncreaseCharge
// (Final, Native, Public, BlueprintCallable)

void UItemModifier::HandleIncreaseCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "HandleIncreaseCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemModifier.HandleIncreaseItemCount
// (Final, Native, Public, BlueprintCallable)

void UItemModifier::HandleIncreaseItemCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "HandleIncreaseItemCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemModifier.HandleIncreaseMaxCharge
// (Final, Native, Public, BlueprintCallable)

void UItemModifier::HandleIncreaseMaxCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "HandleIncreaseMaxCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemModifier.GetBaseItem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACollectable*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACollectable* UItemModifier::GetBaseItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "GetBaseItem");

	Params::ItemModifier_GetBaseItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ItemModifier.GetItemCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UItemModifier::GetItemCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "GetItemCount");

	Params::ItemModifier_GetItemCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ItemModifier.GetItemEnergy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UItemModifier::GetItemEnergy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "GetItemEnergy");

	Params::ItemModifier_GetItemEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ItemModifier.GetItemMaxEnergy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UItemModifier::GetItemMaxEnergy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemModifier", "GetItemMaxEnergy");

	Params::ItemModifier_GetItemMaxEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ItemAddon.Authority_ApplyMetaModifiers
// (Final, Native, Private)

void UItemAddon::Authority_ApplyMetaModifiers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "Authority_ApplyMetaModifiers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.Authority_DecrementToken
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UItemAddon::Authority_DecrementToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "Authority_DecrementToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.Authority_IncrementToken
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UItemAddon::Authority_IncrementToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "Authority_IncrementToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.Authority_OnCollectableDropped
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemAddon::Authority_OnCollectableDropped(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "Authority_OnCollectableDropped");

	Params::ItemAddon_Authority_OnCollectableDropped Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ItemAddon.Authority_OnCollectablePickedUp
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemAddon::Authority_OnCollectablePickedUp(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "Authority_OnCollectablePickedUp");

	Params::ItemAddon_Authority_OnCollectablePickedUp Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.Authority_SetMaxTokenCount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemAddon::Authority_SetMaxTokenCount(int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "Authority_SetMaxTokenCount");

	Params::ItemAddon_Authority_SetMaxTokenCount Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.Authority_SetTokenCount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemAddon::Authority_SetTokenCount(int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "Authority_SetTokenCount");

	Params::ItemAddon_Authority_SetTokenCount Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.DebugPrintStats
// (Event, Public, BlueprintEvent)

void UItemAddon::DebugPrintStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "DebugPrintStats");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ItemAddon.Multicast_AddAddonToItem
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ACollectable*                     item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemAddon::Multicast_AddAddonToItem(class ACollectable* item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "Multicast_AddAddonToItem");

	Params::ItemAddon_Multicast_AddAddonToItem Parms{};

	Parms.item = item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.Multicast_SetBaseItem
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, NetValidate)
// Parameters:
// class ACollectable*                     baseItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemAddon::Multicast_SetBaseItem(class ACollectable* baseItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "Multicast_SetBaseItem");

	Params::ItemAddon_Multicast_SetBaseItem Parms{};

	Parms.baseItem = baseItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.OnPostItemAddonsCreation
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACollectable*                     item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemAddon::OnPostItemAddonsCreation(class ADBDPlayer* player, class ACollectable* item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "OnPostItemAddonsCreation");

	Params::ItemAddon_OnPostItemAddonsCreation Parms{};

	Parms.player = player;
	Parms.item = item;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ItemAddon.OnRep_AddonInitializationData
// (Final, Native, Private)

void UItemAddon::OnRep_AddonInitializationData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "OnRep_AddonInitializationData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.OnRep_TokenCount
// (Final, Native, Private)
// Parameters:
// int32                                   oldCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemAddon::OnRep_TokenCount(int32 oldCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "OnRep_TokenCount");

	Params::ItemAddon_OnRep_TokenCount Parms{};

	Parms.oldCount = oldCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemAddon.SetUpAddon
// (Event, Protected, BlueprintEvent)

void UItemAddon::SetUpAddon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "SetUpAddon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ItemAddon.GetMaxTokenCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UItemAddon::GetMaxTokenCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "GetMaxTokenCount");

	Params::ItemAddon_GetMaxTokenCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ItemAddon.GetTokenCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UItemAddon::GetTokenCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "GetTokenCount");

	Params::ItemAddon_GetTokenCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ItemAddon.IsReadyForSetUp
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemAddon::IsReadyForSetUp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "IsReadyForSetUp");

	Params::ItemAddon_IsReadyForSetUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ItemAddon.IsSecondaryAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemAddon::IsSecondaryAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemAddon", "IsSecondaryAction");

	Params::ItemAddon_IsSecondaryAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StreamVideoPlayer.OnEndReached
// (Final, Native, Private)

void AStreamVideoPlayer::OnEndReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StreamVideoPlayer", "OnEndReached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StreamVideoPlayer.OnMediaClosed
// (Final, Native, Private)

void AStreamVideoPlayer::OnMediaClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StreamVideoPlayer", "OnMediaClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StreamVideoPlayer.OnMediaOpened
// (Final, Native, Private)
// Parameters:
// const class FString&                    openedUrl                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStreamVideoPlayer::OnMediaOpened(const class FString& openedUrl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StreamVideoPlayer", "OnMediaOpened");

	Params::StreamVideoPlayer_OnMediaOpened Parms{};

	Parms.openedUrl = std::move(openedUrl);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StreamVideoPlayer.OnSkipButtonTriggered
// (Final, Native, Private)

void AStreamVideoPlayer::OnSkipButtonTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StreamVideoPlayer", "OnSkipButtonTriggered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StreamVideoPlayer.OnVideoAssetLoaded
// (Final, Native, Private)

void AStreamVideoPlayer::OnVideoAssetLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StreamVideoPlayer", "OnVideoAssetLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.Authority_AddCharge
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   deltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isChargeFromItem                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::Authority_AddCharge(float deltaSeconds, class ADBDPlayer* character, bool isChargeFromItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "Authority_AddCharge");

	Params::ChargeableInteractionDefinition_Authority_AddCharge Parms{};

	Parms.deltaSeconds = deltaSeconds;
	Parms.character = character;
	Parms.isChargeFromItem = isChargeFromItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.Authority_ChargeWithItem
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   deltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACollectable*                     item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::Authority_ChargeWithItem(float deltaSeconds, class ACollectable* item, class ADBDPlayer* character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "Authority_ChargeWithItem");

	Params::ChargeableInteractionDefinition_Authority_ChargeWithItem Parms{};

	Parms.deltaSeconds = deltaSeconds;
	Parms.item = item;
	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.OnInteractionCompletionStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    complete                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::OnInteractionCompletionStateChanged(class ADBDPlayer* player, bool complete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "OnInteractionCompletionStateChanged");

	Params::ChargeableInteractionDefinition_OnInteractionCompletionStateChanged Parms{};

	Parms.player = player;
	Parms.complete = complete;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ChargeableInteractionDefinition.OnSkillCheckResponseAesthetic
// (Native, Protected)
// Parameters:
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    triggerLoudNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::OnSkillCheckResponseAesthetic(bool success, bool bonus, class ADBDPlayer* player, bool triggerLoudNoise, bool hadInput, ESkillCheckCustomType type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "OnSkillCheckResponseAesthetic");

	Params::ChargeableInteractionDefinition_OnSkillCheckResponseAesthetic Parms{};

	Parms.success = success;
	Parms.bonus = bonus;
	Parms.player = player;
	Parms.triggerLoudNoise = triggerLoudNoise;
	Parms.hadInput = hadInput;
	Parms.type = type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.OnSkillCheckResponseAestheticBP
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::OnSkillCheckResponseAestheticBP(class ADBDPlayer* player, bool success, bool bonus, bool hadInput, ESkillCheckCustomType type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "OnSkillCheckResponseAestheticBP");

	Params::ChargeableInteractionDefinition_OnSkillCheckResponseAestheticBP Parms{};

	Parms.player = player;
	Parms.success = success;
	Parms.bonus = bonus;
	Parms.hadInput = hadInput;
	Parms.type = type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ChargeableInteractionDefinition.OnSkillCheckResponseAuthority
// (Final, Native, Protected)
// Parameters:
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    triggerLoudNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::OnSkillCheckResponseAuthority(bool success, bool bonus, class ADBDPlayer* player, bool triggerLoudNoise, bool hadInput, ESkillCheckCustomType type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "OnSkillCheckResponseAuthority");

	Params::ChargeableInteractionDefinition_OnSkillCheckResponseAuthority Parms{};

	Parms.success = success;
	Parms.bonus = bonus;
	Parms.player = player;
	Parms.triggerLoudNoise = triggerLoudNoise;
	Parms.hadInput = hadInput;
	Parms.type = type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.OnSkillCheckResponseAuthorityBP
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::OnSkillCheckResponseAuthorityBP(class ADBDPlayer* player, bool success, bool bonus, bool hadInput, ESkillCheckCustomType type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "OnSkillCheckResponseAuthorityBP");

	Params::ChargeableInteractionDefinition_OnSkillCheckResponseAuthorityBP Parms{};

	Parms.player = player;
	Parms.success = success;
	Parms.bonus = bonus;
	Parms.hadInput = hadInput;
	Parms.type = type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ChargeableInteractionDefinition.SetChargeableComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UChargeableComponent*             chargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isNullAllowed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::SetChargeableComponent(class UChargeableComponent* chargeableComponent, bool isNullAllowed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "SetChargeableComponent");

	Params::ChargeableInteractionDefinition_SetChargeableComponent Parms{};

	Parms.chargeableComponent = chargeableComponent;
	Parms.isNullAllowed = isNullAllowed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.SetSpeedBase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   speedBase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::SetSpeedBase(float speedBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "SetSpeedBase");

	Params::ChargeableInteractionDefinition_SetSpeedBase Parms{};

	Parms.speedBase = speedBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.SetTutorialChargeableMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   multiplierValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableInteractionDefinition::SetTutorialChargeableMultiplier(float multiplierValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "SetTutorialChargeableMultiplier");

	Params::ChargeableInteractionDefinition_SetTutorialChargeableMultiplier Parms{};

	Parms.multiplierValue = multiplierValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetAdditiveChargeTimeReductionAsMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetAdditiveChargeTimeReductionAsMultiplier(const class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetAdditiveChargeTimeReductionAsMultiplier");

	Params::ChargeableInteractionDefinition_GetAdditiveChargeTimeReductionAsMultiplier Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetAdditiveLuckBonus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetAdditiveLuckBonus(const class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetAdditiveLuckBonus");

	Params::ChargeableInteractionDefinition_GetAdditiveLuckBonus Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetBonusSkillCheckSuccessPercentReward
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetBonusSkillCheckSuccessPercentReward(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetBonusSkillCheckSuccessPercentReward");

	Params::ChargeableInteractionDefinition_GetBonusSkillCheckSuccessPercentReward Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetBonusSkillCheckZoneSizeModifier
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetBonusSkillCheckZoneSizeModifier(const class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetBonusSkillCheckZoneSizeModifier");

	Params::ChargeableInteractionDefinition_GetBonusSkillCheckZoneSizeModifier Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetChargeableComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UChargeableComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableComponent* UChargeableInteractionDefinition::GetChargeableComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetChargeableComponent");

	Params::ChargeableInteractionDefinition_GetChargeableComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetChargeAmountForTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   deltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetChargeAmountForTime(float deltaSeconds, class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetChargeAmountForTime");

	Params::ChargeableInteractionDefinition_GetChargeAmountForTime Parms{};

	Parms.deltaSeconds = deltaSeconds;
	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetChargeSpeedModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetChargeSpeedModifier(const class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetChargeSpeedModifier");

	Params::ChargeableInteractionDefinition_GetChargeSpeedModifier Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetGoodSkillCheckSuccessPercentReward
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetGoodSkillCheckSuccessPercentReward(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetGoodSkillCheckSuccessPercentReward");

	Params::ChargeableInteractionDefinition_GetGoodSkillCheckSuccessPercentReward Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetInteractionChargeSpeedMultiplier
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetInteractionChargeSpeedMultiplier(const class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetInteractionChargeSpeedMultiplier");

	Params::ChargeableInteractionDefinition_GetInteractionChargeSpeedMultiplier Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetItemEfficiencyModifier
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetItemEfficiencyModifier(const class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetItemEfficiencyModifier");

	Params::ChargeableInteractionDefinition_GetItemEfficiencyModifier Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetMaxCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetMaxCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetMaxCharge");

	Params::ChargeableInteractionDefinition_GetMaxCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetMultiplicativeLuckBonus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetMultiplicativeLuckBonus(const class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetMultiplicativeLuckBonus");

	Params::ChargeableInteractionDefinition_GetMultiplicativeLuckBonus Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetPerkMultiplier
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetPerkMultiplier(const class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetPerkMultiplier");

	Params::ChargeableInteractionDefinition_GetPerkMultiplier Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetPipsPassed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UChargeableInteractionDefinition::GetPipsPassed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetPipsPassed");

	Params::ChargeableInteractionDefinition_GetPipsPassed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetSkillCheckCharge
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetSkillCheckCharge(class ADBDPlayer* player, bool success, bool bonus, ESkillCheckCustomType type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetSkillCheckCharge");

	Params::ChargeableInteractionDefinition_GetSkillCheckCharge Parms{};

	Parms.player = player;
	Parms.success = success;
	Parms.bonus = bonus;
	Parms.type = type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetSkillCheckDifficulityModifier
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetSkillCheckDifficulityModifier(const class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetSkillCheckDifficulityModifier");

	Params::ChargeableInteractionDefinition_GetSkillCheckDifficulityModifier Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetSkillCheckFailurePercentPenalty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetSkillCheckFailurePercentPenalty(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetSkillCheckFailurePercentPenalty");

	Params::ChargeableInteractionDefinition_GetSkillCheckFailurePercentPenalty Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetSkillCheckFailureTimePenalty
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetSkillCheckFailureTimePenalty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetSkillCheckFailureTimePenalty");

	Params::ChargeableInteractionDefinition_GetSkillCheckFailureTimePenalty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetSkillCheckProbability
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 interactingPlayer                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetSkillCheckProbability(const class ADBDPlayer* interactingPlayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetSkillCheckProbability");

	Params::ChargeableInteractionDefinition_GetSkillCheckProbability Parms{};

	Parms.interactingPlayer = interactingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetSuccessProbability
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetSuccessProbability() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetSuccessProbability");

	Params::ChargeableInteractionDefinition_GetSuccessProbability Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.GetTunableValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TunableValueID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   defaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableInteractionDefinition::GetTunableValue(class FName TunableValueID, float defaultValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "GetTunableValue");

	Params::ChargeableInteractionDefinition_GetTunableValue Parms{};

	Parms.TunableValueID = TunableValueID;
	Parms.defaultValue = defaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.HasSkillCheckHappened
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChargeableInteractionDefinition::HasSkillCheckHappened(const class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "HasSkillCheckHappened");

	Params::ChargeableInteractionDefinition_HasSkillCheckHappened Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.IsChargeComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 currentlyInteractingPlayer                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChargeableInteractionDefinition::IsChargeComplete(const class ADBDPlayer* currentlyInteractingPlayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "IsChargeComplete");

	Params::ChargeableInteractionDefinition_IsChargeComplete Parms{};

	Parms.currentlyInteractingPlayer = currentlyInteractingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableInteractionDefinition.ShouldShowSpeedProficiencyForMultipleInteractors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChargeableInteractionDefinition::ShouldShowSpeedProficiencyForMultipleInteractors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableInteractionDefinition", "ShouldShowSpeedProficiencyForMultipleInteractors");

	Params::ChargeableInteractionDefinition_ShouldShowSpeedProficiencyForMultipleInteractors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.AttachEveryInteractionToZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              zone                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::AttachEveryInteractionToZone(class UPrimitiveComponent* zone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "AttachEveryInteractionToZone");

	Params::Interactable_AttachEveryInteractionToZone Parms{};

	Parms.zone = zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactable.AuthorityRequestCancelOngoingInteractions
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    onlyOnHitCancelableInteractions                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::AuthorityRequestCancelOngoingInteractions(bool onlyOnHitCancelableInteractions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "AuthorityRequestCancelOngoingInteractions");

	Params::Interactable_AuthorityRequestCancelOngoingInteractions Parms{};

	Parms.onlyOnHitCancelableInteractions = onlyOnHitCancelableInteractions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactable.OnInteractorLockChanged
// (Final, Native, Private)
// Parameters:
// bool                                    locked                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interactingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::OnInteractorLockChanged(bool locked, class ADBDPlayer* interactingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "OnInteractorLockChanged");

	Params::Interactable_OnInteractorLockChanged Parms{};

	Parms.locked = locked;
	Parms.interactingPlayer = interactingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactable.OnLevelReadyToPlay
// (Event, Public, BlueprintEvent)

void AInteractable::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "OnLevelReadyToPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Interactable.OnLevelReadyToPlay_Native
// (Native, Protected)

void AInteractable::OnLevelReadyToPlay_Native()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "OnLevelReadyToPlay_Native");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactable.PreInterruptionEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       interruptor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptee                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterruptionDefinition*          interruption                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::PreInterruptionEvent(class ADBDPlayer* interruptor, class ADBDPlayer* interruptee, class UInterruptionDefinition* interruption)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "PreInterruptionEvent");

	Params::Interactable_PreInterruptionEvent Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;
	Parms.interruption = interruption;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Interactable.SetInteractorsUsable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    usable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractor*                      exception                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::SetInteractorsUsable(bool usable, class UInteractor* exception)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "SetInteractorsUsable");

	Params::Interactable_SetInteractorsUsable Parms{};

	Parms.usable = usable;
	Parms.exception = exception;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactable.SetSingleZone
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              zone                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractable::SetSingleZone(class UPrimitiveComponent* zone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "SetSingleZone");

	Params::Interactable_SetSingleZone Parms{};

	Parms.zone = zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactable.Authority_GetInteractingPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ADBDPlayer*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDPlayer*> AInteractable::Authority_GetInteractingPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "Authority_GetInteractingPlayers");

	Params::Interactable_Authority_GetInteractingPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.GetFocalPointPosition
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInteractionDefinition*     definition                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AInteractable::GetFocalPointPosition(const class ADBDPlayer* player, const class UInteractionDefinition* definition) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "GetFocalPointPosition");

	Params::Interactable_GetFocalPointPosition Parms{};

	Parms.player = player;
	Parms.definition = definition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.GetInteractingPlayersRaw
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ADBDPlayer*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDPlayer*> AInteractable::GetInteractingPlayersRaw() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "GetInteractingPlayersRaw");

	Params::Interactable_GetInteractingPlayersRaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.GetInteractors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UInteractor*>              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UInteractor*> AInteractable::GetInteractors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "GetInteractors");

	Params::Interactable_GetInteractors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.GetPlayerOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* AInteractable::GetPlayerOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "GetPlayerOwner");

	Params::Interactable_GetPlayerOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.HasAnOngoingInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractable::HasAnOngoingInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "HasAnOngoingInteraction");

	Params::Interactable_HasAnOngoingInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.IsInteractingWith
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractable::IsInteractingWith(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "IsInteractingWith");

	Params::Interactable_IsInteractingWith Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.IsInteractionDone
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInteractor*                interactor                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInteractionDefinition*     definition                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractable::IsInteractionDone(class ADBDPlayer* player, const class UInteractor* interactor, const class UInteractionDefinition* definition, EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "IsInteractionDone");

	Params::Interactable_IsInteractionDone Parms{};

	Parms.player = player;
	Parms.interactor = interactor;
	Parms.definition = definition;
	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactable.IsInterruptionPossible
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 interruptor                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 interruptee                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInteractor*                interactor                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInteractionDefinition*     definition                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInterruptionDefinition*    interruption                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractable::IsInterruptionPossible(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee, const class UInteractor* interactor, const class UInteractionDefinition* definition, const class UInterruptionDefinition* interruption) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactable", "IsInterruptionPossible");

	Params::Interactable_IsInterruptionPossible Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;
	Parms.interactor = interactor;
	Parms.definition = definition;
	Parms.interruption = interruption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialBehaviourInteractable.OnRep_SpecialBehaviourOwner
// (Final, Native, Private)

void ASpecialBehaviourInteractable::OnRep_SpecialBehaviourOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpecialBehaviourInteractable", "OnRep_SpecialBehaviourOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Charm.BeginDestroySequence_Internal
// (Native, Event, Protected, BlueprintEvent)

void ACharm::BeginDestroySequence_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Charm", "BeginDestroySequence_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseIndicatorWidget.OnOutAnimationFinished
// (Final, Native, Protected)

void UBaseIndicatorWidget::OnOutAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseIndicatorWidget", "OnOutAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInfoScreen.OnBackButtonClick
// (Final, Native, Private)

void UCharacterInfoScreen::OnBackButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInfoScreen", "OnBackButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTooltipContentPlayerLevelWidget.SetInfo
// (Final, Native, Public)
// Parameters:
// const int32                             playerLevel                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             playerPrestige                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             currentExperience                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             nextLevelExperience                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTooltipContentPlayerLevelWidget::SetInfo(const int32 playerLevel, const int32 playerPrestige, const int32 currentExperience, const int32 nextLevelExperience)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTooltipContentPlayerLevelWidget", "SetInfo");

	Params::UMGTooltipContentPlayerLevelWidget_SetInfo Parms{};

	Parms.playerLevel = playerLevel;
	Parms.playerPrestige = playerPrestige;
	Parms.currentExperience = currentExperience;
	Parms.nextLevelExperience = nextLevelExperience;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.QuestEventEvaluatorBase.OnGameEvent
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UQuestEventEvaluatorBase::OnGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestEventEvaluatorBase", "OnGameEvent");

	Params::QuestEventEvaluatorBase_OnGameEvent Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedAudioComponent.GetAudioSwitchState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAudioCustomizationCategory             audioCustomizationCategory                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCustomizedAudioComponent::GetAudioSwitchState(EAudioCustomizationCategory audioCustomizationCategory) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedAudioComponent", "GetAudioSwitchState");

	Params::CustomizedAudioComponent_GetAudioSwitchState Parms{};

	Parms.audioCustomizationCategory = audioCustomizationCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomizedAudioComponent.GetOutfitCustomizedAudioCollectionState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCustomizedAudioComponent::GetOutfitCustomizedAudioCollectionState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedAudioComponent", "GetOutfitCustomizedAudioCollectionState");

	Params::CustomizedAudioComponent_GetOutfitCustomizedAudioCollectionState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BaseTooltipWidget.OnQuitButtonClicked
// (Final, Native, Protected)

void UBaseTooltipWidget::OnQuitButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseTooltipWidget", "OnQuitButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseSky.CopyComponentsSettingsFromSource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             moonMesh                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDirectionalLightComponent*       shadowLight                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDirectionalLightComponent*       godRayLight                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkyLightComponent*               skylight                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UExponentialHeightFogComponent*   heightFog                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPostProcessComponent*            postProcess                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           sourceBaseSkyClass                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSky::CopyComponentsSettingsFromSource(class UStaticMeshComponent* moonMesh, class UDirectionalLightComponent* shadowLight, class UDirectionalLightComponent* godRayLight, class USkyLightComponent* skylight, class UExponentialHeightFogComponent* heightFog, class UPostProcessComponent* postProcess, class UClass* sourceBaseSkyClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "CopyComponentsSettingsFromSource");

	Params::BaseSky_CopyComponentsSettingsFromSource Parms{};

	Parms.moonMesh = moonMesh;
	Parms.shadowLight = shadowLight;
	Parms.godRayLight = godRayLight;
	Parms.skylight = skylight;
	Parms.heightFog = heightFog;
	Parms.postProcess = postProcess;
	Parms.sourceBaseSkyClass = sourceBaseSkyClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseSky.GetPostprocessComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPostProcessComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPostProcessComponent* ABaseSky::GetPostprocessComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "GetPostprocessComponent");

	Params::BaseSky_GetPostprocessComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BaseSky.OnAlphaChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   newAlpha                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSky::OnAlphaChanged(float newAlpha, class AActor* other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "OnAlphaChanged");

	Params::BaseSky_OnAlphaChanged Parms{};

	Parms.newAlpha = newAlpha;
	Parms.other = other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseSky.OnFadeBegin
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSky::OnFadeBegin(class AActor* other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "OnFadeBegin");

	Params::BaseSky_OnFadeBegin Parms{};

	Parms.other = other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseSky.OnFadeEnd
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSky::OnFadeEnd(class AActor* other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "OnFadeEnd");

	Params::BaseSky_OnFadeEnd Parms{};

	Parms.other = other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseSky.SetCullDistance
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   newCullDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSky::SetCullDistance(float newCullDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "SetCullDistance");

	Params::BaseSky_SetCullDistance Parms{};

	Parms.newCullDistance = newCullDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseSky.SetProbesTint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FLinearColor&              inColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   inSaturation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSky::SetProbesTint(const struct FLinearColor& inColor, float inSaturation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "SetProbesTint");

	Params::BaseSky_SetProbesTint Parms{};

	Parms.inColor = std::move(inColor);
	Parms.inSaturation = inSaturation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseSky.ToggleDreamworldLighting
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    toggleOn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseSky::ToggleDreamworldLighting(bool toggleOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSky", "ToggleDreamworldLighting");

	Params::BaseSky_ToggleDreamworldLighting Parms{};

	Parms.toggleOn = toggleOn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.GeneratorDrivenActor.Authority_CheckActivation
// (Final, Native, Public)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::Authority_CheckActivation(bool isAutoCompleted, int32 generatorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "Authority_CheckActivation");

	Params::GeneratorDrivenActor_Authority_CheckActivation Parms{};

	Parms.isAutoCompleted = isAutoCompleted;
	Parms.generatorId = generatorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.Authority_CheckGeneratorRepairedBySurvivor
// (Final, Native, Public)
// Parameters:
// class ADBDPlayer*                       repairingSurvivor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::Authority_CheckGeneratorRepairedBySurvivor(class ADBDPlayer* repairingSurvivor, int32 generatorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "Authority_CheckGeneratorRepairedBySurvivor");

	Params::GeneratorDrivenActor_Authority_CheckGeneratorRepairedBySurvivor Parms{};

	Parms.repairingSurvivor = repairingSurvivor;
	Parms.generatorId = generatorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.GetSharedTileRandomizer
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRandomStream                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FRandomStream AGeneratorDrivenActor::GetSharedTileRandomizer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "GetSharedTileRandomizer");

	Params::GeneratorDrivenActor_GetSharedTileRandomizer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorDrivenActor.Multicast_ActivationChecked
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    activated                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::Multicast_ActivationChecked(bool activated, bool isAutoCompleted, int32 generatorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "Multicast_ActivationChecked");

	Params::GeneratorDrivenActor_Multicast_ActivationChecked Parms{};

	Parms.activated = activated;
	Parms.isAutoCompleted = isAutoCompleted;
	Parms.generatorId = generatorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.Multicast_GeneratorRepairedBySurvivor
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ADBDPlayer*                       repairingSurvivor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::Multicast_GeneratorRepairedBySurvivor(class ADBDPlayer* repairingSurvivor, int32 generatorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "Multicast_GeneratorRepairedBySurvivor");

	Params::GeneratorDrivenActor_Multicast_GeneratorRepairedBySurvivor Parms{};

	Parms.repairingSurvivor = repairingSurvivor;
	Parms.generatorId = generatorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.OnActivateGeneratorDrivenActor
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnActivateGeneratorDrivenActor(bool isAutoCompleted, int32 generatorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnActivateGeneratorDrivenActor");

	Params::GeneratorDrivenActor_OnActivateGeneratorDrivenActor Parms{};

	Parms.isAutoCompleted = isAutoCompleted;
	Parms.generatorId = generatorId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.GeneratorDrivenActor.OnGeneratorRepairedBySurvivor
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       repairingSurvivor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnGeneratorRepairedBySurvivor(class ADBDPlayer* repairingSurvivor, int32 generatorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnGeneratorRepairedBySurvivor");

	Params::GeneratorDrivenActor_OnGeneratorRepairedBySurvivor Parms{};

	Parms.repairingSurvivor = repairingSurvivor;
	Parms.generatorId = generatorId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.GeneratorDrivenActor.OnGeneratorRepairedBySurvivorEvent0
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       repairingSurvivor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnGeneratorRepairedBySurvivorEvent0(class ADBDPlayer* repairingSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnGeneratorRepairedBySurvivorEvent0");

	Params::GeneratorDrivenActor_OnGeneratorRepairedBySurvivorEvent0 Parms{};

	Parms.repairingSurvivor = repairingSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.OnGeneratorRepairedBySurvivorEvent1
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       repairingSurvivor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnGeneratorRepairedBySurvivorEvent1(class ADBDPlayer* repairingSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnGeneratorRepairedBySurvivorEvent1");

	Params::GeneratorDrivenActor_OnGeneratorRepairedBySurvivorEvent1 Parms{};

	Parms.repairingSurvivor = repairingSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.OnGeneratorRepairedBySurvivorEvent2
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       repairingSurvivor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnGeneratorRepairedBySurvivorEvent2(class ADBDPlayer* repairingSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnGeneratorRepairedBySurvivorEvent2");

	Params::GeneratorDrivenActor_OnGeneratorRepairedBySurvivorEvent2 Parms{};

	Parms.repairingSurvivor = repairingSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.OnGeneratorRepairedBySurvivorEvent3
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       repairingSurvivor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnGeneratorRepairedBySurvivorEvent3(class ADBDPlayer* repairingSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnGeneratorRepairedBySurvivorEvent3");

	Params::GeneratorDrivenActor_OnGeneratorRepairedBySurvivorEvent3 Parms{};

	Parms.repairingSurvivor = repairingSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.OnGeneratorRepairedBySurvivorEvent4
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       repairingSurvivor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnGeneratorRepairedBySurvivorEvent4(class ADBDPlayer* repairingSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnGeneratorRepairedBySurvivorEvent4");

	Params::GeneratorDrivenActor_OnGeneratorRepairedBySurvivorEvent4 Parms{};

	Parms.repairingSurvivor = repairingSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.OnGeneratorRepairedBySurvivorEvent5
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       repairingSurvivor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnGeneratorRepairedBySurvivorEvent5(class ADBDPlayer* repairingSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnGeneratorRepairedBySurvivorEvent5");

	Params::GeneratorDrivenActor_OnGeneratorRepairedBySurvivorEvent5 Parms{};

	Parms.repairingSurvivor = repairingSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.OnGeneratorRepairedBySurvivorEvent6
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       repairingSurvivor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnGeneratorRepairedBySurvivorEvent6(class ADBDPlayer* repairingSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnGeneratorRepairedBySurvivorEvent6");

	Params::GeneratorDrivenActor_OnGeneratorRepairedBySurvivorEvent6 Parms{};

	Parms.repairingSurvivor = repairingSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.OnGeneratorRepairedEvent0
// (Final, Native, Private)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnGeneratorRepairedEvent0(bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnGeneratorRepairedEvent0");

	Params::GeneratorDrivenActor_OnGeneratorRepairedEvent0 Parms{};

	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.OnGeneratorRepairedEvent1
// (Final, Native, Private)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnGeneratorRepairedEvent1(bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnGeneratorRepairedEvent1");

	Params::GeneratorDrivenActor_OnGeneratorRepairedEvent1 Parms{};

	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.OnGeneratorRepairedEvent2
// (Final, Native, Private)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnGeneratorRepairedEvent2(bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnGeneratorRepairedEvent2");

	Params::GeneratorDrivenActor_OnGeneratorRepairedEvent2 Parms{};

	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.OnGeneratorRepairedEvent3
// (Final, Native, Private)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnGeneratorRepairedEvent3(bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnGeneratorRepairedEvent3");

	Params::GeneratorDrivenActor_OnGeneratorRepairedEvent3 Parms{};

	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.OnGeneratorRepairedEvent4
// (Final, Native, Private)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnGeneratorRepairedEvent4(bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnGeneratorRepairedEvent4");

	Params::GeneratorDrivenActor_OnGeneratorRepairedEvent4 Parms{};

	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.OnGeneratorRepairedEvent5
// (Final, Native, Private)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnGeneratorRepairedEvent5(bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnGeneratorRepairedEvent5");

	Params::GeneratorDrivenActor_OnGeneratorRepairedEvent5 Parms{};

	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.OnGeneratorRepairedEvent6
// (Final, Native, Private)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnGeneratorRepairedEvent6(bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnGeneratorRepairedEvent6");

	Params::GeneratorDrivenActor_OnGeneratorRepairedEvent6 Parms{};

	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.OnInitGeneratorDrivenActor
// (Event, Public, BlueprintEvent)
// Parameters:
// class AGenerator*                       generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::OnInitGeneratorDrivenActor(class AGenerator* generator, int32 generatorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "OnInitGeneratorDrivenActor");

	Params::GeneratorDrivenActor_OnInitGeneratorDrivenActor Parms{};

	Parms.generator = generator;
	Parms.generatorId = generatorId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.GeneratorDrivenActor.SetSpawnedObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGenerator*                       generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorDrivenActor::SetSpawnedObject(class AGenerator* generator, int32 generatorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "SetSpawnedObject");

	Params::GeneratorDrivenActor_SetSpawnedObject Parms{};

	Parms.generator = generator;
	Parms.generatorId = generatorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorDrivenActor.IsActivated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGeneratorDrivenActor::IsActivated(int32 generatorId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "IsActivated");

	Params::GeneratorDrivenActor_IsActivated Parms{};

	Parms.generatorId = generatorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorDrivenActor.IsValidGeneratorId
// (Final, Native, Private, Const)
// Parameters:
// int32                                   generatorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGeneratorDrivenActor::IsValidGeneratorId(int32 generatorId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorDrivenActor", "IsValidGeneratorId");

	Params::GeneratorDrivenActor_IsValidGeneratorId Parms{};

	Parms.generatorId = generatorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CrowBomb.TriggerLand
// (Final, Native, Public, BlueprintCallable)

void ACrowBomb::TriggerLand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrowBomb", "TriggerLand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CrowBomb.TriggerTakeOff
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   triggerLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrowBomb::TriggerTakeOff(const struct FVector& triggerLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrowBomb", "TriggerTakeOff");

	Params::CrowBomb_TriggerTakeOff Parms{};

	Parms.triggerLocation = std::move(triggerLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Authority_AddItemAddon
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UItemAddon*                       addon                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::Authority_AddItemAddon(class UItemAddon* addon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Authority_AddItemAddon");

	Params::Collectable_Authority_AddItemAddon Parms{};

	Parms.addon = addon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.Authority_Discard
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ACollectable::Authority_Discard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Authority_Discard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Authority_OnConsumed
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    forceDiscard                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::Authority_OnConsumed(bool forceDiscard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Authority_OnConsumed");

	Params::Collectable_Authority_OnConsumed Parms{};

	Parms.forceDiscard = forceDiscard;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Authority_RemoveItemAddon
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UItemAddon*                       addon                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::Authority_RemoveItemAddon(class UItemAddon* addon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Authority_RemoveItemAddon");

	Params::Collectable_Authority_RemoveItemAddon Parms{};

	Parms.addon = addon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Authority_Use
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ACollectable::Authority_Use()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Authority_Use");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Authority_UseReleased
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ACollectable::Authority_UseReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Authority_UseReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.BP_OnSurvivorAdded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::BP_OnSurvivorAdded(class ACamperPlayer* survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "BP_OnSurvivorAdded");

	Params::Collectable_BP_OnSurvivorAdded Parms{};

	Parms.survivor = survivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Collectable.CallOnCollectorSetBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(class ADBDPlayer* player)>callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void ACollectable::CallOnCollectorSetBP(TDelegate<void(class ADBDPlayer* player)> callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "CallOnCollectorSetBP");

	Params::Collectable_CallOnCollectorSetBP Parms{};

	Parms.callback = callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.DebugPrintStats
// (Native, Event, Public, BlueprintEvent)

void ACollectable::DebugPrintStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "DebugPrintStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.GetItemAddons
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UItemAddon*>               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UItemAddon*> ACollectable::GetItemAddons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetItemAddons");

	Params::Collectable_GetItemAddons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.Local_Dropped_Location
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       droppedBy                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACollectable::Local_Dropped_Location(class ADBDPlayer* droppedBy, const struct FVector& location, const struct FRotator& rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Local_Dropped_Location");

	Params::Collectable_Local_Dropped_Location Parms{};

	Parms.droppedBy = droppedBy;
	Parms.location = std::move(location);
	Parms.rotation = std::move(rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Multicast_Collected
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ADBDPlayer*                       collector                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::Multicast_Collected(class ADBDPlayer* collector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Multicast_Collected");

	Params::Collectable_Multicast_Collected Parms{};

	Parms.collector = collector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Multicast_Dropped
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// class ADBDPlayer*                       droppedBy                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  rotation                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACollectable::Multicast_Dropped(class ADBDPlayer* droppedBy, const struct FVector& location, const struct FRotator& rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Multicast_Dropped");

	Params::Collectable_Multicast_Dropped Parms{};

	Parms.droppedBy = droppedBy;
	Parms.location = std::move(location);
	Parms.rotation = std::move(rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Multicast_RemoveAllAddons
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ACollectable::Multicast_RemoveAllAddons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Multicast_RemoveAllAddons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Multicast_RemoveItemAddon
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class UItemAddon*                       addon                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::Multicast_RemoveItemAddon(class UItemAddon* addon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Multicast_RemoveItemAddon");

	Params::Collectable_Multicast_RemoveItemAddon Parms{};

	Parms.addon = addon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Multicast_Use
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ACollectable::Multicast_Use()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Multicast_Use");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Multicast_UseReleased
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ADBDPlayer*                       collector                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::Multicast_UseReleased(class ADBDPlayer* collector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Multicast_UseReleased");

	Params::Collectable_Multicast_UseReleased Parms{};

	Parms.collector = collector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.OnActivateDissolveItem
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)

void ACollectable::OnActivateDissolveItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnActivateDissolveItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Collectable.OnAddonsAdded
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<class UItemAddon*>&        addons                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACollectable::OnAddonsAdded(const TArray<class UItemAddon*>& addons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnAddonsAdded");

	Params::Collectable_OnAddonsAdded Parms{};

	Parms.addons = std::move(addons);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Collectable.OnAddonsRemoved
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<class UItemAddon*>&        addons                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACollectable::OnAddonsRemoved(const TArray<class UItemAddon*>& addons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnAddonsRemoved");

	Params::Collectable_OnAddonsRemoved Parms{};

	Parms.addons = std::move(addons);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Collectable.OnCollectorEndPlay
// (Final, Native, Private)
// Parameters:
// class AActor*                           actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          endPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::OnCollectorEndPlay(class AActor* actor, EEndPlayReason endPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnCollectorEndPlay");

	Params::Collectable_OnCollectorEndPlay Parms{};

	Parms.actor = actor;
	Parms.endPlayReason = endPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.OnCollectorSet
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       collector                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::OnCollectorSet(class ADBDPlayer* collector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnCollectorSet");

	Params::Collectable_OnCollectorSet Parms{};

	Parms.collector = collector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.OnCustomizationChanged
// (Event, Public, BlueprintEvent)

void ACollectable::OnCustomizationChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnCustomizationChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Collectable.OnDropped
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       droppingPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::OnDropped(class ADBDPlayer* droppingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnDropped");

	Params::Collectable_OnDropped Parms{};

	Parms.droppingPlayer = droppingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.OnPostItemAddonsCreation
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::OnPostItemAddonsCreation(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnPostItemAddonsCreation");

	Params::Collectable_OnPostItemAddonsCreation Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Collectable.OnRep_Collector
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       oldCollector                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::OnRep_Collector(class ADBDPlayer* oldCollector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnRep_Collector");

	Params::Collectable_OnRep_Collector Parms{};

	Parms.oldCollector = oldCollector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.OnRep_State
// (Final, Native, Private)

void ACollectable::OnRep_State()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnRep_State");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.OnUse
// (Native, Event, Protected, BlueprintEvent)

void ACollectable::OnUse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnUse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.OnUseReleased
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       collector                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::OnUseReleased(class ADBDPlayer* collector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "OnUseReleased");

	Params::Collectable_OnUseReleased Parms{};

	Parms.collector = collector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.Server_Discard
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACollectable::Server_Discard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "Server_Discard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.SetCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::SetCount(int32 count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "SetCount");

	Params::Collectable_SetCount Parms{};

	Parms.count = count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.SetDisplayedInputType
// (Final, Native, Public)
// Parameters:
// const EInputInteractionType             displayedInputType                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::SetDisplayedInputType(const EInputInteractionType displayedInputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "SetDisplayedInputType");

	Params::Collectable_SetDisplayedInputType Parms{};

	Parms.displayedInputType = displayedInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.SetIsKeyPromptForceDisabled
// (Final, Native, Public)
// Parameters:
// const bool                              isKeyPromptForceDisabled                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::SetIsKeyPromptForceDisabled(const bool isKeyPromptForceDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "SetIsKeyPromptForceDisabled");

	Params::Collectable_SetIsKeyPromptForceDisabled Parms{};

	Parms.isKeyPromptForceDisabled = isKeyPromptForceDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.SetItemInteractor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractor*                      interactor                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::SetItemInteractor(class UInteractor* interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "SetItemInteractor");

	Params::Collectable_SetItemInteractor Parms{};

	Parms.interactor = interactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.SetVisibilityEvent
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    visibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectable::SetVisibilityEvent(bool visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "SetVisibilityEvent");

	Params::Collectable_SetVisibilityEvent Parms{};

	Parms.visibility = visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Collectable.CanBeCollected
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 collector                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::CanBeCollected(const class ADBDPlayer* collector) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "CanBeCollected");

	Params::Collectable_CanBeCollected Parms{};

	Parms.collector = collector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.CanBeDropped
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 dropper                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::CanBeDropped(const class ADBDPlayer* dropper) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "CanBeDropped");

	Params::Collectable_CanBeDropped Parms{};

	Parms.dropper = dropper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.CanUse
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::CanUse(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "CanUse");

	Params::Collectable_CanUse Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetCollector
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ACollectable::GetCollector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetCollector");

	Params::Collectable_GetCollector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetCount
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACollectable::GetCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetCount");

	Params::Collectable_GetCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetDisplayedInputType
// (Final, Native, Public, Const)
// Parameters:
// EInputInteractionType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInputInteractionType ACollectable::GetDisplayedInputType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetDisplayedInputType");

	Params::Collectable_GetDisplayedInputType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetIconFilePath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ACollectable::GetIconFilePath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetIconFilePath");

	Params::Collectable_GetIconFilePath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetItemIconIndex
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ACollectable::GetItemIconIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetItemIconIndex");

	Params::Collectable_GetItemIconIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetItemInteractor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractor*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractor* ACollectable::GetItemInteractor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetItemInteractor");

	Params::Collectable_GetItemInteractor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetModifierMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              modifierType                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   defaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACollectable::GetModifierMax(const struct FGameplayTag& modifierType, float defaultValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetModifierMax");

	Params::Collectable_GetModifierMax Parms{};

	Parms.modifierType = std::move(modifierType);
	Parms.defaultValue = defaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetModifierSum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              modifierType                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   defaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACollectable::GetModifierSum(const struct FGameplayTag& modifierType, float defaultValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetModifierSum");

	Params::Collectable_GetModifierSum Parms{};

	Parms.modifierType = std::move(modifierType);
	Parms.defaultValue = defaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.GetUsePercentLeft
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACollectable::GetUsePercentLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "GetUsePercentLeft");

	Params::Collectable_GetUsePercentLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.HasGameplayModifierFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              modifierFlag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::HasGameplayModifierFlag(const struct FGameplayTag& modifierFlag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "HasGameplayModifierFlag");

	Params::Collectable_HasGameplayModifierFlag Parms{};

	Parms.modifierFlag = std::move(modifierFlag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsCollected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsCollected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsCollected");

	Params::Collectable_IsCollected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsCountDisplayForced
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsCountDisplayForced() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsCountDisplayForced");

	Params::Collectable_IsCountDisplayForced Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsEquipped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsEquipped");

	Params::Collectable_IsEquipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsInSearchable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsInSearchable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsInSearchable");

	Params::Collectable_IsInSearchable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsKeyPromptForceDisabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsKeyPromptForceDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsKeyPromptForceDisabled");

	Params::Collectable_IsKeyPromptForceDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsLocallyControlled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsLocallyControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsLocallyControlled");

	Params::Collectable_IsLocallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsOnGround
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsOnGround() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsOnGround");

	Params::Collectable_IsOnGround Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsPickable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsPickable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsPickable");

	Params::Collectable_IsPickable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsRechargeable
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsRechargeable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsRechargeable");

	Params::Collectable_IsRechargeable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Collectable.IsStored
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACollectable::IsStored() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Collectable", "IsStored");

	Params::Collectable_IsStored Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGAtlantaNavigationScreen.ButtonClickEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENavigationScreenButton                 buttonid                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaNavigationScreen::ButtonClickEvent(ENavigationScreenButton buttonid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaNavigationScreen", "ButtonClickEvent");

	Params::UMGAtlantaNavigationScreen_ButtonClickEvent Parms{};

	Parms.buttonid = buttonid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaNavigationScreen.GetPartyMembersData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   index                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FPartyMemberUIData> ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FPartyMemberUIData> UUMGAtlantaNavigationScreen::GetPartyMembersData(int32 index) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaNavigationScreen", "GetPartyMembersData");

	Params::UMGAtlantaNavigationScreen_GetPartyMembersData Parms{};

	Parms.index = index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            actorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UActorComponentExt::GetOwningCharacter(const class UActorComponent* actorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningCharacter");

	Params::ActorComponentExt_GetOwningCharacter Parms{};

	Parms.actorComponent = actorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningCharacterChecked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            actorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UActorComponentExt::GetOwningCharacterChecked(const class UActorComponent* actorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningCharacterChecked");

	Params::ActorComponentExt_GetOwningCharacterChecked Parms{};

	Parms.actorComponent = actorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningKiller
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            actorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASlasherPlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASlasherPlayer* UActorComponentExt::GetOwningKiller(const class UActorComponent* actorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningKiller");

	Params::ActorComponentExt_GetOwningKiller Parms{};

	Parms.actorComponent = actorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            actorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UActorComponentExt::GetOwningPawn(const class UActorComponent* actorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningPawn");

	Params::ActorComponentExt_GetOwningPawn Parms{};

	Parms.actorComponent = actorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningPawnChecked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            actorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UActorComponentExt::GetOwningPawnChecked(const class UActorComponent* actorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningPawnChecked");

	Params::ActorComponentExt_GetOwningPawnChecked Parms{};

	Parms.actorComponent = actorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            actorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UActorComponentExt::GetOwningPlayer(const class UActorComponent* actorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningPlayer");

	Params::ActorComponentExt_GetOwningPlayer Parms{};

	Parms.actorComponent = actorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningPlayerChecked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            actorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UActorComponentExt::GetOwningPlayerChecked(const class UActorComponent* actorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningPlayerChecked");

	Params::ActorComponentExt_GetOwningPlayerChecked Parms{};

	Parms.actorComponent = actorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningPlayerInHierarchy
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            actorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UActorComponentExt::GetOwningPlayerInHierarchy(const class UActorComponent* actorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningPlayerInHierarchy");

	Params::ActorComponentExt_GetOwningPlayerInHierarchy Parms{};

	Parms.actorComponent = actorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningSurvivor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            actorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACamperPlayer*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACamperPlayer* UActorComponentExt::GetOwningSurvivor(const class UActorComponent* actorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningSurvivor");

	Params::ActorComponentExt_GetOwningSurvivor Parms{};

	Parms.actorComponent = actorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetOwningSurvivorChecked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            actorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACamperPlayer*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACamperPlayer* UActorComponentExt::GetOwningSurvivorChecked(const class UActorComponent* actorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetOwningSurvivorChecked");

	Params::ActorComponentExt_GetOwningSurvivorChecked Parms{};

	Parms.actorComponent = actorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.GetValidatedOwner
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            actorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UActorComponentExt::GetValidatedOwner(const class UActorComponent* actorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "GetValidatedOwner");

	Params::ActorComponentExt_GetValidatedOwner Parms{};

	Parms.actorComponent = actorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.HasAuthority
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            actorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorComponentExt::HasAuthority(const class UActorComponent* actorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "HasAuthority");

	Params::ActorComponentExt_HasAuthority Parms{};

	Parms.actorComponent = actorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.IsLocallyControlled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            actorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorComponentExt::IsLocallyControlled(const class UActorComponent* actorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "IsLocallyControlled");

	Params::ActorComponentExt_IsLocallyControlled Parms{};

	Parms.actorComponent = actorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorComponentExt.IsLocallyObserved
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UActorComponent*            actorComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    recursiveSearch                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorComponentExt::IsLocallyObserved(const class UActorComponent* actorComponent, bool recursiveSearch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ActorComponentExt", "IsLocallyObserved");

	Params::ActorComponentExt_IsLocallyObserved Parms{};

	Parms.actorComponent = actorComponent;
	Parms.recursiveSearch = recursiveSearch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAttack.Client_ReceiveAttackSubstateRequestResult
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const struct FAttackSubstateRequestResult&result                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UDBDAttack::Client_ReceiveAttackSubstateRequestResult(const struct FAttackSubstateRequestResult& result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Client_ReceiveAttackSubstateRequestResult");

	Params::DBDAttack_Client_ReceiveAttackSubstateRequestResult Parms{};

	Parms.result = std::move(result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Client_ReceiveHitResult
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class ADBDPlayer*                       target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isValid                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FActionPredictionKey&      predictionKey                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttack::Client_ReceiveHitResult(class ADBDPlayer* target, bool isValid, const struct FActionPredictionKey& predictionKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Client_ReceiveHitResult");

	Params::DBDAttack_Client_ReceiveHitResult Parms{};

	Parms.target = target;
	Parms.isValid = isValid;
	Parms.predictionKey = std::move(predictionKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Local_OnMovementChanged
// (Final, Native, Protected)
// Parameters:
// class ACharacter*                       character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           prevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   previousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttack::Local_OnMovementChanged(class ACharacter* character, EMovementMode prevMovementMode, uint8 previousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Local_OnMovementChanged");

	Params::DBDAttack_Local_OnMovementChanged Parms{};

	Parms.character = character;
	Parms.prevMovementMode = prevMovementMode;
	Parms.previousCustomMode = previousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Multicast_ClearTargets
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UDBDAttack::Multicast_ClearTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Multicast_ClearTargets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Multicast_HitAttackableComponent
// (Net, NetReliable, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// class UAttackableComponent*             attackableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttack::Multicast_HitAttackableComponent(class UAttackableComponent* attackableComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Multicast_HitAttackableComponent");

	Params::DBDAttack_Multicast_HitAttackableComponent Parms{};

	Parms.attackableComponent = attackableComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Multicast_HitTarget
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ADBDPlayer*                       target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hitCosmeticOnly                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttack::Multicast_HitTarget(class ADBDPlayer* target, bool hitCosmeticOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Multicast_HitTarget");

	Params::DBDAttack_Multicast_HitTarget Parms{};

	Parms.target = target;
	Parms.hitCosmeticOnly = hitCosmeticOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Multicast_RequestStateChange
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const EAttackSubstate                   state                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttack::Multicast_RequestStateChange(const EAttackSubstate state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Multicast_RequestStateChange");

	Params::DBDAttack_Multicast_RequestStateChange Parms{};

	Parms.state = state;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Multicast_SendPostHitTargetData
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ADBDPlayer*                       owningKiller                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPostAttackData&           attackData                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDBDAttack::Multicast_SendPostHitTargetData(class ADBDPlayer* owningKiller, class ADBDPlayer* target, const struct FPostAttackData& attackData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Multicast_SendPostHitTargetData");

	Params::DBDAttack_Multicast_SendPostHitTargetData Parms{};

	Parms.owningKiller = owningKiller;
	Parms.target = target;
	Parms.attackData = std::move(attackData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Server_ClearTargets
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void UDBDAttack::Server_ClearTargets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Server_ClearTargets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Server_HitAttackableComponent
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UAttackableComponent*             attackableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttack::Server_HitAttackableComponent(class UAttackableComponent* attackableComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Server_HitAttackableComponent");

	Params::DBDAttack_Server_HitAttackableComponent Parms{};

	Parms.attackableComponent = attackableComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Server_HitTarget
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class ADBDPlayer*                       target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             targetLocationTimestamp                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FActionPredictionKey&      predictionKey                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttack::Server_HitTarget(class ADBDPlayer* target, const float targetLocationTimestamp, const struct FActionPredictionKey& predictionKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Server_HitTarget");

	Params::DBDAttack_Server_HitTarget Parms{};

	Parms.target = target;
	Parms.targetLocationTimestamp = targetLocationTimestamp;
	Parms.predictionKey = std::move(predictionKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttack.Server_RequestStateChange
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const EAttackSubstate                   state                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttack::Server_RequestStateChange(const EAttackSubstate state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttack", "Server_RequestStateChange");

	Params::DBDAttack_Server_RequestStateChange Parms{};

	Parms.state = state;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.Authority_AddCharge
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   chargeAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bypassSkillCheckFail                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isOneTimeIncrease                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isChargeWithItem                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::Authority_AddCharge(float chargeAmount, class AActor* instigator, bool bypassSkillCheckFail, bool isOneTimeIncrease, bool isChargeWithItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Authority_AddCharge");

	Params::ChargeableComponent_Authority_AddCharge Parms{};

	Parms.chargeAmount = chargeAmount;
	Parms.instigator = instigator;
	Parms.bypassSkillCheckFail = bypassSkillCheckFail;
	Parms.isOneTimeIncrease = isOneTimeIncrease;
	Parms.isChargeWithItem = isChargeWithItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.Authority_AddChargePercent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   chargePercent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bypassSkillCheckFail                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isOneTimeIncrease                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isChargeWithItem                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::Authority_AddChargePercent(float chargePercent, class AActor* instigator, bool bypassSkillCheckFail, bool isOneTimeIncrease, bool isChargeWithItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Authority_AddChargePercent");

	Params::ChargeableComponent_Authority_AddChargePercent Parms{};

	Parms.chargePercent = chargePercent;
	Parms.instigator = instigator;
	Parms.bypassSkillCheckFail = bypassSkillCheckFail;
	Parms.isOneTimeIncrease = isOneTimeIncrease;
	Parms.isChargeWithItem = isChargeWithItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.Authority_ApplyStartingCharge
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UChargeableComponent::Authority_ApplyStartingCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Authority_ApplyStartingCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.Authority_Reset
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UChargeableComponent::Authority_Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Authority_Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.Authority_SetEnableAddCharge
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              enable                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::Authority_SetEnableAddCharge(const bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Authority_SetEnableAddCharge");

	Params::ChargeableComponent_Authority_SetEnableAddCharge Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.Authority_SetEnableSkillCheckFailurePenalty
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              enable                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::Authority_SetEnableSkillCheckFailurePenalty(const bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Authority_SetEnableSkillCheckFailurePenalty");

	Params::ChargeableComponent_Authority_SetEnableSkillCheckFailurePenalty Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.IncreaseMaxCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::IncreaseMaxCharge(float percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "IncreaseMaxCharge");

	Params::ChargeableComponent_IncreaseMaxCharge Parms{};

	Parms.percent = percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.IncreaseMaxChargeAdditive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   secondsToAdd                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::IncreaseMaxChargeAdditive(float secondsToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "IncreaseMaxChargeAdditive");

	Params::ChargeableComponent_IncreaseMaxChargeAdditive Parms{};

	Parms.secondsToAdd = secondsToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.OnCurrentChargeChanged
// (Final, Native, Private)
// Parameters:
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::OnCurrentChargeChanged(float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "OnCurrentChargeChanged");

	Params::ChargeableComponent_OnCurrentChargeChanged Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.OnRep_CurrentCharge
// (Final, Native, Private)

void UChargeableComponent::OnRep_CurrentCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "OnRep_CurrentCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.SetDechargeRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   dechargeRate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::SetDechargeRate(float dechargeRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "SetDechargeRate");

	Params::ChargeableComponent_SetDechargeRate Parms{};

	Parms.dechargeRate = dechargeRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.SetSecondsToCharge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   secondsToCharge                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::SetSecondsToCharge(float secondsToCharge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "SetSecondsToCharge");

	Params::ChargeableComponent_SetSecondsToCharge Parms{};

	Parms.secondsToCharge = secondsToCharge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.GetChargeRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableComponent::GetChargeRemaining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "GetChargeRemaining");

	Params::ChargeableComponent_GetChargeRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.GetChargingSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableComponent::GetChargingSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "GetChargingSpeed");

	Params::ChargeableComponent_GetChargingSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.GetCurrentCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableComponent::GetCurrentCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "GetCurrentCharge");

	Params::ChargeableComponent_GetCurrentCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.GetMaxCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableComponent::GetMaxCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "GetMaxCharge");

	Params::ChargeableComponent_GetMaxCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.GetPercentComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableComponent::GetPercentComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "GetPercentComplete");

	Params::ChargeableComponent_GetPercentComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.GetPlayerCountPenaltyModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   playerCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableComponent::GetPlayerCountPenaltyModifier(int32 playerCount) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "GetPlayerCountPenaltyModifier");

	Params::ChargeableComponent_GetPlayerCountPenaltyModifier Parms{};

	Parms.playerCount = playerCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.GetTunableValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             TunableValueID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableComponent::GetTunableValue(class FName TunableValueID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "GetTunableValue");

	Params::ChargeableComponent_GetTunableValue Parms{};

	Parms.TunableValueID = TunableValueID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.HasPlayerDoneSkillCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   playerID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChargeableComponent::HasPlayerDoneSkillCheck(int32 playerID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "HasPlayerDoneSkillCheck");

	Params::ChargeableComponent_HasPlayerDoneSkillCheck Parms{};

	Parms.playerID = playerID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.IsChargeComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChargeableComponent::IsChargeComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "IsChargeComplete");

	Params::ChargeableComponent_IsChargeComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.IsSkillCheckTimePenaltyActive
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChargeableComponent::IsSkillCheckTimePenaltyActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "IsSkillCheckTimePenaltyActive");

	Params::ChargeableComponent_IsSkillCheckTimePenaltyActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargeableComponent.Multicast_OnCompleteChanged
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, Const)
// Parameters:
// bool                                    completed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargeableComponent::Multicast_OnCompleteChanged(bool completed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Multicast_OnCompleteChanged");

	Params::ChargeableComponent_Multicast_OnCompleteChanged Parms{};

	Parms.completed = completed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargeableComponent.Multicast_OnEmptied
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, Const)

void UChargeableComponent::Multicast_OnEmptied() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableComponent", "Multicast_OnEmptied");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIUtilities.DrawDebugAINavigation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDAIUtilities::DrawDebugAINavigation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDAIUtilities", "DrawDebugAINavigation");

	Params::DBDAIUtilities_DrawDebugAINavigation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAIUtilities.DrawDebugAINavigationFilter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDAIUtilities::DrawDebugAINavigationFilter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDAIUtilities", "DrawDebugAINavigationFilter");

	Params::DBDAIUtilities_DrawDebugAINavigationFilter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAIUtilities.DrawDebugAIPerception
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDAIUtilities::DrawDebugAIPerception()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDAIUtilities", "DrawDebugAIPerception");

	Params::DBDAIUtilities_DrawDebugAIPerception Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAIUtilities.FindPathWithAgentRadiusToActorSynchronously
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          worldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   pathStart                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           goalActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   agentRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   tetherDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           pathfindingContext                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNavigationQueryFilter>filterClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNavigationPath*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNavigationPath* UDBDAIUtilities::FindPathWithAgentRadiusToActorSynchronously(class UObject* worldContextObject, const struct FVector& pathStart, class AActor* goalActor, float agentRadius, float tetherDistance, class AActor* pathfindingContext, TSubclassOf<class UNavigationQueryFilter> filterClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDAIUtilities", "FindPathWithAgentRadiusToActorSynchronously");

	Params::DBDAIUtilities_FindPathWithAgentRadiusToActorSynchronously Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.pathStart = std::move(pathStart);
	Parms.goalActor = goalActor;
	Parms.agentRadius = agentRadius;
	Parms.tetherDistance = tetherDistance;
	Parms.pathfindingContext = pathfindingContext;
	Parms.filterClass = filterClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAIUtilities.SetCanEverAffectNavigation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    affectNavigation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAIUtilities::SetCanEverAffectNavigation(class UActorComponent* component, bool affectNavigation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDAIUtilities", "SetCanEverAffectNavigation");

	Params::DBDAIUtilities_SetCanEverAffectNavigation Parms{};

	Parms.component = component;
	Parms.affectNavigation = affectNavigation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaDailyRewardsGrid.InitializeLayouts_BP
// (Event, Protected, BlueprintEvent)

void UUMGAtlantaDailyRewardsGrid::InitializeLayouts_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaDailyRewardsGrid", "InitializeLayouts_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGAtlantaDailyRewardsGrid.PlayNextRewardIntroAnimation
// (Final, Native, Protected)

void UUMGAtlantaDailyRewardsGrid::PlayNextRewardIntroAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaDailyRewardsGrid", "PlayNextRewardIntroAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaDailyRewardsGrid.StartIntroSequence
// (Final, Native, Public)

void UUMGAtlantaDailyRewardsGrid::StartIntroSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaDailyRewardsGrid", "StartIntroSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaDailyRewardsGrid.StartRewardsIntroRewardSequence
// (Final, Native, Protected)

void UUMGAtlantaDailyRewardsGrid::StartRewardsIntroRewardSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaDailyRewardsGrid", "StartRewardsIntroRewardSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDNetworkUtilities.IsOnDedicatedServerNetwork
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDNetworkUtilities::IsOnDedicatedServerNetwork(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDNetworkUtilities", "IsOnDedicatedServerNetwork");

	Params::DBDNetworkUtilities_IsOnDedicatedServerNetwork Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDNetworkUtilities.IsRunningDedicatedServerFlow
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDNetworkUtilities::IsRunningDedicatedServerFlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDNetworkUtilities", "IsRunningDedicatedServerFlow");

	Params::DBDNetworkUtilities_IsRunningDedicatedServerFlow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LevelParadise.OnInterpolationDone
// (Final, Native, Private)

void ALevelParadise::OnInterpolationDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelParadise", "OnInterpolationDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LevelParadise.ParadiseEntered
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FParadiseData&             playerData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ALevelParadise::ParadiseEntered(const struct FParadiseData& playerData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelParadise", "ParadiseEntered");

	Params::LevelParadise_ParadiseEntered Parms{};

	Parms.playerData = std::move(playerData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviourInteractWithActorData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterMovementTypes                 characterMovementType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    usePathfinding                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterBehaviourInteractWithActorData::Init(class AActor* actor, ECharacterMovementTypes characterMovementType, bool usePathfinding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviourInteractWithActorData", "Init");

	Params::AICharacterBehaviourInteractWithActorData_Init Parms{};

	Parms.actor = actor;
	Parms.characterMovementType = characterMovementType;
	Parms.usePathfinding = usePathfinding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviourInteractWithActorData.WatchGameEventType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterBehaviourInteractWithActorData::WatchGameEventType(const struct FGameplayTag& gameEventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviourInteractWithActorData", "WatchGameEventType");

	Params::AICharacterBehaviourInteractWithActorData_WatchGameEventType Parms{};

	Parms.gameEventType = std::move(gameEventType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviourInteractWithActorData.WatchGameEventTypes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FGameplayTag>&      gameEventTypes                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAICharacterBehaviourInteractWithActorData::WatchGameEventTypes(const TArray<struct FGameplayTag>& gameEventTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviourInteractWithActorData", "WatchGameEventTypes");

	Params::AICharacterBehaviourInteractWithActorData_WatchGameEventTypes Parms{};

	Parms.gameEventTypes = std::move(gameEventTypes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaHudPowerAttackJoystick.OnFinishedAvailableAnimation
// (Final, Native, Protected)

void UAtlantaHudPowerAttackJoystick::OnFinishedAvailableAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaHudPowerAttackJoystick", "OnFinishedAvailableAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaHudPowerAttackJoystick.OnFinishedTutorialAnimationIn
// (Final, Native, Protected)

void UAtlantaHudPowerAttackJoystick::OnFinishedTutorialAnimationIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaHudPowerAttackJoystick", "OnFinishedTutorialAnimationIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GlyphNavMovementComponent.SetAcceleration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   acceleration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlyphNavMovementComponent::SetAcceleration(float acceleration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlyphNavMovementComponent", "SetAcceleration");

	Params::GlyphNavMovementComponent_SetAcceleration Parms{};

	Parms.acceleration = acceleration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GlyphNavMovementComponent.SetDeceleration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   deceleration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlyphNavMovementComponent::SetDeceleration(float deceleration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlyphNavMovementComponent", "SetDeceleration");

	Params::GlyphNavMovementComponent_SetDeceleration Parms{};

	Parms.deceleration = deceleration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GlyphNavMovementComponent.SetMaxSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   maxSpeed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlyphNavMovementComponent::SetMaxSpeed(float maxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlyphNavMovementComponent", "SetMaxSpeed");

	Params::GlyphNavMovementComponent_SetMaxSpeed Parms{};

	Parms.maxSpeed = maxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GlyphNavMovementComponent.GetGlyphOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UGlyphNavMovementComponent::GetGlyphOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlyphNavMovementComponent", "GetGlyphOwner");

	Params::GlyphNavMovementComponent_GetGlyphOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DoctorPowerAnimStateComponent.SetCurrentAbilityPhase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDoctorAbilityPhase                     abilityPhase                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDoctorPowerAnimStateComponent::SetCurrentAbilityPhase(EDoctorAbilityPhase abilityPhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoctorPowerAnimStateComponent", "SetCurrentAbilityPhase");

	Params::DoctorPowerAnimStateComponent_SetCurrentAbilityPhase Parms{};

	Parms.abilityPhase = abilityPhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DoctorPowerAnimStateComponent.SetCurrentAbilityType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDoctorAbilityType                      abilityType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDoctorPowerAnimStateComponent::SetCurrentAbilityType(EDoctorAbilityType abilityType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoctorPowerAnimStateComponent", "SetCurrentAbilityType");

	Params::DoctorPowerAnimStateComponent_SetCurrentAbilityType Parms{};

	Parms.abilityType = abilityType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.Authority_EndSelf
// (BlueprintAuthorityOnly, Native, Event, Public, BlueprintEvent)

void UStatusEffect::Authority_EndSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "Authority_EndSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.Authority_OnOriginatingPlayerEndPlay
// (Final, Native, Private)
// Parameters:
// class AActor*                           actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          endPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::Authority_OnOriginatingPlayerEndPlay(class AActor* actor, EEndPlayReason endPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "Authority_OnOriginatingPlayerEndPlay");

	Params::StatusEffect_Authority_OnOriginatingPlayerEndPlay Parms{};

	Parms.actor = actor;
	Parms.endPlayReason = endPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.Authority_RemoveSelf
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UStatusEffect::Authority_RemoveSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "Authority_RemoveSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.Authority_SetRemainingLifetime
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::Authority_SetRemainingLifetime(float lifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "Authority_SetRemainingLifetime");

	Params::StatusEffect_Authority_SetRemainingLifetime Parms{};

	Parms.lifetime = lifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.BroadcastGameEventNotification
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const struct FGameplayNotificationData& notificationData                                       (Parm, NativeAccessSpecifierPublic)
// bool                                    addToHistory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::BroadcastGameEventNotification(const struct FGameplayNotificationData& notificationData, bool addToHistory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "BroadcastGameEventNotification");

	Params::StatusEffect_BroadcastGameEventNotification Parms{};

	Parms.notificationData = std::move(notificationData);
	Parms.addToHistory = addToHistory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.BroadcastOriginatorGameEventNotification
// (Final, Native, Protected, BlueprintCallable)

void UStatusEffect::BroadcastOriginatorGameEventNotification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "BroadcastOriginatorGameEventNotification");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.InitializeLifetime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::InitializeLifetime(float lifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "InitializeLifetime");

	Params::StatusEffect_InitializeLifetime Parms{};

	Parms.lifetime = lifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.Multicast_SetRemainingLifetime
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// float                                   lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::Multicast_SetRemainingLifetime(float lifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "Multicast_SetRemainingLifetime");

	Params::StatusEffect_Multicast_SetRemainingLifetime Parms{};

	Parms.lifetime = lifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.Multicast_SetRemainingLifetimeInitialized
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    remainingLifetimeInitialized                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::Multicast_SetRemainingLifetimeInitialized(bool remainingLifetimeInitialized)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "Multicast_SetRemainingLifetimeInitialized");

	Params::StatusEffect_Multicast_SetRemainingLifetimeInitialized Parms{};

	Parms.remainingLifetimeInitialized = remainingLifetimeInitialized;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.OnRep_ShouldDisplay
// (Final, Native, Protected)

void UStatusEffect::OnRep_ShouldDisplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "OnRep_ShouldDisplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.OnRep_ShouldOriginatingPlayerChange
// (Final, Native, Protected)

void UStatusEffect::OnRep_ShouldOriginatingPlayerChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "OnRep_ShouldOriginatingPlayerChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.OnRep_StatusInitializationData
// (Final, Native, Private)

void UStatusEffect::OnRep_StatusInitializationData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "OnRep_StatusInitializationData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.OnShouldDisplayChanged
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    currentValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::OnShouldDisplayChanged(bool currentValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "OnShouldDisplayChanged");

	Params::StatusEffect_OnShouldDisplayChanged Parms{};

	Parms.currentValue = currentValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.OnShouldOriginatingPlayerChange
// (Native, Event, Protected, BlueprintEvent)

void UStatusEffect::OnShouldOriginatingPlayerChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "OnShouldOriginatingPlayerChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.SetShouldDisplay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    on                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::SetShouldDisplay(bool on)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "SetShouldDisplay");

	Params::StatusEffect_SetShouldDisplay Parms{};

	Parms.on = on;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.SetStatusEffectIconPercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::SetStatusEffectIconPercentage(float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "SetStatusEffectIconPercentage");

	Params::StatusEffect_SetStatusEffectIconPercentage Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.FireActiveStatusEffectEvent
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// float                                   percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   levelToDisplay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStatusEffect::FireActiveStatusEffectEvent(float percentage, int32 levelToDisplay) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "FireActiveStatusEffectEvent");

	Params::StatusEffect_FireActiveStatusEffectEvent Parms{};

	Parms.percentage = percentage;
	Parms.levelToDisplay = levelToDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffect.GetCustomParam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStatusEffect::GetCustomParam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "GetCustomParam");

	Params::StatusEffect_GetCustomParam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.GetLifetimeDuration
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStatusEffect::GetLifetimeDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "GetLifetimeDuration");

	Params::StatusEffect_GetLifetimeDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.GetOriginatingPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UStatusEffect::GetOriginatingPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "GetOriginatingPlayer");

	Params::StatusEffect_GetOriginatingPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.GetShouldDisplay
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusEffect::GetShouldDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "GetShouldDisplay");

	Params::StatusEffect_GetShouldDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.GetStatusEffectCooldownRate
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStatusEffect::GetStatusEffectCooldownRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "GetStatusEffectCooldownRate");

	Params::StatusEffect_GetStatusEffectCooldownRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.GetStatusEffectType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EStatusEffectType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStatusEffectType UStatusEffect::GetStatusEffectType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "GetStatusEffectType");

	Params::StatusEffect_GetStatusEffectType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.IsInOriginatorRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusEffect::IsInOriginatorRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "IsInOriginatorRange");

	Params::StatusEffect_IsInOriginatorRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.IsKillerInOriginatorRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   AdditiveRangeModifier                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusEffect::IsKillerInOriginatorRange(float AdditiveRangeModifier) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "IsKillerInOriginatorRange");

	Params::StatusEffect_IsKillerInOriginatorRange Parms{};

	Parms.AdditiveRangeModifier = AdditiveRangeModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.IsOriginatorAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusEffect::IsOriginatorAlive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "IsOriginatorAlive");

	Params::StatusEffect_IsOriginatorAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.IsOriginatorHooked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusEffect::IsOriginatorHooked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "IsOriginatorHooked");

	Params::StatusEffect_IsOriginatorHooked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StatusEffect.ShouldDisplayStatusEffectIcon
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStatusEffect::ShouldDisplayStatusEffectIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffect", "ShouldDisplayStatusEffectIcon");

	Params::StatusEffect_ShouldDisplayStatusEffectIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventLoadingScreen.OnLoadingTextTimerComplete
// (Final, Native, Public, Const)

void USpecialEventLoadingScreen::OnLoadingTextTimerComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpecialEventLoadingScreen", "OnLoadingTextTimerComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HitValidatorComponent.Multicast_DrawDebugHit
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FHitValidationReport&      report                                                 (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UHitValidatorComponent::Multicast_DrawDebugHit(const struct FHitValidationReport& report)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitValidatorComponent", "Multicast_DrawDebugHit");

	Params::HitValidatorComponent_Multicast_DrawDebugHit Parms{};

	Parms.report = std::move(report);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterBehaviourInteractWithActor.OnMovementFinished
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterBehaviourInteractWithActor::OnMovementFinished(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterBehaviourInteractWithActor", "OnMovementFinished");

	Params::AICharacterBehaviourInteractWithActor_OnMovementFinished Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TokenCounter.Authority_DecrementToken
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UTokenCounter::Authority_DecrementToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TokenCounter", "Authority_DecrementToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TokenCounter.Authority_IncrementToken
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UTokenCounter::Authority_IncrementToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TokenCounter", "Authority_IncrementToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TokenCounter.Authority_SetMaxTokenCount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTokenCounter::Authority_SetMaxTokenCount(int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TokenCounter", "Authority_SetMaxTokenCount");

	Params::TokenCounter_Authority_SetMaxTokenCount Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TokenCounter.Authority_SetTokenCount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTokenCounter::Authority_SetTokenCount(int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TokenCounter", "Authority_SetTokenCount");

	Params::TokenCounter_Authority_SetTokenCount Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TokenCounter.OnRep_TokenCount
// (Final, Native, Private)
// Parameters:
// int32                                   oldCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTokenCounter::OnRep_TokenCount(int32 oldCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TokenCounter", "OnRep_TokenCount");

	Params::TokenCounter_OnRep_TokenCount Parms{};

	Parms.oldCount = oldCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TokenCounter.GetMaxTokenCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTokenCounter::GetMaxTokenCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TokenCounter", "GetMaxTokenCount");

	Params::TokenCounter_GetMaxTokenCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TokenCounter.GetTokenCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTokenCounter::GetTokenCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TokenCounter", "GetTokenCount");

	Params::TokenCounter_GetTokenCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BlindableBaseComponent.Authority_AddBlindingEffector
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlindingEffectorInterface>effector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void UBlindableBaseComponent::Authority_AddBlindingEffector(TScriptInterface<class IBlindingEffectorInterface> effector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindableBaseComponent", "Authority_AddBlindingEffector");

	Params::BlindableBaseComponent_Authority_AddBlindingEffector Parms{};

	Parms.effector = effector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlindableBaseComponent.Authority_Blinded
// (Native, Public, BlueprintCallable)
// Parameters:
// EBlindType                              blindType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   blindnessDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           effectorActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlindableBaseComponent::Authority_Blinded(EBlindType blindType, float blindnessDuration, class AActor* effectorActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindableBaseComponent", "Authority_Blinded");

	Params::BlindableBaseComponent_Authority_Blinded Parms{};

	Parms.blindType = blindType;
	Parms.blindnessDuration = blindnessDuration;
	Parms.effectorActor = effectorActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlindableBaseComponent.Authority_RemoveBlindingEffector
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IBlindingEffectorInterface>effector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void UBlindableBaseComponent::Authority_RemoveBlindingEffector(TScriptInterface<class IBlindingEffectorInterface> effector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindableBaseComponent", "Authority_RemoveBlindingEffector");

	Params::BlindableBaseComponent_Authority_RemoveBlindingEffector Parms{};

	Parms.effector = effector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlindableBaseComponent.OnChargeableCompletionPercentChanged
// (Final, Native, Private)
// Parameters:
// class UChargeableComponent*             chargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   totalPercentComplete                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlindableBaseComponent::OnChargeableCompletionPercentChanged(class UChargeableComponent* chargeableComponent, float totalPercentComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindableBaseComponent", "OnChargeableCompletionPercentChanged");

	Params::BlindableBaseComponent_OnChargeableCompletionPercentChanged Parms{};

	Parms.chargeableComponent = chargeableComponent;
	Parms.totalPercentComplete = totalPercentComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlindableBaseComponent.OnRep_IsBlinded
// (Final, Native, Private)

void UBlindableBaseComponent::OnRep_IsBlinded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindableBaseComponent", "OnRep_IsBlinded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlindableBaseComponent.SetChargeable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UChargeableComponent*             value                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlindableBaseComponent::SetChargeable(class UChargeableComponent* value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindableBaseComponent", "SetChargeable");

	Params::BlindableBaseComponent_SetChargeable Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlindableBaseComponent.IsBlinded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlindableBaseComponent::IsBlinded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindableBaseComponent", "IsBlinded");

	Params::BlindableBaseComponent_IsBlinded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DirectionalMinigameSurvivorComponent.Client_StopInteraction
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UDirectionalMinigameComponent*    directionalMinigame                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDirectionalMinigameResult              result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalMinigameSurvivorComponent::Client_StopInteraction(class UDirectionalMinigameComponent* directionalMinigame, EDirectionalMinigameResult result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionalMinigameSurvivorComponent", "Client_StopInteraction");

	Params::DirectionalMinigameSurvivorComponent_Client_StopInteraction Parms{};

	Parms.directionalMinigame = directionalMinigame;
	Parms.result = result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DirectionalMinigameSurvivorComponent.Server_CancelMinigame
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UDirectionalMinigameComponent*    directionalMinigame                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalMinigameSurvivorComponent::Server_CancelMinigame(class UDirectionalMinigameComponent* directionalMinigame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionalMinigameSurvivorComponent", "Server_CancelMinigame");

	Params::DirectionalMinigameSurvivorComponent_Server_CancelMinigame Parms{};

	Parms.directionalMinigame = directionalMinigame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DirectionalMinigameSurvivorComponent.Server_EnterKey
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UDirectionalMinigameComponent*    directionalMinigame                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDirectionalInputKey                    key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalMinigameSurvivorComponent::Server_EnterKey(class UDirectionalMinigameComponent* directionalMinigame, EDirectionalInputKey key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionalMinigameSurvivorComponent", "Server_EnterKey");

	Params::DirectionalMinigameSurvivorComponent_Server_EnterKey Parms{};

	Parms.directionalMinigame = directionalMinigame;
	Parms.key = key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.ActionRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::ActionRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "ActionRequest");

	Params::DBDAIController_ActionRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.AttackRequest
// (Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::AttackRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "AttackRequest");

	Params::DBDAIController_AttackRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.CancelMinigameRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::CancelMinigameRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "CancelMinigameRequest");

	Params::DBDAIController_CancelMinigameRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.DropItemRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::DropItemRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "DropItemRequest");

	Params::DBDAIController_DropItemRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndActionRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndActionRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndActionRequest");

	Params::DBDAIController_EndActionRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndDropItemRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndDropItemRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndDropItemRequest");

	Params::DBDAIController_EndDropItemRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndFastInteractRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndFastInteractRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndFastInteractRequest");

	Params::DBDAIController_EndFastInteractRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndInteractRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndInteractRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndInteractRequest");

	Params::DBDAIController_EndInteractRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndRunRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndRunRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndRunRequest");

	Params::DBDAIController_EndRunRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndSecondAttackRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndSecondAttackRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndSecondAttackRequest");

	Params::DBDAIController_EndSecondAttackRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.EndUseItemRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::EndUseItemRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "EndUseItemRequest");

	Params::DBDAIController_EndUseItemRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.FastInteractRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::FastInteractRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "FastInteractRequest");

	Params::DBDAIController_FastInteractRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.Gesture01Request
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::Gesture01Request(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "Gesture01Request");

	Params::DBDAIController_Gesture01Request Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.Gesture02Request
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::Gesture02Request(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "Gesture02Request");

	Params::DBDAIController_Gesture02Request Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.Gesture03Request
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::Gesture03Request(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "Gesture03Request");

	Params::DBDAIController_Gesture03Request Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.Gesture04Request
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::Gesture04Request(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "Gesture04Request");

	Params::DBDAIController_Gesture04Request Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.InteractRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::InteractRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "InteractRequest");

	Params::DBDAIController_InteractRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.InteractRequestRelease
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::InteractRequestRelease(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "InteractRequestRelease");

	Params::DBDAIController_InteractRequestRelease Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.RunRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::RunRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "RunRequest");

	Params::DBDAIController_RunRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.SecondaryActionRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::SecondaryActionRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "SecondaryActionRequest");

	Params::DBDAIController_SecondaryActionRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.SecondAttackRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::SecondAttackRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "SecondAttackRequest");

	Params::DBDAIController_SecondAttackRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.Server_SetAIPlayerRank
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int32                                   playerRank                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::Server_SetAIPlayerRank(int32 playerRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "Server_SetAIPlayerRank");

	Params::DBDAIController_Server_SetAIPlayerRank Parms{};

	Parms.playerRank = playerRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.SetCharacterMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECharacterMovementTypes                 movementTypes                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDAIController::SetCharacterMovement(ECharacterMovementTypes movementTypes, const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "SetCharacterMovement");

	Params::DBDAIController_SetCharacterMovement Parms{};

	Parms.movementTypes = movementTypes;
	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAIController.StruggleRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   input                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::StruggleRequest(const class UObject* requester, float input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "StruggleRequest");

	Params::DBDAIController_StruggleRequest Parms{};

	Parms.requester = requester;
	Parms.input = input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIController.UseItemRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    requester                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIController::UseItemRequest(const class UObject* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIController", "UseItemRequest");

	Params::DBDAIController_UseItemRequest Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierCondition.OnOwningGameplayModifierSet
// (Event, Public, BlueprintEvent)

void UGameplayModifierCondition::OnOwningGameplayModifierSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierCondition", "OnOwningGameplayModifierSet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.GameplayModifierCondition.SetOwningGameplayModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayModifierContainer*       OwningGameplayModifier                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierCondition::SetOwningGameplayModifier(class UGameplayModifierContainer* OwningGameplayModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierCondition", "SetOwningGameplayModifier");

	Params::GameplayModifierCondition_SetOwningGameplayModifier Parms{};

	Parms.OwningGameplayModifier = OwningGameplayModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierCondition.GetOwningGameplayModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayModifierContainer*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayModifierContainer* UGameplayModifierCondition::GetOwningGameplayModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierCondition", "GetOwningGameplayModifier");

	Params::GameplayModifierCondition_GetOwningGameplayModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierCondition.GetOwningPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UGameplayModifierCondition::GetOwningPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierCondition", "GetOwningPlayer");

	Params::GameplayModifierCondition_GetOwningPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayModifierCondition.IsApplicable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayModifierCondition::IsApplicable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayModifierCondition", "IsApplicable");

	Params::GameplayModifierCondition_IsApplicable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GameplayNotificationManager.FireGameplayNotification
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayNotificationData& notificationData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    addToHistory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayNotificationManager::FireGameplayNotification(const struct FGameplayNotificationData& notificationData, bool addToHistory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayNotificationManager", "FireGameplayNotification");

	Params::GameplayNotificationManager_FireGameplayNotification Parms{};

	Parms.notificationData = std::move(notificationData);
	Parms.addToHistory = addToHistory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayNotificationManager.Multicast_FireGameplayNotification
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const class UGameplayModifierContainer* modifierContainer                                      (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    addToHistory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayNotificationManager::Multicast_FireGameplayNotification(const class UGameplayModifierContainer* modifierContainer, bool addToHistory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayNotificationManager", "Multicast_FireGameplayNotification");

	Params::GameplayNotificationManager_Multicast_FireGameplayNotification Parms{};

	Parms.modifierContainer = modifierContainer;
	Parms.addToHistory = addToHistory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.AddDangerPredictionObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDBDDangerPredictionComponent*    toAdd                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::AddDangerPredictionObject(class UDBDDangerPredictionComponent* toAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "AddDangerPredictionObject");

	Params::DBDGameState_AddDangerPredictionObject Parms{};

	Parms.toAdd = toAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.AddTrap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AInteractable*                    toAdd                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::AddTrap(class AInteractable* toAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "AddTrap");

	Params::DBDGameState_AddTrap Parms{};

	Parms.toAdd = toAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_DeactivateAI
// (Final, Native, Public)

void ADBDGameState::Authority_DeactivateAI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_DeactivateAI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_EnableObsession
// (Final, Native, Public, BlueprintCallable)

void ADBDGameState::Authority_EnableObsession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_EnableObsession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_EscapeThroughHatch
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ADBDGameState::Authority_EscapeThroughHatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_EscapeThroughHatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_EvaluateObsessionTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       potentialTarget                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_EvaluateObsessionTarget(class ADBDPlayer* potentialTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_EvaluateObsessionTarget");

	Params::DBDGameState_Authority_EvaluateObsessionTarget Parms{};

	Parms.potentialTarget = potentialTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetAllPlayerLoaded
// (Final, Native, Public)

void ADBDGameState::Authority_SetAllPlayerLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetAllPlayerLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetEscapeDoorOpened
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    opened                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_SetEscapeDoorOpened(bool opened)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetEscapeDoorOpened");

	Params::DBDGameState_Authority_SetEscapeDoorOpened Parms{};

	Parms.opened = opened;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetGameLevelCreated
// (Final, Native, Public)

void ADBDGameState::Authority_SetGameLevelCreated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetGameLevelCreated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetGameLevelEnded
// (Final, Native, Public)
// Parameters:
// EEndGameReason                          endGameReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_SetGameLevelEnded(EEndGameReason endGameReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetGameLevelEnded");

	Params::DBDGameState_Authority_SetGameLevelEnded Parms{};

	Parms.endGameReason = endGameReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetGameLevelLoaded
// (Final, Native, Public)

void ADBDGameState::Authority_SetGameLevelLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetGameLevelLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetGameSelectedOffering
// (Final, Native, Public, HasOutParams)
// Parameters:
// const TArray<struct FSelectedOffering>& offerings                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_SetGameSelectedOffering(const TArray<struct FSelectedOffering>& offerings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetGameSelectedOffering");

	Params::DBDGameState_Authority_SetGameSelectedOffering Parms{};

	Parms.offerings = std::move(offerings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetGameStarted
// (Final, Native, Public)

void ADBDGameState::Authority_SetGameStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetGameStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetHatchOpen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    opened                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_SetHatchOpen(bool opened)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetHatchOpen");

	Params::DBDGameState_Authority_SetHatchOpen Parms{};

	Parms.opened = opened;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetLevelReadyToPlay
// (Final, Native, Public, BlueprintCallable)

void ADBDGameState::Authority_SetLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetObsessionTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    obsessionTarget                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_SetObsessionTarget(class ACamperPlayer* obsessionTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetObsessionTarget");

	Params::DBDGameState_Authority_SetObsessionTarget Parms{};

	Parms.obsessionTarget = obsessionTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SetSurvivorLeft
// (Final, Native, Public)
// Parameters:
// int32                                   survivorRemaining                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_SetSurvivorLeft(int32 survivorRemaining)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SetSurvivorLeft");

	Params::DBDGameState_Authority_SetSurvivorLeft Parms{};

	Parms.survivorRemaining = survivorRemaining;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Authority_SignalEscapeDoorActivated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    newEscapeDoorActivated                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Authority_SignalEscapeDoorActivated(bool newEscapeDoorActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Authority_SignalEscapeDoorActivated");

	Params::DBDGameState_Authority_SignalEscapeDoorActivated Parms{};

	Parms.newEscapeDoorActivated = newEscapeDoorActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.BroadcastOnSetBuildLevelData
// (Final, Native, Public)

void ADBDGameState::BroadcastOnSetBuildLevelData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "BroadcastOnSetBuildLevelData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.CallOnIntroComplete
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void ADBDGameState::CallOnIntroComplete(TDelegate<void()> callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "CallOnIntroComplete");

	Params::DBDGameState_CallOnIntroComplete Parms{};

	Parms.callback = callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.CallOnLevelReadyToPlay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void ADBDGameState::CallOnLevelReadyToPlay(TDelegate<void()> callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "CallOnLevelReadyToPlay");

	Params::DBDGameState_CallOnLevelReadyToPlay Parms{};

	Parms.callback = callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.CallOnSlasherSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(class ASlasherPlayer* slasher)>callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void ADBDGameState::CallOnSlasherSet(TDelegate<void(class ASlasherPlayer* slasher)> callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "CallOnSlasherSet");

	Params::DBDGameState_CallOnSlasherSet Parms{};

	Parms.callback = callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.GetDangerPredictionObjects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              isObjectDynamic                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class UDBDDangerPredictionComponent*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UDBDDangerPredictionComponent*> ADBDGameState::GetDangerPredictionObjects(const bool isObjectDynamic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetDangerPredictionObjects");

	Params::DBDGameState_GetDangerPredictionObjects Parms{};

	Parms.isObjectDynamic = isObjectDynamic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IntroCompleted
// (Final, Native, Public, BlueprintCallable)

void ADBDGameState::IntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IntroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.IsObsessionTargetAlive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsObsessionTargetAlive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsObsessionTargetAlive");

	Params::DBDGameState_IsObsessionTargetAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsObsessionTargetAliveInLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsObsessionTargetAliveInLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsObsessionTargetAliveInLevel");

	Params::DBDGameState_IsObsessionTargetAliveInLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.Multicast_BroadcastOnLevelLoadingTimeOutClientEvent
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ADBDGameState::Multicast_BroadcastOnLevelLoadingTimeOutClientEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_BroadcastOnLevelLoadingTimeOutClientEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_OnGameStarted
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ADBDGameState::Multicast_OnGameStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_OnGameStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_SendEnsureToClients
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const class FString&                    ensure                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_SendEnsureToClients(const class FString& ensure)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_SendEnsureToClients");

	Params::DBDGameState_Multicast_SendEnsureToClients Parms{};

	Parms.ensure = std::move(ensure);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_SendHVSPlusState
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_SendHVSPlusState(bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_SendHVSPlusState");

	Params::DBDGameState_Multicast_SendHVSPlusState Parms{};

	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_SetBuiltLevelData
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const struct FBuiltLevelData&           builtLevelData                                         (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_SetBuiltLevelData(const struct FBuiltLevelData& builtLevelData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_SetBuiltLevelData");

	Params::DBDGameState_Multicast_SetBuiltLevelData Parms{};

	Parms.builtLevelData = std::move(builtLevelData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_SetGameEnded
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    hasServerLeftGame                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_SetGameEnded(bool hasServerLeftGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_SetGameEnded");

	Params::DBDGameState_Multicast_SetGameEnded Parms{};

	Parms.hasServerLeftGame = hasServerLeftGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_SetGameLevelEnded
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EEndGameReason                          endGameReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_SetGameLevelEnded(EEndGameReason endGameReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_SetGameLevelEnded");

	Params::DBDGameState_Multicast_SetGameLevelEnded Parms{};

	Parms.endGameReason = endGameReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_SetGameLevelLoaded
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    gameLevelLoaded                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_SetGameLevelLoaded(bool gameLevelLoaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_SetGameLevelLoaded");

	Params::DBDGameState_Multicast_SetGameLevelLoaded Parms{};

	Parms.gameLevelLoaded = gameLevelLoaded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_SetLostServerConnection
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    hasLostServerConnection                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_SetLostServerConnection(bool hasLostServerConnection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_SetLostServerConnection");

	Params::DBDGameState_Multicast_SetLostServerConnection Parms{};

	Parms.hasLostServerConnection = hasLostServerConnection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_SetServerLeftGame
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    hasServerLeftGame                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_SetServerLeftGame(bool hasServerLeftGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_SetServerLeftGame");

	Params::DBDGameState_Multicast_SetServerLeftGame Parms{};

	Parms.hasServerLeftGame = hasServerLeftGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Multicast_UpdateCharacterFromGamePreset
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ADBDPlayerState_Menu*             playerState_Menu                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGamePresetData&           gamePresetData                                         (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDGameState::Multicast_UpdateCharacterFromGamePreset(class ADBDPlayerState_Menu* playerState_Menu, const struct FGamePresetData& gamePresetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Multicast_UpdateCharacterFromGamePreset");

	Params::DBDGameState_Multicast_UpdateCharacterFromGamePreset Parms{};

	Parms.playerState_Menu = playerState_Menu;
	Parms.gamePresetData = std::move(gamePresetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnPlayerGameStateChangedAddIfKilled
// (Final, Native, Private)
// Parameters:
// class ADBDPlayerState*                  playerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameState                              gameState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::OnPlayerGameStateChangedAddIfKilled(class ADBDPlayerState* playerState, EGameState gameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnPlayerGameStateChangedAddIfKilled");

	Params::DBDGameState_OnPlayerGameStateChangedAddIfKilled Parms{};

	Parms.playerState = playerState;
	Parms.gameState = gameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_ActivatedGeneratorCount
// (Final, Native, Private)
// Parameters:
// int32                                   oldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::OnRep_ActivatedGeneratorCount(int32 oldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_ActivatedGeneratorCount");

	Params::DBDGameState_OnRep_ActivatedGeneratorCount Parms{};

	Parms.oldValue = oldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_BuildLevelData
// (Final, Native, Private)

void ADBDGameState::OnRep_BuildLevelData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_BuildLevelData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_EscapeDoorActivated
// (Final, Native, Private)
// Parameters:
// bool                                    oldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::OnRep_EscapeDoorActivated(bool oldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_EscapeDoorActivated");

	Params::DBDGameState_OnRep_EscapeDoorActivated Parms{};

	Parms.oldValue = oldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_GameLevelLoadingStarted
// (Final, Native, Private)
// Parameters:
// bool                                    oldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::OnRep_GameLevelLoadingStarted(bool oldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_GameLevelLoadingStarted");

	Params::DBDGameState_OnRep_GameLevelLoadingStarted Parms{};

	Parms.oldValue = oldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_GamePresetData
// (Final, Native, Private)

void ADBDGameState::OnRep_GamePresetData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_GamePresetData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_HatchOpened
// (Final, Native, Private)
// Parameters:
// bool                                    oldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::OnRep_HatchOpened(bool oldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_HatchOpened");

	Params::DBDGameState_OnRep_HatchOpened Parms{};

	Parms.oldValue = oldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_LobbyId
// (Final, Native, Private)

void ADBDGameState::OnRep_LobbyId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_LobbyId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_ObsessionTarget
// (Final, Native, Private)
// Parameters:
// class ACamperPlayer*                    previousObsessionTarget                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::OnRep_ObsessionTarget(class ACamperPlayer* previousObsessionTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_ObsessionTarget");

	Params::DBDGameState_OnRep_ObsessionTarget Parms{};

	Parms.previousObsessionTarget = previousObsessionTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_OnGameLevelCreated
// (Final, Native, Private)

void ADBDGameState::OnRep_OnGameLevelCreated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_OnGameLevelCreated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_OnLevelReadyToPlay
// (Final, Native, Private)
// Parameters:
// bool                                    oldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::OnRep_OnLevelReadyToPlay(bool oldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_OnLevelReadyToPlay");

	Params::DBDGameState_OnRep_OnLevelReadyToPlay Parms{};

	Parms.oldValue = oldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_RequiredActivatedGeneratorCount
// (Final, Native, Private)
// Parameters:
// int32                                   oldRequiredActivatedGeneratorCount                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::OnRep_RequiredActivatedGeneratorCount(int32 oldRequiredActivatedGeneratorCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_RequiredActivatedGeneratorCount");

	Params::DBDGameState_OnRep_RequiredActivatedGeneratorCount Parms{};

	Parms.oldRequiredActivatedGeneratorCount = oldRequiredActivatedGeneratorCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_SecondsLeftInLobby
// (Final, Native, Private)
// Parameters:
// const int32                             oldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::OnRep_SecondsLeftInLobby(const int32 oldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_SecondsLeftInLobby");

	Params::DBDGameState_OnRep_SecondsLeftInLobby Parms{};

	Parms.oldValue = oldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_SessionId
// (Final, Native, Private)

void ADBDGameState::OnRep_SessionId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_SessionId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_SurvivorLeft
// (Final, Native, Private)
// Parameters:
// int32                                   oldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::OnRep_SurvivorLeft(int32 oldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_SurvivorLeft");

	Params::DBDGameState_OnRep_SurvivorLeft Parms{};

	Parms.oldValue = oldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.OnRep_UseNetAsyncLoading
// (Final, Native, Private)

void ADBDGameState::OnRep_UseNetAsyncLoading()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "OnRep_UseNetAsyncLoading");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.RemoveDangerPredictionObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDBDDangerPredictionComponent*    toRemove                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::RemoveDangerPredictionObject(class UDBDDangerPredictionComponent* toRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "RemoveDangerPredictionObject");

	Params::DBDGameState_RemoveDangerPredictionObject Parms{};

	Parms.toRemove = toRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.RemoveTrap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AInteractable*                    toRemove                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::RemoveTrap(class AInteractable* toRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "RemoveTrap");

	Params::DBDGameState_RemoveTrap Parms{};

	Parms.toRemove = toRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.ResetGameLevelStatus
// (Final, Native, Public)

void ADBDGameState::ResetGameLevelStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "ResetGameLevelStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.Server_UpdateGameRole
// (Final, Native, Public)

void ADBDGameState::Server_UpdateGameRole()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "Server_UpdateGameRole");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.SetBuiltLevelData
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FBuiltLevelData&           builtLevelData                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDGameState::SetBuiltLevelData(const struct FBuiltLevelData& builtLevelData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "SetBuiltLevelData");

	Params::DBDGameState_SetBuiltLevelData Parms{};

	Parms.builtLevelData = std::move(builtLevelData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.SetDisplayMapName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    display                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::SetDisplayMapName(bool display)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "SetDisplayMapName");

	Params::DBDGameState_SetDisplayMapName Parms{};

	Parms.display = display;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.SetGameLevelEnded
// (Final, Native, Public)
// Parameters:
// EEndGameReason                          endGameReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::SetGameLevelEnded(EEndGameReason endGameReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "SetGameLevelEnded");

	Params::DBDGameState_SetGameLevelEnded Parms{};

	Parms.endGameReason = endGameReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.SetKillerIntroCompletedNormalized
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   completedAmount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::SetKillerIntroCompletedNormalized(float completedAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "SetKillerIntroCompletedNormalized");

	Params::DBDGameState_SetKillerIntroCompletedNormalized Parms{};

	Parms.completedAmount = completedAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.SetPlayersReadyToStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    playersReadyToStart                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::SetPlayersReadyToStart(bool playersReadyToStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "SetPlayersReadyToStart");

	Params::DBDGameState_SetPlayersReadyToStart Parms{};

	Parms.playersReadyToStart = playersReadyToStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.SortOfferings
// (Final, Native, Public)

void ADBDGameState::SortOfferings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "SortOfferings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.UnregisterFromIntroCompleteAndLevelReadyToPlay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    inObject                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::UnregisterFromIntroCompleteAndLevelReadyToPlay(const class UObject* inObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "UnregisterFromIntroCompleteAndLevelReadyToPlay");

	Params::DBDGameState_UnregisterFromIntroCompleteAndLevelReadyToPlay Parms{};

	Parms.inObject = inObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameState.GetAllDangerPredictionObjects
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UDBDDangerPredictionComponent*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UDBDDangerPredictionComponent*> ADBDGameState::GetAllDangerPredictionObjects() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetAllDangerPredictionObjects");

	Params::DBDGameState_GetAllDangerPredictionObjects Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetCharacterCollection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterCollection*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterCollection* ADBDGameState::GetCharacterCollection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetCharacterCollection");

	Params::DBDGameState_GetCharacterCollection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetCollectableCollection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCollectableCollection*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCollectableCollection* ADBDGameState::GetCollectableCollection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetCollectableCollection");

	Params::DBDGameState_GetCollectableCollection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetEndGameStateComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEndGameStateComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEndGameStateComponent* ADBDGameState::GetEndGameStateComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetEndGameStateComponent");

	Params::DBDGameState_GetEndGameStateComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetGameLevelLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::GetGameLevelLoaded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetGameLevelLoaded");

	Params::DBDGameState_GetGameLevelLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetGameLevelLoadingStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::GetGameLevelLoadingStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetGameLevelLoadingStarted");

	Params::DBDGameState_GetGameLevelLoadingStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameBaseTraps
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ABaseTrap*>          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ABaseTrap*> ADBDGameState::GetInGameBaseTraps() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameBaseTraps");

	Params::DBDGameState_GetInGameBaseTraps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameEscapeDoors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AEscapeDoor*>        ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AEscapeDoor*> ADBDGameState::GetInGameEscapeDoors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameEscapeDoors");

	Params::DBDGameState_GetInGameEscapeDoors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameGenerators
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AGenerator*>         ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AGenerator*> ADBDGameState::GetInGameGenerators() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameGenerators");

	Params::DBDGameState_GetInGameGenerators Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameHatches
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AHatch*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AHatch*> ADBDGameState::GetInGameHatches() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameHatches");

	Params::DBDGameState_GetInGameHatches Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameMeatHooks
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AMeatHook*>          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AMeatHook*> ADBDGameState::GetInGameMeatHooks() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameMeatHooks");

	Params::DBDGameState_GetInGameMeatHooks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGamePallets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class APallet*>            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class APallet*> ADBDGameState::GetInGamePallets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGamePallets");

	Params::DBDGameState_GetInGamePallets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameReverseBearTrapRemovers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AReverseBearTrapRemover*>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AReverseBearTrapRemover*> ADBDGameState::GetInGameReverseBearTrapRemovers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameReverseBearTrapRemovers");

	Params::DBDGameState_GetInGameReverseBearTrapRemovers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameSearchables
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ASearchable*>        ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ASearchable*> ADBDGameState::GetInGameSearchables() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameSearchables");

	Params::DBDGameState_GetInGameSearchables Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetInGameWindows
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AWindow*>            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AWindow*> ADBDGameState::GetInGameWindows() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetInGameWindows");

	Params::DBDGameState_GetInGameWindows Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetIsGameEnded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::GetIsGameEnded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetIsGameEnded");

	Params::DBDGameState_GetIsGameEnded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASlasherPlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASlasherPlayer* ADBDGameState::GetKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetKiller");

	Params::DBDGameState_GetKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetKillerIntroCompletedNormalized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDGameState::GetKillerIntroCompletedNormalized() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetKillerIntroCompletedNormalized");

	Params::DBDGameState_GetKillerIntroCompletedNormalized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetLevelData
// (Final, Native, Public, Const)
// Parameters:
// const struct FBuiltLevelData            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FBuiltLevelData ADBDGameState::GetLevelData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetLevelData");

	Params::DBDGameState_GetLevelData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetLevelThemeAudioSoundBankAssetPtr
// (Final, Native, Public, Const)
// Parameters:
// TSoftObjectPtr<class UAkAudioBank>      ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UAkAudioBank> ADBDGameState::GetLevelThemeAudioSoundBankAssetPtr() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetLevelThemeAudioSoundBankAssetPtr");

	Params::DBDGameState_GetLevelThemeAudioSoundBankAssetPtr Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetLocalPlayerBasePawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* ADBDGameState::GetLocalPlayerBasePawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetLocalPlayerBasePawn");

	Params::DBDGameState_GetLocalPlayerBasePawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetLocalPlayerPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ADBDGameState::GetLocalPlayerPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetLocalPlayerPawn");

	Params::DBDGameState_GetLocalPlayerPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetMapThemeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ADBDGameState::GetMapThemeName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetMapThemeName");

	Params::DBDGameState_GetMapThemeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetNumberOfActiveSurvivors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADBDGameState::GetNumberOfActiveSurvivors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetNumberOfActiveSurvivors");

	Params::DBDGameState_GetNumberOfActiveSurvivors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetNumberOfOtherActiveSurvivors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       exception                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADBDGameState::GetNumberOfOtherActiveSurvivors(class ADBDPlayer* exception) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetNumberOfOtherActiveSurvivors");

	Params::DBDGameState_GetNumberOfOtherActiveSurvivors Parms{};

	Parms.exception = exception;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetObsessionTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACamperPlayer*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACamperPlayer* ADBDGameState::GetObsessionTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetObsessionTarget");

	Params::DBDGameState_GetObsessionTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetPlayerRoleCounts
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32*                                  survivorCount                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  killerCount                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  spectatorCount                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameState::GetPlayerRoleCounts(int32* survivorCount, int32* killerCount, int32* spectatorCount) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetPlayerRoleCounts");

	Params::DBDGameState_GetPlayerRoleCounts Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (survivorCount != nullptr)
		*survivorCount = Parms.survivorCount;

	if (killerCount != nullptr)
		*killerCount = Parms.killerCount;

	if (spectatorCount != nullptr)
		*spectatorCount = Parms.spectatorCount;
}


// Function DeadByDaylight.DBDGameState.GetPlayersReadyToStart
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::GetPlayersReadyToStart() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetPlayersReadyToStart");

	Params::DBDGameState_GetPlayersReadyToStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetPlayerStateByIDString
// (Final, Native, Public, Const)
// Parameters:
// const class FString&                    id                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayerState*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerState* ADBDGameState::GetPlayerStateByIDString(const class FString& id) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetPlayerStateByIDString");

	Params::DBDGameState_GetPlayerStateByIDString Parms{};

	Parms.id = std::move(id);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetPlayerStateByMirrorsID
// (Final, Native, Public, Const)
// Parameters:
// const class FString&                    id                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayerState*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerState* ADBDGameState::GetPlayerStateByMirrorsID(const class FString& id) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetPlayerStateByMirrorsID");

	Params::DBDGameState_GetPlayerStateByMirrorsID Parms{};

	Parms.id = std::move(id);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetRemainingGeneratorsNeeded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADBDGameState::GetRemainingGeneratorsNeeded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetRemainingGeneratorsNeeded");

	Params::DBDGameState_GetRemainingGeneratorsNeeded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetRequiredActivatedGeneratorCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADBDGameState::GetRequiredActivatedGeneratorCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetRequiredActivatedGeneratorCount");

	Params::DBDGameState_GetRequiredActivatedGeneratorCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetSelectedOffering
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// int32                                   index                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSelectedOffering*               selectedOffering                                       (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::GetSelectedOffering(int32 index, struct FSelectedOffering* selectedOffering) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetSelectedOffering");

	Params::DBDGameState_GetSelectedOffering Parms{};

	Parms.index = index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (selectedOffering != nullptr)
		*selectedOffering = std::move(Parms.selectedOffering);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetSelectedOfferings
// (Final, Native, Public, Const)
// Parameters:
// const TArray<struct FSelectedOffering>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FSelectedOffering> ADBDGameState::GetSelectedOfferings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetSelectedOfferings");

	Params::DBDGameState_GetSelectedOfferings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetSpecialEventGameplaySpawnerComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USpecialEventGameplaySpawnerComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USpecialEventGameplaySpawnerComponent* ADBDGameState::GetSpecialEventGameplaySpawnerComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetSpecialEventGameplaySpawnerComponent");

	Params::DBDGameState_GetSpecialEventGameplaySpawnerComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetSurvivorLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADBDGameState::GetSurvivorLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetSurvivorLeft");

	Params::DBDGameState_GetSurvivorLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetTotems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ATotem*>             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ATotem*> ADBDGameState::GetTotems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetTotems");

	Params::DBDGameState_GetTotems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.GetTraps
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AInteractable*>      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class AInteractable*> ADBDGameState::GetTraps() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "GetTraps");

	Params::DBDGameState_GetTraps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsEscapeDoorActivated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsEscapeDoorActivated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsEscapeDoorActivated");

	Params::DBDGameState_IsEscapeDoorActivated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsEscapeDoorOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsEscapeDoorOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsEscapeDoorOpen");

	Params::DBDGameState_IsEscapeDoorOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsEscapeRequirementCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsEscapeRequirementCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsEscapeRequirementCompleted");

	Params::DBDGameState_IsEscapeRequirementCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsHatchVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsHatchVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsHatchVisible");

	Params::DBDGameState_IsHatchVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsIntroCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsIntroCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsIntroCompleted");

	Params::DBDGameState_IsIntroCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsLevelReadyToPlay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsLevelReadyToPlay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsLevelReadyToPlay");

	Params::DBDGameState_IsLevelReadyToPlay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsLevelSetupDone
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsLevelSetupDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsLevelSetupDone");

	Params::DBDGameState_IsLevelSetupDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsLightingGenerated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsLightingGenerated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsLightingGenerated");

	Params::DBDGameState_IsLightingGenerated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsOfferingReceived
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsOfferingReceived() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsOfferingReceived");

	Params::DBDGameState_IsOfferingReceived Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsOnePlayerLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsOnePlayerLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsOnePlayerLeft");

	Params::DBDGameState_IsOnePlayerLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.IsPlayerDistributionReady
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameState::IsPlayerDistributionReady() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "IsPlayerDistributionReady");

	Params::DBDGameState_IsPlayerDistributionReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameState.UpdateInGamePallets
// (Final, Native, Public, BlueprintCallable, Const)

void ADBDGameState::UpdateInGamePallets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameState", "UpdateInGamePallets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventListenerCollectionComponent.AttachGameEventDispatcher
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameEventDispatcher*             gameEventDispatcher                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameEventListenerCollectionComponent::AttachGameEventDispatcher(class UGameEventDispatcher* gameEventDispatcher)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventListenerCollectionComponent", "AttachGameEventDispatcher");

	Params::GameEventListenerCollectionComponent_AttachGameEventDispatcher Parms{};

	Parms.gameEventDispatcher = gameEventDispatcher;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventListenerCollectionComponent.ListenToGameEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              eventType                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)>delegateToBind                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UGameEventListenerCollectionComponent::ListenToGameEvent(const struct FGameplayTag& eventType, TDelegate<void(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)> delegateToBind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventListenerCollectionComponent", "ListenToGameEvent");

	Params::GameEventListenerCollectionComponent_ListenToGameEvent Parms{};

	Parms.eventType = std::move(eventType);
	Parms.delegateToBind = delegateToBind;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventListenerCollectionComponent.UnlistenToAllGameEvents
// (Final, Native, Public, BlueprintCallable)

void UGameEventListenerCollectionComponent::UnlistenToAllGameEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventListenerCollectionComponent", "UnlistenToAllGameEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventListenerCollectionComponent.UnlistenToGameEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              eventType                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameEventListenerCollectionComponent::UnlistenToGameEvent(const struct FGameplayTag& eventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventListenerCollectionComponent", "UnlistenToGameEvent");

	Params::GameEventListenerCollectionComponent_UnlistenToGameEvent Parms{};

	Parms.eventType = std::move(eventType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StateMachine.Multicast_SetStateStack
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, NetValidate)
// Parameters:
// const TArray<uint16>&                   netStateIDStack                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UStateMachine::Multicast_SetStateStack(const TArray<uint16>& netStateIDStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachine", "Multicast_SetStateStack");

	Params::StateMachine_Multicast_SetStateStack Parms{};

	Parms.netStateIDStack = std::move(netStateIDStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StateMachine.NetIDStackChanged
// (Final, Native, Private)

void UStateMachine::NetIDStackChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachine", "NetIDStackChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StateMachine.Server_SetStateStack
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const TArray<uint16>&                   netStateIDStack                                        (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UStateMachine::Server_SetStateStack(const TArray<uint16>& netStateIDStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StateMachine", "Server_SetStateStack");

	Params::StateMachine_Server_SetStateStack Parms{};

	Parms.netStateIDStack = std::move(netStateIDStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDEmblem.Client_FinalizeReplication
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const float                             points                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FProgressionPoints>&progressionPoints                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDBDEmblem::Client_FinalizeReplication(const float points, const TArray<struct FProgressionPoints>& progressionPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDEmblem", "Client_FinalizeReplication");

	Params::DBDEmblem_Client_FinalizeReplication Parms{};

	Parms.points = points;
	Parms.progressionPoints = std::move(progressionPoints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActionButton.PlayBecameAvailableAnimation
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UActionButton::PlayBecameAvailableAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionButton", "PlayBecameAvailableAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ActionButton.SetIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FSlateBrush&               slateBrush                                             (Parm, NativeAccessSpecifierPublic)

void UActionButton::SetIcon(const struct FSlateBrush& slateBrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionButton", "SetIcon");

	Params::ActionButton_SetIcon Parms{};

	Parms.slateBrush = std::move(slateBrush);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActionButton.SetPreviousState
// (Final, Native, Protected, BlueprintCallable)

void UActionButton::SetPreviousState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionButton", "SetPreviousState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActionButton.SetSlateBrush
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSlateBrush&               InBrush                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UActionButton::SetSlateBrush(const struct FSlateBrush& InBrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionButton", "SetSlateBrush");

	Params::ActionButton_SetSlateBrush Parms{};

	Parms.InBrush = std::move(InBrush);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActionButton.SetState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EActionButtonState                      state                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActionButton::SetState(EActionButtonState state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActionButton", "SetState");

	Params::ActionButton_SetState Parms{};

	Parms.state = state;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.WorldRunawayMeshComponent.SetShouldRunAway
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    should                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldRunawayMeshComponent::SetShouldRunAway(bool should)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldRunawayMeshComponent", "SetShouldRunAway");

	Params::WorldRunawayMeshComponent_SetShouldRunAway Parms{};

	Parms.should = should;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.WorldRunawayMeshComponent.SetShouldRunAwayWithDelay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    should                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldRunawayMeshComponent::SetShouldRunAwayWithDelay(bool should, float delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldRunawayMeshComponent", "SetShouldRunAwayWithDelay");

	Params::WorldRunawayMeshComponent_SetShouldRunAwayWithDelay Parms{};

	Parms.should = should;
	Parms.delay = delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.WorldRunawayMeshComponent.SetShouldRunAwayWithRandomDelay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    should                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   delayRange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldRunawayMeshComponent::SetShouldRunAwayWithRandomDelay(bool should, float delayRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldRunawayMeshComponent", "SetShouldRunAwayWithRandomDelay");

	Params::WorldRunawayMeshComponent_SetShouldRunAwayWithRandomDelay Parms{};

	Parms.should = should;
	Parms.delayRange = delayRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.WorldRunawayMeshComponent.GetShouldRunAway
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorldRunawayMeshComponent::GetShouldRunAway() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldRunawayMeshComponent", "GetShouldRunAway");

	Params::WorldRunawayMeshComponent_GetShouldRunAway Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LegalMenuScreen.OnAcceptClick
// (Final, Native, Protected)

void ULegalMenuScreen::OnAcceptClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalMenuScreen", "OnAcceptClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LegalMenuScreen.OnDeclineClick
// (Final, Native, Protected)

void ULegalMenuScreen::OnDeclineClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalMenuScreen", "OnDeclineClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LegalMenuScreen.OnOkClick
// (Final, Native, Protected)

void ULegalMenuScreen::OnOkClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LegalMenuScreen", "OnOkClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaCreditsPopup.SetCreditContent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    content                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaCreditsPopup::SetCreditContent(const class FString& content)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaCreditsPopup", "SetCreditContent");

	Params::UMGAtlantaCreditsPopup_SetCreditContent Parms{};

	Parms.content = std::move(content);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaCreditsPopup.SetCreditTitle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    title                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaCreditsPopup::SetCreditTitle(const class FString& title)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaCreditsPopup", "SetCreditTitle");

	Params::UMGAtlantaCreditsPopup_SetCreditTitle Parms{};

	Parms.title = std::move(title);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerProjectile.SetActiveSlashable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKillerProjectile::SetActiveSlashable(bool active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectile", "SetActiveSlashable");

	Params::KillerProjectile_SetActiveSlashable Parms{};

	Parms.active = active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerProjectile.GetLaunchingKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASlasherPlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASlasherPlayer* AKillerProjectile::GetLaunchingKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectile", "GetLaunchingKiller");

	Params::KillerProjectile_GetLaunchingKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.KillerProjectile.GetPlayerPrimitiveComponent
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* AKillerProjectile::GetPlayerPrimitiveComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectile", "GetPlayerPrimitiveComponent");

	Params::KillerProjectile_GetPlayerPrimitiveComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BaseLinkedVomitProjectile.NativeExplode
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FImpactInfo&               impactInfo                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABaseLinkedVomitProjectile::NativeExplode(const struct FImpactInfo& impactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseLinkedVomitProjectile", "NativeExplode");

	Params::BaseLinkedVomitProjectile_NativeExplode Parms{};

	Parms.impactInfo = std::move(impactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseLinkedVomitProjectile.OnAffectInteractable
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AInteractable*                    interactable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  hitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseLinkedVomitProjectile::OnAffectInteractable(class AInteractable* interactable, class USceneComponent* hitComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseLinkedVomitProjectile", "OnAffectInteractable");

	Params::BaseLinkedVomitProjectile_OnAffectInteractable Parms{};

	Parms.interactable = interactable;
	Parms.hitComponent = hitComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseLinkedVomitProjectile.OnAffectSurvivor
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ACamperPlayer*                    camperPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseLinkedVomitProjectile::OnAffectSurvivor(class ACamperPlayer* camperPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseLinkedVomitProjectile", "OnAffectSurvivor");

	Params::BaseLinkedVomitProjectile_OnAffectSurvivor Parms{};

	Parms.camperPlayer = camperPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GateFactory.GetGate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EGateType                               gateType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGate*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGate* AGateFactory::GetGate(EGateType gateType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GateFactory", "GetGate");

	Params::GateFactory_GetGate Parms{};

	Parms.gateType = gateType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorClipperComponent.OnCameraChanged
// (Final, Native, Private)
// Parameters:
// EDBDCameraSocketID                      socketId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorClipperComponent::OnCameraChanged(EDBDCameraSocketID socketId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorClipperComponent", "OnCameraChanged");

	Params::ActorClipperComponent_OnCameraChanged Parms{};

	Parms.socketId = socketId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorClipperComponent.OnOwnerLocallyObservedChanged
// (Final, Native, Private)
// Parameters:
// bool                                    locallyObserved                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorClipperComponent::OnOwnerLocallyObservedChanged(bool locallyObserved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorClipperComponent", "OnOwnerLocallyObservedChanged");

	Params::ActorClipperComponent_OnOwnerLocallyObservedChanged Parms{};

	Parms.locallyObserved = locallyObserved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorClipperComponent.SetPrimitiveCollection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UPrimitiveCollection*       clippables                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorClipperComponent::SetPrimitiveCollection(const class UPrimitiveCollection* clippables)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorClipperComponent", "SetPrimitiveCollection");

	Params::ActorClipperComponent_SetPrimitiveCollection Parms{};

	Parms.clippables = clippables;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGGenericPopup.OnPopupAppearance
// (Event, Public, BlueprintEvent)

void UUMGGenericPopup::OnPopupAppearance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGGenericPopup", "OnPopupAppearance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGGenericPopup.OnPopupDisappearance
// (Event, Public, BlueprintEvent)

void UUMGGenericPopup::OnPopupDisappearance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGGenericPopup", "OnPopupDisappearance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ActorDetectorComponent.OnOverlapEnter
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UActorDetectorComponent::OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorDetectorComponent", "OnOverlapEnter");

	Params::ActorDetectorComponent_OnOverlapEnter Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorDetectorComponent.SetDetectionPrimitive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              primitive                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorDetectorComponent::SetDetectionPrimitive(class UPrimitiveComponent* primitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorDetectorComponent", "SetDetectionPrimitive");

	Params::ActorDetectorComponent_SetDetectionPrimitive Parms{};

	Parms.primitive = primitive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Authority_Add
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorKnowledgeCollection::Authority_Add(class AActor* actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Authority_Add");

	Params::ActorKnowledgeCollection_Authority_Add Parms{};

	Parms.actor = actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Authority_Append
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UActorKnowledgeCollection::Authority_Append(const TArray<class AActor*>& actors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Authority_Append");

	Params::ActorKnowledgeCollection_Authority_Append Parms{};

	Parms.actors = std::move(actors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Authority_Empty
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UActorKnowledgeCollection::Authority_Empty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Authority_Empty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Authority_Remove
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorKnowledgeCollection::Authority_Remove(class AActor* actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Authority_Remove");

	Params::ActorKnowledgeCollection_Authority_Remove Parms{};

	Parms.actor = actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Authority_SetAvailable
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorKnowledgeCollection::Authority_SetAvailable(bool value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Authority_SetAvailable");

	Params::ActorKnowledgeCollection_Authority_SetAvailable Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Authority_SetPossessor
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       possessor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorKnowledgeCollection::Authority_SetPossessor(class ACharacter* possessor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Authority_SetPossessor");

	Params::ActorKnowledgeCollection_Authority_SetPossessor Parms{};

	Parms.possessor = possessor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Authority_SetSharingType
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EKnowledgeSharingType                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorKnowledgeCollection::Authority_SetSharingType(EKnowledgeSharingType value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Authority_SetSharingType");

	Params::ActorKnowledgeCollection_Authority_SetSharingType Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Local_SetAvailable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorKnowledgeCollection::Local_SetAvailable(bool value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Local_SetAvailable");

	Params::ActorKnowledgeCollection_Local_SetAvailable Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.OnRep_Actors
// (Final, Native, Private)

void UActorKnowledgeCollection::OnRep_Actors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "OnRep_Actors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorKnowledgeCollection.Contains
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorKnowledgeCollection::Contains(class AActor* actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "Contains");

	Params::ActorKnowledgeCollection_Contains Parms{};

	Parms.actor = actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorKnowledgeCollection.IsAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ACharacter*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorKnowledgeCollection::IsAvailable(const class ACharacter* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorKnowledgeCollection", "IsAvailable");

	Params::ActorKnowledgeCollection_IsAvailable Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaPartyFlowHandler.DisplayPartyFlowHandlerInfo
// (Final, Native, Private)

void UAtlantaPartyFlowHandler::DisplayPartyFlowHandlerInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaPartyFlowHandler", "DisplayPartyFlowHandlerInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorSpawner.Authority_SpawnActorAsyncEvent
// (Final, Native, Public, BlueprintCallable)

void UActorSpawner::Authority_SpawnActorAsyncEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSpawner", "Authority_SpawnActorAsyncEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorSpawner.AuthoritySelect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    selected                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorSpawner::AuthoritySelect(bool selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSpawner", "AuthoritySelect");

	Params::ActorSpawner_AuthoritySelect Parms{};

	Parms.selected = selected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorSpawner.EditorForceSpawnVisualization
// (Final, Native, Public, BlueprintCallable)

void UActorSpawner::EditorForceSpawnVisualization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSpawner", "EditorForceSpawnVisualization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ActorSpawner.AuthorityGetSpawnedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UActorSpawner::AuthorityGetSpawnedActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSpawner", "AuthorityGetSpawnedActor");

	Params::ActorSpawner_AuthorityGetSpawnedActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorSpawner.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorSpawner::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSpawner", "IsEnabled");

	Params::ActorSpawner_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ActorSpawner.UseActivatedElement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UActorSpawner::UseActivatedElement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorSpawner", "UseActivatedElement");

	Params::ActorSpawner_UseActivatedElement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Authority_SetPlayerReady
// (Final, Native, Public)
// Parameters:
// bool                                    isReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Authority_SetPlayerReady(bool isReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Authority_SetPlayerReady");

	Params::DBDPlayerController_Menu_Authority_SetPlayerReady Parms{};

	Parms.isReady = isReady;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Authority_TogglePlayerReadyState
// (Final, Native, Public)

void ADBDPlayerController_Menu::Authority_TogglePlayerReadyState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Authority_TogglePlayerReadyState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_GamePresetDataFromClient
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const struct FGamePresetData&           gameState                                              (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_GamePresetDataFromClient(const struct FGamePresetData& gameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_GamePresetDataFromClient");

	Params::DBDPlayerController_Menu_Server_GamePresetDataFromClient Parms{};

	Parms.gameState = std::move(gameState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_SetCharacterData
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   characterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlayerDataSync&           playerDataSync                                         (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_SetCharacterData(int32 characterIndex, const struct FPlayerDataSync& playerDataSync)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_SetCharacterData");

	Params::DBDPlayerController_Menu_Server_SetCharacterData Parms{};

	Parms.characterIndex = characterIndex;
	Parms.playerDataSync = std::move(playerDataSync);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_SetCharacterLevel
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   characterLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   prestigeLevel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    callOnRep                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_SetCharacterLevel(int32 characterLevel, int32 prestigeLevel, bool callOnRep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_SetCharacterLevel");

	Params::DBDPlayerController_Menu_Server_SetCharacterLevel Parms{};

	Parms.characterLevel = characterLevel;
	Parms.prestigeLevel = prestigeLevel;
	Parms.callOnRep = callOnRep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_SetCustomizationCharm
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FName                             charmId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int8                                    slotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_SetCustomizationCharm(class FName charmId, int8 slotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_SetCustomizationCharm");

	Params::DBDPlayerController_Menu_Server_SetCustomizationCharm Parms{};

	Parms.charmId = charmId;
	Parms.slotIndex = slotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_SetCustomizationMeshes
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const struct FCharacterCustomization&   customization                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_SetCustomizationMeshes(const struct FCharacterCustomization& customization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_SetCustomizationMeshes");

	Params::DBDPlayerController_Menu_Server_SetCustomizationMeshes Parms{};

	Parms.customization = std::move(customization);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_SetEquipedPerks
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const TArray<class FName>&              perkIds                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<int32>&                    perkLevels                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    callOnRep                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_SetEquipedPerks(const TArray<class FName>& perkIds, const TArray<int32>& perkLevels, bool callOnRep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_SetEquipedPerks");

	Params::DBDPlayerController_Menu_Server_SetEquipedPerks Parms{};

	Parms.perkIds = std::move(perkIds);
	Parms.perkLevels = std::move(perkLevels);
	Parms.callOnRep = callOnRep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_SetPlayerLoadout
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const struct FPlayerLoadoutData&        desiredLoadout                                         (Parm, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_SetPlayerLoadout(const struct FPlayerLoadoutData& desiredLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_SetPlayerLoadout");

	Params::DBDPlayerController_Menu_Server_SetPlayerLoadout Parms{};

	Parms.desiredLoadout = std::move(desiredLoadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_SetPlayerReady
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    isReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::Server_SetPlayerReady(bool isReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_SetPlayerReady");

	Params::DBDPlayerController_Menu_Server_SetPlayerReady Parms{};

	Parms.isReady = isReady;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.Server_SetReadyToTravel
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ADBDPlayerController_Menu::Server_SetReadyToTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "Server_SetReadyToTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.SetPlayerReady
// (Final, Native, Public)
// Parameters:
// bool                                    isReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController_Menu::SetPlayerReady(bool isReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "SetPlayerReady");

	Params::DBDPlayerController_Menu_SetPlayerReady Parms{};

	Parms.isReady = isReady;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController_Menu.TogglePlayerReadyState
// (Final, Native, Public)

void ADBDPlayerController_Menu::TogglePlayerReadyState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController_Menu", "TogglePlayerReadyState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterEscapeCarriedData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    preventWiggleSuccess                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterEscapeCarriedData::Init(bool preventWiggleSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterEscapeCarriedData", "Init");

	Params::AICharacterEscapeCarriedData_Init Parms{};

	Parms.preventWiggleSuccess = preventWiggleSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterEvasionBehaviourData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           hunter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            escapePoints                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   minEscapeDist                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterEvasionBehaviourData::Init(class AActor* hunter, const TArray<class AActor*>& escapePoints, float minEscapeDist)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterEvasionBehaviourData", "Init");

	Params::CharacterEvasionBehaviourData_Init Parms{};

	Parms.hunter = hunter;
	Parms.escapePoints = std::move(escapePoints);
	Parms.minEscapeDist = minEscapeDist;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterEvasionBehaviour.EscapeDestinationReached
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterEvasionBehaviour::EscapeDestinationReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterEvasionBehaviour", "EscapeDestinationReached");

	Params::AICharacterEvasionBehaviour_EscapeDestinationReached Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterHideInLockerBehaviourData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALocker*                          locker                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterMovementTypes                 characterMovementType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterHideInLockerBehaviourData::Init(class ALocker* locker, ECharacterMovementTypes characterMovementType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterHideInLockerBehaviourData", "Init");

	Params::AICharacterHideInLockerBehaviourData_Init Parms{};

	Parms.locker = locker;
	Parms.characterMovementType = characterMovementType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.Authority_ConditionalVolumeBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTriggerableWorldObjectComponent::Authority_ConditionalVolumeBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "Authority_ConditionalVolumeBeginOverlap");

	Params::TriggerableWorldObjectComponent_Authority_ConditionalVolumeBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.other = other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.Authority_ConditionalVolumeEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTriggerableWorldObjectComponent::Authority_ConditionalVolumeEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "Authority_ConditionalVolumeEndOverlap");

	Params::TriggerableWorldObjectComponent_Authority_ConditionalVolumeEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.other = other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.Authority_GuaranteedVolumeOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTriggerableWorldObjectComponent::Authority_GuaranteedVolumeOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "Authority_GuaranteedVolumeOverlap");

	Params::TriggerableWorldObjectComponent_Authority_GuaranteedVolumeOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.other = other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.Authority_ResetTrigger
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UTriggerableWorldObjectComponent::Authority_ResetTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "Authority_ResetTrigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.Authority_Trigger
// (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   triggerLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTriggerableWorldObjectComponent::Authority_Trigger(class AActor* instigator, const struct FVector& triggerLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "Authority_Trigger");

	Params::TriggerableWorldObjectComponent_Authority_Trigger Parms{};

	Parms.instigator = instigator;
	Parms.triggerLocation = std::move(triggerLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.CanPlayerTriggerConditional
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTriggerableWorldObjectComponent::CanPlayerTriggerConditional(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "CanPlayerTriggerConditional");

	Params::TriggerableWorldObjectComponent_CanPlayerTriggerConditional Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.CanPlayerTriggerGuaranteed
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTriggerableWorldObjectComponent::CanPlayerTriggerGuaranteed(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "CanPlayerTriggerGuaranteed");

	Params::TriggerableWorldObjectComponent_CanPlayerTriggerGuaranteed Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.GetConditionalModifiers
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  outAdditive                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  outMultiplicative                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTriggerableWorldObjectComponent::GetConditionalModifiers(class ADBDPlayer* player, float* outAdditive, float* outMultiplicative)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "GetConditionalModifiers");

	Params::TriggerableWorldObjectComponent_GetConditionalModifiers Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outAdditive != nullptr)
		*outAdditive = Parms.outAdditive;

	if (outMultiplicative != nullptr)
		*outMultiplicative = Parms.outMultiplicative;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.Multicast_OnTriggered
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// class AActor*                           instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   triggerLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTriggerableWorldObjectComponent::Multicast_OnTriggered(class AActor* instigator, const struct FVector& triggerLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "Multicast_OnTriggered");

	Params::TriggerableWorldObjectComponent_Multicast_OnTriggered Parms{};

	Parms.instigator = instigator;
	Parms.triggerLocation = std::move(triggerLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.Multicast_OnTriggerReset
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void UTriggerableWorldObjectComponent::Multicast_OnTriggerReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "Multicast_OnTriggerReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.SetConditionalTriggerVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              volume                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTriggerableWorldObjectComponent::SetConditionalTriggerVolume(class UPrimitiveComponent* volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "SetConditionalTriggerVolume");

	Params::TriggerableWorldObjectComponent_SetConditionalTriggerVolume Parms{};

	Parms.volume = volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriggerableWorldObjectComponent.SetGuaranteedTriggerVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              volume                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTriggerableWorldObjectComponent::SetGuaranteedTriggerVolume(class UPrimitiveComponent* volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableWorldObjectComponent", "SetGuaranteedTriggerVolume");

	Params::TriggerableWorldObjectComponent_SetGuaranteedTriggerVolume Parms{};

	Parms.volume = volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Authority_CancelOngoingScoreEvent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              scoreTypeTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Authority_CancelOngoingScoreEvent(const struct FGameplayTag& scoreTypeTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Authority_CancelOngoingScoreEvent");

	Params::DBDPlayerState_Authority_CancelOngoingScoreEvent Parms{};

	Parms.scoreTypeTag = std::move(scoreTypeTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Authority_EndOngoingScoreEvent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              scoreTypeTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Authority_EndOngoingScoreEvent(const struct FGameplayTag& scoreTypeTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Authority_EndOngoingScoreEvent");

	Params::DBDPlayerState_Authority_EndOngoingScoreEvent Parms{};

	Parms.scoreTypeTag = std::move(scoreTypeTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Authority_HandleScoreEvent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              scoreTypeTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FScoreEventData&           scoreEventData                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayerState::Authority_HandleScoreEvent(const struct FGameplayTag& scoreTypeTag, const struct FScoreEventData& scoreEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Authority_HandleScoreEvent");

	Params::DBDPlayerState_Authority_HandleScoreEvent Parms{};

	Parms.scoreTypeTag = std::move(scoreTypeTag);
	Parms.scoreEventData = std::move(scoreEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Authority_SetPlayerGameState
// (Final, Native, Private)
// Parameters:
// EGameState                              newGameState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isEscapeHatch                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Authority_SetPlayerGameState(EGameState newGameState, bool isEscapeHatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Authority_SetPlayerGameState");

	Params::DBDPlayerState_Authority_SetPlayerGameState Parms{};

	Parms.newGameState = newGameState;
	Parms.isEscapeHatch = isEscapeHatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.ChangeStartingGameRole
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerRole                             gameRole                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::ChangeStartingGameRole(EPlayerRole gameRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "ChangeStartingGameRole");

	Params::DBDPlayerState_ChangeStartingGameRole Parms{};

	Parms.gameRole = gameRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_AtlantaUpdateInventoryItem
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// const class FName&                      itemid                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   newCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_AtlantaUpdateInventoryItem(const class FName& itemid, int32 newCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_AtlantaUpdateInventoryItem");

	Params::DBDPlayerState_Client_AtlantaUpdateInventoryItem Parms{};

	Parms.itemid = itemid;
	Parms.newCount = newCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_FetchCoreRituals
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// bool                                    hasClaimableRitual                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_FetchCoreRituals(bool hasClaimableRitual)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_FetchCoreRituals");

	Params::DBDPlayerState_Client_FetchCoreRituals Parms{};

	Parms.hasClaimableRitual = hasClaimableRitual;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_HandleEndOfMatch
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FEndOfMatchRPCData&        response                                               (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_HandleEndOfMatch(bool success, const struct FEndOfMatchRPCData& response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_HandleEndOfMatch");

	Params::DBDPlayerState_Client_HandleEndOfMatch Parms{};

	Parms.success = success;
	Parms.response = std::move(response);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_HandleEscapeScoreEvent
// (Net, NetReliable, Native, Event, Public, NetClient)

void ADBDPlayerState::Client_HandleEscapeScoreEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_HandleEscapeScoreEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_InvalidateIncentives
// (Net, NetReliable, Native, Event, Public, NetClient)

void ADBDPlayerState::Client_InvalidateIncentives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_InvalidateIncentives");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_RemotelyDispatchGameEvent
// (Net, NetReliable, Native, Event, Public, NetClient, NetValidate)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_RemotelyDispatchGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_RemotelyDispatchGameEvent");

	Params::DBDPlayerState_Client_RemotelyDispatchGameEvent Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_RemotelyDispatchGameEventWithScore
// (Net, NetReliable, Native, Event, Public, NetClient, NetValidate)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FAwardedScore&             awardedScore                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_RemotelyDispatchGameEventWithScore(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData, const struct FAwardedScore& awardedScore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_RemotelyDispatchGameEventWithScore");

	Params::DBDPlayerState_Client_RemotelyDispatchGameEventWithScore Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);
	Parms.awardedScore = std::move(awardedScore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_RemoveItemFromInventory
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                             toRemove                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    updateLoadout                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_RemoveItemFromInventory(class FName toRemove, bool updateLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_RemoveItemFromInventory");

	Params::DBDPlayerState_Client_RemoveItemFromInventory Parms{};

	Parms.toRemove = toRemove;
	Parms.updateLoadout = updateLoadout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_SetGameRole
// (Net, NetReliable, Native, Event, Protected, NetClient, NetValidate)
// Parameters:
// EPlayerRole                             newRole                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_SetGameRole(EPlayerRole newRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_SetGameRole");

	Params::DBDPlayerState_Client_SetGameRole Parms{};

	Parms.newRole = newRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_SetInParadise
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void ADBDPlayerState::Client_SetInParadise()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_SetInParadise");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Client_UpdateWallet
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const class FString&                    currencyId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Client_UpdateWallet(const class FString& currencyId, int32 amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Client_UpdateWallet");

	Params::DBDPlayerState_Client_UpdateWallet Parms{};

	Parms.currencyId = std::move(currencyId);
	Parms.amount = amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.FireActiveStatusEffectEvent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             statusEffectID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   iconFilePathIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   levelToDisplay                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::FireActiveStatusEffectEvent(class FName statusEffectID, float percentage, int32 iconFilePathIndex, int32 levelToDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "FireActiveStatusEffectEvent");

	Params::DBDPlayerState_FireActiveStatusEffectEvent Parms{};

	Parms.statusEffectID = statusEffectID;
	Parms.percentage = percentage;
	Parms.iconFilePathIndex = iconFilePathIndex;
	Parms.levelToDisplay = levelToDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.FireActiveStatusViewEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             statusViewID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             uniqueSourceID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FStatusViewSource&         statusViewSource                                       (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayerState::FireActiveStatusViewEvent(class FName statusViewID, class FName uniqueSourceID, const struct FStatusViewSource& statusViewSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "FireActiveStatusViewEvent");

	Params::DBDPlayerState_FireActiveStatusViewEvent Parms{};

	Parms.statusViewID = statusViewID;
	Parms.uniqueSourceID = uniqueSourceID;
	Parms.statusViewSource = std::move(statusViewSource);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.FireScoreEvent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EDBDScoreTypes                          scoreType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   percentToAward                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::FireScoreEvent(EDBDScoreTypes scoreType, float percentToAward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "FireScoreEvent");

	Params::DBDPlayerState_FireScoreEvent Parms{};

	Parms.scoreType = scoreType;
	Parms.percentToAward = percentToAward;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Multicast_FireGameplayEvent
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, NetValidate)
// Parameters:
// EDBDScoreTypes                          playerGameplayEventType                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           effector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Multicast_FireGameplayEvent(EDBDScoreTypes playerGameplayEventType, float amount, class AActor* effector, class AActor* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Multicast_FireGameplayEvent");

	Params::DBDPlayerState_Multicast_FireGameplayEvent Parms{};

	Parms.playerGameplayEventType = playerGameplayEventType;
	Parms.amount = amount;
	Parms.effector = effector;
	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Multicast_FireGameplayEventWithScore
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, NetValidate)
// Parameters:
// EDBDScoreTypes                          playerGameplayEventType                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           effector                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAwardedScore&             awardedScore                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayerState::Multicast_FireGameplayEventWithScore(EDBDScoreTypes playerGameplayEventType, float amount, class AActor* effector, class AActor* target, const struct FAwardedScore& awardedScore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Multicast_FireGameplayEventWithScore");

	Params::DBDPlayerState_Multicast_FireGameplayEventWithScore Parms{};

	Parms.playerGameplayEventType = playerGameplayEventType;
	Parms.amount = amount;
	Parms.effector = effector;
	Parms.target = target;
	Parms.awardedScore = std::move(awardedScore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Multicast_SetAsDisconnected
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ADBDPlayerState::Multicast_SetAsDisconnected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Multicast_SetAsDisconnected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Multicast_SetAsLeftMatch
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ADBDPlayerState::Multicast_SetAsLeftMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Multicast_SetAsLeftMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Multicast_SetInParadise
// (Net, NetReliable, Native, Event, NetMulticast, Protected, NetValidate)

void ADBDPlayerState::Multicast_SetInParadise()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Multicast_SetInParadise");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Multicast_SetPlayerGameState
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EGameState                              newGameState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isEscapeHatch                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Multicast_SetPlayerGameState(EGameState newGameState, bool isEscapeHatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Multicast_SetPlayerGameState");

	Params::DBDPlayerState_Multicast_SetPlayerGameState Parms{};

	Parms.newGameState = newGameState;
	Parms.isEscapeHatch = isEscapeHatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.OnRep_BotDifficultyLevel
// (Final, Native, Public)

void ADBDPlayerState::OnRep_BotDifficultyLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "OnRep_BotDifficultyLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.OnRep_CustomizationData
// (Native, Public)

void ADBDPlayerState::OnRep_CustomizationData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "OnRep_CustomizationData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.OnRep_DisplayData
// (Native, Public)

void ADBDPlayerState::OnRep_DisplayData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "OnRep_DisplayData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Server_CheatSelectKiller
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   slasherIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Server_CheatSelectKiller(int32 slasherIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Server_CheatSelectKiller");

	Params::DBDPlayerState_Server_CheatSelectKiller Parms{};

	Parms.slasherIndex = slasherIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.Server_CheatSelectSurvivor
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   camperIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState::Server_CheatSelectSurvivor(int32 camperIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "Server_CheatSelectSurvivor");

	Params::DBDPlayerState_Server_CheatSelectSurvivor Parms{};

	Parms.camperIndex = camperIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.UpdateOngoingScores
// (Final, Native, Protected)

void ADBDPlayerState::UpdateOngoingScores()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "UpdateOngoingScores");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState.GetGameplayNotificationManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayNotificationManager*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayNotificationManager* ADBDPlayerState::GetGameplayNotificationManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "GetGameplayNotificationManager");

	Params::DBDPlayerState_GetGameplayNotificationManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerState.GetGameRole
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerRole                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerRole ADBDPlayerState::GetGameRole() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "GetGameRole");

	Params::DBDPlayerState_GetGameRole Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerState.GetPlayerGameState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGameState                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameState ADBDPlayerState::GetPlayerGameState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "GetPlayerGameState");

	Params::DBDPlayerState_GetPlayerGameState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerState.HasEscaped
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayerState::HasEscaped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "HasEscaped");

	Params::DBDPlayerState_HasEscaped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerState.IsInFinishedPlayingState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayerState::IsInFinishedPlayingState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState", "IsInFinishedPlayingState");

	Params::DBDPlayerState_IsInFinishedPlayingState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerState_Menu.Multicast_SetSelectedCharacterCustomization
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EPlayerRole                             forRole                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FEquippedPlayerCustomization&customization                                          (ConstParm, Parm, NativeAccessSpecifierPublic)

void ADBDPlayerState_Menu::Multicast_SetSelectedCharacterCustomization(EPlayerRole forRole, int32 id, const struct FEquippedPlayerCustomization& customization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState_Menu", "Multicast_SetSelectedCharacterCustomization");

	Params::DBDPlayerState_Menu_Multicast_SetSelectedCharacterCustomization Parms{};

	Parms.forRole = forRole;
	Parms.id = id;
	Parms.customization = std::move(customization);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState_Menu.Multicast_SetSelectedCharacterId
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// EPlayerRole                             forRole                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    updateDisplayData                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState_Menu::Multicast_SetSelectedCharacterId(EPlayerRole forRole, int32 id, bool updateDisplayData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState_Menu", "Multicast_SetSelectedCharacterId");

	Params::DBDPlayerState_Menu_Multicast_SetSelectedCharacterId Parms{};

	Parms.forRole = forRole;
	Parms.id = id;
	Parms.updateDisplayData = updateDisplayData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState_Menu.Server_NotifyOnRep
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ADBDPlayerState_Menu::Server_NotifyOnRep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState_Menu", "Server_NotifyOnRep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState_Menu.Server_SetEquipment
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// ELoadoutSlot                            slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             itemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    callOnRep                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState_Menu::Server_SetEquipment(ELoadoutSlot slot, class FName itemId, bool callOnRep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState_Menu", "Server_SetEquipment");

	Params::DBDPlayerState_Menu_Server_SetEquipment Parms{};

	Parms.slot = slot;
	Parms.itemId = itemId;
	Parms.callOnRep = callOnRep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState_Menu.Server_SetEquipmentAddons
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const TArray<class FName>&              addonItemIds                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    callOnRep                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState_Menu::Server_SetEquipmentAddons(const TArray<class FName>& addonItemIds, bool callOnRep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState_Menu", "Server_SetEquipmentAddons");

	Params::DBDPlayerState_Menu_Server_SetEquipmentAddons Parms{};

	Parms.addonItemIds = std::move(addonItemIds);
	Parms.callOnRep = callOnRep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState_Menu.Server_SetSelectedCharacterCustomization
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EPlayerRole                             forRole                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FEquippedPlayerCustomization&customization                                          (ConstParm, Parm, NativeAccessSpecifierPublic)

void ADBDPlayerState_Menu::Server_SetSelectedCharacterCustomization(EPlayerRole forRole, int32 id, const struct FEquippedPlayerCustomization& customization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState_Menu", "Server_SetSelectedCharacterCustomization");

	Params::DBDPlayerState_Menu_Server_SetSelectedCharacterCustomization Parms{};

	Parms.forRole = forRole;
	Parms.id = id;
	Parms.customization = std::move(customization);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerState_Menu.Server_SetSelectedCharacterId
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    updateDisplayData                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerState_Menu::Server_SetSelectedCharacterId(int32 id, bool updateDisplayData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerState_Menu", "Server_SetSelectedCharacterId");

	Params::DBDPlayerState_Menu_Server_SetSelectedCharacterId Parms{};

	Parms.id = id;
	Parms.updateDisplayData = updateDisplayData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterHideInLockerBehaviour.OnMovementFinished
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterHideInLockerBehaviour::OnMovementFinished(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterHideInLockerBehaviour", "OnMovementFinished");

	Params::AICharacterHideInLockerBehaviour_OnMovementFinished Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterRepairGeneratorBehaviourData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGenerator*                       generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterMovementTypes                 characterMovementType                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterRepairGeneratorBehaviourData::Init(class AGenerator* generator, ECharacterMovementTypes characterMovementType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterRepairGeneratorBehaviourData", "Init");

	Params::AICharacterRepairGeneratorBehaviourData_Init Parms{};

	Parms.generator = generator;
	Parms.characterMovementType = characterMovementType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterRepairGeneratorBehaviour.OnGeneratorRepairedEventHandler
// (Final, Native, Private)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterRepairGeneratorBehaviour::OnGeneratorRepairedEventHandler(bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterRepairGeneratorBehaviour", "OnGeneratorRepairedEventHandler");

	Params::AICharacterRepairGeneratorBehaviour_OnGeneratorRepairedEventHandler Parms{};

	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AICharacterRepairGeneratorBehaviour.OnMovementFinished
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAICharacterRepairGeneratorBehaviour::OnMovementFinished(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AICharacterRepairGeneratorBehaviour", "OnMovementFinished");

	Params::AICharacterRepairGeneratorBehaviour_OnMovementFinished Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaStoreScreen.HandleOnClickedBuyAuricCell
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   cellIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaStoreScreen::HandleOnClickedBuyAuricCell(int32 cellIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaStoreScreen", "HandleOnClickedBuyAuricCell");

	Params::UMGAtlantaStoreScreen_HandleOnClickedBuyAuricCell Parms{};

	Parms.cellIndex = cellIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaStoreScreen.HandleOnStoreLeft
// (Final, Native, Public, BlueprintCallable)

void UUMGAtlantaStoreScreen::HandleOnStoreLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaStoreScreen", "HandleOnStoreLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaStoreScreen.SetBank
// (Event, Public, BlueprintEvent)
// Parameters:
// ECurrencyType                           currencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   bank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaStoreScreen::SetBank(ECurrencyType currencyType, int32 bank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaStoreScreen", "SetBank");

	Params::UMGAtlantaStoreScreen_SetBank Parms{};

	Parms.currencyType = currencyType;
	Parms.bank = bank;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.AIHealAllyBehaviourData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    allyToHealTarget                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIHealAllyBehaviourData::Init(class ACamperPlayer* allyToHealTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIHealAllyBehaviourData", "Init");

	Params::AIHealAllyBehaviourData_Init Parms{};

	Parms.allyToHealTarget = allyToHealTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGRitualClaimRewardButton.BroadcastOnPressedAnimationCompleted
// (Final, Native, Protected, BlueprintCallable)

void UUMGRitualClaimRewardButton::BroadcastOnPressedAnimationCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGRitualClaimRewardButton", "BroadcastOnPressedAnimationCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGRitualClaimRewardButton.SetClaimedButtonStatus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    isClaimed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGRitualClaimRewardButton::SetClaimedButtonStatus(bool isClaimed, float percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGRitualClaimRewardButton", "SetClaimedButtonStatus");

	Params::UMGRitualClaimRewardButton_SetClaimedButtonStatus Parms{};

	Parms.isClaimed = isClaimed;
	Parms.percent = percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AIHealAllyBehaviour.Init
// (Native, Public)
// Parameters:
// class ADBDPlayer*                       character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAICharacterBehaviourData*        behaviourData                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIHealAllyBehaviour::Init(class ADBDPlayer* character, class UAICharacterBehaviourData* behaviourData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIHealAllyBehaviour", "Init");

	Params::AIHealAllyBehaviour_Init Parms{};

	Parms.character = character;
	Parms.behaviourData = behaviourData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AIHealAllyBehaviour.TargetPositionReached
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIHealAllyBehaviour::TargetPositionReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIHealAllyBehaviour", "TargetPositionReached");

	Params::AIHealAllyBehaviour_TargetPositionReached Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGRoleSelectionScreen.ButtonClickEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERoleSelectionScreenButton              buttonId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGRoleSelectionScreen::ButtonClickEvent(ERoleSelectionScreenButton buttonId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGRoleSelectionScreen", "ButtonClickEvent");

	Params::UMGRoleSelectionScreen_ButtonClickEvent Parms{};

	Parms.buttonId = buttonId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AIMoveToInteractData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           interactActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterMovementTypes                 characterMovementTypes                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           targetPositionActor                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIMoveToInteractData::Init(class AActor* interactActor, ECharacterMovementTypes characterMovementTypes, class AActor* targetPositionActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIMoveToInteractData", "Init");

	Params::AIMoveToInteractData_Init Parms{};

	Parms.interactActor = interactActor;
	Parms.characterMovementTypes = characterMovementTypes;
	Parms.targetPositionActor = targetPositionActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusView.FireNotification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FStatusViewSource&         statusViewSource                                       (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void AStatusView::FireNotification(const struct FStatusViewSource& statusViewSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusView", "FireNotification");

	Params::StatusView_FireNotification Parms{};

	Parms.statusViewSource = std::move(statusViewSource);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusView.ResetView
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// const class ADBDPlayer*                 dbdPlayer                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AStatusView::ResetView(const class ADBDPlayer* dbdPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusView", "ResetView");

	Params::StatusView_ResetView Parms{};

	Parms.dbdPlayer = dbdPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AIMoveToInteract.Init
// (Native, Public)
// Parameters:
// class ADBDPlayer*                       character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAICharacterBehaviourData*        behaviourData                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIMoveToInteract::Init(class ADBDPlayer* character, class UAICharacterBehaviourData* behaviourData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIMoveToInteract", "Init");

	Params::AIMoveToInteract_Init Parms{};

	Parms.character = character;
	Parms.behaviourData = behaviourData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AIMoveToInteract.InteractionPointReached
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIMoveToInteract::InteractionPointReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIMoveToInteract", "InteractionPointReached");

	Params::AIMoveToInteract_InteractionPointReached Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AIMoveToPositionData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           positionActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterMovementTypes                 movementType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    usePathfinding                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIMoveToPositionData::Init(class AActor* positionActor, ECharacterMovementTypes movementType, bool usePathfinding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIMoveToPositionData", "Init");

	Params::AIMoveToPositionData_Init Parms{};

	Parms.positionActor = positionActor;
	Parms.movementType = movementType;
	Parms.usePathfinding = usePathfinding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AIMoveToPosition.Init
// (Native, Public)
// Parameters:
// class ADBDPlayer*                       character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAICharacterBehaviourData*        behaviourData                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIMoveToPosition::Init(class ADBDPlayer* character, class UAICharacterBehaviourData* behaviourData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIMoveToPosition", "Init");

	Params::AIMoveToPosition_Init Parms{};

	Parms.character = character;
	Parms.behaviourData = behaviourData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AIMoveToPosition.TargetPositionReached
// (Final, Native, Private)
// Parameters:
// const struct FAIRequestID&              RequestID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPathFollowingResult                    Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIMoveToPosition::TargetPositionReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIMoveToPosition", "TargetPositionReached");

	Params::AIMoveToPosition_TargetPositionReached Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBaseLandingPageStorefrontWidget.HandleTabSelected
// (Final, Native, Private, HasOutParams)
// Parameters:
// const EStorefrontState&                 tabId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBaseLandingPageStorefrontWidget::HandleTabSelected(const EStorefrontState& tabId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBaseLandingPageStorefrontWidget", "HandleTabSelected");

	Params::UMGBaseLandingPageStorefrontWidget_HandleTabSelected Parms{};

	Parms.tabId = tabId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlLandingPageStorefrontWidget.OnPromoCodeButtonPressed
// (Final, Native, Protected)

void UUMGAtlLandingPageStorefrontWidget::OnPromoCodeButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlLandingPageStorefrontWidget", "OnPromoCodeButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingContextButton.GetContextButtonData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUMGSettingContextButton::GetContextButtonData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingContextButton", "GetContextButtonData");

	Params::UMGSettingContextButton_GetContextButtonData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGSettingContextButton.HandleSettingContextButtonClick
// (Final, Native, Protected, BlueprintCallable)

void UUMGSettingContextButton::HandleSettingContextButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingContextButton", "HandleSettingContextButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingContextButton.SetButtonText
// (Event, Public, BlueprintEvent)
// Parameters:
// const class FString&                    buttonText                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingContextButton::SetButtonText(const class FString& buttonText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingContextButton", "SetButtonText");

	Params::UMGSettingContextButton_SetButtonText Parms{};

	Parms.buttonText = std::move(buttonText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGSettingContextButton.SetContextButtonData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   buttonID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingContextButton::SetContextButtonData(int32 buttonID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingContextButton", "SetContextButtonData");

	Params::UMGSettingContextButton_SetContextButtonData Parms{};

	Parms.buttonID = buttonID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingContextButton.SetIsSelected
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isSelected                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingContextButton::SetIsSelected(bool isSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingContextButton", "SetIsSelected");

	Params::UMGSettingContextButton_SetIsSelected Parms{};

	Parms.isSelected = isSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.EventHookComponent.SetOutlineCarryingColorToDefault
// (Final, Native, Public, BlueprintCallable)

void UEventHookComponent::SetOutlineCarryingColorToDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventHookComponent", "SetOutlineCarryingColorToDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingContextWidget.HandleContextButtonClickEvent
// (Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   buttonData                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingContextWidget::HandleContextButtonClickEvent(int32 buttonData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingContextWidget", "HandleContextButtonClickEvent");

	Params::UMGSettingContextWidget_HandleContextButtonClickEvent Parms{};

	Parms.buttonData = buttonData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingContextWidget.SetContextTitle
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      contextTitle                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGSettingContextWidget::SetContextTitle(const class FText& contextTitle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingContextWidget", "SetContextTitle");

	Params::UMGSettingContextWidget_SetContextTitle Parms{};

	Parms.contextTitle = std::move(contextTitle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.EscapeRequirementTracker.OnGameEventDispatched
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UEscapeRequirementTracker::OnGameEventDispatched(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeRequirementTracker", "OnGameEventDispatched");

	Params::EscapeRequirementTracker_OnGameEventDispatched Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AISense_Trail.ReportTrailEvent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          worldContextObj                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              ignoreOnPerkTag                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   lifeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAISense_Trail::ReportTrailEvent(class UObject* worldContextObj, const struct FVector& location, class AActor* instigator, const struct FGameplayTag& ignoreOnPerkTag, float lifeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AISense_Trail", "ReportTrailEvent");

	Params::AISense_Trail_ReportTrailEvent Parms{};

	Parms.worldContextObj = worldContextObj;
	Parms.location = std::move(location);
	Parms.instigator = instigator;
	Parms.ignoreOnPerkTag = std::move(ignoreOnPerkTag);
	Parms.lifeTime = lifeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AISlasherChaseAndAttackBehaviourData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    targetSurvivor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   attackRangeDistance                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   locationDistance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAISlasherChaseAndAttackBehaviourData::Init(class ACamperPlayer* targetSurvivor, float attackRangeDistance, float locationDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AISlasherChaseAndAttackBehaviourData", "Init");

	Params::AISlasherChaseAndAttackBehaviourData_Init Parms{};

	Parms.targetSurvivor = targetSurvivor;
	Parms.attackRangeDistance = attackRangeDistance;
	Parms.locationDistance = locationDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAuthentificationProviderListWidget.HideGuestButton
// (Final, Native, Public, BlueprintCallable)

void UUMGAuthentificationProviderListWidget::HideGuestButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAuthentificationProviderListWidget", "HideGuestButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AISlasherMoveToGrabSurvivorBehaviourData.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    targetSurvivor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAISlasherMoveToGrabSurvivorBehaviourData::Init(class ACamperPlayer* targetSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AISlasherMoveToGrabSurvivorBehaviourData", "Init");

	Params::AISlasherMoveToGrabSurvivorBehaviourData_Init Parms{};

	Parms.targetSurvivor = targetSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutBaseWidget.SetDividerImageColor
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FLinearColor&              color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutBaseWidget::SetDividerImageColor(const struct FLinearColor& color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutBaseWidget", "SetDividerImageColor");

	Params::UMGLoadoutBaseWidget_SetDividerImageColor Parms{};

	Parms.color = std::move(color);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLoadoutBaseWidget.SetIsSelectedLoadoutItemButton
// (Event, Public, BlueprintEvent)
// Parameters:
// ELoadoutSlot                            loadoutSlot                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutBaseWidget::SetIsSelectedLoadoutItemButton(ELoadoutSlot loadoutSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutBaseWidget", "SetIsSelectedLoadoutItemButton");

	Params::UMGLoadoutBaseWidget_SetIsSelectedLoadoutItemButton Parms{};

	Parms.loadoutSlot = loadoutSlot;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLoadoutBaseWidget.SetLoadoutData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FInventorySlotData>&loadoutData                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    usingMatchRules                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    perkSlotsLockedByAdmin                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELoadoutSlot                            loadoutSlot                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isSlasher                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isClickable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutBaseWidget::SetLoadoutData(const TArray<struct FInventorySlotData>& loadoutData, bool usingMatchRules, bool perkSlotsLockedByAdmin, ELoadoutSlot loadoutSlot, bool isSlasher, bool isClickable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutBaseWidget", "SetLoadoutData");

	Params::UMGLoadoutBaseWidget_SetLoadoutData Parms{};

	Parms.loadoutData = std::move(loadoutData);
	Parms.usingMatchRules = usingMatchRules;
	Parms.perkSlotsLockedByAdmin = perkSlotsLockedByAdmin;
	Parms.loadoutSlot = loadoutSlot;
	Parms.isSlasher = isSlasher;
	Parms.isClickable = isClickable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutFilterWidget.ClearSelectedFilter
// (Final, Native, Public, BlueprintCallable)

void UUMGLoadoutFilterWidget::ClearSelectedFilter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutFilterWidget", "ClearSelectedFilter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutFilterWidget.InitFilterWidget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TMap<class FName, TSoftObjectPtr<class UTexture2D>>&filtersInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

void UUMGLoadoutFilterWidget::InitFilterWidget(const TMap<class FName, TSoftObjectPtr<class UTexture2D>>& filtersInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutFilterWidget", "InitFilterWidget");

	Params::UMGLoadoutFilterWidget_InitFilterWidget Parms{};

	Parms.filtersInfo = std::move(filtersInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutFilterWidget.OnFilterButtonClicked
// (Final, Native, Public)
// Parameters:
// class FName                             filterName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutFilterWidget::OnFilterButtonClicked(class FName filterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutFilterWidget", "OnFilterButtonClicked");

	Params::UMGLoadoutFilterWidget_OnFilterButtonClicked Parms{};

	Parms.filterName = filterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AlertsScreen.RewardAlertSequenceCompleted
// (Final, Native, Private, Const)

void UAlertsScreen::RewardAlertSequenceCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AlertsScreen", "RewardAlertSequenceCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DedicatedServerHandlerComponent.OnGameEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDedicatedServerHandlerComponent::OnGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DedicatedServerHandlerComponent", "OnGameEvent");

	Params::DedicatedServerHandlerComponent_OnGameEvent Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DedicatedServerHandlerComponent.ReceiveGameEvent
// (Final, Native, Public)
// Parameters:
// EDBDScoreTypes                          scoreType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDedicatedServerHandlerComponent::ReceiveGameEvent(EDBDScoreTypes scoreType, float amount, class AActor* instigator, class AActor* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DedicatedServerHandlerComponent", "ReceiveGameEvent");

	Params::DedicatedServerHandlerComponent_ReceiveGameEvent Parms{};

	Parms.scoreType = scoreType;
	Parms.amount = amount;
	Parms.instigator = instigator;
	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationFollowerActor.Cosmetic_OnMontageStarted
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AAnimationFollowerActor::Cosmetic_OnMontageStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "Cosmetic_OnMontageStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.AnimationFollowerActor.Cosmetic_OnMontageStopped
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AAnimationFollowerActor::Cosmetic_OnMontageStopped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "Cosmetic_OnMontageStopped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.AnimationFollowerActor.NativeOnMontageEnded
// (Native, Protected)
// Parameters:
// const struct FAnimationMontageDescriptor&montage                                                (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                                    interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAnimationFollowerActor::NativeOnMontageEnded(const struct FAnimationMontageDescriptor& montage, bool interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "NativeOnMontageEnded");

	Params::AnimationFollowerActor_NativeOnMontageEnded Parms{};

	Parms.montage = std::move(montage);
	Parms.interrupted = interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationFollowerActor.NativeOnMontageStarted
// (Native, Protected)
// Parameters:
// const struct FAnimationMontageDescriptor&id                                                     (ConstParm, Parm, NativeAccessSpecifierPublic)
// const float                             rate                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAnimationFollowerActor::NativeOnMontageStarted(const struct FAnimationMontageDescriptor& id, const float rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "NativeOnMontageStarted");

	Params::AnimationFollowerActor_NativeOnMontageStarted Parms{};

	Parms.id = std::move(id);
	Parms.rate = rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationFollowerActor.NativeOnMontageStopped
// (Native, Protected)
// Parameters:
// const struct FAnimationMontageDescriptor&id                                                     (ConstParm, Parm, NativeAccessSpecifierPublic)

void AAnimationFollowerActor::NativeOnMontageStopped(const struct FAnimationMontageDescriptor& id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "NativeOnMontageStopped");

	Params::AnimationFollowerActor_NativeOnMontageStopped Parms{};

	Parms.id = std::move(id);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationFollowerActor.OnMontageEnd
// (Final, Native, Private)
// Parameters:
// const struct FAnimationMontageDescriptor&montage                                                (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                                    interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAnimationFollowerActor::OnMontageEnd(const struct FAnimationMontageDescriptor& montage, bool interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "OnMontageEnd");

	Params::AnimationFollowerActor_OnMontageEnd Parms{};

	Parms.montage = std::move(montage);
	Parms.interrupted = interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationFollowerActor.OnMontageStarted
// (Final, Native, Private)
// Parameters:
// const struct FAnimationMontageDescriptor&id                                                     (ConstParm, Parm, NativeAccessSpecifierPublic)
// const float                             rate                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAnimationFollowerActor::OnMontageStarted(const struct FAnimationMontageDescriptor& id, const float rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "OnMontageStarted");

	Params::AnimationFollowerActor_OnMontageStarted Parms{};

	Parms.id = std::move(id);
	Parms.rate = rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationFollowerActor.OnMontageStopped
// (Final, Native, Private)
// Parameters:
// const struct FAnimationMontageDescriptor&id                                                     (ConstParm, Parm, NativeAccessSpecifierPublic)

void AAnimationFollowerActor::OnMontageStopped(const struct FAnimationMontageDescriptor& id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationFollowerActor", "OnMontageStopped");

	Params::AnimationFollowerActor_OnMontageStopped Parms{};

	Parms.id = std::move(id);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialFunctionLibrary.GetTutorialGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATutorialGameMode*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATutorialGameMode* UTutorialFunctionLibrary::GetTutorialGameMode(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialFunctionLibrary", "GetTutorialGameMode");

	Params::TutorialFunctionLibrary_GetTutorialGameMode Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialFunctionLibrary.GetTutorialGameState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATutorialGameState*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATutorialGameState* UTutorialFunctionLibrary::GetTutorialGameState(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialFunctionLibrary", "GetTutorialGameState");

	Params::TutorialFunctionLibrary_GetTutorialGameState Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialFunctionLibrary.GetTutorialHighlightController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTutorialHighlightController*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTutorialHighlightController* UTutorialFunctionLibrary::GetTutorialHighlightController(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialFunctionLibrary", "GetTutorialHighlightController");

	Params::TutorialFunctionLibrary_GetTutorialHighlightController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialFunctionLibrary.GetTutorialNotificationController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTutorialNotificationController*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTutorialNotificationController* UTutorialFunctionLibrary::GetTutorialNotificationController(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialFunctionLibrary", "GetTutorialNotificationController");

	Params::TutorialFunctionLibrary_GetTutorialNotificationController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialFunctionLibrary.GetTutorialObjectiveController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTutorialObjectiveController*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTutorialObjectiveController* UTutorialFunctionLibrary::GetTutorialObjectiveController(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialFunctionLibrary", "GetTutorialObjectiveController");

	Params::TutorialFunctionLibrary_GetTutorialObjectiveController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialFunctionLibrary.IsInTutorial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTutorialFunctionLibrary::IsInTutorial(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialFunctionLibrary", "IsInTutorial");

	Params::TutorialFunctionLibrary_IsInTutorial Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AnimationMontageSlave.OnMontageStarted
// (Final, Native, Private)
// Parameters:
// const struct FAnimationMontageDescriptor&id                                                     (ConstParm, Parm, NativeAccessSpecifierPublic)
// const float                             rate                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationMontageSlave::OnMontageStarted(const struct FAnimationMontageDescriptor& id, const float rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationMontageSlave", "OnMontageStarted");

	Params::AnimationMontageSlave_OnMontageStarted Parms{};

	Parms.id = std::move(id);
	Parms.rate = rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationMontageSlave.OnMontageStopped
// (Final, Native, Private)
// Parameters:
// const struct FAnimationMontageDescriptor&id                                                     (ConstParm, Parm, NativeAccessSpecifierPublic)

void UAnimationMontageSlave::OnMontageStopped(const struct FAnimationMontageDescriptor& id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationMontageSlave", "OnMontageStopped");

	Params::AnimationMontageSlave_OnMontageStopped Parms{};

	Parms.id = std::move(id);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationMontageSlave.SetLeader
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMontagePlayer*                   leader                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationMontageSlave::SetLeader(class UMontagePlayer* leader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationMontageSlave", "SetLeader");

	Params::AnimationMontageSlave_SetLeader Parms{};

	Parms.leader = leader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreWidget.PurchaseSelectedNode
// (Final, Native, Private)

void UUMGBloodStoreWidget::PurchaseSelectedNode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreWidget", "PurchaseSelectedNode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreWidget.RegenerateBloodStore
// (Final, Native, Private)

void UUMGBloodStoreWidget::RegenerateBloodStore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreWidget", "RegenerateBloodStore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreWidget.SetFaction
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isKiller                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBloodStoreWidget::SetFaction(bool isKiller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreWidget", "SetFaction");

	Params::UMGBloodStoreWidget_SetFaction Parms{};

	Parms.isKiller = isKiller;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGBloodStoreWidget.SetSelectedNode
// (Final, Native, Private)
// Parameters:
// const class FString&                    selectedId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBloodStoreWidget::SetSelectedNode(const class FString& selectedId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreWidget", "SetSelectedNode");

	Params::UMGBloodStoreWidget_SetSelectedNode Parms{};

	Parms.selectedId = std::move(selectedId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreWidget.SwitchRole
// (Final, Native, Private)

void UUMGBloodStoreWidget::SwitchRole()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreWidget", "SwitchRole");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreWidget.UnselectNode
// (Final, Native, Private)

void UUMGBloodStoreWidget::UnselectNode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreWidget", "UnselectNode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DiscordancePerk.Multicast_AddGeneratorAura
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class AGenerator*                       generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiscordancePerk::Multicast_AddGeneratorAura(class AGenerator* generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiscordancePerk", "Multicast_AddGeneratorAura");

	Params::DiscordancePerk_Multicast_AddGeneratorAura Parms{};

	Parms.generator = generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DiscordancePerk.Multicast_AddLingeringGeneratorAura
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class AGenerator*                       generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDiscordancePerk::Multicast_AddLingeringGeneratorAura(class AGenerator* generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DiscordancePerk", "Multicast_AddLingeringGeneratorAura");

	Params::DiscordancePerk_Multicast_AddLingeringGeneratorAura Parms{};

	Parms.generator = generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DestroyBreakableDefinition.GetBreakable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABreakableBase*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABreakableBase* UDestroyBreakableDefinition::GetBreakable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DestroyBreakableDefinition", "GetBreakable");

	Params::DestroyBreakableDefinition_GetBreakable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SectionnedChargeableComponent.GetSectionChargeRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USectionnedChargeableComponent::GetSectionChargeRemaining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SectionnedChargeableComponent", "GetSectionChargeRemaining");

	Params::SectionnedChargeableComponent_GetSectionChargeRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DecalSpawner.GetSpawnerStrategy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USpawnerStrategy*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USpawnerStrategy* UDecalSpawner::GetSpawnerStrategy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecalSpawner", "GetSpawnerStrategy");

	Params::DecalSpawner_GetSpawnerStrategy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DirectionalMinigameComponent.Authority_StartMinigameForSurvivor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalMinigameComponent::Authority_StartMinigameForSurvivor(class ACamperPlayer* survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionalMinigameComponent", "Authority_StartMinigameForSurvivor");

	Params::DirectionalMinigameComponent_Authority_StartMinigameForSurvivor Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DirectionalMinigameComponent.OnRep_IsInProgress
// (Final, Native, Private)

void UDirectionalMinigameComponent::OnRep_IsInProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionalMinigameComponent", "OnRep_IsInProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DirectionalMinigameComponent.Server_CancelMinigame
// (Net, NetReliable, Native, Event, Public, NetServer)

void UDirectionalMinigameComponent::Server_CancelMinigame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionalMinigameComponent", "Server_CancelMinigame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DirectionalMinigameComponent.Server_EnterKey
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// EDirectionalInputKey                    enteredKey                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionalMinigameComponent::Server_EnterKey(EDirectionalInputKey enteredKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionalMinigameComponent", "Server_EnterKey");

	Params::DirectionalMinigameComponent_Server_EnterKey Parms{};

	Parms.enteredKey = enteredKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GenericPopupScreen.OnChoiceSelected
// (Final, Native, Private)
// Parameters:
// int32                                   selectedButtonType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGenericPopupScreen::OnChoiceSelected(int32 selectedButtonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenericPopupScreen", "OnChoiceSelected");

	Params::GenericPopupScreen_OnChoiceSelected Parms{};

	Parms.selectedButtonType = selectedButtonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterPrice.SetCurrencyData
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FPurchaseCurrencyData&     currencyData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGCharacterPrice::SetCurrencyData(const struct FPurchaseCurrencyData& currencyData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterPrice", "SetCurrencyData");

	Params::UMGCharacterPrice_SetCurrencyData Parms{};

	Parms.currencyData = std::move(currencyData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ArchiveTierPurchasePopupScreen.OnConfirmPurchase
// (Final, Native, Private)
// Parameters:
// int32                                   tiersToPurchaseNumber                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArchiveTierPurchasePopupScreen::OnConfirmPurchase(int32 tiersToPurchaseNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArchiveTierPurchasePopupScreen", "OnConfirmPurchase");

	Params::ArchiveTierPurchasePopupScreen_OnConfirmPurchase Parms{};

	Parms.tiersToPurchaseNumber = tiersToPurchaseNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OfferingSequenceManager.FadeInScreen
// (Final, Native, Private)

void AOfferingSequenceManager::FadeInScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceManager", "FadeInScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OfferingSequenceManager.HandleSequenceEnded
// (Event, Protected, BlueprintEvent)

void AOfferingSequenceManager::HandleSequenceEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceManager", "HandleSequenceEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.OfferingSequenceManager.HandleSequenceStarted
// (Event, Protected, BlueprintEvent)

void AOfferingSequenceManager::HandleSequenceStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceManager", "HandleSequenceStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.OfferingSequenceManager.HandleSequenceStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EOfferingSequenceState                  state                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOfferingSequenceManager::HandleSequenceStateChanged(EOfferingSequenceState state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceManager", "HandleSequenceStateChanged");

	Params::OfferingSequenceManager_HandleSequenceStateChanged Parms{};

	Parms.state = state;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.OfferingSequenceManager.ContainsDefaultCard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOfferingSequenceManager::ContainsDefaultCard() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceManager", "ContainsDefaultCard");

	Params::OfferingSequenceManager_ContainsDefaultCard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingSequenceManager.ContainsEventCard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOfferingSequenceManager::ContainsEventCard() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceManager", "ContainsEventCard");

	Params::OfferingSequenceManager_ContainsEventCard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingSequenceManager.GetCurrentState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOfferingSequenceState                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOfferingSequenceState AOfferingSequenceManager::GetCurrentState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceManager", "GetCurrentState");

	Params::OfferingSequenceManager_GetCurrentState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ArchiveWidgetScreen.OnQuestsButtonClick
// (Final, Native, Private)

void UArchiveWidgetScreen::OnQuestsButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArchiveWidgetScreen", "OnQuestsButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ArchiveWidgetScreen.OnRewardsButtonClick
// (Final, Native, Private)

void UArchiveWidgetScreen::OnRewardsButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArchiveWidgetScreen", "OnRewardsButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacementValidationWithRestrictionStrategy.OnLevelReadyToPlay
// (Native, Protected)

void UObjectPlacementValidationWithRestrictionStrategy::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacementValidationWithRestrictionStrategy", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaCustomGameUtilities.IsCustomGameEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaCustomGameUtilities::IsCustomGameEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaCustomGameUtilities", "IsCustomGameEnabled");

	Params::AtlantaCustomGameUtilities_IsCustomGameEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaCustomGameUtilities.IsInCustomGameLobby
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UDBDGameInstance*           gameInstance                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaCustomGameUtilities::IsInCustomGameLobby(const class UDBDGameInstance* gameInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaCustomGameUtilities", "IsInCustomGameLobby");

	Params::AtlantaCustomGameUtilities_IsInCustomGameLobby Parms{};

	Parms.gameInstance = gameInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DisplayStandItemRequesterComponent.LoadItemsOnCharacter
// (Final, Native, Private)
// Parameters:
// class AActor*                           actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisplayStandItemRequesterComponent::LoadItemsOnCharacter(class AActor* actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisplayStandItemRequesterComponent", "LoadItemsOnCharacter");

	Params::DisplayStandItemRequesterComponent_LoadItemsOnCharacter Parms{};

	Parms.actor = actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OfferingUtilities.HasItemLossProtection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOfferingUtilities::HasItemLossProtection(const class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OfferingUtilities", "HasItemLossProtection");

	Params::OfferingUtilities_HasItemLossProtection Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingUtilities.HasOfferingOfType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOfferingEffectType                     offeringEffectType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   playerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOfferingUtilities::HasOfferingOfType(const class UObject* worldContextObject, EOfferingEffectType offeringEffectType, int32 playerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OfferingUtilities", "HasOfferingOfType");

	Params::OfferingUtilities_HasOfferingOfType Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.offeringEffectType = offeringEffectType;
	Parms.playerId = playerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingUtilities.IsPlayerEquippedWithOfferingWithTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       offeringTag                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOfferingUtilities::IsPlayerEquippedWithOfferingWithTag(const class ADBDPlayer* player, const class FName offeringTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OfferingUtilities", "IsPlayerEquippedWithOfferingWithTag");

	Params::OfferingUtilities_IsPlayerEquippedWithOfferingWithTag Parms{};

	Parms.player = player;
	Parms.offeringTag = offeringTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialLevel.AddObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             objectiveId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::AddObjective(class FName objectiveId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "AddObjective");

	Params::TutorialLevel_AddObjective Parms{};

	Parms.objectiveId = objectiveId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.CompleteObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             objectiveId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::CompleteObjective(class FName objectiveId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "CompleteObjective");

	Params::TutorialLevel_CompleteObjective Parms{};

	Parms.objectiveId = objectiveId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.DisplayBlockingNotification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             notificationId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::DisplayBlockingNotification(class FName notificationId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "DisplayBlockingNotification");

	Params::TutorialLevel_DisplayBlockingNotification Parms{};

	Parms.notificationId = notificationId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.DisplayNotification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             notificationId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::DisplayNotification(class FName notificationId, float time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "DisplayNotification");

	Params::TutorialLevel_DisplayNotification Parms{};

	Parms.notificationId = notificationId;
	Parms.time = time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.HandleNotificationDismissed
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FName                             notificationId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::HandleNotificationDismissed(class FName notificationId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "HandleNotificationDismissed");

	Params::TutorialLevel_HandleNotificationDismissed Parms{};

	Parms.notificationId = notificationId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.TutorialLevel.HandleTutorialStepReached
// (Event, Protected, BlueprintEvent)

void ATutorialLevel::HandleTutorialStepReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "HandleTutorialStepReached");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.TutorialLevel.OnNotificationDismissed
// (Final, Native, Protected)
// Parameters:
// class FName                             notificationId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::OnNotificationDismissed(class FName notificationId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "OnNotificationDismissed");

	Params::TutorialLevel_OnNotificationDismissed Parms{};

	Parms.notificationId = notificationId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.OnTutorialStepUpdated
// (Final, Native, Protected)
// Parameters:
// ETutorialStep                           tutorialStep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::OnTutorialStepUpdated(ETutorialStep tutorialStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "OnTutorialStepUpdated");

	Params::TutorialLevel_OnTutorialStepUpdated Parms{};

	Parms.tutorialStep = tutorialStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.RemoveObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             objectiveId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::RemoveObjective(class FName objectiveId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "RemoveObjective");

	Params::TutorialLevel_RemoveObjective Parms{};

	Parms.objectiveId = objectiveId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.SetHandledTutorialStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETutorialStep                           tutorialStep                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialLevel::SetHandledTutorialStep(ETutorialStep tutorialStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "SetHandledTutorialStep");

	Params::TutorialLevel_SetHandledTutorialStep Parms{};

	Parms.tutorialStep = tutorialStep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialLevel.StartTutorial
// (Native, Public, BlueprintCallable)

void ATutorialLevel::StartTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialLevel", "StartTutorial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaTutorialLevel.HandleCanStartTutorialChanged
// (Final, Native, Private)
// Parameters:
// bool                                    canStartTutorial                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAtlantaTutorialLevel::HandleCanStartTutorialChanged(bool canStartTutorial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialLevel", "HandleCanStartTutorialChanged");

	Params::AtlantaTutorialLevel_HandleCanStartTutorialChanged Parms{};

	Parms.canStartTutorial = canStartTutorial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaTutorialLevel.IsActorInLineOfSight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDAIPlayerController*           aiPlayerController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                playerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAtlantaTutorialLevel::IsActorInLineOfSight(class ADBDAIPlayerController* aiPlayerController, class APlayerController* playerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialLevel", "IsActorInLineOfSight");

	Params::AtlantaTutorialLevel_IsActorInLineOfSight Parms{};

	Parms.aiPlayerController = aiPlayerController;
	Parms.playerController = playerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaTutorialLevel.OnTriggerBeginOverlapActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    triggerID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           overlappingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAtlantaTutorialLevel::OnTriggerBeginOverlapActor(const class FString& triggerID, class AActor* overlappingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialLevel", "OnTriggerBeginOverlapActor");

	Params::AtlantaTutorialLevel_OnTriggerBeginOverlapActor Parms{};

	Parms.triggerID = std::move(triggerID);
	Parms.overlappingActor = overlappingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaTutorialLevel.OnTutorialStarted
// (Event, Public, BlueprintEvent)

void AAtlantaTutorialLevel::OnTutorialStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialLevel", "OnTutorialStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.AtlantaTutorialLevel.SetAIEscapePoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            escapePoints                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void AAtlantaTutorialLevel::SetAIEscapePoints(const TArray<class AActor*>& escapePoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialLevel", "SetAIEscapePoints");

	Params::AtlantaTutorialLevel_SetAIEscapePoints Parms{};

	Parms.escapePoints = std::move(escapePoints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaTutorialLevel.SetLocallyControlledPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       locallyControllerPlayer                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAtlantaTutorialLevel::SetLocallyControlledPlayer(class ADBDPlayer* locallyControllerPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialLevel", "SetLocallyControlledPlayer");

	Params::AtlantaTutorialLevel_SetLocallyControlledPlayer Parms{};

	Parms.locallyControllerPlayer = locallyControllerPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaTutorialLevel.SetTutorialElement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    elementKey                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           elementToSet                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAtlantaTutorialLevel::SetTutorialElement(const class FString& elementKey, class AActor* elementToSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialLevel", "SetTutorialElement");

	Params::AtlantaTutorialLevel_SetTutorialElement Parms{};

	Parms.elementKey = std::move(elementKey);
	Parms.elementToSet = elementToSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaTutorialLevel.SetTutorialElements
// (Event, Public, BlueprintEvent)

void AAtlantaTutorialLevel::SetTutorialElements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialLevel", "SetTutorialElements");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.AtlantaTutorialLevel.StartCameraFadeIn
// (Final, Native, Public, BlueprintCallable)

void AAtlantaTutorialLevel::StartCameraFadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialLevel", "StartCameraFadeIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaTutorialLevel.GetTutorialElement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    elementKey                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AAtlantaTutorialLevel::GetTutorialElement(const class FString& elementKey) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialLevel", "GetTutorialElement");

	Params::AtlantaTutorialLevel_GetTutorialElement Parms{};

	Parms.elementKey = std::move(elementKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorAtlantaTutorialLevel.SetSlasherPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASlasherPlayer*                   slasherPlayer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASurvivorAtlantaTutorialLevel::SetSlasherPlayer(class ASlasherPlayer* slasherPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorAtlantaTutorialLevel", "SetSlasherPlayer");

	Params::SurvivorAtlantaTutorialLevel_SetSlasherPlayer Parms{};

	Parms.slasherPlayer = slasherPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorAtlantaTutorialLevel.GetCamperPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACamperPlayer*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACamperPlayer* ASurvivorAtlantaTutorialLevel::GetCamperPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorAtlantaTutorialLevel", "GetCamperPlayer");

	Params::SurvivorAtlantaTutorialLevel_GetCamperPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorAtlantaTutorialLevel.GetSlasherAIPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDAIPlayerController*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDAIPlayerController* ASurvivorAtlantaTutorialLevel::GetSlasherAIPlayerController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorAtlantaTutorialLevel", "GetSlasherAIPlayerController");

	Params::SurvivorAtlantaTutorialLevel_GetSlasherAIPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorAtlantaTutorialLevel.GetSlasherPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASlasherPlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASlasherPlayer* ASurvivorAtlantaTutorialLevel::GetSlasherPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorAtlantaTutorialLevel", "GetSlasherPlayer");

	Params::SurvivorAtlantaTutorialLevel_GetSlasherPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DisplayStand.BlockRotation
// (Final, Native, Public)
// Parameters:
// bool                                    shouldBlockRotation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADisplayStand::BlockRotation(bool shouldBlockRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisplayStand", "BlockRotation");

	Params::DisplayStand_BlockRotation Parms{};

	Parms.shouldBlockRotation = shouldBlockRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DisplayStand.OnCurrentActorDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           destroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADisplayStand::OnCurrentActorDestroyed(class AActor* destroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisplayStand", "OnCurrentActorDestroyed");

	Params::DisplayStand_OnCurrentActorDestroyed Parms{};

	Parms.destroyedActor = destroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaHudDirectionalStick.SetMovementLockAnimationStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaHudDirectionalStick::SetMovementLockAnimationStatus(bool value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaHudDirectionalStick", "SetMovementLockAnimationStatus");

	Params::AtlantaHudDirectionalStick_SetMovementLockAnimationStatus Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBaseRootStorefrontWidget.OnBackButtonPressed
// (Final, Native, Protected)

void UUMGBaseRootStorefrontWidget::OnBackButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBaseRootStorefrontWidget", "OnBackButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBaseRootStorefrontWidget.OnCurrencyButtonLongPressed
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FTooltipPressedData&       tooltipPressedData                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const ECurrencyType                     currencyType                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBaseRootStorefrontWidget::OnCurrencyButtonLongPressed(const struct FTooltipPressedData& tooltipPressedData, const ECurrencyType currencyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBaseRootStorefrontWidget", "OnCurrencyButtonLongPressed");

	Params::UMGBaseRootStorefrontWidget_OnCurrencyButtonLongPressed Parms{};

	Parms.tooltipPressedData = std::move(tooltipPressedData);
	Parms.currencyType = currencyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBaseRootStorefrontWidget.OnPurchaseAuricCellButtonPressed
// (Final, Native, Protected)

void UUMGBaseRootStorefrontWidget::OnPurchaseAuricCellButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBaseRootStorefrontWidget", "OnPurchaseAuricCellButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.VaultableOutlineUpdateStrategy.SetCanBeRevealedToLocalPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    canBeRevealedToLocalPlayer                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVaultableOutlineUpdateStrategy::SetCanBeRevealedToLocalPlayer(bool canBeRevealedToLocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultableOutlineUpdateStrategy", "SetCanBeRevealedToLocalPlayer");

	Params::VaultableOutlineUpdateStrategy_SetCanBeRevealedToLocalPlayer Parms{};

	Parms.canBeRevealedToLocalPlayer = canBeRevealedToLocalPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DreamPalletOutlineUpdateStrategy.InitializeTunableValues
// (Final, Native, Protected)
// Parameters:
// class ASlasherPlayer*                   killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDreamPalletOutlineUpdateStrategy::InitializeTunableValues(class ASlasherPlayer* killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DreamPalletOutlineUpdateStrategy", "InitializeTunableValues");

	Params::DreamPalletOutlineUpdateStrategy_InitializeTunableValues Parms{};

	Parms.killer = killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LobbyLevel.OnAdditionalSubLevelsLoaded
// (Final, Native, Private)

void ALobbyLevel::OnAdditionalSubLevelsLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevel", "OnAdditionalSubLevelsLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LobbyLevel.OnLobbySubLevelLoaded
// (Final, Native, Private)

void ALobbyLevel::OnLobbySubLevelLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevel", "OnLobbySubLevelLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LobbyLevel.OnShopSubLevelLoaded
// (Final, Native, Private)

void ALobbyLevel::OnShopSubLevelLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevel", "OnShopSubLevelLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.VaultableComponent.OnChaseEnded
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   chaseTimer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVaultableComponent::OnChaseEnded(class ADBDPlayer* survivor, float chaseTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultableComponent", "OnChaseEnded");

	Params::VaultableComponent_OnChaseEnded Parms{};

	Parms.survivor = survivor;
	Parms.chaseTimer = chaseTimer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.VaultableComponent.SignalVault
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   interactionTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVaultableComponent::SignalVault(class ADBDPlayer* survivor, float interactionTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultableComponent", "SignalVault");

	Params::VaultableComponent_SignalVault Parms{};

	Parms.survivor = survivor;
	Parms.interactionTime = interactionTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaLobbyLevel.OnBackPawnSpawned
// (Final, Native, Private)
// Parameters:
// class AActor*                           backgroundPawn                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAtlantaLobbyLevel::OnBackPawnSpawned(class AActor* backgroundPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaLobbyLevel", "OnBackPawnSpawned");

	Params::AtlantaLobbyLevel_OnBackPawnSpawned Parms{};

	Parms.backgroundPawn = backgroundPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaLobbyLevel.OnFrontPawnSpawned
// (Final, Native, Private)
// Parameters:
// class AActor*                           forefrontPawn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAtlantaLobbyLevel::OnFrontPawnSpawned(class AActor* forefrontPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaLobbyLevel", "OnFrontPawnSpawned");

	Params::AtlantaLobbyLevel_OnFrontPawnSpawned Parms{};

	Parms.forefrontPawn = forefrontPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaOfflineLobbyCamera.SetCameraPosition
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   positionVector                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAtlantaOfflineLobbyCamera::SetCameraPosition(const struct FVector& positionVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaOfflineLobbyCamera", "SetCameraPosition");

	Params::AtlantaOfflineLobbyCamera_SetCameraPosition Parms{};

	Parms.positionVector = std::move(positionVector);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.AtlantaOfflineLobbyCamera.SetCameraRotation
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FRotator&                  rotationVector                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AAtlantaOfflineLobbyCamera::SetCameraRotation(const struct FRotator& rotationVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaOfflineLobbyCamera", "SetCameraRotation");

	Params::AtlantaOfflineLobbyCamera_SetCameraRotation Parms{};

	Parms.rotationVector = std::move(rotationVector);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.EndGameStateComponent.Multicast_SetIsInEndGameSimulation
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, NetValidate)
// Parameters:
// bool                                    endGameSimulation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEndGameStateComponent::Multicast_SetIsInEndGameSimulation(bool endGameSimulation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "Multicast_SetIsInEndGameSimulation");

	Params::EndGameStateComponent_Multicast_SetIsInEndGameSimulation Parms{};

	Parms.endGameSimulation = endGameSimulation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameStateComponent.OnRep_IsEndGameOver
// (Final, Native, Private)

void UEndGameStateComponent::OnRep_IsEndGameOver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "OnRep_IsEndGameOver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameStateComponent.OnRep_IsTimerPaused
// (Final, Native, Private)

void UEndGameStateComponent::OnRep_IsTimerPaused()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "OnRep_IsTimerPaused");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameStateComponent.OnRep_TimeDilation
// (Final, Native, Private)

void UEndGameStateComponent::OnRep_TimeDilation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "OnRep_TimeDilation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameStateComponent.OnRep_WorldTimeAtLastDilationModification
// (Final, Native, Private)

void UEndGameStateComponent::OnRep_WorldTimeAtLastDilationModification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "OnRep_WorldTimeAtLastDilationModification");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameStateComponent.GetElapsedTimePercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEndGameStateComponent::GetElapsedTimePercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "GetElapsedTimePercent");

	Params::EndGameStateComponent_GetElapsedTimePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EndGameStateComponent.HasEndGameBegun
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEndGameStateComponent::HasEndGameBegun() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "HasEndGameBegun");

	Params::EndGameStateComponent_HasEndGameBegun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EndGameStateComponent.IsEndGameOver
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEndGameStateComponent::IsEndGameOver() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "IsEndGameOver");

	Params::EndGameStateComponent_IsEndGameOver Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EndGameStateComponent.IsTimerSlowedDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEndGameStateComponent::IsTimerSlowedDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameStateComponent", "IsTimerSlowedDown");

	Params::EndGameStateComponent_IsTimerSlowedDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaPartyFlowUtilities.IsCurrentPlayerAloneInParty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaPartyFlowUtilities::IsCurrentPlayerAloneInParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaPartyFlowUtilities", "IsCurrentPlayerAloneInParty");

	Params::AtlantaPartyFlowUtilities_IsCurrentPlayerAloneInParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaPartyFlowUtilities.IsCurrentPlayerInParty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaPartyFlowUtilities::IsCurrentPlayerInParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaPartyFlowUtilities", "IsCurrentPlayerInParty");

	Params::AtlantaPartyFlowUtilities_IsCurrentPlayerInParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaInstalledContent.GetFreeDiskSpace
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAtlantaInstalledContent::GetFreeDiskSpace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaInstalledContent", "GetFreeDiskSpace");

	Params::AtlantaInstalledContent_GetFreeDiskSpace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaInstalledContent.GetInstalledContentSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAtlantaInstalledContent::GetInstalledContentSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaInstalledContent", "GetInstalledContentSize");

	Params::AtlantaInstalledContent_GetInstalledContentSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaInstalledContent.Mount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PakOrder                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    MountPoint                                             (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaInstalledContent::Mount(int32 PakOrder, const class FString& MountPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaInstalledContent", "Mount");

	Params::AtlantaInstalledContent_Mount Parms{};

	Parms.PakOrder = PakOrder;
	Parms.MountPoint = std::move(MountPoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoorAnimInstance.PlaySound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    akEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEscapeDoorAnimInstance::PlaySound(class UAkAudioEvent* akEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoorAnimInstance", "PlaySound");

	Params::EscapeDoorAnimInstance_PlaySound Parms{};

	Parms.akEvent = akEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoorAnimInstance.SetIsOpen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isOpen                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEscapeDoorAnimInstance::SetIsOpen(bool isOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoorAnimInstance", "SetIsOpen");

	Params::EscapeDoorAnimInstance_SetIsOpen Parms{};

	Parms.isOpen = isOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoorAnimInstance.SetIsOpenByKiller
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              isOpenByKiller                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEscapeDoorAnimInstance::SetIsOpenByKiller(const bool isOpenByKiller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoorAnimInstance", "SetIsOpenByKiller");

	Params::EscapeDoorAnimInstance_SetIsOpenByKiller Parms{};

	Parms.isOpenByKiller = isOpenByKiller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.AttachSurvivor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::AttachSurvivor(class ACamperPlayer* survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "AttachSurvivor");

	Params::ReverseBearTrap_AttachSurvivor Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.Authority_GenerateAttemptsNeeded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             remainingAttemptsTotal                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             remainingRBTs                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             numRemovers                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::Authority_GenerateAttemptsNeeded(const int32 remainingAttemptsTotal, const int32 remainingRBTs, const int32 numRemovers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "Authority_GenerateAttemptsNeeded");

	Params::ReverseBearTrap_Authority_GenerateAttemptsNeeded Parms{};

	Parms.remainingAttemptsTotal = remainingAttemptsTotal;
	Parms.remainingRBTs = remainingRBTs;
	Parms.numRemovers = numRemovers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.Authority_SetKeyID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   keyID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::Authority_SetKeyID(int32 keyID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "Authority_SetKeyID");

	Params::ReverseBearTrap_Authority_SetKeyID Parms{};

	Parms.keyID = keyID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.DetachSurvivor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::DetachSurvivor(class ACamperPlayer* survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "DetachSurvivor");

	Params::ReverseBearTrap_DetachSurvivor Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.FastForwardExecutionTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   deltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::FastForwardExecutionTimer(float deltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "FastForwardExecutionTimer");

	Params::ReverseBearTrap_FastForwardExecutionTimer Parms{};

	Parms.deltaTime = deltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.IncrementAttemptsMade
// (Final, Native, Public, BlueprintCallable)

void AReverseBearTrap::IncrementAttemptsMade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "IncrementAttemptsMade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.NotifyDetachStarted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::NotifyDetachStarted(class ACamperPlayer* survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "NotifyDetachStarted");

	Params::ReverseBearTrap_NotifyDetachStarted Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.NotifyOnAttachSurvivorBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::NotifyOnAttachSurvivorBegin(class ACamperPlayer* survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "NotifyOnAttachSurvivorBegin");

	Params::ReverseBearTrap_NotifyOnAttachSurvivorBegin Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.OnAttachSurvivor
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::OnAttachSurvivor(class ACamperPlayer* survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "OnAttachSurvivor");

	Params::ReverseBearTrap_OnAttachSurvivor Parms{};

	Parms.survivor = survivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ReverseBearTrap.OnAttachSurvivorBegin
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::OnAttachSurvivorBegin(class ACamperPlayer* survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "OnAttachSurvivorBegin");

	Params::ReverseBearTrap_OnAttachSurvivorBegin Parms{};

	Parms.survivor = survivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ReverseBearTrap.OnDetachSurvivor
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::OnDetachSurvivor(class ACamperPlayer* survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "OnDetachSurvivor");

	Params::ReverseBearTrap_OnDetachSurvivor Parms{};

	Parms.survivor = survivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ReverseBearTrap.OnEnterWarningZone
// (Final, Native, Public, BlueprintCallable)

void AReverseBearTrap::OnEnterWarningZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "OnEnterWarningZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.OnExitWarningZone
// (Final, Native, Public, BlueprintCallable)

void AReverseBearTrap::OnExitWarningZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "OnExitWarningZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.OnGeneratorComplete
// (Final, Native, Private)
// Parameters:
// int32                                   activatedGeneratorCount                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::OnGeneratorComplete(int32 activatedGeneratorCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "OnGeneratorComplete");

	Params::ReverseBearTrap_OnGeneratorComplete Parms{};

	Parms.activatedGeneratorCount = activatedGeneratorCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.OnWarningLevelChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   previousWarningLevel                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   currentWarningLevel                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::OnWarningLevelChanged(int32 previousWarningLevel, int32 currentWarningLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "OnWarningLevelChanged");

	Params::ReverseBearTrap_OnWarningLevelChanged Parms{};

	Parms.previousWarningLevel = previousWarningLevel;
	Parms.currentWarningLevel = currentWarningLevel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ReverseBearTrap.ResetExecutionTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::ResetExecutionTimer(float time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "ResetExecutionTimer");

	Params::ReverseBearTrap_ResetExecutionTimer Parms{};

	Parms.time = time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.SetGateClosedAtAttachment
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    closed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::SetGateClosedAtAttachment(bool closed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "SetGateClosedAtAttachment");

	Params::ReverseBearTrap_SetGateClosedAtAttachment Parms{};

	Parms.closed = closed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.SetVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrap::SetVisible(bool visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "SetVisible");

	Params::ReverseBearTrap_SetVisible Parms{};

	Parms.visible = visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.StopExecutionTimer
// (Final, Native, Public, BlueprintCallable)

void AReverseBearTrap::StopExecutionTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "StopExecutionTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.StopMontage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AReverseBearTrap::StopMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "StopMontage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrap.CanExecute
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::CanExecute() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "CanExecute");

	Params::ReverseBearTrap_CanExecute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetAttachedSurvivor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACamperPlayer*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACamperPlayer* AReverseBearTrap::GetAttachedSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetAttachedSurvivor");

	Params::ReverseBearTrap_GetAttachedSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetAttemptsMade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AReverseBearTrap::GetAttemptsMade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetAttemptsMade");

	Params::ReverseBearTrap_GetAttemptsMade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetAttemptsNeeded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AReverseBearTrap::GetAttemptsNeeded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetAttemptsNeeded");

	Params::ReverseBearTrap_GetAttemptsNeeded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetExecutionTimerPercentTimeElapsed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AReverseBearTrap::GetExecutionTimerPercentTimeElapsed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetExecutionTimerPercentTimeElapsed");

	Params::ReverseBearTrap_GetExecutionTimerPercentTimeElapsed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetExecutionTimerTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AReverseBearTrap::GetExecutionTimerTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetExecutionTimerTimeLeft");

	Params::ReverseBearTrap_GetExecutionTimerTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetExitGatesPoweredAfterAttachment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::GetExitGatesPoweredAfterAttachment() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetExitGatesPoweredAfterAttachment");

	Params::ReverseBearTrap_GetExitGatesPoweredAfterAttachment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetGeneratorFixedAfterAttachment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::GetGeneratorFixedAfterAttachment() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetGeneratorFixedAfterAttachment");

	Params::ReverseBearTrap_GetGeneratorFixedAfterAttachment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetKeyID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AReverseBearTrap::GetKeyID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetKeyID");

	Params::ReverseBearTrap_GetKeyID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetWarningLevel
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AReverseBearTrap::GetWarningLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetWarningLevel");

	Params::ReverseBearTrap_GetWarningLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.GetWasGateClosedAtAttachment
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::GetWasGateClosedAtAttachment() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "GetWasGateClosedAtAttachment");

	Params::ReverseBearTrap_GetWasGateClosedAtAttachment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.HasDetachStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::HasDetachStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "HasDetachStarted");

	Params::ReverseBearTrap_HasDetachStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.IsExecutionTimerActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::IsExecutionTimerActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "IsExecutionTimerActive");

	Params::ReverseBearTrap_IsExecutionTimerActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.IsExecutionTimerDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::IsExecutionTimerDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "IsExecutionTimerDone");

	Params::ReverseBearTrap_IsExecutionTimerDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.IsInWarningZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::IsInWarningZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "IsInWarningZone");

	Params::ReverseBearTrap_IsInWarningZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.IsRBTActivated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::IsRBTActivated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "IsRBTActivated");

	Params::ReverseBearTrap_IsRBTActivated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrap.ShouldUpdateExecutionTimer
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrap::ShouldUpdateExecutionTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrap", "ShouldUpdateExecutionTimer");

	Params::ReverseBearTrap_ShouldUpdateExecutionTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaPendingContent.GetDownloadSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAtlantaPendingContent::GetDownloadSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaPendingContent", "GetDownloadSize");

	Params::AtlantaPendingContent_GetDownloadSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaPendingContent.GetDownloadSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAtlantaPendingContent::GetDownloadSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaPendingContent", "GetDownloadSpeed");

	Params::AtlantaPendingContent_GetDownloadSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaPendingContent.GetDownloadStatusText
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaPendingContent::GetDownloadStatusText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaPendingContent", "GetDownloadStatusText");

	Params::AtlantaPendingContent_GetDownloadStatusText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaPendingContent.GetInstallProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAtlantaPendingContent::GetInstallProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaPendingContent", "GetInstallProgress");

	Params::AtlantaPendingContent_GetInstallProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaPendingContent.GetIsDownloading
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaPendingContent::GetIsDownloading()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaPendingContent", "GetIsDownloading");

	Params::AtlantaPendingContent_GetIsDownloading Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaPendingContent.GetRequiredDiskSpace
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAtlantaPendingContent::GetRequiredDiskSpace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaPendingContent", "GetRequiredDiskSpace");

	Params::AtlantaPendingContent_GetRequiredDiskSpace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaPendingContent.GetTotalDownloadedSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAtlantaPendingContent::GetTotalDownloadedSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaPendingContent", "GetTotalDownloadedSize");

	Params::AtlantaPendingContent_GetTotalDownloadedSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaPendingContent.StartInstall
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       OnSucceeded                                            (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(class FText ErrorText, int32 ErrorCode)>OnFailed                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UAtlantaPendingContent::StartInstall(TDelegate<void()> OnSucceeded, TDelegate<void(class FText ErrorText, int32 ErrorCode)> OnFailed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaPendingContent", "StartInstall");

	Params::AtlantaPendingContent_StartInstall Parms{};

	Parms.OnSucceeded = OnSucceeded;
	Parms.OnFailed = OnFailed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaPatchingLibrary.GetActiveDeviceProfileName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtlantaPatchingLibrary::GetActiveDeviceProfileName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaPatchingLibrary", "GetActiveDeviceProfileName");

	Params::AtlantaPatchingLibrary_GetActiveDeviceProfileName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaPatchingLibrary.GetInstalledContent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    InstallDirectory                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    ManifestFilename                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtlantaInstalledContent*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtlantaInstalledContent* UAtlantaPatchingLibrary::GetInstalledContent(const class FString& InstallDirectory, const class FString& ManifestFilename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaPatchingLibrary", "GetInstalledContent");

	Params::AtlantaPatchingLibrary_GetInstalledContent Parms{};

	Parms.InstallDirectory = std::move(InstallDirectory);
	Parms.ManifestFilename = std::move(ManifestFilename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaPatchingLibrary.GetSupportedPlatformNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UAtlantaPatchingLibrary::GetSupportedPlatformNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaPatchingLibrary", "GetSupportedPlatformNames");

	Params::AtlantaPatchingLibrary_GetSupportedPlatformNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaPatchingLibrary.HasActiveWiFiConnection
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaPatchingLibrary::HasActiveWiFiConnection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaPatchingLibrary", "HasActiveWiFiConnection");

	Params::AtlantaPatchingLibrary_HasActiveWiFiConnection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaPatchingLibrary.PrintPakLocations
// (Final, Native, Static, Public)

void UAtlantaPatchingLibrary::PrintPakLocations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaPatchingLibrary", "PrintPakLocations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaPatchingLibrary.RequestContent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    RemoteManifestURL                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    CloudURL                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InstallDirectory                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class UAtlantaPendingContent* MobilePendingContent)>OnSucceeded                                            (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(class FText ErrorText, int32 ErrorCode)>OnFailed                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// class UAtlantaPendingContent*           MobilePendingContent                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaPatchingLibrary::RequestContent(const class FString& RemoteManifestURL, const class FString& CloudURL, const class FString& InstallDirectory, TDelegate<void(class UAtlantaPendingContent* MobilePendingContent)> OnSucceeded, TDelegate<void(class FText ErrorText, int32 ErrorCode)> OnFailed, class UAtlantaPendingContent* MobilePendingContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaPatchingLibrary", "RequestContent");

	Params::AtlantaPatchingLibrary_RequestContent Parms{};

	Parms.RemoteManifestURL = std::move(RemoteManifestURL);
	Parms.CloudURL = std::move(CloudURL);
	Parms.InstallDirectory = std::move(InstallDirectory);
	Parms.OnSucceeded = OnSucceeded;
	Parms.OnFailed = OnFailed;
	Parms.MobilePendingContent = MobilePendingContent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Entity.ChangeToIdleState
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AEntity::ChangeToIdleState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "ChangeToIdleState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Entity.ChangeToSacrificeState
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AEntity::ChangeToSacrificeState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "ChangeToSacrificeState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Entity.ChangeToStruggleState
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AEntity::ChangeToStruggleState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "ChangeToStruggleState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Entity.CompleteSacrifice
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    isBasementHook                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEntity::CompleteSacrifice(bool isBasementHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "CompleteSacrifice");

	Params::Entity_CompleteSacrifice Parms{};

	Parms.isBasementHook = isBasementHook;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Entity.HideEntity
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AEntity::HideEntity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "HideEntity");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Entity.InitEntity
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AMeatHook*                        meatHook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEntity::InitEntity(class AMeatHook* meatHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "InitEntity");

	Params::Entity_InitEntity Parms{};

	Parms.meatHook = meatHook;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Entity.OnReactionStart
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AEntity::OnReactionStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "OnReactionStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Entity.SetAnimationIsStruggling
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    isStruggling                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEntity::SetAnimationIsStruggling(bool isStruggling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "SetAnimationIsStruggling");

	Params::Entity_SetAnimationIsStruggling Parms{};

	Parms.isStruggling = isStruggling;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Entity.SetAnimationStrugglePercent
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEntity::SetAnimationStrugglePercent(float percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Entity", "SetAnimationStrugglePercent");

	Params::Entity_SetAnimationStrugglePercent Parms{};

	Parms.percent = percent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.TutorialNotificationController.HideNotification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    removeAllCachedNotifs                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialNotificationController::HideNotification(bool removeAllCachedNotifs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialNotificationController", "HideNotification");

	Params::TutorialNotificationController_HideNotification Parms{};

	Parms.removeAllCachedNotifs = removeAllCachedNotifs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialNotificationController.OnBlockingNotificationDismissed
// (Final, Native, Private)

void UTutorialNotificationController::OnBlockingNotificationDismissed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialNotificationController", "OnBlockingNotificationDismissed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialNotificationController.ShowBlockingNotification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             tutorialNotificationId                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialNotificationController::ShowBlockingNotification(class FName tutorialNotificationId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialNotificationController", "ShowBlockingNotification");

	Params::TutorialNotificationController_ShowBlockingNotification Parms{};

	Parms.tutorialNotificationId = tutorialNotificationId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialNotificationController.ShowNotification
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             tutorialNotificationId                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialNotificationController::ShowNotification(class FName tutorialNotificationId, float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialNotificationController", "ShowNotification");

	Params::TutorialNotificationController_ShowNotification Parms{};

	Parms.tutorialNotificationId = tutorialNotificationId;
	Parms.duration = duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaRitualsScreen.OnClaimRewards
// (Final, Native, Private)
// Parameters:
// int32                                   ritualId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaRitualsScreen::OnClaimRewards(int32 ritualId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaRitualsScreen", "OnClaimRewards");

	Params::AtlantaRitualsScreen_OnClaimRewards Parms{};

	Parms.ritualId = ritualId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaRitualsScreen.OnExitRequested
// (Final, Native, Private)

void UAtlantaRitualsScreen::OnExitRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaRitualsScreen", "OnExitRequested");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaRitualsScreen.OnRefreshRitual
// (Final, Native, Private)

void UAtlantaRitualsScreen::OnRefreshRitual()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaRitualsScreen", "OnRefreshRitual");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaSkillCheckWidget.OnIsActiveChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaSkillCheckWidget::OnIsActiveChanged(bool isActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaSkillCheckWidget", "OnIsActiveChanged");

	Params::AtlantaSkillCheckWidget_OnIsActiveChanged Parms{};

	Parms.isActive = isActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.AtlantaSkillCheckWidget.SetActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaSkillCheckWidget::SetActive(bool active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaSkillCheckWidget", "SetActive");

	Params::AtlantaSkillCheckWidget_SetActive Parms{};

	Parms.active = active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaSkillCheckWidget.SetHexed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isHexed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaSkillCheckWidget::SetHexed(bool isHexed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaSkillCheckWidget", "SetHexed");

	Params::AtlantaSkillCheckWidget_SetHexed Parms{};

	Parms.isHexed = isHexed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaSkillCheckWidget.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UAtlantaSkillCheckWidget::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaSkillCheckWidget", "IsActive");

	Params::AtlantaSkillCheckWidget_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaTooltipManager.TryCloseActiveTooltip
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaTooltipManager::TryCloseActiveTooltip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTooltipManager", "TryCloseActiveTooltip");

	Params::AtlantaTooltipManager_TryCloseActiveTooltip Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaTooltipManager.TryCloseActiveTooltipWithWidget
// (Final, Native, Private)

void UAtlantaTooltipManager::TryCloseActiveTooltipWithWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTooltipManager", "TryCloseActiveTooltipWithWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaTooltipUtilities.TryCloseActiveTooltip
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaTooltipUtilities::TryCloseActiveTooltip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaTooltipUtilities", "TryCloseActiveTooltip");

	Params::AtlantaTooltipUtilities_TryCloseActiveTooltip Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaTutorialPlayerHudController.HideHudComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHudComponent                           hudComponentToHide                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaTutorialPlayerHudController::HideHudComponent(EHudComponent hudComponentToHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialPlayerHudController", "HideHudComponent");

	Params::AtlantaTutorialPlayerHudController_HideHudComponent Parms{};

	Parms.hudComponentToHide = hudComponentToHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaTutorialPlayerHudController.SetVirtualJoystickInputEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaTutorialPlayerHudController::SetVirtualJoystickInputEnabled(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialPlayerHudController", "SetVirtualJoystickInputEnabled");

	Params::AtlantaTutorialPlayerHudController_SetVirtualJoystickInputEnabled Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaTutorialPlayerHudController.ShowHudComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHudComponent                           hudComponentToShow                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaTutorialPlayerHudController::ShowHudComponent(EHudComponent hudComponentToShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialPlayerHudController", "ShowHudComponent");

	Params::AtlantaTutorialPlayerHudController_ShowHudComponent Parms{};

	Parms.hudComponentToShow = hudComponentToShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaTutorialStateMachine.OnBlockingNotificationDismissed
// (Final, Native, Private)
// Parameters:
// class FName                             blockingNotificationID                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaTutorialStateMachine::OnBlockingNotificationDismissed(class FName blockingNotificationID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtlantaTutorialStateMachine", "OnBlockingNotificationDismissed");

	Params::AtlantaTutorialStateMachine_OnBlockingNotificationDismissed Parms{};

	Parms.blockingNotificationID = blockingNotificationID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaUtilities.GetAlantaInteractionDescriptionText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UInteractionDefinition*           interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaUtilities::GetAlantaInteractionDescriptionText(class UInteractionDefinition* interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetAlantaInteractionDescriptionText");

	Params::AtlantaUtilities_GetAlantaInteractionDescriptionText Parms{};

	Parms.interaction = interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetAvailableInteractionOfType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionInputType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UAtlantaUtilities::GetAvailableInteractionOfType(class ADBDPlayer* player, EInputInteractionType interactionInputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetAvailableInteractionOfType");

	Params::AtlantaUtilities_GetAvailableInteractionOfType Parms{};

	Parms.player = player;
	Parms.interactionInputType = interactionInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetBackgroundColorByRarity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const EItemRarity                       rarity                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UAtlantaUtilities::GetBackgroundColorByRarity(const EItemRarity rarity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetBackgroundColorByRarity");

	Params::AtlantaUtilities_GetBackgroundColorByRarity Parms{};

	Parms.rarity = rarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetControlsTunable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             tunableValueName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAtlantaUtilities::GetControlsTunable(class FName tunableValueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetControlsTunable");

	Params::AtlantaUtilities_GetControlsTunable Parms{};

	Parms.tunableValueName = tunableValueName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetControlsTunableByRole
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EPlayerRole                             playerRole                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             tunableValueName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAtlantaUtilities::GetControlsTunableByRole(EPlayerRole playerRole, class FName tunableValueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetControlsTunableByRole");

	Params::AtlantaUtilities_GetControlsTunableByRole Parms{};

	Parms.playerRole = playerRole;
	Parms.tunableValueName = tunableValueName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetCurrencyColor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECurrencyType                           currencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateColor                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateColor UAtlantaUtilities::GetCurrencyColor(ECurrencyType currencyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetCurrencyColor");

	Params::AtlantaUtilities_GetCurrencyColor Parms{};

	Parms.currencyType = currencyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetCurrencyUITexturePath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECurrencyType                           currencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtlantaUtilities::GetCurrencyUITexturePath(ECurrencyType currencyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetCurrencyUITexturePath");

	Params::AtlantaUtilities_GetCurrencyUITexturePath Parms{};

	Parms.currencyType = currencyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetCurrentInteraction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UAtlantaUtilities::GetCurrentInteraction(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetCurrentInteraction");

	Params::AtlantaUtilities_GetCurrentInteraction Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetCurrentInteractionOfType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionInputType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UAtlantaUtilities::GetCurrentInteractionOfType(class ADBDPlayer* player, EInputInteractionType interactionInputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetCurrentInteractionOfType");

	Params::AtlantaUtilities_GetCurrentInteractionOfType Parms{};

	Parms.player = player;
	Parms.interactionInputType = interactionInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetCurrentOrAvailableInteractionOfType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionInputType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UAtlantaUtilities::GetCurrentOrAvailableInteractionOfType(class ADBDPlayer* player, EInputInteractionType interactionInputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetCurrentOrAvailableInteractionOfType");

	Params::AtlantaUtilities_GetCurrentOrAvailableInteractionOfType Parms{};

	Parms.player = player;
	Parms.interactionInputType = interactionInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetDifficultyLevelText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EAIDifficultyLevel                difficultyLevel                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaUtilities::GetDifficultyLevelText(const EAIDifficultyLevel difficultyLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetDifficultyLevelText");

	Params::AtlantaUtilities_GetDifficultyLevelText Parms{};

	Parms.difficultyLevel = difficultyLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetEmblemColorByQuality
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const EEmblemQuality                    emblemQuality                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UAtlantaUtilities::GetEmblemColorByQuality(const EEmblemQuality emblemQuality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetEmblemColorByQuality");

	Params::AtlantaUtilities_GetEmblemColorByQuality Parms{};

	Parms.emblemQuality = emblemQuality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetEmblemQualityText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EEmblemQuality                    emblemQuality                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaUtilities::GetEmblemQualityText(const EEmblemQuality emblemQuality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetEmblemQualityText");

	Params::AtlantaUtilities_GetEmblemQualityText Parms{};

	Parms.emblemQuality = emblemQuality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetIconImageByPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    iconPath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UAtlantaUtilities::GetIconImageByPath(const class FString& iconPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetIconImageByPath");

	Params::AtlantaUtilities_GetIconImageByPath Parms{};

	Parms.iconPath = std::move(iconPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetItemAvailabilityText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EItemAvailability                 availability                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaUtilities::GetItemAvailabilityText(const EItemAvailability availability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetItemAvailabilityText");

	Params::AtlantaUtilities_GetItemAvailabilityText Parms{};

	Parms.availability = availability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetItemRarityText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EItemRarity                       rarity                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaUtilities::GetItemRarityText(const EItemRarity rarity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetItemRarityText");

	Params::AtlantaUtilities_GetItemRarityText Parms{};

	Parms.rarity = rarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetMapSpriteFromPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    mapSpritePath                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPaperSprite*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPaperSprite* UAtlantaUtilities::GetMapSpriteFromPath(const class FString& mapSpritePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetMapSpriteFromPath");

	Params::AtlantaUtilities_GetMapSpriteFromPath Parms{};

	Parms.mapSpritePath = std::move(mapSpritePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetOfferingCategoryText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EOfferingCategory                 offeringCategory                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaUtilities::GetOfferingCategoryText(const EOfferingCategory offeringCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetOfferingCategoryText");

	Params::AtlantaUtilities_GetOfferingCategoryText Parms{};

	Parms.offeringCategory = offeringCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetPaintColorByRarity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const EItemRarity                       rarity                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UAtlantaUtilities::GetPaintColorByRarity(const EItemRarity rarity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetPaintColorByRarity");

	Params::AtlantaUtilities_GetPaintColorByRarity Parms{};

	Parms.rarity = rarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetPlayerRoleText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EPlayerRole                       playerRole                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaUtilities::GetPlayerRoleText(const EPlayerRole playerRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetPlayerRoleText");

	Params::AtlantaUtilities_GetPlayerRoleText Parms{};

	Parms.playerRole = playerRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetPlayerRoleTextUppercase
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EPlayerRole                       playerRole                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAtlantaUtilities::GetPlayerRoleTextUppercase(const EPlayerRole playerRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetPlayerRoleTextUppercase");

	Params::AtlantaUtilities_GetPlayerRoleTextUppercase Parms{};

	Parms.playerRole = playerRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetSpriteFromFullPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    fullSpritePath                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPaperSprite*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPaperSprite* UAtlantaUtilities::GetSpriteFromFullPath(const class FString& fullSpritePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetSpriteFromFullPath");

	Params::AtlantaUtilities_GetSpriteFromFullPath Parms{};

	Parms.fullSpritePath = std::move(fullSpritePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetSpriteFromPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    fullDbPathToImage                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    constantDbPathToImageFolder                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    constantPathToSpriteFolder                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPaperSprite*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPaperSprite* UAtlantaUtilities::GetSpriteFromPath(const class FString& fullDbPathToImage, const class FString& constantDbPathToImageFolder, const class FString& constantPathToSpriteFolder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetSpriteFromPath");

	Params::AtlantaUtilities_GetSpriteFromPath Parms{};

	Parms.fullDbPathToImage = std::move(fullDbPathToImage);
	Parms.constantDbPathToImageFolder = std::move(constantDbPathToImageFolder);
	Parms.constantPathToSpriteFolder = std::move(constantPathToSpriteFolder);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.GetStoreVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtlantaUtilities::GetStoreVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "GetStoreVersion");

	Params::AtlantaUtilities_GetStoreVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.IsInAtlantaTutorialLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::IsInAtlantaTutorialLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "IsInAtlantaTutorialLevel");

	Params::AtlantaUtilities_IsInAtlantaTutorialLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.IsPlayerInteractingWithActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::IsPlayerInteractingWithActor(class ADBDPlayer* player, const class AActor* actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "IsPlayerInteractingWithActor");

	Params::AtlantaUtilities_IsPlayerInteractingWithActor Parms{};

	Parms.player = player;
	Parms.actor = actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.IsTutorialEditorDebuggingEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::IsTutorialEditorDebuggingEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "IsTutorialEditorDebuggingEnabled");

	Params::AtlantaUtilities_IsTutorialEditorDebuggingEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.LoadTextureByAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UAtlantaUtilities::LoadTextureByAsset(const class FString& path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "LoadTextureByAsset");

	Params::AtlantaUtilities_LoadTextureByAsset Parms{};

	Parms.path = std::move(path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.MakeBrushFromSprite
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPaperSprite*                     sprite                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UAtlantaUtilities::MakeBrushFromSprite(class UPaperSprite* sprite)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "MakeBrushFromSprite");

	Params::AtlantaUtilities_MakeBrushFromSprite Parms{};

	Parms.sprite = sprite;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.MakeBrushFromTexture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UAtlantaUtilities::MakeBrushFromTexture(class UTexture2D* texture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "MakeBrushFromTexture");

	Params::AtlantaUtilities_MakeBrushFromTexture Parms{};

	Parms.texture = texture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.SecondsToStringWithoutDecimals
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const int32                             seconds                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtlantaUtilities::SecondsToStringWithoutDecimals(const int32 seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "SecondsToStringWithoutDecimals");

	Params::AtlantaUtilities_SecondsToStringWithoutDecimals Parms{};

	Parms.seconds = seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.SetButtonStyle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UButton*                          button                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSlateBrush&               brush                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAtlantaUtilities::SetButtonStyle(class UButton* button, const struct FSlateBrush& brush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "SetButtonStyle");

	Params::AtlantaUtilities_SetButtonStyle Parms{};

	Parms.button = button;
	Parms.brush = std::move(brush);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaUtilities.SetImageBrush
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UImage*                           image                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       asset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMatchSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaUtilities::SetImageBrush(class UImage* image, class UTexture2D* asset, bool bMatchSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "SetImageBrush");

	Params::AtlantaUtilities_SetImageBrush Parms{};

	Parms.image = image;
	Parms.asset = asset;
	Parms.bMatchSize = bMatchSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaUtilities.SetImageBrushFromPath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UImage*                           image                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMatchSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaUtilities::SetImageBrushFromPath(class UImage* image, const class FString& path, bool bMatchSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "SetImageBrushFromPath");

	Params::AtlantaUtilities_SetImageBrushFromPath Parms{};

	Parms.image = image;
	Parms.path = std::move(path);
	Parms.bMatchSize = bMatchSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaUtilities.SetImageBrushFromSpritePath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UImage*                           image                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtlantaUtilities::SetImageBrushFromSpritePath(class UImage* image, const class FString& path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "SetImageBrushFromSpritePath");

	Params::AtlantaUtilities_SetImageBrushFromSpritePath Parms{};

	Parms.image = image;
	Parms.path = std::move(path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AtlantaUtilities.SetImageSlateBrush
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UImage*                           image                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSlateBrush&               brush                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bMatchSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::SetImageSlateBrush(class UImage* image, const struct FSlateBrush& brush, bool bMatchSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "SetImageSlateBrush");

	Params::AtlantaUtilities_SetImageSlateBrush Parms{};

	Parms.image = image;
	Parms.brush = std::move(brush);
	Parms.bMatchSize = bMatchSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldSupportMultipleActiveActivatablePerks
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldSupportMultipleActiveActivatablePerks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldSupportMultipleActiveActivatablePerks");

	Params::AtlantaUtilities_ShouldSupportMultipleActiveActivatablePerks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaBackendBloodMarketData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaBackendBloodMarketData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaBackendBloodMarketData");

	Params::AtlantaUtilities_ShouldUseAtlantaBackendBloodMarketData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaBloodweb
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaBloodweb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaBloodweb");

	Params::AtlantaUtilities_ShouldUseAtlantaBloodweb Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaBundleFilterRules
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaBundleFilterRules()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaBundleFilterRules");

	Params::AtlantaUtilities_ShouldUseAtlantaBundleFilterRules Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaCatalog
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaCatalog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaCatalog");

	Params::AtlantaUtilities_ShouldUseAtlantaCatalog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaCDNBucketChangelist
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaCDNBucketChangelist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaCDNBucketChangelist");

	Params::AtlantaUtilities_ShouldUseAtlantaCDNBucketChangelist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaCDNPatching
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaCDNPatching()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaCDNPatching");

	Params::AtlantaUtilities_ShouldUseAtlantaCDNPatching Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaCharacterProgression
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaCharacterProgression()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaCharacterProgression");

	Params::AtlantaUtilities_ShouldUseAtlantaCharacterProgression Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaContent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaContent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaContent");

	Params::AtlantaUtilities_ShouldUseAtlantaContent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaCurrencies
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaCurrencies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaCurrencies");

	Params::AtlantaUtilities_ShouldUseAtlantaCurrencies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaCustomizedHudSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaCustomizedHudSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaCustomizedHudSettings");

	Params::AtlantaUtilities_ShouldUseAtlantaCustomizedHudSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaDailyRewards
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaDailyRewards()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaDailyRewards");

	Params::AtlantaUtilities_ShouldUseAtlantaDailyRewards Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaDreamworldFX
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaDreamworldFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaDreamworldFX");

	Params::AtlantaUtilities_ShouldUseAtlantaDreamworldFX Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaEntity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaEntity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaEntity");

	Params::AtlantaUtilities_ShouldUseAtlantaEntity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaFearMarket
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaFearMarket()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaFearMarket");

	Params::AtlantaUtilities_ShouldUseAtlantaFearMarket Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaFixedMaps
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaFixedMaps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaFixedMaps");

	Params::AtlantaUtilities_ShouldUseAtlantaFixedMaps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaFreeTickets
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaFreeTickets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaFreeTickets");

	Params::AtlantaUtilities_ShouldUseAtlantaFreeTickets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaFriendList
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaFriendList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaFriendList");

	Params::AtlantaUtilities_ShouldUseAtlantaFriendList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaGameplayValues
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaGameplayValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaGameplayValues");

	Params::AtlantaUtilities_ShouldUseAtlantaGameplayValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaHudAttackJoystick
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaHudAttackJoystick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaHudAttackJoystick");

	Params::AtlantaUtilities_ShouldUseAtlantaHudAttackJoystick Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaHudEditor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaHudEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaHudEditor");

	Params::AtlantaUtilities_ShouldUseAtlantaHudEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaItemAvailability
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaItemAvailability()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaItemAvailability");

	Params::AtlantaUtilities_ShouldUseAtlantaItemAvailability Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaKrakenContentVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaKrakenContentVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaKrakenContentVersion");

	Params::AtlantaUtilities_ShouldUseAtlantaKrakenContentVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaLighting
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaLighting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaLighting");

	Params::AtlantaUtilities_ShouldUseAtlantaLighting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaMatchmaking
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaMatchmaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaMatchmaking");

	Params::AtlantaUtilities_ShouldUseAtlantaMatchmaking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaOutlines
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaOutlines()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaOutlines");

	Params::AtlantaUtilities_ShouldUseAtlantaOutlines Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaPurchasableOperations
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaPurchasableOperations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaPurchasableOperations");

	Params::AtlantaUtilities_ShouldUseAtlantaPurchasableOperations Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaQualitySettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaQualitySettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaQualitySettings");

	Params::AtlantaUtilities_ShouldUseAtlantaQualitySettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaRank
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaRank()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaRank");

	Params::AtlantaUtilities_ShouldUseAtlantaRank Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaRituals
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaRituals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaRituals");

	Params::AtlantaUtilities_ShouldUseAtlantaRituals Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaStreamVideo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaStreamVideo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaStreamVideo");

	Params::AtlantaUtilities_ShouldUseAtlantaStreamVideo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseAtlantaUI
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseAtlantaUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseAtlantaUI");

	Params::AtlantaUtilities_ShouldUseAtlantaUI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseOfflineMatchHistory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseOfflineMatchHistory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseOfflineMatchHistory");

	Params::AtlantaUtilities_ShouldUseOfflineMatchHistory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AtlantaUtilities.ShouldUseQuickRoleSwitch
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtlantaUtilities::ShouldUseQuickRoleSwitch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtlantaUtilities", "ShouldUseQuickRoleSwitch");

	Params::AtlantaUtilities_ShouldUseQuickRoleSwitch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EvilWithinComponent.Authority_NotifyKill
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       killedPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEvilWithinComponent::Authority_NotifyKill(class ADBDPlayer* killedPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "Authority_NotifyKill");

	Params::EvilWithinComponent_Authority_NotifyKill Parms{};

	Parms.killedPlayer = killedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EvilWithinComponent.Authority_OnPlayerDisconnect
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEvilWithinComponent::Authority_OnPlayerDisconnect(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "Authority_OnPlayerDisconnect");

	Params::EvilWithinComponent_Authority_OnPlayerDisconnect Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EvilWithinComponent.Authority_OnStalkPointsAdded
// (Final, Native, Private)
// Parameters:
// float                                   stalkPoints                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEvilWithinComponent::Authority_OnStalkPointsAdded(float stalkPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "Authority_OnStalkPointsAdded");

	Params::EvilWithinComponent_Authority_OnStalkPointsAdded Parms{};

	Parms.stalkPoints = stalkPoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EvilWithinComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UEvilWithinComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EvilWithinComponent.OnRep_CurrentTier
// (Final, Native, Private)
// Parameters:
// int32                                   previousTier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEvilWithinComponent::OnRep_CurrentTier(int32 previousTier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "OnRep_CurrentTier");

	Params::EvilWithinComponent_OnRep_CurrentTier Parms{};

	Parms.previousTier = previousTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EvilWithinComponent.CanBeStandingKilled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEvilWithinComponent::CanBeStandingKilled(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "CanBeStandingKilled");

	Params::EvilWithinComponent_CanBeStandingKilled Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EvilWithinComponent.CanStandKill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEvilWithinComponent::CanStandKill(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "CanStandKill");

	Params::EvilWithinComponent_CanStandKill Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EvilWithinComponent.GetCurrentTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEvilWithinComponent::GetCurrentTier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "GetCurrentTier");

	Params::EvilWithinComponent_GetCurrentTier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EvilWithinComponent.GetMaxTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEvilWithinComponent::GetMaxTier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "GetMaxTier");

	Params::EvilWithinComponent_GetMaxTier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EvilWithinComponent.GetPercentStalkingPointsInCurrentTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEvilWithinComponent::GetPercentStalkingPointsInCurrentTier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "GetPercentStalkingPointsInCurrentTier");

	Params::EvilWithinComponent_GetPercentStalkingPointsInCurrentTier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EvilWithinComponent.GetRequirementForTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   tier                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEvilWithinComponent::GetRequirementForTier(int32 tier) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "GetRequirementForTier");

	Params::EvilWithinComponent_GetRequirementForTier Parms{};

	Parms.tier = tier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EvilWithinComponent.IsAtLastTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEvilWithinComponent::IsAtLastTier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EvilWithinComponent", "IsAtLastTier");

	Params::EvilWithinComponent_IsAtLastTier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Tile.InitOnSpawned
// (Event, Protected, BlueprintEvent)

void ATile::InitOnSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tile", "InitOnSpawned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Tile.OnAllTileSpawned
// (Event, Public, BlueprintEvent)

void ATile::OnAllTileSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tile", "OnAllTileSpawned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Tile.OnRep_Initialized
// (Final, Native, Protected)
// Parameters:
// bool                                    oldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATile::OnRep_Initialized(bool oldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tile", "OnRep_Initialized");

	Params::Tile_OnRep_Initialized Parms{};

	Parms.oldValue = oldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Tile.OnSetSpawnObject
// (Event, Public, BlueprintEvent)
// Parameters:
// class UTileSpawnPoint*                  tileSpawnPoint                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           spawnedObject                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATile::OnSetSpawnObject(class UTileSpawnPoint* tileSpawnPoint, class AActor* spawnedObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Tile", "OnSetSpawnObject");

	Params::Tile_OnSetSpawnObject Parms{};

	Parms.tileSpawnPoint = tileSpawnPoint;
	Parms.spawnedObject = spawnedObject;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.AudioFXComponent.Authority_Deafen
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFXComponent::Authority_Deafen(float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioFXComponent", "Authority_Deafen");

	Params::AudioFXComponent_Authority_Deafen Parms{};

	Parms.duration = duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AudioFXComponent.Multicast_Deafen
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFXComponent::Multicast_Deafen(float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioFXComponent", "Multicast_Deafen");

	Params::AudioFXComponent_Multicast_Deafen Parms{};

	Parms.duration = duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AudioFXComponent.OnDeafenCompleted
// (Final, Native, Private)

void UAudioFXComponent::OnDeafenCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioFXComponent", "OnDeafenCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AudioFXComponent.OnLocallyObservedChanged
// (Final, Native, Private)
// Parameters:
// bool                                    locallyObserved                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFXComponent::OnLocallyObservedChanged(bool locallyObserved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioFXComponent", "OnLocallyObservedChanged");

	Params::AudioFXComponent_OnLocallyObservedChanged Parms{};

	Parms.locallyObserved = locallyObserved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AudioFXComponent.SetAudioAmbientDetector
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              audioAmbientDetector                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAudioFXComponent::SetAudioAmbientDetector(class UPrimitiveComponent* audioAmbientDetector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AudioFXComponent", "SetAudioAmbientDetector");

	Params::AudioFXComponent_SetAudioAmbientDetector Parms{};

	Parms.audioAmbientDetector = audioAmbientDetector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ExposerCirclingComponent.Reset
// (Final, Native, Public, BlueprintCallable)

void UExposerCirclingComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExposerCirclingComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ExposerCirclingComponent.SetIsCircling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    circling                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExposerCirclingComponent::SetIsCircling(bool circling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExposerCirclingComponent", "SetIsCircling");

	Params::ExposerCirclingComponent_SetIsCircling Parms{};

	Parms.circling = circling;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AuthoritativeMovementComponent.OnPawnDetectorOverlapEnter
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAuthoritativeMovementComponent::OnPawnDetectorOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthoritativeMovementComponent", "OnPawnDetectorOverlapEnter");

	Params::AuthoritativeMovementComponent_OnPawnDetectorOverlapEnter Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AuthoritativeMovementComponent.OnPawnDetectorOverlapExit
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuthoritativeMovementComponent::OnPawnDetectorOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthoritativeMovementComponent", "OnPawnDetectorOverlapExit");

	Params::AuthoritativeMovementComponent_OnPawnDetectorOverlapExit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AuthoritativeMovementComponent.OnRep_AuthoritativeIgnoreOverlapCharacters
// (Final, Native, Private)

void UAuthoritativeMovementComponent::OnRep_AuthoritativeIgnoreOverlapCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthoritativeMovementComponent", "OnRep_AuthoritativeIgnoreOverlapCharacters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AuthoritativeMovementComponent.SetPawnDetector
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCapsuleComponent*                pawnDetector                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuthoritativeMovementComponent::SetPawnDetector(class UCapsuleComponent* pawnDetector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthoritativeMovementComponent", "SetPawnDetector");

	Params::AuthoritativeMovementComponent_SetPawnDetector Parms{};

	Parms.pawnDetector = pawnDetector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AutomaticLeanComponent.Local_Lean
// (Final, Native, Public, BlueprintCallable)

void UAutomaticLeanComponent::Local_Lean()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "Local_Lean");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AutomaticLeanComponent.Local_Unlean
// (Final, Native, Public, BlueprintCallable)

void UAutomaticLeanComponent::Local_Unlean()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "Local_Unlean");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AutomaticLeanComponent.OnRep_LeanState
// (Final, Native, Private)

void UAutomaticLeanComponent::OnRep_LeanState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "OnRep_LeanState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AutomaticLeanComponent.Server_SetLeanState
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// ELeanState                              leanState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAutomaticLeanComponent::Server_SetLeanState(ELeanState leanState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "Server_SetLeanState");

	Params::AutomaticLeanComponent_Server_SetLeanState Parms{};

	Parms.leanState = leanState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AutomaticLeanComponent.CanInitiateLean
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAutomaticLeanComponent::CanInitiateLean() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "CanInitiateLean");

	Params::AutomaticLeanComponent_CanInitiateLean Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AutomaticLeanComponent.GetAvailableDistanceInFrontOfCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAutomaticLeanComponent::GetAvailableDistanceInFrontOfCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "GetAvailableDistanceInFrontOfCamera");

	Params::AutomaticLeanComponent_GetAvailableDistanceInFrontOfCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AutomaticLeanComponent.GetLeanState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELeanState                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELeanState UAutomaticLeanComponent::GetLeanState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "GetLeanState");

	Params::AutomaticLeanComponent_GetLeanState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AutomaticLeanComponent.GetPotentialLeanState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELeanState                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELeanState UAutomaticLeanComponent::GetPotentialLeanState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "GetPotentialLeanState");

	Params::AutomaticLeanComponent_GetPotentialLeanState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.AutomaticLeanComponent.IsLeaning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAutomaticLeanComponent::IsLeaning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutomaticLeanComponent", "IsLeaning");

	Params::AutomaticLeanComponent_IsLeaning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BaseEscapeThroughHatch.GetHatch
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AHatch*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AHatch* UBaseEscapeThroughHatch::GetHatch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseEscapeThroughHatch", "GetHatch");

	Params::BaseEscapeThroughHatch_GetHatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGPartySlotsWidget.HandleBotEditButtonClickEvent
// (Final, Native, Private)
// Parameters:
// const int32                             index                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGPartySlotsWidget::HandleBotEditButtonClickEvent(const int32 index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPartySlotsWidget", "HandleBotEditButtonClickEvent");

	Params::UMGPartySlotsWidget_HandleBotEditButtonClickEvent Parms{};

	Parms.index = index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGPartySlotsWidget.HandleInviteFriendButtonClickEvent
// (Final, Native, Private)

void UUMGPartySlotsWidget::HandleInviteFriendButtonClickEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPartySlotsWidget", "HandleInviteFriendButtonClickEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGPartySlotsWidget.HandleKickPlayerButtonClickEvent
// (Final, Native, Private)
// Parameters:
// const class FString&                    friendKrakenId                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGPartySlotsWidget::HandleKickPlayerButtonClickEvent(const class FString& friendKrakenId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPartySlotsWidget", "HandleKickPlayerButtonClickEvent");

	Params::UMGPartySlotsWidget_HandleKickPlayerButtonClickEvent Parms{};

	Parms.friendKrakenId = std::move(friendKrakenId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGPartySlotsWidget.RearrangePartySlots
// (Final, Native, Private, BlueprintCallable)

void UUMGPartySlotsWidget::RearrangePartySlots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPartySlotsWidget", "RearrangePartySlots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGPartySlotsWidget.SetWidgetState
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// int32                                   index                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPartyPlayerSlotWidgetState             state                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGPartySlotsWidget::SetWidgetState(int32 index, EPartyPlayerSlotWidgetState state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPartySlotsWidget", "SetWidgetState");

	Params::UMGPartySlotsWidget_SetWidgetState Parms{};

	Parms.index = index;
	Parms.state = state;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGPartySlotsWidget.SwapWidgets
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// int32                                   first                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   second                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGPartySlotsWidget::SwapWidgets(int32 first, int32 second)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPartySlotsWidget", "SwapWidgets");

	Params::UMGPartySlotsWidget_SwapWidgets Parms{};

	Parms.first = first;
	Parms.second = second;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseLockerItem.AdjustPositionOnLocker
// (Final, Native, Private)

void ABaseLockerItem::AdjustPositionOnLocker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseLockerItem", "AdjustPositionOnLocker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseLockerItem.OnRep_OwningLocker
// (Final, Native, Protected)

void ABaseLockerItem::OnRep_OwningLocker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseLockerItem", "OnRep_OwningLocker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGPlayersStatusWidget.OnPlayerStatusClicked
// (Final, Native, Private)
// Parameters:
// class UUMGPlayerStatusIcon*             playerStatusIcon                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGPlayersStatusWidget::OnPlayerStatusClicked(class UUMGPlayerStatusIcon* playerStatusIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPlayersStatusWidget", "OnPlayerStatusClicked");

	Params::UMGPlayersStatusWidget_OnPlayerStatusClicked Parms{};

	Parms.playerStatusIcon = playerStatusIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseTrap.SetIsTrapSet
// (Native, Public, BlueprintCallable)
// Parameters:
// const bool                              value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseTrap::SetIsTrapSet(const bool value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseTrap", "SetIsTrapSet");

	Params::BaseTrap_SetIsTrapSet Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BaseTrap.IsTrapSet
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseTrap::IsTrapSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseTrap", "IsTrapSet");

	Params::BaseTrap_IsTrapSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BearTrapOutlineUpdateStrategy.SetOwningBearTrapMapActorComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMapActorComponent*               mapActorComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBearTrapOutlineUpdateStrategy::SetOwningBearTrapMapActorComponent(class UMapActorComponent* mapActorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BearTrapOutlineUpdateStrategy", "SetOwningBearTrapMapActorComponent");

	Params::BearTrapOutlineUpdateStrategy_SetOwningBearTrapMapActorComponent Parms{};

	Parms.mapActorComponent = mapActorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBaseCurrencyStorefrontWidget.BroadcastOnAuricCellButtonClicked
// (Final, Native, Protected)
// Parameters:
// int32                                   cellIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBaseCurrencyStorefrontWidget::BroadcastOnAuricCellButtonClicked(int32 cellIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBaseCurrencyStorefrontWidget", "BroadcastOnAuricCellButtonClicked");

	Params::UMGBaseCurrencyStorefrontWidget_BroadcastOnAuricCellButtonClicked Parms{};

	Parms.cellIndex = cellIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlCurrencyStorefrontWidget.UpdateFirstPurchaseForAllAuricCellsEndInUI
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class FString&                    endInText                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlCurrencyStorefrontWidget::UpdateFirstPurchaseForAllAuricCellsEndInUI(const class FString& endInText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlCurrencyStorefrontWidget", "UpdateFirstPurchaseForAllAuricCellsEndInUI");

	Params::UMGAtlCurrencyStorefrontWidget_UpdateFirstPurchaseForAllAuricCellsEndInUI Parms{};

	Parms.endInText = std::move(endInText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.BlessedVignetteController.OnActivateBlessedVignette
// (Event, Public, BlueprintEvent)

void UBlessedVignetteController::OnActivateBlessedVignette()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlessedVignetteController", "OnActivateBlessedVignette");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.BlessedVignetteController.OnDeactivateBlessedVignette
// (Event, Public, BlueprintEvent)

void UBlessedVignetteController::OnDeactivateBlessedVignette()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlessedVignetteController", "OnDeactivateBlessedVignette");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.BlindingFXComponent.SetPostProcess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPostProcessComponent*            value                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlindingFXComponent::SetPostProcess(class UPostProcessComponent* value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindingFXComponent", "SetPostProcess");

	Params::BlindingFXComponent_SetPostProcess Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlindingFXComponent.SetPostProcessMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlindingFXComponent::SetPostProcessMaterial(class UMaterialInstanceDynamic* value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlindingFXComponent", "SetPostProcessMaterial");

	Params::BlindingFXComponent_SetPostProcessMaterial Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlockableComponent.Authority_AddBlock
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSet<class ADBDPlayer*>&          affectedPlayers                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBlockableComponent::Authority_AddBlock(const class UObject* source, const TSet<class ADBDPlayer*>& affectedPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlockableComponent", "Authority_AddBlock");

	Params::BlockableComponent_Authority_AddBlock Parms{};

	Parms.source = source;
	Parms.affectedPlayers = std::move(affectedPlayers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlockableComponent.Authority_AddTimedBlock
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSet<class ADBDPlayer*>&          affectedPlayers                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBlockableComponent::Authority_AddTimedBlock(const class UObject* source, const float duration, const TSet<class ADBDPlayer*>& affectedPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlockableComponent", "Authority_AddTimedBlock");

	Params::BlockableComponent_Authority_AddTimedBlock Parms{};

	Parms.source = source;
	Parms.duration = duration;
	Parms.affectedPlayers = std::move(affectedPlayers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlockableComponent.Authority_RemoveBlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlockableComponent::Authority_RemoveBlock(const class UObject* source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlockableComponent", "Authority_RemoveBlock");

	Params::BlockableComponent_Authority_RemoveBlock Parms{};

	Parms.source = source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlockableComponent.OnRep_ReplicatedDatum
// (Final, Native, Private)

void UBlockableComponent::OnRep_ReplicatedDatum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlockableComponent", "OnRep_ReplicatedDatum");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAggregateCullDistanceVolumes.SpawnCullDistanceVolumes
// (Final, Native, Public)

void ADBDAggregateCullDistanceVolumes::SpawnCullDistanceVolumes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAggregateCullDistanceVolumes", "SpawnCullDistanceVolumes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.WakerObject.BindToCamperDreamStateChanged
// (Final, Native, Public)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWakerObject::BindToCamperDreamStateChanged(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "BindToCamperDreamStateChanged");

	Params::WakerObject_BindToCamperDreamStateChanged Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.WakerObject.LinkCampersOnLevelReadyToPlay
// (Final, Native, Public)

void AWakerObject::LinkCampersOnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "LinkCampersOnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.WakerObject.OnAnyCamperDreamStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    isInDreamworld                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    locallyObservedChanged                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWakerObject::OnAnyCamperDreamStateChanged(bool isInDreamworld, bool locallyObservedChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "OnAnyCamperDreamStateChanged");

	Params::WakerObject_OnAnyCamperDreamStateChanged Parms{};

	Parms.isInDreamworld = isInDreamworld;
	Parms.locallyObservedChanged = locallyObservedChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.WakerObject.OnLinkedCamperDreamStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    isInDreamworld                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    locallyObservedChanged                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWakerObject::OnLinkedCamperDreamStateChanged(bool isInDreamworld, bool locallyObservedChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "OnLinkedCamperDreamStateChanged");

	Params::WakerObject_OnLinkedCamperDreamStateChanged Parms{};

	Parms.isInDreamworld = isInDreamworld;
	Parms.locallyObservedChanged = locallyObservedChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.WakerObject.OnNewLinkedCamper
// (Event, Public, BlueprintEvent)
// Parameters:
// class UCamperDreamworldComponent*       dreamworldComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWakerObject::OnNewLinkedCamper(class UCamperDreamworldComponent* dreamworldComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "OnNewLinkedCamper");

	Params::WakerObject_OnNewLinkedCamper Parms{};

	Parms.dreamworldComponent = dreamworldComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.WakerObject.OnRep_LinkedCamperChanged
// (Final, Native, Protected)
// Parameters:
// class UCamperDreamworldComponent*       previous                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWakerObject::OnRep_LinkedCamperChanged(class UCamperDreamworldComponent* previous)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "OnRep_LinkedCamperChanged");

	Params::WakerObject_OnRep_LinkedCamperChanged Parms{};

	Parms.previous = previous;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.WakerObject.SetChargeComplete
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    complete                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWakerObject::SetChargeComplete(bool complete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "SetChargeComplete");

	Params::WakerObject_SetChargeComplete Parms{};

	Parms.complete = complete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.WakerObject.UpdateVisibilityAndOutline
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AWakerObject::UpdateVisibilityAndOutline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "UpdateVisibilityAndOutline");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.WakerObject.CanWakeUpCamper
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 camper                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWakerObject::CanWakeUpCamper(const class ADBDPlayer* camper) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "CanWakeUpCamper");

	Params::WakerObject_CanWakeUpCamper Parms{};

	Parms.camper = camper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.WakerObject.GetChargeComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWakerObject::GetChargeComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "GetChargeComplete");

	Params::WakerObject_GetChargeComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.WakerObject.GetInteractionPercentComplete
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AWakerObject::GetInteractionPercentComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "GetInteractionPercentComplete");

	Params::WakerObject_GetInteractionPercentComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.WakerObject.GetInteractorPrimitiveComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* AWakerObject::GetInteractorPrimitiveComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "GetInteractorPrimitiveComponent");

	Params::WakerObject_GetInteractorPrimitiveComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.WakerObject.GetIsInteracting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWakerObject::GetIsInteracting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "GetIsInteracting");

	Params::WakerObject_GetIsInteracting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.WakerObject.GetMesh
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AWakerObject::GetMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "GetMesh");

	Params::WakerObject_GetMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.WakerObject.HasLinkedCamper
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWakerObject::HasLinkedCamper() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "HasLinkedCamper");

	Params::WakerObject_HasLinkedCamper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.WakerObject.IsLinkedToCamper
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 camper                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWakerObject::IsLinkedToCamper(const class ADBDPlayer* camper) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WakerObject", "IsLinkedToCamper");

	Params::WakerObject_IsLinkedToCamper Parms{};

	Parms.camper = camper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDiceRoller.CalculateOverTimeRollResult
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     RollingActor                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseProbability                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ExpectedTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MultiplicativeModifier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdditiveModifier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDDiceRoller::CalculateOverTimeRollResult(const class AActor* RollingActor, float BaseProbability, float DeltaTime, float ExpectedTime, float MultiplicativeModifier, float AdditiveModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDiceRoller", "CalculateOverTimeRollResult");

	Params::DBDDiceRoller_CalculateOverTimeRollResult Parms{};

	Parms.RollingActor = RollingActor;
	Parms.BaseProbability = BaseProbability;
	Parms.DeltaTime = DeltaTime;
	Parms.ExpectedTime = ExpectedTime;
	Parms.MultiplicativeModifier = MultiplicativeModifier;
	Parms.AdditiveModifier = AdditiveModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDiceRoller.CalculateRollResult
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     RollingActor                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseProbability                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MultiplicativeModifier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdditiveModifier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDDiceRoller::CalculateRollResult(const class AActor* RollingActor, float BaseProbability, float MultiplicativeModifier, float AdditiveModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDiceRoller", "CalculateRollResult");

	Params::DBDDiceRoller_CalculateRollResult Parms{};

	Parms.RollingActor = RollingActor;
	Parms.BaseProbability = BaseProbability;
	Parms.MultiplicativeModifier = MultiplicativeModifier;
	Parms.AdditiveModifier = AdditiveModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDiceRoller.CalculateTickedRollResult
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     RollingActor                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseProbability                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ticks                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MultiplicativeModifier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdditiveModifier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDDiceRoller::CalculateTickedRollResult(const class AActor* RollingActor, float BaseProbability, float ticks, float MultiplicativeModifier, float AdditiveModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDiceRoller", "CalculateTickedRollResult");

	Params::DBDDiceRoller_CalculateTickedRollResult Parms{};

	Parms.RollingActor = RollingActor;
	Parms.BaseProbability = BaseProbability;
	Parms.ticks = ticks;
	Parms.MultiplicativeModifier = MultiplicativeModifier;
	Parms.AdditiveModifier = AdditiveModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDiceRoller.GetInteractionRollSuccessPercentageByDiceRollType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UInteractionDefinition*     interaction                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 RollingPlayer                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDiceRollType                           DiceRollType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDDiceRoller::GetInteractionRollSuccessPercentageByDiceRollType(const class UInteractionDefinition* interaction, const class ADBDPlayer* RollingPlayer, EDiceRollType DiceRollType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDiceRoller", "GetInteractionRollSuccessPercentageByDiceRollType");

	Params::DBDDiceRoller_GetInteractionRollSuccessPercentageByDiceRollType Parms{};

	Parms.interaction = interaction;
	Parms.RollingPlayer = RollingPlayer;
	Parms.DiceRollType = DiceRollType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDiceRoller.GetRollResultByDiceRollType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 RollingPlayer                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDiceRollType                           DiceRollType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDDiceRoller::GetRollResultByDiceRollType(const class ADBDPlayer* RollingPlayer, EDiceRollType DiceRollType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDiceRoller", "GetRollResultByDiceRollType");

	Params::DBDDiceRoller_GetRollResultByDiceRollType Parms{};

	Parms.RollingPlayer = RollingPlayer;
	Parms.DiceRollType = DiceRollType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDiceRoller.GetRollResultByTunableValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     RollingActor                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TunableValueName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MultiplicativeModifier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdditiveModifier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDDiceRoller::GetRollResultByTunableValue(const class AActor* RollingActor, class FName TunableValueName, float MultiplicativeModifier, float AdditiveModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDDiceRoller", "GetRollResultByTunableValue");

	Params::DBDDiceRoller_GetRollResultByTunableValue Parms{};

	Parms.RollingActor = RollingActor;
	Parms.TunableValueName = TunableValueName;
	Parms.MultiplicativeModifier = MultiplicativeModifier;
	Parms.AdditiveModifier = AdditiveModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGAtlantaFriendListScreen.HandleCloseButtonClicked
// (Final, Native, Private)

void UUMGAtlantaFriendListScreen::HandleCloseButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaFriendListScreen", "HandleCloseButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaFriendListScreen.HandleContextualMenuAction
// (Final, Native, Private)
// Parameters:
// EActionOnFriendType                     action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaFriendListScreen::HandleContextualMenuAction(EActionOnFriendType action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaFriendListScreen", "HandleContextualMenuAction");

	Params::UMGAtlantaFriendListScreen_HandleContextualMenuAction Parms{};

	Parms.action = action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaFriendListScreen.HandleOnActionOnFriend
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FActionOnFriend&           actionOnFriend                                         (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UUMGAtlantaFriendListScreen::HandleOnActionOnFriend(const struct FActionOnFriend& actionOnFriend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaFriendListScreen", "HandleOnActionOnFriend");

	Params::UMGAtlantaFriendListScreen_HandleOnActionOnFriend Parms{};

	Parms.actionOnFriend = std::move(actionOnFriend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaFriendListScreen.HandleSearchButtonClicked
// (Final, Native, Private)

void UUMGAtlantaFriendListScreen::HandleSearchButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaFriendListScreen", "HandleSearchButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaFriendListScreen.HandleSearchInputChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// const class FText&                      inputText                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGAtlantaFriendListScreen::HandleSearchInputChanged(const class FText& inputText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaFriendListScreen", "HandleSearchInputChanged");

	Params::UMGAtlantaFriendListScreen_HandleSearchInputChanged Parms{};

	Parms.inputText = std::move(inputText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaFriendListScreen.HandleTabButtonClicked
// (Final, Native, Private)
// Parameters:
// uint8                                   tabIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaFriendListScreen::HandleTabButtonClicked(uint8 tabIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaFriendListScreen", "HandleTabButtonClicked");

	Params::UMGAtlantaFriendListScreen_HandleTabButtonClicked Parms{};

	Parms.tabIndex = tabIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaFriendListScreen.OnFinishedOutAnimation
// (Final, Native, Private)

void UUMGAtlantaFriendListScreen::OnFinishedOutAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaFriendListScreen", "OnFinishedOutAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaFriendListScreen.VerifyReceivedFriendRequestFocus
// (Final, Native, Private)
// Parameters:
// class UExpandableArea*                  expandableArea                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsExpanded                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaFriendListScreen::VerifyReceivedFriendRequestFocus(class UExpandableArea* expandableArea, bool bIsExpanded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaFriendListScreen", "VerifyReceivedFriendRequestFocus");

	Params::UMGAtlantaFriendListScreen_VerifyReceivedFriendRequestFocus Parms{};

	Parms.expandableArea = expandableArea;
	Parms.bIsExpanded = bIsExpanded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Bloodlust.DBD_SetBloodlust
// (Final, Exec, Native, Public)
// Parameters:
// const int32                             amount                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              enableDecay                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBloodlust::DBD_SetBloodlust(const int32 amount, const bool enableDecay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Bloodlust", "DBD_SetBloodlust");

	Params::Bloodlust_DBD_SetBloodlust Parms{};

	Parms.amount = amount;
	Parms.enableDecay = enableDecay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Bloodlust.OnAllChaseEndedEvent
// (Final, Native, Private)

void UBloodlust::OnAllChaseEndedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Bloodlust", "OnAllChaseEndedEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Bloodlust.OnChaseStartedEvent
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       chasedPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBloodlust::OnChaseStartedEvent(class ADBDPlayer* chasedPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Bloodlust", "OnChaseStartedEvent");

	Params::Bloodlust_OnChaseStartedEvent Parms{};

	Parms.chasedPlayer = chasedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Bloodlust.OnRep_BloodlustTime
// (Final, Native, Private)
// Parameters:
// float                                   oldBloodlustTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBloodlust::OnRep_BloodlustTime(float oldBloodlustTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Bloodlust", "OnRep_BloodlustTime");

	Params::Bloodlust_OnRep_BloodlustTime Parms{};

	Parms.oldBloodlustTime = oldBloodlustTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Bloodlust.GetBloodlustTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBloodlust::GetBloodlustTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Bloodlust", "GetBloodlustTime");

	Params::Bloodlust_GetBloodlustTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBaseMatchGameMode.GetEndGameComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEndGameComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEndGameComponent* ADBDBaseMatchGameMode::GetEndGameComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBaseMatchGameMode", "GetEndGameComponent");

	Params::DBDBaseMatchGameMode_GetEndGameComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameMode.DBD_BlockCamperEscape
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    shouldBlock                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameMode::DBD_BlockCamperEscape(bool shouldBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameMode", "DBD_BlockCamperEscape");

	Params::DBDGameMode_DBD_BlockCamperEscape Parms{};

	Parms.shouldBlock = shouldBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameMode.HostGame
// (Final, Native, Protected, BlueprintCallable)

void ADBDGameMode::HostGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameMode", "HostGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameMode.InitializeEscapeRequirements
// (Final, Native, Protected, BlueprintCallable)

void ADBDGameMode::InitializeEscapeRequirements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameMode", "InitializeEscapeRequirements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameMode.LevelLoaded
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    levelName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameMode::LevelLoaded(const class FString& levelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameMode", "LevelLoaded");

	Params::DBDGameMode_LevelLoaded Parms{};

	Parms.levelName = std::move(levelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameMode.OnPlayerGameStateChanged
// (Final, Native, Public)
// Parameters:
// class ADBDPlayerState*                  playerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameState                              playerGameState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameMode::OnPlayerGameStateChanged(class ADBDPlayerState* playerState, EGameState playerGameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameMode", "OnPlayerGameStateChanged");

	Params::DBDGameMode_OnPlayerGameStateChanged Parms{};

	Parms.playerState = playerState;
	Parms.playerGameState = playerGameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameMode.RegisterOnPlayerStateChanged
// (Final, Native, Public)
// Parameters:
// class APlayerState*                     playerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameMode::RegisterOnPlayerStateChanged(class APlayerState* playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameMode", "RegisterOnPlayerStateChanged");

	Params::DBDGameMode_RegisterOnPlayerStateChanged Parms{};

	Parms.playerState = playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameMode.SetEscapeOpened
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameMode::SetEscapeOpened(bool val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameMode", "SetEscapeOpened");

	Params::DBDGameMode_SetEscapeOpened Parms{};

	Parms.val = val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameMode.SetPlayerCount
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   playerAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGameMode::SetPlayerCount(int32 playerAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameMode", "SetPlayerCount");

	Params::DBDGameMode_SetPlayerCount Parms{};

	Parms.playerAmount = playerAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameMode.AreLoadoutsCreated
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameMode::AreLoadoutsCreated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameMode", "AreLoadoutsCreated");

	Params::DBDGameMode_AreLoadoutsCreated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameMode.IsEscapeOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDGameMode::IsEscapeOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameMode", "IsEscapeOpen");

	Params::DBDGameMode_IsEscapeOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BloodTrailComponent.ConditionalStartBleeding
// (Native, Public, BlueprintCallable)

void UBloodTrailComponent::ConditionalStartBleeding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodTrailComponent", "ConditionalStartBleeding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBD_SoundClipUtil.Cosmetic_OnSoundTriggered
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBD_SoundClipUtil::Cosmetic_OnSoundTriggered(class AActor* actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBD_SoundClipUtil", "Cosmetic_OnSoundTriggered");

	Params::DBD_SoundClipUtil_Cosmetic_OnSoundTriggered Parms{};

	Parms.actor = actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBD_SoundClipUtil.GetAudioEventForMesh
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             usm                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAkAudioEvent*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkAudioEvent* UDBD_SoundClipUtil::GetAudioEventForMesh(class UStaticMeshComponent* usm)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBD_SoundClipUtil", "GetAudioEventForMesh");

	Params::DBD_SoundClipUtil_GetAudioEventForMesh Parms{};

	Parms.usm = usm;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBD_SoundClipUtil.OnCharacterEnterSoundRegion
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDBD_SoundClipUtil::OnCharacterEnterSoundRegion(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBD_SoundClipUtil", "OnCharacterEnterSoundRegion");

	Params::DBD_SoundClipUtil_OnCharacterEnterSoundRegion Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DailyRitualsScreen.OnClaimAllRituals
// (Final, Native, Private)

void UDailyRitualsScreen::OnClaimAllRituals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DailyRitualsScreen", "OnClaimAllRituals");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DailyRitualsScreen.OnClaimRitual
// (Final, Native, Private)
// Parameters:
// const class FString&                    id                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDailyRitualsScreen::OnClaimRitual(const class FString& id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DailyRitualsScreen", "OnClaimRitual");

	Params::DailyRitualsScreen_OnClaimRitual Parms{};

	Parms.id = std::move(id);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DailyRitualsScreen.OnClosed
// (Final, Native, Private)

void UDailyRitualsScreen::OnClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DailyRitualsScreen", "OnClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DailyRitualsScreen.OnRemoveRitual
// (Final, Native, Private)
// Parameters:
// const class FString&                    id                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDailyRitualsScreen::OnRemoveRitual(const class FString& id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DailyRitualsScreen", "OnRemoveRitual");

	Params::DailyRitualsScreen_OnRemoveRitual Parms{};

	Parms.id = std::move(id);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BloodwebManager.Init
// (Final, Native, Public)
// Parameters:
// class UDBDGameInstance*                 gameInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDBDDesignTunables*               tunables                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBloodwebManager::Init(class UDBDGameInstance* gameInstance, class UDBDDesignTunables* tunables)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BloodwebManager", "Init");

	Params::BloodwebManager_Init Parms{};

	Parms.gameInstance = gameInstance;
	Parms.tunables = tunables;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIPlayerController.MovePlayerToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           goal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   acceptanceRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIPlayerController::MovePlayerToActor(class AActor* goal, float acceptanceRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIPlayerController", "MovePlayerToActor");

	Params::DBDAIPlayerController_MovePlayerToActor Parms{};

	Parms.goal = goal;
	Parms.acceptanceRadius = acceptanceRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIPlayerController.OnBehaviourEndedHandler
// (Final, Native, Private)
// Parameters:
// class UAICharacterBehaviour*            behaviourEnded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIPlayerController::OnBehaviourEndedHandler(class UAICharacterBehaviour* behaviourEnded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIPlayerController", "OnBehaviourEndedHandler");

	Params::DBDAIPlayerController_OnBehaviourEndedHandler Parms{};

	Parms.behaviourEnded = behaviourEnded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIPlayerController.PauseCharacterBehaviour
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UClass*                     behaviourClass                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIPlayerController::PauseCharacterBehaviour(const class UClass* behaviourClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIPlayerController", "PauseCharacterBehaviour");

	Params::DBDAIPlayerController_PauseCharacterBehaviour Parms{};

	Parms.behaviourClass = behaviourClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIPlayerController.ResumeCharacterBehaviour
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UClass*                     behaviourClass                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIPlayerController::ResumeCharacterBehaviour(const class UClass* behaviourClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIPlayerController", "ResumeCharacterBehaviour");

	Params::DBDAIPlayerController_ResumeCharacterBehaviour Parms{};

	Parms.behaviourClass = behaviourClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIPlayerController.StartCharacterBehaviour
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           behaviourClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAICharacterBehaviourData*        characterBehaviourData                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIPlayerController::StartCharacterBehaviour(class UClass* behaviourClass, class UAICharacterBehaviourData* characterBehaviourData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIPlayerController", "StartCharacterBehaviour");

	Params::DBDAIPlayerController_StartCharacterBehaviour Parms{};

	Parms.behaviourClass = behaviourClass;
	Parms.characterBehaviourData = characterBehaviourData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIPlayerController.StopAllCharacterBehaviours
// (Final, Native, Public, BlueprintCallable)

void ADBDAIPlayerController::StopAllCharacterBehaviours()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIPlayerController", "StopAllCharacterBehaviours");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAIPlayerController.StopCharacterBehaviour
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UClass*                     behaviourClass                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDAIPlayerController::StopCharacterBehaviour(const class UClass* behaviourClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAIPlayerController", "StopCharacterBehaviour");

	Params::DBDAIPlayerController_StopCharacterBehaviour Parms{};

	Parms.behaviourClass = behaviourClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlueprintDebugUtilities.EnsureFalseWithMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ensureMessage                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintDebugUtilities::EnsureFalseWithMessage(const class FString& ensureMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintDebugUtilities", "EnsureFalseWithMessage");

	Params::BlueprintDebugUtilities_EnsureFalseWithMessage Parms{};

	Parms.ensureMessage = std::move(ensureMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BlueprintDebugUtilities.EnsureOnConditionWithMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const bool                              condition                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    ensureMessage                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintDebugUtilities::EnsureOnConditionWithMessage(const bool condition, const class FString& ensureMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintDebugUtilities", "EnsureOnConditionWithMessage");

	Params::BlueprintDebugUtilities_EnsureOnConditionWithMessage Parms{};

	Parms.condition = condition;
	Parms.ensureMessage = std::move(ensureMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherHitsWhileCarryingTrackerComponent.OnAttack
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USlasherHitsWhileCarryingTrackerComponent::OnAttack(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherHitsWhileCarryingTrackerComponent", "OnAttack");

	Params::SlasherHitsWhileCarryingTrackerComponent_OnAttack Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherHitsWhileCarryingTrackerComponent.OnPickup
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USlasherHitsWhileCarryingTrackerComponent::OnPickup(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherHitsWhileCarryingTrackerComponent", "OnPickup");

	Params::SlasherHitsWhileCarryingTrackerComponent_OnPickup Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherHitsWhileCarryingTrackerComponent.OnPostAttack
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USlasherHitsWhileCarryingTrackerComponent::OnPostAttack(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherHitsWhileCarryingTrackerComponent", "OnPostAttack");

	Params::SlasherHitsWhileCarryingTrackerComponent_OnPostAttack Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgPlayerHud.OnInitializeHUD
// (Event, Protected, BlueprintEvent)

void UUmgPlayerHud::OnInitializeHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgPlayerHud", "OnInitializeHUD");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UmgPlayerHud.OnInteractionEnded
// (Native, Protected)
// Parameters:
// class UInteractionDefinition*           interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgPlayerHud::OnInteractionEnded(class UInteractionDefinition* interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgPlayerHud", "OnInteractionEnded");

	Params::UmgPlayerHud_OnInteractionEnded Parms{};

	Parms.interaction = interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgPlayerHud.OnInteractionStarted
// (Native, Protected)
// Parameters:
// class UInteractionDefinition*           interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgPlayerHud::OnInteractionStarted(class UInteractionDefinition* interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgPlayerHud", "OnInteractionStarted");

	Params::UmgPlayerHud_OnInteractionStarted Parms{};

	Parms.interaction = interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgPlayerHud.OnPerkClicked
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             perkID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    clickedOnPerksWidget                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgPlayerHud::OnPerkClicked(class FName perkID, bool clickedOnPerksWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgPlayerHud", "OnPerkClicked");

	Params::UmgPlayerHud_OnPerkClicked Parms{};

	Parms.perkID = perkID;
	Parms.clickedOnPerksWidget = clickedOnPerksWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgPlayerHud.OnSettingsButtonPressed
// (Final, Native, Protected, BlueprintCallable)

void UUmgPlayerHud::OnSettingsButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgPlayerHud", "OnSettingsButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgPlayerHud.SetVirtualJoystickThumbImage
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    locked                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgPlayerHud::SetVirtualJoystickThumbImage(bool locked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgPlayerHud", "SetVirtualJoystickThumbImage");

	Params::UmgPlayerHud_SetVirtualJoystickThumbImage Parms{};

	Parms.locked = locked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgPlayerHud.TutorialTallyLeaveSelected
// (Final, Native, Protected, BlueprintCallable)

void UUmgPlayerHud::TutorialTallyLeaveSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgPlayerHud", "TutorialTallyLeaveSelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgPlayerHud.TutorialTallyNextSelected
// (Final, Native, Protected, BlueprintCallable)

void UUmgPlayerHud::TutorialTallyNextSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgPlayerHud", "TutorialTallyNextSelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgPlayerHud.GetCurrentOrAvailableInteractionOfType
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInputInteractionType                   interactionInputType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UUmgPlayerHud::GetCurrentOrAvailableInteractionOfType(EInputInteractionType interactionInputType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgPlayerHud", "GetCurrentOrAvailableInteractionOfType");

	Params::UmgPlayerHud_GetCurrentOrAvailableInteractionOfType Parms{};

	Parms.interactionInputType = interactionInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UmgPlayerHud.GetInteractionIconByType
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInputInteractionType                   interactionInputType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UUmgPlayerHud::GetInteractionIconByType(EInputInteractionType interactionInputType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgPlayerHud", "GetInteractionIconByType");

	Params::UmgPlayerHud_GetInteractionIconByType Parms{};

	Parms.interactionInputType = interactionInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UmgPlayerHud.IsInitialized
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUmgPlayerHud::IsInitialized() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgPlayerHud", "IsInitialized");

	Params::UmgPlayerHud_IsInitialized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UmgPlayerHud.IsInteractionAllowed
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionDefinition*           interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUmgPlayerHud::IsInteractionAllowed(class UInteractionDefinition* interaction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgPlayerHud", "IsInteractionAllowed");

	Params::UmgPlayerHud_IsInteractionAllowed Parms{};

	Parms.interaction = interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UmgPlayerHud.IsInteractionAvailable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUmgPlayerHud::IsInteractionAvailable(EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgPlayerHud", "IsInteractionAvailable");

	Params::UmgPlayerHud_IsInteractionAvailable Parms{};

	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UmgSurvivorHud.CenterItemClicked
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    fromCancelRequest                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgSurvivorHud::CenterItemClicked(bool fromCancelRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSurvivorHud", "CenterItemClicked");

	Params::UmgSurvivorHud_CenterItemClicked Parms{};

	Parms.fromCancelRequest = fromCancelRequest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgSurvivorHud.GetLookBackJoystickIsPressed
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUmgSurvivorHud::GetLookBackJoystickIsPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSurvivorHud", "GetLookBackJoystickIsPressed");

	Params::UmgSurvivorHud_GetLookBackJoystickIsPressed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UmgSurvivorHud.GetLookBackJoystickNormalizedOffset
// (Final, Native, Private, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UUmgSurvivorHud::GetLookBackJoystickNormalizedOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSurvivorHud", "GetLookBackJoystickNormalizedOffset");

	Params::UmgSurvivorHud_GetLookBackJoystickNormalizedOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UmgSurvivorHud.InitializeLookBackJoystickPosition
// (Event, Protected, BlueprintEvent)

void UUmgSurvivorHud::InitializeLookBackJoystickPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSurvivorHud", "InitializeLookBackJoystickPosition");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UmgSurvivorHud.OnCancelButtonClicked
// (Final, Native, Private, BlueprintCallable)

void UUmgSurvivorHud::OnCancelButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSurvivorHud", "OnCancelButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgSurvivorHud.RespondToVirtualJoystickPressChanged
// (Final, Native, Public)
// Parameters:
// int32                                   controlIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgSurvivorHud::RespondToVirtualJoystickPressChanged(int32 controlIndex, bool pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSurvivorHud", "RespondToVirtualJoystickPressChanged");

	Params::UmgSurvivorHud_RespondToVirtualJoystickPressChanged Parms{};

	Parms.controlIndex = controlIndex;
	Parms.pressed = pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgSurvivorHud.SetLookBackJoystickImage
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgSurvivorHud::SetLookBackJoystickImage(bool pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSurvivorHud", "SetLookBackJoystickImage");

	Params::UmgSurvivorHud_SetLookBackJoystickImage Parms{};

	Parms.pressed = pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgSurvivorHud.SetLookBackJoystickPosition
// (Final, Native, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D&                       position                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgSurvivorHud::SetLookBackJoystickPosition(struct FVector2D& position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSurvivorHud", "SetLookBackJoystickPosition");

	Params::UmgSurvivorHud_SetLookBackJoystickPosition Parms{};

	Parms.position = std::move(position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	position = std::move(Parms.position);
}


// Function DeadByDaylight.UmgSurvivorHud.SetNonRestrictedControlsVisibility
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgSurvivorHud::SetNonRestrictedControlsVisibility(bool visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSurvivorHud", "SetNonRestrictedControlsVisibility");

	Params::UmgSurvivorHud_SetNonRestrictedControlsVisibility Parms{};

	Parms.visible = visible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UmgSurvivorHud.SetSkillCheckButtonPosition
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    isInsane                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgSurvivorHud::SetSkillCheckButtonPosition(bool isInsane)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSurvivorHud", "SetSkillCheckButtonPosition");

	Params::UmgSurvivorHud_SetSkillCheckButtonPosition Parms{};

	Parms.isInsane = isInsane;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgSurvivorHud.UpdateCancelButton
// (Final, Native, Private, BlueprintCallable)

void UUmgSurvivorHud::UpdateCancelButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSurvivorHud", "UpdateCancelButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgSurvivorHud.GetCenterItemIcon
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UUmgSurvivorHud::GetCenterItemIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSurvivorHud", "GetCenterItemIcon");

	Params::UmgSurvivorHud_GetCenterItemIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UmgSurvivorHud.GetCenterItemText
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FText                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const class FText UUmgSurvivorHud::GetCenterItemText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSurvivorHud", "GetCenterItemText");

	Params::UmgSurvivorHud_GetCenterItemText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UmgSurvivorHud.HasSecondaryActionAvailable
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUmgSurvivorHud::HasSecondaryActionAvailable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSurvivorHud", "HasSecondaryActionAvailable");

	Params::UmgSurvivorHud_HasSecondaryActionAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UmgSurvivorHud.ShouldUseContextualItemButton
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUmgSurvivorHud::ShouldUseContextualItemButton() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSurvivorHud", "ShouldUseContextualItemButton");

	Params::UmgSurvivorHud_ShouldUseContextualItemButton Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BlueprintPlatformUtilities.ToFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDPerPlatformFloat&      perPlatformFloat                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class UObject*                    objectInWorld                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBlueprintPlatformUtilities::ToFloat(const struct FDBDPerPlatformFloat& perPlatformFloat, const class UObject* objectInWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintPlatformUtilities", "ToFloat");

	Params::BlueprintPlatformUtilities_ToFloat Parms{};

	Parms.perPlatformFloat = std::move(perPlatformFloat);
	Parms.objectInWorld = objectInWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BlueprintPlatformUtilities.ToInteger
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDPerPlatformInt&        perPlatformInt                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const class UObject*                    objectInWorld                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintPlatformUtilities::ToInteger(const struct FDBDPerPlatformInt& perPlatformInt, const class UObject* objectInWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintPlatformUtilities", "ToInteger");

	Params::BlueprintPlatformUtilities_ToInteger Parms{};

	Parms.perPlatformInt = std::move(perPlatformInt);
	Parms.objectInWorld = objectInWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrapUtilities.GetAttachedRBT
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AReverseBearTrap*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AReverseBearTrap* UReverseBearTrapUtilities::GetAttachedRBT(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ReverseBearTrapUtilities", "GetAttachedRBT");

	Params::ReverseBearTrapUtilities_GetAttachedRBT Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BreakableBase.Explode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABreakableBase::Explode(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreakableBase", "Explode");

	Params::BreakableBase_Explode Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BreakableBase.ExplodeVfxSfx
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   impulseDir                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABreakableBase::ExplodeVfxSfx(const struct FVector& impulseDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreakableBase", "ExplodeVfxSfx");

	Params::BreakableBase_ExplodeVfxSfx Parms{};

	Parms.impulseDir = std::move(impulseDir);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.BreakableBase.PlayAudioBreakable
// (Final, Native, Public, BlueprintCallable)

void ABreakableBase::PlayAudioBreakable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreakableBase", "PlayAudioBreakable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BreakableBase.IsUnbroken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABreakableBase::IsUnbroken() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreakableBase", "IsUnbroken");

	Params::BreakableBase_IsUnbroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BubbleIndicator.ActivateBubbleFX
// (Event, Public, BlueprintEvent)
// Parameters:
// const float                             duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABubbleIndicator::ActivateBubbleFX(const float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BubbleIndicator", "ActivateBubbleFX");

	Params::BubbleIndicator_ActivateBubbleFX Parms{};

	Parms.duration = duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.BubbleIndicator.DeactivateBubble
// (Final, Native, Protected, BlueprintCallable)

void ABubbleIndicator::DeactivateBubble()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BubbleIndicator", "DeactivateBubble");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BubbleIndicator.SetSilhouette
// (Event, Public, BlueprintEvent)
// Parameters:
// class UStaticMesh*                      staticMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABubbleIndicator::SetSilhouette(class UStaticMesh* staticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BubbleIndicator", "SetSilhouette");

	Params::BubbleIndicator_SetSilhouette Parms{};

	Parms.staticMesh = staticMesh;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.BubbleIndicatorNotifier.ActivateBubbleIndicator
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          worldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABubbleIndicator*                 bubbleIndicator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    triggerLoudNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   audibleRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBubbleIndicatorNotifier::ActivateBubbleIndicator(class UObject* worldContextObject, class ABubbleIndicator* bubbleIndicator, const struct FTransform& transform, bool triggerLoudNoise, float lifetime, float audibleRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BubbleIndicatorNotifier", "ActivateBubbleIndicator");

	Params::BubbleIndicatorNotifier_ActivateBubbleIndicator Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.bubbleIndicator = bubbleIndicator;
	Parms.transform = std::move(transform);
	Parms.triggerLoudNoise = triggerLoudNoise;
	Parms.lifetime = lifetime;
	Parms.audibleRange = audibleRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.BubbleIndicatorNotifier.PreSpawnBubbleIndicator
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          worldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ABubbleIndicator>     bubbleIndicatorBP                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      silhouetteStaticMesh                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ABubbleIndicator*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABubbleIndicator* UBubbleIndicatorNotifier::PreSpawnBubbleIndicator(class UObject* worldContextObject, TSubclassOf<class ABubbleIndicator> bubbleIndicatorBP, class UStaticMesh* silhouetteStaticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BubbleIndicatorNotifier", "PreSpawnBubbleIndicator");

	Params::BubbleIndicatorNotifier_PreSpawnBubbleIndicator Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.bubbleIndicatorBP = bubbleIndicatorBP;
	Parms.silhouetteStaticMesh = silhouetteStaticMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.BubbleIndicatorNotifier.SpawnBubbleIndicator
// (Final, Native, Static, Private, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          worldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ABubbleIndicator>     bubbleIndicatorBP                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    triggerLoudNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    spawnOnKillerSideOnly                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      silhouetteStaticMesh                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   audibleRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBubbleIndicatorNotifier::SpawnBubbleIndicator(class UObject* worldContextObject, TSubclassOf<class ABubbleIndicator> bubbleIndicatorBP, const struct FTransform& transform, bool triggerLoudNoise, bool spawnOnKillerSideOnly, float lifetime, class UStaticMesh* silhouetteStaticMesh, float audibleRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BubbleIndicatorNotifier", "SpawnBubbleIndicator");

	Params::BubbleIndicatorNotifier_SpawnBubbleIndicator Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.bubbleIndicatorBP = bubbleIndicatorBP;
	Parms.transform = std::move(transform);
	Parms.triggerLoudNoise = triggerLoudNoise;
	Parms.spawnOnKillerSideOnly = spawnOnKillerSideOnly;
	Parms.lifetime = lifetime;
	Parms.silhouetteStaticMesh = silhouetteStaticMesh;
	Parms.audibleRange = audibleRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraAttachmentComponent.Detach
// (Final, Native, Public, BlueprintCallable)

void UCameraAttachmentComponent::Detach()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraAttachmentComponent", "Detach");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraAttachmentComponent.Reset
// (Final, Native, Public, BlueprintCallable)

void UCameraAttachmentComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraAttachmentComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraAttachmentComponent.IsAttached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCameraAttachmentComponent::IsAttached() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraAttachmentComponent", "IsAttached");

	Params::CameraAttachmentComponent_IsAttached Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CameraFadeComponent.OnFadedIn
// (Final, Native, Public, BlueprintCallable)

void UCameraFadeComponent::OnFadedIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraFadeComponent", "OnFadedIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraFadeComponent.OnFadedOut
// (Final, Native, Public, BlueprintCallable)

void UCameraFadeComponent::OnFadedOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraFadeComponent", "OnFadedOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraFadeComponent.GetCameraFadeState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECameraFadeState                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECameraFadeState UCameraFadeComponent::GetCameraFadeState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraFadeComponent", "GetCameraFadeState");

	Params::CameraFadeComponent_GetCameraFadeState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGStoreAuricCellButton.HasBonusExpired
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FDateTime&                 endDate                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUMGStoreAuricCellButton::HasBonusExpired(const struct FDateTime& endDate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGStoreAuricCellButton", "HasBonusExpired");

	Params::UMGStoreAuricCellButton_HasBonusExpired Parms{};

	Parms.endDate = std::move(endDate);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGStoreAuricCellButton.ReportInvalidPercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGStoreAuricCellButton::ReportInvalidPercentage(float percentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGStoreAuricCellButton", "ReportInvalidPercentage");

	Params::UMGStoreAuricCellButton_ReportInvalidPercentage Parms{};

	Parms.percentage = percentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGStoreAuricCellButton.UpdateFirstPurchaseEndInUI
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class FString&                    endInString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGStoreAuricCellButton::UpdateFirstPurchaseEndInUI(const class FString& endInString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGStoreAuricCellButton", "UpdateFirstPurchaseEndInUI");

	Params::UMGStoreAuricCellButton_UpdateFirstPurchaseEndInUI Parms{};

	Parms.endInString = std::move(endInString);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGStoreAuricCellButton.UpdateWidget
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const int32                             multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDateTime&                 endDate                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGStoreAuricCellButton::UpdateWidget(const int32 multiplier, const struct FDateTime& endDate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGStoreAuricCellButton", "UpdateWidget");

	Params::UMGStoreAuricCellButton_UpdateWidget Parms{};

	Parms.multiplier = multiplier;
	Parms.endDate = std::move(endDate);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDAttackUtilities.GetCurrentAttackSubstateRemainingTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     attacker                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDAttackUtilities::GetCurrentAttackSubstateRemainingTime(const class AActor* attacker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDAttackUtilities", "GetCurrentAttackSubstateRemainingTime");

	Params::DBDAttackUtilities_GetCurrentAttackSubstateRemainingTime Parms{};

	Parms.attacker = attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAttackUtilities.GetCurrentAttackType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     attacker                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttackType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAttackType UDBDAttackUtilities::GetCurrentAttackType(const class AActor* attacker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDAttackUtilities", "GetCurrentAttackType");

	Params::DBDAttackUtilities_GetCurrentAttackType Parms{};

	Parms.attacker = attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CameraHandlerComponent.AddCameraToSocket
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDBDCameraSocketID                      mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           camera                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraHandlerComponent::AddCameraToSocket(EDBDCameraSocketID mode, class AActor* camera)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "AddCameraToSocket");

	Params::CameraHandlerComponent_AddCameraToSocket Parms{};

	Parms.mode = mode;
	Parms.camera = camera;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraHandlerComponent.GetCurrentCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UCameraHandlerComponent::GetCurrentCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "GetCurrentCamera");

	Params::CameraHandlerComponent_GetCurrentCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CameraHandlerComponent.GetSocketID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDBDCameraSocketID                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDBDCameraSocketID UCameraHandlerComponent::GetSocketID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "GetSocketID");

	Params::CameraHandlerComponent_GetSocketID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CameraHandlerComponent.PlayVFXOnCurrentCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UParticleSystemComponent*         component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraHandlerComponent::PlayVFXOnCurrentCamera(class UParticleSystemComponent* component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "PlayVFXOnCurrentCamera");

	Params::CameraHandlerComponent_PlayVFXOnCurrentCamera Parms{};

	Parms.component = component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraHandlerComponent.SetAttachmentComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  attachmentComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraHandlerComponent::SetAttachmentComponent(class USceneComponent* attachmentComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "SetAttachmentComponent");

	Params::CameraHandlerComponent_SetAttachmentComponent Parms{};

	Parms.attachmentComponent = attachmentComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraHandlerComponent.SetSocketID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDBDCameraSocketID                      mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraHandlerComponent::SetSocketID(EDBDCameraSocketID mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "SetSocketID");

	Params::CameraHandlerComponent_SetSocketID Parms{};

	Parms.mode = mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CameraHandlerComponent.GetDesiredFOV
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCameraHandlerComponent::GetDesiredFOV() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraHandlerComponent", "GetDesiredFOV");

	Params::CameraHandlerComponent_GetDesiredFOV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAtlantaInputHandler.SetVirtualJoystickCenter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const int32                             controlIndex                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 controlCenter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAtlantaInputHandler::SetVirtualJoystickCenter(const int32 controlIndex, const struct FVector2D& controlCenter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAtlantaInputHandler", "SetVirtualJoystickCenter");

	Params::DBDAtlantaInputHandler_SetVirtualJoystickCenter Parms{};

	Parms.controlIndex = controlIndex;
	Parms.controlCenter = std::move(controlCenter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAtlantaInputHandler.GetVirtualJoystickNormalizedOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             controlIndex                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UDBDAtlantaInputHandler::GetVirtualJoystickNormalizedOffset(const int32 controlIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAtlantaInputHandler", "GetVirtualJoystickNormalizedOffset");

	Params::DBDAtlantaInputHandler_GetVirtualJoystickNormalizedOffset Parms{};

	Parms.controlIndex = controlIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAtlantaInputHandler.GetVirtualJoystickPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             controlIndex                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UDBDAtlantaInputHandler::GetVirtualJoystickPosition(const int32 controlIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAtlantaInputHandler", "GetVirtualJoystickPosition");

	Params::DBDAtlantaInputHandler_GetVirtualJoystickPosition Parms{};

	Parms.controlIndex = controlIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAtlantaInputHandler.GetVirtualJoystickVisualCenter
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             controlIndex                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UDBDAtlantaInputHandler::GetVirtualJoystickVisualCenter(const int32 controlIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAtlantaInputHandler", "GetVirtualJoystickVisualCenter");

	Params::DBDAtlantaInputHandler_GetVirtualJoystickVisualCenter Parms{};

	Parms.controlIndex = controlIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAtlantaInputHandler.GetVirtualJoystickVisualSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             controlIndex                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UDBDAtlantaInputHandler::GetVirtualJoystickVisualSize(const int32 controlIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAtlantaInputHandler", "GetVirtualJoystickVisualSize");

	Params::DBDAtlantaInputHandler_GetVirtualJoystickVisualSize Parms{};

	Parms.controlIndex = controlIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperBloodTrailComponent.OnDamageStateChanged
// (Final, Native, Private)
// Parameters:
// ECamperDamageState                      oldDamageState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECamperDamageState                      currentDamageState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperBloodTrailComponent::OnDamageStateChanged(ECamperDamageState oldDamageState, ECamperDamageState currentDamageState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperBloodTrailComponent", "OnDamageStateChanged");

	Params::CamperBloodTrailComponent_OnDamageStateChanged Parms{};

	Parms.oldDamageState = oldDamageState;
	Parms.currentDamageState = currentDamageState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterDreamworldComponent.GetLocallyObservedOrLocalCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UCharacterDreamworldComponent::GetLocallyObservedOrLocalCharacter(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterDreamworldComponent", "GetLocallyObservedOrLocalCharacter");

	Params::CharacterDreamworldComponent_GetLocallyObservedOrLocalCharacter Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterDreamworldComponent.Authority_SetIsInDreamworld
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    newValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isScripted                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterDreamworldComponent::Authority_SetIsInDreamworld(bool newValue, bool isScripted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDreamworldComponent", "Authority_SetIsInDreamworld");

	Params::CharacterDreamworldComponent_Authority_SetIsInDreamworld Parms{};

	Parms.newValue = newValue;
	Parms.isScripted = isScripted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterDreamworldComponent.FireWakeUpScoreEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterDreamworldComponent::FireWakeUpScoreEvent(class ADBDPlayer* instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDreamworldComponent", "FireWakeUpScoreEvent");

	Params::CharacterDreamworldComponent_FireWakeUpScoreEvent Parms{};

	Parms.instigator = instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterDreamworldComponent.OnRep_IsInDreamworld
// (Final, Native, Private)
// Parameters:
// bool                                    previous                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterDreamworldComponent::OnRep_IsInDreamworld(bool previous)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDreamworldComponent", "OnRep_IsInDreamworld");

	Params::CharacterDreamworldComponent_OnRep_IsInDreamworld Parms{};

	Parms.previous = previous;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterDreamworldComponent.IsInDreamworld
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterDreamworldComponent::IsInDreamworld() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDreamworldComponent", "IsInDreamworld");

	Params::CharacterDreamworldComponent_IsInDreamworld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterDreamworldComponent.ShouldShowVignette
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterDreamworldComponent::ShouldShowVignette() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDreamworldComponent", "ShouldShowVignette");

	Params::CharacterDreamworldComponent_ShouldShowVignette Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperDreamworldComponent.Authority_HandleSkillCheckFailure
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    wakeUpEveryoneInteracting                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperDreamworldComponent::Authority_HandleSkillCheckFailure(bool wakeUpEveryoneInteracting, class ADBDPlayer* instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "Authority_HandleSkillCheckFailure");

	Params::CamperDreamworldComponent_Authority_HandleSkillCheckFailure Parms{};

	Parms.wakeUpEveryoneInteracting = wakeUpEveryoneInteracting;
	Parms.instigator = instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperDreamworldComponent.Authority_OnAttacked
// (Final, Native, Private)

void UCamperDreamworldComponent::Authority_OnAttacked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "Authority_OnAttacked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperDreamworldComponent.Authority_PutAsleep
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UCamperDreamworldComponent::Authority_PutAsleep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "Authority_PutAsleep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperDreamworldComponent.Authority_WakeUpByHook
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UCamperDreamworldComponent::Authority_WakeUpByHook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "Authority_WakeUpByHook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperDreamworldComponent.Authority_WakeUpByOther
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperDreamworldComponent::Authority_WakeUpByOther(class ADBDPlayer* instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "Authority_WakeUpByOther");

	Params::CamperDreamworldComponent_Authority_WakeUpByOther Parms{};

	Parms.instigator = instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperDreamworldComponent.Authority_WakeUpByWakerObject
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UCamperDreamworldComponent::Authority_WakeUpByWakerObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "Authority_WakeUpByWakerObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperDreamworldComponent.BroadcastCamperTriggeredDreamTrap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           dreamObject                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperDreamworldComponent::BroadcastCamperTriggeredDreamTrap(class AActor* dreamObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "BroadcastCamperTriggeredDreamTrap");

	Params::CamperDreamworldComponent_BroadcastCamperTriggeredDreamTrap Parms{};

	Parms.dreamObject = dreamObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperDreamworldComponent.HandleShowKillerChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    showKiller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    instantly                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperDreamworldComponent::HandleShowKillerChanged(bool showKiller, bool instantly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "HandleShowKillerChanged");

	Params::CamperDreamworldComponent_HandleShowKillerChanged Parms{};

	Parms.showKiller = showKiller;
	Parms.instantly = instantly;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.CamperDreamworldComponent.InitializeTunableValues
// (Final, Native, Private)
// Parameters:
// class ASlasherPlayer*                   killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperDreamworldComponent::InitializeTunableValues(class ASlasherPlayer* killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "InitializeTunableValues");

	Params::CamperDreamworldComponent_InitializeTunableValues Parms{};

	Parms.killer = killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperDreamworldComponent.Local_SetShowKiller
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    showKiller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    instantly                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperDreamworldComponent::Local_SetShowKiller(bool showKiller, bool instantly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "Local_SetShowKiller");

	Params::CamperDreamworldComponent_Local_SetShowKiller Parms{};

	Parms.showKiller = showKiller;
	Parms.instantly = instantly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperDreamworldComponent.OnRep_ShowKiller
// (Final, Native, Private)

void UCamperDreamworldComponent::OnRep_ShowKiller()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "OnRep_ShowKiller");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperDreamworldComponent.SetScriptedKillerVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    useScriptedKillerVisibility                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperDreamworldComponent::SetScriptedKillerVisibility(bool useScriptedKillerVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "SetScriptedKillerVisibility");

	Params::CamperDreamworldComponent_SetScriptedKillerVisibility Parms{};

	Parms.useScriptedKillerVisibility = useScriptedKillerVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperDreamworldComponent.Authority_GetFellAsleepCount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCamperDreamworldComponent::Authority_GetFellAsleepCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "Authority_GetFellAsleepCount");

	Params::CamperDreamworldComponent_Authority_GetFellAsleepCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperDreamworldComponent.Authority_GetWakeUpBySkillCheckCount
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCamperDreamworldComponent::Authority_GetWakeUpBySkillCheckCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "Authority_GetWakeUpBySkillCheckCount");

	Params::CamperDreamworldComponent_Authority_GetWakeUpBySkillCheckCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperDreamworldComponent.Authority_SpawnDreamworldStatusEffect
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, Const)

void UCamperDreamworldComponent::Authority_SpawnDreamworldStatusEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "Authority_SpawnDreamworldStatusEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperDreamworldComponent.CanWakeUp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCamperDreamworldComponent::CanWakeUp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "CanWakeUp");

	Params::CamperDreamworldComponent_CanWakeUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperDreamworldComponent.CanWakeUpBySkillCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCamperDreamworldComponent::CanWakeUpBySkillCheck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "CanWakeUpBySkillCheck");

	Params::CamperDreamworldComponent_CanWakeUpBySkillCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperDreamworldComponent.GetWakeUpByOtherCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCamperDreamworldComponent::GetWakeUpByOtherCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "GetWakeUpByOtherCount");

	Params::CamperDreamworldComponent_GetWakeUpByOtherCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperDreamworldComponent.ShouldLookSleepyToLocalPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCamperDreamworldComponent::ShouldLookSleepyToLocalPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperDreamworldComponent", "ShouldLookSleepyToLocalPlayer");

	Params::CamperDreamworldComponent_ShouldLookSleepyToLocalPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperEndGameComponent.OnDelayBeforeSacrificeEnd
// (Final, Native, Private)

void UCamperEndGameComponent::OnDelayBeforeSacrificeEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperEndGameComponent", "OnDelayBeforeSacrificeEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperEndGameComponent.OnEndGameSacrificeEnd
// (Final, Native, Public, BlueprintCallable)

void UCamperEndGameComponent::OnEndGameSacrificeEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperEndGameComponent", "OnEndGameSacrificeEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperEndGameComponent.GetSacrificedByEndGame
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCamperEndGameComponent::GetSacrificedByEndGame() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperEndGameComponent", "GetSacrificedByEndGame");

	Params::CamperEndGameComponent_GetSacrificedByEndGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGPlayerStatusIcon.OnPlayerStatusButtonClicked
// (Final, Native, Public, BlueprintCallable)

void UUMGPlayerStatusIcon::OnPlayerStatusButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPlayerStatusIcon", "OnPlayerStatusButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGPlayerStatusIcon.SetReverseTrapProgressionTimer
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGPlayerStatusIcon::SetReverseTrapProgressionTimer(float seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPlayerStatusIcon", "SetReverseTrapProgressionTimer");

	Params::UMGPlayerStatusIcon_SetReverseTrapProgressionTimer Parms{};

	Parms.seconds = seconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGPlayerStatusIcon.SetSleepingTimer
// (Event, Public, BlueprintEvent)
// Parameters:
// const float                             progress                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGPlayerStatusIcon::SetSleepingTimer(const float progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPlayerStatusIcon", "SetSleepingTimer");

	Params::UMGPlayerStatusIcon_SetSleepingTimer Parms{};

	Parms.progress = progress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDCharacterMovementUtilities.Local_AddMaxSpeedMultiplierCurve
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCurveFloat*                curve                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    autoReset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementUtilities::Local_AddMaxSpeedMultiplierCurve(class ACharacter* character, const class UCurveFloat* curve, float duration, bool autoReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterMovementUtilities", "Local_AddMaxSpeedMultiplierCurve");

	Params::DBDCharacterMovementUtilities_Local_AddMaxSpeedMultiplierCurve Parms{};

	Parms.character = character;
	Parms.curve = curve;
	Parms.duration = duration;
	Parms.autoReset = autoReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementUtilities.Local_RemoveMaxSpeedMultiplierCurve
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCurveFloat*                curveToReset                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementUtilities::Local_RemoveMaxSpeedMultiplierCurve(class ACharacter* character, const class UCurveFloat* curveToReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterMovementUtilities", "Local_RemoveMaxSpeedMultiplierCurve");

	Params::DBDCharacterMovementUtilities_Local_RemoveMaxSpeedMultiplierCurve Parms{};

	Parms.character = character;
	Parms.curveToReset = curveToReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperExposerInstance.ExitSequenceComplete
// (Final, Native, Public, BlueprintCallable)

void ACamperExposerInstance::ExitSequenceComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperExposerInstance", "ExitSequenceComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperExposerInstance.SetIsInteriorBP
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    interior                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperExposerInstance::SetIsInteriorBP(bool interior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperExposerInstance", "SetIsInteriorBP");

	Params::CamperExposerInstance_SetIsInteriorBP Parms{};

	Parms.interior = interior;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.CamperExposerInstance.StartExitSequence
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    withRandomDelay                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperExposerInstance::StartExitSequence(bool withRandomDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperExposerInstance", "StartExitSequence");

	Params::CamperExposerInstance_StartExitSequence Parms{};

	Parms.withRandomDelay = withRandomDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperExposerInstance.StartSpawnSequence
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    withRandomDelay                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperExposerInstance::StartSpawnSequence(bool withRandomDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperExposerInstance", "StartSpawnSequence");

	Params::CamperExposerInstance_StartSpawnSequence Parms{};

	Parms.withRandomDelay = withRandomDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Authority_ApplyDamage
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           damageSource                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       damagePlayerOwner                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperHealthComponent::Authority_ApplyDamage(class AActor* damageSource, class ACharacter* damagePlayerOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Authority_ApplyDamage");

	Params::CamperHealthComponent_Authority_ApplyDamage Parms{};

	Parms.damageSource = damageSource;
	Parms.damagePlayerOwner = damagePlayerOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Authority_ApplyDeepWound
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           damageSource                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       damagePlayerOwner                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperHealthComponent::Authority_ApplyDeepWound(class AActor* damageSource, class ACharacter* damagePlayerOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Authority_ApplyDeepWound");

	Params::CamperHealthComponent_Authority_ApplyDeepWound Parms{};

	Parms.damageSource = damageSource;
	Parms.damagePlayerOwner = damagePlayerOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Authority_ApplyDoubleDamage
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           damageSource                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       damagePlayerOwner                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperHealthComponent::Authority_ApplyDoubleDamage(class AActor* damageSource, class ACharacter* damagePlayerOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Authority_ApplyDoubleDamage");

	Params::CamperHealthComponent_Authority_ApplyDoubleDamage Parms{};

	Parms.damageSource = damageSource;
	Parms.damagePlayerOwner = damagePlayerOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Authority_EndInjuredBleedout
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UCamperHealthComponent::Authority_EndInjuredBleedout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Authority_EndInjuredBleedout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Authority_HealTryGrantScoresOnChargeApplied
// (Final, Native, Protected)
// Parameters:
// float                                   individualChargeAmount                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   totalChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           chargeInstigator                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    wasCoop                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   deltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperHealthComponent::Authority_HealTryGrantScoresOnChargeApplied(float individualChargeAmount, float totalChargeAmount, class AActor* chargeInstigator, bool wasCoop, float deltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Authority_HealTryGrantScoresOnChargeApplied");

	Params::CamperHealthComponent_Authority_HealTryGrantScoresOnChargeApplied Parms{};

	Parms.individualChargeAmount = individualChargeAmount;
	Parms.totalChargeAmount = totalChargeAmount;
	Parms.chargeInstigator = chargeInstigator;
	Parms.wasCoop = wasCoop;
	Parms.deltaTime = deltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Authority_MendTryGrantScoresOnChargeApplied
// (Final, Native, Protected)
// Parameters:
// float                                   individualChargeAmount                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   totalChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           chargeInstigator                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    wasCoop                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   deltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperHealthComponent::Authority_MendTryGrantScoresOnChargeApplied(float individualChargeAmount, float totalChargeAmount, class AActor* chargeInstigator, bool wasCoop, float deltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Authority_MendTryGrantScoresOnChargeApplied");

	Params::CamperHealthComponent_Authority_MendTryGrantScoresOnChargeApplied Parms{};

	Parms.individualChargeAmount = individualChargeAmount;
	Parms.totalChargeAmount = totalChargeAmount;
	Parms.chargeInstigator = chargeInstigator;
	Parms.wasCoop = wasCoop;
	Parms.deltaTime = deltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Authority_OnHealthBarCharged
// (Final, Native, Public, HasOutParams)
// Parameters:
// bool                                    complete                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            instigators                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCamperHealthComponent::Authority_OnHealthBarCharged(bool complete, const TArray<class AActor*>& instigators)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Authority_OnHealthBarCharged");

	Params::CamperHealthComponent_Authority_OnHealthBarCharged Parms{};

	Parms.complete = complete;
	Parms.instigators = std::move(instigators);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Authority_OnMendChargeCompletionStateChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// bool                                    complete                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            instigators                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCamperHealthComponent::Authority_OnMendChargeCompletionStateChanged(bool complete, const TArray<class AActor*>& instigators)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Authority_OnMendChargeCompletionStateChanged");

	Params::CamperHealthComponent_Authority_OnMendChargeCompletionStateChanged Parms{};

	Parms.complete = complete;
	Parms.instigators = std::move(instigators);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Authority_OnSurvivorRemoved
// (Final, Native, Private)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperHealthComponent::Authority_OnSurvivorRemoved(class ACamperPlayer* survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Authority_OnSurvivorRemoved");

	Params::CamperHealthComponent_Authority_OnSurvivorRemoved Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Authority_SetDamageState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// ECamperDamageState                      damageState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    fireScoreEvent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    sacrificed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperHealthComponent::Authority_SetDamageState(ECamperDamageState damageState, bool fireScoreEvent, bool sacrificed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Authority_SetDamageState");

	Params::CamperHealthComponent_Authority_SetDamageState Parms{};

	Parms.damageState = damageState;
	Parms.fireScoreEvent = fireScoreEvent;
	Parms.sacrificed = sacrificed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.GetCurrentHPSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UChargeableComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableComponent* UCamperHealthComponent::GetCurrentHPSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "GetCurrentHPSlot");

	Params::CamperHealthComponent_GetCurrentHPSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperHealthComponent.IncreaseHPSlotSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperHealthComponent::IncreaseHPSlotSize(float percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "IncreaseHPSlotSize");

	Params::CamperHealthComponent_IncreaseHPSlotSize Parms{};

	Parms.percent = percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Multicast_OnHealed
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const struct FCamperHealResult&         healResult                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UCamperHealthComponent::Multicast_OnHealed(const struct FCamperHealResult& healResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Multicast_OnHealed");

	Params::CamperHealthComponent_Multicast_OnHealed Parms{};

	Parms.healResult = std::move(healResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Multicast_OnInjuredBleedoutKO
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ADBDPlayer*                       injuredBleedoutInstigator                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperHealthComponent::Multicast_OnInjuredBleedoutKO(class ADBDPlayer* injuredBleedoutInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Multicast_OnInjuredBleedoutKO");

	Params::CamperHealthComponent_Multicast_OnInjuredBleedoutKO Parms{};

	Parms.injuredBleedoutInstigator = injuredBleedoutInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Multicast_OnSurvivorGainedHealthStateByOthersEvents
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const bool                              healedFromKO                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       healedSurvivor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class ADBDPlayer*>&        healers                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<bool>&                     healedSurvivorFarEnoughAway                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCamperHealthComponent::Multicast_OnSurvivorGainedHealthStateByOthersEvents(const bool healedFromKO, class ADBDPlayer* healedSurvivor, const TArray<class ADBDPlayer*>& healers, const TArray<bool>& healedSurvivorFarEnoughAway)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Multicast_OnSurvivorGainedHealthStateByOthersEvents");

	Params::CamperHealthComponent_Multicast_OnSurvivorGainedHealthStateByOthersEvents Parms{};

	Parms.healedFromKO = healedFromKO;
	Parms.healedSurvivor = healedSurvivor;
	Parms.healers = std::move(healers);
	Parms.healedSurvivorFarEnoughAway = std::move(healedSurvivorFarEnoughAway);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Multicast_SetCurrentHealthStateCount
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// int32                                   newHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    fireScoreEvent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperHealthComponent::Multicast_SetCurrentHealthStateCount(int32 newHealth, bool fireScoreEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Multicast_SetCurrentHealthStateCount");

	Params::CamperHealthComponent_Multicast_SetCurrentHealthStateCount Parms{};

	Parms.newHealth = newHealth;
	Parms.fireScoreEvent = fireScoreEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Multicast_SetDamageState
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// ECamperDamageState                      damageState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    fireScoreEvent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    sacrificed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperHealthComponent::Multicast_SetDamageState(ECamperDamageState damageState, bool fireScoreEvent, bool sacrificed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Multicast_SetDamageState");

	Params::CamperHealthComponent_Multicast_SetDamageState Parms{};

	Parms.damageState = damageState;
	Parms.fireScoreEvent = fireScoreEvent;
	Parms.sacrificed = sacrificed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Multicast_SetHealthStateFromDamageState
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// ECamperDamageState                      damageState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    fireScoreEvent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperHealthComponent::Multicast_SetHealthStateFromDamageState(ECamperDamageState damageState, bool fireScoreEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Multicast_SetHealthStateFromDamageState");

	Params::CamperHealthComponent_Multicast_SetHealthStateFromDamageState Parms{};

	Parms.damageState = damageState;
	Parms.fireScoreEvent = fireScoreEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.Multicast_SetHealthType
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EHealthType                             healthType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperHealthComponent::Multicast_SetHealthType(EHealthType healthType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "Multicast_SetHealthType");

	Params::CamperHealthComponent_Multicast_SetHealthType Parms{};

	Parms.healthType = healthType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.OnImmobilizedStateChanged
// (Final, Native, Private)
// Parameters:
// const ECamperImmobilizeState            oldImmobilizeState                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ECamperImmobilizeState            newImmobilizeState                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperHealthComponent::OnImmobilizedStateChanged(const ECamperImmobilizeState oldImmobilizeState, const ECamperImmobilizeState newImmobilizeState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "OnImmobilizedStateChanged");

	Params::CamperHealthComponent_OnImmobilizedStateChanged Parms{};

	Parms.oldImmobilizeState = oldImmobilizeState;
	Parms.newImmobilizeState = newImmobilizeState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.OnRep_InInjuredBleedOut
// (Final, Native, Private)

void UCamperHealthComponent::OnRep_InInjuredBleedOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "OnRep_InInjuredBleedOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.SetCanBleedout
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    canBleedout                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperHealthComponent::SetCanBleedout(bool canBleedout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "SetCanBleedout");

	Params::CamperHealthComponent_SetCanBleedout Parms{};

	Parms.canBleedout = canBleedout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperHealthComponent.CanBecomeHealthy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCamperHealthComponent::CanBecomeHealthy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "CanBecomeHealthy");

	Params::CamperHealthComponent_CanBecomeHealthy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperHealthComponent.CanBeHealed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCamperHealthComponent::CanBeHealed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "CanBeHealed");

	Params::CamperHealthComponent_CanBeHealed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperHealthComponent.CanBeHealedFromInjured
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCamperHealthComponent::CanBeHealedFromInjured() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "CanBeHealedFromInjured");

	Params::CamperHealthComponent_CanBeHealedFromInjured Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperHealthComponent.CanHealSelf
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCamperHealthComponent::CanHealSelf() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "CanHealSelf");

	Params::CamperHealthComponent_CanHealSelf Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperHealthComponent.GetCurrentTotalHealthBarPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCamperHealthComponent::GetCurrentTotalHealthBarPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "GetCurrentTotalHealthBarPercent");

	Params::CamperHealthComponent_GetCurrentTotalHealthBarPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperHealthComponent.GetDamageState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECamperDamageState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECamperDamageState UCamperHealthComponent::GetDamageState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "GetDamageState");

	Params::CamperHealthComponent_GetDamageState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperHealthComponent.GetPercentDyingTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCamperHealthComponent::GetPercentDyingTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "GetPercentDyingTimer");

	Params::CamperHealthComponent_GetPercentDyingTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperHealthComponent.GetPercentInjuredBleedoutTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCamperHealthComponent::GetPercentInjuredBleedoutTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "GetPercentInjuredBleedoutTimer");

	Params::CamperHealthComponent_GetPercentInjuredBleedoutTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperHealthComponent.IsDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCamperHealthComponent::IsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "IsDead");

	Params::CamperHealthComponent_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperHealthComponent.IsDyingTimerExpired
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCamperHealthComponent::IsDyingTimerExpired() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "IsDyingTimerExpired");

	Params::CamperHealthComponent_IsDyingTimerExpired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperHealthComponent.IsHealthy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCamperHealthComponent::IsHealthy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "IsHealthy");

	Params::CamperHealthComponent_IsHealthy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperHealthComponent.IsInInjuredBleedout
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCamperHealthComponent::IsInInjuredBleedout() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "IsInInjuredBleedout");

	Params::CamperHealthComponent_IsInInjuredBleedout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperHealthComponent.IsInjured
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCamperHealthComponent::IsInjured() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "IsInjured");

	Params::CamperHealthComponent_IsInjured Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperHealthComponent.IsInjuredBleedoutTimerExpired
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCamperHealthComponent::IsInjuredBleedoutTimerExpired() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "IsInjuredBleedoutTimerExpired");

	Params::CamperHealthComponent_IsInjuredBleedoutTimerExpired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperHealthComponent.IsKO
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCamperHealthComponent::IsKO() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperHealthComponent", "IsKO");

	Params::CamperHealthComponent_IsKO Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractable.InitInteractable
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerInteractable::InitInteractable(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractable", "InitInteractable");

	Params::PlayerInteractable_InitInteractable Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperInteractable.ServerMoveOut
// (Final, Net, Native, Event, Private, NetServer, NetValidate)

void ACamperInteractable::ServerMoveOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperInteractable", "ServerMoveOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperInteractable.SetKillInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionDefinition*           killInteraction                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperInteractable::SetKillInteraction(class UInteractionDefinition* killInteraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperInteractable", "SetKillInteraction");

	Params::CamperInteractable_SetKillInteraction Parms{};

	Parms.killInteraction = killInteraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperInteractable.UpdateTargetHPSlot
// (Final, Native, Private)

void ACamperInteractable::UpdateTargetHPSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperInteractable", "UpdateTargetHPSlot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperInteractable.GetOwningSurvivor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACamperPlayer*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACamperPlayer* ACamperInteractable::GetOwningSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperInteractable", "GetOwningSurvivor");

	Params::CamperInteractable_GetOwningSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperInteractable.GetSlasherInteractor
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UInteractor*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractor* ACamperInteractable::GetSlasherInteractor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperInteractable", "GetSlasherInteractor");

	Params::CamperInteractable_GetSlasherInteractor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperMaterialHelperController.AddManagedGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    group                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperMaterialHelperController::AddManagedGroup(class UObject* source, const class FString& group)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperMaterialHelperController", "AddManagedGroup");

	Params::CamperMaterialHelperController_AddManagedGroup Parms{};

	Parms.source = source;
	Parms.group = std::move(group);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperMaterialHelperController.AddManagedWithCondition
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    group                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void()>&                condition                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCamperMaterialHelperController::AddManagedWithCondition(class UObject* source, const class FString& group, const TDelegate<void()>& condition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperMaterialHelperController", "AddManagedWithCondition");

	Params::CamperMaterialHelperController_AddManagedWithCondition Parms{};

	Parms.source = source;
	Parms.group = std::move(group);
	Parms.condition = condition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperMaterialHelperController.RemoveGroupsBySource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperMaterialHelperController::RemoveGroupsBySource(class UObject* source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperMaterialHelperController", "RemoveGroupsBySource");

	Params::CamperMaterialHelperController_RemoveGroupsBySource Parms{};

	Parms.source = source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerData.Server_CampaignDataSynced
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UDBDPlayerData::Server_CampaignDataSynced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "Server_CampaignDataSynced");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerData.Server_LoadoutSpawned
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UDBDPlayerData::Server_LoadoutSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "Server_LoadoutSpawned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerData.Server_NotifyAIPawnSpawned
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UDBDPlayerData::Server_NotifyAIPawnSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "Server_NotifyAIPawnSpawned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerData.Server_RenderingFeaturesCompleted
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UDBDPlayerData::Server_RenderingFeaturesCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "Server_RenderingFeaturesCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerData.Server_SetIntroCompleted
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UDBDPlayerData::Server_SetIntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "Server_SetIntroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerData.Server_SetPlayerReady
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UDBDPlayerData::Server_SetPlayerReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "Server_SetPlayerReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerData.GetControlRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UDBDPlayerData::GetControlRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "GetControlRotation");

	Params::DBDPlayerData_GetControlRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerData.GetUseInputPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDPlayerData::GetUseInputPressed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "GetUseInputPressed");

	Params::DBDPlayerData_GetUseInputPressed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerData.IsInteractionInputPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDPlayerData::IsInteractionInputPressed(EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerData", "IsInteractionInputPressed");

	Params::DBDPlayerData_IsInteractionInputPressed Parms{};

	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Client_PreventMovement
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// const bool                              value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Client_PreventMovement(const bool value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Client_PreventMovement");

	Params::DBDCharacterMovementComponent_Client_PreventMovement Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Client_Stop
// (Net, NetReliable, Native, Event, Protected, NetClient)

void UDBDCharacterMovementComponent::Client_Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Client_Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Client_TeleportTo
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// const struct FVector_NetQuantize100&    location                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FYawAndPitchRotator_NetQuantize32&rotation                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Client_TeleportTo(const struct FVector_NetQuantize100& location, const struct FYawAndPitchRotator_NetQuantize32& rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Client_TeleportTo");

	Params::DBDCharacterMovementComponent_Client_TeleportTo Parms{};

	Parms.location = std::move(location);
	Parms.rotation = std::move(rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.DBD_SimulateHack_LocalLaunch
// (Final, Exec, Native, Private)
// Parameters:
// const float                             xVelocity                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             yVelocity                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             zVelocity                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::DBD_SimulateHack_LocalLaunch(const float xVelocity, const float yVelocity, const float zVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "DBD_SimulateHack_LocalLaunch");

	Params::DBDCharacterMovementComponent_DBD_SimulateHack_LocalLaunch Parms{};

	Parms.xVelocity = xVelocity;
	Parms.yVelocity = yVelocity;
	Parms.zVelocity = zVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.DBD_SimulateHack_LocalSurvivorMaxSpeedMultiplierUsingServerRPC
// (Final, Exec, Native, Private)
// Parameters:
// const float                             maxSpeedMultiplier                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::DBD_SimulateHack_LocalSurvivorMaxSpeedMultiplierUsingServerRPC(const float maxSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "DBD_SimulateHack_LocalSurvivorMaxSpeedMultiplierUsingServerRPC");

	Params::DBDCharacterMovementComponent_DBD_SimulateHack_LocalSurvivorMaxSpeedMultiplierUsingServerRPC Parms{};

	Parms.maxSpeedMultiplier = maxSpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.OnMontageStarted
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FMontagePlaybackDefinition&montageDefinition                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class UAnimMontage*               montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::OnMontageStarted(const struct FMontagePlaybackDefinition& montageDefinition, const class UAnimMontage* montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "OnMontageStarted");

	Params::DBDCharacterMovementComponent_OnMontageStarted Parms{};

	Parms.montageDefinition = std::move(montageDefinition);
	Parms.montage = montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.OnPreMontageStop
// (Final, Native, Private)
// Parameters:
// const struct FMontageStopDefinition&    montageDefinition                                      (ConstParm, Parm, NativeAccessSpecifierPublic)
// const class UAnimMontage*               montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::OnPreMontageStop(const struct FMontageStopDefinition& montageDefinition, const class UAnimMontage* montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "OnPreMontageStop");

	Params::DBDCharacterMovementComponent_OnPreMontageStop Parms{};

	Parms.montageDefinition = std::move(montageDefinition);
	Parms.montage = montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_AddMaxSpeedMovementCurve
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const uint32                            curveNetId                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   startOffset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EMovementCurveType                movementCurveType                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_AddMaxSpeedMovementCurve(float timestamp, const uint32 curveNetId, float duration, float startOffset, const EMovementCurveType movementCurveType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_AddMaxSpeedMovementCurve");

	Params::DBDCharacterMovementComponent_Server_AddMaxSpeedMovementCurve Parms{};

	Parms.timestamp = timestamp;
	Parms.curveNetId = curveNetId;
	Parms.duration = duration;
	Parms.startOffset = startOffset;
	Parms.movementCurveType = movementCurveType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_Launch
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// float                                   timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   launchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   launchCallCount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_Launch(float timestamp, const struct FVector& launchVelocity, int32 launchCallCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_Launch");

	Params::DBDCharacterMovementComponent_Server_Launch Parms{};

	Parms.timestamp = timestamp;
	Parms.launchVelocity = std::move(launchVelocity);
	Parms.launchCallCount = launchCallCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_PlayMontage
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMontagePlaybackDefinition&montagePlaybackDefinition                              (ConstParm, Parm, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_PlayMontage(float timestamp, const struct FMontagePlaybackDefinition& montagePlaybackDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_PlayMontage");

	Params::DBDCharacterMovementComponent_Server_PlayMontage Parms{};

	Parms.timestamp = timestamp;
	Parms.montagePlaybackDefinition = std::move(montagePlaybackDefinition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_RemoveMaxSpeedMovementCurve
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const uint32                            curveNetId                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EMovementCurveType                movementCurveType                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_RemoveMaxSpeedMovementCurve(float timestamp, const uint32 curveNetId, const EMovementCurveType movementCurveType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_RemoveMaxSpeedMovementCurve");

	Params::DBDCharacterMovementComponent_Server_RemoveMaxSpeedMovementCurve Parms{};

	Parms.timestamp = timestamp;
	Parms.curveNetId = curveNetId;
	Parms.movementCurveType = movementCurveType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_ReplicateControlRotation
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// uint8                                   clientRoll                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  view                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_ReplicateControlRotation(uint8 clientRoll, uint32 view)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_ReplicateControlRotation");

	Params::DBDCharacterMovementComponent_Server_ReplicateControlRotation Parms{};

	Parms.clientRoll = clientRoll;
	Parms.view = view;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_SetAdditiveMaxSpeedScalar
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_SetAdditiveMaxSpeedScalar(float timestamp, float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_SetAdditiveMaxSpeedScalar");

	Params::DBDCharacterMovementComponent_Server_SetAdditiveMaxSpeedScalar Parms{};

	Parms.timestamp = timestamp;
	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_SetGroundFriction
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_SetGroundFriction(float timestamp, float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_SetGroundFriction");

	Params::DBDCharacterMovementComponent_Server_SetGroundFriction Parms{};

	Parms.timestamp = timestamp;
	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_SetIgnorePawnCollisionOverride
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isIgnoringPawnCollision                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_SetIgnorePawnCollisionOverride(float timestamp, bool isIgnoringPawnCollision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_SetIgnorePawnCollisionOverride");

	Params::DBDCharacterMovementComponent_Server_SetIgnorePawnCollisionOverride Parms{};

	Parms.timestamp = timestamp;
	Parms.isIgnoringPawnCollision = isIgnoringPawnCollision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_SetMaxAcceleration
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_SetMaxAcceleration(float timestamp, float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_SetMaxAcceleration");

	Params::DBDCharacterMovementComponent_Server_SetMaxAcceleration Parms{};

	Parms.timestamp = timestamp;
	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_SetMaxSpeedMultiplierScalar
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_SetMaxSpeedMultiplierScalar(float timestamp, float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_SetMaxSpeedMultiplierScalar");

	Params::DBDCharacterMovementComponent_Server_SetMaxSpeedMultiplierScalar Parms{};

	Parms.timestamp = timestamp;
	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_SetMaxSpeedOverride
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isSet                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_SetMaxSpeedOverride(float timestamp, float value, bool isSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_SetMaxSpeedOverride");

	Params::DBDCharacterMovementComponent_Server_SetMaxSpeedOverride Parms{};

	Parms.timestamp = timestamp;
	Parms.value = value;
	Parms.isSet = isSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_SetStopSnapping
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              snapToFinalDestination                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_SetStopSnapping(float timestamp, const bool snapToFinalDestination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_SetStopSnapping");

	Params::DBDCharacterMovementComponent_Server_SetStopSnapping Parms{};

	Parms.timestamp = timestamp;
	Parms.snapToFinalDestination = snapToFinalDestination;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_StartSnapping
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSnappingData&             data                                                   (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   snappingCallCount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_StartSnapping(float timestamp, const struct FSnappingData& data, int32 snappingCallCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_StartSnapping");

	Params::DBDCharacterMovementComponent_Server_StartSnapping Parms{};

	Parms.timestamp = timestamp;
	Parms.data = std::move(data);
	Parms.snappingCallCount = snappingCallCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDCharacterMovementComponent.Server_StopMontage
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   timestamp                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMontageStopDefinition&    montageStopDefinition                                  (ConstParm, Parm, NativeAccessSpecifierPublic)

void UDBDCharacterMovementComponent::Server_StopMontage(float timestamp, const struct FMontageStopDefinition& montageStopDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDCharacterMovementComponent", "Server_StopMontage");

	Params::DBDCharacterMovementComponent_Server_StopMontage Parms{};

	Parms.timestamp = timestamp;
	Parms.montageStopDefinition = std::move(montageStopDefinition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperMovementComponent.Client_Debug_SetSurvivorMaxSpeedMultiplier
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const float                             maxSpeedMultiplier                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperMovementComponent::Client_Debug_SetSurvivorMaxSpeedMultiplier(const float maxSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperMovementComponent", "Client_Debug_SetSurvivorMaxSpeedMultiplier");

	Params::CamperMovementComponent_Client_Debug_SetSurvivorMaxSpeedMultiplier Parms{};

	Parms.maxSpeedMultiplier = maxSpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperMovementComponent.DBD_SimulateHack_LocalSurvivorMaxSpeedMultiplier
// (Final, Exec, Native, Private)
// Parameters:
// const float                             maxSpeedMultiplier                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperMovementComponent::DBD_SimulateHack_LocalSurvivorMaxSpeedMultiplier(const float maxSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperMovementComponent", "DBD_SimulateHack_LocalSurvivorMaxSpeedMultiplier");

	Params::CamperMovementComponent_DBD_SimulateHack_LocalSurvivorMaxSpeedMultiplier Parms{};

	Parms.maxSpeedMultiplier = maxSpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperMovementComponent.DBD_SurvivorMaxSpeedMultiplier
// (Final, Exec, Native, Private)
// Parameters:
// const float                             maxSpeedMultiplier                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperMovementComponent::DBD_SurvivorMaxSpeedMultiplier(const float maxSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperMovementComponent", "DBD_SurvivorMaxSpeedMultiplier");

	Params::CamperMovementComponent_DBD_SurvivorMaxSpeedMultiplier Parms{};

	Parms.maxSpeedMultiplier = maxSpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperMovementComponent.OnCamperHealthStateChanged
// (Final, Native, Public)
// Parameters:
// ECamperDamageState                      oldDamageState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECamperDamageState                      currentDamageState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperMovementComponent::OnCamperHealthStateChanged(ECamperDamageState oldDamageState, ECamperDamageState currentDamageState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperMovementComponent", "OnCamperHealthStateChanged");

	Params::CamperMovementComponent_OnCamperHealthStateChanged Parms{};

	Parms.oldDamageState = oldDamageState;
	Parms.currentDamageState = currentDamageState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperMovementComponent.GetDefaultRotationRate
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UCamperMovementComponent::GetDefaultRotationRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperMovementComponent", "GetDefaultRotationRate");

	Params::CamperMovementComponent_GetDefaultRotationRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperMovementComponent.GetDropStaggerTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCamperMovementComponent::GetDropStaggerTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperMovementComponent", "GetDropStaggerTimeLeft");

	Params::CamperMovementComponent_GetDropStaggerTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperMovementComponent.GetRotationRateWhileCrawling
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UCamperMovementComponent::GetRotationRateWhileCrawling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperMovementComponent", "GetRotationRateWhileCrawling");

	Params::CamperMovementComponent_GetRotationRateWhileCrawling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReportPlayerPopupScreen.OnConfirmReportPlayer
// (Final, Native, Private)
// Parameters:
// const class FString&                    category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    comment                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReportPlayerPopupScreen::OnConfirmReportPlayer(const class FString& category, const class FString& comment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReportPlayerPopupScreen", "OnConfirmReportPlayer");

	Params::ReportPlayerPopupScreen_OnConfirmReportPlayer Parms{};

	Parms.category = std::move(category);
	Parms.comment = std::move(comment);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReportPlayerPopupScreen.OnTextInputMouseOver
// (Final, Native, Private)
// Parameters:
// bool                                    isMouseOver                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UReportPlayerPopupScreen::OnTextInputMouseOver(bool isMouseOver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReportPlayerPopupScreen", "OnTextInputMouseOver");

	Params::ReportPlayerPopupScreen_OnTextInputMouseOver Parms{};

	Parms.isMouseOver = isMouseOver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDBasePlayer.DBD_SwapCosmetics
// (Final, Exec, Native, Protected)
// Parameters:
// class FName                             cosmeticId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDBasePlayer::DBD_SwapCosmetics(class FName cosmeticId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "DBD_SwapCosmetics");

	Params::DBDBasePlayer_DBD_SwapCosmetics Parms{};

	Parms.cosmeticId = cosmeticId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDBasePlayer.Multicast_SwapCosmetics
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class FName                             cosmeticId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDBasePlayer::Multicast_SwapCosmetics(class FName cosmeticId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "Multicast_SwapCosmetics");

	Params::DBDBasePlayer_Multicast_SwapCosmetics Parms{};

	Parms.cosmeticId = cosmeticId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDBasePlayer.TeleportWithClothHandling
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    checkCollisions                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDBasePlayer::TeleportWithClothHandling(const struct FVector& location, const struct FRotator& rotation, bool checkCollisions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "TeleportWithClothHandling");

	Params::DBDBasePlayer_TeleportWithClothHandling Parms{};

	Parms.location = std::move(location);
	Parms.rotation = std::move(rotation);
	Parms.checkCollisions = checkCollisions;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetAudioComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAkComponent*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkComponent* ADBDBasePlayer::GetAudioComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetAudioComponent");

	Params::DBDBasePlayer_GetAudioComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetCharacterIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADBDBasePlayer::GetCharacterIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetCharacterIndex");

	Params::DBDBasePlayer_GetCharacterIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetCharacterName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ADBDBasePlayer::GetCharacterName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetCharacterName");

	Params::DBDBasePlayer_GetCharacterName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetCustomizedAudio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCustomizedAudioComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCustomizedAudioComponent* ADBDBasePlayer::GetCustomizedAudio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetCustomizedAudio");

	Params::DBDBasePlayer_GetCustomizedAudio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetCustomizedSkeletalMesh
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UCustomizedSkeletalMesh*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCustomizedSkeletalMesh* ADBDBasePlayer::GetCustomizedSkeletalMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetCustomizedSkeletalMesh");

	Params::DBDBasePlayer_GetCustomizedSkeletalMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetLeftFootAudioSurfaceName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ADBDBasePlayer::GetLeftFootAudioSurfaceName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetLeftFootAudioSurfaceName");

	Params::DBDBasePlayer_GetLeftFootAudioSurfaceName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetLeftFootSurfaceType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPhysicalSurface                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPhysicalSurface ADBDBasePlayer::GetLeftFootSurfaceType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetLeftFootSurfaceType");

	Params::DBDBasePlayer_GetLeftFootSurfaceType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetRightFootAudioSurfaceName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ADBDBasePlayer::GetRightFootAudioSurfaceName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetRightFootAudioSurfaceName");

	Params::DBDBasePlayer_GetRightFootAudioSurfaceName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetRightFootSurfaceType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPhysicalSurface                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPhysicalSurface ADBDBasePlayer::GetRightFootSurfaceType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetRightFootSurfaceType");

	Params::DBDBasePlayer_GetRightFootSurfaceType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetSemanticTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer ADBDBasePlayer::GetSemanticTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetSemanticTag");

	Params::DBDBasePlayer_GetSemanticTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBasePlayer.GetShowBlindDebugInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDBasePlayer::GetShowBlindDebugInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBasePlayer", "GetShowBlindDebugInfo");

	Params::DBDBasePlayer_GetShowBlindDebugInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGAtlantaLegalMenuScreen.HandleMenuButtonClickEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    isAccept                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaLegalMenuScreen::HandleMenuButtonClickEvent(bool isAccept)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaLegalMenuScreen", "HandleMenuButtonClickEvent");

	Params::UMGAtlantaLegalMenuScreen_HandleMenuButtonClickEvent Parms{};

	Parms.isAccept = isAccept;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaLegalMenuScreen.SetButtonText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      acceptText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      declineText                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGAtlantaLegalMenuScreen::SetButtonText(const class FText& acceptText, const class FText& declineText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaLegalMenuScreen", "SetButtonText");

	Params::UMGAtlantaLegalMenuScreen_SetButtonText Parms{};

	Parms.acceptText = std::move(acceptText);
	Parms.declineText = std::move(declineText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGAtlantaLegalMenuScreen.SetLegalText
// (Event, Public, BlueprintEvent)
// Parameters:
// const class FString&                    title                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    legalText                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaLegalMenuScreen::SetLegalText(const class FString& title, const class FString& legalText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaLegalMenuScreen", "SetLegalText");

	Params::UMGAtlantaLegalMenuScreen_SetLegalText Parms{};

	Parms.title = std::move(title);
	Parms.legalText = std::move(legalText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDPlayer.AbilityInputReleased
// (Final, Native, Public, BlueprintCallable)

void ADBDPlayer::AbilityInputReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "AbilityInputReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.AbilityTwoInputPressed
// (Final, Native, Public, BlueprintCallable)

void ADBDPlayer::AbilityTwoInputPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "AbilityTwoInputPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.AbilityTwoInputReleased
// (Final, Native, Public, BlueprintCallable)

void ADBDPlayer::AbilityTwoInputReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "AbilityTwoInputReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.AddDetectionZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDetectionZone                          detectionZoneID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              zone                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::AddDetectionZone(EDetectionZone detectionZoneID, class UPrimitiveComponent* zone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "AddDetectionZone");

	Params::DBDPlayer_AddDetectionZone Parms{};

	Parms.detectionZoneID = detectionZoneID;
	Parms.zone = zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.AttachInteractor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractor*                      interactor                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::AttachInteractor(class UInteractor* interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "AttachInteractor");

	Params::DBDPlayer_AttachInteractor Parms{};

	Parms.interactor = interactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Authority_HandleScoreEvent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              scoreTypeTag                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FScoreEventData&           scoreEventData                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayer::Authority_HandleScoreEvent(const struct FGameplayTag& scoreTypeTag, const struct FScoreEventData& scoreEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Authority_HandleScoreEvent");

	Params::DBDPlayer_Authority_HandleScoreEvent Parms{};

	Parms.scoreTypeTag = std::move(scoreTypeTag);
	Parms.scoreEventData = std::move(scoreEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Authority_ImposeDynamicStatusEffect_DEPRECATED
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             statusEffectID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       originatingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   customParam                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer*       originatingEffect                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStatusEffect* ADBDPlayer::Authority_ImposeDynamicStatusEffect_DEPRECATED(class FName statusEffectID, class ADBDPlayer* originatingPlayer, float customParam, class UGameplayModifierContainer* originatingEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Authority_ImposeDynamicStatusEffect_DEPRECATED");

	Params::DBDPlayer_Authority_ImposeDynamicStatusEffect_DEPRECATED Parms{};

	Parms.statusEffectID = statusEffectID;
	Parms.originatingPlayer = originatingPlayer;
	Parms.customParam = customParam;
	Parms.originatingEffect = originatingEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.Authority_ImposeStatusEffect_DEPRECATED
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             statusEffectID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       originatingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   customParam                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer*       originatingEffect                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    shouldDisplay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStatusEffect* ADBDPlayer::Authority_ImposeStatusEffect_DEPRECATED(class FName statusEffectID, class ADBDPlayer* originatingPlayer, float customParam, class UGameplayModifierContainer* originatingEffect, bool shouldDisplay, float lifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Authority_ImposeStatusEffect_DEPRECATED");

	Params::DBDPlayer_Authority_ImposeStatusEffect_DEPRECATED Parms{};

	Parms.statusEffectID = statusEffectID;
	Parms.originatingPlayer = originatingPlayer;
	Parms.customParam = customParam;
	Parms.originatingEffect = originatingEffect;
	Parms.shouldDisplay = shouldDisplay;
	Parms.lifetime = lifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.Authority_RemoveStatusEffectByID
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             statusEffectId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveAllWithID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Authority_RemoveStatusEffectByID(class FName statusEffectId, bool bRemoveAllWithID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Authority_RemoveStatusEffectByID");

	Params::DBDPlayer_Authority_RemoveStatusEffectByID Parms{};

	Parms.statusEffectId = statusEffectId;
	Parms.bRemoveAllWithID = bRemoveAllWithID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Authority_RequestStun
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EStunType                               stunType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       stunner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Authority_RequestStun(EStunType stunType, class ADBDPlayer* stunner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Authority_RequestStun");

	Params::DBDPlayer_Authority_RequestStun Parms{};

	Parms.stunType = stunType;
	Parms.stunner = stunner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Authority_SetDreamworldComponent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UCharacterDreamworldComponent*    component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Authority_SetDreamworldComponent(class UCharacterDreamworldComponent* component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Authority_SetDreamworldComponent");

	Params::DBDPlayer_Authority_SetDreamworldComponent Parms{};

	Parms.component = component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.CameraUpdated
// (Native, Public, BlueprintCallable)

void ADBDPlayer::CameraUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "CameraUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.CancelCarry
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    alsoCancelForOtherPlayer                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::CancelCarry(bool alsoCancelForOtherPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "CancelCarry");

	Params::DBDPlayer_CancelCarry Parms{};

	Parms.alsoCancelForOtherPlayer = alsoCancelForOtherPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Client_Debug_PlayerStartSnapping
// (Final, Net, NetReliable, Native, Event, Private, HasDefaults, NetClient)
// Parameters:
// const struct FVector&                   location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Client_Debug_PlayerStartSnapping(const struct FVector& location, const float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Client_Debug_PlayerStartSnapping");

	Params::DBDPlayer_Client_Debug_PlayerStartSnapping Parms{};

	Parms.location = std::move(location);
	Parms.duration = duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Client_SendCancelInteraction
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// const class UInteractionDefinition*     interactionDefinition                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Client_SendCancelInteraction(const class UInteractionDefinition* interactionDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Client_SendCancelInteraction");

	Params::DBDPlayer_Client_SendCancelInteraction Parms{};

	Parms.interactionDefinition = interactionDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Client_TryInteraction
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UInteractionDefinition*           interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       requester                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    usingInputPersistence                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Client_TryInteraction(class UInteractionDefinition* interaction, class ADBDPlayer* requester, bool force, bool usingInputPersistence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Client_TryInteraction");

	Params::DBDPlayer_Client_TryInteraction Parms{};

	Parms.interaction = interaction;
	Parms.requester = requester;
	Parms.force = force;
	Parms.usingInputPersistence = usingInputPersistence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Client_TryInteractionType
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       requester                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Client_TryInteractionType(EInputInteractionType interactionType, class ADBDPlayer* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Client_TryInteractionType");

	Params::DBDPlayer_Client_TryInteractionType Parms{};

	Parms.interactionType = interactionType;
	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.DBD_DebugStartInteraction
// (Final, Exec, Native, Public)

void ADBDPlayer::DBD_DebugStartInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "DBD_DebugStartInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.DBD_SetMouseLookUpSpeedMultiplier
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::DBD_SetMouseLookUpSpeedMultiplier(float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "DBD_SetMouseLookUpSpeedMultiplier");

	Params::DBDPlayer_DBD_SetMouseLookUpSpeedMultiplier Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.DBD_SetMouseTurnSpeedMultiplier
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::DBD_SetMouseTurnSpeedMultiplier(float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "DBD_SetMouseTurnSpeedMultiplier");

	Params::DBDPlayer_DBD_SetMouseTurnSpeedMultiplier Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.DBD_ToggleDebugInteractionInZone
// (Final, Exec, Native, Public)

void ADBDPlayer::DBD_ToggleDebugInteractionInZone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "DBD_ToggleDebugInteractionInZone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.DBD_ToggleForceAuthoritativeMovement
// (Final, Exec, Native, Private)

void ADBDPlayer::DBD_ToggleForceAuthoritativeMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "DBD_ToggleForceAuthoritativeMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.DBDCrouch
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ADBDPlayer::DBDCrouch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "DBDCrouch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.DBDUnCrouch
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ADBDPlayer::DBDUnCrouch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "DBDUnCrouch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.DetachInteractor
// (Final, Native, Public, BlueprintCallable)

void ADBDPlayer::DetachInteractor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "DetachInteractor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Dissolve
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    dissolve                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Dissolve(bool dissolve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Dissolve");

	Params::DBDPlayer_Dissolve Parms{};

	Parms.dissolve = dissolve;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDPlayer.FastInteractionInputPressed
// (Final, Native, Public, BlueprintCallable)

void ADBDPlayer::FastInteractionInputPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "FastInteractionInputPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.FastInteractionInputReleased
// (Final, Native, Public, BlueprintCallable)

void ADBDPlayer::FastInteractionInputReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "FastInteractionInputReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.GetInteractionPlayerProperties
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FInteractionPlayerPropertiesReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FInteractionPlayerProperties ADBDPlayer::GetInteractionPlayerProperties()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetInteractionPlayerProperties");

	Params::DBDPlayer_GetInteractionPlayerProperties Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.InteractionInputPressed
// (Final, Native, Public, BlueprintCallable)

void ADBDPlayer::InteractionInputPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "InteractionInputPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.InteractionInputReleased
// (Final, Native, Public, BlueprintCallable)

void ADBDPlayer::InteractionInputReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "InteractionInputReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.ItemUsePressed
// (Final, Native, Public, BlueprintCallable)

void ADBDPlayer::ItemUsePressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "ItemUsePressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.ItemUseReleased
// (Final, Native, Public, BlueprintCallable)

void ADBDPlayer::ItemUseReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "ItemUseReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.K2_SetActorLocationByBottomCapsule
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      SweepHitResult                                         (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::K2_SetActorLocationByBottomCapsule(const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "K2_SetActorLocationByBottomCapsule");

	Params::DBDPlayer_K2_SetActorLocationByBottomCapsule Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.bSweep = bSweep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SweepHitResult != nullptr)
		*SweepHitResult = std::move(Parms.SweepHitResult);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.Local_NotifyMatchEnded
// (Native, Event, Public, BlueprintEvent)

void ADBDPlayer::Local_NotifyMatchEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Local_NotifyMatchEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_Broadcast_DebugPlayMontage
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// float                                   playRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_Broadcast_DebugPlayMontage(const struct FAnimationMontageDescriptor& animMontageID, float playRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_Broadcast_DebugPlayMontage");

	Params::DBDPlayer_Multicast_Broadcast_DebugPlayMontage Parms{};

	Parms.animMontageID = std::move(animMontageID);
	Parms.playRate = playRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_ConfirmItemDrop
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_ConfirmItemDrop(bool pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_ConfirmItemDrop");

	Params::DBDPlayer_Multicast_ConfirmItemDrop Parms{};

	Parms.pressed = pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_Debug_SetMaxWalkSpeed
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   maxWalkSpeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_Debug_SetMaxWalkSpeed(float maxWalkSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_Debug_SetMaxWalkSpeed");

	Params::DBDPlayer_Multicast_Debug_SetMaxWalkSpeed Parms{};

	Parms.maxWalkSpeed = maxWalkSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_LeaveGame
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// const struct FGuid&                     uniqueLeavingPlayerId                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_LeaveGame(const struct FGuid& uniqueLeavingPlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_LeaveGame");

	Params::DBDPlayer_Multicast_LeaveGame Parms{};

	Parms.uniqueLeavingPlayerId = std::move(uniqueLeavingPlayerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_ReplicateController
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AController*                      newController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_ReplicateController(class AController* newController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_ReplicateController");

	Params::DBDPlayer_Multicast_ReplicateController Parms{};

	Parms.newController = newController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_ServerResetMeshRelativeOffSet
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ADBDPlayer::Multicast_ServerResetMeshRelativeOffSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_ServerResetMeshRelativeOffSet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetAuthoritativeMovement
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetAuthoritativeMovement(bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetAuthoritativeMovement");

	Params::DBDPlayer_Multicast_SetAuthoritativeMovement Parms{};

	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetContinuousPrintDebug
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetContinuousPrintDebug(bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetContinuousPrintDebug");

	Params::DBDPlayer_Multicast_SetContinuousPrintDebug Parms{};

	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetCustomization
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FEquippedPlayerCustomization&customization                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetCustomization(const struct FEquippedPlayerCustomization& customization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetCustomization");

	Params::DBDPlayer_Multicast_SetCustomization Parms{};

	Parms.customization = std::move(customization);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetDebugCarry
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetDebugCarry(bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetDebugCarry");

	Params::DBDPlayer_Multicast_SetDebugCarry Parms{};

	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetDebugPrintAvailableInteractions
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetDebugPrintAvailableInteractions(bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetDebugPrintAvailableInteractions");

	Params::DBDPlayer_Multicast_SetDebugPrintAvailableInteractions Parms{};

	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetDebugSnapPoint
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetDebugSnapPoint(bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetDebugSnapPoint");

	Params::DBDPlayer_Multicast_SetDebugSnapPoint Parms{};

	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetEnableCapsuleDynamicResize
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetEnableCapsuleDynamicResize(bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetEnableCapsuleDynamicResize");

	Params::DBDPlayer_Multicast_SetEnableCapsuleDynamicResize Parms{};

	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetForceAuthoritativeMovement
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// bool                                    value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetForceAuthoritativeMovement(bool value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetForceAuthoritativeMovement");

	Params::DBDPlayer_Multicast_SetForceAuthoritativeMovement Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetInteractingPlayer
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ADBDPlayer*                       interactingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetInteractingPlayer(class ADBDPlayer* interactingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetInteractingPlayer");

	Params::DBDPlayer_Multicast_SetInteractingPlayer Parms{};

	Parms.interactingPlayer = interactingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetReverseTraverseEnabled
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetReverseTraverseEnabled(bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetReverseTraverseEnabled");

	Params::DBDPlayer_Multicast_SetReverseTraverseEnabled Parms{};

	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Multicast_SetRunVaultEnabled
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Multicast_SetRunVaultEnabled(bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Multicast_SetRunVaultEnabled");

	Params::DBDPlayer_Multicast_SetRunVaultEnabled Parms{};

	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnAllPlayerLoaded
// (Final, Native, Public)

void ADBDPlayer::OnAllPlayerLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnAllPlayerLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnAnimInstanceChanged
// (Final, Native, Private)

void ADBDPlayer::OnAnimInstanceChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnAnimInstanceChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnBlindChargeEmptied
// (Native, Protected)

void ADBDPlayer::OnBlindChargeEmptied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnBlindChargeEmptied");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnClientRestart
// (Event, Public, BlueprintEvent)

void ADBDPlayer::OnClientRestart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnClientRestart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDPlayer.OnControllerChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      oldController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      newController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::OnControllerChanged(class APawn* pawn, class AController* oldController, class AController* newController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnControllerChanged");

	Params::DBDPlayer_OnControllerChanged Parms{};

	Parms.pawn = pawn;
	Parms.oldController = oldController;
	Parms.newController = newController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnCurrentMontageBlendingOut
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     MontageAsset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::OnCurrentMontageBlendingOut(class UAnimMontage* MontageAsset, bool interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnCurrentMontageBlendingOut");

	Params::DBDPlayer_OnCurrentMontageBlendingOut Parms{};

	Parms.MontageAsset = MontageAsset;
	Parms.interrupted = interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnCurrentMontageComplete
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     MontageAsset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::OnCurrentMontageComplete(class UAnimMontage* MontageAsset, bool interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnCurrentMontageComplete");

	Params::DBDPlayer_OnCurrentMontageComplete Parms{};

	Parms.MontageAsset = MontageAsset;
	Parms.interrupted = interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnEscapeDoorActivated
// (Event, Protected, BlueprintEvent)

void ADBDPlayer::OnEscapeDoorActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnEscapeDoorActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDPlayer.OnHudVisibilityChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// const bool                              isVisible                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::OnHudVisibilityChanged(const bool isVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnHudVisibilityChanged");

	Params::DBDPlayer_OnHudVisibilityChanged Parms{};

	Parms.isVisible = isVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDPlayer.OnHudVisibilityChangedNative
// (Native, Protected)
// Parameters:
// const bool                              isVisible                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::OnHudVisibilityChangedNative(const bool isVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnHudVisibilityChangedNative");

	Params::DBDPlayer_OnHudVisibilityChangedNative Parms{};

	Parms.isVisible = isVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnInterruptedStart
// (Event, Protected, BlueprintEvent)

void ADBDPlayer::OnInterruptedStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnInterruptedStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDPlayer.OnIntroCompleted
// (Event, Public, BlueprintEvent)

void ADBDPlayer::OnIntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnIntroCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDPlayer.OnIntroCompletedNative
// (Native, Protected)

void ADBDPlayer::OnIntroCompletedNative()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnIntroCompletedNative");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnLevelReadyToPlay
// (Native, Event, Public, BlueprintEvent)

void ADBDPlayer::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnLocallyObservedChanged
// (Event, Protected, BlueprintEvent)

void ADBDPlayer::OnLocallyObservedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnLocallyObservedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDPlayer.OnPickupEnd
// (Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::OnPickupEnd(class ADBDPlayer* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnPickupEnd");

	Params::DBDPlayer_OnPickupEnd Parms{};

	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnPickupStart
// (Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::OnPickupStart(class ADBDPlayer* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnPickupStart");

	Params::DBDPlayer_OnPickupStart Parms{};

	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnPostProcessInput
// (Final, Native, Private)

void ADBDPlayer::OnPostProcessInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnPostProcessInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnRep_DreamworldComponent
// (Final, Native, Protected)

void ADBDPlayer::OnRep_DreamworldComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnRep_DreamworldComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.OnRep_Interactable
// (Final, Native, Protected)

void ADBDPlayer::OnRep_Interactable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnRep_Interactable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.PlayMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// float                                   playRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isFollower                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ADBDPlayer::PlayMontage(const struct FAnimationMontageDescriptor& animMontageID, float playRate, bool isFollower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "PlayMontage");

	Params::DBDPlayer_PlayMontage Parms{};

	Parms.animMontageID = std::move(animMontageID);
	Parms.playRate = playRate;
	Parms.isFollower = isFollower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.RemoveStatusEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStatusEffect*                    statusEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::RemoveStatusEffect(class UStatusEffect* statusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "RemoveStatusEffect");

	Params::DBDPlayer_RemoveStatusEffect Parms{};

	Parms.statusEffect = statusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.ResetCamera
// (Native, Public, BlueprintCallable)

void ADBDPlayer::ResetCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "ResetCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.ResetPitchScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   adjustTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::ResetPitchScale(float adjustTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "ResetPitchScale");

	Params::DBDPlayer_ResetPitchScale Parms{};

	Parms.adjustTime = adjustTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_Broadcast_DebugPlayMontage
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// float                                   playRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_Broadcast_DebugPlayMontage(const struct FAnimationMontageDescriptor& animMontageID, float playRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_Broadcast_DebugPlayMontage");

	Params::DBDPlayer_Server_Broadcast_DebugPlayMontage Parms{};

	Parms.animMontageID = std::move(animMontageID);
	Parms.playRate = playRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_DebugSetCustomization
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FEquippedPlayerCustomization&customization                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_DebugSetCustomization(const struct FEquippedPlayerCustomization& customization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_DebugSetCustomization");

	Params::DBDPlayer_Server_DebugSetCustomization Parms{};

	Parms.customization = std::move(customization);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_Drop
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// class ACollectable*                     item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  rotation                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    onDeath                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_Drop(class ACollectable* item, const struct FVector& location, const struct FRotator& rotation, bool onDeath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_Drop");

	Params::DBDPlayer_Server_Drop Parms{};

	Parms.item = item;
	Parms.location = std::move(location);
	Parms.rotation = std::move(rotation);
	Parms.onDeath = onDeath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_GameTimeSync
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ADBDPlayer::Server_GameTimeSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_GameTimeSync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_SendAbilityInput
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_SendAbilityInput(bool pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_SendAbilityInput");

	Params::DBDPlayer_Server_SendAbilityInput Parms{};

	Parms.pressed = pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_SendAbilityTwoInput
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_SendAbilityTwoInput(bool pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_SendAbilityTwoInput");

	Params::DBDPlayer_Server_SendAbilityTwoInput Parms{};

	Parms.pressed = pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_SendFastInteractionInput
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_SendFastInteractionInput(bool pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_SendFastInteractionInput");

	Params::DBDPlayer_Server_SendFastInteractionInput Parms{};

	Parms.pressed = pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_SendInteractionInput
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_SendInteractionInput(bool pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_SendInteractionInput");

	Params::DBDPlayer_Server_SendInteractionInput Parms{};

	Parms.pressed = pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_SendItemDropInput
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_SendItemDropInput(bool pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_SendItemDropInput");

	Params::DBDPlayer_Server_SendItemDropInput Parms{};

	Parms.pressed = pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_SendItemUseInput
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    requestItemUse                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_SendItemUseInput(bool pressed, bool requestItemUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_SendItemUseInput");

	Params::DBDPlayer_Server_SendItemUseInput Parms{};

	Parms.pressed = pressed;
	Parms.requestItemUse = requestItemUse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_SendSecondaryActionPressed
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// bool                                    fromCancelRequest                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_SendSecondaryActionPressed(bool fromCancelRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_SendSecondaryActionPressed");

	Params::DBDPlayer_Server_SendSecondaryActionPressed Parms{};

	Parms.fromCancelRequest = fromCancelRequest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.Server_UpdateScreenAspectRatio
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const float                             value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::Server_UpdateScreenAspectRatio(const float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Server_UpdateScreenAspectRatio");

	Params::DBDPlayer_Server_UpdateScreenAspectRatio Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetAllDetectionZonesEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetAllDetectionZonesEnabled(bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetAllDetectionZonesEnabled");

	Params::DBDPlayer_SetAllDetectionZonesEnabled Parms{};

	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetAllowNavigation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetAllowNavigation(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetAllowNavigation");

	Params::DBDPlayer_SetAllowNavigation Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetAnimationCrouchState
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    crouched                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetAnimationCrouchState(bool crouched)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetAnimationCrouchState");

	Params::DBDPlayer_SetAnimationCrouchState Parms{};

	Parms.crouched = crouched;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDPlayer.SetDetectionZoneEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDetectionZone                          detectionZoneID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetDetectionZoneEnabled(EDetectionZone detectionZoneID, bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetDetectionZoneEnabled");

	Params::DBDPlayer_SetDetectionZoneEnabled Parms{};

	Parms.detectionZoneID = detectionZoneID;
	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetFeetOnGround
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    feetOnGround                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetFeetOnGround(bool feetOnGround)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetFeetOnGround");

	Params::DBDPlayer_SetFeetOnGround Parms{};

	Parms.feetOnGround = feetOnGround;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetFirstPersonModelEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetFirstPersonModelEnabled(bool enabled, bool force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetFirstPersonModelEnabled");

	Params::DBDPlayer_SetFirstPersonModelEnabled Parms{};

	Parms.enabled = enabled;
	Parms.force = force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetFirstPersonVfxsVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isFirstPerson                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetFirstPersonVfxsVisibility(bool isFirstPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetFirstPersonVfxsVisibility");

	Params::DBDPlayer_SetFirstPersonVfxsVisibility Parms{};

	Parms.isFirstPerson = isFirstPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetForceDisableSkillChecks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetForceDisableSkillChecks(bool isEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetForceDisableSkillChecks");

	Params::DBDPlayer_SetForceDisableSkillChecks Parms{};

	Parms.isEnabled = isEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetIsCloaked
// (Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    isCloaked                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    forced                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetIsCloaked(bool isCloaked, bool forced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetIsCloaked");

	Params::DBDPlayer_SetIsCloaked Parms{};

	Parms.isCloaked = isCloaked;
	Parms.forced = forced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetItemUseAsToggle
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetItemUseAsToggle(bool value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetItemUseAsToggle");

	Params::DBDPlayer_SetItemUseAsToggle Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetQuestEventHandlerComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetQuestEventHandlerComponent(class UActorComponent* component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetQuestEventHandlerComponent");

	Params::DBDPlayer_SetQuestEventHandlerComponent Parms{};

	Parms.component = component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetReverseMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    reverse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetReverseMontage(bool reverse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetReverseMontage");

	Params::DBDPlayer_SetReverseMontage Parms{};

	Parms.reverse = reverse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SetShouldPlayCarryAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    shouldPlayCarryAnim                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SetShouldPlayCarryAnim(bool shouldPlayCarryAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SetShouldPlayCarryAnim");

	Params::DBDPlayer_SetShouldPlayCarryAnim Parms{};

	Parms.shouldPlayCarryAnim = shouldPlayCarryAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.SnapCharacter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    snapPosition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   stopSnapDistance                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    snapRotation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    useZCoord                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    sweepOnFinalSnap                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    snapRoll                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::SnapCharacter(bool snapPosition, const struct FVector& position, float stopSnapDistance, bool snapRotation, const struct FRotator& rotation, float time, bool useZCoord, bool sweepOnFinalSnap, bool snapRoll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "SnapCharacter");

	Params::DBDPlayer_SnapCharacter Parms{};

	Parms.snapPosition = snapPosition;
	Parms.position = std::move(position);
	Parms.stopSnapDistance = stopSnapDistance;
	Parms.snapRotation = snapRotation;
	Parms.rotation = std::move(rotation);
	Parms.time = time;
	Parms.useZCoord = useZCoord;
	Parms.sweepOnFinalSnap = sweepOnFinalSnap;
	Parms.snapRoll = snapRoll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.StopMontage
// (Final, Native, Public, BlueprintCallable)

void ADBDPlayer::StopMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "StopMontage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.TriggerAnimNotify
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAnimNotifyType                         animNotifyType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayer::TriggerAnimNotify(EAnimNotifyType animNotifyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "TriggerAnimNotify");

	Params::DBDPlayer_TriggerAnimNotify Parms{};

	Parms.animNotifyType = animNotifyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.TryFireScoreEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDBDScoreTypes                          scoreType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   percentToAward                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::TryFireScoreEvent(EDBDScoreTypes scoreType, float percentToAward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "TryFireScoreEvent");

	Params::DBDPlayer_TryFireScoreEvent Parms{};

	Parms.scoreType = scoreType;
	Parms.percentToAward = percentToAward;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.TryInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionDefinition*           interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       requester                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    usingInputPersistence                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::TryInteraction(class UInteractionDefinition* interaction, class ADBDPlayer* requester, bool force, bool usingInputPersistence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "TryInteraction");

	Params::DBDPlayer_TryInteraction Parms{};

	Parms.interaction = interaction;
	Parms.requester = requester;
	Parms.force = force;
	Parms.usingInputPersistence = usingInputPersistence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.TryInteractionType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInputInteractionType                   interactionInputType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       requester                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    usingInputPersistence                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::TryInteractionType(EInputInteractionType interactionInputType, class ADBDPlayer* requester, bool usingInputPersistence, bool force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "TryInteractionType");

	Params::DBDPlayer_TryInteractionType Parms{};

	Parms.interactionInputType = interactionInputType;
	Parms.requester = requester;
	Parms.usingInputPersistence = usingInputPersistence;
	Parms.force = force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.Authority_EvaluateIfPlayerCanSee
// (Final, Native, Private, Const)

void ADBDPlayer::Authority_EvaluateIfPlayerCanSee() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Authority_EvaluateIfPlayerCanSee");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.CanInterrupt_BP
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::CanInterrupt_BP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "CanInterrupt_BP");

	Params::DBDPlayer_CanInterrupt_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.DBD_CancelInteraction
// (Final, Exec, Native, Public, Const)

void ADBDPlayer::DBD_CancelInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "DBD_CancelInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayer.FindClosestSlashablePlayerInDetectionZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDetectionZone                          detectionZoneID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ADBDPlayer::FindClosestSlashablePlayerInDetectionZone(EDetectionZone detectionZoneID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "FindClosestSlashablePlayerInDetectionZone");

	Params::DBDPlayer_FindClosestSlashablePlayerInDetectionZone Parms{};

	Parms.detectionZoneID = detectionZoneID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetActorLocationFromFeetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   FeetLocation                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ADBDPlayer::GetActorLocationFromFeetLocation(const struct FVector& FeetLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetActorLocationFromFeetLocation");

	Params::DBDPlayer_GetActorLocationFromFeetLocation Parms{};

	Parms.FeetLocation = std::move(FeetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetAnimInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* ADBDPlayer::GetAnimInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetAnimInstance");

	Params::DBDPlayer_GetAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetAnimTags
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>*                    outTags                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ADBDPlayer::GetAnimTags(TArray<class FName>* outTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetAnimTags");

	Params::DBDPlayer_GetAnimTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outTags != nullptr)
		*outTags = std::move(Parms.outTags);
}


// Function DeadByDaylight.DBDPlayer.GetAssociatedPlayerState
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class APlayerState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerState* ADBDPlayer::GetAssociatedPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetAssociatedPlayerState");

	Params::DBDPlayer_GetAssociatedPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetAttachPoint
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FName                             attachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* ADBDPlayer::GetAttachPoint(class FName attachPointName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetAttachPoint");

	Params::DBDPlayer_GetAttachPoint Parms{};

	Parms.attachPointName = attachPointName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetAuthoritativeMovementComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAuthoritativeMovementComponent*  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuthoritativeMovementComponent* ADBDPlayer::GetAuthoritativeMovementComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetAuthoritativeMovementComponent");

	Params::DBDPlayer_GetAuthoritativeMovementComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetAverageVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ADBDPlayer::GetAverageVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetAverageVelocity");

	Params::DBDPlayer_GetAverageVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetBlindableComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlindableComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlindableComponent* ADBDPlayer::GetBlindableComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetBlindableComponent");

	Params::DBDPlayer_GetBlindableComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetBoneLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             name                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBoneSpaces                             space                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ADBDPlayer::GetBoneLocation(class FName name, EBoneSpaces space) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetBoneLocation");

	Params::DBDPlayer_GetBoneLocation Parms{};

	Parms.name = name;
	Parms.space = space;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetCameraManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayerCameraManager*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerCameraManager* ADBDPlayer::GetCameraManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetCameraManager");

	Params::DBDPlayer_GetCameraManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetCharacterInventoryComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterInventoryComponent*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterInventoryComponent* ADBDPlayer::GetCharacterInventoryComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetCharacterInventoryComponent");

	Params::DBDPlayer_GetCharacterInventoryComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetChaseComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UChaseComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChaseComponent* ADBDPlayer::GetChaseComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetChaseComponent");

	Params::DBDPlayer_GetChaseComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetCurrentInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* ADBDPlayer::GetCurrentInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetCurrentInteraction");

	Params::DBDPlayer_GetCurrentInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetCurrentInteractionAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInteractionAnimation                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInteractionAnimation ADBDPlayer::GetCurrentInteractionAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetCurrentInteractionAnimation");

	Params::DBDPlayer_GetCurrentInteractionAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetDBDPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayerState*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerState* ADBDPlayer::GetDBDPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetDBDPlayerState");

	Params::DBDPlayer_GetDBDPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetDetectionZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDetectionZone                          detectionZoneID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* ADBDPlayer::GetDetectionZone(EDetectionZone detectionZoneID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetDetectionZone");

	Params::DBDPlayer_GetDetectionZone Parms{};

	Parms.detectionZoneID = detectionZoneID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetDreamworldComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterDreamworldComponent*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterDreamworldComponent* ADBDPlayer::GetDreamworldComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetDreamworldComponent");

	Params::DBDPlayer_GetDreamworldComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetFeetPosition
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ADBDPlayer::GetFeetPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetFeetPosition");

	Params::DBDPlayer_GetFeetPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetFirstComponentByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UActorComponent>      ComponentClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* ADBDPlayer::GetFirstComponentByClass(TSubclassOf<class UActorComponent> ComponentClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetFirstComponentByClass");

	Params::DBDPlayer_GetFirstComponentByClass Parms{};

	Parms.ComponentClass = ComponentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetGrassEffectRadiusMultiplier
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDPlayer::GetGrassEffectRadiusMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetGrassEffectRadiusMultiplier");

	Params::DBDPlayer_GetGrassEffectRadiusMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetGuidingPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ADBDPlayer::GetGuidingPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetGuidingPlayer");

	Params::DBDPlayer_GetGuidingPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetInteractable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInteractable*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractable* ADBDPlayer::GetInteractable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetInteractable");

	Params::DBDPlayer_GetInteractable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetInteractionDetectorComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionDetectorComponent*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDetectorComponent* ADBDPlayer::GetInteractionDetectorComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetInteractionDetectorComponent");

	Params::DBDPlayer_GetInteractionDetectorComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetIsInFirstPerson
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::GetIsInFirstPerson() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetIsInFirstPerson");

	Params::DBDPlayer_GetIsInFirstPerson Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetIsInteracting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::GetIsInteracting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetIsInteracting");

	Params::DBDPlayer_GetIsInteracting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetIsInterrupting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::GetIsInterrupting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetIsInterrupting");

	Params::DBDPlayer_GetIsInterrupting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetItemAddons
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UItemAddon*>         ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UItemAddon*> ADBDPlayer::GetItemAddons() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetItemAddons");

	Params::DBDPlayer_GetItemAddons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetItemModifiers
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UItemModifier*>      ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UItemModifier*> ADBDPlayer::GetItemModifiers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetItemModifiers");

	Params::DBDPlayer_GetItemModifiers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetLuck
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDPlayer::GetLuck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetLuck");

	Params::DBDPlayer_GetLuck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetMaxSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDPlayer::GetMaxSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetMaxSpeed");

	Params::DBDPlayer_GetMaxSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetMontage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ADBDPlayer::GetMontage(const struct FAnimationMontageDescriptor& animMontageID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetMontage");

	Params::DBDPlayer_GetMontage Parms{};

	Parms.animMontageID = std::move(animMontageID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetMontageLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDPlayer::GetMontageLength(const struct FAnimationMontageDescriptor& animMontageID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetMontageLength");

	Params::DBDPlayer_GetMontageLength Parms{};

	Parms.animMontageID = std::move(animMontageID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetMontagePlaybackDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// float                                   playRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isFollower                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMontagePlaybackDefinition       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMontagePlaybackDefinition ADBDPlayer::GetMontagePlaybackDefinition(const struct FAnimationMontageDescriptor& animMontageID, float playRate, bool isFollower) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetMontagePlaybackDefinition");

	Params::DBDPlayer_GetMontagePlaybackDefinition Parms{};

	Parms.animMontageID = std::move(animMontageID);
	Parms.playRate = playRate;
	Parms.isFollower = isFollower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetMontagePlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMontagePlayer*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMontagePlayer* ADBDPlayer::GetMontagePlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetMontagePlayer");

	Params::DBDPlayer_GetMontagePlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetNameDebugString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ADBDPlayer::GetNameDebugString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetNameDebugString");

	Params::DBDPlayer_GetNameDebugString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetObjectState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayTagContainerComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTagContainerComponent* ADBDPlayer::GetObjectState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetObjectState");

	Params::DBDPlayer_GetObjectState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetOtherCharactersVerticalCollisionsHandler
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOtherCharactersVerticalCollisionsHandler*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOtherCharactersVerticalCollisionsHandler* ADBDPlayer::GetOtherCharactersVerticalCollisionsHandler() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetOtherCharactersVerticalCollisionsHandler");

	Params::DBDPlayer_GetOtherCharactersVerticalCollisionsHandler Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPawnType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPawnType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPawnType ADBDPlayer::GetPawnType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPawnType");

	Params::DBDPlayer_GetPawnType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPercentMovementSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDPlayer::GetPercentMovementSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPercentMovementSpeed");

	Params::DBDPlayer_GetPercentMovementSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPerkManager
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPerkManager*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPerkManager* ADBDPlayer::GetPerkManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPerkManager");

	Params::DBDPlayer_GetPerkManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPlayerCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* ADBDPlayer::GetPlayerCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPlayerCamera");

	Params::DBDPlayer_GetPlayerCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayerController*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerController* ADBDPlayer::GetPlayerController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPlayerController");

	Params::DBDPlayer_GetPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPlayerDirection
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ADBDPlayer::GetPlayerDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPlayerDirection");

	Params::DBDPlayer_GetPlayerDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPlayerInteractionHandler
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPlayerInteractionHandler*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayerInteractionHandler* ADBDPlayer::GetPlayerInteractionHandler() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPlayerInteractionHandler");

	Params::DBDPlayer_GetPlayerInteractionHandler Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPlayerRole
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerRole                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerRole ADBDPlayer::GetPlayerRole() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPlayerRole");

	Params::DBDPlayer_GetPlayerRole Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetPlayerTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerTeam                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerTeam ADBDPlayer::GetPlayerTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetPlayerTeam");

	Params::DBDPlayer_GetPlayerTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetRepControlRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ADBDPlayer::GetRepControlRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetRepControlRotation");

	Params::DBDPlayer_GetRepControlRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetReverseTraverseEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::GetReverseTraverseEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetReverseTraverseEnabled");

	Params::DBDPlayer_GetReverseTraverseEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetRunVaultEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::GetRunVaultEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetRunVaultEnabled");

	Params::DBDPlayer_GetRunVaultEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetSharedPlayerController
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class ADBDPlayerController*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerController* ADBDPlayer::GetSharedPlayerController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetSharedPlayerController");

	Params::DBDPlayer_GetSharedPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.GetTunableValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   defaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    warnIfRowMissing                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDPlayer::GetTunableValue(class FName key, float defaultValue, bool warnIfRowMissing) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "GetTunableValue");

	Params::DBDPlayer_GetTunableValue Parms{};

	Parms.key = key;
	Parms.defaultValue = defaultValue;
	Parms.warnIfRowMissing = warnIfRowMissing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.HasClearPathToTarget
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   targetPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::HasClearPathToTarget(const struct FVector& targetPosition) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "HasClearPathToTarget");

	Params::DBDPlayer_HasClearPathToTarget Parms{};

	Parms.targetPosition = std::move(targetPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.HasClearPathToTargetWithIgnore
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   targetPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ignoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::HasClearPathToTargetWithIgnore(const struct FVector& targetPosition, const TArray<class AActor*>& ignoreActors) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "HasClearPathToTargetWithIgnore");

	Params::DBDPlayer_HasClearPathToTargetWithIgnore Parms{};

	Parms.targetPosition = std::move(targetPosition);
	Parms.ignoreActors = std::move(ignoreActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.HasDamageImmunity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::HasDamageImmunity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "HasDamageImmunity");

	Params::DBDPlayer_HasDamageImmunity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.HasMoveInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::HasMoveInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "HasMoveInput");

	Params::DBDPlayer_HasMoveInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsAllowedNavigation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsAllowedNavigation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsAllowedNavigation");

	Params::DBDPlayer_IsAllowedNavigation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsBeingInterrupted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsBeingInterrupted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsBeingInterrupted");

	Params::DBDPlayer_IsBeingInterrupted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsCloaked
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsCloaked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsCloaked");

	Params::DBDPlayer_IsCloaked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsCrouching
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsCrouching() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsCrouching");

	Params::DBDPlayer_IsCrouching Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsCrouchPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsCrouchPressed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsCrouchPressed");

	Params::DBDPlayer_IsCrouchPressed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsExhausted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsExhausted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsExhausted");

	Params::DBDPlayer_IsExhausted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsHeadHidden
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsHeadHidden() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsHeadHidden");

	Params::DBDPlayer_IsHeadHidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsIncapacitated
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsIncapacitated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsIncapacitated");

	Params::DBDPlayer_IsIncapacitated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsInMeathookZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsInMeathookZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsInMeathookZone");

	Params::DBDPlayer_IsInMeathookZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsInParadise
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsInParadise() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsInParadise");

	Params::DBDPlayer_IsInParadise Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsInsideCloset
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsInsideCloset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsInsideCloset");

	Params::DBDPlayer_IsInsideCloset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsInStalkMode
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsInStalkMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsInStalkMode");

	Params::DBDPlayer_IsInStalkMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsInteractionInputPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsInteractionInputPressed(EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsInteractionInputPressed");

	Params::DBDPlayer_IsInteractionInputPressed Parms{};

	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsInTerrorRadius
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsInTerrorRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsInTerrorRadius");

	Params::DBDPlayer_IsInTerrorRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsLocallyObserved
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsLocallyObserved() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsLocallyObserved");

	Params::DBDPlayer_IsLocallyObserved Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsMoving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsMoving");

	Params::DBDPlayer_IsMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsPlayingAnyMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsPlayingAnyMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsPlayingAnyMontage");

	Params::DBDPlayer_IsPlayingAnyMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsPlayingMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsPlayingMontage(const struct FAnimationMontageDescriptor& animMontageID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsPlayingMontage");

	Params::DBDPlayer_IsPlayingMontage Parms{};

	Parms.animMontageID = std::move(animMontageID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.IsRunning
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::IsRunning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "IsRunning");

	Params::DBDPlayer_IsRunning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.Local_IsInteractionInputPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::Local_IsInteractionInputPressed(EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "Local_IsInteractionInputPressed");

	Params::DBDPlayer_Local_IsInteractionInputPressed Parms{};

	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.OnGetCharacterName
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ADBDPlayer::OnGetCharacterName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "OnGetCharacterName");

	Params::DBDPlayer_OnGetCharacterName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.ShouldFall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::ShouldFall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "ShouldFall");

	Params::DBDPlayer_ShouldFall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.ShouldPlayCarryAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayer::ShouldPlayCarryAnim() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "ShouldPlayCarryAnim");

	Params::DBDPlayer_ShouldPlayCarryAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayer.UpdateLoadoutFromInventory
// (Final, Native, Public, Const)

void ADBDPlayer::UpdateLoadoutFromInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayer", "UpdateLoadoutFromInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGPartyBotSlotWidget.HandleEditButtonEvent
// (Final, Native, Private)

void UUMGPartyBotSlotWidget::HandleEditButtonEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPartyBotSlotWidget", "HandleEditButtonEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGPartyBotSlotWidget.HandleInvitePartyButtonEvent
// (Final, Native, Private)

void UUMGPartyBotSlotWidget::HandleInvitePartyButtonEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPartyBotSlotWidget", "HandleInvitePartyButtonEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialGameState.SetCurrentTutorialStep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETutorialStep                           step                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialGameState::SetCurrentTutorialStep(ETutorialStep step)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameState", "SetCurrentTutorialStep");

	Params::TutorialGameState_SetCurrentTutorialStep Parms{};

	Parms.step = step;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialGameState.SetForcedHatchVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isHatchVisible                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialGameState::SetForcedHatchVisibility(bool isHatchVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameState", "SetForcedHatchVisibility");

	Params::TutorialGameState_SetForcedHatchVisibility Parms{};

	Parms.isHatchVisible = isHatchVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialGameState.TutorialEndReached
// (Final, Native, Public, BlueprintCallable)

void ATutorialGameState::TutorialEndReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameState", "TutorialEndReached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialGameState.CompleteLocallyControlledCharacterIntros
// (Final, Native, Public, BlueprintCallable, Const)

void ATutorialGameState::CompleteLocallyControlledCharacterIntros() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameState", "CompleteLocallyControlledCharacterIntros");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialGameState.GetCurrentTutorialStep
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETutorialStep                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETutorialStep ATutorialGameState::GetCurrentTutorialStep() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameState", "GetCurrentTutorialStep");

	Params::TutorialGameState_GetCurrentTutorialStep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialGameState.IsTutorialStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATutorialGameState::IsTutorialStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameState", "IsTutorialStarted");

	Params::TutorialGameState_IsTutorialStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialGameState.SetEscapeRequirementsVisibility
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                                    isVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialGameState::SetEscapeRequirementsVisibility(bool isVisible) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameState", "SetEscapeRequirementsVisibility");

	Params::TutorialGameState_SetEscapeRequirementsVisibility Parms{};

	Parms.isVisible = isVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.ActionInputPressed
// (Final, Native, Public, BlueprintCallable)

void ACamperPlayer::ActionInputPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "ActionInputPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.ActionInputReleased
// (Final, Native, Public, BlueprintCallable)

void ACamperPlayer::ActionInputReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "ActionInputReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.ActivateLocalPlayerExposedVFX
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void ACamperPlayer::ActivateLocalPlayerExposedVFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "ActivateLocalPlayerExposedVFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CamperPlayer.ActivatePlayerExposedVFX
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void ACamperPlayer::ActivatePlayerExposedVFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "ActivatePlayerExposedVFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CamperPlayer.AddBloodDecalToGK_Mori
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ACamperPlayer::AddBloodDecalToGK_Mori()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "AddBloodDecalToGK_Mori");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CamperPlayer.AddBloodDrippingToGK_Mori
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ACamperPlayer::AddBloodDrippingToGK_Mori()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "AddBloodDrippingToGK_Mori");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CamperPlayer.AddBloodDropsToLeftHand
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ACamperPlayer::AddBloodDropsToLeftHand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "AddBloodDropsToLeftHand");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CamperPlayer.AddBloodDropsToRightHand
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ACamperPlayer::AddBloodDropsToRightHand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "AddBloodDropsToRightHand");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CamperPlayer.AttachToGuidingPlayer
// (Final, Native, Public, BlueprintCallable)

void ACamperPlayer::AttachToGuidingPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "AttachToGuidingPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.Authority_ApplySprintEffect
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ACamperPlayer::Authority_ApplySprintEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Authority_ApplySprintEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.Authority_DropItemAtLastSafePosition
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ACamperPlayer::Authority_DropItemAtLastSafePosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Authority_DropItemAtLastSafePosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.Authority_OnSlashed
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       attacker                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::Authority_OnSlashed(class ADBDPlayer* attacker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Authority_OnSlashed");

	Params::CamperPlayer_Authority_OnSlashed Parms{};

	Parms.attacker = attacker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.Authority_SetImmobilized
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECamperImmobilizeState                  state                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::Authority_SetImmobilized(ECamperImmobilizeState state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Authority_SetImmobilized");

	Params::CamperPlayer_Authority_SetImmobilized Parms{};

	Parms.state = state;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.CallOnDroppedByBearTrap
// (Final, Native, Public, BlueprintCallable)

void ACamperPlayer::CallOnDroppedByBearTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "CallOnDroppedByBearTrap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.Client_OnSlashedOutOfTrap
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       requester                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::Client_OnSlashedOutOfTrap(class ADBDPlayer* requester)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Client_OnSlashedOutOfTrap");

	Params::CamperPlayer_Client_OnSlashedOutOfTrap Parms{};

	Parms.requester = requester;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.ComputeBeartrapEscapeResult
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::ComputeBeartrapEscapeResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "ComputeBeartrapEscapeResult");

	Params::CamperPlayer_ComputeBeartrapEscapeResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.ComputeHookEscapeResult
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::ComputeHookEscapeResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "ComputeHookEscapeResult");

	Params::CamperPlayer_ComputeHookEscapeResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.ComputeInteractionSuccessPercentage
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const class UInteractionDefinition*     interaction                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACamperPlayer::ComputeInteractionSuccessPercentage(const class UInteractionDefinition* interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "ComputeInteractionSuccessPercentage");

	Params::CamperPlayer_ComputeInteractionSuccessPercentage Parms{};

	Parms.interaction = interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.DBD_CheatEscaped
// (Final, Exec, Native, Public, BlueprintCallable)

void ACamperPlayer::DBD_CheatEscaped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "DBD_CheatEscaped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.DBD_ForceRun
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    forced                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::DBD_ForceRun(bool forced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "DBD_ForceRun");

	Params::CamperPlayer_DBD_ForceRun Parms{};

	Parms.forced = forced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.DBD_LeaveParadise
// (Final, Exec, Native, Public, BlueprintCallable)

void ACamperPlayer::DBD_LeaveParadise()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "DBD_LeaveParadise");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.DBD_SetImmobilized
// (Final, Exec, Native, Public)
// Parameters:
// ECamperImmobilizeState                  state                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::DBD_SetImmobilized(ECamperImmobilizeState state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "DBD_SetImmobilized");

	Params::CamperPlayer_DBD_SetImmobilized Parms{};

	Parms.state = state;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.DBD_SetSurvivorCameraArmLength
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   cameraArmLength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::DBD_SetSurvivorCameraArmLength(float cameraArmLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "DBD_SetSurvivorCameraArmLength");

	Params::CamperPlayer_DBD_SetSurvivorCameraArmLength Parms{};

	Parms.cameraArmLength = cameraArmLength;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.CamperPlayer.DBD_SetSurvivorCameraArmLengthCommand
// (Final, Exec, Native, Public)
// Parameters:
// float                                   cameraArmLength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::DBD_SetSurvivorCameraArmLengthCommand(float cameraArmLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "DBD_SetSurvivorCameraArmLengthCommand");

	Params::CamperPlayer_DBD_SetSurvivorCameraArmLengthCommand Parms{};

	Parms.cameraArmLength = cameraArmLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.DecalBlood_Puddles
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ACamperPlayer::DecalBlood_Puddles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "DecalBlood_Puddles");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CamperPlayer.DetachFromGuidingPlayer
// (Final, Native, Public, BlueprintCallable)

void ACamperPlayer::DetachFromGuidingPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "DetachFromGuidingPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.DoSacrificialDissolve
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ACamperPlayer::DoSacrificialDissolve()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "DoSacrificialDissolve");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CamperPlayer.EscapeTutorial
// (Final, Native, Public, BlueprintCallable)

void ACamperPlayer::EscapeTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "EscapeTutorial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.EventOnDeath
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ACamperPlayer::EventOnDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "EventOnDeath");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CamperPlayer.GetCamperStillnessComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCamperStillnessTrackerComponent* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCamperStillnessTrackerComponent* ACamperPlayer::GetCamperStillnessComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetCamperStillnessComponent");

	Params::CamperPlayer_GetCamperStillnessComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetIsHealingKOCamper
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::GetIsHealingKOCamper()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetIsHealingKOCamper");

	Params::CamperPlayer_GetIsHealingKOCamper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetIsSkillCheckFailed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::GetIsSkillCheckFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetIsSkillCheckFailed");

	Params::CamperPlayer_GetIsSkillCheckFailed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetMontageFollower
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimationMontageSlave*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimationMontageSlave* ACamperPlayer::GetMontageFollower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetMontageFollower");

	Params::CamperPlayer_GetMontageFollower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.HatchEscapeZoneEntered
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           escape                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::HatchEscapeZoneEntered(class AActor* escape)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "HatchEscapeZoneEntered");

	Params::CamperPlayer_HatchEscapeZoneEntered Parms{};

	Parms.escape = escape;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.Input_ToggleRun
// (Final, Native, Public, BlueprintCallable)

void ACamperPlayer::Input_ToggleRun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Input_ToggleRun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.IsRunLocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsRunLocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsRunLocked");

	Params::CamperPlayer_IsRunLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.Kill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHealthType                             healthType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::Kill(EHealthType healthType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Kill");

	Params::CamperPlayer_Kill Parms{};

	Parms.healthType = healthType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.Local_SetImmobilized
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECamperImmobilizeState                  state                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::Local_SetImmobilized(ECamperImmobilizeState state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Local_SetImmobilized");

	Params::CamperPlayer_Local_SetImmobilized Parms{};

	Parms.state = state;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.MakeCamperDisappear
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ACamperPlayer::MakeCamperDisappear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "MakeCamperDisappear");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CamperPlayer.MakeCamperDisappearBleedOut
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ACamperPlayer::MakeCamperDisappearBleedOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "MakeCamperDisappearBleedOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CamperPlayer.Multicast_EscapeItemEvents
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    isItemFromSpawn                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::Multicast_EscapeItemEvents(bool isItemFromSpawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Multicast_EscapeItemEvents");

	Params::CamperPlayer_Multicast_EscapeItemEvents Parms{};

	Parms.isItemFromSpawn = isItemFromSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.Multicast_RemoveReverseBearTrap
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ACamperPlayer::Multicast_RemoveReverseBearTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Multicast_RemoveReverseBearTrap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.Multicast_SetAuthoritativeMovementFlag
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EAuthoritativeMovementFlag              flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::Multicast_SetAuthoritativeMovementFlag(EAuthoritativeMovementFlag flag, bool value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Multicast_SetAuthoritativeMovementFlag");

	Params::CamperPlayer_Multicast_SetAuthoritativeMovementFlag Parms{};

	Parms.flag = flag;
	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.Multicast_SetGuidedAction
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ECamperGuidedAction                     action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::Multicast_SetGuidedAction(ECamperGuidedAction action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Multicast_SetGuidedAction");

	Params::CamperPlayer_Multicast_SetGuidedAction Parms{};

	Parms.action = action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.Multicast_SetHookEscapeAutoFail
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::Multicast_SetHookEscapeAutoFail(bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Multicast_SetHookEscapeAutoFail");

	Params::CamperPlayer_Multicast_SetHookEscapeAutoFail Parms{};

	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.Multicast_SetImmobilized
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// ECamperImmobilizeState                  state                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::Multicast_SetImmobilized(ECamperImmobilizeState state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Multicast_SetImmobilized");

	Params::CamperPlayer_Multicast_SetImmobilized Parms{};

	Parms.state = state;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.Multicast_SetOverlappingEscape
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class AActor*                           escape                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::Multicast_SetOverlappingEscape(class AActor* escape)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Multicast_SetOverlappingEscape");

	Params::CamperPlayer_Multicast_SetOverlappingEscape Parms{};

	Parms.escape = escape;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.OnDroppedByBearTrap
// (Event, Protected, BlueprintEvent)

void ACamperPlayer::OnDroppedByBearTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "OnDroppedByBearTrap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CamperPlayer.OnDroppedEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    clearLeader                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::OnDroppedEnd(bool clearLeader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "OnDroppedEnd");

	Params::CamperPlayer_OnDroppedEnd Parms{};

	Parms.clearLeader = clearLeader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.OnDroppedStart
// (Final, Native, Public, BlueprintCallable)

void ACamperPlayer::OnDroppedStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "OnDroppedStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.OnFinishedPlaying
// (Final, Native, Public, BlueprintCallable)

void ACamperPlayer::OnFinishedPlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "OnFinishedPlaying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.OnHooked
// (Final, Native, Public, BlueprintCallable)

void ACamperPlayer::OnHooked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "OnHooked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.OnHookedStateChangedCosmetic
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    hooked                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::OnHookedStateChangedCosmetic(bool hooked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "OnHookedStateChangedCosmetic");

	Params::CamperPlayer_OnHookedStateChangedCosmetic Parms{};

	Parms.hooked = hooked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.CamperPlayer.OnHpSlotSkillCheckResponseAesthetic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bonus                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    triggerLoudNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hadInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   chargeChange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::OnHpSlotSkillCheckResponseAesthetic(bool success, bool bonus, class ADBDPlayer* player, bool triggerLoudNoise, bool hadInput, ESkillCheckCustomType type, float chargeChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "OnHpSlotSkillCheckResponseAesthetic");

	Params::CamperPlayer_OnHpSlotSkillCheckResponseAesthetic Parms{};

	Parms.success = success;
	Parms.bonus = bonus;
	Parms.player = player;
	Parms.triggerLoudNoise = triggerLoudNoise;
	Parms.hadInput = hadInput;
	Parms.type = type;
	Parms.chargeChange = chargeChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.OnObsessionChanged
// (Final, Native, Public)
// Parameters:
// class ACamperPlayer*                    newObsession                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACamperPlayer*                    previousObsession                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::OnObsessionChanged(class ACamperPlayer* newObsession, class ACamperPlayer* previousObsession)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "OnObsessionChanged");

	Params::CamperPlayer_OnObsessionChanged Parms{};

	Parms.newObsession = newObsession;
	Parms.previousObsession = previousObsession;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.OnPawnSensed
// (Final, Native, Private)
// Parameters:
// class APawn*                            pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::OnPawnSensed(class APawn* pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "OnPawnSensed");

	Params::CamperPlayer_OnPawnSensed Parms{};

	Parms.pawn = pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.OnPickUpDenied
// (Final, Native, Protected, BlueprintCallable)

void ACamperPlayer::OnPickUpDenied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "OnPickUpDenied");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.OnPickUpEnter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       picker                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   transitionTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::OnPickUpEnter(class ADBDPlayer* picker, float transitionTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "OnPickUpEnter");

	Params::CamperPlayer_OnPickUpEnter Parms{};

	Parms.picker = picker;
	Parms.transitionTime = transitionTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.OnProximityEntered
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              hitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           otherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              otherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   otherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                sweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACamperPlayer::OnProximityEntered(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "OnProximityEntered");

	Params::CamperPlayer_OnProximityEntered Parms{};

	Parms.hitComponent = hitComponent;
	Parms.otherActor = otherActor;
	Parms.otherComp = otherComp;
	Parms.otherBodyIndex = otherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.sweepResult = std::move(sweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.OnRep_RunInputPressed
// (Final, Native, Private)

void ACamperPlayer::OnRep_RunInputPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "OnRep_RunInputPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.OnRep_SprintEffect
// (Final, Native, Private)

void ACamperPlayer::OnRep_SprintEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "OnRep_SprintEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.OnUnhooked
// (Final, Native, Public, BlueprintCallable)

void ACamperPlayer::OnUnhooked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "OnUnhooked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.RemoveReverseBearTrap
// (Event, Public, BlueprintEvent)

void ACamperPlayer::RemoveReverseBearTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "RemoveReverseBearTrap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CamperPlayer.ResetCameraAttach
// (Final, Native, Public, BlueprintCallable)

void ACamperPlayer::ResetCameraAttach()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "ResetCameraAttach");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.ResetPotentialSaviors
// (Final, Native, Public, BlueprintCallable)

void ACamperPlayer::ResetPotentialSaviors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "ResetPotentialSaviors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.RunLocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    lock                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::RunLocked(bool lock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "RunLocked");

	Params::CamperPlayer_RunLocked Parms{};

	Parms.lock = lock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.Server_SetOverlappingEscape
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AActor*                           escape                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::Server_SetOverlappingEscape(class AActor* escape)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Server_SetOverlappingEscape");

	Params::CamperPlayer_Server_SetOverlappingEscape Parms{};

	Parms.escape = escape;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.Server_SetRunInput
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::Server_SetRunInput(bool pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "Server_SetRunInput");

	Params::CamperPlayer_Server_SetRunInput Parms{};

	Parms.pressed = pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.SetBeingCarried
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isBeingCarried                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       carrier                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::SetBeingCarried(bool isBeingCarried, class ADBDPlayer* carrier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "SetBeingCarried");

	Params::CamperPlayer_SetBeingCarried Parms{};

	Parms.isBeingCarried = isBeingCarried;
	Parms.carrier = carrier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.SetGuidedAction
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// ECamperGuidedAction                     action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::SetGuidedAction(ECamperGuidedAction action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "SetGuidedAction");

	Params::CamperPlayer_SetGuidedAction Parms{};

	Parms.action = action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.SetGuidedActionLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECamperGuidedAction                     action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::SetGuidedActionLocal(ECamperGuidedAction action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "SetGuidedActionLocal");

	Params::CamperPlayer_SetGuidedActionLocal Parms{};

	Parms.action = action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.SetIsHealingKOCamper
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isHealingKOCamper                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::SetIsHealingKOCamper(bool isHealingKOCamper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "SetIsHealingKOCamper");

	Params::CamperPlayer_SetIsHealingKOCamper Parms{};

	Parms.isHealingKOCamper = isHealingKOCamper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.SetIsSkillCheckFailed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isSkillCheckFailed                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::SetIsSkillCheckFailed(bool isSkillCheckFailed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "SetIsSkillCheckFailed");

	Params::CamperPlayer_SetIsSkillCheckFailed Parms{};

	Parms.isSkillCheckFailed = isSkillCheckFailed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.SetPlayerExposedVFX
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void ACamperPlayer::SetPlayerExposedVFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "SetPlayerExposedVFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CamperPlayer.SetVignetteVisible
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::SetVignetteVisible(bool visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "SetVignetteVisible");

	Params::CamperPlayer_SetVignetteVisible Parms{};

	Parms.visible = visible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.CamperPlayer.StartHealingTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::StartHealingTimer(float time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "StartHealingTimer");

	Params::CamperPlayer_StartHealingTimer Parms{};

	Parms.time = time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.StopHealingTimer
// (Final, Native, Public, BlueprintCallable)

void ACamperPlayer::StopHealingTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "StopHealingTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.TriggerAfflictionHUDFeedback
// (Final, Native, Public, BlueprintCallable)

void ACamperPlayer::TriggerAfflictionHUDFeedback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "TriggerAfflictionHUDFeedback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.TriggerPickUpAnimation
// (Event, Public, BlueprintEvent)

void ACamperPlayer::TriggerPickUpAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "TriggerPickUpAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CamperPlayer.TriggerPutDownAnimation
// (Event, Public, BlueprintEvent)

void ACamperPlayer::TriggerPutDownAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "TriggerPutDownAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CamperPlayer.UpdateHealingTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   deltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACamperPlayer::UpdateHealingTimer(float deltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "UpdateHealingTimer");

	Params::CamperPlayer_UpdateHealingTimer Parms{};

	Parms.deltaTime = deltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperPlayer.AcceptsHealing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::AcceptsHealing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "AcceptsHealing");

	Params::CamperPlayer_AcceptsHealing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.CanBeKilled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::CanBeKilled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "CanBeKilled");

	Params::CamperPlayer_CanBeKilled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.CanBePickedUp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::CanBePickedUp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "CanBePickedUp");

	Params::CamperPlayer_CanBePickedUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.CanBeShocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::CanBeShocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "CanBeShocked");

	Params::CamperPlayer_CanBeShocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.CanRushQuietly
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::CanRushQuietly() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "CanRushQuietly");

	Params::CamperPlayer_CanRushQuietly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetAimPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACamperPlayer::GetAimPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetAimPoint");

	Params::CamperPlayer_GetAimPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetAllEntityRenderRegions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UDBDClipRegionComponent*>  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UDBDClipRegionComponent*> ACamperPlayer::GetAllEntityRenderRegions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetAllEntityRenderRegions");

	Params::CamperPlayer_GetAllEntityRenderRegions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetAttenuationAudioComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAkComponent*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkComponent* ACamperPlayer::GetAttenuationAudioComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetAttenuationAudioComponent");

	Params::CamperPlayer_GetAttenuationAudioComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetBloodTrailComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCamperBloodTrailComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCamperBloodTrailComponent* ACamperPlayer::GetBloodTrailComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetBloodTrailComponent");

	Params::CamperPlayer_GetBloodTrailComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetCameraAttachmentComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCameraAttachmentComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraAttachmentComponent* ACamperPlayer::GetCameraAttachmentComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetCameraAttachmentComponent");

	Params::CamperPlayer_GetCameraAttachmentComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetCamperData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDBDCamperData*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDBDCamperData* ACamperPlayer::GetCamperData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetCamperData");

	Params::CamperPlayer_GetCamperData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetChaseeCharacterComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UChaseeCharacterComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChaseeCharacterComponent* ACamperPlayer::GetChaseeCharacterComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetChaseeCharacterComponent");

	Params::CamperPlayer_GetChaseeCharacterComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetEntityRenderRegionAtIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDBDClipRegionComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDBDClipRegionComponent* ACamperPlayer::GetEntityRenderRegionAtIndex(int32 InIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetEntityRenderRegionAtIndex");

	Params::CamperPlayer_GetEntityRenderRegionAtIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetGuidedAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECamperGuidedAction                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECamperGuidedAction ACamperPlayer::GetGuidedAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetGuidedAction");

	Params::CamperPlayer_GetGuidedAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetHealthComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCamperHealthComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCamperHealthComponent* ACamperPlayer::GetHealthComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetHealthComponent");

	Params::CamperPlayer_GetHealthComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetHookableComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UHookableComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHookableComponent* ACamperPlayer::GetHookableComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetHookableComponent");

	Params::CamperPlayer_GetHookableComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetHookAntiCampingComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UHookAntiCampingComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHookAntiCampingComponent* ACamperPlayer::GetHookAntiCampingComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetHookAntiCampingComponent");

	Params::CamperPlayer_GetHookAntiCampingComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetImmobilizedState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECamperImmobilizeState                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECamperImmobilizeState ACamperPlayer::GetImmobilizedState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetImmobilizedState");

	Params::CamperPlayer_GetImmobilizedState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetIsBeingDissolved
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::GetIsBeingDissolved() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetIsBeingDissolved");

	Params::CamperPlayer_GetIsBeingDissolved Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetIsWiggleProgressionAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::GetIsWiggleProgressionAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetIsWiggleProgressionAllowed");

	Params::CamperPlayer_GetIsWiggleProgressionAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetMaxGruntDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    isLocalPlayerKiller                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACamperPlayer::GetMaxGruntDistance(bool isLocalPlayerKiller) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetMaxGruntDistance");

	Params::CamperPlayer_GetMaxGruntDistance Parms{};

	Parms.isLocalPlayerKiller = isLocalPlayerKiller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetMeshMover
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMoveComponentToComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMoveComponentToComponent* ACamperPlayer::GetMeshMover() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetMeshMover");

	Params::CamperPlayer_GetMeshMover Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetNoOcclusionAudioComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAkComponent*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkComponent* ACamperPlayer::GetNoOcclusionAudioComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetNoOcclusionAudioComponent");

	Params::CamperPlayer_GetNoOcclusionAudioComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetNumberOfEntityRenderRegions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACamperPlayer::GetNumberOfEntityRenderRegions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetNumberOfEntityRenderRegions");

	Params::CamperPlayer_GetNumberOfEntityRenderRegions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetObsessionTargetWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACamperPlayer::GetObsessionTargetWeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetObsessionTargetWeight");

	Params::CamperPlayer_GetObsessionTargetWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetOverlappingEscape
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ACamperPlayer::GetOverlappingEscape() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetOverlappingEscape");

	Params::CamperPlayer_GetOverlappingEscape Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetPercentHealingTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACamperPlayer::GetPercentHealingTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetPercentHealingTimer");

	Params::CamperPlayer_GetPercentHealingTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetReverseBearTrap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AReverseBearTrap*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AReverseBearTrap* ACamperPlayer::GetReverseBearTrap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetReverseBearTrap");

	Params::CamperPlayer_GetReverseBearTrap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetStillness
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACamperPlayer::GetStillness() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetStillness");

	Params::CamperPlayer_GetStillness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetToAimPointRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ACamperPlayer::GetToAimPointRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetToAimPointRotation");

	Params::CamperPlayer_GetToAimPointRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.GetWiggleChargeable
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UChargeableComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableComponent* ACamperPlayer::GetWiggleChargeable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "GetWiggleChargeable");

	Params::CamperPlayer_GetWiggleChargeable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.HasGuidedAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::HasGuidedAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "HasGuidedAction");

	Params::CamperPlayer_HasGuidedAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.HasHitEvents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::HasHitEvents() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "HasHitEvents");

	Params::CamperPlayer_HasHitEvents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.HasReverseBearTrap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::HasReverseBearTrap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "HasReverseBearTrap");

	Params::CamperPlayer_HasReverseBearTrap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsBeingCarried
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsBeingCarried() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsBeingCarried");

	Params::CamperPlayer_IsBeingCarried Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsBeingEndGameSacrificed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsBeingEndGameSacrificed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsBeingEndGameSacrificed");

	Params::CamperPlayer_IsBeingEndGameSacrificed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsBeingHealed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsBeingHealed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsBeingHealed");

	Params::CamperPlayer_IsBeingHealed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsBeingInteractedWith
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsBeingInteractedWith() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsBeingInteractedWith");

	Params::CamperPlayer_IsBeingInteractedWith Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsBeingKilled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsBeingKilled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsBeingKilled");

	Params::CamperPlayer_IsBeingKilled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsBeingMended
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsBeingMended() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsBeingMended");

	Params::CamperPlayer_IsBeingMended Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsBeingPickedUp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsBeingPickedUp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsBeingPickedUp");

	Params::CamperPlayer_IsBeingPickedUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsBeingPulledFromCloset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsBeingPulledFromCloset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsBeingPulledFromCloset");

	Params::CamperPlayer_IsBeingPulledFromCloset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsBeingPutDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsBeingPutDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsBeingPutDown");

	Params::CamperPlayer_IsBeingPutDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsBeingPutOnHook
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsBeingPutOnHook() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsBeingPutOnHook");

	Params::CamperPlayer_IsBeingPutOnHook Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsBeingUnhooked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsBeingUnhooked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsBeingUnhooked");

	Params::CamperPlayer_IsBeingUnhooked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsCrawling
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsCrawling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsCrawling");

	Params::CamperPlayer_IsCrawling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsDeadOrInParadise
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsDeadOrInParadise() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsDeadOrInParadise");

	Params::CamperPlayer_IsDeadOrInParadise Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsEscaped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsEscaped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsEscaped");

	Params::CamperPlayer_IsEscaped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsGuidedBySlasher
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsGuidedBySlasher() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsGuidedBySlasher");

	Params::CamperPlayer_IsGuidedBySlasher Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsHealingTimerExpired
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsHealingTimerExpired() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsHealingTimerExpired");

	Params::CamperPlayer_IsHealingTimerExpired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsHooked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsHooked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsHooked");

	Params::CamperPlayer_IsHooked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsImmobilized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsImmobilized() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsImmobilized");

	Params::CamperPlayer_IsImmobilized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsInDeathBed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsInDeathBed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsInDeathBed");

	Params::CamperPlayer_IsInDeathBed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsInNeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsInNeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsInNeed");

	Params::CamperPlayer_IsInNeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsMovementGuided
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsMovementGuided() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsMovementGuided");

	Params::CamperPlayer_IsMovementGuided Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsObsessionTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsObsessionTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsObsessionTarget");

	Params::CamperPlayer_IsObsessionTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsSacrificed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsSacrificed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsSacrificed");

	Params::CamperPlayer_IsSacrificed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsTrapped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsTrapped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsTrapped");

	Params::CamperPlayer_IsTrapped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsUnhookingSelf
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsUnhookingSelf() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsUnhookingSelf");

	Params::CamperPlayer_IsUnhookingSelf Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsUnintentionallyImmobilized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsUnintentionallyImmobilized() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsUnintentionallyImmobilized");

	Params::CamperPlayer_IsUnintentionallyImmobilized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperPlayer.IsVaulting
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACamperPlayer::IsVaulting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperPlayer", "IsVaulting");

	Params::CamperPlayer_IsVaulting Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CamperSlashableComponent.SetCrouchCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperSlashableComponent::SetCrouchCapsuleHalfHeight(float height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperSlashableComponent", "SetCrouchCapsuleHalfHeight");

	Params::CamperSlashableComponent_SetCrouchCapsuleHalfHeight Parms{};

	Parms.height = height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperSlashableComponent.SetHookSlashableZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCapsuleComponent*                zone                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperSlashableComponent::SetHookSlashableZone(class UCapsuleComponent* zone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperSlashableComponent", "SetHookSlashableZone");

	Params::CamperSlashableComponent_SetHookSlashableZone Parms{};

	Parms.zone = zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperSlashableComponent.SetSlashableZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCapsuleComponent*                zone                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperSlashableComponent::SetSlashableZone(class UCapsuleComponent* zone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperSlashableComponent", "SetSlashableZone");

	Params::CamperSlashableComponent_SetSlashableZone Parms{};

	Parms.zone = zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperSlashableComponent.SetStandingCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperSlashableComponent::SetStandingCapsuleHalfHeight(float height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperSlashableComponent", "SetStandingCapsuleHalfHeight");

	Params::CamperSlashableComponent_SetStandingCapsuleHalfHeight Parms{};

	Parms.height = height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperSlashableComponent.SetUseCrouchSlashableCapsule
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    useCrouchCapsule                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperSlashableComponent::SetUseCrouchSlashableCapsule(bool useCrouchCapsule)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperSlashableComponent", "SetUseCrouchSlashableCapsule");

	Params::CamperSlashableComponent_SetUseCrouchSlashableCapsule Parms{};

	Parms.useCrouchCapsule = useCrouchCapsule;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ColorBlindSettingsListenerInterface.OnColorBlindSettingsChange
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// EColorVisionDeficiency                  colorBlindMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   colorBlindIntensity                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IColorBlindSettingsListenerInterface::OnColorBlindSettingsChange(EColorVisionDeficiency colorBlindMode, int32 colorBlindIntensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ColorBlindSettingsListenerInterface", "OnColorBlindSettingsChange");

	Params::ColorBlindSettingsListenerInterface_OnColorBlindSettingsChange Parms{};

	Parms.colorBlindMode = colorBlindMode;
	Parms.colorBlindIntensity = colorBlindIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StillnessTrackerComponent.StartTracking
// (Final, Native, Private)

void UStillnessTrackerComponent::StartTracking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StillnessTrackerComponent", "StartTracking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperStillnessTrackerComponent.EnterInteriorZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UExposerInteriorZoneComponent*    zone                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperStillnessTrackerComponent::EnterInteriorZone(class UExposerInteriorZoneComponent* zone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperStillnessTrackerComponent", "EnterInteriorZone");

	Params::CamperStillnessTrackerComponent_EnterInteriorZone Parms{};

	Parms.zone = zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperStillnessTrackerComponent.ExitInteriorZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UExposerInteriorZoneComponent*    zone                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperStillnessTrackerComponent::ExitInteriorZone(class UExposerInteriorZoneComponent* zone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperStillnessTrackerComponent", "ExitInteriorZone");

	Params::CamperStillnessTrackerComponent_ExitInteriorZone Parms{};

	Parms.zone = zone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperStillnessTrackerComponent.OnLevelReadyToPlay
// (Final, Native, Protected)

void UCamperStillnessTrackerComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperStillnessTrackerComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperStillnessTrackerComponent.OnOverlapEnter
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCamperStillnessTrackerComponent::OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperStillnessTrackerComponent", "OnOverlapEnter");

	Params::CamperStillnessTrackerComponent_OnOverlapEnter Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CamperStillnessTrackerComponent.OnOverlapExit
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCamperStillnessTrackerComponent::OnOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CamperStillnessTrackerComponent", "OnOverlapExit");

	Params::CamperStillnessTrackerComponent_OnOverlapExit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInGameAssetPreloadState.Server_SetPreloadCompleted
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const class FString&                    preloadInfo                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInGameAssetPreloadState::Server_SetPreloadCompleted(const class FString& preloadInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInGameAssetPreloadState", "Server_SetPreloadCompleted");

	Params::PlayerInGameAssetPreloadState_Server_SetPreloadCompleted Parms{};

	Parms.preloadInfo = std::move(preloadInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CartersSparkComponent.Authority_AddTotallyInsaneSurvivor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       insaneSurvivor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCartersSparkComponent::Authority_AddTotallyInsaneSurvivor(class ADBDPlayer* insaneSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "Authority_AddTotallyInsaneSurvivor");

	Params::CartersSparkComponent_Authority_AddTotallyInsaneSurvivor Parms{};

	Parms.insaneSurvivor = insaneSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CartersSparkComponent.Authority_RegisterToGameEvents
// (Final, Native, Private)

void UCartersSparkComponent::Authority_RegisterToGameEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "Authority_RegisterToGameEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CartersSparkComponent.Multicast_OnShockTherapyCooldownCheatEntered
// (Net, NetReliable, Native, Event, NetMulticast, Public, NetValidate)

void UCartersSparkComponent::Multicast_OnShockTherapyCooldownCheatEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "Multicast_OnShockTherapyCooldownCheatEntered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CartersSparkComponent.OnRequestAndBeginInteraction
// (Final, Native, Private)
// Parameters:
// class UInteractionDefinition*           interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCartersSparkComponent::OnRequestAndBeginInteraction(class UInteractionDefinition* interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "OnRequestAndBeginInteraction");

	Params::CartersSparkComponent_OnRequestAndBeginInteraction Parms{};

	Parms.interaction = interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CartersSparkComponent.TriggerShockTherapyCooldown
// (Final, Native, Public, BlueprintCallable)

void UCartersSparkComponent::TriggerShockTherapyCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "TriggerShockTherapyCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CartersSparkComponent.TriggerStaticBlastCooldown
// (Final, Native, Public, BlueprintCallable)

void UCartersSparkComponent::TriggerStaticBlastCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "TriggerStaticBlastCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CartersSparkComponent.GetStaticBlastCooldownPercentElapsed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCartersSparkComponent::GetStaticBlastCooldownPercentElapsed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "GetStaticBlastCooldownPercentElapsed");

	Params::CartersSparkComponent_GetStaticBlastCooldownPercentElapsed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CartersSparkComponent.IsShockTherapyOnCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCartersSparkComponent::IsShockTherapyOnCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "IsShockTherapyOnCooldown");

	Params::CartersSparkComponent_IsShockTherapyOnCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CartersSparkComponent.IsStaticBlastOnCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCartersSparkComponent::IsStaticBlastOnCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CartersSparkComponent", "IsStaticBlastOnCooldown");

	Params::CartersSparkComponent_IsStaticBlastOnCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGLoadoutItemButton.BroadcastClickedEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             itemID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutItemButton::BroadcastClickedEvent(class FName itemID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutItemButton", "BroadcastClickedEvent");

	Params::UMGLoadoutItemButton_BroadcastClickedEvent Parms{};

	Parms.itemID = itemID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutItemButton.BroadcastLongPressEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             itemID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutItemButton::BroadcastLongPressEvent(class FName itemID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutItemButton", "BroadcastLongPressEvent");

	Params::UMGLoadoutItemButton_BroadcastLongPressEvent Parms{};

	Parms.itemID = itemID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutItemButton.GetLoadoutItemID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UUMGLoadoutItemButton::GetLoadoutItemID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutItemButton", "GetLoadoutItemID");

	Params::UMGLoadoutItemButton_GetLoadoutItemID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGLoadoutItemButton.InitializationForCharacterInfoWidget
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UUMGLoadoutItemButton::InitializationForCharacterInfoWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutItemButton", "InitializationForCharacterInfoWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGLoadoutItemButton.InitializationForLoadoutWidget
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UUMGLoadoutItemButton::InitializationForLoadoutWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutItemButton", "InitializationForLoadoutWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGLoadoutItemButton.OnLockedButtonClicked
// (Final, Native, Private, BlueprintCallable)

void UUMGLoadoutItemButton::OnLockedButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutItemButton", "OnLockedButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutItemButton.SetIconImageByPath
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    iconPath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutItemButton::SetIconImageByPath(const class FString& iconPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutItemButton", "SetIconImageByPath");

	Params::UMGLoadoutItemButton_SetIconImageByPath Parms{};

	Parms.iconPath = std::move(iconPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutItemButton.SetIsSelected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isSelected                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutItemButton::SetIsSelected(bool isSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutItemButton", "SetIsSelected");

	Params::UMGLoadoutItemButton_SetIsSelected Parms{};

	Parms.isSelected = isSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutItemButton.ShowClickableOutline
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    clickable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutItemButton::ShowClickableOutline(bool clickable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutItemButton", "ShowClickableOutline");

	Params::UMGLoadoutItemButton_ShowClickableOutline Parms{};

	Parms.clickable = clickable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutItemButton.UpdateImageColor
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EItemRarity                             rarity                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       effectType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutItemButton::UpdateImageColor(EItemRarity rarity, EStatusEffectType effectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutItemButton", "UpdateImageColor");

	Params::UMGLoadoutItemButton_UpdateImageColor Parms{};

	Parms.rarity = rarity;
	Parms.effectType = effectType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutItemButton.UpdateStackCount
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   stackCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutItemButton::UpdateStackCount(int32 stackCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutItemButton", "UpdateStackCount");

	Params::UMGLoadoutItemButton_UpdateStackCount Parms{};

	Parms.stackCount = stackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutItemButton.UpdateUnlockable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    nameToDisplay                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   unlockableLevel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutItemButton::UpdateUnlockable(const class FString& nameToDisplay, int32 unlockableLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutItemButton", "UpdateUnlockable");

	Params::UMGLoadoutItemButton_UpdateUnlockable Parms{};

	Parms.nameToDisplay = std::move(nameToDisplay);
	Parms.unlockableLevel = unlockableLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutItemButton.UpdateWidgetByData
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FInventorySlotData&        slotData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGLoadoutItemButton::UpdateWidgetByData(const struct FInventorySlotData& slotData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutItemButton", "UpdateWidgetByData");

	Params::UMGLoadoutItemButton_UpdateWidgetByData Parms{};

	Parms.slotData = std::move(slotData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutItemButton.UpdateWidgetByDataBP
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FInventorySlotData&        slotData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGLoadoutItemButton::UpdateWidgetByDataBP(const struct FInventorySlotData& slotData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutItemButton", "UpdateWidgetByDataBP");

	Params::UMGLoadoutItemButton_UpdateWidgetByDataBP Parms{};

	Parms.slotData = std::move(slotData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLoadoutItemButton.UpdateWidgetByState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInventoryButtonState                   state                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutItemButton::UpdateWidgetByState(EInventoryButtonState state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutItemButton", "UpdateWidgetByState");

	Params::UMGLoadoutItemButton_UpdateWidgetByState Parms{};

	Parms.state = state;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGInventoryItemButton.UpdateItemButton
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class ACollectable*                     item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGInventoryItemButton::UpdateItemButton(class ACollectable* item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInventoryItemButton", "UpdateItemButton");

	Params::UMGInventoryItemButton_UpdateItemButton Parms{};

	Parms.item = item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGInventoryItemButton.UpdateItemButtonProgressBar
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class ACollectable*                     item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UProgressBar*                     itemProgressBar                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGInventoryItemButton::UpdateItemButtonProgressBar(class ACollectable* item, class UProgressBar* itemProgressBar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInventoryItemButton", "UpdateItemButtonProgressBar");

	Params::UMGInventoryItemButton_UpdateItemButtonProgressBar Parms{};

	Parms.item = item;
	Parms.itemProgressBar = itemProgressBar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CDNPatchManager.OnInstallFailed
// (Final, Native, Private)
// Parameters:
// const class FText&                      errorText                                              (Parm, NativeAccessSpecifierPublic)
// int32                                   errorCode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCDNPatchManager::OnInstallFailed(const class FText& errorText, int32 errorCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CDNPatchManager", "OnInstallFailed");

	Params::CDNPatchManager_OnInstallFailed Parms{};

	Parms.errorText = std::move(errorText);
	Parms.errorCode = errorCode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CDNPatchManager.OnInstallSucceeded
// (Final, Native, Private)

void UCDNPatchManager::OnInstallSucceeded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CDNPatchManager", "OnInstallSucceeded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CDNPatchManager.OnRequestFailed
// (Final, Native, Private)
// Parameters:
// const class FText&                      errorText                                              (Parm, NativeAccessSpecifierPublic)
// int32                                   errorCode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCDNPatchManager::OnRequestFailed(const class FText& errorText, int32 errorCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CDNPatchManager", "OnRequestFailed");

	Params::CDNPatchManager_OnRequestFailed Parms{};

	Parms.errorText = std::move(errorText);
	Parms.errorCode = errorCode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CDNPatchManager.OnRequestSucceeded
// (Final, Native, Private)
// Parameters:
// class UAtlantaPendingContent*           pendingContent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCDNPatchManager::OnRequestSucceeded(class UAtlantaPendingContent* pendingContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CDNPatchManager", "OnRequestSucceeded");

	Params::CDNPatchManager_OnRequestSucceeded Parms{};

	Parms.pendingContent = pendingContent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterChaseVisualComponent.OnAllChaseEnd
// (Final, Native, Public)

void UCharacterChaseVisualComponent::OnAllChaseEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterChaseVisualComponent", "OnAllChaseEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterChaseVisualComponent.OnObservedCharacterChange
// (Final, Native, Public)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterChaseVisualComponent::OnObservedCharacterChange(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterChaseVisualComponent", "OnObservedCharacterChange");

	Params::CharacterChaseVisualComponent_OnObservedCharacterChange Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDClipRegionComponent.ApplyArrayOfClipsToDynamicMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TArray<class UDBDClipRegionComponent*>&InRegions                                              (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UMaterialInstanceDynamic*         dynamicInstanceToClip                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDClipRegionComponent::ApplyArrayOfClipsToDynamicMaterial(const TArray<class UDBDClipRegionComponent*>& InRegions, class UMaterialInstanceDynamic* dynamicInstanceToClip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDClipRegionComponent", "ApplyArrayOfClipsToDynamicMaterial");

	Params::DBDClipRegionComponent_ApplyArrayOfClipsToDynamicMaterial Parms{};

	Parms.InRegions = std::move(InRegions);
	Parms.dynamicInstanceToClip = dynamicInstanceToClip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDClipRegionComponent.ApplyClip
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UMaterialInstanceDynamic*         InMaterial2clip                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InRegionID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDClipRegionComponent::ApplyClip(class UMaterialInstanceDynamic* InMaterial2clip, int32 InRegionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDClipRegionComponent", "ApplyClip");

	Params::DBDClipRegionComponent_ApplyClip Parms{};

	Parms.InMaterial2clip = InMaterial2clip;
	Parms.InRegionID = InRegionID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDClipRegionComponent.ApplyClipToDynamicMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         dynamicInstanceToClip                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InRegionID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDClipRegionComponent::ApplyClipToDynamicMaterial(class UMaterialInstanceDynamic* dynamicInstanceToClip, int32 InRegionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDClipRegionComponent", "ApplyClipToDynamicMaterial");

	Params::DBDClipRegionComponent_ApplyClipToDynamicMaterial Parms{};

	Parms.dynamicInstanceToClip = dynamicInstanceToClip;
	Parms.InRegionID = InRegionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDClipRegionComponent.ClipDistance
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UMeshComponent*                   InMeshComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDClipRegionComponent::ClipDistance(class UMeshComponent* InMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDClipRegionComponent", "ClipDistance");

	Params::DBDClipRegionComponent_ClipDistance Parms{};

	Parms.InMeshComponent = InMeshComponent;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDClipRegionComponent.NotifyShouldClipComponent
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UMeshComponent*                   InMeshComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDClipRegionComponent::NotifyShouldClipComponent(class UMeshComponent* InMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDClipRegionComponent", "NotifyShouldClipComponent");

	Params::DBDClipRegionComponent_NotifyShouldClipComponent Parms{};

	Parms.InMeshComponent = InMeshComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.CharacterCollection.GetAllDBDPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ADBDPlayer*>         ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class ADBDPlayer*> UCharacterCollection::GetAllDBDPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCollection", "GetAllDBDPlayers");

	Params::CharacterCollection_GetAllDBDPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollection.GetKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASlasherPlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASlasherPlayer* UCharacterCollection::GetKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCollection", "GetKiller");

	Params::CharacterCollection_GetKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollection.GetMainDBDPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSet<class ADBDPlayer*>           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<class ADBDPlayer*> UCharacterCollection::GetMainDBDPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCollection", "GetMainDBDPlayers");

	Params::CharacterCollection_GetMainDBDPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollection.GetSurvivors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSet<class ACamperPlayer*>        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<class ACamperPlayer*> UCharacterCollection::GetSurvivors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterCollection", "GetSurvivors");

	Params::CharacterCollection_GetSurvivors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetAllCharacters
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSet<class ACharacter*>           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<class ACharacter*> UCharacterCollectionUtilities::GetAllCharacters(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetAllCharacters");

	Params::CharacterCollectionUtilities_GetAllCharacters Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetAllDBDPlayers
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADBDPlayer*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDPlayer*> UCharacterCollectionUtilities::GetAllDBDPlayers(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetAllDBDPlayers");

	Params::CharacterCollectionUtilities_GetAllDBDPlayers Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetCharactersByPlayerTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPlayerTeam                             playerTeam                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADBDPlayer*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDPlayer*> UCharacterCollectionUtilities::GetCharactersByPlayerTeam(EPlayerTeam playerTeam, const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetCharactersByPlayerTeam");

	Params::CharacterCollectionUtilities_GetCharactersByPlayerTeam Parms{};

	Parms.playerTeam = playerTeam;
	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetInGamePlayers
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADBDPlayer*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDPlayer*> UCharacterCollectionUtilities::GetInGamePlayers(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetInGamePlayers");

	Params::CharacterCollectionUtilities_GetInGamePlayers Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetInGameSurvivors
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ACamperPlayer*>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACamperPlayer*> UCharacterCollectionUtilities::GetInGameSurvivors(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetInGameSurvivors");

	Params::CharacterCollectionUtilities_GetInGameSurvivors Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetInGameSurvivorsAsPlayers
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADBDPlayer*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDPlayer*> UCharacterCollectionUtilities::GetInGameSurvivorsAsPlayers(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetInGameSurvivorsAsPlayers");

	Params::CharacterCollectionUtilities_GetInGameSurvivorsAsPlayers Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetInGameSurvivorsByRef
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSet<class ACamperPlayer*>        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TSet<class ACamperPlayer*> UCharacterCollectionUtilities::GetInGameSurvivorsByRef(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetInGameSurvivorsByRef");

	Params::CharacterCollectionUtilities_GetInGameSurvivorsByRef Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetKiller
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASlasherPlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASlasherPlayer* UCharacterCollectionUtilities::GetKiller(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetKiller");

	Params::CharacterCollectionUtilities_GetKiller Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterCollectionUtilities.GetNumberOfInjuredHookedOrDyingSurvivors
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UCharacterCollectionUtilities::GetNumberOfInjuredHookedOrDyingSurvivors(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterCollectionUtilities", "GetNumberOfInjuredHookedOrDyingSurvivors");

	Params::CharacterCollectionUtilities_GetNumberOfInjuredHookedOrDyingSurvivors Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.WiggleWidget.BecomeAvailable
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UWiggleWidget::BecomeAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleWidget", "BecomeAvailable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.WiggleWidget.BecomeUnavailable
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UWiggleWidget::BecomeUnavailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WiggleWidget", "BecomeUnavailable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDDesignTunables.GetTunableValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    warnIfRowMissing                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDDesignTunables::GetTunableValue(class FName ID, bool warnIfRowMissing) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDDesignTunables", "GetTunableValue");

	Params::DBDDesignTunables_GetTunableValue Parms{};

	Parms.ID = ID;
	Parms.warnIfRowMissing = warnIfRowMissing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterHelper.GetAllEnabledCharms
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UCharacterHelper::GetAllEnabledCharms()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "GetAllEnabledCharms");

	Params::CharacterHelper_GetAllEnabledCharms Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterHelper.GetAllOutfitComponentsOfCharacter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FCustomizationItemData>*  returnHeads                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FCustomizationItemData>*  returnTorsos                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FCustomizationItemData>*  returnLegsWeapons                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// const class FString&                    characterId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterHelper::GetAllOutfitComponentsOfCharacter(TArray<struct FCustomizationItemData>* returnHeads, TArray<struct FCustomizationItemData>* returnTorsos, TArray<struct FCustomizationItemData>* returnLegsWeapons, const class FString& characterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "GetAllOutfitComponentsOfCharacter");

	Params::CharacterHelper_GetAllOutfitComponentsOfCharacter Parms{};

	Parms.characterId = std::move(characterId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (returnHeads != nullptr)
		*returnHeads = std::move(Parms.returnHeads);

	if (returnTorsos != nullptr)
		*returnTorsos = std::move(Parms.returnTorsos);

	if (returnLegsWeapons != nullptr)
		*returnLegsWeapons = std::move(Parms.returnLegsWeapons);
}


// Function DeadByDaylight.CharacterHelper.GetCharactersByRole
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const EPlayerRole                       role                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCharacterDescription>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCharacterDescription> UCharacterHelper::GetCharactersByRole(const EPlayerRole role)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "GetCharactersByRole");

	Params::CharacterHelper_GetCharactersByRole Parms{};

	Parms.role = role;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterHelper.GetOutfitComposition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCustomizationItemData*          returnHead                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FCustomizationItemData*          returnTorso                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FCustomizationItemData*          returnLegsWeapon                                       (Parm, OutParm, NativeAccessSpecifierPublic)
// const class FString&                    outfitId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterHelper::GetOutfitComposition(struct FCustomizationItemData* returnHead, struct FCustomizationItemData* returnTorso, struct FCustomizationItemData* returnLegsWeapon, const class FString& outfitId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "GetOutfitComposition");

	Params::CharacterHelper_GetOutfitComposition Parms{};

	Parms.outfitId = std::move(outfitId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (returnHead != nullptr)
		*returnHead = std::move(Parms.returnHead);

	if (returnTorso != nullptr)
		*returnTorso = std::move(Parms.returnTorso);

	if (returnLegsWeapon != nullptr)
		*returnLegsWeapon = std::move(Parms.returnLegsWeapon);
}


// Function DeadByDaylight.CharacterHelper.GetOutfitsByCharacterID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    characterId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FOutfitData>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FOutfitData> UCharacterHelper::GetOutfitsByCharacterID(const class FString& characterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "GetOutfitsByCharacterID");

	Params::CharacterHelper_GetOutfitsByCharacterID Parms{};

	Parms.characterId = std::move(characterId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterHelper.SetCharmSlot
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADBDPlayerState*                  playerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      charmId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   slotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharmIdSlot                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCharmIdSlot UCharacterHelper::SetCharmSlot(class ADBDPlayerState* playerState, const class FName& charmId, int32 slotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterHelper", "SetCharmSlot");

	Params::CharacterHelper_SetCharmSlot Parms{};

	Parms.playerState = playerState;
	Parms.charmId = charmId;
	Parms.slotIndex = slotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGAtlantaDailyRewardsScreen.HandleContinueButtonClick
// (Final, Native, Protected, BlueprintCallable)

void UUMGAtlantaDailyRewardsScreen::HandleContinueButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaDailyRewardsScreen", "HandleContinueButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaDailyRewardsScreen.HandleCurrentActiveDailyRewardStateChanged
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   dailyRewardIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   dailyRewardNewState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaDailyRewardsScreen::HandleCurrentActiveDailyRewardStateChanged(int32 dailyRewardIndex, int32 dailyRewardNewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaDailyRewardsScreen", "HandleCurrentActiveDailyRewardStateChanged");

	Params::UMGAtlantaDailyRewardsScreen_HandleCurrentActiveDailyRewardStateChanged Parms{};

	Parms.dailyRewardIndex = dailyRewardIndex;
	Parms.dailyRewardNewState = dailyRewardNewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.AddToInventory
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ACollectable*                     item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInventoryComponent::AddToInventory(class ACollectable* item, EInventoryType inventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "AddToInventory");

	Params::CharacterInventoryComponent_AddToInventory Parms{};

	Parms.item = item;
	Parms.inventoryType = inventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.Authority_Drop
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class ACollectable*                     item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    onDeath                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    adjustToGround                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    dropInChest                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInventoryComponent::Authority_Drop(class ACollectable* item, const struct FVector& location, const struct FRotator& rotation, bool onDeath, bool adjustToGround, bool dropInChest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "Authority_Drop");

	Params::CharacterInventoryComponent_Authority_Drop Parms{};

	Parms.item = item;
	Parms.location = std::move(location);
	Parms.rotation = std::move(rotation);
	Parms.onDeath = onDeath;
	Parms.adjustToGround = adjustToGround;
	Parms.dropInChest = dropInChest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.Authority_UseInventoryItem
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UCharacterInventoryComponent::Authority_UseInventoryItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "Authority_UseInventoryItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.ClearAndDestroyInventory
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UCharacterInventoryComponent::ClearAndDestroyInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "ClearAndDestroyInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.Collect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACollectable*                     item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInventoryComponent::Collect(class ACollectable* item, EInventoryType inventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "Collect");

	Params::CharacterInventoryComponent_Collect Parms{};

	Parms.item = item;
	Parms.inventoryType = inventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.EquipItem
// (Final, Native, Public, BlueprintCallable)

void UCharacterInventoryComponent::EquipItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "EquipItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.GetAddons
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class UItemAddon*>         ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UItemAddon*> UCharacterInventoryComponent::GetAddons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "GetAddons");

	Params::CharacterInventoryComponent_GetAddons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.GetFirstItemFromInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class ACollectable>         item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACollectable*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACollectable* UCharacterInventoryComponent::GetFirstItemFromInventory(TSubclassOf<class ACollectable> item, EInventoryType inventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "GetFirstItemFromInventory");

	Params::CharacterInventoryComponent_GetFirstItemFromInventory Parms{};

	Parms.item = item;
	Parms.inventoryType = inventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.HasInInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class ACollectable>         item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterInventoryComponent::HasInInventory(TSubclassOf<class ACollectable> item, EInventoryType inventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "HasInInventory");

	Params::CharacterInventoryComponent_HasInInventory Parms{};

	Parms.item = item;
	Parms.inventoryType = inventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.Multicast_AddToInventory
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ACollectable*                     item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInventoryComponent::Multicast_AddToInventory(class ACollectable* item, EInventoryType inventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "Multicast_AddToInventory");

	Params::CharacterInventoryComponent_Multicast_AddToInventory Parms{};

	Parms.item = item;
	Parms.inventoryType = inventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.Multicast_ClearAndDestroyInventory
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UCharacterInventoryComponent::Multicast_ClearAndDestroyInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "Multicast_ClearAndDestroyInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.Multicast_RemoveFromInventory
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ACollectable*                     item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInventoryComponent::Multicast_RemoveFromInventory(class ACollectable* item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "Multicast_RemoveFromInventory");

	Params::CharacterInventoryComponent_Multicast_RemoveFromInventory Parms{};

	Parms.item = item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.OnRep_BackpackInventory
// (Final, Native, Private)

void UCharacterInventoryComponent::OnRep_BackpackInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "OnRep_BackpackInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.OnRep_GeneralAddons
// (Final, Native, Private)

void UCharacterInventoryComponent::OnRep_GeneralAddons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "OnRep_GeneralAddons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.OnRep_Inventory
// (Final, Native, Private)

void UCharacterInventoryComponent::OnRep_Inventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "OnRep_Inventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.RemoveFromInventory
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ACollectable*                     item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInventoryComponent::RemoveFromInventory(class ACollectable* item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "RemoveFromInventory");

	Params::CharacterInventoryComponent_RemoveFromInventory Parms{};

	Parms.item = item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.SpawnAndCollectItem
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             itemID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACollectable*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACollectable* UCharacterInventoryComponent::SpawnAndCollectItem(class FName itemID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "SpawnAndCollectItem");

	Params::CharacterInventoryComponent_SpawnAndCollectItem Parms{};

	Parms.itemID = itemID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.StoreItem
// (Final, Native, Public, BlueprintCallable)

void UCharacterInventoryComponent::StoreItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "StoreItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterInventoryComponent.GetItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACollectable*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACollectable* UCharacterInventoryComponent::GetItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "GetItem");

	Params::CharacterInventoryComponent_GetItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.GetItemCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterInventoryComponent::GetItemCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "GetItemCount");

	Params::CharacterInventoryComponent_GetItemCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.GetItemCountByID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             itemID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterInventoryComponent::GetItemCountByID(class FName itemID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "GetItemCountByID");

	Params::CharacterInventoryComponent_GetItemCountByID Parms{};

	Parms.itemID = itemID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.GetItemID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCharacterInventoryComponent::GetItemID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "GetItemID");

	Params::CharacterInventoryComponent_GetItemID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.HasEquippedItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterInventoryComponent::HasEquippedItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "HasEquippedItem");

	Params::CharacterInventoryComponent_HasEquippedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.HasItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterInventoryComponent::HasItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "HasItem");

	Params::CharacterInventoryComponent_HasItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.HasMaximumItemCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ACollectable*               item                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterInventoryComponent::HasMaximumItemCount(const class ACollectable* item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "HasMaximumItemCount");

	Params::CharacterInventoryComponent_HasMaximumItemCount Parms{};

	Parms.item = item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.HasStoredItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterInventoryComponent::HasStoredItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "HasStoredItem");

	Params::CharacterInventoryComponent_HasStoredItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterInventoryComponent.IsUsingAimItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterInventoryComponent::IsUsingAimItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInventoryComponent", "IsUsingAimItem");

	Params::CharacterInventoryComponent_IsUsingAimItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterStatsHandlerComponent.InitializePreMatchStats
// (Final, Native, Private)

void UCharacterStatsHandlerComponent::InitializePreMatchStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatsHandlerComponent", "InitializePreMatchStats");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterStatsHandlerComponent.OnGameEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCharacterStatsHandlerComponent::OnGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatsHandlerComponent", "OnGameEvent");

	Params::CharacterStatsHandlerComponent_OnGameEvent Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharacterStatsHandlerComponent.ReceiveGameEvent
// (Final, Native, Public)
// Parameters:
// EDBDScoreTypes                          scoreType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterStatsHandlerComponent::ReceiveGameEvent(EDBDScoreTypes scoreType, float amount, class AActor* instigator, class AActor* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStatsHandlerComponent", "ReceiveGameEvent");

	Params::CharacterStatsHandlerComponent_ReceiveGameEvent Parms{};

	Parms.scoreType = scoreType;
	Parms.amount = amount;
	Parms.instigator = instigator;
	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenSpaceLocationComponent.GetCurrentResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UScreenSpaceLocationComponent::GetCurrentResolution() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenSpaceLocationComponent", "GetCurrentResolution");

	Params::ScreenSpaceLocationComponent_GetCurrentResolution Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ScreenSpaceLocationComponent.HasValidPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScreenSpaceLocationComponent::HasValidPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreenSpaceLocationComponent", "HasValidPosition");

	Params::ScreenSpaceLocationComponent_HasValidPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGame_Lobby.DBD_AddBotToLobby
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   selectedCharacter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    addon1                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    addon2                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    offering                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    perk1                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    perk2                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    perk3                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    perk4                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGame_Lobby::DBD_AddBotToLobby(int32 selectedCharacter, const class FString& item, const class FString& addon1, const class FString& addon2, const class FString& offering, const class FString& perk1, const class FString& perk2, const class FString& perk3, const class FString& perk4, int32 rank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGame_Lobby", "DBD_AddBotToLobby");

	Params::DBDGame_Lobby_DBD_AddBotToLobby Parms{};

	Parms.selectedCharacter = selectedCharacter;
	Parms.item = std::move(item);
	Parms.addon1 = std::move(addon1);
	Parms.addon2 = std::move(addon2);
	Parms.offering = std::move(offering);
	Parms.perk1 = std::move(perk1);
	Parms.perk2 = std::move(perk2);
	Parms.perk3 = std::move(perk3);
	Parms.perk4 = std::move(perk4);
	Parms.rank = rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGame_Lobby.DBD_AddBotToLobbyByName
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    selectedCharacter                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    item                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    addon1                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    addon2                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    offering                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    perk1                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    perk2                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    perk3                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    perk4                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGame_Lobby::DBD_AddBotToLobbyByName(const class FString& selectedCharacter, const class FString& item, const class FString& addon1, const class FString& addon2, const class FString& offering, const class FString& perk1, const class FString& perk2, const class FString& perk3, const class FString& perk4, int32 rank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGame_Lobby", "DBD_AddBotToLobbyByName");

	Params::DBDGame_Lobby_DBD_AddBotToLobbyByName Parms{};

	Parms.selectedCharacter = std::move(selectedCharacter);
	Parms.item = std::move(item);
	Parms.addon1 = std::move(addon1);
	Parms.addon2 = std::move(addon2);
	Parms.offering = std::move(offering);
	Parms.perk1 = std::move(perk1);
	Parms.perk2 = std::move(perk2);
	Parms.perk3 = std::move(perk3);
	Parms.perk4 = std::move(perk4);
	Parms.rank = rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGame_Lobby.DBD_AddBotToLobbyNoLoadout
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   selectedCharacter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGame_Lobby::DBD_AddBotToLobbyNoLoadout(int32 selectedCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGame_Lobby", "DBD_AddBotToLobbyNoLoadout");

	Params::DBDGame_Lobby_DBD_AddBotToLobbyNoLoadout Parms{};

	Parms.selectedCharacter = selectedCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGame_Lobby.DBD_AddBotToLobbyNoLoadoutByName
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    selectedCharacter                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGame_Lobby::DBD_AddBotToLobbyNoLoadoutByName(const class FString& selectedCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGame_Lobby", "DBD_AddBotToLobbyNoLoadoutByName");

	Params::DBDGame_Lobby_DBD_AddBotToLobbyNoLoadoutByName Parms{};

	Parms.selectedCharacter = std::move(selectedCharacter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGame_Lobby.DBD_FillLobby
// (Final, Exec, Native, Public)

void ADBDGame_Lobby::DBD_FillLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGame_Lobby", "DBD_FillLobby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGame_Lobby.DBD_FillLobbyWithBotsByName
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    selectedKiller                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGame_Lobby::DBD_FillLobbyWithBotsByName(const class FString& selectedKiller, int32 rank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGame_Lobby", "DBD_FillLobbyWithBotsByName");

	Params::DBDGame_Lobby_DBD_FillLobbyWithBotsByName Parms{};

	Parms.selectedKiller = std::move(selectedKiller);
	Parms.rank = rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGame_Lobby.DBD_RemoveBotByIndex
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   botIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDGame_Lobby::DBD_RemoveBotByIndex(int32 botIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGame_Lobby", "DBD_RemoveBotByIndex");

	Params::DBDGame_Lobby_DBD_RemoveBotByIndex Parms{};

	Parms.botIndex = botIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SpecialEventManager.GetCurrentMainSpecialEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCombinedSpecialEventData*       outSpecialEventData                                    (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpecialEventManager::GetCurrentMainSpecialEvent(const class UObject* worldContextObject, struct FCombinedSpecialEventData* outSpecialEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventManager", "GetCurrentMainSpecialEvent");

	Params::SpecialEventManager_GetCurrentMainSpecialEvent Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outSpecialEventData != nullptr)
		*outSpecialEventData = std::move(Parms.outSpecialEventData);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventManager.GetCurrentSpecialEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCombinedSpecialEventData*       outSpecialEventData                                    (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpecialEventManager::GetCurrentSpecialEvent(const class UObject* worldContextObject, struct FCombinedSpecialEventData* outSpecialEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventManager", "GetCurrentSpecialEvent");

	Params::SpecialEventManager_GetCurrentSpecialEvent Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outSpecialEventData != nullptr)
		*outSpecialEventData = std::move(Parms.outSpecialEventData);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventManager.GetEventMainEndDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    eventId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime*                       outDate                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpecialEventManager::GetEventMainEndDate(const class FString& eventId, struct FDateTime* outDate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventManager", "GetEventMainEndDate");

	Params::SpecialEventManager_GetEventMainEndDate Parms{};

	Parms.eventId = std::move(eventId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outDate != nullptr)
		*outDate = std::move(Parms.outDate);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventManager.GetEventPostEndDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    eventId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime*                       outDate                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpecialEventManager::GetEventPostEndDate(const class FString& eventId, struct FDateTime* outDate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventManager", "GetEventPostEndDate");

	Params::SpecialEventManager_GetEventPostEndDate Parms{};

	Parms.eventId = std::move(eventId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outDate != nullptr)
		*outDate = std::move(Parms.outDate);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventManager.GetEventStartDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    eventId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime*                       outDate                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpecialEventManager::GetEventStartDate(const class FString& eventId, struct FDateTime* outDate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventManager", "GetEventStartDate");

	Params::SpecialEventManager_GetEventStartDate Parms{};

	Parms.eventId = std::move(eventId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outDate != nullptr)
		*outDate = std::move(Parms.outDate);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventManager.GetEventTimeSinceStartDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    eventId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan*                       outDate                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpecialEventManager::GetEventTimeSinceStartDate(const class FString& eventId, struct FTimespan* outDate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventManager", "GetEventTimeSinceStartDate");

	Params::SpecialEventManager_GetEventTimeSinceStartDate Parms{};

	Parms.eventId = std::move(eventId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outDate != nullptr)
		*outDate = std::move(Parms.outDate);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventManager.GetEventTimeTillMainEndDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    eventId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan*                       outDate                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpecialEventManager::GetEventTimeTillMainEndDate(const class FString& eventId, struct FTimespan* outDate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventManager", "GetEventTimeTillMainEndDate");

	Params::SpecialEventManager_GetEventTimeTillMainEndDate Parms{};

	Parms.eventId = std::move(eventId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outDate != nullptr)
		*outDate = std::move(Parms.outDate);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventManager.GetEventTimeTillPostEndDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    eventId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan*                       outDate                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpecialEventManager::GetEventTimeTillPostEndDate(const class FString& eventId, struct FTimespan* outDate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventManager", "GetEventTimeTillPostEndDate");

	Params::SpecialEventManager_GetEventTimeTillPostEndDate Parms{};

	Parms.eventId = std::move(eventId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outDate != nullptr)
		*outDate = std::move(Parms.outDate);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventManager.GetMainEndDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& specialEventData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime USpecialEventManager::GetMainEndDate(const struct FCombinedSpecialEventData& specialEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventManager", "GetMainEndDate");

	Params::SpecialEventManager_GetMainEndDate Parms{};

	Parms.specialEventData = std::move(specialEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventManager.GetPostEndDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& specialEventData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime USpecialEventManager::GetPostEndDate(const struct FCombinedSpecialEventData& specialEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventManager", "GetPostEndDate");

	Params::SpecialEventManager_GetPostEndDate Parms{};

	Parms.specialEventData = std::move(specialEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventManager.GetSpecialEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          worldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       eventId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCombinedSpecialEventData*       outSpecialEventData                                    (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USpecialEventManager::GetSpecialEvent(class UObject* worldContextObject, const class FName eventId, struct FCombinedSpecialEventData* outSpecialEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventManager", "GetSpecialEvent");

	Params::SpecialEventManager_GetSpecialEvent Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.eventId = eventId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outSpecialEventData != nullptr)
		*outSpecialEventData = std::move(Parms.outSpecialEventData);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventManager.GetStartDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& specialEventData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime USpecialEventManager::GetStartDate(const struct FCombinedSpecialEventData& specialEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventManager", "GetStartDate");

	Params::SpecialEventManager_GetStartDate Parms{};

	Parms.specialEventData = std::move(specialEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventManager.GetStatus
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& specialEventData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// ESpecialEventStatus                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESpecialEventStatus USpecialEventManager::GetStatus(const struct FCombinedSpecialEventData& specialEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventManager", "GetStatus");

	Params::SpecialEventManager_GetStatus Parms{};

	Parms.specialEventData = std::move(specialEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventManager.GetTimeSinceStartDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& specialEventData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan USpecialEventManager::GetTimeSinceStartDate(const struct FCombinedSpecialEventData& specialEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventManager", "GetTimeSinceStartDate");

	Params::SpecialEventManager_GetTimeSinceStartDate Parms{};

	Parms.specialEventData = std::move(specialEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventManager.GetTimeTillMainEndDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& specialEventData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan USpecialEventManager::GetTimeTillMainEndDate(const struct FCombinedSpecialEventData& specialEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventManager", "GetTimeTillMainEndDate");

	Params::SpecialEventManager_GetTimeTillMainEndDate Parms{};

	Parms.specialEventData = std::move(specialEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SpecialEventManager.GetTimeTillPostEndDate
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& specialEventData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan USpecialEventManager::GetTimeTillPostEndDate(const struct FCombinedSpecialEventData& specialEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SpecialEventManager", "GetTimeTillPostEndDate");

	Params::SpecialEventManager_GetTimeTillPostEndDate Parms{};

	Parms.specialEventData = std::move(specialEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterUtilities.GetActorLocationFromFeetLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ACharacter*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   feetLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterUtilities::GetActorLocationFromFeetLocation(const class ACharacter* character, const struct FVector& feetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterUtilities", "GetActorLocationFromFeetLocation");

	Params::CharacterUtilities_GetActorLocationFromFeetLocation Parms{};

	Parms.character = character;
	Parms.feetLocation = std::move(feetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterUtilities.GetFeetPosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ACharacter*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterUtilities::GetFeetPosition(const class ACharacter* character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterUtilities", "GetFeetPosition");

	Params::CharacterUtilities_GetFeetPosition Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharacterUtilities.GetFeetPositionAtTargetLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ACharacter*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCharacterUtilities::GetFeetPositionAtTargetLocation(const class ACharacter* character, const struct FVector& location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CharacterUtilities", "GetFeetPositionAtTargetLocation");

	Params::CharacterUtilities_GetFeetPositionAtTargetLocation Parms{};

	Parms.character = character;
	Parms.location = std::move(location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SelectiveVisibilityComponent.Local_SetVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewVisibility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPropagateToChildren                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USelectiveVisibilityComponent::Local_SetVisibility(bool bNewVisibility, bool bPropagateToChildren)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SelectiveVisibilityComponent", "Local_SetVisibility");

	Params::SelectiveVisibilityComponent_Local_SetVisibility Parms{};

	Parms.bNewVisibility = bNewVisibility;
	Parms.bPropagateToChildren = bPropagateToChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameFlowUtilities.TriggerUIFlowEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          worldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUIFlowEvent                            uiFlowEvent                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameFlowUtilities::TriggerUIFlowEvent(class UObject* worldContextObject, EUIFlowEvent uiFlowEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameFlowUtilities", "TriggerUIFlowEvent");

	Params::DBDGameFlowUtilities_TriggerUIFlowEvent Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.uiFlowEvent = uiFlowEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameFlowUtilities.TriggerWorldFlowEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          worldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWorldFlowEvent                         worldFlowEvent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameFlowUtilities::TriggerWorldFlowEvent(class UObject* worldContextObject, EWorldFlowEvent worldFlowEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameFlowUtilities", "TriggerWorldFlowEvent");

	Params::DBDGameFlowUtilities_TriggerWorldFlowEvent Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.worldFlowEvent = worldFlowEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargedAttackStateComponent.SetChargingPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   chargePercent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargedAttackStateComponent::SetChargingPercent(float chargePercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargedAttackStateComponent", "SetChargingPercent");

	Params::ChargedAttackStateComponent_SetChargingPercent Parms{};

	Parms.chargePercent = chargePercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargedAttackStateComponent.SetIsCharging
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isCharging                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargedAttackStateComponent::SetIsCharging(bool isCharging)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargedAttackStateComponent", "SetIsCharging");

	Params::ChargedAttackStateComponent_SetIsCharging Parms{};

	Parms.isCharging = isCharging;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargedAttackStateComponent.GetChargingPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargedAttackStateComponent::GetChargingPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargedAttackStateComponent", "GetChargingPercent");

	Params::ChargedAttackStateComponent_GetChargingPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargedAttackStateComponent.GetIsCharging
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChargedAttackStateComponent::GetIsCharging() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargedAttackStateComponent", "GetIsCharging");

	Params::ChargedAttackStateComponent_GetIsCharging Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargerComponent.OnRep_EnergyLevel
// (Final, Native, Private)
// Parameters:
// float                                   previousEnergyLevel                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargerComponent::OnRep_EnergyLevel(float previousEnergyLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "OnRep_EnergyLevel");

	Params::ChargerComponent_OnRep_EnergyLevel Parms{};

	Parms.previousEnergyLevel = previousEnergyLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargerComponent.Reset
// (Final, Native, Public, BlueprintCallable)

void UChargerComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargerComponent.SetEnergyLevel
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   energyLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargerComponent::SetEnergyLevel(float energyLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "SetEnergyLevel");

	Params::ChargerComponent_SetEnergyLevel Parms{};

	Parms.energyLevel = energyLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargerComponent.SetMaxEnergyLevel
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   energyLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargerComponent::SetMaxEnergyLevel(float energyLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "SetMaxEnergyLevel");

	Params::ChargerComponent_SetMaxEnergyLevel Parms{};

	Parms.energyLevel = energyLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargerComponent.SetNormalizedEnergyLevel
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   energyLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargerComponent::SetNormalizedEnergyLevel(float energyLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "SetNormalizedEnergyLevel");

	Params::ChargerComponent_SetNormalizedEnergyLevel Parms{};

	Parms.energyLevel = energyLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargerComponent.UseEnergy
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   energyUseModifier                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChargerComponent::UseEnergy(float seconds, float energyUseModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "UseEnergy");

	Params::ChargerComponent_UseEnergy Parms{};

	Parms.seconds = seconds;
	Parms.energyUseModifier = energyUseModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChargerComponent.GetEnergyLevel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargerComponent::GetEnergyLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "GetEnergyLevel");

	Params::ChargerComponent_GetEnergyLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargerComponent.GetMaxEnergyLevel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargerComponent::GetMaxEnergyLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "GetMaxEnergyLevel");

	Params::ChargerComponent_GetMaxEnergyLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargerComponent.GetNormalizedEnergyLevel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargerComponent::GetNormalizedEnergyLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "GetNormalizedEnergyLevel");

	Params::ChargerComponent_GetNormalizedEnergyLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ChargerComponent.HasCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChargerComponent::HasCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargerComponent", "HasCharge");

	Params::ChargerComponent_HasCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharmAttacher.BindOnCharmAnimationTagsChanged
// (Final, Native, Private)

void ACharmAttacher::BindOnCharmAnimationTagsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharmAttacher", "BindOnCharmAnimationTagsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharmAttacher.DispatchOnCharmAnimationTagsChanged
// (Final, Native, Private)

void ACharmAttacher::DispatchOnCharmAnimationTagsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharmAttacher", "DispatchOnCharmAnimationTagsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CharmAttacher.GetActorAttachedOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ACharmAttacher::GetActorAttachedOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharmAttacher", "GetActorAttachedOn");

	Params::CharmAttacher_GetActorAttachedOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharmAttacher.GetAnimationTweak
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FCharmAttacherAnimationTweak     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCharmAttacherAnimationTweak ACharmAttacher::GetAnimationTweak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharmAttacher", "GetAnimationTweak");

	Params::CharmAttacher_GetAnimationTweak Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharmAttacher.GetAttachedCharm
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharm*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharm* ACharmAttacher::GetAttachedCharm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharmAttacher", "GetAttachedCharm");

	Params::CharmAttacher_GetAttachedCharm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharmAttacher.GetSkeletalMeshComponentAttachedOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ACharmAttacher::GetSkeletalMeshComponentAttachedOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharmAttacher", "GetSkeletalMeshComponentAttachedOn");

	Params::CharmAttacher_GetSkeletalMeshComponentAttachedOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CharmSpawnerComponent.ReplaceCharmTextures
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FCharmIdSlot>&      customization                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCharmSpawnerComponent::ReplaceCharmTextures(const TArray<struct FCharmIdSlot>& customization)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharmSpawnerComponent", "ReplaceCharmTextures");

	Params::CharmSpawnerComponent_ReplaceCharmTextures Parms{};

	Parms.customization = std::move(customization);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaseComponent.OnRep_IsInChase
// (Native, Protected)

void UChaseComponent::OnRep_IsInChase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaseComponent", "OnRep_IsInChase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaseComponent.IsInChase
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UChaseComponent::IsInChase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaseComponent", "IsInChase");

	Params::ChaseComponent_IsInChase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TallyScreen.OnBloodwebButtonClick
// (Final, Native, Protected)

void UTallyScreen::OnBloodwebButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TallyScreen", "OnBloodwebButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TallyScreen.OnCustomerSupportButtonClick
// (Final, Native, Protected)

void UTallyScreen::OnCustomerSupportButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TallyScreen", "OnCustomerSupportButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TallyScreen.OnLeaveButtonClick
// (Final, Native, Protected)

void UTallyScreen::OnLeaveButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TallyScreen", "OnLeaveButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TallyScreen.OnLevelingSequenceComplete
// (Final, Native, Protected)

void UTallyScreen::OnLevelingSequenceComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TallyScreen", "OnLevelingSequenceComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TallyScreen.OnPlayerInfoClick
// (Final, Native, Protected)
// Parameters:
// const class FString&                    playerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTallyScreen::OnPlayerInfoClick(const class FString& playerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TallyScreen", "OnPlayerInfoClick");

	Params::TallyScreen_OnPlayerInfoClick Parms{};

	Parms.playerId = std::move(playerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TallyScreen.OnPlayerOptionClick
// (Final, Native, Protected)
// Parameters:
// const class FString&                    krakenId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    playerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTallyScreen::OnPlayerOptionClick(const class FString& krakenId, const class FString& playerId, uint8 option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TallyScreen", "OnPlayerOptionClick");

	Params::TallyScreen_OnPlayerOptionClick Parms{};

	Parms.krakenId = std::move(krakenId);
	Parms.playerId = std::move(playerId);
	Parms.option = option;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TallyScreen.OnRateMatch
// (Final, Native, Protected)
// Parameters:
// int32                                   rateValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTallyScreen::OnRateMatch(int32 rateValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TallyScreen", "OnRateMatch");

	Params::TallyScreen_OnRateMatch Parms{};

	Parms.rateValue = rateValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TallyScreen.OnReportPlayerButtonClick
// (Final, Native, Protected)
// Parameters:
// const class FString&                    playerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTallyScreen::OnReportPlayerButtonClick(const class FString& playerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TallyScreen", "OnReportPlayerButtonClick");

	Params::TallyScreen_OnReportPlayerButtonClick Parms{};

	Parms.playerId = std::move(playerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TallyScreen.OnShowSlasherInfos
// (Final, Native, Protected)

void UTallyScreen::OnShowSlasherInfos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TallyScreen", "OnShowSlasherInfos");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TallyScreen.OnSpectateButtonClick
// (Final, Native, Protected)

void UTallyScreen::OnSpectateButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TallyScreen", "OnSpectateButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaseeCharacterComponent.Authority_OnGeneratorPercentChanged
// (Final, Native, Private)
// Parameters:
// class UChargeableComponent*             chargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   percentCompletionChange                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   totalPercentComplete                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaseeCharacterComponent::Authority_OnGeneratorPercentChanged(class UChargeableComponent* chargeableComponent, float percentCompletionChange, float totalPercentComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaseeCharacterComponent", "Authority_OnGeneratorPercentChanged");

	Params::ChaseeCharacterComponent_Authority_OnGeneratorPercentChanged Parms{};

	Parms.chargeableComponent = chargeableComponent;
	Parms.percentCompletionChange = percentCompletionChange;
	Parms.totalPercentComplete = totalPercentComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaseeCharacterComponent.Authority_OnLevelReadyToPlay
// (Final, Native, Private)

void UChaseeCharacterComponent::Authority_OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaseeCharacterComponent", "Authority_OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaserCharacterComponent.Authority_OnChaseTargetFound
// (Final, Native, Private)
// Parameters:
// class APawn*                            pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaserCharacterComponent::Authority_OnChaseTargetFound(class APawn* pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaserCharacterComponent", "Authority_OnChaseTargetFound");

	Params::ChaserCharacterComponent_Authority_OnChaseTargetFound Parms{};

	Parms.pawn = pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaserCharacterComponent.Multicast_OnAllChaseEnd
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UChaserCharacterComponent::Multicast_OnAllChaseEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaserCharacterComponent", "Multicast_OnAllChaseEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaserCharacterComponent.Multicast_OnChaseEnd
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FChaseUpdateInfo&          chaseUpdateInfo                                        (ConstParm, Parm, NativeAccessSpecifierPublic)

void UChaserCharacterComponent::Multicast_OnChaseEnd(class ACamperPlayer* survivor, const struct FChaseUpdateInfo& chaseUpdateInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaserCharacterComponent", "Multicast_OnChaseEnd");

	Params::ChaserCharacterComponent_Multicast_OnChaseEnd Parms{};

	Parms.survivor = survivor;
	Parms.chaseUpdateInfo = std::move(chaseUpdateInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaserCharacterComponent.Multicast_OnChaseStart
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaserCharacterComponent::Multicast_OnChaseStart(class ACamperPlayer* survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaserCharacterComponent", "Multicast_OnChaseStart");

	Params::ChaserCharacterComponent_Multicast_OnChaseStart Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChaserCharacterComponent.OnKillerLocallyObservedChanged
// (Final, Native, Private)
// Parameters:
// bool                                    locallyObserved                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChaserCharacterComponent::OnKillerLocallyObservedChanged(bool locallyObserved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChaserCharacterComponent", "OnKillerLocallyObservedChanged");

	Params::ChaserCharacterComponent_OnKillerLocallyObservedChanged Parms{};

	Parms.locallyObserved = locallyObserved;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ChatManager.Multicast_DisplayMessage
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const class FString&                    chatIdentifier                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   playerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    mirrorsId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AChatManager::Multicast_DisplayMessage(const class FString& chatIdentifier, int32 playerIndex, const class FString& mirrorsId, const class FString& msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChatManager", "Multicast_DisplayMessage");

	Params::ChatManager_Multicast_DisplayMessage Parms{};

	Parms.chatIdentifier = std::move(chatIdentifier);
	Parms.playerIndex = playerIndex;
	Parms.mirrorsId = std::move(mirrorsId);
	Parms.msg = std::move(msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CinematicManager.CancelAllCinematicToPlay
// (Final, Native, Public, BlueprintCallable)

void UCinematicManager::CancelAllCinematicToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicManager", "CancelAllCinematicToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CinematicManager.GetNextCinematicToPlay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FCinematic                       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCinematic UCinematicManager::GetNextCinematicToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicManager", "GetNextCinematicToPlay");

	Params::CinematicManager_GetNextCinematicToPlay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CinematicManager.PlayMultiple
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FCinematic>&        cinematics                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCinematicManager::PlayMultiple(const TArray<struct FCinematic>& cinematics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicManager", "PlayMultiple");

	Params::CinematicManager_PlayMultiple Parms{};

	Parms.cinematics = std::move(cinematics);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CinematicManager.PlaySingle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FCinematic&                cinematic                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCinematicManager::PlaySingle(const struct FCinematic& cinematic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicManager", "PlaySingle");

	Params::CinematicManager_PlaySingle Parms{};

	Parms.cinematic = std::move(cinematic);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CinematicManager.HasCinematicToPlay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCinematicManager::HasCinematicToPlay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CinematicManager", "HasCinematicToPlay");

	Params::CinematicManager_HasCinematicToPlay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ClipManager.RemoveDissolveMaterials
// (Final, Native, Public, BlueprintCallable)

void AClipManager::RemoveDissolveMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClipManager", "RemoveDissolveMaterials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ClipManager.SphericalDissolveAt
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AClipManager::SphericalDissolveAt(const struct FVector& Location, float radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClipManager", "SphericalDissolveAt");

	Params::ClipManager_SphericalDissolveAt Parms{};

	Parms.Location = std::move(Location);
	Parms.radius = radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CombinedSpecialEventDataUtilities.GetObjectOutlineColour
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UCombinedSpecialEventDataUtilities::GetObjectOutlineColour(const struct FCombinedSpecialEventData& data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CombinedSpecialEventDataUtilities", "GetObjectOutlineColour");

	Params::CombinedSpecialEventDataUtilities_GetObjectOutlineColour Parms{};

	Parms.data = std::move(data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CombinedSpecialEventDataUtilities.GetSpecialMusicState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FCombinedSpecialEventData& data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCombinedSpecialEventDataUtilities::GetSpecialMusicState(const struct FCombinedSpecialEventData& data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CombinedSpecialEventDataUtilities", "GetSpecialMusicState");

	Params::CombinedSpecialEventDataUtilities_GetSpecialMusicState Parms{};

	Parms.data = std::move(data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ConstrainAspectRatioComponent.DBD_ToggleBlackBars
// (Final, Exec, Native, Private)
// Parameters:
// int32                                   option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstrainAspectRatioComponent::DBD_ToggleBlackBars(int32 option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConstrainAspectRatioComponent", "DBD_ToggleBlackBars");

	Params::ConstrainAspectRatioComponent_DBD_ToggleBlackBars Parms{};

	Parms.option = option;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ConstrainAspectRatioComponent.OnIntroCompleted
// (Final, Native, Private)

void UConstrainAspectRatioComponent::OnIntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConstrainAspectRatioComponent", "OnIntroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ConstrainAspectRatioComponent.SetCinematicMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    cinematicMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConstrainAspectRatioComponent::SetCinematicMode(bool cinematicMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConstrainAspectRatioComponent", "SetCinematicMode");

	Params::ConstrainAspectRatioComponent_SetCinematicMode Parms{};

	Parms.cinematicMode = cinematicMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ConstrainAspectRatioComponent.GetCameraConstrainedViewSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FIntPoint UConstrainAspectRatioComponent::GetCameraConstrainedViewSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConstrainAspectRatioComponent", "GetCameraConstrainedViewSize");

	Params::ConstrainAspectRatioComponent_GetCameraConstrainedViewSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGTallyBloodpointsScoreWidget.UpdateWidgetByScoreData
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      title                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class UTexture2D*                 asset                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   scoreValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTallyBloodpointsScoreWidget::UpdateWidgetByScoreData(const class FText& title, const class UTexture2D* asset, int32 scoreValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyBloodpointsScoreWidget", "UpdateWidgetByScoreData");

	Params::UMGTallyBloodpointsScoreWidget_UpdateWidgetByScoreData Parms{};

	Parms.title = std::move(title);
	Parms.asset = asset;
	Parms.scoreValue = scoreValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ContextualQuestComponent.Authority_DebugAddSpecialBehaviour
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   amountRequired                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextualQuestComponent::Authority_DebugAddSpecialBehaviour(class FName id, int32 amountRequired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualQuestComponent", "Authority_DebugAddSpecialBehaviour");

	Params::ContextualQuestComponent_Authority_DebugAddSpecialBehaviour Parms{};

	Parms.id = id;
	Parms.amountRequired = amountRequired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ContextualQuestComponent.Authority_DebugRemoveSpecialBehaviour
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextualQuestComponent::Authority_DebugRemoveSpecialBehaviour(class FName id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualQuestComponent", "Authority_DebugRemoveSpecialBehaviour");

	Params::ContextualQuestComponent_Authority_DebugRemoveSpecialBehaviour Parms{};

	Parms.id = id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ContextualQuestComponent.OnRep_SpecialBehaviourObjectsInfo
// (Final, Native, Private)

void UContextualQuestComponent::OnRep_SpecialBehaviourObjectsInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualQuestComponent", "OnRep_SpecialBehaviourObjectsInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDMaterialBlueprintLibrary.CreateDynamicMaterialInstanceForParticleSystem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UParticleSystemComponent*         System                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMaterialInstanceDynamic*> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UMaterialInstanceDynamic*> UDBDMaterialBlueprintLibrary::CreateDynamicMaterialInstanceForParticleSystem(class UParticleSystemComponent* System)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDMaterialBlueprintLibrary", "CreateDynamicMaterialInstanceForParticleSystem");

	Params::DBDMaterialBlueprintLibrary_CreateDynamicMaterialInstanceForParticleSystem Parms{};

	Parms.System = System;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMaterialBlueprintLibrary.SetTransformParameterInverseValueOnMaterialDynamic
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Value                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UDBDMaterialBlueprintLibrary::SetTransformParameterInverseValueOnMaterialDynamic(class UMaterialInstanceDynamic* Material, class FName ParameterName, const struct FTransform& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDMaterialBlueprintLibrary", "SetTransformParameterInverseValueOnMaterialDynamic");

	Params::DBDMaterialBlueprintLibrary_SetTransformParameterInverseValueOnMaterialDynamic Parms{};

	Parms.Material = Material;
	Parms.ParameterName = ParameterName;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDMaterialBlueprintLibrary.SetTransformParameterValueOnMaterialDynamic
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Value                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UDBDMaterialBlueprintLibrary::SetTransformParameterValueOnMaterialDynamic(class UMaterialInstanceDynamic* Material, class FName ParameterName, const struct FTransform& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDMaterialBlueprintLibrary", "SetTransformParameterValueOnMaterialDynamic");

	Params::DBDMaterialBlueprintLibrary_SetTransformParameterValueOnMaterialDynamic Parms{};

	Parms.Material = Material;
	Parms.ParameterName = ParameterName;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDMaterialBlueprintLibrary.SetTransformParameterValueOnMeshComponent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   Mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                Value                                                  (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UDBDMaterialBlueprintLibrary::SetTransformParameterValueOnMeshComponent(class UMeshComponent* Mesh, class FName ParameterName, const struct FTransform& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDMaterialBlueprintLibrary", "SetTransformParameterValueOnMeshComponent");

	Params::DBDMaterialBlueprintLibrary_SetTransformParameterValueOnMeshComponent Parms{};

	Parms.Mesh = Mesh;
	Parms.ParameterName = ParameterName;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDMaterialBlueprintLibrary.SetVectorParameterValueOnMeshComponent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   Mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDMaterialBlueprintLibrary::SetVectorParameterValueOnMeshComponent(class UMeshComponent* Mesh, class FName ParameterName, const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDMaterialBlueprintLibrary", "SetVectorParameterValueOnMeshComponent");

	Params::DBDMaterialBlueprintLibrary_SetVectorParameterValueOnMeshComponent Parms{};

	Parms.Mesh = Mesh;
	Parms.ParameterName = ParameterName;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGToastNotificationScreen.HandleOnButtonSelected
// (Final, Native, Protected)
// Parameters:
// int32                                   buttonId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   notificationId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGToastNotificationScreen::HandleOnButtonSelected(int32 buttonId, int32 notificationId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGToastNotificationScreen", "HandleOnButtonSelected");

	Params::UMGToastNotificationScreen_HandleOnButtonSelected Parms{};

	Parms.buttonId = buttonId;
	Parms.notificationId = notificationId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGToastNotificationScreen.HandleOnNotificationDisplayEnd
// (Final, Native, Protected)
// Parameters:
// int32                                   notificationId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGToastNotificationScreen::HandleOnNotificationDisplayEnd(int32 notificationId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGToastNotificationScreen", "HandleOnNotificationDisplayEnd");

	Params::UMGToastNotificationScreen_HandleOnNotificationDisplayEnd Parms{};

	Parms.notificationId = notificationId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGToastNotificationScreen.HandleOnPromptSelected
// (Final, Native, Protected)
// Parameters:
// int32                                   notificationId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGToastNotificationScreen::HandleOnPromptSelected(int32 notificationId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGToastNotificationScreen", "HandleOnPromptSelected");

	Params::UMGToastNotificationScreen_HandleOnPromptSelected Parms{};

	Parms.notificationId = notificationId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CoreHudRootWidget.ApplyConstrainedAspectRatio
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isConstrained                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   aspectRatio                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreHudRootWidget::ApplyConstrainedAspectRatio(bool isConstrained, float aspectRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoreHudRootWidget", "ApplyConstrainedAspectRatio");

	Params::CoreHudRootWidget_ApplyConstrainedAspectRatio Parms{};

	Parms.isConstrained = isConstrained;
	Parms.aspectRatio = aspectRatio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.CoreHudRootWidget.FadeInWidgets
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UCoreHudRootWidget::FadeInWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoreHudRootWidget", "FadeInWidgets");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CoreHudRootWidget.FadeOutWidgets
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UCoreHudRootWidget::FadeOutWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoreHudRootWidget", "FadeOutWidgets");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.CoreHudRootWidget.SetWidgetsVisibility
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoreHudRootWidget::SetWidgetsVisibility(bool visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoreHudRootWidget", "SetWidgetsVisibility");

	Params::CoreHudRootWidget_SetWidgetsVisibility Parms{};

	Parms.visible = visible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDMenuPlayer.BeginCreateSequence
// (Event, Protected, BlueprintEvent)

void ADBDMenuPlayer::BeginCreateSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "BeginCreateSequence");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDMenuPlayer.BeginDestroySequence_Internal
// (Native, Event, Protected, BlueprintEvent)

void ADBDMenuPlayer::BeginDestroySequence_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "BeginDestroySequence_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDMenuPlayer.BlockCharacterRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    shouldBlock                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::BlockCharacterRotation(bool shouldBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "BlockCharacterRotation");

	Params::DBDMenuPlayer_BlockCharacterRotation Parms{};

	Parms.shouldBlock = shouldBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDMenuPlayer.GetCharmSpawnerComponent
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UCharmSpawnerComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharmSpawnerComponent* ADBDMenuPlayer::GetCharmSpawnerComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "GetCharmSpawnerComponent");

	Params::DBDMenuPlayer_GetCharmSpawnerComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.IsInMenuPlayer
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDMenuPlayer::IsInMenuPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "IsInMenuPlayer");

	Params::DBDMenuPlayer_IsInMenuPlayer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.OnAllPlayersReadyInOnlineLobby
// (Event, Public, BlueprintEvent)

void ADBDMenuPlayer::OnAllPlayersReadyInOnlineLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnAllPlayersReadyInOnlineLobby");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDMenuPlayer.OnCustomizationTransactionCompleted
// (Event, Public, BlueprintEvent)
// Parameters:
// ECustomizationCategory                  category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::OnCustomizationTransactionCompleted(ECustomizationCategory category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnCustomizationTransactionCompleted");

	Params::DBDMenuPlayer_OnCustomizationTransactionCompleted Parms{};

	Parms.category = category;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDMenuPlayer.OnGuestPlayerDespawned
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDMenuPlayer*                   player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::OnGuestPlayerDespawned(class ADBDMenuPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnGuestPlayerDespawned");

	Params::DBDMenuPlayer_OnGuestPlayerDespawned Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDMenuPlayer.OnGuestPlayerReadyChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDMenuPlayer*                   player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::OnGuestPlayerReadyChanged(class ADBDMenuPlayer* player, bool isReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnGuestPlayerReadyChanged");

	Params::DBDMenuPlayer_OnGuestPlayerReadyChanged Parms{};

	Parms.player = player;
	Parms.isReady = isReady;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDMenuPlayer.OnGuestPlayerSpawned
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDMenuPlayer*                   player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::OnGuestPlayerSpawned(class ADBDMenuPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnGuestPlayerSpawned");

	Params::DBDMenuPlayer_OnGuestPlayerSpawned Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDMenuPlayer.OnIsReadyChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::OnIsReadyChanged(bool isReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnIsReadyChanged");

	Params::DBDMenuPlayer_OnIsReadyChanged Parms{};

	Parms.isReady = isReady;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDMenuPlayer.OnLocalPlayerReadyChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::OnLocalPlayerReadyChanged(bool isReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnLocalPlayerReadyChanged");

	Params::DBDMenuPlayer_OnLocalPlayerReadyChanged Parms{};

	Parms.isReady = isReady;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDMenuPlayer.OnLocalPlayerSpawned
// (Event, Public, BlueprintEvent)

void ADBDMenuPlayer::OnLocalPlayerSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "OnLocalPlayerSpawned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDMenuPlayer.RestartInSequence_Internal
// (Event, Protected, BlueprintEvent)

void ADBDMenuPlayer::RestartInSequence_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "RestartInSequence_Internal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDMenuPlayer.WrappedOnDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDMenuPlayer::WrappedOnDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "WrappedOnDestroyed");

	Params::DBDMenuPlayer_WrappedOnDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDMenuPlayer.GetBlockRotationAfterSpawningTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADBDMenuPlayer::GetBlockRotationAfterSpawningTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "GetBlockRotationAfterSpawningTime");

	Params::DBDMenuPlayer_GetBlockRotationAfterSpawningTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.GetCurrentMenu
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGameFlowStep                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameFlowStep ADBDMenuPlayer::GetCurrentMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "GetCurrentMenu");

	Params::DBDMenuPlayer_GetCurrentMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.GetHandPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EItemHandPosition                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EItemHandPosition ADBDMenuPlayer::GetHandPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "GetHandPosition");

	Params::DBDMenuPlayer_GetHandPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.GetIsLocalPlayerCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDMenuPlayer::GetIsLocalPlayerCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "GetIsLocalPlayerCharacter");

	Params::DBDMenuPlayer_GetIsLocalPlayerCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.GetIsReady
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDMenuPlayer::GetIsReady() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "GetIsReady");

	Params::DBDMenuPlayer_GetIsReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.ShouldApplyPositionOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDMenuPlayer::ShouldApplyPositionOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "ShouldApplyPositionOffset");

	Params::DBDMenuPlayer_ShouldApplyPositionOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMenuPlayer.ShouldShowSpawnAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDMenuPlayer::ShouldShowSpawnAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDMenuPlayer", "ShouldShowSpawnAnimation");

	Params::DBDMenuPlayer_ShouldShowSpawnAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDNavEvadeLoopComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UDBDNavEvadeLoopComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDNavEvadeLoopComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CurrencyDisplayable.BeginDestroySequence_Internal
// (Native, Event, Protected, BlueprintEvent)

void ACurrencyDisplayable::BeginDestroySequence_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurrencyDisplayable", "BeginDestroySequence_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CurrencyDisplayable.FinishSpawningCurrency
// (Event, Public, BlueprintEvent)
// Parameters:
// ECurrencyType                           currencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACurrencyDisplayable::FinishSpawningCurrency(ECurrencyType currencyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurrencyDisplayable", "FinishSpawningCurrency");

	Params::CurrencyDisplayable_FinishSpawningCurrency Parms{};

	Parms.currencyType = currencyType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.RoleSelectionScreen.OnButtonSelected
// (Final, Native, Private)
// Parameters:
// int32                                   buttonId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URoleSelectionScreen::OnButtonSelected(int32 buttonId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoleSelectionScreen", "OnButtonSelected");

	Params::RoleSelectionScreen_OnButtonSelected Parms{};

	Parms.buttonId = buttonId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RoleSelectionScreen.OnChangeUserButtonClick
// (Final, Native, Private)

void URoleSelectionScreen::OnChangeUserButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoleSelectionScreen", "OnChangeUserButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RoleSelectionScreen.OnEventButtonClick
// (Final, Native, Private)

void URoleSelectionScreen::OnEventButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoleSelectionScreen", "OnEventButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyRankBanner.SetAsLocked
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    locked                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTallyRankBanner::SetAsLocked(bool locked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyRankBanner", "SetAsLocked");

	Params::UMGTallyRankBanner_SetAsLocked Parms{};

	Parms.locked = locked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDObserverPlayer.Server_PlayerReady
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ADBDObserverPlayer::Server_PlayerReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDObserverPlayer", "Server_PlayerReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedAnimationComponent.OnCustomizationChanged
// (Final, Native, Private)

void UCustomizedAnimationComponent::OnCustomizationChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedAnimationComponent", "OnCustomizationChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.InitBatcher
// (Final, Native, Private)

void UDBDOutlineComponent::InitBatcher()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "InitBatcher");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UDBDOutlineComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.RefreshOutlineComponent
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)

void UDBDOutlineComponent::RefreshOutlineComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "RefreshOutlineComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.ResetToTransparent
// (Final, Native, Public, BlueprintCallable)

void UDBDOutlineComponent::ResetToTransparent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "ResetToTransparent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.SetFadeIntensity
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// float                                   fadeIntensity                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDOutlineComponent::SetFadeIntensity(float fadeIntensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "SetFadeIntensity");

	Params::DBDOutlineComponent_SetFadeIntensity Parms{};

	Parms.fadeIntensity = fadeIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.SetFadeTexture
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture*                         inFadeTexture                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDOutlineComponent::SetFadeTexture(class UTexture* inFadeTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "SetFadeTexture");

	Params::DBDOutlineComponent_SetFadeTexture Parms{};

	Parms.inFadeTexture = inFadeTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.SetIsOccludingOutlines
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              isOccluding                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDOutlineComponent::SetIsOccludingOutlines(const bool isOccluding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "SetIsOccludingOutlines");

	Params::DBDOutlineComponent_SetIsOccludingOutlines Parms{};

	Parms.isOccluding = isOccluding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.SetMaterialCopyTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               inMaterialToCopy                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDOutlineComponent::SetMaterialCopyTarget(class UMaterialInterface* inMaterialToCopy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "SetMaterialCopyTarget");

	Params::DBDOutlineComponent_SetMaterialCopyTarget Parms{};

	Parms.inMaterialToCopy = inMaterialToCopy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.SetMinimumOutlineDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDOutlineComponent::SetMinimumOutlineDistance(float distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "SetMinimumOutlineDistance");

	Params::DBDOutlineComponent_SetMinimumOutlineDistance Parms{};

	Parms.distance = distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.SetOutlineIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   outlineIntensity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDOutlineComponent::SetOutlineIntensity(float outlineIntensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "SetOutlineIntensity");

	Params::DBDOutlineComponent_SetOutlineIntensity Parms{};

	Parms.outlineIntensity = outlineIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.SetTargetColor
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FLinearColor&              color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDOutlineComponent::SetTargetColor(const struct FLinearColor& color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "SetTargetColor");

	Params::DBDOutlineComponent_SetTargetColor Parms{};

	Parms.color = std::move(color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDOutlineComponent.GetTargetColor
// (Final, BlueprintCosmetic, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FLinearColor               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FLinearColor UDBDOutlineComponent::GetTargetColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDOutlineComponent", "GetTargetColor");

	Params::DBDOutlineComponent_GetTargetColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.ClearAllVfxs
// (Final, Native, Public, BlueprintCallable)

void UCustomizedSkeletalMesh::ClearAllVfxs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "ClearAllVfxs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.CopyCustomization
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UCustomizedSkeletalMesh*    copyFrom                                               (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizedSkeletalMesh::CopyCustomization(const class UCustomizedSkeletalMesh* copyFrom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "CopyCustomization");

	Params::CustomizedSkeletalMesh_CopyCustomization Parms{};

	Parms.copyFrom = copyFrom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.GetMeshOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkinnedMeshComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkinnedMeshComponent* UCustomizedSkeletalMesh::GetMeshOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "GetMeshOwner");

	Params::CustomizedSkeletalMesh_GetMeshOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.SetAllAccessoriesVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizedSkeletalMesh::SetAllAccessoriesVisibility(bool visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "SetAllAccessoriesVisibility");

	Params::CustomizedSkeletalMesh_SetAllAccessoriesVisibility Parms{};

	Parms.visible = visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.SetAllVfxsVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizedSkeletalMesh::SetAllVfxsVisibility(bool visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "SetAllVfxsVisibility");

	Params::CustomizedSkeletalMesh_SetAllVfxsVisibility Parms{};

	Parms.visible = visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.SetCastShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    castShadow                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizedSkeletalMesh::SetCastShadow(bool castShadow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "SetCastShadow");

	Params::CustomizedSkeletalMesh_SetCastShadow Parms{};

	Parms.castShadow = castShadow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.SetMeshOwner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkinnedMeshComponent*            mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizedSkeletalMesh::SetMeshOwner(class USkinnedMeshComponent* mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "SetMeshOwner");

	Params::CustomizedSkeletalMesh_SetMeshOwner Parms{};

	Parms.mesh = mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.SetMeshVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizedSkeletalMesh::SetMeshVisibility(bool visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "SetMeshVisibility");

	Params::CustomizedSkeletalMesh_SetMeshVisibility Parms{};

	Parms.visible = visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.SetVfxsVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECustomizationCategory                  category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizedSkeletalMesh::SetVfxsVisibility(ECustomizationCategory category, bool visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "SetVfxsVisibility");

	Params::CustomizedSkeletalMesh_SetVfxsVisibility Parms{};

	Parms.category = category;
	Parms.visible = visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.Contains
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class FName>&              itemIds                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizedSkeletalMesh::Contains(const TArray<class FName>& itemIds) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "Contains");

	Params::CustomizedSkeletalMesh_Contains Parms{};

	Parms.itemIds = std::move(itemIds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.GetComponents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class USkeletalMeshComponent*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class USkeletalMeshComponent*> UCustomizedSkeletalMesh::GetComponents() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "GetComponents");

	Params::CustomizedSkeletalMesh_GetComponents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.GetCurrentCustomizationItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCustomizedSkeletalMesh::GetCurrentCustomizationItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "GetCurrentCustomizationItems");

	Params::CustomizedSkeletalMesh_GetCurrentCustomizationItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.GetSkeletalMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECustomizationCategory                  category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UCustomizedSkeletalMesh::GetSkeletalMesh(ECustomizationCategory category) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "GetSkeletalMesh");

	Params::CustomizedSkeletalMesh_GetSkeletalMesh Parms{};

	Parms.category = category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomizedSkeletalMesh.HasValidCustomization
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomizedSkeletalMesh::HasValidCustomization() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizedSkeletalMesh", "HasValidCustomization");

	Params::CustomizedSkeletalMesh_HasValidCustomization Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomWidgetWrapper.ApplyOpacity
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   opacity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomWidgetWrapper::ApplyOpacity(float opacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper", "ApplyOpacity");

	Params::CustomWidgetWrapper_ApplyOpacity Parms{};

	Parms.opacity = opacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomWidgetWrapper.ApplyScale
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomWidgetWrapper::ApplyScale(float scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper", "ApplyScale");

	Params::CustomWidgetWrapper_ApplyScale Parms{};

	Parms.scale = scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomWidgetWrapper.ApplyVersion
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   version                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomWidgetWrapper::ApplyVersion(int32 version)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper", "ApplyVersion");

	Params::CustomWidgetWrapper_ApplyVersion Parms{};

	Parms.version = version;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.AddToTranslation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 translation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomWidgetWrapper_HudEditor::AddToTranslation(const struct FVector2D& translation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "AddToTranslation");

	Params::CustomWidgetWrapper_HudEditor_AddToTranslation Parms{};

	Parms.translation = std::move(translation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.ApplyScaleWithOverlappingWrappers
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class UCustomWidgetWrapper_HudEditor*>&allEditableWrappers                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    needDetectOverlapping                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomWidgetWrapper_HudEditor::ApplyScaleWithOverlappingWrappers(float scale, class UWidget* widget, const TArray<class UCustomWidgetWrapper_HudEditor*>& allEditableWrappers, bool needDetectOverlapping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "ApplyScaleWithOverlappingWrappers");

	Params::CustomWidgetWrapper_HudEditor_ApplyScaleWithOverlappingWrappers Parms{};

	Parms.scale = scale;
	Parms.widget = widget;
	Parms.allEditableWrappers = std::move(allEditableWrappers);
	Parms.needDetectOverlapping = needDetectOverlapping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.ClampToViewport
// (Final, Native, Public, BlueprintCallable)

void UCustomWidgetWrapper_HudEditor::ClampToViewport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "ClampToViewport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.FlipPositionWithChildLinkWidget
// (Final, Native, Public, BlueprintCallable)

void UCustomWidgetWrapper_HudEditor::FlipPositionWithChildLinkWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "FlipPositionWithChildLinkWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.FlipScreenPosition
// (Final, Native, Public, BlueprintCallable)

void UCustomWidgetWrapper_HudEditor::FlipScreenPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "FlipScreenPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.CanEditOpacity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomWidgetWrapper_HudEditor::CanEditOpacity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "CanEditOpacity");

	Params::CustomWidgetWrapper_HudEditor_CanEditOpacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.CanEditScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomWidgetWrapper_HudEditor::CanEditScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "CanEditScale");

	Params::CustomWidgetWrapper_HudEditor_CanEditScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.GetOpacity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomWidgetWrapper_HudEditor::GetOpacity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "GetOpacity");

	Params::CustomWidgetWrapper_HudEditor_GetOpacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomWidgetWrapper_HudEditor.GetScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomWidgetWrapper_HudEditor::GetScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_HudEditor", "GetScale");

	Params::CustomWidgetWrapper_HudEditor_GetScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CustomWidgetWrapper_InGame.UpdateSettings
// (Final, Native, Public)

void UCustomWidgetWrapper_InGame::UpdateSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomWidgetWrapper_InGame", "UpdateSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBD_CrossDissolver.KillClone
// (Final, Native, Public, BlueprintCallable)

void UDBD_CrossDissolver::KillClone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBD_CrossDissolver", "KillClone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBD_CrossDissolver.MakeClone
// (Final, Native, Public, BlueprintCallable)

void UDBD_CrossDissolver::MakeClone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBD_CrossDissolver", "MakeClone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBD_SoundEventSpawner.AssetsLoaded
// (Final, Native, Protected)

void ADBD_SoundEventSpawner::AssetsLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBD_SoundEventSpawner", "AssetsLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBD_SoundEventSpawner.OnLoudNoiseTriggered
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           originator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigatingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    shouldTrack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  audibleRange                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isQuickAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isDeceivingNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBD_SoundEventSpawner::OnLoudNoiseTriggered(class AActor* originator, class AActor* instigatingActor, const struct FVector& location, bool shouldTrack, float* audibleRange, bool isQuickAction, bool isDeceivingNoise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBD_SoundEventSpawner", "OnLoudNoiseTriggered");

	Params::DBD_SoundEventSpawner_OnLoudNoiseTriggered Parms{};

	Parms.originator = originator;
	Parms.instigatingActor = instigatingActor;
	Parms.location = std::move(location);
	Parms.shouldTrack = shouldTrack;
	Parms.isQuickAction = isQuickAction;
	Parms.isDeceivingNoise = isDeceivingNoise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (audibleRange != nullptr)
		*audibleRange = Parms.audibleRange;
}


// Function DeadByDaylight.MoriComponent.OnMoriChargeCompleted
// (Final, Native, Public, BlueprintCallable)

void UMoriComponent::OnMoriChargeCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoriComponent", "OnMoriChargeCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MoriComponent.OnMoriFinished
// (Final, Native, Public, BlueprintCallable)

void UMoriComponent::OnMoriFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoriComponent", "OnMoriFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MoriComponent.OnMoriUpdateStart
// (Final, Native, Public, BlueprintCallable)

void UMoriComponent::OnMoriUpdateStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoriComponent", "OnMoriUpdateStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LightFollower.AddFollower
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULightComponent*                  follower                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightFollower::AddFollower(class ULightComponent* follower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightFollower", "AddFollower");

	Params::LightFollower_AddFollower Parms{};

	Parms.follower = follower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LightFollower.SetLeader
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULightComponent*                  leader                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   maxIntensity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightFollower::SetLeader(class ULightComponent* leader, float maxIntensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightFollower", "SetLeader");

	Params::LightFollower_SetLeader Parms{};

	Parms.leader = leader;
	Parms.maxIntensity = maxIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttackerComponent.Local_RequestAttack
// (Native, Public, BlueprintCallable)
// Parameters:
// const EAttackType                       attackType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttackerComponent::Local_RequestAttack(const EAttackType attackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttackerComponent", "Local_RequestAttack");

	Params::DBDAttackerComponent_Local_RequestAttack Parms{};

	Parms.attackType = attackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttackerComponent.Multicast_StoreAttack
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const EAttackType                       attackType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttackerComponent::Multicast_StoreAttack(const EAttackType attackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttackerComponent", "Multicast_StoreAttack");

	Params::DBDAttackerComponent_Multicast_StoreAttack Parms{};

	Parms.attackType = attackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttackerComponent.Server_StoreAttack
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const EAttackType                       attackType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDAttackerComponent::Server_StoreAttack(const EAttackType attackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttackerComponent", "Server_StoreAttack");

	Params::DBDAttackerComponent_Server_StoreAttack Parms{};

	Parms.attackType = attackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDAttackerComponent.IsAnyAttackTransitionRequested
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDAttackerComponent::IsAnyAttackTransitionRequested() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttackerComponent", "IsAnyAttackTransitionRequested");

	Params::DBDAttackerComponent_IsAnyAttackTransitionRequested Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAttackerComponent.IsAttacking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDAttackerComponent::IsAttacking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttackerComponent", "IsAttacking");

	Params::DBDAttackerComponent_IsAttacking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDAttackerComponent.IsAttackTransitionRequested
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EAttackType                       attackType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDAttackerComponent::IsAttackTransitionRequested(const EAttackType attackType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDAttackerComponent", "IsAttackTransitionRequested");

	Params::DBDAttackerComponent_IsAttackTransitionRequested Parms{};

	Parms.attackType = attackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDBaseHud.DBD_ShowAnimHud
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDBaseHud::DBD_ShowAnimHud(bool show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBaseHud", "DBD_ShowAnimHud");

	Params::DBDBaseHud_DBD_ShowAnimHud Parms{};

	Parms.show = show;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDBaseHud.ShowAnimHudBP
// (Event, Protected, BlueprintEvent)

void ADBDBaseHud::ShowAnimHudBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBaseHud", "ShowAnimHudBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.DBDBaseHud.ShouldDrawAnimHud
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDBaseHud::ShouldDrawAnimHud() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDBaseHud", "ShouldDrawAnimHud");

	Params::DBDBaseHud_ShouldDrawAnimHud Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LoadingScreen.OnLoadingTextTimerComplete
// (Final, Native, Public, Const)

void ULoadingScreen::OnLoadingTextTimerComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadingScreen", "OnLoadingTextTimerComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionProficiency.GetIsActive
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class UChargeableInteractionDefinition*chargeableInteraction                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionProficiency::GetIsActive(const class UChargeableInteractionDefinition* chargeableInteraction, const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionProficiency", "GetIsActive");

	Params::InteractionProficiency_GetIsActive Parms{};

	Parms.chargeableInteraction = chargeableInteraction;
	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionProficiency.GetLevel
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class UChargeableInteractionDefinition*chargeableInteraction                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInteractionProficiency::GetLevel(const class UChargeableInteractionDefinition* chargeableInteraction, const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionProficiency", "GetLevel");

	Params::InteractionProficiency_GetLevel Parms{};

	Parms.chargeableInteraction = chargeableInteraction;
	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionProficiency.GetType
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const float                             value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStatusEffectType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStatusEffectType UInteractionProficiency::GetType(const float value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionProficiency", "GetType");

	Params::InteractionProficiency_GetType Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionProficiency.GetValue
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class UChargeableInteractionDefinition*chargeableInteraction                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionProficiency::GetValue(const class UChargeableInteractionDefinition* chargeableInteraction, const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionProficiency", "GetValue");

	Params::InteractionProficiency_GetValue Parms{};

	Parms.chargeableInteraction = chargeableInteraction;
	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.GetLocallyObservedPlayerRole
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerRole                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerRole UDBDCharacterUtilities::GetLocallyObservedPlayerRole(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "GetLocallyObservedPlayerRole");

	Params::DBDCharacterUtilities_GetLocallyObservedPlayerRole Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsAceVisconti
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsAceVisconti(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsAceVisconti");

	Params::DBDCharacterUtilities_IsAceVisconti Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsAdamFrancis
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsAdamFrancis(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsAdamFrancis");

	Params::DBDCharacterUtilities_IsAdamFrancis Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsAshleyWilliams
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsAshleyWilliams(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsAshleyWilliams");

	Params::DBDCharacterUtilities_IsAshleyWilliams Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsClaudetteMorel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsClaudetteMorel(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsClaudetteMorel");

	Params::DBDCharacterUtilities_IsClaudetteMorel Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsDavidKing
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsDavidKing(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsDavidKing");

	Params::DBDCharacterUtilities_IsDavidKing Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsDavidTapp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsDavidTapp(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsDavidTapp");

	Params::DBDCharacterUtilities_IsDavidTapp Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsDwightFairfield
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsDwightFairfield(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsDwightFairfield");

	Params::DBDCharacterUtilities_IsDwightFairfield Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsFengMin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsFengMin(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsFengMin");

	Params::DBDCharacterUtilities_IsFengMin Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsInDreamworld
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsInDreamworld(const class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsInDreamworld");

	Params::DBDCharacterUtilities_IsInDreamworld Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsJakePark
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsJakePark(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsJakePark");

	Params::DBDCharacterUtilities_IsJakePark Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsJaneRomero
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsJaneRomero(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsJaneRomero");

	Params::DBDCharacterUtilities_IsJaneRomero Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsJeffJohansen
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsJeffJohansen(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsJeffJohansen");

	Params::DBDCharacterUtilities_IsJeffJohansen Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsKateDenson
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsKateDenson(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsKateDenson");

	Params::DBDCharacterUtilities_IsKateDenson Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsLaurieStrode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsLaurieStrode(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsLaurieStrode");

	Params::DBDCharacterUtilities_IsLaurieStrode Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsMegThomas
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsMegThomas(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsMegThomas");

	Params::DBDCharacterUtilities_IsMegThomas Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsNancyWheeler
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsNancyWheeler(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsNancyWheeler");

	Params::DBDCharacterUtilities_IsNancyWheeler Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsNeaKarlsson
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsNeaKarlsson(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsNeaKarlsson");

	Params::DBDCharacterUtilities_IsNeaKarlsson Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsPlague
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsPlague(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsPlague");

	Params::DBDCharacterUtilities_IsPlague Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsQuentinSmith
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsQuentinSmith(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsQuentinSmith");

	Params::DBDCharacterUtilities_IsQuentinSmith Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsSlasherLocallyObserved
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsSlasherLocallyObserved(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsSlasherLocallyObserved");

	Params::DBDCharacterUtilities_IsSlasherLocallyObserved Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsSteveHarrington
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsSteveHarrington(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsSteveHarrington");

	Params::DBDCharacterUtilities_IsSteveHarrington Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheBlight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheBlight(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheBlight");

	Params::DBDCharacterUtilities_IsTheBlight Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheCannibal
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheCannibal(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheCannibal");

	Params::DBDCharacterUtilities_IsTheCannibal Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheClown
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheClown(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheClown");

	Params::DBDCharacterUtilities_IsTheClown Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheDemogorgon
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheDemogorgon(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheDemogorgon");

	Params::DBDCharacterUtilities_IsTheDemogorgon Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheDoctor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheDoctor(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheDoctor");

	Params::DBDCharacterUtilities_IsTheDoctor Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheExecutioner
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheExecutioner(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheExecutioner");

	Params::DBDCharacterUtilities_IsTheExecutioner Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheGhost
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheGhost(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheGhost");

	Params::DBDCharacterUtilities_IsTheGhost Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheHag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheHag(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheHag");

	Params::DBDCharacterUtilities_IsTheHag Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheHillBilly
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheHillBilly(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheHillBilly");

	Params::DBDCharacterUtilities_IsTheHillBilly Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheHuntress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheHuntress(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheHuntress");

	Params::DBDCharacterUtilities_IsTheHuntress Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheLegion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheLegion(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheLegion");

	Params::DBDCharacterUtilities_IsTheLegion Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheNightmare
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheNightmare(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheNightmare");

	Params::DBDCharacterUtilities_IsTheNightmare Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheNurse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheNurse(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheNurse");

	Params::DBDCharacterUtilities_IsTheNurse Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheOni
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheOni(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheOni");

	Params::DBDCharacterUtilities_IsTheOni Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsThePig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsThePig(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsThePig");

	Params::DBDCharacterUtilities_IsThePig Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheShape
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheShape(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheShape");

	Params::DBDCharacterUtilities_IsTheShape Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheSpirit
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheSpirit(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheSpirit");

	Params::DBDCharacterUtilities_IsTheSpirit Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheTrapper
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheTrapper(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheTrapper");

	Params::DBDCharacterUtilities_IsTheTrapper Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheTrickster
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheTrickster(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheTrickster");

	Params::DBDCharacterUtilities_IsTheTrickster Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheTwins
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheTwins(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheTwins");

	Params::DBDCharacterUtilities_IsTheTwins Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheTwins_Brother
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheTwins_Brother(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheTwins_Brother");

	Params::DBDCharacterUtilities_IsTheTwins_Brother Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheTwins_Sister
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheTwins_Sister(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheTwins_Sister");

	Params::DBDCharacterUtilities_IsTheTwins_Sister Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsTheWraith
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsTheWraith(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsTheWraith");

	Params::DBDCharacterUtilities_IsTheWraith Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDCharacterUtilities.IsWilliamBillOverbeck
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDBasePlayer*             targetPlayer                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDCharacterUtilities::IsWilliamBillOverbeck(const class ADBDBasePlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDCharacterUtilities", "IsWilliamBillOverbeck");

	Params::DBDCharacterUtilities_IsWilliamBillOverbeck Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.NatAudioCustomMesh.OnBeginOverlapAudioMesh
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              overlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           otherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              otherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   otherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                sweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UNatAudioCustomMesh::OnBeginOverlapAudioMesh(class UPrimitiveComponent* overlappedComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NatAudioCustomMesh", "OnBeginOverlapAudioMesh");

	Params::NatAudioCustomMesh_OnBeginOverlapAudioMesh Parms{};

	Parms.overlappedComponent = overlappedComponent;
	Parms.otherActor = otherActor;
	Parms.otherComp = otherComp;
	Parms.otherBodyIndex = otherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.sweepResult = std::move(sweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NatAudioCustomMesh.OnEndOverlapAudioMesh
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              overlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           otherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              otherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   otherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNatAudioCustomMesh::OnEndOverlapAudioMesh(class UPrimitiveComponent* overlappedComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NatAudioCustomMesh", "OnEndOverlapAudioMesh");

	Params::NatAudioCustomMesh_OnEndOverlapAudioMesh Parms{};

	Parms.overlappedComponent = overlappedComponent;
	Parms.otherActor = otherActor;
	Parms.otherComp = otherComp;
	Parms.otherBodyIndex = otherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDClientSyncer.Multicast_SyncActorToSpawnLocally
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const TArray<struct FSpawnInfo>&        spawnInfos                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   startIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDClientSyncer::Multicast_SyncActorToSpawnLocally(const TArray<struct FSpawnInfo>& spawnInfos, int32 startIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDClientSyncer", "Multicast_SyncActorToSpawnLocally");

	Params::DBDClientSyncer_Multicast_SyncActorToSpawnLocally Parms{};

	Parms.spawnInfos = std::move(spawnInfos);
	Parms.startIndex = startIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDClientSyncer.Multicast_SyncFinalLocallySpawnCount
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// int32                                   numLocal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDClientSyncer::Multicast_SyncFinalLocallySpawnCount(int32 numLocal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDClientSyncer", "Multicast_SyncFinalLocallySpawnCount");

	Params::DBDClientSyncer_Multicast_SyncFinalLocallySpawnCount Parms{};

	Parms.numLocal = numLocal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDClientSyncer.Multicast_SyncSeed
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// int32                                   seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPaperTileMap*                    tileMap                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   generationPlayerCount                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    premadeMap                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDClientSyncer::Multicast_SyncSeed(int32 seed, class UPaperTileMap* tileMap, int32 generationPlayerCount, const class FString& premadeMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDClientSyncer", "Multicast_SyncSeed");

	Params::DBDClientSyncer_Multicast_SyncSeed Parms{};

	Parms.seed = seed;
	Parms.tileMap = tileMap;
	Parms.generationPlayerCount = generationPlayerCount;
	Parms.premadeMap = std::move(premadeMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ColorBlindFunctionLibrary.CallOnColorBlindSettingsChange
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class AActor*                           callingActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UColorBlindFunctionLibrary::CallOnColorBlindSettingsChange(class AActor* callingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ColorBlindFunctionLibrary", "CallOnColorBlindSettingsChange");

	Params::ColorBlindFunctionLibrary_CallOnColorBlindSettingsChange Parms{};

	Parms.callingActor = callingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LightingHelper.DBD_ModifyExposure
// (Final, Exec, Native, Private, BlueprintCallable)
// Parameters:
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightingHelper::DBD_ModifyExposure(float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightingHelper", "DBD_ModifyExposure");

	Params::LightingHelper_DBD_ModifyExposure Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LightingHelper.GetInitialComponentState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             componentName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* ULightingHelper::GetInitialComponentState(class FName componentName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightingHelper", "GetInitialComponentState");

	Params::LightingHelper_GetInitialComponentState Parms{};

	Parms.componentName = componentName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LightingHelper.GetSourceLevelLightingClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* ULightingHelper::GetSourceLevelLightingClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightingHelper", "GetSourceLevelLightingClass");

	Params::LightingHelper_GetSourceLevelLightingClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LightingHelper.GetTextureCube
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             mapTheme                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureCube*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextureCube* ULightingHelper::GetTextureCube(class FName mapTheme)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightingHelper", "GetTextureCube");

	Params::LightingHelper_GetTextureCube Parms{};

	Parms.mapTheme = mapTheme;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LightingHelper.ToggleDreamworldLighting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bActivateDreamworld                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightingHelper::ToggleDreamworldLighting(bool bActivateDreamworld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightingHelper", "ToggleDreamworldLighting");

	Params::LightingHelper_ToggleDreamworldLighting Parms{};

	Parms.bActivateDreamworld = bActivateDreamworld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RitualEvaluatorBase.EvaluateEvent
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FRitualEvent&              ritualEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URitualEvaluatorBase::EvaluateEvent(const struct FRitualEvent& ritualEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RitualEvaluatorBase", "EvaluateEvent");

	Params::RitualEvaluatorBase_EvaluateEvent Parms{};

	Parms.ritualEvent = std::move(ritualEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDDebugInputComponent.DBD_ItsAlive
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    aliveEnabled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDDebugInputComponent::DBD_ItsAlive(bool aliveEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDDebugInputComponent", "DBD_ItsAlive");

	Params::DBDDebugInputComponent_DBD_ItsAlive Parms{};

	Parms.aliveEnabled = aliveEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaPurchasePopup.HandleBuyButtonClicked
// (Final, Native, Protected)

void UUMGAtlantaPurchasePopup::HandleBuyButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaPurchasePopup", "HandleBuyButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaPurchasePopup.HandleCloseButtonClicked
// (Final, Native, Protected)

void UUMGAtlantaPurchasePopup::HandleCloseButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaPurchasePopup", "HandleCloseButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Locker.Authority_EnableOtherInteractors
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const class UInteractor*                usableInteractor                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    usable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocker::Authority_EnableOtherInteractors(const class UInteractor* usableInteractor, bool usable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "Authority_EnableOtherInteractors");

	Params::Locker_Authority_EnableOtherInteractors Parms{};

	Parms.usableInteractor = usableInteractor;
	Parms.usable = usable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Locker.Authority_ReportOpenLockerNoiseEventToAI
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              fastActivation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocker::Authority_ReportOpenLockerNoiseEventToAI(const bool fastActivation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "Authority_ReportOpenLockerNoiseEventToAI");

	Params::Locker_Authority_ReportOpenLockerNoiseEventToAI Parms{};

	Parms.fastActivation = fastActivation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Locker.EjectSurvivor
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ALocker::EjectSurvivor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "EjectSurvivor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Locker.Multicast_EjectSurvivor
// (Net, NetReliable, Native, Event, NetMulticast, Public, NetValidate)

void ALocker::Multicast_EjectSurvivor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "Multicast_EjectSurvivor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Locker.OnRep_PreventAllInteractions
// (Final, Native, Private)

void ALocker::OnRep_PreventAllInteractions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "OnRep_PreventAllInteractions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Locker.OnSurvivorEndPlay
// (Final, Native, Private)
// Parameters:
// class AActor*                           actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          endPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocker::OnSurvivorEndPlay(class AActor* actor, EEndPlayReason endPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "OnSurvivorEndPlay");

	Params::Locker_OnSurvivorEndPlay Parms{};

	Parms.actor = actor;
	Parms.endPlayReason = endPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Locker.OnSurvivorHealthChanged
// (Final, Native, Private)
// Parameters:
// ECamperDamageState                      before                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECamperDamageState                      after                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocker::OnSurvivorHealthChanged(ECamperDamageState before, ECamperDamageState after)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "OnSurvivorHealthChanged");

	Params::Locker_OnSurvivorHealthChanged Parms{};

	Parms.before = before;
	Parms.after = after;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Locker.SetPlayerOpeningLocker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocker::SetPlayerOpeningLocker(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "SetPlayerOpeningLocker");

	Params::Locker_SetPlayerOpeningLocker Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Locker.SetSurvivorInLocker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocker::SetSurvivorInLocker(class ACamperPlayer* survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "SetSurvivorInLocker");

	Params::Locker_SetSurvivorInLocker Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Locker.StopMinNearOutlineDistLerp
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocker::StopMinNearOutlineDistLerp(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "StopMinNearOutlineDistLerp");

	Params::Locker_StopMinNearOutlineDistLerp Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Locker.GetChildInteractionActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ALocker::GetChildInteractionActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "GetChildInteractionActor");

	Params::Locker_GetChildInteractionActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.GetInteractor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractor*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractor* ALocker::GetInteractor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "GetInteractor");

	Params::Locker_GetInteractor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.GetObjectState
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameplayTagContainerComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayTagContainerComponent* ALocker::GetObjectState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "GetObjectState");

	Params::Locker_GetObjectState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.GetPlayerInLocker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ALocker::GetPlayerInLocker() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "GetPlayerInLocker");

	Params::Locker_GetPlayerInLocker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.GetStunZone
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* ALocker::GetStunZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "GetStunZone");

	Params::Locker_GetStunZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.GetSurvivorInLocker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACamperPlayer*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACamperPlayer* ALocker::GetSurvivorInLocker() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "GetSurvivorInLocker");

	Params::Locker_GetSurvivorInLocker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.IsFacingLocker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   toleranceDegreeAngle                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocker::IsFacingLocker(const class ADBDPlayer* player, float toleranceDegreeAngle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "IsFacingLocker");

	Params::Locker_IsFacingLocker Parms{};

	Parms.player = player;
	Parms.toleranceDegreeAngle = toleranceDegreeAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Locker.IsOccupied
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALocker::IsOccupied() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Locker", "IsOccupied");

	Params::Locker_IsOccupied Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkCollectionComponent.OnRep_Array
// (Final, Native, Private, HasOutParams)
// Parameters:
// const TArray<class UPerk*>&             oldArray                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPerkCollectionComponent::OnRep_Array(const TArray<class UPerk*>& oldArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkCollectionComponent", "OnRep_Array");

	Params::PerkCollectionComponent_OnRep_Array Parms{};

	Parms.oldArray = std::move(oldArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameEventUtilities.Authority_AccumulateOngoingGameEvent
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   customValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ongoingWaitTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          customObjectParameter                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   customIntValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameEventUtilities::Authority_AccumulateOngoingGameEvent(const class UObject* worldContextObject, const struct FGameplayTag& gameEventType, class ADBDPlayer* instigator, class AActor* target, float customValue, float ongoingWaitTime, class UObject* customObjectParameter, int32 customIntValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameEventUtilities", "Authority_AccumulateOngoingGameEvent");

	Params::DBDGameEventUtilities_Authority_AccumulateOngoingGameEvent Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.gameEventType = std::move(gameEventType);
	Parms.instigator = instigator;
	Parms.target = target;
	Parms.customValue = customValue;
	Parms.ongoingWaitTime = ongoingWaitTime;
	Parms.customObjectParameter = customObjectParameter;
	Parms.customIntValue = customIntValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameEventUtilities.Authority_DispatcherFireGameEvent
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    broadcastOverNetwork                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   customValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          customObjectParameter                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   customIntValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameEventUtilities::Authority_DispatcherFireGameEvent(const class UObject* worldContextObject, const struct FGameplayTag& gameEventType, bool broadcastOverNetwork, class ADBDPlayer* instigator, class AActor* target, float customValue, class UObject* customObjectParameter, int32 customIntValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameEventUtilities", "Authority_DispatcherFireGameEvent");

	Params::DBDGameEventUtilities_Authority_DispatcherFireGameEvent Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.gameEventType = std::move(gameEventType);
	Parms.broadcastOverNetwork = broadcastOverNetwork;
	Parms.instigator = instigator;
	Parms.target = target;
	Parms.customValue = customValue;
	Parms.customObjectParameter = customObjectParameter;
	Parms.customIntValue = customIntValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameEventUtilities.DispatcherFireGameEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    broadcastOverNetwork                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   customValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          customObjectParameter                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   customIntValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameEventUtilities::DispatcherFireGameEvent(const class UObject* worldContextObject, const struct FGameplayTag& gameEventType, bool broadcastOverNetwork, class ADBDPlayer* instigator, class AActor* target, float customValue, class UObject* customObjectParameter, int32 customIntValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameEventUtilities", "DispatcherFireGameEvent");

	Params::DBDGameEventUtilities_DispatcherFireGameEvent Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.gameEventType = std::move(gameEventType);
	Parms.broadcastOverNetwork = broadcastOverNetwork;
	Parms.instigator = instigator;
	Parms.target = target;
	Parms.customValue = customValue;
	Parms.customObjectParameter = customObjectParameter;
	Parms.customIntValue = customIntValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameEventUtilities.LocallyDispatchGameEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   customValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          customObjectParameter                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   customIntValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameEventUtilities::LocallyDispatchGameEvent(const class UObject* worldContextObject, const struct FGameplayTag& gameEventType, class ADBDPlayer* instigator, class AActor* target, float customValue, class UObject* customObjectParameter, int32 customIntValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameEventUtilities", "LocallyDispatchGameEvent");

	Params::DBDGameEventUtilities_LocallyDispatchGameEvent Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.gameEventType = std::move(gameEventType);
	Parms.instigator = instigator;
	Parms.target = target;
	Parms.customValue = customValue;
	Parms.customObjectParameter = customObjectParameter;
	Parms.customIntValue = customIntValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameEventUtilities.RemotelyDispatchGameEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   customValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          customObjectParameter                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   customIntValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameEventUtilities::RemotelyDispatchGameEvent(const class UObject* worldContextObject, const struct FGameplayTag& gameEventType, class ADBDPlayer* instigator, class AActor* target, float customValue, class UObject* customObjectParameter, int32 customIntValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameEventUtilities", "RemotelyDispatchGameEvent");

	Params::DBDGameEventUtilities_RemotelyDispatchGameEvent Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.gameEventType = std::move(gameEventType);
	Parms.instigator = instigator;
	Parms.target = target;
	Parms.customValue = customValue;
	Parms.customObjectParameter = customObjectParameter;
	Parms.customIntValue = customIntValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkSoundHudIcon.ActivatePerk
// (Native, Public)
// Parameters:
// float                                   percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkSoundHudIcon::ActivatePerk(float percentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkSoundHudIcon", "ActivatePerk");

	Params::PerkSoundHudIcon_ActivatePerk Parms{};

	Parms.percentage = percentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkSoundHudIcon.ClearPerk
// (Native, Public)

void UPerkSoundHudIcon::ClearPerk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkSoundHudIcon", "ClearPerk");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkSoundHudIconSporadic.NativeTick
// (Native, Public, HasOutParams)
// Parameters:
// const struct FGeometry&                 MyGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkSoundHudIconSporadic::NativeTick(const struct FGeometry& MyGeometry, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkSoundHudIconSporadic", "NativeTick");

	Params::PerkSoundHudIconSporadic_NativeTick Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.ForceCloseGame
// (Final, Native, Static, Public)

void UDBDGameInstance::ForceCloseGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameInstance", "ForceCloseGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.AddActorKnowledgeCollection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UActorKnowledgeCollection*        collection                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::AddActorKnowledgeCollection(class UActorKnowledgeCollection* collection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "AddActorKnowledgeCollection");

	Params::DBDGameInstance_AddActorKnowledgeCollection Parms{};

	Parms.collection = collection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.Authority_SimulatePerks
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class FName>&              perks                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::Authority_SimulatePerks(const TArray<class FName>& perks, int32 level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "Authority_SimulatePerks");

	Params::DBDGameInstance_Authority_SimulatePerks Parms{};

	Parms.perks = std::move(perks);
	Parms.level = level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.BeginLoadingScreen
// (Final, Native, Public)
// Parameters:
// const class FString&                    MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::BeginLoadingScreen(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "BeginLoadingScreen");

	Params::DBDGameInstance_BeginLoadingScreen Parms{};

	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ApplyMist
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// const float                             fogModifier                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_ApplyMist(const float fogModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ApplyMist");

	Params::DBDGameInstance_DBD_ApplyMist Parms{};

	Parms.fogModifier = fogModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ApplyNoMist
// (Final, Exec, Native, Public, BlueprintCallable)

void UDBDGameInstance::DBD_ApplyNoMist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ApplyNoMist");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ChangeSteamOverlayPosition
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   verticalOffset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   horizontalOffset                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_ChangeSteamOverlayPosition(int32 position, int32 verticalOffset, int32 horizontalOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ChangeSteamOverlayPosition");

	Params::DBDGameInstance_DBD_ChangeSteamOverlayPosition Parms{};

	Parms.position = position;
	Parms.verticalOffset = verticalOffset;
	Parms.horizontalOffset = horizontalOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_CheckForNewContent
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    debugGameVersion                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    forceDisplay                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_CheckForNewContent(const class FString& debugGameVersion, bool forceDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_CheckForNewContent");

	Params::DBDGameInstance_DBD_CheckForNewContent Parms{};

	Parms.debugGameVersion = std::move(debugGameVersion);
	Parms.forceDisplay = forceDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_DeleteLocalSaveFile
// (Final, Exec, Native, Public, BlueprintCallable)

void UDBDGameInstance::DBD_DeleteLocalSaveFile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_DeleteLocalSaveFile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_DestroySteamInventory
// (Final, Exec, Native, Public)

void UDBDGameInstance::DBD_DestroySteamInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_DestroySteamInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_DisplayCurrentAchievementStat
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             statName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_DisplayCurrentAchievementStat(class FName statName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_DisplayCurrentAchievementStat");

	Params::DBDGameInstance_DBD_DisplayCurrentAchievementStat Parms{};

	Parms.statName = statName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_DumpSessions
// (Final, Exec, Native, Public, BlueprintCallable)

void UDBDGameInstance::DBD_DumpSessions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_DumpSessions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ForceLoad
// (Final, Exec, Native, Public, BlueprintCallable)

void UDBDGameInstance::DBD_ForceLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ForceLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ForceSave
// (Final, Exec, Native, Public, BlueprintCallable)

void UDBDGameInstance::DBD_ForceSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ForceSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_GetRegion
// (Final, Exec, Native, Public)

void UDBDGameInstance::DBD_GetRegion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_GetRegion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_PIXBeginCapture
// (Final, Exec, Native, Public)

void UDBDGameInstance::DBD_PIXBeginCapture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_PIXBeginCapture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_PIXEndCapture
// (Final, Exec, Native, Public)

void UDBDGameInstance::DBD_PIXEndCapture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_PIXEndCapture");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ResetCurrentAchievementStat
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             statName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    andUpload                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_ResetCurrentAchievementStat(class FName statName, bool andUpload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ResetCurrentAchievementStat");

	Params::DBDGameInstance_DBD_ResetCurrentAchievementStat Parms{};

	Parms.statName = statName;
	Parms.andUpload = andUpload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ResetCurrentAchievementStats
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    andUpload                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    andUpdateData                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_ResetCurrentAchievementStats(bool andUpload, bool andUpdateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ResetCurrentAchievementStats");

	Params::DBDGameInstance_DBD_ResetCurrentAchievementStats Parms{};

	Parms.andUpload = andUpload;
	Parms.andUpdateData = andUpdateData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ResetSaveData
// (Final, Exec, Native, Public, BlueprintCallable)

void UDBDGameInstance::DBD_ResetSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ResetSaveData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_SetFearMarketDate
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    dateString                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_SetFearMarketDate(const class FString& dateString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_SetFearMarketDate");

	Params::DBDGameInstance_DBD_SetFearMarketDate Parms{};

	Parms.dateString = std::move(dateString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_SetStatsUploadEnabled
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_SetStatsUploadEnabled(bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_SetStatsUploadEnabled");

	Params::DBDGameInstance_DBD_SetStatsUploadEnabled Parms{};

	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_TestDiceRoll
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   BaseProbability                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MultiplicativeModifier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdditiveModifier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_TestDiceRoll(float BaseProbability, float MultiplicativeModifier, float AdditiveModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_TestDiceRoll");

	Params::DBDGameInstance_DBD_TestDiceRoll Parms{};

	Parms.BaseProbability = BaseProbability;
	Parms.MultiplicativeModifier = MultiplicativeModifier;
	Parms.AdditiveModifier = AdditiveModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_TestRegion
// (Final, Exec, Native, Public)

void UDBDGameInstance::DBD_TestRegion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_TestRegion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_TestSaveFile
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    name                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_TestSaveFile(const class FString& name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_TestSaveFile");

	Params::DBDGameInstance_DBD_TestSaveFile Parms{};

	Parms.name = std::move(name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_TestTickedDiceRoll
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   BaseProbability                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ticks                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MultiplicativeModifier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AdditiveModifier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::DBD_TestTickedDiceRoll(float BaseProbability, float ticks, float MultiplicativeModifier, float AdditiveModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_TestTickedDiceRoll");

	Params::DBDGameInstance_DBD_TestTickedDiceRoll Parms{};

	Parms.BaseProbability = BaseProbability;
	Parms.ticks = ticks;
	Parms.MultiplicativeModifier = MultiplicativeModifier;
	Parms.AdditiveModifier = AdditiveModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_ToggleLightingLoaded
// (Final, Exec, Native, Public, BlueprintCallable)

void UDBDGameInstance::DBD_ToggleLightingLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_ToggleLightingLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_UpdateSteamInventory
// (Final, Exec, Native, Public, BlueprintCallable)

void UDBDGameInstance::DBD_UpdateSteamInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_UpdateSteamInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.EndLoadingScreen
// (Final, Native, Public)
// Parameters:
// class UWorld*                           loadedWorld                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::EndLoadingScreen(class UWorld* loadedWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "EndLoadingScreen");

	Params::DBDGameInstance_EndLoadingScreen Parms{};

	Parms.loadedWorld = loadedWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.GetCharacterDefaultItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   inCharacterIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UDBDGameInstance::GetCharacterDefaultItem(int32 inCharacterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetCharacterDefaultItem");

	Params::DBDGameInstance_GetCharacterDefaultItem Parms{};

	Parms.inCharacterIndex = inCharacterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetLevelLighting
// (Final, Native, Public)
// Parameters:
// class ABaseSky*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseSky* UDBDGameInstance::GetLevelLighting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetLevelLighting");

	Params::DBDGameInstance_GetLevelLighting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetLightingHelper
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULightingHelper*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULightingHelper* UDBDGameInstance::GetLightingHelper()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetLightingHelper");

	Params::DBDGameInstance_GetLightingHelper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetLightInterpolator
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULightingInterpolator*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULightingInterpolator* UDBDGameInstance::GetLightInterpolator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetLightInterpolator");

	Params::DBDGameInstance_GetLightInterpolator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GotoSplashScreen
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    showDefaultDialogueOnSplashScreen                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::GotoSplashScreen(bool showDefaultDialogueOnSplashScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GotoSplashScreen");

	Params::DBDGameInstance_GotoSplashScreen Parms{};

	Parms.showDefaultDialogueOnSplashScreen = showDefaultDialogueOnSplashScreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.RemoveActorKnowledgeCollection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UActorKnowledgeCollection*        collection                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::RemoveActorKnowledgeCollection(class UActorKnowledgeCollection* collection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "RemoveActorKnowledgeCollection");

	Params::DBDGameInstance_RemoveActorKnowledgeCollection Parms{};

	Parms.collection = collection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.SimulateOfferingSequence
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class FName>&              offerings                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    playSequence                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::SimulateOfferingSequence(const TArray<class FName>& offerings, bool playSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "SimulateOfferingSequence");

	Params::DBDGameInstance_SimulateOfferingSequence Parms{};

	Parms.offerings = std::move(offerings);
	Parms.playSequence = playSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.StartOfferingSequence
// (Final, Native, Public)

void UDBDGameInstance::StartOfferingSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "StartOfferingSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.DBD_PrintAudioConfig
// (Final, Exec, Native, Public, BlueprintCallable, Const)

void UDBDGameInstance::DBD_PrintAudioConfig() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "DBD_PrintAudioConfig");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDGameInstance.GetBonusPointEventsManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBonusPointEventsManager*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBonusPointEventsManager* UDBDGameInstance::GetBonusPointEventsManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetBonusPointEventsManager");

	Params::DBDGameInstance_GetBonusPointEventsManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetCharacterClippingPrimitiveCollection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveCollection*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveCollection* UDBDGameInstance::GetCharacterClippingPrimitiveCollection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetCharacterClippingPrimitiveCollection");

	Params::DBDGameInstance_GetCharacterClippingPrimitiveCollection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetCinematicManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCinematicManager*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCinematicManager* UDBDGameInstance::GetCinematicManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetCinematicManager");

	Params::DBDGameInstance_GetCinematicManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetConsentManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UConsentManager*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UConsentManager* UDBDGameInstance::GetConsentManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetConsentManager");

	Params::DBDGameInstance_GetConsentManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetDeadOrDisconnectedCampersCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayerState*                  exception                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDGameInstance::GetDeadOrDisconnectedCampersCount(class ADBDPlayerState* exception) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetDeadOrDisconnectedCampersCount");

	Params::DBDGameInstance_GetDeadOrDisconnectedCampersCount Parms{};

	Parms.exception = exception;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetDecalSpawnerCollection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDecalSpawnerCollection*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDecalSpawnerCollection* UDBDGameInstance::GetDecalSpawnerCollection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetDecalSpawnerCollection");

	Params::DBDGameInstance_GetDecalSpawnerCollection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetDedicatedServerManager
// (Final, Native, Public, Const)
// Parameters:
// class UDedicatedServerManager*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDedicatedServerManager* UDBDGameInstance::GetDedicatedServerManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetDedicatedServerManager");

	Params::DBDGameInstance_GetDedicatedServerManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetInventoryHandler
// (Final, Native, Public, Const)
// Parameters:
// class UInventoryHandler*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInventoryHandler* UDBDGameInstance::GetInventoryHandler() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetInventoryHandler");

	Params::DBDGameInstance_GetInventoryHandler Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetLocalEventManager
// (Final, Native, Public, Const)
// Parameters:
// class ULocalEventManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalEventManager* UDBDGameInstance::GetLocalEventManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetLocalEventManager");

	Params::DBDGameInstance_GetLocalEventManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetLocallyControlledCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UDBDGameInstance::GetLocallyControlledCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetLocallyControlledCharacter");

	Params::DBDGameInstance_GetLocallyControlledCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetLocalPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULocalPlayer*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalPlayer* UDBDGameInstance::GetLocalPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetLocalPlayer");

	Params::DBDGameInstance_GetLocalPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetLocalPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerController* UDBDGameInstance::GetLocalPlayerController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetLocalPlayerController");

	Params::DBDGameInstance_GetLocalPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetMapActorDB
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMapActorDB*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMapActorDB* UDBDGameInstance::GetMapActorDB() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetMapActorDB");

	Params::DBDGameInstance_GetMapActorDB Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetMaxSurvivorCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDGameInstance::GetMaxSurvivorCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetMaxSurvivorCount");

	Params::DBDGameInstance_GetMaxSurvivorCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetPlayerLevelManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDBDPlayerLevelManager*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDBDPlayerLevelManager* UDBDGameInstance::GetPlayerLevelManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetPlayerLevelManager");

	Params::DBDGameInstance_GetPlayerLevelManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetPlayerNameRegistration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPlayerNameRegistration*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayerNameRegistration* UDBDGameInstance::GetPlayerNameRegistration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetPlayerNameRegistration");

	Params::DBDGameInstance_GetPlayerNameRegistration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetRankManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URankManager*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URankManager* UDBDGameInstance::GetRankManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetRankManager");

	Params::DBDGameInstance_GetRankManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetSoftBanManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USoftBanManager*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoftBanManager* UDBDGameInstance::GetSoftBanManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetSoftBanManager");

	Params::DBDGameInstance_GetSoftBanManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetSpecialEventManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USpecialEventManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USpecialEventManager* UDBDGameInstance::GetSpecialEventManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetSpecialEventManager");

	Params::DBDGameInstance_GetSpecialEventManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.GetTimeUtils
// (Final, Native, Public, Const)
// Parameters:
// class UDBDTimeUtilities*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDBDTimeUtilities* UDBDGameInstance::GetTimeUtils() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "GetTimeUtils");

	Params::DBDGameInstance_GetTimeUtils Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.HasOfferingByType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOfferingEffectType                     type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameInstance::HasOfferingByType(EOfferingEffectType type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "HasOfferingByType");

	Params::DBDGameInstance_HasOfferingByType Parms{};

	Parms.type = type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.HasOfferingOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOfferingEffectType                     type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   playerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameInstance::HasOfferingOfType(EOfferingEffectType type, int32 playerId, class FName tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "HasOfferingOfType");

	Params::DBDGameInstance_HasOfferingOfType Parms{};

	Parms.type = type;
	Parms.playerId = playerId;
	Parms.tag = tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.IsActorKnown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 knowledgePossessor                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           possiblyKnownActor                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameInstance::IsActorKnown(const class ADBDPlayer* knowledgePossessor, class AActor* possiblyKnownActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "IsActorKnown");

	Params::DBDGameInstance_IsActorKnown Parms{};

	Parms.knowledgePossessor = knowledgePossessor;
	Parms.possiblyKnownActor = possiblyKnownActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameInstance.OnTimeTravelComplete
// (Final, Native, Public, Const)
// Parameters:
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    date                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDGameInstance::OnTimeTravelComplete(bool success, const class FString& date) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameInstance", "OnTimeTravelComplete");

	Params::DBDGameInstance_OnTimeTravelComplete Parms{};

	Parms.success = success;
	Parms.date = std::move(date);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGDragWidget.SetClampToViewportDirty
// (Final, Native, Public, BlueprintCallable)

void UUMGDragWidget::SetClampToViewportDirty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDragWidget", "SetClampToViewportDirty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGDragWidget.GetAllEditableWidgets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UCustomWidgetWrapper_HudEditor*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UCustomWidgetWrapper_HudEditor*> UUMGDragWidget::GetAllEditableWidgets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDragWidget", "GetAllEditableWidgets");

	Params::UMGDragWidget_GetAllEditableWidgets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGDragWidget_HudEditor.SetOnSelection
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    isSelected                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGDragWidget_HudEditor::SetOnSelection(bool isSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDragWidget_HudEditor", "SetOnSelection");

	Params::UMGDragWidget_HudEditor_SetOnSelection Parms{};

	Parms.isSelected = isSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGDragWidget_HudEditor.GetCustomWrapper
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCustomWidgetWrapper_HudEditor*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCustomWidgetWrapper_HudEditor* UUMGDragWidget_HudEditor::GetCustomWrapper() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDragWidget_HudEditor", "GetCustomWrapper");

	Params::UMGDragWidget_HudEditor_GetCustomWrapper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetDBDGameUserSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDBDGameUserSettings*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDBDGameUserSettings* UDBDGameUserSettings::GetDBDGameUserSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDGameUserSettings", "GetDBDGameUserSettings");

	Params::DBDGameUserSettings_GetDBDGameUserSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetBloodwebInteractionBehaviour
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetBloodwebInteractionBehaviour() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetBloodwebInteractionBehaviour");

	Params::DBDGameUserSettings_GetBloodwebInteractionBehaviour Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetChallengeCompletion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetChallengeCompletion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetChallengeCompletion");

	Params::DBDGameUserSettings_GetChallengeCompletion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetChallengeProgression
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetChallengeProgression() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetChallengeProgression");

	Params::DBDGameUserSettings_GetChallengeProgression Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetColorBlindMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EColorVisionDeficiency                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EColorVisionDeficiency UDBDGameUserSettings::GetColorBlindMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetColorBlindMode");

	Params::DBDGameUserSettings_GetColorBlindMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetColorBlindModeIntensity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDGameUserSettings::GetColorBlindModeIntensity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetColorBlindModeIntensity");

	Params::DBDGameUserSettings_GetColorBlindModeIntensity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetHUDKillerHookCountVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetHUDKillerHookCountVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetHUDKillerHookCountVisibility");

	Params::DBDGameUserSettings_GetHUDKillerHookCountVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetHUDPlayerNamesVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetHUDPlayerNamesVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetHUDPlayerNamesVisibility");

	Params::DBDGameUserSettings_GetHUDPlayerNamesVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetHudScaleFactor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDGameUserSettings::GetHudScaleFactor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetHudScaleFactor");

	Params::DBDGameUserSettings_GetHudScaleFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetHUDScoreEventsVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetHUDScoreEventsVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetHUDScoreEventsVisibility");

	Params::DBDGameUserSettings_GetHUDScoreEventsVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetLargeText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetLargeText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetLargeText");

	Params::DBDGameUserSettings_GetLargeText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetLegacyPrestigePortraits
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetLegacyPrestigePortraits() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetLegacyPrestigePortraits");

	Params::DBDGameUserSettings_GetLegacyPrestigePortraits Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetMenuScaleFactor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDGameUserSettings::GetMenuScaleFactor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetMenuScaleFactor");

	Params::DBDGameUserSettings_GetMenuScaleFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetSkillCheckScaleFactor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDGameUserSettings::GetSkillCheckScaleFactor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetSkillCheckScaleFactor");

	Params::DBDGameUserSettings_GetSkillCheckScaleFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGameUserSettings.GetTerrorRadiusVisualFeedback
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDGameUserSettings::GetTerrorRadiusVisualFeedback() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGameUserSettings", "GetTerrorRadiusVisualFeedback");

	Params::DBDGameUserSettings_GetTerrorRadiusVisualFeedback Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGDownloadProgressionWidget.UpdateProgression
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FDownloadProgression&      downloadProgression                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGDownloadProgressionWidget::UpdateProgression(const struct FDownloadProgression& downloadProgression)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDownloadProgressionWidget", "UpdateProgression");

	Params::UMGDownloadProgressionWidget_UpdateProgression Parms{};

	Parms.downloadProgression = std::move(downloadProgression);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDHud.RemoveStatusViewOnDestroy
// (Final, Native, Private)
// Parameters:
// class AActor*                           actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDHud::RemoveStatusViewOnDestroy(class AActor* actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDHud", "RemoveStatusViewOnDestroy");

	Params::DBDHud_RemoveStatusViewOnDestroy Parms{};

	Parms.actor = actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDKeyDisplayInfo.GetActionForInteractionType
// (Final, Native, Public)
// Parameters:
// EPlayerRole                             playerRole                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   inputInteractionType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    useGamePad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ignoreInteractMash                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName UDBDKeyDisplayInfo::GetActionForInteractionType(EPlayerRole playerRole, EInputInteractionType inputInteractionType, bool useGamePad, bool ignoreInteractMash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDKeyDisplayInfo", "GetActionForInteractionType");

	Params::DBDKeyDisplayInfo_GetActionForInteractionType Parms{};

	Parms.playerRole = playerRole;
	Parms.inputInteractionType = inputInteractionType;
	Parms.useGamePad = useGamePad;
	Parms.ignoreInteractMash = ignoreInteractMash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDKeyDisplayInfo.GetFirstKeyForAction
// (Final, Native, Public)
// Parameters:
// class UPlayerInput*                     playerInput                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             actionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    useGamePad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKey                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FKey UDBDKeyDisplayInfo::GetFirstKeyForAction(class UPlayerInput* playerInput, class FName actionName, bool useGamePad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDKeyDisplayInfo", "GetFirstKeyForAction");

	Params::DBDKeyDisplayInfo_GetFirstKeyForAction Parms{};

	Parms.playerInput = playerInput;
	Parms.actionName = actionName;
	Parms.useGamePad = useGamePad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDKeyDisplayInfo.GetKeyDisplayInfo
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKeyDisplayInfo            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FKeyDisplayInfo UDBDKeyDisplayInfo::GetKeyDisplayInfo(const struct FKey& key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDKeyDisplayInfo", "GetKeyDisplayInfo");

	Params::DBDKeyDisplayInfo_GetKeyDisplayInfo Parms{};

	Parms.key = std::move(key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDKeyDisplayInfo.GetKeyDisplayInfoForInteractionType
// (Final, Native, Public)
// Parameters:
// class UPlayerInput*                     playerInput                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerRole                             playerRole                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    useGamePad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKeyDisplayInfo            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FKeyDisplayInfo UDBDKeyDisplayInfo::GetKeyDisplayInfoForInteractionType(class UPlayerInput* playerInput, EPlayerRole playerRole, EInputInteractionType interactionType, bool useGamePad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDKeyDisplayInfo", "GetKeyDisplayInfoForInteractionType");

	Params::DBDKeyDisplayInfo_GetKeyDisplayInfoForInteractionType Parms{};

	Parms.playerInput = playerInput;
	Parms.playerRole = playerRole;
	Parms.interactionType = interactionType;
	Parms.useGamePad = useGamePad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDKeyDisplayInfo.IsExcludedKey
// (Final, Native, Public)
// Parameters:
// const struct FKey&                      key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UDBDKeyDisplayInfo::IsExcludedKey(const struct FKey& key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDKeyDisplayInfo", "IsExcludedKey");

	Params::DBDKeyDisplayInfo_IsExcludedKey Parms{};

	Parms.key = std::move(key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMathBlueprintLibrary.TransformToMatrix
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FTransform&                A                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FLinearColor>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLinearColor> UDBDMathBlueprintLibrary::TransformToMatrix(const struct FTransform& A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDMathBlueprintLibrary", "TransformToMatrix");

	Params::DBDMathBlueprintLibrary_TransformToMatrix Parms{};

	Parms.A = std::move(A);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMathBlueprintLibrary.VectorAbsoluteValue
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDBDMathBlueprintLibrary::VectorAbsoluteValue(const struct FVector& A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDMathBlueprintLibrary", "VectorAbsoluteValue");

	Params::DBDMathBlueprintLibrary_VectorAbsoluteValue Parms{};

	Parms.A = std::move(A);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDMathBlueprintLibrary.VectorIntersect
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   OriginA                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ExtentA                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   OriginB                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ExtentB                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDMathBlueprintLibrary::VectorIntersect(const struct FVector& OriginA, const struct FVector& ExtentA, const struct FVector& OriginB, const struct FVector& ExtentB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDMathBlueprintLibrary", "VectorIntersect");

	Params::DBDMathBlueprintLibrary_VectorIntersect Parms{};

	Parms.OriginA = std::move(OriginA);
	Parms.ExtentA = std::move(ExtentA);
	Parms.OriginB = std::move(OriginB);
	Parms.ExtentB = std::move(ExtentB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerCameraManager.StartFadeInTimeline
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerCameraManager::StartFadeInTimeline(float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerCameraManager", "StartFadeInTimeline");

	Params::DBDPlayerCameraManager_StartFadeInTimeline Parms{};

	Parms.duration = duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDPlayerCameraManager.StartFadeOutTimeline
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerCameraManager::StartFadeOutTimeline(float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerCameraManager", "StartFadeOutTimeline");

	Params::DBDPlayerCameraManager_StartFadeOutTimeline Parms{};

	Parms.duration = duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDPlayerController.ActivateAI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    activate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   playerRank                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::ActivateAI(bool activate, int32 playerRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "ActivateAI");

	Params::DBDPlayerController_ActivateAI Parms{};

	Parms.activate = activate;
	Parms.playerRank = playerRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Client_SetPlayerFinishStats
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const struct FPlayerFinishStats&        stats                                                  (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADBDPlayerController::Client_SetPlayerFinishStats(const struct FPlayerFinishStats& stats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Client_SetPlayerFinishStats");

	Params::DBDPlayerController_Client_SetPlayerFinishStats Parms{};

	Parms.stats = std::move(stats);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Client_SetSpectatorMode
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    on                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Client_SetSpectatorMode(bool on)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Client_SetSpectatorMode");

	Params::DBDPlayerController_Client_SetSpectatorMode Parms{};

	Parms.on = on;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Client_SetSpectatorModeInEditor
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    on                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayerState*                  spectatingPlayerState                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Client_SetSpectatorModeInEditor(bool on, class ADBDPlayerState* spectatingPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Client_SetSpectatorModeInEditor");

	Params::DBDPlayerController_Client_SetSpectatorModeInEditor Parms{};

	Parms.on = on;
	Parms.spectatingPlayerState = spectatingPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Client_SpectateAI
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class APawn*                            aiPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Client_SpectateAI(class APawn* aiPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Client_SpectateAI");

	Params::DBDPlayerController_Client_SpectateAI Parms{};

	Parms.aiPawn = aiPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.ImplementRunLockMechanic
// (Final, Native, Public, BlueprintCallable)

void ADBDPlayerController::ImplementRunLockMechanic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "ImplementRunLockMechanic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.OnRep_Fence
// (Final, Native, Private)

void ADBDPlayerController::OnRep_Fence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "OnRep_Fence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_ActivateAI
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    activate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   playerRank                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Server_ActivateAI(bool activate, int32 playerRank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_ActivateAI");

	Params::DBDPlayerController_Server_ActivateAI Parms{};

	Parms.activate = activate;
	Parms.playerRank = playerRank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_ActivateAIAll
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    activate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   playerRank                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int8                                    playerRole                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Server_ActivateAIAll(bool activate, int32 playerRank, int8 playerRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_ActivateAIAll");

	Params::DBDPlayerController_Server_ActivateAIAll Parms{};

	Parms.activate = activate;
	Parms.playerRank = playerRank;
	Parms.playerRole = playerRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_ClientTimeSinceLastLoadingProgress
// (Net, Native, Event, Public, NetServer)
// Parameters:
// float                                   lastProgression                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Server_ClientTimeSinceLastLoadingProgress(float lastProgression)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_ClientTimeSinceLastLoadingProgress");

	Params::DBDPlayerController_Server_ClientTimeSinceLastLoadingProgress Parms{};

	Parms.lastProgression = lastProgression;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_DebugSend
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class FString&                    data                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Server_DebugSend(const class FString& data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_DebugSend");

	Params::DBDPlayerController_Server_DebugSend Parms{};

	Parms.data = std::move(data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_LeaveGame
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    joiningLobby                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Server_LeaveGame(bool joiningLobby)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_LeaveGame");

	Params::DBDPlayerController_Server_LeaveGame Parms{};

	Parms.joiningLobby = joiningLobby;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_RequestEndGame
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADBDPlayerController::Server_RequestEndGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_RequestEndGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_SetHasMoveInputThisFrame
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    hasMoveInputThisFrame                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Server_SetHasMoveInputThisFrame(bool hasMoveInputThisFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_SetHasMoveInputThisFrame");

	Params::DBDPlayerController_Server_SetHasMoveInputThisFrame Parms{};

	Parms.hasMoveInputThisFrame = hasMoveInputThisFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_SetReadyToTravel
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADBDPlayerController::Server_SetReadyToTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_SetReadyToTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_SetSpectatorMode
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// bool                                    on                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Server_SetSpectatorMode(bool on)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_SetSpectatorMode");

	Params::DBDPlayerController_Server_SetSpectatorMode Parms{};

	Parms.on = on;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.Server_SetSpectatorModeInEditor
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    on                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayerState*                  spectatingPlayerState                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::Server_SetSpectatorModeInEditor(bool on, class ADBDPlayerState* spectatingPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "Server_SetSpectatorModeInEditor");

	Params::DBDPlayerController_Server_SetSpectatorModeInEditor Parms{};

	Parms.on = on;
	Parms.spectatingPlayerState = spectatingPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.ServerViewPlayer
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const class FString&                    playerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::ServerViewPlayer(const class FString& playerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "ServerViewPlayer");

	Params::DBDPlayerController_ServerViewPlayer Parms{};

	Parms.playerName = std::move(playerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.SetShouldMoveInputReplicateToServer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    shouldReplicate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADBDPlayerController::SetShouldMoveInputReplicateToServer(bool shouldReplicate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "SetShouldMoveInputReplicateToServer");

	Params::DBDPlayerController_SetShouldMoveInputReplicateToServer Parms{};

	Parms.shouldReplicate = shouldReplicate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDPlayerController.GetAIPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* ADBDPlayerController::GetAIPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "GetAIPawn");

	Params::DBDPlayerController_GetAIPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerController.GetControlledPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ADBDPlayerController::GetControlledPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "GetControlledPlayer");

	Params::DBDPlayerController_GetControlledPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerController.GetSpectatedPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* ADBDPlayerController::GetSpectatedPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "GetSpectatedPlayer");

	Params::DBDPlayerController_GetSpectatedPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerController.GetSpectatedPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayerState*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerState* ADBDPlayerController::GetSpectatedPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "GetSpectatedPlayerState");

	Params::DBDPlayerController_GetSpectatedPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerController.IsSpectating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayerController::IsSpectating() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "IsSpectating");

	Params::DBDPlayerController_IsSpectating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDPlayerController.MobileJoystickInput_Pressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   joystickIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADBDPlayerController::MobileJoystickInput_Pressed(int32 joystickIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDPlayerController", "MobileJoystickInput_Pressed");

	Params::DBDPlayerController_MobileJoystickInput_Pressed Parms{};

	Parms.joystickIndex = joystickIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.CoopRepairTracker.SetHasEverCoopRepaired
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCoopRepairTracker::SetHasEverCoopRepaired(const class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoopRepairTracker", "SetHasEverCoopRepaired");

	Params::CoopRepairTracker_SetHasEverCoopRepaired Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.CoopRepairTracker.HasEverCoopRepaired
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCoopRepairTracker::HasEverCoopRepaired(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoopRepairTracker", "HasEverCoopRepaired");

	Params::CoopRepairTracker_HasEverCoopRepaired Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HookableComponent.Authority_DebugSetHookDrainStage
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   drainStage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHookableComponent::Authority_DebugSetHookDrainStage(int32 drainStage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "Authority_DebugSetHookDrainStage");

	Params::HookableComponent_Authority_DebugSetHookDrainStage Parms{};

	Parms.drainStage = drainStage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HookableComponent.Authority_DebugSetHookEscapeAutoFail
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              fail                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHookableComponent::Authority_DebugSetHookEscapeAutoFail(const bool fail)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "Authority_DebugSetHookEscapeAutoFail");

	Params::HookableComponent_Authority_DebugSetHookEscapeAutoFail Parms{};

	Parms.fail = fail;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HookableComponent.Authority_DebugSetHookEscapeAutoSuccess
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              success                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHookableComponent::Authority_DebugSetHookEscapeAutoSuccess(const bool success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "Authority_DebugSetHookEscapeAutoSuccess");

	Params::HookableComponent_Authority_DebugSetHookEscapeAutoSuccess Parms{};

	Parms.success = success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HookableComponent.Authority_SetDrainTimerPercentLeft
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   percentTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHookableComponent::Authority_SetDrainTimerPercentLeft(float percentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "Authority_SetDrainTimerPercentLeft");

	Params::HookableComponent_Authority_SetDrainTimerPercentLeft Parms{};

	Parms.percentTime = percentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HookableComponent.Multicast_DebugSetHookDrainStage
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// int32                                   drainStage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHookableComponent::Multicast_DebugSetHookDrainStage(int32 drainStage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "Multicast_DebugSetHookDrainStage");

	Params::HookableComponent_Multicast_DebugSetHookDrainStage Parms{};

	Parms.drainStage = drainStage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HookableComponent.Multicast_SetDrainTimerPercentLeft
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// float                                   percentTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHookableComponent::Multicast_SetDrainTimerPercentLeft(float percentTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "Multicast_SetDrainTimerPercentLeft");

	Params::HookableComponent_Multicast_SetDrainTimerPercentLeft Parms{};

	Parms.percentTime = percentTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HookableComponent.GetDrainTimerPercentLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHookableComponent::GetDrainTimerPercentLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "GetDrainTimerPercentLeft");

	Params::HookableComponent_GetDrainTimerPercentLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HookableComponent.GetHookedCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UHookableComponent::GetHookedCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookableComponent", "GetHookedCount");

	Params::HookableComponent_GetHookedCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDProjectileUtilities.CreateProjectilePoolAdapter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          outer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuthoritativeActorPoolComponent* pool                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuthoritativePoolProjectileProviderAdapter*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuthoritativePoolProjectileProviderAdapter* UDBDProjectileUtilities::CreateProjectilePoolAdapter(class UObject* outer, class UAuthoritativeActorPoolComponent* pool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDProjectileUtilities", "CreateProjectilePoolAdapter");

	Params::DBDProjectileUtilities_CreateProjectilePoolAdapter Parms{};

	Parms.outer = outer;
	Parms.pool = pool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDSpecialEventUtilities.DoesPlayerHasEventOffering
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOfferingEffectType                     offeringEffectType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDSpecialEventUtilities::DoesPlayerHasEventOffering(class ADBDPlayer* player, EOfferingEffectType offeringEffectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDSpecialEventUtilities", "DoesPlayerHasEventOffering");

	Params::DBDSpecialEventUtilities_DoesPlayerHasEventOffering Parms{};

	Parms.player = player;
	Parms.offeringEffectType = offeringEffectType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDSpringArmComponent.ClearIgnoreActors
// (Final, Native, Public, BlueprintCallable)

void UDBDSpringArmComponent::ClearIgnoreActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDSpringArmComponent", "ClearIgnoreActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDSpringArmComponent.IgnoreActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldIgnore                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDSpringArmComponent::IgnoreActor(class AActor* Actor, bool bShouldIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDSpringArmComponent", "IgnoreActor");

	Params::DBDSpringArmComponent_IgnoreActor Parms{};

	Parms.Actor = Actor;
	Parms.bShouldIgnore = bShouldIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDSurfaceTypeName.Convert
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const EPhysicalSurface                  surfaceType                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UDBDSurfaceTypeName::Convert(const EPhysicalSurface surfaceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDSurfaceTypeName", "Convert");

	Params::DBDSurfaceTypeName_Convert Parms{};

	Parms.surfaceType = surfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDSurfaceTypeName.ConvertFromPhysicalMaterial
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UPhysicalMaterial*          material                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UDBDSurfaceTypeName::ConvertFromPhysicalMaterial(const class UPhysicalMaterial* material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDSurfaceTypeName", "ConvertFromPhysicalMaterial");

	Params::DBDSurfaceTypeName_ConvertFromPhysicalMaterial Parms{};

	Parms.material = material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDSurfaceTypeName.GetSurfaceName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UPhysicalMaterial*          physicalMaterial                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDBDSurfaceTypeName::GetSurfaceName(const class UPhysicalMaterial* physicalMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDSurfaceTypeName", "GetSurfaceName");

	Params::DBDSurfaceTypeName_GetSurfaceName Parms{};

	Parms.physicalMaterial = physicalMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDSurfaceTypeName.GetSurfaceType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UPhysicalMaterial*          physicalMaterial                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPhysicalSurface UDBDSurfaceTypeName::GetSurfaceType(const class UPhysicalMaterial* physicalMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDSurfaceTypeName", "GetSurfaceType");

	Params::DBDSurfaceTypeName_GetSurfaceType Parms{};

	Parms.physicalMaterial = physicalMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTimerComponent.Pause
// (Final, Native, Public, BlueprintCallable)

void UDBDTimerComponent::Pause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "Pause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDTimerComponent.Reset
// (Final, Native, Public, BlueprintCallable)

void UDBDTimerComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDTimerComponent.ResetTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDTimerComponent::ResetTo(float time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "ResetTo");

	Params::DBDTimerComponent_ResetTo Parms{};

	Parms.time = time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDTimerComponent.Stop
// (Final, Native, Public, BlueprintCallable)

void UDBDTimerComponent::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDTimerComponent.Unpause
// (Final, Native, Public, BlueprintCallable)

void UDBDTimerComponent::Unpause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "Unpause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDTimerComponent.Update
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   deltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDTimerComponent::Update(float deltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "Update");

	Params::DBDTimerComponent_Update Parms{};

	Parms.deltaTime = deltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDTimerComponent.GetPercentTimeElapsed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTimerComponent::GetPercentTimeElapsed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "GetPercentTimeElapsed");

	Params::DBDTimerComponent_GetPercentTimeElapsed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTimerComponent.GetPercentTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTimerComponent::GetPercentTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "GetPercentTimeLeft");

	Params::DBDTimerComponent_GetPercentTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTimerComponent.GetStartTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTimerComponent::GetStartTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "GetStartTime");

	Params::DBDTimerComponent_GetStartTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTimerComponent.GetTimeElapsed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTimerComponent::GetTimeElapsed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "GetTimeElapsed");

	Params::DBDTimerComponent_GetTimeElapsed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTimerComponent.GetTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTimerComponent::GetTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "GetTimeLeft");

	Params::DBDTimerComponent_GetTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTimerComponent.IsDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDTimerComponent::IsDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "IsDone");

	Params::DBDTimerComponent_IsDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTimerComponent.IsOnPause
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDTimerComponent::IsOnPause() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDTimerComponent", "IsOnPause");

	Params::DBDTimerComponent_IsOnPause Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTunableUtilities.GetEndGameTunableValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          worldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             valueName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTunableUtilities::GetEndGameTunableValue(class UObject* worldContextObject, class FName valueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDTunableUtilities", "GetEndGameTunableValue");

	Params::DBDTunableUtilities_GetEndGameTunableValue Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.valueName = valueName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTunableUtilities.GetSlasherTunableValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          worldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             valueName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTunableUtilities::GetSlasherTunableValue(class UObject* worldContextObject, class FName valueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDTunableUtilities", "GetSlasherTunableValue");

	Params::DBDTunableUtilities_GetSlasherTunableValue Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.valueName = valueName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTunableUtilities.GetTunableRowHandleValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDTunableRowHandle&      rowHandle                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTunableUtilities::GetTunableRowHandleValue(const struct FDBDTunableRowHandle& rowHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDTunableUtilities", "GetTunableRowHandleValue");

	Params::DBDTunableUtilities_GetTunableRowHandleValue Parms{};

	Parms.rowHandle = std::move(rowHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDTunableUtilities.GetTunableValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             valueName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDTunableUtilities::GetTunableValue(const class UObject* worldContextObject, class FName valueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDTunableUtilities", "GetTunableValue");

	Params::DBDTunableUtilities_GetTunableValue Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.valueName = valueName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.AddComponentToActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UClass*                           compClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             compName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActorComponent* UDBDUtilities::AddComponentToActor(class UClass* compClass, class FName compName, class AActor* actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "AddComponentToActor");

	Params::DBDUtilities_AddComponentToActor Parms{};

	Parms.compClass = compClass;
	Parms.compName = compName;
	Parms.actor = actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.BoxTraceAgainstActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   end                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UBoxComponent*              box                                                    (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      outHitResult                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::BoxTraceAgainstActor(const struct FVector& start, const struct FVector& end, const class UBoxComponent* box, const class AActor* actor, struct FHitResult* outHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "BoxTraceAgainstActor");

	Params::DBDUtilities_BoxTraceAgainstActor Parms{};

	Parms.start = std::move(start);
	Parms.end = std::move(end);
	Parms.box = box;
	Parms.actor = actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outHitResult != nullptr)
		*outHitResult = std::move(Parms.outHitResult);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.CrashGameCausingInterrupt
// (Final, Native, Static, Public, BlueprintCallable)

void UDBDUtilities::CrashGameCausingInterrupt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "CrashGameCausingInterrupt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDUtilities.DBDCapsuleTraceSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIgnoreSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::DBDCapsuleTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "DBDCapsuleTraceSingle");

	Params::DBDUtilities_DBDCapsuleTraceSingle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.bIgnoreSelf = bIgnoreSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.DBDLoadAudioBank
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioBank*                     bank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           caller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDUtilities::DBDLoadAudioBank(class UAkAudioBank* bank, class AActor* caller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "DBDLoadAudioBank");

	Params::DBDUtilities_DBDLoadAudioBank Parms{};

	Parms.bank = bank;
	Parms.caller = caller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDUtilities.DBDLoadAudioBankAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAkAudioBank*                     bank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           caller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDUtilities::DBDLoadAudioBankAsync(class UAkAudioBank* bank, class AActor* caller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "DBDLoadAudioBankAsync");

	Params::DBDUtilities_DBDLoadAudioBankAsync Parms{};

	Parms.bank = bank;
	Parms.caller = caller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDUtilities.DBDLoadAudioBankByAssetPtr
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UAkAudioBank>      bank                                                   (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           caller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UDBDUtilities::DBDLoadAudioBankByAssetPtr(TSoftObjectPtr<class UAkAudioBank> bank, class AActor* caller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "DBDLoadAudioBankByAssetPtr");

	Params::DBDUtilities_DBDLoadAudioBankByAssetPtr Parms{};

	Parms.bank = bank;
	Parms.caller = caller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.DistanceFromPointToPane
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   point                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlane&                    plane                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::DistanceFromPointToPane(const struct FVector& point, const struct FPlane& plane)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "DistanceFromPointToPane");

	Params::DBDUtilities_DistanceFromPointToPane Parms{};

	Parms.point = std::move(point);
	Parms.plane = std::move(plane);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.FindFloorSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   raycastLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      outHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::FindFloorSingle(class UObject* WorldContextObject, const struct FVector& location, float raycastLength, struct FHitResult* outHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "FindFloorSingle");

	Params::DBDUtilities_FindFloorSingle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.location = std::move(location);
	Parms.raycastLength = raycastLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outHit != nullptr)
		*outHit = std::move(Parms.outHit);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.FindParentOfClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InChild                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDBDUtilities::FindParentOfClass(class AActor* InChild, class UClass* InClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "FindParentOfClass");

	Params::DBDUtilities_FindParentOfClass Parms{};

	Parms.InChild = InChild;
	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetActiveShadowSystem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EShadowSystem                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EShadowSystem UDBDUtilities::GetActiveShadowSystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetActiveShadowSystem");

	Params::DBDUtilities_GetActiveShadowSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetActorOwnerName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDBDUtilities::GetActorOwnerName(class AActor* actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetActorOwnerName");

	Params::DBDUtilities_GetActorOwnerName Parms{};

	Parms.actor = actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetActorSpawners
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UActorSpawner*>*           actorSpawners                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDBDUtilities::GetActorSpawners(TArray<class UActorSpawner*>* actorSpawners)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetActorSpawners");

	Params::DBDUtilities_GetActorSpawners Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (actorSpawners != nullptr)
		*actorSpawners = std::move(Parms.actorSpawners);
}


// Function DeadByDaylight.DBDUtilities.GetAnimSequenceLength
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimSequence*              sequence                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetAnimSequenceLength(const class UAnimSequence* sequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetAnimSequenceLength");

	Params::DBDUtilities_GetAnimSequenceLength Parms{};

	Parms.sequence = sequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetBuilder
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AProceduralLevelBuilder*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AProceduralLevelBuilder* UDBDUtilities::GetBuilder(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetBuilder");

	Params::DBDUtilities_GetBuilder Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetClosestPointOnOrbit
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   centerPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   orbitterPosition                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             distance                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDBDUtilities::GetClosestPointOnOrbit(const struct FVector& centerPoint, const struct FVector& orbitterPosition, const float distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetClosestPointOnOrbit");

	Params::DBDUtilities_GetClosestPointOnOrbit Parms{};

	Parms.centerPoint = std::move(centerPoint);
	Parms.orbitterPosition = std::move(orbitterPosition);
	Parms.distance = distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetClosestSnapTransformOnOrbit
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   centerPoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   orbitterPosition                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             distance                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UDBDUtilities::GetClosestSnapTransformOnOrbit(const struct FVector& centerPoint, const struct FVector& orbitterPosition, const float distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetClosestSnapTransformOnOrbit");

	Params::DBDUtilities_GetClosestSnapTransformOnOrbit Parms{};

	Parms.centerPoint = std::move(centerPoint);
	Parms.orbitterPosition = std::move(orbitterPosition);
	Parms.distance = distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetComponentOwnerName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  actorComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDBDUtilities::GetComponentOwnerName(class UActorComponent* actorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetComponentOwnerName");

	Params::DBDUtilities_GetComponentOwnerName Parms{};

	Parms.actorComponent = actorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetDBDAIPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDAIPlayerController*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDAIPlayerController* UDBDUtilities::GetDBDAIPlayerController(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetDBDAIPlayerController");

	Params::DBDUtilities_GetDBDAIPlayerController Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetDBDGameInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDBDGameInstance*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDBDGameInstance* UDBDUtilities::GetDBDGameInstance(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetDBDGameInstance");

	Params::DBDUtilities_GetDBDGameInstance Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetDBDGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDGameMode*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDGameMode* UDBDUtilities::GetDBDGameMode(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetDBDGameMode");

	Params::DBDUtilities_GetDBDGameMode Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetDBDGameState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDGameState*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDGameState* UDBDUtilities::GetDBDGameState(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetDBDGameState");

	Params::DBDUtilities_GetDBDGameState Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetDistanceToNearestHookedSurvivor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetDistanceToNearestHookedSurvivor(const class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetDistanceToNearestHookedSurvivor");

	Params::DBDUtilities_GetDistanceToNearestHookedSurvivor Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetEndGameTunableValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          worldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             valueName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetEndGameTunableValue(class UObject* worldContextObject, class FName valueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetEndGameTunableValue");

	Params::DBDUtilities_GetEndGameTunableValue Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.valueName = valueName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetFirstActorWithTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            actorsArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDBDUtilities::GetFirstActorWithTag(class FName tag, const TArray<class AActor*>& actorsArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetFirstActorWithTag");

	Params::DBDUtilities_GetFirstActorWithTag Parms{};

	Parms.tag = tag;
	Parms.actorsArray = std::move(actorsArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetFloorLocationAt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   raycastStartHeight                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   raycastEndHeight                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    useComplex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDBDUtilities::GetFloorLocationAt(class UObject* WorldContextObject, const struct FVector& location, float raycastStartHeight, float raycastEndHeight, bool useComplex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetFloorLocationAt");

	Params::DBDUtilities_GetFloorLocationAt Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.location = std::move(location);
	Parms.raycastStartHeight = raycastStartHeight;
	Parms.raycastEndHeight = raycastEndHeight;
	Parms.useComplex = useComplex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetFormattedNumberString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   maxDecimals                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   minDecimals                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    leadingZero                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDBDUtilities::GetFormattedNumberString(float value, int32 maxDecimals, int32 minDecimals, bool leadingZero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetFormattedNumberString");

	Params::DBDUtilities_GetFormattedNumberString Parms{};

	Parms.value = value;
	Parms.maxDecimals = maxDecimals;
	Parms.minDecimals = minDecimals;
	Parms.leadingZero = leadingZero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetFormattedNumberText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   maxDecimals                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   minDecimals                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    leadingZero                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDBDUtilities::GetFormattedNumberText(float value, int32 maxDecimals, int32 minDecimals, bool leadingZero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetFormattedNumberText");

	Params::DBDUtilities_GetFormattedNumberText Parms{};

	Parms.value = value;
	Parms.maxDecimals = maxDecimals;
	Parms.minDecimals = minDecimals;
	Parms.leadingZero = leadingZero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetImpactCollisionObjectType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UPrimitiveComponent*        primitive                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollisionChannel UDBDUtilities::GetImpactCollisionObjectType(const class UPrimitiveComponent* primitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetImpactCollisionObjectType");

	Params::DBDUtilities_GetImpactCollisionObjectType Parms{};

	Parms.primitive = primitive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetImpactCollisionResponseContainer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UPrimitiveComponent*        primitive                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCollisionResponseContainer      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCollisionResponseContainer UDBDUtilities::GetImpactCollisionResponseContainer(const class UPrimitiveComponent* primitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetImpactCollisionResponseContainer");

	Params::DBDUtilities_GetImpactCollisionResponseContainer Parms{};

	Parms.primitive = primitive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetInventoryCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          worldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   characterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             itemID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDUtilities::GetInventoryCount(class UObject* worldContextObject, int32 characterIndex, class FName itemID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetInventoryCount");

	Params::DBDUtilities_GetInventoryCount Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.characterIndex = characterIndex;
	Parms.itemID = itemID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetInventoryCountForMultipleCharacters
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          worldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<int32>&                    characterIndexes                                       (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FName                             itemID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDUtilities::GetInventoryCountForMultipleCharacters(class UObject* worldContextObject, const TArray<int32>& characterIndexes, class FName itemID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetInventoryCountForMultipleCharacters");

	Params::DBDUtilities_GetInventoryCountForMultipleCharacters Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.characterIndexes = std::move(characterIndexes);
	Parms.itemID = itemID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLocalDBDCameraManager
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayerCameraManager*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerCameraManager* UDBDUtilities::GetLocalDBDCameraManager(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLocalDBDCameraManager");

	Params::DBDUtilities_GetLocalDBDCameraManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLocalDBDPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayerControllerBase*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerControllerBase* UDBDUtilities::GetLocalDBDPlayerController(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLocalDBDPlayerController");

	Params::DBDUtilities_GetLocalDBDPlayerController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLocallyControlledCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UDBDUtilities::GetLocallyControlledCharacter(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLocallyControlledCharacter");

	Params::DBDUtilities_GetLocallyControlledCharacter Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLocallyControlledCharacterRole
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerRole                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerRole UDBDUtilities::GetLocallyControlledCharacterRole(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLocallyControlledCharacterRole");

	Params::DBDUtilities_GetLocallyControlledCharacterRole Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLocallyControlledKiller
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASlasherPlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASlasherPlayer* UDBDUtilities::GetLocallyControlledKiller(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLocallyControlledKiller");

	Params::DBDUtilities_GetLocallyControlledKiller Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLocallyControlledSurvivor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACamperPlayer*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACamperPlayer* UDBDUtilities::GetLocallyControlledSurvivor(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLocallyControlledSurvivor");

	Params::DBDUtilities_GetLocallyControlledSurvivor Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLocallyObservedCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UDBDUtilities::GetLocallyObservedCharacter(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLocallyObservedCharacter");

	Params::DBDUtilities_GetLocallyObservedCharacter Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLocallyObservedCharacterRole
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerRole                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerRole UDBDUtilities::GetLocallyObservedCharacterRole(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLocallyObservedCharacterRole");

	Params::DBDUtilities_GetLocallyObservedCharacterRole Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetLogStringMaterialInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    inStr                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UMaterialInterface*         root                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDBDUtilities::GetLogStringMaterialInfo(const class FString& inStr, const class UMaterialInterface* root)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetLogStringMaterialInfo");

	Params::DBDUtilities_GetLogStringMaterialInfo Parms{};

	Parms.inStr = std::move(inStr);
	Parms.root = root;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetMaterialHelpersAttachedToPlayerMesh
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMaterialHelper*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UMaterialHelper*> UDBDUtilities::GetMaterialHelpersAttachedToPlayerMesh(const class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetMaterialHelpersAttachedToPlayerMesh");

	Params::DBDUtilities_GetMaterialHelpersAttachedToPlayerMesh Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetMontageLength
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                     montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetMontageLength(class UAnimMontage* montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetMontageLength");

	Params::DBDUtilities_GetMontageLength Parms{};

	Parms.montage = montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetNearbyActorsOfType
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UWorld*                           world                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  outNearbyActors                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UClass*                           actorClassType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       collisionChannel                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ignoreActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::GetNearbyActorsOfType(class UWorld* world, const struct FVector& center, float radius, TArray<class AActor*>* outNearbyActors, class UClass* actorClassType, ECollisionChannel collisionChannel, class AActor* ignoreActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetNearbyActorsOfType");

	Params::DBDUtilities_GetNearbyActorsOfType Parms{};

	Parms.world = world;
	Parms.center = std::move(center);
	Parms.radius = radius;
	Parms.actorClassType = actorClassType;
	Parms.collisionChannel = collisionChannel;
	Parms.ignoreActor = ignoreActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outNearbyActors != nullptr)
		*outNearbyActors = std::move(Parms.outNearbyActors);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetNearbyCampers
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UWorld*                           world                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ACamperPlayer*>*           outNearbyCampers                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ignoredCampers                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDBDUtilities::GetNearbyCampers(class UWorld* world, const struct FVector& center, float radius, TArray<class ACamperPlayer*>* outNearbyCampers, const TArray<class AActor*>& ignoredCampers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetNearbyCampers");

	Params::DBDUtilities_GetNearbyCampers Parms{};

	Parms.world = world;
	Parms.center = std::move(center);
	Parms.radius = radius;
	Parms.ignoredCampers = std::move(ignoredCampers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outNearbyCampers != nullptr)
		*outNearbyCampers = std::move(Parms.outNearbyCampers);
}


// Function DeadByDaylight.DBDUtilities.GetOuterMostActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              animInstance                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDBDUtilities::GetOuterMostActor(const class UAnimInstance* animInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetOuterMostActor");

	Params::DBDUtilities_GetOuterMostActor Parms{};

	Parms.animInstance = animInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetOwningCamper
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              animInstance                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACamperPlayer*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACamperPlayer* UDBDUtilities::GetOwningCamper(const class UAnimInstance* animInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetOwningCamper");

	Params::DBDUtilities_GetOwningCamper Parms{};

	Parms.animInstance = animInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetOwningDBDBasePlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              animInstance                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDBasePlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDBasePlayer* UDBDUtilities::GetOwningDBDBasePlayer(const class UAnimInstance* animInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetOwningDBDBasePlayer");

	Params::DBDUtilities_GetOwningDBDBasePlayer Parms{};

	Parms.animInstance = animInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetOwningSlasher
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimInstance*              animInstance                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASlasherPlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASlasherPlayer* UDBDUtilities::GetOwningSlasher(const class UAnimInstance* animInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetOwningSlasher");

	Params::DBDUtilities_GetOwningSlasher Parms{};

	Parms.animInstance = animInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetPercentOfRange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const float                             val                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             min_0                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             max_0                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetPercentOfRange(const float val, const float min_0, const float max_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetPercentOfRange");

	Params::DBDUtilities_GetPercentOfRange Parms{};

	Parms.val = val;
	Parms.min_0 = min_0;
	Parms.max_0 = max_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetPlayRateForMontage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                     montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetPlayRateForMontage(class UAnimMontage* montage, float time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetPlayRateForMontage");

	Params::DBDUtilities_GetPlayRateForMontage Parms{};

	Parms.montage = montage;
	Parms.time = time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetSimilarVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   vector                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   maximumDeviation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDBDUtilities::GetSimilarVector(const struct FVector& vector, float maximumDeviation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetSimilarVector");

	Params::DBDUtilities_GetSimilarVector Parms{};

	Parms.vector = std::move(vector);
	Parms.maximumDeviation = maximumDeviation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetSlasherTunableValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             valueName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetSlasherTunableValue(class UObject* WorldContextObject, class FName valueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetSlasherTunableValue");

	Params::DBDUtilities_GetSlasherTunableValue Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.valueName = valueName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetSquaredDistanceToKiller
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     survivor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetSquaredDistanceToKiller(const class AActor* survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetSquaredDistanceToKiller");

	Params::DBDUtilities_GetSquaredDistanceToKiller Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetThreeClosestGenerators
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AGenerator*>&        unrevealedGenerators                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AGenerator*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AGenerator*> UDBDUtilities::GetThreeClosestGenerators(const TArray<class AGenerator*>& unrevealedGenerators)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetThreeClosestGenerators");

	Params::DBDUtilities_GetThreeClosestGenerators Parms{};

	Parms.unrevealedGenerators = std::move(unrevealedGenerators);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetTileSpawnPoints
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UTileSpawnPoint*>*         tileSpawnPoints                                        (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDBDUtilities::GetTileSpawnPoints(TArray<class UTileSpawnPoint*>* tileSpawnPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetTileSpawnPoints");

	Params::DBDUtilities_GetTileSpawnPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (tileSpawnPoints != nullptr)
		*tileSpawnPoints = std::move(Parms.tileSpawnPoints);
}


// Function DeadByDaylight.DBDUtilities.GetTotalPlaytime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    update                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTimespan UDBDUtilities::GetTotalPlaytime(const class UObject* worldContextObject, bool update)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetTotalPlaytime");

	Params::DBDUtilities_GetTotalPlaytime Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.update = update;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetVelocityXYAngleDegrees
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::GetVelocityXYAngleDegrees(const class AActor* actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetVelocityXYAngleDegrees");

	Params::DBDUtilities_GetVelocityXYAngleDegrees Parms{};

	Parms.actor = actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetXYVector
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDBDUtilities::GetXYVector(const struct FVector& vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetXYVector");

	Params::DBDUtilities_GetXYVector Parms{};

	Parms.vector = std::move(vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.GetYawOnly
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FRotator&                  rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UDBDUtilities::GetYawOnly(const struct FRotator& rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "GetYawOnly");

	Params::DBDUtilities_GetYawOnly Parms{};

	Parms.rotation = std::move(rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.HasFloorForward
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   fowardVector                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   raycastStartHeight                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   raycastEndHeight                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>*              outHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector*                         raycastStart                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::HasFloorForward(class UObject* WorldContextObject, const struct FVector& location, const struct FVector& fowardVector, float distance, float raycastStartHeight, float raycastEndHeight, TArray<struct FHitResult>* outHits, struct FVector* raycastStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "HasFloorForward");

	Params::DBDUtilities_HasFloorForward Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.location = std::move(location);
	Parms.fowardVector = std::move(fowardVector);
	Parms.distance = distance;
	Parms.raycastStartHeight = raycastStartHeight;
	Parms.raycastEndHeight = raycastEndHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outHits != nullptr)
		*outHits = std::move(Parms.outHits);

	if (raycastStart != nullptr)
		*raycastStart = std::move(Parms.raycastStart);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.HasLineOfSightToTarget
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   startPosition                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   targetPosition                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     ignoredActor                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              useComplex                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              useDebugLogs                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::HasLineOfSightToTarget(class UObject* WorldContextObject, const struct FVector& startPosition, const struct FVector& targetPosition, const class AActor* ignoredActor, const bool useComplex, const bool useDebugLogs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "HasLineOfSightToTarget");

	Params::DBDUtilities_HasLineOfSightToTarget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.startPosition = std::move(startPosition);
	Parms.targetPosition = std::move(targetPosition);
	Parms.ignoredActor = ignoredActor;
	Parms.useComplex = useComplex;
	Parms.useDebugLogs = useDebugLogs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.HasWalkableSurfaceForward
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   fowardVector                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   raycastStartHeight                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   raycastEndHeight                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>*              outHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector*                         raycastStart                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::HasWalkableSurfaceForward(class UObject* WorldContextObject, const struct FVector& location, const struct FVector& fowardVector, float distance, float raycastStartHeight, float raycastEndHeight, TArray<struct FHitResult>* outHits, struct FVector* raycastStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "HasWalkableSurfaceForward");

	Params::DBDUtilities_HasWalkableSurfaceForward Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.location = std::move(location);
	Parms.fowardVector = std::move(fowardVector);
	Parms.distance = distance;
	Parms.raycastStartHeight = raycastStartHeight;
	Parms.raycastEndHeight = raycastEndHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outHits != nullptr)
		*outHits = std::move(Parms.outHits);

	if (raycastStart != nullptr)
		*raycastStart = std::move(Parms.raycastStart);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsInKillerTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsInKillerTeam(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsInKillerTeam");

	Params::DBDUtilities_IsInKillerTeam Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsInSurvivorTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsInSurvivorTeam(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsInSurvivorTeam");

	Params::DBDUtilities_IsInSurvivorTeam Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsInTutorialLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsInTutorialLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsInTutorialLevel");

	Params::DBDUtilities_IsInTutorialLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsLocallyObservingAKiller
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsLocallyObservingAKiller(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsLocallyObservingAKiller");

	Params::DBDUtilities_IsLocallyObservingAKiller Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsLocallyObservingASurvivor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsLocallyObservingASurvivor(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsLocallyObservingASurvivor");

	Params::DBDUtilities_IsLocallyObservingASurvivor Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsNonViolent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsNonViolent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsNonViolent");

	Params::DBDUtilities_IsNonViolent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsReplaceDisconnectedPlayersWithBotsActive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsReplaceDisconnectedPlayersWithBotsActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsReplaceDisconnectedPlayersWithBotsActive");

	Params::DBDUtilities_IsReplaceDisconnectedPlayersWithBotsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsServer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsServer(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsServer");

	Params::DBDUtilities_IsServer Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.IsSteamPIEGame
// (Final, Native, Static, Public)
// Parameters:
// const class UObject*                    contextObject                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::IsSteamPIEGame(const class UObject* contextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "IsSteamPIEGame");

	Params::DBDUtilities_IsSteamPIEGame Parms{};

	Parms.contextObject = contextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.LogMeshMaterialInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    inStr                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UMeshComponent*             root                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDUtilities::LogMeshMaterialInfo(const class FString& inStr, const class UMeshComponent* root)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "LogMeshMaterialInfo");

	Params::DBDUtilities_LogMeshMaterialInfo Parms{};

	Parms.inStr = std::move(inStr);
	Parms.root = root;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDUtilities.LogString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    inStr                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDUtilities::LogString(const class FString& inStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "LogString");

	Params::DBDUtilities_LogString Parms{};

	Parms.inStr = std::move(inStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDUtilities.NormalizeXY
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector*                         vector                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::NormalizeXY(struct FVector* vector, float tolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "NormalizeXY");

	Params::DBDUtilities_NormalizeXY Parms{};

	Parms.tolerance = tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (vector != nullptr)
		*vector = std::move(Parms.vector);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.PointerToInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          obj                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int64 UDBDUtilities::PointerToInt(class UObject* obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "PointerToInt");

	Params::DBDUtilities_PointerToInt Parms{};

	Parms.obj = obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.PrintStringEmbiggened
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              TextColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDUtilities::PrintStringEmbiggened(class UObject* WorldContextObject, const class FString& InString, const struct FLinearColor& TextColor, float Duration, int32 Key, float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "PrintStringEmbiggened");

	Params::DBDUtilities_PrintStringEmbiggened Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InString = std::move(InString);
	Parms.TextColor = std::move(TextColor);
	Parms.Duration = Duration;
	Parms.Key = Key;
	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDUtilities.ResolveCharacterIdFromPlayerState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayerState*            playerState                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDBDUtilities::ResolveCharacterIdFromPlayerState(const class ADBDPlayerState* playerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "ResolveCharacterIdFromPlayerState");

	Params::DBDUtilities_ResolveCharacterIdFromPlayerState Parms{};

	Parms.playerState = playerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.SetComponentCastHiddenShadow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    castShadow                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDUtilities::SetComponentCastHiddenShadow(class UPrimitiveComponent* component, bool castShadow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "SetComponentCastHiddenShadow");

	Params::DBDUtilities_SetComponentCastHiddenShadow Parms{};

	Parms.component = component;
	Parms.castShadow = castShadow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DBDUtilities.SphereTraceAgainstActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   end                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class USphereComponent*           sphere                                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      outHitResult                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::SphereTraceAgainstActor(const struct FVector& start, const struct FVector& end, const class USphereComponent* sphere, const class AActor* actor, struct FHitResult* outHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "SphereTraceAgainstActor");

	Params::DBDUtilities_SphereTraceAgainstActor Parms{};

	Parms.start = std::move(start);
	Parms.end = std::move(end);
	Parms.sphere = sphere;
	Parms.actor = actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outHitResult != nullptr)
		*outHitResult = std::move(Parms.outHitResult);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.SphereTraceSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   start                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   end                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class USphereComponent*           sphere                                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      outHitResult                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            ignoredActors                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::SphereTraceSingle(const struct FVector& start, const struct FVector& end, const class USphereComponent* sphere, struct FHitResult* outHitResult, const TArray<class AActor*>& ignoredActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "SphereTraceSingle");

	Params::DBDUtilities_SphereTraceSingle Parms{};

	Parms.start = std::move(start);
	Parms.end = std::move(end);
	Parms.sphere = sphere;
	Parms.ignoredActors = std::move(ignoredActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outHitResult != nullptr)
		*outHitResult = std::move(Parms.outHitResult);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.ToAngle_negative180to180
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilities::ToAngle_negative180to180(float angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "ToAngle_negative180to180");

	Params::DBDUtilities_ToAngle_negative180to180 Parms{};

	Parms.angle = angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.WithinRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   min_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   max_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::WithinRange(float min_0, float max_0, float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "WithinRange");

	Params::DBDUtilities_WithinRange Parms{};

	Parms.min_0 = min_0;
	Parms.max_0 = max_0;
	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilities.WithinRangeExclusive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   min_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   max_0                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilities::WithinRangeExclusive(float min_0, float max_0, float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilities", "WithinRangeExclusive");

	Params::DBDUtilities_WithinRangeExclusive Parms{};

	Parms.min_0 = min_0;
	Parms.max_0 = max_0;
	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGInboxScreen.ButtonClickEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EInboxScreenButton                      buttonid                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGInboxScreen::ButtonClickEvent(EInboxScreenButton buttonid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxScreen", "ButtonClickEvent");

	Params::UMGInboxScreen_ButtonClickEvent Parms{};

	Parms.buttonid = buttonid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGInboxScreen.ClaimAllMessagesEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EInboxMessageUIType                     messageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGInboxScreen::ClaimAllMessagesEvent(EInboxMessageUIType messageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxScreen", "ClaimAllMessagesEvent");

	Params::UMGInboxScreen_ClaimAllMessagesEvent Parms{};

	Parms.messageType = messageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGInboxScreen.ClaimMessageEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    messageId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGInboxScreen::ClaimMessageEvent(const class FString& messageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxScreen", "ClaimMessageEvent");

	Params::UMGInboxScreen_ClaimMessageEvent Parms{};

	Parms.messageId = std::move(messageId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGInboxScreen.CleanAllMessagesEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EInboxMessageUIType                     messageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGInboxScreen::CleanAllMessagesEvent(EInboxMessageUIType messageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxScreen", "CleanAllMessagesEvent");

	Params::UMGInboxScreen_CleanAllMessagesEvent Parms{};

	Parms.messageType = messageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGInboxScreen.CleanMessageEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    messageId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGInboxScreen::CleanMessageEvent(const class FString& messageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxScreen", "CleanMessageEvent");

	Params::UMGInboxScreen_CleanMessageEvent Parms{};

	Parms.messageId = std::move(messageId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGInboxScreen.FindMessageWidgetById
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UPanelWidget*                     containingPanel                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    messageId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUMGInboxMessageEntryWidget*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUMGInboxMessageEntryWidget* UUMGInboxScreen::FindMessageWidgetById(class UPanelWidget* containingPanel, const class FString& messageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxScreen", "FindMessageWidgetById");

	Params::UMGInboxScreen_FindMessageWidgetById Parms{};

	Parms.containingPanel = containingPanel;
	Parms.messageId = std::move(messageId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGInboxScreen.FindWidgetIndexByMessageId
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UPanelWidget*                     containingPanel                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    messageId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUMGInboxScreen::FindWidgetIndexByMessageId(class UPanelWidget* containingPanel, const class FString& messageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxScreen", "FindWidgetIndexByMessageId");

	Params::UMGInboxScreen_FindWidgetIndexByMessageId Parms{};

	Parms.containingPanel = containingPanel;
	Parms.messageId = std::move(messageId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGInboxScreen.ReadAllMessagesEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EInboxMessageUIType                     messageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGInboxScreen::ReadAllMessagesEvent(EInboxMessageUIType messageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxScreen", "ReadAllMessagesEvent");

	Params::UMGInboxScreen_ReadAllMessagesEvent Parms{};

	Parms.messageType = messageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGInboxScreen.ReadMessageEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    messageId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGInboxScreen::ReadMessageEvent(const class FString& messageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxScreen", "ReadMessageEvent");

	Params::UMGInboxScreen_ReadMessageEvent Parms{};

	Parms.messageId = std::move(messageId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGInboxScreen.RemoveMessage
// (Event, Public, BlueprintEvent)
// Parameters:
// const class FString&                    messageId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGInboxScreen::RemoveMessage(const class FString& messageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxScreen", "RemoveMessage");

	Params::UMGInboxScreen_RemoveMessage Parms{};

	Parms.messageId = std::move(messageId);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGInboxScreen.RemoveMessageFromPanel
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UPanelWidget*                     containingPanel                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    messageId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hasSeparator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUMGInboxScreen::RemoveMessageFromPanel(class UPanelWidget* containingPanel, const class FString& messageId, bool hasSeparator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxScreen", "RemoveMessageFromPanel");

	Params::UMGInboxScreen_RemoveMessageFromPanel Parms{};

	Parms.containingPanel = containingPanel;
	Parms.messageId = std::move(messageId);
	Parms.hasSeparator = hasSeparator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGInboxScreen.SetNewsMessages
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<struct FInboxMessageUIData>&messages                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   unreadCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   totalCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGInboxScreen::SetNewsMessages(const TArray<struct FInboxMessageUIData>& messages, int32 unreadCount, int32 totalCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxScreen", "SetNewsMessages");

	Params::UMGInboxScreen_SetNewsMessages Parms{};

	Parms.messages = std::move(messages);
	Parms.unreadCount = unreadCount;
	Parms.totalCount = totalCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGInboxScreen.SetRewardsMessages
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<struct FInboxMessageUIData>&messages                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   unclaimedCount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   unreadCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   totalCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGInboxScreen::SetRewardsMessages(const TArray<struct FInboxMessageUIData>& messages, int32 unclaimedCount, int32 unreadCount, int32 totalCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxScreen", "SetRewardsMessages");

	Params::UMGInboxScreen_SetRewardsMessages Parms{};

	Parms.messages = std::move(messages);
	Parms.unclaimedCount = unclaimedCount;
	Parms.unreadCount = unreadCount;
	Parms.totalCount = totalCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGInboxScreen.SetSocialMessages
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<struct FInboxMessageUIData>&messages                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   unreadCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   totalCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGInboxScreen::SetSocialMessages(const TArray<struct FInboxMessageUIData>& messages, int32 unreadCount, int32 totalCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxScreen", "SetSocialMessages");

	Params::UMGInboxScreen_SetSocialMessages Parms{};

	Parms.messages = std::move(messages);
	Parms.unreadCount = unreadCount;
	Parms.totalCount = totalCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGInboxScreen.UpdateMessage
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FInboxMessageUIData&       message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGInboxScreen::UpdateMessage(const struct FInboxMessageUIData& message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxScreen", "UpdateMessage");

	Params::UMGInboxScreen_UpdateMessage Parms{};

	Parms.message = std::move(message);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGInboxScreen.UpdateMessagesCount
// (Event, Public, BlueprintEvent)
// Parameters:
// EInboxMessageUIType                     messageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   unclaimedCount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   unreadCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   totalCount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGInboxScreen::UpdateMessagesCount(EInboxMessageUIType messageType, int32 unclaimedCount, int32 unreadCount, int32 totalCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxScreen", "UpdateMessagesCount");

	Params::UMGInboxScreen_UpdateMessagesCount Parms{};

	Parms.messageType = messageType;
	Parms.unclaimedCount = unclaimedCount;
	Parms.unreadCount = unreadCount;
	Parms.totalCount = totalCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.DBDUtilTimer.GetPercentTimeElapsed
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDTimer&                 Timer                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilTimer::GetPercentTimeElapsed(const struct FDBDTimer& Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "GetPercentTimeElapsed");

	Params::DBDUtilTimer_GetPercentTimeElapsed Parms{};

	Parms.Timer = std::move(Timer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilTimer.GetPercentTimeLeft
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDTimer&                 Timer                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilTimer::GetPercentTimeLeft(const struct FDBDTimer& Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "GetPercentTimeLeft");

	Params::DBDUtilTimer_GetPercentTimeLeft Parms{};

	Parms.Timer = std::move(Timer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilTimer.GetStartTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDTimer&                 Timer                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilTimer::GetStartTime(const struct FDBDTimer& Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "GetStartTime");

	Params::DBDUtilTimer_GetStartTime Parms{};

	Parms.Timer = std::move(Timer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilTimer.GetTimeElapsed
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDTimer&                 Timer                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilTimer::GetTimeElapsed(const struct FDBDTimer& Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "GetTimeElapsed");

	Params::DBDUtilTimer_GetTimeElapsed Parms{};

	Parms.Timer = std::move(Timer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilTimer.GetTimeLeft
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDTimer&                 Timer                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDBDUtilTimer::GetTimeLeft(const struct FDBDTimer& Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "GetTimeLeft");

	Params::DBDUtilTimer_GetTimeLeft Parms{};

	Parms.Timer = std::move(Timer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilTimer.IsDone
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDBDTimer&                 Timer                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDBDUtilTimer::IsDone(const struct FDBDTimer& Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "IsDone");

	Params::DBDUtilTimer_IsDone Parms{};

	Parms.Timer = std::move(Timer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDUtilTimer.Reset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDBDTimer&                       Timer                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDBDUtilTimer::Reset(struct FDBDTimer& Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "Reset");

	Params::DBDUtilTimer_Reset Parms{};

	Parms.Timer = std::move(Timer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Timer = std::move(Parms.Timer);
}


// Function DeadByDaylight.DBDUtilTimer.ResetTo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDBDTimer&                       Timer                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDUtilTimer::ResetTo(struct FDBDTimer& Timer, float time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "ResetTo");

	Params::DBDUtilTimer_ResetTo Parms{};

	Parms.Timer = std::move(Timer);
	Parms.time = time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Timer = std::move(Parms.Timer);
}


// Function DeadByDaylight.DBDUtilTimer.Stop
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDBDTimer&                       Timer                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDBDUtilTimer::Stop(struct FDBDTimer& Timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "Stop");

	Params::DBDUtilTimer_Stop Parms{};

	Parms.Timer = std::move(Timer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Timer = std::move(Parms.Timer);
}


// Function DeadByDaylight.DBDUtilTimer.Update
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDBDTimer&                       Timer                                                  (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   deltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDUtilTimer::Update(struct FDBDTimer& Timer, float deltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DBDUtilTimer", "Update");

	Params::DBDUtilTimer_Update Parms{};

	Parms.Timer = std::move(Timer);
	Parms.deltaTime = deltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Timer = std::move(Parms.Timer);
}


// Function DeadByDaylight.HudScreen.OnHemorrhageAnimationComplete
// (Final, Native, Private)

void UHudScreen::OnHemorrhageAnimationComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudScreen", "OnHemorrhageAnimationComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HudScreen.OnHideStartSequenceCompleted
// (Final, Native, Private)

void UHudScreen::OnHideStartSequenceCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudScreen", "OnHideStartSequenceCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HudScreen.OnHUDWidgetFadeOutCompleted
// (Final, Native, Private)

void UHudScreen::OnHUDWidgetFadeOutCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudScreen", "OnHUDWidgetFadeOutCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HudScreen.OnTutorialHudFadeInTriggered
// (Final, Native, Private)

void UHudScreen::OnTutorialHudFadeInTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudScreen", "OnTutorialHudFadeInTriggered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HudScreen.OnTutorialHudFadeOutTriggered
// (Final, Native, Private)

void UHudScreen::OnTutorialHudFadeOutTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudScreen", "OnTutorialHudFadeOutTriggered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DecalSpawnerCollection.CreateDecalSpawner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             decalSpawnerName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               decalMaterial                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   poolSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESpawnerStrategyType                    spawnerStrateryType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDecalSpawner*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDecalSpawner* UDecalSpawnerCollection::CreateDecalSpawner(const class UObject* worldContextObject, class FName decalSpawnerName, class UMaterialInterface* decalMaterial, int32 poolSize, ESpawnerStrategyType spawnerStrateryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecalSpawnerCollection", "CreateDecalSpawner");

	Params::DecalSpawnerCollection_CreateDecalSpawner Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.decalSpawnerName = decalSpawnerName;
	Parms.decalMaterial = decalMaterial;
	Parms.poolSize = poolSize;
	Parms.spawnerStrateryType = spawnerStrateryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DecalSpawnerCollection.ReleaseDecalSpawner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             decalSpawnerName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDecalSpawnerCollection::ReleaseDecalSpawner(class FName decalSpawnerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecalSpawnerCollection", "ReleaseDecalSpawner");

	Params::DecalSpawnerCollection_ReleaseDecalSpawner Parms{};

	Parms.decalSpawnerName = decalSpawnerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.DecalSpawnerCollection.SpawnDecalAtLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             decalSpawnerName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   decalSize                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   lifeSpan                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             decalType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             sortOrder                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDBDDecalComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDBDDecalComponent* UDecalSpawnerCollection::SpawnDecalAtLocation(class FName decalSpawnerName, const struct FVector& decalSize, const struct FVector& location, const struct FRotator& rotation, float lifeSpan, class FName decalType, const int32 sortOrder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DecalSpawnerCollection", "SpawnDecalAtLocation");

	Params::DecalSpawnerCollection_SpawnDecalAtLocation Parms{};

	Parms.decalSpawnerName = decalSpawnerName;
	Parms.decalSize = std::move(decalSize);
	Parms.location = std::move(location);
	Parms.rotation = std::move(rotation);
	Parms.lifeSpan = lifeSpan;
	Parms.decalType = decalType;
	Parms.sortOrder = sortOrder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DetectionZoneUtilities.DetectObstruction
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDetectionZone                          detectionZoneID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial**               physicalMaterialOut                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         positionOut                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         normalOut                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDetectionZoneUtilities::DetectObstruction(const class ADBDPlayer* player, EDetectionZone detectionZoneID, class UPhysicalMaterial** physicalMaterialOut, struct FVector* positionOut, struct FVector* normalOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DetectionZoneUtilities", "DetectObstruction");

	Params::DetectionZoneUtilities_DetectObstruction Parms{};

	Parms.player = player;
	Parms.detectionZoneID = detectionZoneID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (physicalMaterialOut != nullptr)
		*physicalMaterialOut = Parms.physicalMaterialOut;

	if (positionOut != nullptr)
		*positionOut = std::move(Parms.positionOut);

	if (normalOut != nullptr)
		*normalOut = std::move(Parms.normalOut);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DialogHandlerCondition.IsTrue
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDialogHandlerCondition::IsTrue(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DialogHandlerCondition", "IsTrue");

	Params::DialogHandlerCondition_IsTrue Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DisplayStandCharmRequesterComponent.OnCharmDisplayed
// (Final, Native, Private)
// Parameters:
// class AActor*                           actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDisplayStandCharmRequesterComponent::OnCharmDisplayed(class AActor* actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DisplayStandCharmRequesterComponent", "OnCharmDisplayed");

	Params::DisplayStandCharmRequesterComponent_OnCharmDisplayed Parms{};

	Parms.actor = actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventTracker.FireGameEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDBDScoreTypes                          eventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameEventTracker::FireGameEvent(EDBDScoreTypes eventType, float amount, class AActor* instigator, class AActor* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventTracker", "FireGameEvent");

	Params::GameEventTracker_FireGameEvent Parms{};

	Parms.eventType = eventType;
	Parms.amount = amount;
	Parms.instigator = instigator;
	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventTracker.FireGameflowEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDBDScoreTypes                          eventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayerState*            instigator                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameEventTracker::FireGameflowEvent(EDBDScoreTypes eventType, float amount, const class ADBDPlayerState* instigator, class FName data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventTracker", "FireGameflowEvent");

	Params::GameEventTracker_FireGameflowEvent Parms{};

	Parms.eventType = eventType;
	Parms.amount = amount;
	Parms.instigator = instigator;
	Parms.data = data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PromoPackPurchaseUIDataUtility.SetRemainingTimeFromHours
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPromoPackPurchaseUIData&        data                                                   (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   remainHours                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPromoPackPurchaseUIDataUtility::SetRemainingTimeFromHours(struct FPromoPackPurchaseUIData& data, int32 remainHours)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PromoPackPurchaseUIDataUtility", "SetRemainingTimeFromHours");

	Params::PromoPackPurchaseUIDataUtility_SetRemainingTimeFromHours Parms{};

	Parms.data = std::move(data);
	Parms.remainHours = remainHours;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	data = std::move(Parms.data);
}


// Function DeadByDaylight.Interactor.BPPostInitializeComponents
// (Event, Public, BlueprintEvent)

void UInteractor::BPPostInitializeComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "BPPostInitializeComponents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Interactor.Multicast_LockStatus
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, NetValidate)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           currentInteraction                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    lock                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractor::Multicast_LockStatus(class ADBDPlayer* player, class UInteractionDefinition* currentInteraction, bool lock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "Multicast_LockStatus");

	Params::Interactor_Multicast_LockStatus Parms{};

	Parms.player = player;
	Parms.currentInteraction = currentInteraction;
	Parms.lock = lock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactor.Multicast_ReservationStatus
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, NetValidate)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    lock                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractor::Multicast_ReservationStatus(class ADBDPlayer* player, bool lock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "Multicast_ReservationStatus");

	Params::Interactor_Multicast_ReservationStatus Parms{};

	Parms.player = player;
	Parms.lock = lock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactor.SetIsUsable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isUsableParam                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractor::SetIsUsable(bool isUsableParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "SetIsUsable");

	Params::Interactor_SetIsUsable Parms{};

	Parms.isUsableParam = isUsableParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Interactor.Authority_GetInteractingPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UInteractor::Authority_GetInteractingPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "Authority_GetInteractingPlayer");

	Params::Interactor_Authority_GetInteractingPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.CanPerformInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInteractionDefinition*     definition                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractor::CanPerformInteraction(const class ADBDPlayer* player, const class UInteractionDefinition* definition) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "CanPerformInteraction");

	Params::Interactor_CanPerformInteraction Parms{};

	Parms.player = player;
	Parms.definition = definition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.GetCurrentInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UInteractor::GetCurrentInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "GetCurrentInteraction");

	Params::Interactor_GetCurrentInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.GetInteractable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInteractable*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractable* UInteractor::GetInteractable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "GetInteractable");

	Params::Interactor_GetInteractable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.GetInteractingPlayerRaw
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* UInteractor::GetInteractingPlayerRaw() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "GetInteractingPlayerRaw");

	Params::Interactor_GetInteractingPlayerRaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.GetInteractionDefinitions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UInteractionDefinition*>   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UInteractionDefinition*> UInteractor::GetInteractionDefinitions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "GetInteractionDefinitions");

	Params::Interactor_GetInteractionDefinitions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.GetIsUsable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractor::GetIsUsable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "GetIsUsable");

	Params::Interactor_GetIsUsable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.IsInteracting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractor::IsInteracting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "IsInteracting");

	Params::Interactor_IsInteracting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Interactor.IsInterruptionPossible
// (Final, Native, Public, Const)
// Parameters:
// const class ADBDPlayer*                 interruptor                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 interruptee                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInteractionDefinition*     definition                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInterruptionDefinition*    interruption                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractor::IsInterruptionPossible(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee, const class UInteractionDefinition* definition, const class UInterruptionDefinition* interruption) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Interactor", "IsInterruptionPossible");

	Params::Interactor_IsInterruptionPossible Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;
	Parms.definition = definition;
	Parms.interruption = interruption;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.NoiseIndicatorWidget.SetIndicatorPanel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCanvasPanel*                     panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoiseIndicatorWidget::SetIndicatorPanel(class UCanvasPanel* panel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoiseIndicatorWidget", "SetIndicatorPanel");

	Params::NoiseIndicatorWidget_SetIndicatorPanel Parms{};

	Parms.panel = panel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillInteractionDefinition.OnKillAudioActivation
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// const bool                              active                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interactingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillInteractionDefinition::OnKillAudioActivation(const bool active, class ADBDPlayer* interactingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillInteractionDefinition", "OnKillAudioActivation");

	Params::KillInteractionDefinition_OnKillAudioActivation Parms{};

	Parms.active = active;
	Parms.interactingPlayer = interactingPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.KillInteractionDefinition.OnMoriCancelled
// (Event, Protected, BlueprintEvent)

void UKillInteractionDefinition::OnMoriCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillInteractionDefinition", "OnMoriCancelled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.KillInteractionDefinition.GetChargeCompleted
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKillInteractionDefinition::GetChargeCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillInteractionDefinition", "GetChargeCompleted");

	Params::KillInteractionDefinition_GetChargeCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.KillInteractionDefinition.GetExitAnimationMontage
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// struct FAnimationMontageDescriptor      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAnimationMontageDescriptor UKillInteractionDefinition::GetExitAnimationMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillInteractionDefinition", "GetExitAnimationMontage");

	Params::KillInteractionDefinition_GetExitAnimationMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.KillInteractionDefinition.GetOwningSurvivor
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ACamperPlayer*              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ACamperPlayer* UKillInteractionDefinition::GetOwningSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillInteractionDefinition", "GetOwningSurvivor");

	Params::KillInteractionDefinition_GetOwningSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EffectsLocator.OnActorTick
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMaterialInstanceDynamic*         actorMaterialInstanceDynamic                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectsLocator::OnActorTick(class UMaterialInstanceDynamic* actorMaterialInstanceDynamic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectsLocator", "OnActorTick");

	Params::EffectsLocator_OnActorTick Parms{};

	Parms.actorMaterialInstanceDynamic = actorMaterialInstanceDynamic;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.EffectsLocator.OnEnterCollisionArea
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectsLocator::OnEnterCollisionArea(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectsLocator", "OnEnterCollisionArea");

	Params::EffectsLocator_OnEnterCollisionArea Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EffectsLocator.OnFoundActor
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           foundActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectsLocator::OnFoundActor(class AActor* foundActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectsLocator", "OnFoundActor");

	Params::EffectsLocator_OnFoundActor Parms{};

	Parms.foundActor = foundActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.EffectsLocator.OnLeaveCollisionArea
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectsLocator::OnLeaveCollisionArea(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectsLocator", "OnLeaveCollisionArea");

	Params::EffectsLocator_OnLeaveCollisionArea Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EffectsLocator.OnLostActor
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           lostActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEffectsLocator::OnLostActor(class AActor* lostActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EffectsLocator", "OnLostActor");

	Params::EffectsLocator_OnLostActor Parms{};

	Parms.lostActor = lostActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.EndGameComponent.DisableEndGameScenario
// (Final, Native, Public, BlueprintCallable)

void UEndGameComponent::DisableEndGameScenario()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameComponent", "DisableEndGameScenario");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameComponent.FireEndGameSacrificeScoreEvent
// (Final, Native, Private)
// Parameters:
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void UEndGameComponent::FireEndGameSacrificeScoreEvent(const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameComponent", "FireEndGameSacrificeScoreEvent");

	Params::EndGameComponent_FireEndGameSacrificeScoreEvent Parms{};

	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameComponent.PauseEndGameTimer
// (Final, Native, Public, BlueprintCallable)

void UEndGameComponent::PauseEndGameTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameComponent", "PauseEndGameTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameComponent.StartEndGame_Cheat
// (Final, Native, Public, BlueprintCallable)

void UEndGameComponent::StartEndGame_Cheat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameComponent", "StartEndGame_Cheat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameComponent.UnpauseEndGameTimer
// (Final, Native, Public, BlueprintCallable)

void UEndGameComponent::UnpauseEndGameTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameComponent", "UnpauseEndGameTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EndGameComponent.GetHasEndGameBegun
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEndGameComponent::GetHasEndGameBegun() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndGameComponent", "GetHasEndGameBegun");

	Params::EndGameComponent_GetHasEndGameBegun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MapActorComponent.Multicast_SetDetectionEnabled
// (BlueprintAuthorityOnly, Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapActorComponent::Multicast_SetDetectionEnabled(bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorComponent", "Multicast_SetDetectionEnabled");

	Params::MapActorComponent_Multicast_SetDetectionEnabled Parms{};

	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MapActorComponent.GetDetectionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapActorComponent::GetDetectionEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorComponent", "GetDetectionEnabled");

	Params::MapActorComponent_GetDetectionEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MapActorComponent.IsKnownBy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapActorComponent::IsKnownBy(const class ADBDPlayer* character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorComponent", "IsKnownBy");

	Params::MapActorComponent_IsKnownBy Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EnduranceVFXComponent.ShowHighlight
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayModifierContainer*       preventKOSource                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnduranceVFXComponent::ShowHighlight(class UGameplayModifierContainer* preventKOSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnduranceVFXComponent", "ShowHighlight");

	Params::EnduranceVFXComponent_ShowHighlight Parms{};

	Parms.preventKOSource = preventKOSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrapRemover.AddKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   keyId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrapRemover::AddKey(int32 keyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrapRemover", "AddKey");

	Params::ReverseBearTrapRemover_AddKey Parms{};

	Parms.keyId = keyId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrapRemover.AddSearchedKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   keyId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AReverseBearTrapRemover::AddSearchedKey(int32 keyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrapRemover", "AddSearchedKey");

	Params::ReverseBearTrapRemover_AddSearchedKey Parms{};

	Parms.keyId = keyId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ReverseBearTrapRemover.PlayRemoveFailMontage
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AReverseBearTrapRemover::PlayRemoveFailMontage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrapRemover", "PlayRemoveFailMontage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ReverseBearTrapRemover.GetAttachedRBT
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AReverseBearTrap*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AReverseBearTrap* AReverseBearTrapRemover::GetAttachedRBT(class AActor* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrapRemover", "GetAttachedRBT");

	Params::ReverseBearTrapRemover_GetAttachedRBT Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrapRemover.GetInteractorPrimitiveComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* AReverseBearTrapRemover::GetInteractorPrimitiveComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrapRemover", "GetInteractorPrimitiveComponent");

	Params::ReverseBearTrapRemover_GetInteractorPrimitiveComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrapRemover.GetMapActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMapActorComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMapActorComponent* AReverseBearTrapRemover::GetMapActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrapRemover", "GetMapActor");

	Params::ReverseBearTrapRemover_GetMapActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrapRemover.HasKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   keyId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrapRemover::HasKey(int32 keyId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrapRemover", "HasKey");

	Params::ReverseBearTrapRemover_HasKey Parms{};

	Parms.keyId = keyId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ReverseBearTrapRemover.HasSearchedForKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   keyId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AReverseBearTrapRemover::HasSearchedForKey(int32 keyId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReverseBearTrapRemover", "HasSearchedForKey");

	Params::ReverseBearTrapRemover_HasSearchedForKey Parms{};

	Parms.keyId = keyId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MatchManagementScreen.OnAddMap
// (Final, Native, Private)
// Parameters:
// const class FString&                    mapId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchManagementScreen::OnAddMap(const class FString& mapId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnAddMap");

	Params::MatchManagementScreen_OnAddMap Parms{};

	Parms.mapId = std::move(mapId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MatchManagementScreen.OnAllowDlcSettingsClick
// (Final, Native, Private)

void UMatchManagementScreen::OnAllowDlcSettingsClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnAllowDlcSettingsClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MatchManagementScreen.OnApplyChangesClicked
// (Final, Native, Private)

void UMatchManagementScreen::OnApplyChangesClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnApplyChangesClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MatchManagementScreen.OnBackButtonClick
// (Final, Native, Private)

void UMatchManagementScreen::OnBackButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnBackButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MatchManagementScreen.OnItemsAndAddonsSettingsChange
// (Final, Native, Private)
// Parameters:
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchManagementScreen::OnItemsAndAddonsSettingsChange(int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnItemsAndAddonsSettingsChange");

	Params::MatchManagementScreen_OnItemsAndAddonsSettingsChange Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MatchManagementScreen.OnOfferingsSettingsChange
// (Final, Native, Private)
// Parameters:
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchManagementScreen::OnOfferingsSettingsChange(int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnOfferingsSettingsChange");

	Params::MatchManagementScreen_OnOfferingsSettingsChange Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MatchManagementScreen.OnPerksSettingsChange
// (Final, Native, Private)
// Parameters:
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchManagementScreen::OnPerksSettingsChange(int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnPerksSettingsChange");

	Params::MatchManagementScreen_OnPerksSettingsChange Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MatchManagementScreen.OnRemoveMap
// (Final, Native, Private)
// Parameters:
// const class FString&                    mapId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchManagementScreen::OnRemoveMap(const class FString& mapId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchManagementScreen", "OnRemoveMap");

	Params::MatchManagementScreen_OnRemoveMap Parms{};

	Parms.mapId = std::move(mapId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeBlocker.ActivatePlayerBlockerFX
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AEscapeBlocker::ActivatePlayerBlockerFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeBlocker", "ActivatePlayerBlockerFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.EscapeBlocker.DeactivatePlayerBlockerFX
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AEscapeBlocker::DeactivatePlayerBlockerFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeBlocker", "DeactivatePlayerBlockerFX");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.EscapeBlocker.OnPlayerDetectionZoneBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              hitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           otherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              otherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   otherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                sweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AEscapeBlocker::OnPlayerDetectionZoneBeginOverlap(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeBlocker", "OnPlayerDetectionZoneBeginOverlap");

	Params::EscapeBlocker_OnPlayerDetectionZoneBeginOverlap Parms{};

	Parms.hitComponent = hitComponent;
	Parms.otherActor = otherActor;
	Parms.otherComp = otherComp;
	Parms.otherBodyIndex = otherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.sweepResult = std::move(sweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeBlocker.OnPlayerDetectionZoneEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              hitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           otherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              otherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   otherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeBlocker::OnPlayerDetectionZoneEndOverlap(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeBlocker", "OnPlayerDetectionZoneEndOverlap");

	Params::EscapeBlocker_OnPlayerDetectionZoneEndOverlap Parms{};

	Parms.hitComponent = hitComponent;
	Parms.otherActor = otherActor;
	Parms.otherComp = otherComp;
	Parms.otherBodyIndex = otherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeBlocker.SetCamperBlocker
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UBoxComponent*                    camperBlocker                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeBlocker::SetCamperBlocker(class UBoxComponent* camperBlocker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeBlocker", "SetCamperBlocker");

	Params::EscapeBlocker_SetCamperBlocker Parms{};

	Parms.camperBlocker = camperBlocker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeBlocker.SetPlayerDetectionZone
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UBoxComponent*                    playerDetectionZone                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeBlocker::SetPlayerDetectionZone(class UBoxComponent* playerDetectionZone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeBlocker", "SetPlayerDetectionZone");

	Params::EscapeBlocker_SetPlayerDetectionZone Parms{};

	Parms.playerDetectionZone = playerDetectionZone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.GetOpenEscapeInteraction
// (Event, Public, BlueprintEvent)
// Parameters:
// class UChargeableInteractionDefinition* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableInteractionDefinition* AEscapeDoor::GetOpenEscapeInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetOpenEscapeInteraction");

	Params::EscapeDoor_GetOpenEscapeInteraction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.LightAllLights
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)

void AEscapeDoor::LightAllLights()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "LightAllLights");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.EscapeDoor.OnBlockDoorSwitchCosmetic
// (Event, Protected, BlueprintEvent)

void AEscapeDoor::OnBlockDoorSwitchCosmetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnBlockDoorSwitchCosmetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.EscapeDoor.OnCamperStartOpeningExitGate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnCamperStartOpeningExitGate(class ACamperPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnCamperStartOpeningExitGate");

	Params::EscapeDoor_OnCamperStartOpeningExitGate Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.OnEscapeZoneBeginOverlap
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           overlappingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnEscapeZoneBeginOverlap(class AActor* overlappingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnEscapeZoneBeginOverlap");

	Params::EscapeDoor_OnEscapeZoneBeginOverlap Parms{};

	Parms.overlappingActor = overlappingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.OnEscapeZoneEndOverlap
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           overlappingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnEscapeZoneEndOverlap(class AActor* overlappingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnEscapeZoneEndOverlap");

	Params::EscapeDoor_OnEscapeZoneEndOverlap Parms{};

	Parms.overlappingActor = overlappingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.OnExitActivationChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    activated                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnExitActivationChanged(bool activated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnExitActivationChanged");

	Params::EscapeDoor_OnExitActivationChanged Parms{};

	Parms.activated = activated;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.EscapeDoor.OnExitGateOpened
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnExitGateOpened(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnExitGateOpened");

	Params::EscapeDoor_OnExitGateOpened Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.OnExitOpenChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    opened                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnExitOpenChanged(bool opened)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnExitOpenChanged");

	Params::EscapeDoor_OnExitOpenChanged Parms{};

	Parms.opened = opened;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.EscapeDoor.OnPlayerEnterExitArea
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnPlayerEnterExitArea(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnPlayerEnterExitArea");

	Params::EscapeDoor_OnPlayerEnterExitArea Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.OnPlayerExitExitArea
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnPlayerExitExitArea(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnPlayerExitExitArea");

	Params::EscapeDoor_OnPlayerExitExitArea Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.OnRep_Activated
// (Final, Native, Private)
// Parameters:
// bool                                    oldActivated                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::OnRep_Activated(bool oldActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnRep_Activated");

	Params::EscapeDoor_OnRep_Activated Parms{};

	Parms.oldActivated = oldActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.OnUnblockDoorSwitchCosmetic
// (Event, Protected, BlueprintEvent)

void AEscapeDoor::OnUnblockDoorSwitchCosmetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "OnUnblockDoorSwitchCosmetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.EscapeDoor.SetIsActivated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isActivated                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEscapeDoor::SetIsActivated(bool isActivated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "SetIsActivated");

	Params::EscapeDoor_SetIsActivated Parms{};

	Parms.isActivated = isActivated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.StartAtlantaDoorBeepingSound
// (Final, Native, Public, BlueprintCallable)

void AEscapeDoor::StartAtlantaDoorBeepingSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "StartAtlantaDoorBeepingSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.StartAtlantaDoorOpeningSound
// (Final, Native, Public, BlueprintCallable)

void AEscapeDoor::StartAtlantaDoorOpeningSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "StartAtlantaDoorOpeningSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.EscapeDoor.GetAtlantaExitOpeningIndicatorVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEscapeDoor::GetAtlantaExitOpeningIndicatorVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetAtlantaExitOpeningIndicatorVisibility");

	Params::EscapeDoor_GetAtlantaExitOpeningIndicatorVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.GetDoorSkeletalMeshComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AEscapeDoor::GetDoorSkeletalMeshComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetDoorSkeletalMeshComponent");

	Params::EscapeDoor_GetDoorSkeletalMeshComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.GetEscapeSwitchFloorLocation
// (Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AEscapeDoor::GetEscapeSwitchFloorLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetEscapeSwitchFloorLocation");

	Params::EscapeDoor_GetEscapeSwitchFloorLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.GetExitArea
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UBoxComponent*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBoxComponent* AEscapeDoor::GetExitArea() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetExitArea");

	Params::EscapeDoor_GetExitArea Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.GetIsOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEscapeDoor::GetIsOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetIsOpen");

	Params::EscapeDoor_GetIsOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.GetOpenTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AEscapeDoor::GetOpenTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetOpenTime");

	Params::EscapeDoor_GetOpenTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.GetParadiseServerLocation
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AEscapeDoor::GetParadiseServerLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetParadiseServerLocation");

	Params::EscapeDoor_GetParadiseServerLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.GetSwitchSceneComponent
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AEscapeDoor::GetSwitchSceneComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "GetSwitchSceneComponent");

	Params::EscapeDoor_GetSwitchSceneComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.IsActivated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEscapeDoor::IsActivated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "IsActivated");

	Params::EscapeDoor_IsActivated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeDoor.IsDoorSwitchBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEscapeDoor::IsDoorSwitchBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeDoor", "IsDoorSwitchBlocked");

	Params::EscapeDoor_IsDoorSwitchBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.EscapeThroughHatch.OnCamperEscapeThroughHatch
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ACamperPlayer*                    player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEscapeThroughHatch::OnCamperEscapeThroughHatch(class ACamperPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EscapeThroughHatch", "OnCamperEscapeThroughHatch");

	Params::EscapeThroughHatch_OnCamperEscapeThroughHatch Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.EventGeneratorComponent.Authority_FireGenCompletedEventScore
// (Final, Native, Private)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventGeneratorComponent::Authority_FireGenCompletedEventScore(bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventGeneratorComponent", "Authority_FireGenCompletedEventScore");

	Params::EventGeneratorComponent_Authority_FireGenCompletedEventScore Parms{};

	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternLightCollectable.SetParentLantern
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALanternInteractable*             parentLantern                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALanternLightCollectable::SetParentLantern(class ALanternInteractable* parentLantern)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternLightCollectable", "SetParentLantern");

	Params::LanternLightCollectable_SetParentLantern Parms{};

	Parms.parentLantern = parentLantern;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ExposerInteriorZoneComponent.AddExposerSpawnPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  point                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UExposerInteriorZoneComponent::AddExposerSpawnPoint(class USceneComponent* point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExposerInteriorZoneComponent", "AddExposerSpawnPoint");

	Params::ExposerInteriorZoneComponent_AddExposerSpawnPoint Parms{};

	Parms.point = point;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgSpectatorHud.HandleLeaveSpectateClicked
// (Final, Native, Public, BlueprintCallable)

void UUmgSpectatorHud::HandleLeaveSpectateClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSpectatorHud", "HandleLeaveSpectateClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgSpectatorHud.OnPlayerStatusSelected
// (Final, Native, Private)
// Parameters:
// const class FString&                    playerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgSpectatorHud::OnPlayerStatusSelected(const class FString& playerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgSpectatorHud", "OnPlayerStatusSelected");

	Params::UmgSpectatorHud_OnPlayerStatusSelected Parms{};

	Parms.playerName = std::move(playerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Fadeable.OnAlphaChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   newAlpha                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFadeable::OnAlphaChanged(float newAlpha, class AActor* other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Fadeable", "OnAlphaChanged");

	Params::Fadeable_OnAlphaChanged Parms{};

	Parms.newAlpha = newAlpha;
	Parms.other = other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Fadeable.OnFadeBegin
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFadeable::OnFadeBegin(class AActor* other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Fadeable", "OnFadeBegin");

	Params::Fadeable_OnFadeBegin Parms{};

	Parms.other = other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Fadeable.OnFadeEnd
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFadeable::OnFadeEnd(class AActor* other)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("Fadeable", "OnFadeEnd");

	Params::Fadeable_OnFadeEnd Parms{};

	Parms.other = other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoginPopup.ChooseProvider
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const uint8                             provider                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoginPopup::ChooseProvider(const uint8 provider)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoginPopup", "ChooseProvider");

	Params::UMGLoginPopup_ChooseProvider Parms{};

	Parms.provider = provider;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FearMarketManager.ReceivedFearMarketData
// (Final, Native, Private)
// Parameters:
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFearMarketManager::ReceivedFearMarketData(bool success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FearMarketManager", "ReceivedFearMarketData");

	Params::FearMarketManager_ReceivedFearMarketData Parms{};

	Parms.success = success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Firecracker.Multicast_InitFromSpawner
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// class ACollectable*                     spawner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFirecracker::Multicast_InitFromSpawner(class ACollectable* spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "Multicast_InitFromSpawner");

	Params::Firecracker_Multicast_InitFromSpawner Parms{};

	Parms.spawner = spawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Firecracker.OnEffectsInitialized
// (Native, Event, Protected, BlueprintEvent)

void AFirecracker::OnEffectsInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "OnEffectsInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Firecracker.OnExplode
// (Event, Protected, BlueprintEvent)

void AFirecracker::OnExplode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "OnExplode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Firecracker.OnFuseBurnEnter
// (Event, Protected, BlueprintEvent)

void AFirecracker::OnFuseBurnEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "OnFuseBurnEnter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Firecracker.OnFuseBurnExit
// (Event, Protected, BlueprintEvent)

void AFirecracker::OnFuseBurnExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "OnFuseBurnExit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Firecracker.OnFuseBurnUpdate
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   deltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   fuseTimeLeftPercent                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFirecracker::OnFuseBurnUpdate(float deltaSeconds, float fuseTimeLeftPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "OnFuseBurnUpdate");

	Params::Firecracker_OnFuseBurnUpdate Parms{};

	Parms.deltaSeconds = deltaSeconds;
	Parms.fuseTimeLeftPercent = fuseTimeLeftPercent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Firecracker.GetBlindnessEffectDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFirecracker::GetBlindnessEffectDuration(const class AActor* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "GetBlindnessEffectDuration");

	Params::Firecracker_GetBlindnessEffectDuration Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Firecracker.GetDeafnessEffectDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFirecracker::GetDeafnessEffectDuration(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "GetDeafnessEffectDuration");

	Params::Firecracker_GetDeafnessEffectDuration Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Firecracker.GetEffects
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UGameplayModifierContainer*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UGameplayModifierContainer*> AFirecracker::GetEffects() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "GetEffects");

	Params::Firecracker_GetEffects Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Firecracker.GetExploded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFirecracker::GetExploded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "GetExploded");

	Params::Firecracker_GetExploded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Firecracker.GetExplosionDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFirecracker::GetExplosionDelay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "GetExplosionDelay");

	Params::Firecracker_GetExplosionDelay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Firecracker.GetExplosionEffectDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFirecracker::GetExplosionEffectDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "GetExplosionEffectDuration");

	Params::Firecracker_GetExplosionEffectDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Firecracker.GetExplosionRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFirecracker::GetExplosionRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "GetExplosionRange");

	Params::Firecracker_GetExplosionRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Firecracker.GetModifierValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AFirecracker::GetModifierValue(const struct FGameplayTag& type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "GetModifierValue");

	Params::Firecracker_GetModifierValue Parms{};

	Parms.type = std::move(type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Firecracker.HasFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              flag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFirecracker::HasFlag(const struct FGameplayTag& flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "HasFlag");

	Params::Firecracker_HasFlag Parms{};

	Parms.flag = std::move(flag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Firecracker.HasModifierOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFirecracker::HasModifierOfType(const struct FGameplayTag& type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "HasModifierOfType");

	Params::Firecracker_HasModifierOfType Parms{};

	Parms.type = std::move(type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Firecracker.ShouldBlind
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  outDuration                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFirecracker::ShouldBlind(const class ADBDPlayer* player, float* outDuration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "ShouldBlind");

	Params::Firecracker_ShouldBlind Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outDuration != nullptr)
		*outDuration = Parms.outDuration;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Firecracker.ShouldDeafen
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  outDuration                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFirecracker::ShouldDeafen(const class ADBDPlayer* player, float* outDuration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Firecracker", "ShouldDeafen");

	Params::Firecracker_ShouldDeafen Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outDuration != nullptr)
		*outDuration = Parms.outDuration;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GenericTextInputPopupScreen.OnTextInputChoiceSelected
// (Final, Native, Private)
// Parameters:
// int32                                   selectedButtonType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    inputText                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGenericTextInputPopupScreen::OnTextInputChoiceSelected(int32 selectedButtonType, const class FString& inputText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GenericTextInputPopupScreen", "OnTextInputChoiceSelected");

	Params::GenericTextInputPopupScreen_OnTextInputChoiceSelected Parms{};

	Parms.selectedButtonType = selectedButtonType;
	Parms.inputText = std::move(inputText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FirecrackerEffectHandlerComponent.OnFirecrackerDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           destroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFirecrackerEffectHandlerComponent::OnFirecrackerDestroyed(class AActor* destroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FirecrackerEffectHandlerComponent", "OnFirecrackerDestroyed");

	Params::FirecrackerEffectHandlerComponent_OnFirecrackerDestroyed Parms{};

	Parms.destroyedActor = destroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLobbyScreen.HandleJoinedLobbyLeave
// (Final, Native, Protected, BlueprintCallable)

void UUMGLobbyScreen::HandleJoinedLobbyLeave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbyScreen", "HandleJoinedLobbyLeave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLobbyScreen.HandleSearchingLobbyCancel
// (Final, Native, Protected, BlueprintCallable)

void UUMGLobbyScreen::HandleSearchingLobbyCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbyScreen", "HandleSearchingLobbyCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FlickeringLight.GetActiveLightComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULocalLightComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalLightComponent* AFlickeringLight::GetActiveLightComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlickeringLight", "GetActiveLightComponent");

	Params::FlickeringLight_GetActiveLightComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.FlickeringLight.GetSecondaryLightComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULocalLightComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalLightComponent* AFlickeringLight::GetSecondaryLightComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlickeringLight", "GetSecondaryLightComponent");

	Params::FlickeringLight_GetSecondaryLightComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.FlickeringLight.GetSecondaryLightVisibilty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFlickeringLight::GetSecondaryLightVisibilty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlickeringLight", "GetSecondaryLightVisibilty");

	Params::FlickeringLight_GetSecondaryLightVisibilty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.FlickeringLight.Init
// (Final, Native, Protected, BlueprintCallable)

void AFlickeringLight::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlickeringLight", "Init");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FlickeringLight.StartFlickering
// (Final, Native, Protected, BlueprintCallable)

void AFlickeringLight::StartFlickering()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlickeringLight", "StartFlickering");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FlickeringLight.StopFlickering
// (Final, Native, Protected, BlueprintCallable)

void AFlickeringLight::StopFlickering()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlickeringLight", "StopFlickering");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FranklinsDemiseConsumedByEntityComponent.Authority_StartConsume
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       previousOwner                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       slasher                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFranklinsDemiseConsumedByEntityComponent::Authority_StartConsume(float duration, class ADBDPlayer* previousOwner, class ADBDPlayer* slasher)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FranklinsDemiseConsumedByEntityComponent", "Authority_StartConsume");

	Params::FranklinsDemiseConsumedByEntityComponent_Authority_StartConsume Parms{};

	Parms.duration = duration;
	Parms.previousOwner = previousOwner;
	Parms.slasher = slasher;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FranklinsDemiseConsumedByEntityComponent.OnConsumedByEntity
// (Event, Public, BlueprintEvent)

void UFranklinsDemiseConsumedByEntityComponent::OnConsumedByEntity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FranklinsDemiseConsumedByEntityComponent", "OnConsumedByEntity");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.FranklinsDemiseConsumedByEntityComponent.OnRep_ConsumeTimer
// (Final, Native, Private)

void UFranklinsDemiseConsumedByEntityComponent::OnRep_ConsumeTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FranklinsDemiseConsumedByEntityComponent", "OnRep_ConsumeTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendSearchPopupScreen.OnAcceptFriendInvite
// (Final, Native, Public)
// Parameters:
// const class FString&                    friendKrakenID                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendSearchPopupScreen::OnAcceptFriendInvite(const class FString& friendKrakenID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendSearchPopupScreen", "OnAcceptFriendInvite");

	Params::FriendSearchPopupScreen_OnAcceptFriendInvite Parms{};

	Parms.friendKrakenID = std::move(friendKrakenID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendSearchPopupScreen.OnFriendSearchStart
// (Final, Native, Public)
// Parameters:
// const class FString&                    searchText                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendSearchPopupScreen::OnFriendSearchStart(const class FString& searchText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendSearchPopupScreen", "OnFriendSearchStart");

	Params::FriendSearchPopupScreen_OnFriendSearchStart Parms{};

	Parms.searchText = std::move(searchText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendSearchPopupScreen.OnInviteFriend
// (Final, Native, Public)
// Parameters:
// const class FString&                    friendKrakenID                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isOffNetwork                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendSearchPopupScreen::OnInviteFriend(const class FString& friendKrakenID, bool isOffNetwork)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendSearchPopupScreen", "OnInviteFriend");

	Params::FriendSearchPopupScreen_OnInviteFriend Parms{};

	Parms.friendKrakenID = std::move(friendKrakenID);
	Parms.isOffNetwork = isOffNetwork;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendSearchPopupScreen.OnUnblockPlayer
// (Final, Native, Public)
// Parameters:
// const class FString&                    friendKrakenID                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendSearchPopupScreen::OnUnblockPlayer(const class FString& friendKrakenID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendSearchPopupScreen", "OnUnblockPlayer");

	Params::FriendSearchPopupScreen_OnUnblockPlayer Parms{};

	Parms.friendKrakenID = std::move(friendKrakenID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnAcceptFriendInvite
// (Final, Native, Private)
// Parameters:
// const class FString&                    friendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnAcceptFriendInvite(const class FString& friendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnAcceptFriendInvite");

	Params::FriendsListScreen_OnAcceptFriendInvite Parms{};

	Parms.friendId = std::move(friendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnBlockPlayer
// (Final, Native, Private)
// Parameters:
// const class FString&                    playerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnBlockPlayer(const class FString& playerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnBlockPlayer");

	Params::FriendsListScreen_OnBlockPlayer Parms{};

	Parms.playerId = std::move(playerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnCancelFriendInvite
// (Final, Native, Private)
// Parameters:
// const class FString&                    friendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnCancelFriendInvite(const class FString& friendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnCancelFriendInvite");

	Params::FriendsListScreen_OnCancelFriendInvite Parms{};

	Parms.friendId = std::move(friendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnDeclineFriendInvite
// (Final, Native, Private)
// Parameters:
// const class FString&                    friendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnDeclineFriendInvite(const class FString& friendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnDeclineFriendInvite");

	Params::FriendsListScreen_OnDeclineFriendInvite Parms{};

	Parms.friendId = std::move(friendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnPartyJoinRequest
// (Final, Native, Private)
// Parameters:
// const class FString&                    friendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnPartyJoinRequest(const class FString& friendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnPartyJoinRequest");

	Params::FriendsListScreen_OnPartyJoinRequest Parms{};

	Parms.friendId = std::move(friendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnRemoveFriend
// (Final, Native, Private)
// Parameters:
// const class FString&                    friendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnRemoveFriend(const class FString& friendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnRemoveFriend");

	Params::FriendsListScreen_OnRemoveFriend Parms{};

	Parms.friendId = std::move(friendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnSearchForFriend
// (Final, Native, Private)

void UFriendsListScreen::OnSearchForFriend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnSearchForFriend");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnSendPartyInvite
// (Final, Native, Private)
// Parameters:
// const class FString&                    friendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnSendPartyInvite(const class FString& friendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnSendPartyInvite");

	Params::FriendsListScreen_OnSendPartyInvite Parms{};

	Parms.friendId = std::move(friendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnShowNameSelected
// (Final, Native, Private)
// Parameters:
// const class FString&                    playerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnShowNameSelected(const class FString& playerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnShowNameSelected");

	Params::FriendsListScreen_OnShowNameSelected Parms{};

	Parms.playerId = std::move(playerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnUnblockPlayer
// (Final, Native, Private)
// Parameters:
// const class FString&                    playerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnUnblockPlayer(const class FString& playerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnUnblockPlayer");

	Params::FriendsListScreen_OnUnblockPlayer Parms{};

	Parms.playerId = std::move(playerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.FriendsListScreen.OnViewProfile
// (Final, Native, Private)
// Parameters:
// const class FString&                    friendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendsListScreen::OnViewProfile(const class FString& friendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendsListScreen", "OnViewProfile");

	Params::FriendsListScreen_OnViewProfile Parms{};

	Parms.friendId = std::move(friendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventDispatcher.Authority_AccumulateOngoingGameEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ongoingWaitTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameEventDispatcher::Authority_AccumulateOngoingGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData, float ongoingWaitTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventDispatcher", "Authority_AccumulateOngoingGameEvent");

	Params::GameEventDispatcher_Authority_AccumulateOngoingGameEvent Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);
	Parms.ongoingWaitTime = ongoingWaitTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventDispatcher.Authority_RemotelyDispatch
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGameEventDispatcher::Authority_RemotelyDispatch(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventDispatcher", "Authority_RemotelyDispatch");

	Params::GameEventDispatcher_Authority_RemotelyDispatch Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventDispatcher.LocallyDispatch
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGameEventDispatcher::LocallyDispatch(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventDispatcher", "LocallyDispatch");

	Params::GameEventDispatcher_LocallyDispatch Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventDispatcher.RegisterListener
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameEventDispatcherHandleBP&gameEventDispatcherHandle                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGameEventDispatcher::RegisterListener(const struct FGameEventDispatcherHandleBP& gameEventDispatcherHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventDispatcher", "RegisterListener");

	Params::GameEventDispatcher_RegisterListener Parms{};

	Parms.gameEventDispatcherHandle = std::move(gameEventDispatcherHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventDispatcher.RemotelyDispatch
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGameEventDispatcher::RemotelyDispatch(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventDispatcher", "RemotelyDispatch");

	Params::GameEventDispatcher_RemotelyDispatch Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameEventDispatcher.UnregisterListener
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameEventDispatcherHandleBP&gameEventDispatcherHandle                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGameEventDispatcher::UnregisterListener(const struct FGameEventDispatcherHandleBP& gameEventDispatcherHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameEventDispatcher", "UnregisterListener");

	Params::GameEventDispatcher_UnregisterListener Parms{};

	Parms.gameEventDispatcherHandle = std::move(gameEventDispatcherHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierFunctionLibrary.Authority_ClearAllPlayerGameplayFlags
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       targetPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierFunctionLibrary::Authority_ClearAllPlayerGameplayFlags(class ADBDPlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayModifierFunctionLibrary", "Authority_ClearAllPlayerGameplayFlags");

	Params::GameplayModifierFunctionLibrary_Authority_ClearAllPlayerGameplayFlags Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierFunctionLibrary.Authority_ClearAllPlayerGameplayModifiers
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       targetPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierFunctionLibrary::Authority_ClearAllPlayerGameplayModifiers(class ADBDPlayer* targetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayModifierFunctionLibrary", "Authority_ClearAllPlayerGameplayModifiers");

	Params::GameplayModifierFunctionLibrary_Authority_ClearAllPlayerGameplayModifiers Parms{};

	Parms.targetPlayer = targetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierFunctionLibrary.Authority_ClearPlayerGameplayFlag
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       targetPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              flagType                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierFunctionLibrary::Authority_ClearPlayerGameplayFlag(class ADBDPlayer* targetPlayer, const struct FGameplayTag& flagType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayModifierFunctionLibrary", "Authority_ClearPlayerGameplayFlag");

	Params::GameplayModifierFunctionLibrary_Authority_ClearPlayerGameplayFlag Parms{};

	Parms.targetPlayer = targetPlayer;
	Parms.flagType = std::move(flagType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierFunctionLibrary.Authority_ClearPlayerGameplayModifier
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       targetPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              modifierType                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierFunctionLibrary::Authority_ClearPlayerGameplayModifier(class ADBDPlayer* targetPlayer, const struct FGameplayTag& modifierType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayModifierFunctionLibrary", "Authority_ClearPlayerGameplayModifier");

	Params::GameplayModifierFunctionLibrary_Authority_ClearPlayerGameplayModifier Parms{};

	Parms.targetPlayer = targetPlayer;
	Parms.modifierType = std::move(modifierType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierFunctionLibrary.Authority_SetPlayerGameplayFlag
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       targetPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              flagType                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierFunctionLibrary::Authority_SetPlayerGameplayFlag(class ADBDPlayer* targetPlayer, const struct FGameplayTag& flagType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayModifierFunctionLibrary", "Authority_SetPlayerGameplayFlag");

	Params::GameplayModifierFunctionLibrary_Authority_SetPlayerGameplayFlag Parms{};

	Parms.targetPlayer = targetPlayer;
	Parms.flagType = std::move(flagType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GameplayModifierFunctionLibrary.Authority_SetPlayerGameplayModifier
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       targetPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              modifierType                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   modifierValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayModifierFunctionLibrary::Authority_SetPlayerGameplayModifier(class ADBDPlayer* targetPlayer, const struct FGameplayTag& modifierType, float modifierValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayModifierFunctionLibrary", "Authority_SetPlayerGameplayModifier");

	Params::GameplayModifierFunctionLibrary_Authority_SetPlayerGameplayModifier Parms{};

	Parms.targetPlayer = targetPlayer;
	Parms.modifierType = std::move(modifierType);
	Parms.modifierValue = modifierValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.AddDamagingInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionDefinition*           interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::AddDamagingInteraction(class UInteractionDefinition* interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "AddDamagingInteraction");

	Params::Generator_AddDamagingInteraction Parms{};

	Parms.interaction = interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.AddPlayerStartTime
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   startTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::AddPlayerStartTime(class ADBDPlayer* player, float startTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "AddPlayerStartTime");

	Params::Generator_AddPlayerStartTime Parms{};

	Parms.player = player;
	Parms.startTime = startTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Authority_AddBlockingSource
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Authority_AddBlockingSource(const class UObject* source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_AddBlockingSource");

	Params::Generator_Authority_AddBlockingSource Parms{};

	Parms.source = source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Authority_AddTimedBlockingSource
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             blockingTime                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Authority_AddTimedBlockingSource(const class UObject* source, const float blockingTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_AddTimedBlockingSource");

	Params::Generator_Authority_AddTimedBlockingSource Parms{};

	Parms.source = source;
	Parms.blockingTime = blockingTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Authority_CancelRepairInteractions
// (Final, Native, Public, BlueprintCallable)

void AGenerator::Authority_CancelRepairInteractions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_CancelRepairInteractions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Authority_Damage
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       damagedBy                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             immediateRegressionPercent                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ignoreBlocked                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Authority_Damage(class ADBDPlayer* damagedBy, const float immediateRegressionPercent, bool ignoreBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_Damage");

	Params::Generator_Authority_Damage Parms{};

	Parms.damagedBy = damagedBy;
	Parms.immediateRegressionPercent = immediateRegressionPercent;
	Parms.ignoreBlocked = ignoreBlocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Authority_OnChargeApplied
// (Final, Native, Private)
// Parameters:
// float                                   individualChargeAmount                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   totalChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           chargeInstigator                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    wasCoop                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   deltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Authority_OnChargeApplied(float individualChargeAmount, float totalChargeAmount, class AActor* chargeInstigator, bool wasCoop, float deltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_OnChargeApplied");

	Params::Generator_Authority_OnChargeApplied Parms{};

	Parms.individualChargeAmount = individualChargeAmount;
	Parms.totalChargeAmount = totalChargeAmount;
	Parms.chargeInstigator = chargeInstigator;
	Parms.wasCoop = wasCoop;
	Parms.deltaTime = deltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Authority_OnChargeChanged
// (Final, Native, Private)
// Parameters:
// class UChargeableComponent*             chargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   percentCompletionChange                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   totalPercentComplete                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Authority_OnChargeChanged(class UChargeableComponent* chargeableComponent, float percentCompletionChange, float totalPercentComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_OnChargeChanged");

	Params::Generator_Authority_OnChargeChanged Parms{};

	Parms.chargeableComponent = chargeableComponent;
	Parms.percentCompletionChange = percentCompletionChange;
	Parms.totalPercentComplete = totalPercentComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Authority_RemoveBlockingSource
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Authority_RemoveBlockingSource(const class UObject* source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_RemoveBlockingSource");

	Params::Generator_Authority_RemoveBlockingSource Parms{};

	Parms.source = source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Authority_RepairDamage
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       repairedBy                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Authority_RepairDamage(class ADBDPlayer* repairedBy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_RepairDamage");

	Params::Generator_Authority_RepairDamage Parms{};

	Parms.repairedBy = repairedBy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Authority_SetRepaired
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              showGeneratorCloneLoudNoise                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              isAutoCompleted                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Authority_SetRepaired(const bool showGeneratorCloneLoudNoise, const bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_SetRepaired");

	Params::Generator_Authority_SetRepaired Parms{};

	Parms.showGeneratorCloneLoudNoise = showGeneratorCloneLoudNoise;
	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.BroadcastIsDamagedChangedEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::BroadcastIsDamagedChangedEvent(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "BroadcastIsDamagedChangedEvent");

	Params::Generator_BroadcastIsDamagedChangedEvent Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.DisableInaccessibleInteractors
// (Final, Native, Private)

void AGenerator::DisableInaccessibleInteractors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "DisableInaccessibleInteractors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.GetIsBlockedFromCharging
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGenerator::GetIsBlockedFromCharging()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetIsBlockedFromCharging");

	Params::Generator_GetIsBlockedFromCharging Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.Multicast_DamageCosmetic
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// bool                                    intense                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Multicast_DamageCosmetic(bool intense)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Multicast_DamageCosmetic");

	Params::Generator_Multicast_DamageCosmetic Parms{};

	Parms.intense = intense;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Multicast_OnRepaired
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const bool                              showGeneratorCloneLoudNoise                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              isAutoCompleted                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             updatedRemainingGeneratorCount                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Multicast_OnRepaired(const bool showGeneratorCloneLoudNoise, const bool isAutoCompleted, const int32 updatedRemainingGeneratorCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Multicast_OnRepaired");

	Params::Generator_Multicast_OnRepaired Parms{};

	Parms.showGeneratorCloneLoudNoise = showGeneratorCloneLoudNoise;
	Parms.isAutoCompleted = isAutoCompleted;
	Parms.updatedRemainingGeneratorCount = updatedRemainingGeneratorCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.Multicast_PlayFailSparksFX
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    explode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::Multicast_PlayFailSparksFX(class ADBDPlayer* player, bool explode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Multicast_PlayFailSparksFX");

	Params::Generator_Multicast_PlayFailSparksFX Parms{};

	Parms.player = player;
	Parms.explode = explode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.NotifyRepairFinish
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractor*                      interactor                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::NotifyRepairFinish(const class ADBDPlayer* player, class UInteractor* interactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "NotifyRepairFinish");

	Params::Generator_NotifyRepairFinish Parms{};

	Parms.player = player;
	Parms.interactor = interactor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.NotifyRepairStart
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::NotifyRepairStart(const class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "NotifyRepairStart");

	Params::Generator_NotifyRepairStart Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.OnBlockingStatusChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// const bool                              isBlocked                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::OnBlockingStatusChanged(const bool isBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnBlockingStatusChanged");

	Params::Generator_OnBlockingStatusChanged Parms{};

	Parms.isBlocked = isBlocked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.OnCaptureProbeSecondState
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AGenerator::OnCaptureProbeSecondState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnCaptureProbeSecondState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Generator.OnChargeApplied
// (Final, Native, Private)
// Parameters:
// float                                   individualChargeAmount                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   totalChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           chargeInstigator                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    wasCoop                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   deltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::OnChargeApplied(float individualChargeAmount, float totalChargeAmount, class AActor* chargeInstigator, bool wasCoop, float deltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnChargeApplied");

	Params::Generator_OnChargeApplied Parms{};

	Parms.individualChargeAmount = individualChargeAmount;
	Parms.totalChargeAmount = totalChargeAmount;
	Parms.chargeInstigator = chargeInstigator;
	Parms.wasCoop = wasCoop;
	Parms.deltaTime = deltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.OnChargeChanged
// (Final, Native, Private)
// Parameters:
// class UChargeableComponent*             chargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::OnChargeChanged(class UChargeableComponent* chargeableComponent, float percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnChargeChanged");

	Params::Generator_OnChargeChanged Parms{};

	Parms.chargeableComponent = chargeableComponent;
	Parms.percent = percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.OnDamageCosmetic
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    intense                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::OnDamageCosmetic(bool intense)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnDamageCosmetic");

	Params::Generator_OnDamageCosmetic Parms{};

	Parms.intense = intense;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.OnEscapeDoorActivated
// (Event, Protected, BlueprintEvent)

void AGenerator::OnEscapeDoorActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnEscapeDoorActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Generator.OnPreWarmASMCache
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AGenerator::OnPreWarmASMCache()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnPreWarmASMCache");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Generator.OnRep_DamageData
// (Final, Native, Private)

void AGenerator::OnRep_DamageData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnRep_DamageData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.OnRep_IsBlocked
// (Final, Native, Private)

void AGenerator::OnRep_IsBlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnRep_IsBlocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.OnRepairedBP
// (Event, Public, BlueprintEvent)
// Parameters:
// const bool                              showGeneratorCloneLoudNoise                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              isAutoCompleted                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::OnRepairedBP(const bool showGeneratorCloneLoudNoise, const bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnRepairedBP");

	Params::Generator_OnRepairedBP Parms{};

	Parms.showGeneratorCloneLoudNoise = showGeneratorCloneLoudNoise;
	Parms.isAutoCompleted = isAutoCompleted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.OnResetGenerator
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AGenerator::OnResetGenerator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnResetGenerator");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Generator.OnUpdateChargeProgress
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   newPercentComplete                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::OnUpdateChargeProgress(float newPercentComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "OnUpdateChargeProgress");

	Params::Generator_OnUpdateChargeProgress Parms{};

	Parms.newPercentComplete = newPercentComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.PlayFailSparksFX
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       interactingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    explode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::PlayFailSparksFX(class ADBDPlayer* interactingPlayer, bool explode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "PlayFailSparksFX");

	Params::Generator_PlayFailSparksFX Parms{};

	Parms.interactingPlayer = interactingPlayer;
	Parms.explode = explode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.PostAkEvent
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAkAudioEvent*                    AkEvent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CallbackMask                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>&PostEventCallback                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// const TArray<struct FAkExternalSourceInfo>&ExternalSources                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, AdvancedDisplay, NativeAccessSpecifierPublic)
// const class FString&                    in_EventName                                           (Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGenerator::PostAkEvent(class UAkAudioEvent* AkEvent, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, const TArray<struct FAkExternalSourceInfo>& ExternalSources, const class FString& in_EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "PostAkEvent");

	Params::Generator_PostAkEvent Parms{};

	Parms.AkEvent = AkEvent;
	Parms.CallbackMask = CallbackMask;
	Parms.PostEventCallback = PostEventCallback;
	Parms.ExternalSources = std::move(ExternalSources);
	Parms.in_EventName = std::move(in_EventName);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.RemovePlayerStartTime
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::RemovePlayerStartTime(const class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "RemovePlayerStartTime");

	Params::Generator_RemovePlayerStartTime Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.ResetGenerator
// (Final, Native, Public, BlueprintCallable)

void AGenerator::ResetGenerator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "ResetGenerator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.SetComplete
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    complete                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::SetComplete(bool complete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "SetComplete");

	Params::Generator_SetComplete Parms{};

	Parms.complete = complete;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.SetIsAutoCompleted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              isAutoCompleted                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::SetIsAutoCompleted(const bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "SetIsAutoCompleted");

	Params::Generator_SetIsAutoCompleted Parms{};

	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.SetIsBlockedFromCharging
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isBlockedFromCharging                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::SetIsBlockedFromCharging(bool isBlockedFromCharging)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "SetIsBlockedFromCharging");

	Params::Generator_SetIsBlockedFromCharging Parms{};

	Parms.isBlockedFromCharging = isBlockedFromCharging;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.SetIsOvercharged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              overcharged                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::SetIsOvercharged(const bool overcharged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "SetIsOvercharged");

	Params::Generator_SetIsOvercharged Parms{};

	Parms.overcharged = overcharged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.SpawnBloodEffectToSocket
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FName                       name                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::SpawnBloodEffectToSocket(const class FName name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "SpawnBloodEffectToSocket");

	Params::Generator_SpawnBloodEffectToSocket Parms{};

	Parms.name = name;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.TriggerSkillCheck
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       instigatingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::TriggerSkillCheck(class ADBDPlayer* instigatingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "TriggerSkillCheck");

	Params::Generator_TriggerSkillCheck Parms{};

	Parms.instigatingPlayer = instigatingPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.TriggerSkillCheckFailureLoudNoise
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       instigatingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::TriggerSkillCheckFailureLoudNoise(class ADBDPlayer* instigatingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "TriggerSkillCheckFailureLoudNoise");

	Params::Generator_TriggerSkillCheckFailureLoudNoise Parms{};

	Parms.instigatingPlayer = instigatingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.VFXClampTopActivationSingleLight
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             parameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::VFXClampTopActivationSingleLight(float distance, class FName parameterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "VFXClampTopActivationSingleLight");

	Params::Generator_VFXClampTopActivationSingleLight Parms{};

	Parms.distance = distance;
	Parms.parameterName = parameterName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.ActivateTeleportGeneratorIndicator
// (Event, Public, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// bool                                    activate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::ActivateTeleportGeneratorIndicator(bool activate) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "ActivateTeleportGeneratorIndicator");

	Params::Generator_ActivateTeleportGeneratorIndicator Parms{};

	Parms.activate = activate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Generator.Authority_GetRepairingCampers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ADBDPlayer*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDPlayer*> AGenerator::Authority_GetRepairingCampers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_GetRepairingCampers");

	Params::Generator_Authority_GetRepairingCampers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.Authority_HasRepairedDamage
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGenerator::Authority_HasRepairedDamage(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "Authority_HasRepairedDamage");

	Params::Generator_Authority_HasRepairedDamage Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.BroadcastGeneratorRepairedBySurvivor
// (Final, Native, Protected, BlueprintCallable, Const)
// Parameters:
// class ADBDPlayer*                       repairingSurvivor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGenerator::BroadcastGeneratorRepairedBySurvivor(class ADBDPlayer* repairingSurvivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "BroadcastGeneratorRepairedBySurvivor");

	Params::Generator_BroadcastGeneratorRepairedBySurvivor Parms{};

	Parms.repairingSurvivor = repairingSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Generator.CanSurvivorReactToBlockingEntity
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ACamperPlayer*              survivor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGenerator::CanSurvivorReactToBlockingEntity(const class ACamperPlayer* survivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "CanSurvivorReactToBlockingEntity");

	Params::Generator_CanSurvivorReactToBlockingEntity Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.GetChargePercentComplete
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGenerator::GetChargePercentComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetChargePercentComplete");

	Params::Generator_GetChargePercentComplete Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.GetGeneratorChargeComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UChargeableComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableComponent* AGenerator::GetGeneratorChargeComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetGeneratorChargeComponent");

	Params::Generator_GetGeneratorChargeComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.GetIsAutoCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGenerator::GetIsAutoCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetIsAutoCompleted");

	Params::Generator_GetIsAutoCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.GetPlayerStartTime
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGenerator::GetPlayerStartTime(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetPlayerStartTime");

	Params::Generator_GetPlayerStartTime Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.GetPlayerStartTimes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FPlayerFloatTuple>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FPlayerFloatTuple> AGenerator::GetPlayerStartTimes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetPlayerStartTimes");

	Params::Generator_GetPlayerStartTimes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.GetRepairers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ADBDPlayer*>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDPlayer*> AGenerator::GetRepairers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetRepairers");

	Params::Generator_GetRepairers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.GetRepairPercentComplete
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AGenerator::GetRepairPercentComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetRepairPercentComplete");

	Params::Generator_GetRepairPercentComplete Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.GetSkeletalMesh
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AGenerator::GetSkeletalMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "GetSkeletalMesh");

	Params::Generator_GetSkeletalMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.IsBeingDamagedByKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGenerator::IsBeingDamagedByKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "IsBeingDamagedByKiller");

	Params::Generator_IsBeingDamagedByKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.IsBeingRepaired
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGenerator::IsBeingRepaired() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "IsBeingRepaired");

	Params::Generator_IsBeingRepaired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.IsBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGenerator::IsBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "IsBlocked");

	Params::Generator_IsBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.IsIntenseDamage
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGenerator::IsIntenseDamage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "IsIntenseDamage");

	Params::Generator_IsIntenseDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.IsRegressing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGenerator::IsRegressing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "IsRegressing");

	Params::Generator_IsRegressing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Generator.ShouldDoOverchargeSkillcheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGenerator::ShouldDoOverchargeSkillcheck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Generator", "ShouldDoOverchargeSkillcheck");

	Params::Generator_ShouldDoOverchargeSkillcheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.DBDGeneratorDrivenReflectionCaptureActor.SwapToSecondState
// (Final, Native, Public, BlueprintCallable)

void ADBDGeneratorDrivenReflectionCaptureActor::SwapToSecondState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDGeneratorDrivenReflectionCaptureActor", "SwapToSecondState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorEntity.PlayMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// float                                   playRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isFollower                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorEntity::PlayMontage(const struct FAnimationMontageDescriptor& animMontageID, float playRate, bool isFollower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorEntity", "PlayMontage");

	Params::GeneratorEntity_PlayMontage Parms{};

	Parms.animMontageID = std::move(animMontageID);
	Parms.playRate = playRate;
	Parms.isFollower = isFollower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorEntity.SetAssociatedGenerator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGenerator*                       generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorEntity::SetAssociatedGenerator(class AGenerator* generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorEntity", "SetAssociatedGenerator");

	Params::GeneratorEntity_SetAssociatedGenerator Parms{};

	Parms.generator = generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorEntity.SetSkeletalMeshActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGeneratorEntity::SetSkeletalMeshActive(bool active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorEntity", "SetSkeletalMeshActive");

	Params::GeneratorEntity_SetSkeletalMeshActive Parms{};

	Parms.active = active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorEntity.GetMontagePlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMontagePlayer*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMontagePlayer* AGeneratorEntity::GetMontagePlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorEntity", "GetMontagePlayer");

	Params::GeneratorEntity_GetMontagePlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorOutlineUpdateStrategy.GetWhiteColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UGeneratorOutlineUpdateStrategy::GetWhiteColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorOutlineUpdateStrategy", "GetWhiteColor");

	Params::GeneratorOutlineUpdateStrategy_GetWhiteColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorOutlineUpdateStrategy.GetYellowColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UGeneratorOutlineUpdateStrategy::GetYellowColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorOutlineUpdateStrategy", "GetYellowColor");

	Params::GeneratorOutlineUpdateStrategy_GetYellowColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorTrappableComponent.GetHasAnyTrap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGeneratorTrappableComponent::GetHasAnyTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrappableComponent", "GetHasAnyTrap");

	Params::GeneratorTrappableComponent_GetHasAnyTrap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorTrappableComponent.GetHasTrap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const EGeneratorTrapType                trapType                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGeneratorTrappableComponent::GetHasTrap(const EGeneratorTrapType trapType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrappableComponent", "GetHasTrap");

	Params::GeneratorTrappableComponent_GetHasTrap Parms{};

	Parms.trapType = trapType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorTrappableComponent.OnRep_TrapsOnGenerator
// (Final, Native, Private)

void UGeneratorTrappableComponent::OnRep_TrapsOnGenerator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrappableComponent", "OnRep_TrapsOnGenerator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorTrapPerk.Authority_OnExitGatesPowered
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventTag                                           (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGeneratorTrapPerk::Authority_OnExitGatesPowered(const struct FGameplayTag& gameEventTag, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "Authority_OnExitGatesPowered");

	Params::GeneratorTrapPerk_Authority_OnExitGatesPowered Parms{};

	Parms.gameEventTag = std::move(gameEventTag);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorTrapPerk.Authority_OnGeneratorCompleted
// (Final, Native, Private)
// Parameters:
// bool                                    isAutoCompleted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTrapPerk::Authority_OnGeneratorCompleted(bool isAutoCompleted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "Authority_OnGeneratorCompleted");

	Params::GeneratorTrapPerk_Authority_OnGeneratorCompleted Parms{};

	Parms.isAutoCompleted = isAutoCompleted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorTrapPerk.Authority_OnRepairProgress
// (Final, Native, Private)
// Parameters:
// float                                   individualChargeAmount                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   totalChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           chargeInstigator                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    wasCoop                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   deltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTrapPerk::Authority_OnRepairProgress(float individualChargeAmount, float totalChargeAmount, class AActor* chargeInstigator, bool wasCoop, float deltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "Authority_OnRepairProgress");

	Params::GeneratorTrapPerk_Authority_OnRepairProgress Parms{};

	Parms.individualChargeAmount = individualChargeAmount;
	Parms.totalChargeAmount = totalChargeAmount;
	Parms.chargeInstigator = chargeInstigator;
	Parms.wasCoop = wasCoop;
	Parms.deltaTime = deltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorTrapPerk.Authority_OnTrapDamaged
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventTag                                           (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGeneratorTrapPerk::Authority_OnTrapDamaged(const struct FGameplayTag& gameEventTag, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "Authority_OnTrapDamaged");

	Params::GeneratorTrapPerk_Authority_OnTrapDamaged Parms{};

	Parms.gameEventTag = std::move(gameEventTag);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorTrapPerk.Client_OnTrapActivated
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// const class AGenerator*                 generator                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTrapPerk::Client_OnTrapActivated(const class AGenerator* generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "Client_OnTrapActivated");

	Params::GeneratorTrapPerk_Client_OnTrapActivated Parms{};

	Parms.generator = generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorTrapPerk.Client_OnTrapDestroyed
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// const class AGenerator*                 generator                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ETrapRemovedReason                reason                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTrapPerk::Client_OnTrapDestroyed(const class AGenerator* generator, const ETrapRemovedReason reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "Client_OnTrapDestroyed");

	Params::GeneratorTrapPerk_Client_OnTrapDestroyed Parms{};

	Parms.generator = generator;
	Parms.reason = reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorTrapPerk.Local_TrapActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class AGenerator*                 generator                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTrapPerk::Local_TrapActivated(const class AGenerator* generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "Local_TrapActivated");

	Params::GeneratorTrapPerk_Local_TrapActivated Parms{};

	Parms.generator = generator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.GeneratorTrapPerk.Local_TrapDestroyed
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class AGenerator*                 generator                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ETrapRemovedReason                reason                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTrapPerk::Local_TrapDestroyed(const class AGenerator* generator, const ETrapRemovedReason reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "Local_TrapDestroyed");

	Params::GeneratorTrapPerk_Local_TrapDestroyed Parms{};

	Parms.generator = generator;
	Parms.reason = reason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.GeneratorTrapPerk.OnRep_CurrentRepairInteractionWithAbility
// (Final, Native, Private)
// Parameters:
// class UInteractionDefinition*           oldRepairInteraction                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTrapPerk::OnRep_CurrentRepairInteractionWithAbility(class UInteractionDefinition* oldRepairInteraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "OnRep_CurrentRepairInteractionWithAbility");

	Params::GeneratorTrapPerk_OnRep_CurrentRepairInteractionWithAbility Parms{};

	Parms.oldRepairInteraction = oldRepairInteraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorTrapPerk.OnRep_TrappedGenerator
// (Final, Native, Protected)
// Parameters:
// class AGenerator*                       oldGenerator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorTrapPerk::OnRep_TrappedGenerator(class AGenerator* oldGenerator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "OnRep_TrappedGenerator");

	Params::GeneratorTrapPerk_OnRep_TrappedGenerator Parms{};

	Parms.oldGenerator = oldGenerator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorTrapPerk.Server_TryTriggerAction
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UGeneratorTrapPerk::Server_TryTriggerAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "Server_TryTriggerAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.GeneratorTrapPerk.GetGeneratorTrapDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGeneratorTrapPerk::GetGeneratorTrapDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "GetGeneratorTrapDuration");

	Params::GeneratorTrapPerk_GetGeneratorTrapDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorTrapPerk.GetRepairProgressPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGeneratorTrapPerk::GetRepairProgressPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "GetRepairProgressPercent");

	Params::GeneratorTrapPerk_GetRepairProgressPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorTrapPerk.GetRequiredRepairProgressForSettingTrap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGeneratorTrapPerk::GetRequiredRepairProgressForSettingTrap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "GetRequiredRepairProgressForSettingTrap");

	Params::GeneratorTrapPerk_GetRequiredRepairProgressForSettingTrap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.GeneratorTrapPerk.GetSecondsToActivatePerk
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGeneratorTrapPerk::GetSecondsToActivatePerk() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorTrapPerk", "GetSecondsToActivatePerk");

	Params::GeneratorTrapPerk_GetSecondsToActivatePerk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HalloweenEventComponent.OnFinishedPlaying
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UHalloweenEventComponent::OnFinishedPlaying(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HalloweenEventComponent", "OnFinishedPlaying");

	Params::HalloweenEventComponent_OnFinishedPlaying Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HalloweenEventComponent.OnRep_Vial
// (Final, Native, Private)

void UHalloweenEventComponent::OnRep_Vial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HalloweenEventComponent", "OnRep_Vial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HalloweenEventComponent.Server_SpawnVial
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// float                                   initialCharge                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHalloweenEventComponent::Server_SpawnVial(float initialCharge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HalloweenEventComponent", "Server_SpawnVial");

	Params::HalloweenEventComponent_Server_SpawnVial Parms{};

	Parms.initialCharge = initialCharge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HalloweenEventComponent.GetVial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USectionnedChargeableComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USectionnedChargeableComponent* UHalloweenEventComponent::GetVial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HalloweenEventComponent", "GetVial");

	Params::HalloweenEventComponent_GetVial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HalloweenEventComponent.IsVialFull
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHalloweenEventComponent::IsVialFull() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HalloweenEventComponent", "IsVialFull");

	Params::HalloweenEventComponent_IsVialFull Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Hatch.Authority_CheckedChangeActiveState
// (Final, Native, Private)

void AHatch::Authority_CheckedChangeActiveState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_CheckedChangeActiveState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_CheckedCloseHatch
// (Final, Native, Private)

void AHatch::Authority_CheckedCloseHatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_CheckedCloseHatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_CheckedOpenForceClosedHatch
// (Final, Native, Private)

void AHatch::Authority_CheckedOpenForceClosedHatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_CheckedOpenForceClosedHatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_CheckedOpenHatch
// (Final, Native, Private)

void AHatch::Authority_CheckedOpenHatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_CheckedOpenHatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_OnCloseTimerComplete
// (Final, Native, Private)

void AHatch::Authority_OnCloseTimerComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_OnCloseTimerComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_OnEndGameOver
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AHatch::Authority_OnEndGameOver(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_OnEndGameOver");

	Params::Hatch_Authority_OnEndGameOver Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_OnHatchVisibilityChanged
// (Final, Native, Private)
// Parameters:
// bool                                    isVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHatch::Authority_OnHatchVisibilityChanged(bool isVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_OnHatchVisibilityChanged");

	Params::Hatch_Authority_OnHatchVisibilityChanged Parms{};

	Parms.isVisible = isVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_OnSurvivorsLeftChanged
// (Final, Native, Private)
// Parameters:
// int32                                   survivorRemaining                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHatch::Authority_OnSurvivorsLeftChanged(int32 survivorRemaining)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_OnSurvivorsLeftChanged");

	Params::Hatch_Authority_OnSurvivorsLeftChanged Parms{};

	Parms.survivorRemaining = survivorRemaining;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_ResetTimer
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHatch::Authority_ResetTimer(float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_ResetTimer");

	Params::Hatch_Authority_ResetTimer Parms{};

	Parms.duration = duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_SetHatchState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EHatchState                             newState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHatch::Authority_SetHatchState(EHatchState newState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_SetHatchState");

	Params::Hatch_Authority_SetHatchState Parms{};

	Parms.newState = newState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.Authority_SetIsForceOpen
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isForcedOpen                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHatch::Authority_SetIsForceOpen(bool isForcedOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "Authority_SetIsForceOpen");

	Params::Hatch_Authority_SetIsForceOpen Parms{};

	Parms.isForcedOpen = isForcedOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.FXCloseHatch
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AHatch::FXCloseHatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "FXCloseHatch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Hatch.FXEndSmoke
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AHatch::FXEndSmoke()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "FXEndSmoke");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Hatch.FXOpenHatch
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AHatch::FXOpenHatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "FXOpenHatch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Hatch.OnHatchStateModified
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// EHatchState                             oldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHatchState                             newState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHatch::OnHatchStateModified(EHatchState oldState, EHatchState newState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "OnHatchStateModified");

	Params::Hatch_OnHatchStateModified Parms{};

	Parms.oldState = oldState;
	Parms.newState = newState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Hatch.OnHatchStateUnhidden
// (Final, Native, Private)

void AHatch::OnHatchStateUnhidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "OnHatchStateUnhidden");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.OnRep_HatchState
// (Final, Native, Private)
// Parameters:
// EHatchState                             oldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHatch::OnRep_HatchState(EHatchState oldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "OnRep_HatchState");

	Params::Hatch_OnRep_HatchState Parms{};

	Parms.oldState = oldState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Hatch.GetAnimationMontageSlave
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UAnimationMontageSlave*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimationMontageSlave* AHatch::GetAnimationMontageSlave() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "GetAnimationMontageSlave");

	Params::Hatch_GetAnimationMontageSlave Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Hatch.GetEscapeFocalPoint
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AHatch::GetEscapeFocalPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "GetEscapeFocalPoint");

	Params::Hatch_GetEscapeFocalPoint Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Hatch.GetHatchCenter
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AHatch::GetHatchCenter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "GetHatchCenter");

	Params::Hatch_GetHatchCenter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Hatch.GetHatchState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EHatchState                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHatchState AHatch::GetHatchState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "GetHatchState");

	Params::Hatch_GetHatchState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Hatch.IsOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHatch::IsOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Hatch", "IsOpen");

	Params::Hatch_IsOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HitValidationConfigsComponent.DBD_PrintInGameHitValidationConfigs
// (Final, Exec, Native, Public)

void UHitValidationConfigsComponent::DBD_PrintInGameHitValidationConfigs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitValidationConfigsComponent", "DBD_PrintInGameHitValidationConfigs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HookAntiCampingComponent.OnRep_UnhookingSelfAllowedDuringStrugglePhase
// (Final, Native, Private)

void UHookAntiCampingComponent::OnRep_UnhookingSelfAllowedDuringStrugglePhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookAntiCampingComponent", "OnRep_UnhookingSelfAllowedDuringStrugglePhase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.HookAntiCampingComponent.CanUnhookWithAutoSuccess
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHookAntiCampingComponent::CanUnhookWithAutoSuccess() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookAntiCampingComponent", "CanUnhookWithAutoSuccess");

	Params::HookAntiCampingComponent_CanUnhookWithAutoSuccess Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HookAntiCampingComponent.GetCampTimerCompletionPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHookAntiCampingComponent::GetCampTimerCompletionPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookAntiCampingComponent", "GetCampTimerCompletionPercent");

	Params::HookAntiCampingComponent_GetCampTimerCompletionPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.HookAntiCampingComponent.GetCurrentChargeSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHookAntiCampingComponent::GetCurrentChargeSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HookAntiCampingComponent", "GetCurrentChargeSpeed");

	Params::HookAntiCampingComponent_GetCurrentChargeSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InfectedInteractableComponent.Authority_OnHitWithVomit
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UInfectedInteractableComponent::Authority_OnHitWithVomit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "Authority_OnHitWithVomit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InfectedInteractableComponent.Authority_OnOwningInteractableBeginOrEndUse
// (Final, Native, Public)
// Parameters:
// bool                                    inUse                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interactingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInfectedInteractableComponent::Authority_OnOwningInteractableBeginOrEndUse(bool inUse, class ADBDPlayer* interactingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "Authority_OnOwningInteractableBeginOrEndUse");

	Params::InfectedInteractableComponent_Authority_OnOwningInteractableBeginOrEndUse Parms{};

	Parms.inUse = inUse;
	Parms.interactingPlayer = interactingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InfectedInteractableComponent.Multicast_DebugDisplayLifetime
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// float                                   remainingLifetime                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInfectedInteractableComponent::Multicast_DebugDisplayLifetime(float remainingLifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "Multicast_DebugDisplayLifetime");

	Params::InfectedInteractableComponent_Multicast_DebugDisplayLifetime Parms{};

	Parms.remainingLifetime = remainingLifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InfectedInteractableComponent.Multicast_DestroyComponent
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UInfectedInteractableComponent::Multicast_DestroyComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "Multicast_DestroyComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InfectedInteractableComponent.Multicast_FadeInVomit
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UInfectedInteractableComponent::Multicast_FadeInVomit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "Multicast_FadeInVomit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InfectedInteractableComponent.Multicast_FadeOutVomit
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UInfectedInteractableComponent::Multicast_FadeOutVomit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "Multicast_FadeOutVomit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InfectedInteractableComponent.OnVomitAlphaUpdate
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInfectedInteractableComponent::OnVomitAlphaUpdate(float alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "OnVomitAlphaUpdate");

	Params::InfectedInteractableComponent_OnVomitAlphaUpdate Parms{};

	Parms.alpha = alpha;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InfectedInteractableComponent.SetInteractableMeshAlpha
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInfectedInteractableComponent::SetInteractableMeshAlpha(float alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "SetInteractableMeshAlpha");

	Params::InfectedInteractableComponent_SetInteractableMeshAlpha Parms{};

	Parms.alpha = alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InfectedInteractableComponent.Authority_GetEquippingPlayer
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACamperPlayer*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACamperPlayer* UInfectedInteractableComponent::Authority_GetEquippingPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "Authority_GetEquippingPlayer");

	Params::InfectedInteractableComponent_Authority_GetEquippingPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InfectedInteractableComponent.Authority_IsAMaxSicknessSurvivorInteracting
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInfectedInteractableComponent::Authority_IsAMaxSicknessSurvivorInteracting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "Authority_IsAMaxSicknessSurvivorInteracting");

	Params::InfectedInteractableComponent_Authority_IsAMaxSicknessSurvivorInteracting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InfectedInteractableComponent.GetOwningInteractable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInteractable*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractable* UInfectedInteractableComponent::GetOwningInteractable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InfectedInteractableComponent", "GetOwningInteractable");

	Params::InfectedInteractableComponent_GetOwningInteractable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InteractionDetectorComponent.AddIgnoredActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ignored                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDetectorComponent::AddIgnoredActor(class AActor* ignored)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDetectorComponent", "AddIgnoredActor");

	Params::InteractionDetectorComponent_AddIgnoredActor Parms{};

	Parms.ignored = ignored;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDetectorComponent.BeginOverlapCallback
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              hitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           otherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              otherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   otherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    fromSweep                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                sweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UInteractionDetectorComponent::BeginOverlapCallback(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool fromSweep, const struct FHitResult& sweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDetectorComponent", "BeginOverlapCallback");

	Params::InteractionDetectorComponent_BeginOverlapCallback Parms{};

	Parms.hitComponent = hitComponent;
	Parms.otherActor = otherActor;
	Parms.otherComp = otherComp;
	Parms.otherBodyIndex = otherBodyIndex;
	Parms.fromSweep = fromSweep;
	Parms.sweepResult = std::move(sweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDetectorComponent.EndOverlapCallback
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              hitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           otherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              otherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   otherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDetectorComponent::EndOverlapCallback(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDetectorComponent", "EndOverlapCallback");

	Params::InteractionDetectorComponent_EndOverlapCallback Parms{};

	Parms.hitComponent = hitComponent;
	Parms.otherActor = otherActor;
	Parms.otherComp = otherComp;
	Parms.otherBodyIndex = otherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDetectorComponent.OnLocallyObservedChanged
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDetectorComponent::OnLocallyObservedChanged(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDetectorComponent", "OnLocallyObservedChanged");

	Params::InteractionDetectorComponent_OnLocallyObservedChanged Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDetectorComponent.SetDetectionPrimitive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              detectionPrimitive                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionDetectorComponent::SetDetectionPrimitive(class UPrimitiveComponent* detectionPrimitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDetectorComponent", "SetDetectionPrimitive");

	Params::InteractionDetectorComponent_SetDetectionPrimitive Parms{};

	Parms.detectionPrimitive = detectionPrimitive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InteractionDetectorComponent.GetDetectionPrimitive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* UInteractionDetectorComponent::GetDetectionPrimitive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionDetectorComponent", "GetDetectionPrimitive");

	Params::InteractionDetectorComponent_GetDetectionPrimitive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.OnInterruptionEnterStart
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       interruptor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptee                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterruptionDefinition::OnInterruptionEnterStart(class ADBDPlayer* interruptor, class ADBDPlayer* interruptee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "OnInterruptionEnterStart");

	Params::InterruptionDefinition_OnInterruptionEnterStart Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InterruptionDefinition.OnInterruptionExitEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       interruptor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptee                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterruptionDefinition::OnInterruptionExitEnd(class ADBDPlayer* interruptor, class ADBDPlayer* interruptee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "OnInterruptionExitEnd");

	Params::InterruptionDefinition_OnInterruptionExitEnd Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InterruptionDefinition.OnInterruptionUpdateStart
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       interruptor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       interruptee                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInterruptionDefinition::OnInterruptionUpdateStart(class ADBDPlayer* interruptor, class ADBDPlayer* interruptee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "OnInterruptionUpdateStart");

	Params::InterruptionDefinition_OnInterruptionUpdateStart Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.InterruptionDefinition.SetInterruptorSnapPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTransform&                Point                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UInterruptionDefinition::SetInterruptorSnapPoint(const struct FTransform& Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "SetInterruptorSnapPoint");

	Params::InterruptionDefinition_SetInterruptorSnapPoint Parms{};

	Parms.Point = std::move(Point);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.InterruptionDefinition.CanInterruptWhileCarrying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInterruptionDefinition::CanInterruptWhileCarrying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "CanInterruptWhileCarrying");

	Params::InterruptionDefinition_CanInterruptWhileCarrying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.GetInteractable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInteractable*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInteractable* UInterruptionDefinition::GetInteractable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "GetInteractable");

	Params::InterruptionDefinition_GetInteractable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.GetInteractionDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UInterruptionDefinition::GetInteractionDefinition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "GetInteractionDefinition");

	Params::InterruptionDefinition_GetInteractionDefinition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.GetInterruptionSnapPointPositionForInterruptor
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Interruptor                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 Interruptee                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UInterruptionDefinition::GetInterruptionSnapPointPositionForInterruptor(const class ADBDPlayer* Interruptor, const class ADBDPlayer* Interruptee) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "GetInterruptionSnapPointPositionForInterruptor");

	Params::InterruptionDefinition_GetInterruptionSnapPointPositionForInterruptor Parms{};

	Parms.Interruptor = Interruptor;
	Parms.Interruptee = Interruptee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.GetInterruptionSnapPointRotationForInterruptor
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 Interruptor                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 Interruptee                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UInterruptionDefinition::GetInterruptionSnapPointRotationForInterruptor(const class ADBDPlayer* Interruptor, const class ADBDPlayer* Interruptee) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "GetInterruptionSnapPointRotationForInterruptor");

	Params::InterruptionDefinition_GetInterruptionSnapPointRotationForInterruptor Parms{};

	Parms.Interruptor = Interruptor;
	Parms.Interruptee = Interruptee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.InteractionCheckHeightDelta
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 interruptor                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 interruptee                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInterruptionDefinition::InteractionCheckHeightDelta(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "InteractionCheckHeightDelta");

	Params::InterruptionDefinition_InteractionCheckHeightDelta Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.IsInterruptionPossible
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ADBDPlayer*                 interruptor                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 interruptee                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInterruptionDefinition::IsInterruptionPossible(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "IsInterruptionPossible");

	Params::InterruptionDefinition_IsInterruptionPossible Parms{};

	Parms.interruptor = interruptor;
	Parms.interruptee = interruptee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.IsUsingAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInterruptionDefinition::IsUsingAttack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "IsUsingAttack");

	Params::InterruptionDefinition_IsUsingAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.InterruptionDefinition.IsUsingMontageFollower
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInterruptionDefinition::IsUsingMontageFollower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InterruptionDefinition", "IsUsingMontageFollower");

	Params::InterruptionDefinition_IsUsingMontageFollower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ItemPerformedInteraction.IsInteractionPerformedWithItem
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IItemPerformedInteraction::IsInteractionPerformedWithItem(class ADBDPlayer* instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ItemPerformedInteraction", "IsInteractionPerformedWithItem");

	Params::ItemPerformedInteraction_IsInteractionPerformedWithItem Parms{};

	Parms.instigator = instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ItemVfx.AddNiagaraComponent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UNiagaraComponent*                niagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemVfx::AddNiagaraComponent(class UNiagaraComponent* niagaraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemVfx", "AddNiagaraComponent");

	Params::ItemVfx_AddNiagaraComponent Parms{};

	Parms.niagaraComponent = niagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemVfx.AddParticleSystemComponent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UParticleSystemComponent*         particleSystemComponent                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemVfx::AddParticleSystemComponent(class UParticleSystemComponent* particleSystemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemVfx", "AddParticleSystemComponent");

	Params::ItemVfx_AddParticleSystemComponent Parms{};

	Parms.particleSystemComponent = particleSystemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemVfx.AttachToSkeletalMesh
// (Event, Public, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           SkeletonPart                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemVfx::AttachToSkeletalMesh(class USkeletalMeshComponent* SkeletonPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemVfx", "AttachToSkeletalMesh");

	Params::ItemVfx_AttachToSkeletalMesh Parms{};

	Parms.SkeletonPart = SkeletonPart;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ItemVfx.ClearParticleSystems
// (Final, Native, Public, BlueprintCallable)

void AItemVfx::ClearParticleSystems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemVfx", "ClearParticleSystems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ItemVfx.OnAttackBegin
// (Event, Public, BlueprintEvent)

void AItemVfx::OnAttackBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemVfx", "OnAttackBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ItemVfx.OnAttackEnd
// (Event, Public, BlueprintEvent)

void AItemVfx::OnAttackEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemVfx", "OnAttackEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ItemVfx.SpawnNiagaraSystemAttached
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UNiagaraSystem*                   systemTemplate                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  attachToComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             attachPointName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttachLocation                         locationType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    autoDestroy                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENCPoolMethod                           poolingMethod                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   scale                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    autoActivate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    preCullCheck                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    absoluteRotation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    hideInFPV                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraComponent* AItemVfx::SpawnNiagaraSystemAttached(class UNiagaraSystem* systemTemplate, class USceneComponent* attachToComponent, class FName attachPointName, EAttachLocation locationType, bool autoDestroy, ENCPoolMethod poolingMethod, const struct FVector& location, const struct FRotator& rotation, const struct FVector& scale, bool autoActivate, bool preCullCheck, bool absoluteRotation, bool hideInFPV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemVfx", "SpawnNiagaraSystemAttached");

	Params::ItemVfx_SpawnNiagaraSystemAttached Parms{};

	Parms.systemTemplate = systemTemplate;
	Parms.attachToComponent = attachToComponent;
	Parms.attachPointName = attachPointName;
	Parms.locationType = locationType;
	Parms.autoDestroy = autoDestroy;
	Parms.poolingMethod = poolingMethod;
	Parms.location = std::move(location);
	Parms.rotation = std::move(rotation);
	Parms.scale = std::move(scale);
	Parms.autoActivate = autoActivate;
	Parms.preCullCheck = preCullCheck;
	Parms.absoluteRotation = absoluteRotation;
	Parms.hideInFPV = hideInFPV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.KillerAtlantaTutorialLevel.CompleteEscapeRequirements
// (Final, Native, Public, BlueprintCallable)

void AKillerAtlantaTutorialLevel::CompleteEscapeRequirements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAtlantaTutorialLevel", "CompleteEscapeRequirements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerAtlantaTutorialLevel.SetBearTrapSurvivor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    camperPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKillerAtlantaTutorialLevel::SetBearTrapSurvivor(class ACamperPlayer* camperPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAtlantaTutorialLevel", "SetBearTrapSurvivor");

	Params::KillerAtlantaTutorialLevel_SetBearTrapSurvivor Parms{};

	Parms.camperPlayer = camperPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerAtlantaTutorialLevel.SetChaseSurvivor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    camperPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKillerAtlantaTutorialLevel::SetChaseSurvivor(class ACamperPlayer* camperPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAtlantaTutorialLevel", "SetChaseSurvivor");

	Params::KillerAtlantaTutorialLevel_SetChaseSurvivor Parms{};

	Parms.camperPlayer = camperPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerAtlantaTutorialLevel.SetControlledSlasherPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASlasherPlayer*                   slasherPlayer                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKillerAtlantaTutorialLevel::SetControlledSlasherPlayer(class ASlasherPlayer* slasherPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAtlantaTutorialLevel", "SetControlledSlasherPlayer");

	Params::KillerAtlantaTutorialLevel_SetControlledSlasherPlayer Parms{};

	Parms.slasherPlayer = slasherPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerAtlantaTutorialLevel.SetEscapeDoor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEscapeDoor*                      targetEscapeDoor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKillerAtlantaTutorialLevel::SetEscapeDoor(class AEscapeDoor* targetEscapeDoor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAtlantaTutorialLevel", "SetEscapeDoor");

	Params::KillerAtlantaTutorialLevel_SetEscapeDoor Parms{};

	Parms.targetEscapeDoor = targetEscapeDoor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerAtlantaTutorialLevel.SetGenerator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGenerator*                       generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKillerAtlantaTutorialLevel::SetGenerator(class AGenerator* generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAtlantaTutorialLevel", "SetGenerator");

	Params::KillerAtlantaTutorialLevel_SetGenerator Parms{};

	Parms.generator = generator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerAtlantaTutorialLevel.SetHatch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHatch*                           targetHatch                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKillerAtlantaTutorialLevel::SetHatch(class AHatch* targetHatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAtlantaTutorialLevel", "SetHatch");

	Params::KillerAtlantaTutorialLevel_SetHatch Parms{};

	Parms.targetHatch = targetHatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerAtlantaTutorialLevel.SetupEndGameTutorialPhase
// (Event, Public, BlueprintEvent)

void AKillerAtlantaTutorialLevel::SetupEndGameTutorialPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAtlantaTutorialLevel", "SetupEndGameTutorialPhase");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.KillerAtlantaTutorialLevel.SetVaultWindow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AWindow*                          window                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKillerAtlantaTutorialLevel::SetVaultWindow(class AWindow* window)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAtlantaTutorialLevel", "SetVaultWindow");

	Params::KillerAtlantaTutorialLevel_SetVaultWindow Parms{};

	Parms.window = window;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerAtlantaTutorialLevel.TriggerEndGameSequenceAnimation
// (Event, Public, BlueprintEvent)
// Parameters:
// EKillerTutorialEndGameType              camperDeathType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKillerAtlantaTutorialLevel::TriggerEndGameSequenceAnimation(EKillerTutorialEndGameType camperDeathType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAtlantaTutorialLevel", "TriggerEndGameSequenceAnimation");

	Params::KillerAtlantaTutorialLevel_TriggerEndGameSequenceAnimation Parms{};

	Parms.camperDeathType = camperDeathType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.KillerAtlantaTutorialLevel.TriggerExitGameSetup
// (Event, Public, BlueprintEvent)

void AKillerAtlantaTutorialLevel::TriggerExitGameSetup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAtlantaTutorialLevel", "TriggerExitGameSetup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.KillerAudioHandlerComponent.ChaseTriggerKillerReactionSpecificSurvivorSFX
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       camper                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerAudioHandlerComponent::ChaseTriggerKillerReactionSpecificSurvivorSFX(class ADBDPlayer* camper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAudioHandlerComponent", "ChaseTriggerKillerReactionSpecificSurvivorSFX");

	Params::KillerAudioHandlerComponent_ChaseTriggerKillerReactionSpecificSurvivorSFX Parms{};

	Parms.camper = camper;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.KillerAudioHandlerComponent.HitImpactOnSurvivorSFX
// (BlueprintCosmetic, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACamperPlayer*                    camper                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttackType                             attackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isWeaponHit                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerAudioHandlerComponent::HitImpactOnSurvivorSFX(class ACamperPlayer* camper, EAttackType attackType, bool isWeaponHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAudioHandlerComponent", "HitImpactOnSurvivorSFX");

	Params::KillerAudioHandlerComponent_HitImpactOnSurvivorSFX Parms{};

	Parms.camper = camper;
	Parms.attackType = attackType;
	Parms.isWeaponHit = isWeaponHit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.KillerAudioHandlerComponent.OnChaseStart
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       chasedSurvivor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerAudioHandlerComponent::OnChaseStart(class ADBDPlayer* chasedSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAudioHandlerComponent", "OnChaseStart");

	Params::KillerAudioHandlerComponent_OnChaseStart Parms{};

	Parms.chasedSurvivor = chasedSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerAudioHandlerComponent.TriggerKillerReactionSpecificSurvivorSFX
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       camper                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerAudioHandlerComponent::TriggerKillerReactionSpecificSurvivorSFX(class ADBDPlayer* camper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAudioHandlerComponent", "TriggerKillerReactionSpecificSurvivorSFX");

	Params::KillerAudioHandlerComponent_TriggerKillerReactionSpecificSurvivorSFX Parms{};

	Parms.camper = camper;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.KillerAudioHandlerComponent.TriggerSurvivorDamageHitAudioSFX
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACamperPlayer*                    camper                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttackType                             attackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    causedKO                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isWeaponHit                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isLightHit                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerAudioHandlerComponent::TriggerSurvivorDamageHitAudioSFX(class ACamperPlayer* camper, EAttackType attackType, bool causedKO, bool isWeaponHit, bool isLightHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAudioHandlerComponent", "TriggerSurvivorDamageHitAudioSFX");

	Params::KillerAudioHandlerComponent_TriggerSurvivorDamageHitAudioSFX Parms{};

	Parms.camper = camper;
	Parms.attackType = attackType;
	Parms.causedKO = causedKO;
	Parms.isWeaponHit = isWeaponHit;
	Parms.isLightHit = isLightHit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.KillerAudioMenuReactionComponent.LobbyKillerReactionSpecificSurvivorSFX
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<class ADBDMenuPlayer*>&    menuPlayers                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKillerAudioMenuReactionComponent::LobbyKillerReactionSpecificSurvivorSFX(const TArray<class ADBDMenuPlayer*>& menuPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAudioMenuReactionComponent", "LobbyKillerReactionSpecificSurvivorSFX");

	Params::KillerAudioMenuReactionComponent_LobbyKillerReactionSpecificSurvivorSFX Parms{};

	Parms.menuPlayers = std::move(menuPlayers);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.KillerAudioMenuReactionComponent.OnLobbyTimeChanged
// (Final, Native, Private)

void UKillerAudioMenuReactionComponent::OnLobbyTimeChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerAudioMenuReactionComponent", "OnLobbyTimeChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerBlindingFXComponent.Multicast_OnBlindedByPlayersCosmetic
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const TArray<class ADBDPlayer*>&        players                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UKillerBlindingFXComponent::Multicast_OnBlindedByPlayersCosmetic(const TArray<class ADBDPlayer*>& players)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerBlindingFXComponent", "Multicast_OnBlindedByPlayersCosmetic");

	Params::KillerBlindingFXComponent_Multicast_OnBlindedByPlayersCosmetic Parms{};

	Parms.players = std::move(players);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerBloodFXComponent.PlayBloodSplatter
// (Final, Native, Public, BlueprintCallable)

void UKillerBloodFXComponent::PlayBloodSplatter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerBloodFXComponent", "PlayBloodSplatter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerBloodFXComponent.StopBloodSplatter
// (Final, Native, Public, BlueprintCallable)

void UKillerBloodFXComponent::StopBloodSplatter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerBloodFXComponent", "StopBloodSplatter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerBloodFXInterface.PlayBloodSplatter
// (Event, Public, BlueprintEvent)

void IKillerBloodFXInterface::PlayBloodSplatter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("KillerBloodFXInterface", "PlayBloodSplatter");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.KillerBloodFXInterface.StopBloodSplatter
// (Event, Public, BlueprintEvent)

void IKillerBloodFXInterface::StopBloodSplatter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("KillerBloodFXInterface", "StopBloodSplatter");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.KillerIntroComponent.KillerCameraPanInUpdateNative
// (Final, Native, Private)
// Parameters:
// const float                             killerIntroCompletedPercent                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerIntroComponent::KillerCameraPanInUpdateNative(const float killerIntroCompletedPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerIntroComponent", "KillerCameraPanInUpdateNative");

	Params::KillerIntroComponent_KillerCameraPanInUpdateNative Parms{};

	Parms.killerIntroCompletedPercent = killerIntroCompletedPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerIntroComponent.OnIntroCompleted
// (Final, Native, Private)

void UKillerIntroComponent::OnIntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerIntroComponent", "OnIntroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerIntroComponent.OnLevelReadyToPlay
// (Final, Native, Private)

void UKillerIntroComponent::OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerIntroComponent", "OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerNoiseIndicatorWidget.SetSoundDistancePercentage
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   distancePercentage                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerNoiseIndicatorWidget::SetSoundDistancePercentage(float distancePercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerNoiseIndicatorWidget", "SetSoundDistancePercentage");

	Params::KillerNoiseIndicatorWidget_SetSoundDistancePercentage Parms{};

	Parms.distancePercentage = distancePercentage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.KillerOpenGate.UpdateSwitch
// (Event, Protected, BlueprintEvent, Const)

void UKillerOpenGate::UpdateSwitch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerOpenGate", "UpdateSwitch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.KillerProjectileDodgeComponent.OnKillerProjectileFinished
// (Final, Native, Private)
// Parameters:
// class AActor*                           survivorHit                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerProjectileDodgeComponent::OnKillerProjectileFinished(class AActor* survivorHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileDodgeComponent", "OnKillerProjectileFinished");

	Params::KillerProjectileDodgeComponent_OnKillerProjectileFinished Parms{};

	Parms.survivorHit = survivorHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerProjectileDodgeComponent.OnKillerProjectileFinishedWithoutCollision
// (Final, Native, Private)

void UKillerProjectileDodgeComponent::OnKillerProjectileFinishedWithoutCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileDodgeComponent", "OnKillerProjectileFinishedWithoutCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerProjectileDodgeComponent.OnKillerProjectileLaunched
// (Final, Native, Private)

void UKillerProjectileDodgeComponent::OnKillerProjectileLaunched()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileDodgeComponent", "OnKillerProjectileLaunched");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerProjectileLauncher.GetOwningKiller
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASlasherPlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASlasherPlayer* UKillerProjectileLauncher::GetOwningKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerProjectileLauncher", "GetOwningKiller");

	Params::KillerProjectileLauncher_GetOwningKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.KillerRedStainUpdateStrategy.OnHeadHiddenChanged
// (Final, Native, Private)
// Parameters:
// bool                                    isHidden                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerRedStainUpdateStrategy::OnHeadHiddenChanged(bool isHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerRedStainUpdateStrategy", "OnHeadHiddenChanged");

	Params::KillerRedStainUpdateStrategy_OnHeadHiddenChanged Parms{};

	Parms.isHidden = isHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerSoundCuesComponent.StartTrackingActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           actorToStartTracking                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             distanceDataID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerSoundCuesComponent::StartTrackingActor(class AActor* actorToStartTracking, class FName distanceDataID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerSoundCuesComponent", "StartTrackingActor");

	Params::KillerSoundCuesComponent_StartTrackingActor Parms{};

	Parms.actorToStartTracking = actorToStartTracking;
	Parms.distanceDataID = distanceDataID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerSoundCuesComponent.StartTrackingActorWithLifetime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           actorToStartTracking                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             distanceDataID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   trackerLifetime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerSoundCuesComponent::StartTrackingActorWithLifetime(class AActor* actorToStartTracking, class FName distanceDataID, float trackerLifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerSoundCuesComponent", "StartTrackingActorWithLifetime");

	Params::KillerSoundCuesComponent_StartTrackingActorWithLifetime Parms{};

	Parms.actorToStartTracking = actorToStartTracking;
	Parms.distanceDataID = distanceDataID;
	Parms.trackerLifetime = trackerLifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.KillerSoundCuesComponent.StopTrackingActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           actorToStopTracking                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillerSoundCuesComponent::StopTrackingActor(class AActor* actorToStopTracking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillerSoundCuesComponent", "StopTrackingActor");

	Params::KillerSoundCuesComponent_StopTrackingActor Parms{};

	Parms.actorToStopTracking = actorToStopTracking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternInteractable.ChangeLanternState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELanternState                           newLanternState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALanternInteractable::ChangeLanternState(ELanternState newLanternState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "ChangeLanternState");

	Params::LanternInteractable_ChangeLanternState Parms{};

	Parms.newLanternState = newLanternState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternInteractable.CollectLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALanternInteractable::CollectLight(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "CollectLight");

	Params::LanternInteractable_CollectLight Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternInteractable.OnBackToCollectableTimerEnd
// (Final, Native, Private)

void ALanternInteractable::OnBackToCollectableTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "OnBackToCollectableTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternInteractable.OnCamperLeavingHook
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ALanternInteractable::OnCamperLeavingHook(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "OnCamperLeavingHook");

	Params::LanternInteractable_OnCamperLeavingHook Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternInteractable.OnCamperWasHooked
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ALanternInteractable::OnCamperWasHooked(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "OnCamperWasHooked");

	Params::LanternInteractable_OnCamperWasHooked Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternInteractable.OnSlasherDestroyedLantern
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ALanternInteractable::OnSlasherDestroyedLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "OnSlasherDestroyedLantern");

	Params::LanternInteractable_OnSlasherDestroyedLantern Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternInteractable.SlasherDestroyLantern
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALanternInteractable::SlasherDestroyLantern(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "SlasherDestroyLantern");

	Params::LanternInteractable_SlasherDestroyLantern Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LanternInteractable.CanBeCollected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALanternInteractable::CanBeCollected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "CanBeCollected");

	Params::LanternInteractable_CanBeCollected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LanternInteractable.CanBeDestroyed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALanternInteractable::CanBeDestroyed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "CanBeDestroyed");

	Params::LanternInteractable_CanBeDestroyed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LanternInteractable.GetLanternState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELanternState                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELanternState ALanternInteractable::GetLanternState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LanternInteractable", "GetLanternState");

	Params::LanternInteractable_GetLanternState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LevelReadyToPlayPlayerComponent.OnRep_LevelReadyToPlayRequirementsTarget
// (Final, Native, Private)

void ULevelReadyToPlayPlayerComponent::OnRep_LevelReadyToPlayRequirementsTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelReadyToPlayPlayerComponent", "OnRep_LevelReadyToPlayRequirementsTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LevelReadyToPlayPlayerComponent.Server_SetIsReadyToPlay
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// uint32                                  readyToPlay                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelReadyToPlayPlayerComponent::Server_SetIsReadyToPlay(uint32 readyToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelReadyToPlayPlayerComponent", "Server_SetIsReadyToPlay");

	Params::LevelReadyToPlayPlayerComponent_Server_SetIsReadyToPlay Parms{};

	Parms.readyToPlay = readyToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LightingInterpolator.LerpHeightFog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UExponentialHeightFogComponent*   Target                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UExponentialHeightFogComponent*A                                                      (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UExponentialHeightFogComponent*B                                                      (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   thresholdBeforeSwitchingtoB                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightingInterpolator::LerpHeightFog(class UExponentialHeightFogComponent* Target, const class UExponentialHeightFogComponent* A, const class UExponentialHeightFogComponent* B, float alpha, float thresholdBeforeSwitchingtoB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingInterpolator", "LerpHeightFog");

	Params::LightingInterpolator_LerpHeightFog Parms{};

	Parms.Target = Target;
	Parms.A = A;
	Parms.B = B;
	Parms.alpha = alpha;
	Parms.thresholdBeforeSwitchingtoB = thresholdBeforeSwitchingtoB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LightingInterpolator.LerpLight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULightComponent*                  Target                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULightComponent*                  A                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULightComponent*                  B                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightingInterpolator::LerpLight(class ULightComponent* Target, class ULightComponent* A, class ULightComponent* B, float alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingInterpolator", "LerpLight");

	Params::LightingInterpolator_LerpLight Parms{};

	Parms.Target = Target;
	Parms.A = A;
	Parms.B = B;
	Parms.alpha = alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LightingInterpolator.LerpSkylight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkyLightComponent*               Target                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkyLightComponent*               A                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkyLightComponent*               B                                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightingInterpolator::LerpSkylight(class USkyLightComponent* Target, class USkyLightComponent* A, class USkyLightComponent* B, float alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LightingInterpolator", "LerpSkylight");

	Params::LightingInterpolator_LerpSkylight Parms{};

	Parms.Target = Target;
	Parms.A = A;
	Parms.B = B;
	Parms.alpha = alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LimitAccumulationSpawnerStrategy.SetMaxOverlapping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   maxOverlapping                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULimitAccumulationSpawnerStrategy::SetMaxOverlapping(int32 maxOverlapping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitAccumulationSpawnerStrategy", "SetMaxOverlapping");

	Params::LimitAccumulationSpawnerStrategy_SetMaxOverlapping Parms{};

	Parms.maxOverlapping = maxOverlapping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LimitAccumulationSpawnerStrategy.SetRecycleDistancePercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   recycleDistancePercentage                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULimitAccumulationSpawnerStrategy::SetRecycleDistancePercentage(float recycleDistancePercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitAccumulationSpawnerStrategy", "SetRecycleDistancePercentage");

	Params::LimitAccumulationSpawnerStrategy_SetRecycleDistancePercentage Parms{};

	Parms.recycleDistancePercentage = recycleDistancePercentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LimitAccumulationSpawnerStrategy.SetRecycleThresholdPercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   recycleThresholdPercentage                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULimitAccumulationSpawnerStrategy::SetRecycleThresholdPercentage(float recycleThresholdPercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LimitAccumulationSpawnerStrategy", "SetRecycleThresholdPercentage");

	Params::LimitAccumulationSpawnerStrategy_SetRecycleThresholdPercentage Parms{};

	Parms.recycleThresholdPercentage = recycleThresholdPercentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LobbyDialogueSubsystem.CountGuestLobbyMembersWithAudioSwitch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// EAudioCustomizationCategory             switchCategory                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FString>&            audioSwitches                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32*                                  numMatching                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  numNotMatching                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyDialogueSubsystem::CountGuestLobbyMembersWithAudioSwitch(EAudioCustomizationCategory switchCategory, const TArray<class FString>& audioSwitches, int32* numMatching, int32* numNotMatching)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LobbyDialogueSubsystem", "CountGuestLobbyMembersWithAudioSwitch");

	Params::LobbyDialogueSubsystem_CountGuestLobbyMembersWithAudioSwitch Parms{};

	Parms.switchCategory = switchCategory;
	Parms.audioSwitches = std::move(audioSwitches);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (numMatching != nullptr)
		*numMatching = Parms.numMatching;

	if (numNotMatching != nullptr)
		*numNotMatching = Parms.numNotMatching;
}


// Function DeadByDaylight.LobbyDialogueSubsystem.GetGuestLobbyMembers
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ADBDMenuPlayer*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDMenuPlayer*> ULobbyDialogueSubsystem::GetGuestLobbyMembers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LobbyDialogueSubsystem", "GetGuestLobbyMembers");

	Params::LobbyDialogueSubsystem_GetGuestLobbyMembers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LobbyDialogueSubsystem.HasCharacterPlayedDialogueForThisLobby
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    characterName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   dialogueId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULobbyDialogueSubsystem::HasCharacterPlayedDialogueForThisLobby(const class FString& characterName, int32 dialogueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LobbyDialogueSubsystem", "HasCharacterPlayedDialogueForThisLobby");

	Params::LobbyDialogueSubsystem_HasCharacterPlayedDialogueForThisLobby Parms{};

	Parms.characterName = std::move(characterName);
	Parms.dialogueId = dialogueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LobbyDialogueSubsystem.IsLobbyFullForRole
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPlayerRole                             role                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULobbyDialogueSubsystem::IsLobbyFullForRole(EPlayerRole role)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LobbyDialogueSubsystem", "IsLobbyFullForRole");

	Params::LobbyDialogueSubsystem_IsLobbyFullForRole Parms{};

	Parms.role = role;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LobbyDialogueSubsystem.NotifyCharacterPlayedDialogueForThisLobby
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    characterName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   dialogueId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyDialogueSubsystem::NotifyCharacterPlayedDialogueForThisLobby(const class FString& characterName, int32 dialogueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LobbyDialogueSubsystem", "NotifyCharacterPlayedDialogueForThisLobby");

	Params::LobbyDialogueSubsystem_NotifyCharacterPlayedDialogueForThisLobby Parms{};

	Parms.characterName = std::move(characterName);
	Parms.dialogueId = dialogueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LobbyDialogueSubsystem.NotifyDialogueInterrupted
// (Final, Native, Static, Public, BlueprintCallable)

void ULobbyDialogueSubsystem::NotifyDialogueInterrupted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LobbyDialogueSubsystem", "NotifyDialogueInterrupted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LocalPlayerTrackerComponent.TriggerOnLocallyObservedChanged
// (Final, Native, Public)

void ULocalPlayerTrackerComponent::TriggerOnLocallyObservedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalPlayerTrackerComponent", "TriggerOnLocallyObservedChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LocalPlayerUtilities.GetLocalHumanPlayerState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayerState*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayerState* ULocalPlayerUtilities::GetLocalHumanPlayerState(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LocalPlayerUtilities", "GetLocalHumanPlayerState");

	Params::LocalPlayerUtilities_GetLocalHumanPlayerState Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LockerOutlineUpdateStrategy.GetRedColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ULockerOutlineUpdateStrategy::GetRedColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockerOutlineUpdateStrategy", "GetRedColor");

	Params::LockerOutlineUpdateStrategy_GetRedColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.LoudNoiseHUDIndicator.AddTrackedNoise
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoudNoiseHUDIndicator::AddTrackedNoise(const struct FVector& location, float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoudNoiseHUDIndicator", "AddTrackedNoise");

	Params::LoudNoiseHUDIndicator_AddTrackedNoise Parms{};

	Parms.location = std::move(location);
	Parms.duration = duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LoudNoiseNotifier.Fire
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    shouldTrack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   audibleRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       instigatingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isQuickAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isDeceivingNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoudNoiseNotifier::Fire(const class UObject* worldContextObject, class AActor* instigator, const struct FVector& location, bool shouldTrack, float audibleRange, class ADBDPlayer* instigatingPlayer, bool isQuickAction, bool isDeceivingNoise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LoudNoiseNotifier", "Fire");

	Params::LoudNoiseNotifier_Fire Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.instigator = instigator;
	Parms.location = std::move(location);
	Parms.shouldTrack = shouldTrack;
	Parms.audibleRange = audibleRange;
	Parms.instigatingPlayer = instigatingPlayer;
	Parms.isQuickAction = isQuickAction;
	Parms.isDeceivingNoise = isDeceivingNoise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LoudNoiseNotifier.FireWithTimeBudgeter
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    shouldTrack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   audibleRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       instigatingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isQuickAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoudNoiseNotifier::FireWithTimeBudgeter(const class UObject* worldContextObject, class AActor* instigator, const struct FVector& location, bool shouldTrack, float audibleRange, class ADBDPlayer* instigatingPlayer, bool isQuickAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LoudNoiseNotifier", "FireWithTimeBudgeter");

	Params::LoudNoiseNotifier_FireWithTimeBudgeter Parms{};

	Parms.worldContextObject = worldContextObject;
	Parms.instigator = instigator;
	Parms.location = std::move(location);
	Parms.shouldTrack = shouldTrack;
	Parms.audibleRange = audibleRange;
	Parms.instigatingPlayer = instigatingPlayer;
	Parms.isQuickAction = isQuickAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Authority_OnCamperEscape
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Authority_OnCamperEscape(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Authority_OnCamperEscape");

	Params::LunarEventComponent_Authority_OnCamperEscape Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Authority_OnCamperLostLantern
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Authority_OnCamperLostLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Authority_OnCamperLostLantern");

	Params::LunarEventComponent_Authority_OnCamperLostLantern Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Authority_OnDestroyCamperLightGameEvent
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Authority_OnDestroyCamperLightGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Authority_OnDestroyCamperLightGameEvent");

	Params::LunarEventComponent_Authority_OnDestroyCamperLightGameEvent Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Authority_OnFixGenerator
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Authority_OnFixGenerator(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Authority_OnFixGenerator");

	Params::LunarEventComponent_Authority_OnFixGenerator Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Authority_OnPickupLantern
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Authority_OnPickupLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Authority_OnPickupLantern");

	Params::LunarEventComponent_Authority_OnPickupLantern Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Authority_OnPlayerLeaveGame
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Authority_OnPlayerLeaveGame(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Authority_OnPlayerLeaveGame");

	Params::LunarEventComponent_Authority_OnPlayerLeaveGame Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Authority_OnSlasherDestroysLantern
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Authority_OnSlasherDestroysLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Authority_OnSlasherDestroysLantern");

	Params::LunarEventComponent_Authority_OnSlasherDestroysLantern Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Local_OnCamperEscape
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Local_OnCamperEscape(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Local_OnCamperEscape");

	Params::LunarEventComponent_Local_OnCamperEscape Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Local_OnCamperLostLantern
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::Local_OnCamperLostLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Local_OnCamperLostLantern");

	Params::LunarEventComponent_Local_OnCamperLostLantern Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.Multicast_ResetLanternLight
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, NetValidate)
// Parameters:
// class ALanternInteractable*             lanternInteractable                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULunarEventComponent::Multicast_ResetLanternLight(class ALanternInteractable* lanternInteractable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "Multicast_ResetLanternLight");

	Params::LunarEventComponent_Multicast_ResetLanternLight Parms{};

	Parms.lanternInteractable = lanternInteractable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.OnFinishedPlaying
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULunarEventComponent::OnFinishedPlaying(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "OnFinishedPlaying");

	Params::LunarEventComponent_OnFinishedPlaying Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.OnLanternHoldTimerEnd
// (Final, Native, Private)

void ULunarEventComponent::OnLanternHoldTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "OnLanternHoldTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.LunarEventComponent.OnRep_lanternCollectedCount
// (Final, Native, Private)

void ULunarEventComponent::OnRep_lanternCollectedCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LunarEventComponent", "OnRep_lanternCollectedCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MagicFountain.IsCorrupted
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMagicFountain::IsCorrupted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MagicFountain", "IsCorrupted");

	Params::MagicFountain_IsCorrupted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MagicFountainOutlineUpdateStrategy.SetFountainCorrupted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              corrupted                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMagicFountainOutlineUpdateStrategy::SetFountainCorrupted(const bool corrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MagicFountainOutlineUpdateStrategy", "SetFountainCorrupted");

	Params::MagicFountainOutlineUpdateStrategy_SetFountainCorrupted Parms{};

	Parms.corrupted = corrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MapActorDB.CopyListMinusCategories
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<EMapActorCategory>&        Categories                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<EMapActorCategory>&        categoriesToRemove                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<EMapActorCategory>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<EMapActorCategory> UMapActorDB::CopyListMinusCategories(const TArray<EMapActorCategory>& Categories, const TArray<EMapActorCategory>& categoriesToRemove) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorDB", "CopyListMinusCategories");

	Params::MapActorDB_CopyListMinusCategories Parms{};

	Parms.Categories = std::move(Categories);
	Parms.categoriesToRemove = std::move(categoriesToRemove);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MapActorDB.GetRandom
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMapActorCategory                       category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UMapActorDB::GetRandom(EMapActorCategory category) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorDB", "GetRandom");

	Params::MapActorDB_GetRandom Parms{};

	Parms.category = category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MapActorDB.GetUniqueRandom
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<EMapActorCategory>&        categories                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UMapActorDB::GetUniqueRandom(const TArray<EMapActorCategory>& categories, int32 count) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorDB", "GetUniqueRandom");

	Params::MapActorDB_GetUniqueRandom Parms{};

	Parms.categories = std::move(categories);
	Parms.count = count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MapActorDetectorComponent.OnOverlapEnter
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMapActorDetectorComponent::OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorDetectorComponent", "OnOverlapEnter");

	Params::MapActorDetectorComponent_OnOverlapEnter Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MapActorDetectorComponent.SetDetectionPrimitive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              primitive                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapActorDetectorComponent::SetDetectionPrimitive(class UPrimitiveComponent* primitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapActorDetectorComponent", "SetDetectionPrimitive");

	Params::MapActorDetectorComponent_SetDetectionPrimitive Parms{};

	Parms.primitive = primitive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SetHookedSurvivor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Authority_SetHookedSurvivor(class ACamperPlayer* survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SetHookedSurvivor");

	Params::MeatHook_Authority_SetHookedSurvivor Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SetIsBrokenFromUnhook
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isBrokenFromUnhook                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       hookBreaker                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   overrideBaseHookRespawnDuration                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Authority_SetIsBrokenFromUnhook(bool isBrokenFromUnhook, class ADBDPlayer* hookBreaker, float overrideBaseHookRespawnDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SetIsBrokenFromUnhook");

	Params::MeatHook_Authority_SetIsBrokenFromUnhook Parms{};

	Parms.isBrokenFromUnhook = isBrokenFromUnhook;
	Parms.hookBreaker = hookBreaker;
	Parms.overrideBaseHookRespawnDuration = overrideBaseHookRespawnDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SetIsSabotaged
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isSabotaged                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       saboteur                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    useCamperHookRespawnDurationModifiers                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   overrideBaseHookRespawnDuration                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Authority_SetIsSabotaged(bool isSabotaged, class ADBDPlayer* saboteur, bool useCamperHookRespawnDurationModifiers, float overrideBaseHookRespawnDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SetIsSabotaged");

	Params::MeatHook_Authority_SetIsSabotaged Parms{};

	Parms.isSabotaged = isSabotaged;
	Parms.saboteur = saboteur;
	Parms.useCamperHookRespawnDurationModifiers = useCamperHookRespawnDurationModifiers;
	Parms.overrideBaseHookRespawnDuration = overrideBaseHookRespawnDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SetIsSacrificed
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isSacrificed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Authority_SetIsSacrificed(bool isSacrificed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SetIsSacrificed");

	Params::MeatHook_Authority_SetIsSacrificed Parms{};

	Parms.isSacrificed = isSacrificed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SignalSurvivorAttemptingEscape
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AMeatHook::Authority_SignalSurvivorAttemptingEscape()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SignalSurvivorAttemptingEscape");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SignalSurvivorAttemptingEscapeAborted
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AMeatHook::Authority_SignalSurvivorAttemptingEscapeAborted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SignalSurvivorAttemptingEscapeAborted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SignalUnhookingAborted
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AMeatHook::Authority_SignalUnhookingAborted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SignalUnhookingAborted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SignalUnhookingCharged
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AMeatHook::Authority_SignalUnhookingCharged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SignalUnhookingCharged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Authority_SignalUnhookingEnter
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AMeatHook::Authority_SignalUnhookingEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Authority_SignalUnhookingEnter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.BroadcastUnhook
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       rescuer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::BroadcastUnhook(class ADBDPlayer* rescuer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "BroadcastUnhook");

	Params::MeatHook_BroadcastUnhook Parms{};

	Parms.rescuer = rescuer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Cosmetic_SetAsScourgeHookStart
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void AMeatHook::Cosmetic_SetAsScourgeHookStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Cosmetic_SetAsScourgeHookStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.Local_MoveSurvivorToHook
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Local_MoveSurvivorToHook(class ACamperPlayer* survivor, const float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Local_MoveSurvivorToHook");

	Params::MeatHook_Local_MoveSurvivorToHook Parms{};

	Parms.survivor = survivor;
	Parms.duration = duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Multicast_EscapeAttemptResult
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Multicast_EscapeAttemptResult(class ADBDPlayer* player, bool result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Multicast_EscapeAttemptResult");

	Params::MeatHook_Multicast_EscapeAttemptResult Parms{};

	Parms.player = player;
	Parms.result = result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Multicast_RefreshCharmCustomization
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void AMeatHook::Multicast_RefreshCharmCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Multicast_RefreshCharmCustomization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Multicast_SetHookedSurvivor
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Multicast_SetHookedSurvivor(class ACamperPlayer* survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Multicast_SetHookedSurvivor");

	Params::MeatHook_Multicast_SetHookedSurvivor Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Multicast_SetIsBrokenFromUnhook
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// bool                                    setIsBrokendFromUnhook                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       hookBreaker                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   overrideBaseHookRespawnDuration                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Multicast_SetIsBrokenFromUnhook(bool setIsBrokendFromUnhook, class ADBDPlayer* hookBreaker, float overrideBaseHookRespawnDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Multicast_SetIsBrokenFromUnhook");

	Params::MeatHook_Multicast_SetIsBrokenFromUnhook Parms{};

	Parms.setIsBrokendFromUnhook = setIsBrokendFromUnhook;
	Parms.hookBreaker = hookBreaker;
	Parms.overrideBaseHookRespawnDuration = overrideBaseHookRespawnDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Multicast_SetIsSabotaged
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// bool                                    setIsSabotaged                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       hookBreaker                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    useCamperHookRespawnDurationModifiers                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   overrideBaseHookRespawnDuration                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Multicast_SetIsSabotaged(bool setIsSabotaged, class ADBDPlayer* hookBreaker, bool useCamperHookRespawnDurationModifiers, float overrideBaseHookRespawnDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Multicast_SetIsSabotaged");

	Params::MeatHook_Multicast_SetIsSabotaged Parms{};

	Parms.setIsSabotaged = setIsSabotaged;
	Parms.hookBreaker = hookBreaker;
	Parms.useCamperHookRespawnDurationModifiers = useCamperHookRespawnDurationModifiers;
	Parms.overrideBaseHookRespawnDuration = overrideBaseHookRespawnDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.Multicast_SetIsSacrificed
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// bool                                    isSacrificed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::Multicast_SetIsSacrificed(bool isSacrificed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "Multicast_SetIsSacrificed");

	Params::MeatHook_Multicast_SetIsSacrificed Parms{};

	Parms.isSacrificed = isSacrificed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.OnAutoRepair
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnAutoRepair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnAutoRepair");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnHookedEnter
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnHookedEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnHookedEnter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnHookedExit
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnHookedExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnHookedExit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnHookedIdle
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnHookedIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnHookedIdle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnHookedSurvivorAttacked
// (Final, Native, Protected)

void AMeatHook::OnHookedSurvivorAttacked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnHookedSurvivorAttacked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.OnHookedSurvivorChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ACamperPlayer*                    before                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACamperPlayer*                    after                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::OnHookedSurvivorChanged(class ACamperPlayer* before, class ACamperPlayer* after)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnHookedSurvivorChanged");

	Params::MeatHook_OnHookedSurvivorChanged Parms{};

	Parms.before = before;
	Parms.after = after;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.MeatHook.OnHookingEnter
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnHookingEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnHookingEnter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnHookingExit
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnHookingExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnHookingExit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnOwnerReplicated
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnOwnerReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnOwnerReplicated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnReaction
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnReaction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnReaction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnReactionIn
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnReactionIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnReactionIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnSacrificeIn
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnSacrificeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnSacrificeIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnSacrificeOut
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnSacrificeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnSacrificeOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnStartPushingPlayer
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::OnStartPushingPlayer(class ACharacter* character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnStartPushingPlayer");

	Params::MeatHook_OnStartPushingPlayer Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.OnStopPushingPlayer
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::OnStopPushingPlayer(class ACharacter* character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnStopPushingPlayer");

	Params::MeatHook_OnStopPushingPlayer Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.OnStruggleEnter
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnStruggleEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnStruggleEnter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnStruggleExit
// (Event, Protected, BlueprintEvent)

void AMeatHook::OnStruggleExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnStruggleExit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnStruggleSkillCheckFailed_Cosmetic
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AMeatHook::OnStruggleSkillCheckFailed_Cosmetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnStruggleSkillCheckFailed_Cosmetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.MeatHook.OnTickStruggle
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   deltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::OnTickStruggle(float deltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "OnTickStruggle");

	Params::MeatHook_OnTickStruggle Parms{};

	Parms.deltaTime = deltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.MeatHook.SetEntity
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AEntity*                          entity                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::SetEntity(class AEntity* entity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "SetEntity");

	Params::MeatHook_SetEntity Parms{};

	Parms.entity = entity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.SetInteractingPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       interactingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::SetInteractingPlayer(class ADBDPlayer* interactingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "SetInteractingPlayer");

	Params::MeatHook_SetInteractingPlayer Parms{};

	Parms.interactingPlayer = interactingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.SetIsBeingSabotaged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isBeingSabotaged                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::SetIsBeingSabotaged(bool isBeingSabotaged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "SetIsBeingSabotaged");

	Params::MeatHook_SetIsBeingSabotaged Parms{};

	Parms.isBeingSabotaged = isBeingSabotaged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.SetMapActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMapActorComponent*               value                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::SetMapActor(class UMapActorComponent* value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "SetMapActor");

	Params::MeatHook_SetMapActor Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.UpdateSlasherBlockerCollision
// (Final, Native, Protected, BlueprintCallable)

void AMeatHook::UpdateSlasherBlockerCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "UpdateSlasherBlockerCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.CanBeSabotaged
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::CanBeSabotaged() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "CanBeSabotaged");

	Params::MeatHook_CanBeSabotaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.CanHookSurvivor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::CanHookSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "CanHookSurvivor");

	Params::MeatHook_CanHookSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.CanSurvivorAttemptEscape
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ACamperPlayer*              survivor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::CanSurvivorAttemptEscape(const class ACamperPlayer* survivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "CanSurvivorAttemptEscape");

	Params::MeatHook_CanSurvivorAttemptEscape Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.CanSurvivorStruggle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::CanSurvivorStruggle(class ACamperPlayer* survivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "CanSurvivorStruggle");

	Params::MeatHook_CanSurvivorStruggle Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.CanUnhookSurvivor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ACamperPlayer*              survivor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::CanUnhookSurvivor(const class ACamperPlayer* survivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "CanUnhookSurvivor");

	Params::MeatHook_CanUnhookSurvivor Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.DebugHookedSurvivor
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class ACamperPlayer*                    expectedSurvivor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::DebugHookedSurvivor(class ACamperPlayer* expectedSurvivor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "DebugHookedSurvivor");

	Params::MeatHook_DebugHookedSurvivor Parms{};

	Parms.expectedSurvivor = expectedSurvivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHook.FireHookSoundEvent
// (Event, Public, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// const class FName                       NoiseRangeTunable                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ADBDPlayer*                 soundInstigator                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeatHook::FireHookSoundEvent(const class FName NoiseRangeTunable, const class ADBDPlayer* soundInstigator) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "FireHookSoundEvent");

	Params::MeatHook_FireHookSoundEvent Parms{};

	Parms.NoiseRangeTunable = NoiseRangeTunable;
	Parms.soundInstigator = soundInstigator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.MeatHook.GetCamperHookedSnapTransform
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AMeatHook::GetCamperHookedSnapTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetCamperHookedSnapTransform");

	Params::MeatHook_GetCamperHookedSnapTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetCamperUnkookFocalPointTransform
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AMeatHook::GetCamperUnkookFocalPointTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetCamperUnkookFocalPointTransform");

	Params::MeatHook_GetCamperUnkookFocalPointTransform Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetCharacterPusher
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterPusherComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterPusherComponent* AMeatHook::GetCharacterPusher() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetCharacterPusher");

	Params::MeatHook_GetCharacterPusher Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetEscapeHookCID
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UChargeableInteractionDefinition* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableInteractionDefinition* AMeatHook::GetEscapeHookCID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetEscapeHookCID");

	Params::MeatHook_GetEscapeHookCID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetHookableComponentOfHookedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UHookableComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHookableComponent* AMeatHook::GetHookableComponentOfHookedActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetHookableComponentOfHookedActor");

	Params::MeatHook_GetHookableComponentOfHookedActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetHookedSurvivor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACamperPlayer*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACamperPlayer* AMeatHook::GetHookedSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetHookedSurvivor");

	Params::MeatHook_GetHookedSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetHookPosition
// (Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMeatHook::GetHookPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetHookPosition");

	Params::MeatHook_GetHookPosition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetInteractingPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* AMeatHook::GetInteractingPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetInteractingPlayer");

	Params::MeatHook_GetInteractingPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetInteractorPrimitiveComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* AMeatHook::GetInteractorPrimitiveComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetInteractorPrimitiveComponent");

	Params::MeatHook_GetInteractorPrimitiveComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetInteractorZoneComponent
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UBoxComponent*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBoxComponent* AMeatHook::GetInteractorZoneComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetInteractorZoneComponent");

	Params::MeatHook_GetInteractorZoneComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetIsBroken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::GetIsBroken() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetIsBroken");

	Params::MeatHook_GetIsBroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetIsInBasement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::GetIsInBasement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetIsInBasement");

	Params::MeatHook_GetIsInBasement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetIsSabotaged
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::GetIsSabotaged() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetIsSabotaged");

	Params::MeatHook_GetIsSabotaged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetIsSacrificed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMeatHook::GetIsSacrificed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetIsSacrificed");

	Params::MeatHook_GetIsSacrificed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetKickSlasherDetectionZone
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USphereComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USphereComponent* AMeatHook::GetKickSlasherDetectionZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetKickSlasherDetectionZone");

	Params::MeatHook_GetKickSlasherDetectionZone Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetMainInteractor
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UInteractor*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractor* AMeatHook::GetMainInteractor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetMainInteractor");

	Params::MeatHook_GetMainInteractor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetMeatHookAkAudioComponent
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UAkComponent*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkComponent* AMeatHook::GetMeatHookAkAudioComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetMeatHookAkAudioComponent");

	Params::MeatHook_GetMeatHookAkAudioComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetMontagePlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMontagePlayer*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMontagePlayer* AMeatHook::GetMontagePlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetMontagePlayer");

	Params::MeatHook_GetMontagePlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetSabotageHookRespawnDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMeatHook::GetSabotageHookRespawnDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetSabotageHookRespawnDuration");

	Params::MeatHook_GetSabotageHookRespawnDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetSaboteurPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* AMeatHook::GetSaboteurPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetSaboteurPlayer");

	Params::MeatHook_GetSaboteurPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetStrugglePercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMeatHook::GetStrugglePercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetStrugglePercent");

	Params::MeatHook_GetStrugglePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetStruggleThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMeatHook::GetStruggleThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetStruggleThreshold");

	Params::MeatHook_GetStruggleThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetUnhookCID
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UChargeableInteractionDefinition* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableInteractionDefinition* AMeatHook::GetUnhookCID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetUnhookCID");

	Params::MeatHook_GetUnhookCID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetUnhookInMontageDescriptor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAnimationMontageDescriptor      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAnimationMontageDescriptor AMeatHook::GetUnhookInMontageDescriptor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetUnhookInMontageDescriptor");

	Params::MeatHook_GetUnhookInMontageDescriptor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHook.GetUnhookOutMontageDescriptor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAnimationMontageDescriptor      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAnimationMontageDescriptor AMeatHook::GetUnhookOutMontageDescriptor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHook", "GetUnhookOutMontageDescriptor");

	Params::MeatHook_GetUnhookOutMontageDescriptor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MeatHookOutlineUpdateStrategy.Authority_AddBasementHookToPlayerMapItem
// (Final, Native, Private)

void UMeatHookOutlineUpdateStrategy::Authority_AddBasementHookToPlayerMapItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHookOutlineUpdateStrategy", "Authority_AddBasementHookToPlayerMapItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MeatHookOutlineUpdateStrategy.Local_AddBasementOfferingReveal
// (Final, Native, Private)

void UMeatHookOutlineUpdateStrategy::Local_AddBasementOfferingReveal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHookOutlineUpdateStrategy", "Local_AddBasementOfferingReveal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MenuForcedLODHandler.OnCustomizationChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// ECustomizationCategory                  category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      itemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDMenuPlayer*                   menuPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMenuForcedLODHandler::OnCustomizationChanged(ECustomizationCategory category, const class FName& itemId, class ADBDMenuPlayer* menuPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuForcedLODHandler", "OnCustomizationChanged");

	Params::MenuForcedLODHandler_OnCustomizationChanged Parms{};

	Parms.category = category;
	Parms.itemId = itemId;
	Parms.menuPlayer = menuPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MenuForcedLODHandler.OnMenuPlayerEndPlay
// (Final, Native, Private)
// Parameters:
// class AActor*                           menuPlayerActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          endPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMenuForcedLODHandler::OnMenuPlayerEndPlay(class AActor* menuPlayerActor, EEndPlayReason endPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuForcedLODHandler", "OnMenuPlayerEndPlay");

	Params::MenuForcedLODHandler_OnMenuPlayerEndPlay Parms{};

	Parms.menuPlayerActor = menuPlayerActor;
	Parms.endPlayReason = endPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MenuMeatHook.BeginDestroySequence_Internal
// (Native, Event, Protected, BlueprintEvent)

void AMenuMeatHook::BeginDestroySequence_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuMeatHook", "BeginDestroySequence_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MenuMeatHook.OnCharmsUpdated
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<struct FCharmIdSlot>&      charmIDs                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AMenuMeatHook::OnCharmsUpdated(const TArray<struct FCharmIdSlot>& charmIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuMeatHook", "OnCharmsUpdated");

	Params::MenuMeatHook_OnCharmsUpdated Parms{};

	Parms.charmIDs = std::move(charmIDs);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.MenuUtilities.AreAllGuestCharactersReady
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMenuUtilities::AreAllGuestCharactersReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MenuUtilities", "AreAllGuestCharactersReady");

	Params::MenuUtilities_AreAllGuestCharactersReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MenuUtilities.GetAllMenuCharacters
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ADBDMenuPlayer*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADBDMenuPlayer*> UMenuUtilities::GetAllMenuCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MenuUtilities", "GetAllMenuCharacters");

	Params::MenuUtilities_GetAllMenuCharacters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MontagePlayer.JumpToSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             sectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMontagePlayer::JumpToSection(class FName sectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "JumpToSection");

	Params::MontagePlayer_JumpToSection Parms{};

	Parms.sectionName = sectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MontagePlayer.JumpToSectionEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             sectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMontagePlayer::JumpToSectionEnd(class FName sectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "JumpToSectionEnd");

	Params::MontagePlayer_JumpToSectionEnd Parms{};

	Parms.sectionName = sectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MontagePlayer.OnMontageBlendingOutInternal
// (Final, Native, Private, HasDefaults)
// Parameters:
// const struct FGuid&                     guid                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMontagePlayer::OnMontageBlendingOutInternal(const struct FGuid& guid, class UAnimMontage* montage, bool interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "OnMontageBlendingOutInternal");

	Params::MontagePlayer_OnMontageBlendingOutInternal Parms{};

	Parms.guid = std::move(guid);
	Parms.montage = montage;
	Parms.interrupted = interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MontagePlayer.OnMontageEndedInternal
// (Final, Native, Private, HasDefaults)
// Parameters:
// const struct FGuid&                     guid                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMontagePlayer::OnMontageEndedInternal(const struct FGuid& guid, class UAnimMontage* montage, bool interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "OnMontageEndedInternal");

	Params::MontagePlayer_OnMontageEndedInternal Parms{};

	Parms.guid = std::move(guid);
	Parms.montage = montage;
	Parms.interrupted = interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MontagePlayer.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// float                                   playRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isFollower                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UMontagePlayer::Play(const struct FAnimationMontageDescriptor& animMontageID, float playRate, bool isFollower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "Play");

	Params::MontagePlayer_Play Parms{};

	Parms.animMontageID = std::move(animMontageID);
	Parms.playRate = playRate;
	Parms.isFollower = isFollower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MontagePlayer.PlayLoopForDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (Parm, NativeAccessSpecifierPublic)
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   playRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             out                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UMontagePlayer::PlayLoopForDuration(const struct FAnimationMontageDescriptor& animMontageID, float duration, float playRate, class FName out)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "PlayLoopForDuration");

	Params::MontagePlayer_PlayLoopForDuration Parms{};

	Parms.animMontageID = std::move(animMontageID);
	Parms.duration = duration;
	Parms.playRate = playRate;
	Parms.out = out;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MontagePlayer.SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   playRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMontagePlayer::SetPlayRate(float playRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "SetPlayRate");

	Params::MontagePlayer_SetPlayRate Parms{};

	Parms.playRate = playRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MontagePlayer.SetSkeletalMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           skeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMontagePlayer::SetSkeletalMesh(class USkeletalMeshComponent* skeletalMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "SetSkeletalMesh");

	Params::MontagePlayer_SetSkeletalMesh Parms{};

	Parms.skeletalMeshComponent = skeletalMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MontagePlayer.SignalAnimInstanceChanged
// (Final, Native, Private)

void UMontagePlayer::SignalAnimInstanceChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "SignalAnimInstanceChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MontagePlayer.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   blendOutTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMontagePlayer::Stop(float blendOutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "Stop");

	Params::MontagePlayer_Stop Parms{};

	Parms.blendOutTime = blendOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MontagePlayer.GetAnimInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* UMontagePlayer::GetAnimInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "GetAnimInstance");

	Params::MontagePlayer_GetAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MontagePlayer.IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAnimationMontageDescriptor&montageDescriptor                                      (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMontagePlayer::IsPlaying(const struct FAnimationMontageDescriptor& montageDescriptor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "IsPlaying");

	Params::MontagePlayer_IsPlaying Parms{};

	Parms.montageDescriptor = std::move(montageDescriptor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MontagePlayer.IsPlayingAnyMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMontagePlayer::IsPlayingAnyMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MontagePlayer", "IsPlayingAnyMontage");

	Params::MontagePlayer_IsPlayingAnyMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.MoriableComponent.OnMoriFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    hasBeenKilledByMori                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoriableComponent::OnMoriFinished(bool hasBeenKilledByMori)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoriableComponent", "OnMoriFinished");

	Params::MoriableComponent_OnMoriFinished Parms{};

	Parms.hasBeenKilledByMori = hasBeenKilledByMori;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MoriableComponent.OnMoriUpdateStart
// (Final, Native, Public, BlueprintCallable)

void UMoriableComponent::OnMoriUpdateStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoriableComponent", "OnMoriUpdateStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MoriableComponent.OnRep_MoriInteractions
// (Final, Native, Protected)

void UMoriableComponent::OnRep_MoriInteractions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoriableComponent", "OnRep_MoriInteractions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.MultipleLightsFader.SetAffectedLights
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class ULightComponent*>&   affectedLights                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMultipleLightsFader::SetAffectedLights(const TArray<class ULightComponent*>& affectedLights)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MultipleLightsFader", "SetAffectedLights");

	Params::MultipleLightsFader_SetAffectedLights Parms{};

	Parms.affectedLights = std::move(affectedLights);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NatAudioAmbienceBox.OnBeginOverlapAudioAmbience
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              overlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           otherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              otherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   otherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                sweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UNatAudioAmbienceBox::OnBeginOverlapAudioAmbience(class UPrimitiveComponent* overlappedComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NatAudioAmbienceBox", "OnBeginOverlapAudioAmbience");

	Params::NatAudioAmbienceBox_OnBeginOverlapAudioAmbience Parms{};

	Parms.overlappedComponent = overlappedComponent;
	Parms.otherActor = otherActor;
	Parms.otherComp = otherComp;
	Parms.otherBodyIndex = otherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.sweepResult = std::move(sweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NatAudioAmbienceBox.OnEndOverlapAudioAmbience
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              overlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           otherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              otherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   otherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNatAudioAmbienceBox::OnEndOverlapAudioAmbience(class UPrimitiveComponent* overlappedComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NatAudioAmbienceBox", "OnEndOverlapAudioAmbience");

	Params::NatAudioAmbienceBox_OnEndOverlapAudioAmbience Parms{};

	Parms.overlappedComponent = overlappedComponent;
	Parms.otherActor = otherActor;
	Parms.otherComp = otherComp;
	Parms.otherBodyIndex = otherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnAddPlayerClick
// (Final, Native, Protected)
// Parameters:
// int32                                   buttonId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationScreen::OnAddPlayerClick(int32 buttonId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnAddPlayerClick");

	Params::NavigationScreen_OnAddPlayerClick Parms{};

	Parms.buttonId = buttonId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnCancelButtonClick
// (Final, Native, Protected)

void UNavigationScreen::OnCancelButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnCancelButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnCharacterSwapArrowClick
// (Final, Native, Protected)
// Parameters:
// bool                                    isNext                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationScreen::OnCharacterSwapArrowClick(bool isNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnCharacterSwapArrowClick");

	Params::NavigationScreen_OnCharacterSwapArrowClick Parms{};

	Parms.isNext = isNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnChatInputMouseOver
// (Final, Native, Protected)
// Parameters:
// bool                                    isMouseOver                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationScreen::OnChatInputMouseOver(bool isMouseOver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnChatInputMouseOver");

	Params::NavigationScreen_OnChatInputMouseOver Parms{};

	Parms.isMouseOver = isMouseOver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnCrowdPlayButtonClick
// (Final, Native, Protected)

void UNavigationScreen::OnCrowdPlayButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnCrowdPlayButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnDailyRitualsClick
// (Final, Native, Protected)

void UNavigationScreen::OnDailyRitualsClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnDailyRitualsClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnFadeOutEnded
// (Final, Native, Protected)

void UNavigationScreen::OnFadeOutEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnFadeOutEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnInviteFriendClick
// (Final, Native, Protected)

void UNavigationScreen::OnInviteFriendClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnInviteFriendClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnMatchMakingBanTimeout
// (Final, Native, Protected)

void UNavigationScreen::OnMatchMakingBanTimeout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnMatchMakingBanTimeout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnMatchManagementButtonClick
// (Final, Native, Protected)

void UNavigationScreen::OnMatchManagementButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnMatchManagementButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnPlayerInfoClick
// (Final, Native, Protected)
// Parameters:
// int32                                   playerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationScreen::OnPlayerInfoClick(int32 playerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnPlayerInfoClick");

	Params::NavigationScreen_OnPlayerInfoClick Parms{};

	Parms.playerId = playerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnPlayerOptionSelected
// (Final, Native, Protected)
// Parameters:
// const class FString&                    krakenId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    playerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   option                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationScreen::OnPlayerOptionSelected(const class FString& krakenId, const class FString& playerId, uint8 option)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnPlayerOptionSelected");

	Params::NavigationScreen_OnPlayerOptionSelected Parms{};

	Parms.krakenId = std::move(krakenId);
	Parms.playerId = std::move(playerId);
	Parms.option = option;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnReadyButtonClick
// (Final, Native, Protected)

void UNavigationScreen::OnReadyButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnReadyButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnSendChatMsgButtonClick
// (Final, Native, Protected)
// Parameters:
// const class FString&                    message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNavigationScreen::OnSendChatMsgButtonClick(const class FString& message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnSendChatMsgButtonClick");

	Params::NavigationScreen_OnSendChatMsgButtonClick Parms{};

	Parms.message = std::move(message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnSettingsClick
// (Final, Native, Protected)

void UNavigationScreen::OnSettingsClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnSettingsClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnStartButtonClick
// (Final, Native, Protected)

void UNavigationScreen::OnStartButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnStartButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.NavigationScreen.OnToggleChatVisibility
// (Final, Native, Protected)

void UNavigationScreen::OnToggleChatVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavigationScreen", "OnToggleChatVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacerComponent.ActivateObjectPlacement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectPlacerComponent::ActivateObjectPlacement(bool active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "ActivateObjectPlacement");

	Params::ObjectPlacerComponent_ActivateObjectPlacement Parms{};

	Parms.active = active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacerComponent.SetHideIndicatorDuringAttack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectPlacerComponent::SetHideIndicatorDuringAttack(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "SetHideIndicatorDuringAttack");

	Params::ObjectPlacerComponent_SetHideIndicatorDuringAttack Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacerComponent.SetIndicatorOffsetX
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   x                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectPlacerComponent::SetIndicatorOffsetX(float x)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "SetIndicatorOffsetX");

	Params::ObjectPlacerComponent_SetIndicatorOffsetX Parms{};

	Parms.x = x;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacerComponent.SetIndicatorOffsetY
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectPlacerComponent::SetIndicatorOffsetY(float y)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "SetIndicatorOffsetY");

	Params::ObjectPlacerComponent_SetIndicatorOffsetY Parms{};

	Parms.y = y;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacerComponent.SetMeshOffsetZ
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectPlacerComponent::SetMeshOffsetZ(float z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "SetMeshOffsetZ");

	Params::ObjectPlacerComponent_SetMeshOffsetZ Parms{};

	Parms.z = z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacerComponent.SetObjectMesh
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             objectMesh                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectPlacerComponent::SetObjectMesh(class UStaticMeshComponent* objectMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "SetObjectMesh");

	Params::ObjectPlacerComponent_SetObjectMesh Parms{};

	Parms.objectMesh = objectMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacerComponent.SetShowIndicator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    newValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectPlacerComponent::SetShowIndicator(bool newValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "SetShowIndicator");

	Params::ObjectPlacerComponent_SetShowIndicator Parms{};

	Parms.newValue = newValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ObjectPlacerComponent.GetObjectPlacementLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UObjectPlacerComponent::GetObjectPlacementLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "GetObjectPlacementLocation");

	Params::ObjectPlacerComponent_GetObjectPlacementLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ObjectPlacerComponent.GetObjectPlacementRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UObjectPlacerComponent::GetObjectPlacementRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "GetObjectPlacementRotation");

	Params::ObjectPlacerComponent_GetObjectPlacementRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ObjectPlacerComponent.IsPlacementValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObjectPlacerComponent::IsPlacementValid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPlacerComponent", "IsPlacementValid");

	Params::ObjectPlacerComponent_IsPlacementValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingCard.ChangeAnimationClass
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TSubclassOf<class UOfferingCardAnim>&animationClass                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOfferingCard::ChangeAnimationClass(const TSubclassOf<class UOfferingCardAnim>& animationClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingCard", "ChangeAnimationClass");

	Params::OfferingCard_ChangeAnimationClass Parms{};

	Parms.animationClass = animationClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OfferingCard.ChangeState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOfferingAnimState                      state                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOfferingCard::ChangeState(EOfferingAnimState state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingCard", "ChangeState");

	Params::OfferingCard_ChangeState Parms{};

	Parms.state = state;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OfferingCard.HandleCardDissolved
// (Event, Protected, BlueprintEvent)

void AOfferingCard::HandleCardDissolved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingCard", "HandleCardDissolved");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.OfferingCard.HandleStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EOfferingAnimState                      state                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOfferingCard::HandleStateChanged(EOfferingAnimState state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingCard", "HandleStateChanged");

	Params::OfferingCard_HandleStateChanged Parms{};

	Parms.state = state;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.OfferingCard.GetCardAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOfferingCardAnim*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOfferingCardAnim* AOfferingCard::GetCardAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingCard", "GetCardAnimation");

	Params::OfferingCard_GetCardAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingCard.GetState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOfferingAnimState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOfferingAnimState AOfferingCard::GetState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingCard", "GetState");

	Params::OfferingCard_GetState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingCard.IsRevealed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOfferingCard::IsRevealed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingCard", "IsRevealed");

	Params::OfferingCard_IsRevealed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingEffectCollection.HasOfferingOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOfferingEffectType                     type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   playerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOfferingEffectCollection::HasOfferingOfType(EOfferingEffectType type, int32 playerId, class FName tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingEffectCollection", "HasOfferingOfType");

	Params::OfferingEffectCollection_HasOfferingOfType Parms{};

	Parms.type = type;
	Parms.playerId = playerId;
	Parms.tag = tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingEffectCollection.HasOfferingWithTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   playerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOfferingEffectCollection::HasOfferingWithTag(int32 playerId, class FName tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingEffectCollection", "HasOfferingWithTag");

	Params::OfferingEffectCollection_HasOfferingWithTag Parms{};

	Parms.playerId = playerId;
	Parms.tag = tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.OfferingSequenceAssets.PlayFadeIn
// (Event, Public, BlueprintEvent)

void AOfferingSequenceAssets::PlayFadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceAssets", "PlayFadeIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.OfferingSequenceAssets.PlayFadeOut
// (Event, Public, BlueprintEvent)

void AOfferingSequenceAssets::PlayFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceAssets", "PlayFadeOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.OfferingSequenceAssets.PlaySmoke
// (Event, Public, BlueprintEvent)

void AOfferingSequenceAssets::PlaySmoke()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfferingSequenceAssets", "PlaySmoke");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.OfflineLobbyLevel.CheckDestroyingPawns
// (Final, Native, Protected)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOfflineLobbyLevel::CheckDestroyingPawns(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfflineLobbyLevel", "CheckDestroyingPawns");

	Params::OfflineLobbyLevel_CheckDestroyingPawns Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OfflineLobbyLevel.OnStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EOfflineLobbyState                      lobbyState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOfflineLobbyLevel::OnStateChanged(EOfflineLobbyState lobbyState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OfflineLobbyLevel", "OnStateChanged");

	Params::OfflineLobbyLevel_OnStateChanged Parms{};

	Parms.lobbyState = lobbyState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.OniDemonModeAttackStateComponent.Multicast_ClearChargingState
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UOniDemonModeAttackStateComponent::Multicast_ClearChargingState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OniDemonModeAttackStateComponent", "Multicast_ClearChargingState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OniDemonModeAttackStateComponent.Server_ClearChargingState
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UOniDemonModeAttackStateComponent::Server_ClearChargingState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OniDemonModeAttackStateComponent", "Server_ClearChargingState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OtherCharactersVerticalCollisionsHandler.InitializeOverlapDetection
// (Final, Native, Private)

void UOtherCharactersVerticalCollisionsHandler::InitializeOverlapDetection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OtherCharactersVerticalCollisionsHandler", "InitializeOverlapDetection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OtherCharactersVerticalCollisionsHandler.OnPawnDetectorOverlapEnter
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              hitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           otherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              otherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   otherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                sweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOtherCharactersVerticalCollisionsHandler::OnPawnDetectorOverlapEnter(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OtherCharactersVerticalCollisionsHandler", "OnPawnDetectorOverlapEnter");

	Params::OtherCharactersVerticalCollisionsHandler_OnPawnDetectorOverlapEnter Parms{};

	Parms.hitComponent = hitComponent;
	Parms.otherActor = otherActor;
	Parms.otherComp = otherComp;
	Parms.otherBodyIndex = otherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.sweepResult = std::move(sweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OtherCharactersVerticalCollisionsHandler.OnPawnDetectorOverlapExit
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              hitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           otherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              otherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   otherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOtherCharactersVerticalCollisionsHandler::OnPawnDetectorOverlapExit(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OtherCharactersVerticalCollisionsHandler", "OnPawnDetectorOverlapExit");

	Params::OtherCharactersVerticalCollisionsHandler_OnPawnDetectorOverlapExit Parms{};

	Parms.hitComponent = hitComponent;
	Parms.otherActor = otherActor;
	Parms.otherComp = otherComp;
	Parms.otherBodyIndex = otherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OtherCharactersVerticalCollisionsHandler.SetPawnDetector
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCapsuleComponent*                pawnDetector                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOtherCharactersVerticalCollisionsHandler::SetPawnDetector(class UCapsuleComponent* pawnDetector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OtherCharactersVerticalCollisionsHandler", "SetPawnDetector");

	Params::OtherCharactersVerticalCollisionsHandler_SetPawnDetector Parms{};

	Parms.pawnDetector = pawnDetector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OutOfSightMeshRotator.SetMeshesToRotate
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const TArray<class UMeshComponent*>&    meshesToRotate                                         (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOutOfSightMeshRotator::SetMeshesToRotate(const TArray<class UMeshComponent*>& meshesToRotate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OutOfSightMeshRotator", "SetMeshesToRotate");

	Params::OutOfSightMeshRotator_SetMeshesToRotate Parms{};

	Parms.meshesToRotate = std::move(meshesToRotate);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnAimAssistClick
// (Final, Native, Public)
// Parameters:
// bool                                    value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnAimAssistClick(bool value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnAimAssistClick");

	Params::OverlayMenuScreen_OnAimAssistClick Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnAtlantaSettingButtonClick
// (Final, Native, Public)
// Parameters:
// int32                                   buttonID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnAtlantaSettingButtonClick(int32 buttonID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnAtlantaSettingButtonClick");

	Params::OverlayMenuScreen_OnAtlantaSettingButtonClick Parms{};

	Parms.buttonID = buttonID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnBackButtonClick
// (Final, Native, Public)

void UOverlayMenuScreen::OnBackButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnBackButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnCustomerSupportButtonClick
// (Final, Native, Public)

void UOverlayMenuScreen::OnCustomerSupportButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnCustomerSupportButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnEULAButtonClick
// (Final, Native, Public)

void UOverlayMenuScreen::OnEULAButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnEULAButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnForumsButtonClick
// (Final, Native, Public)

void UOverlayMenuScreen::OnForumsButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnForumsButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnKillerCameraSensitivityChanged
// (Final, Native, Public)
// Parameters:
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnKillerCameraSensitivityChanged(int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnKillerCameraSensitivityChanged");

	Params::OverlayMenuScreen_OnKillerCameraSensitivityChanged Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnLanguageChange
// (Final, Native, Public)
// Parameters:
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnLanguageChange(int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnLanguageChange");

	Params::OverlayMenuScreen_OnLanguageChange Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnPlayerInfoClick
// (Final, Native, Public)
// Parameters:
// const class FString&                    playerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnPlayerInfoClick(const class FString& playerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnPlayerInfoClick");

	Params::OverlayMenuScreen_OnPlayerInfoClick Parms{};

	Parms.playerId = std::move(playerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnPrivacyPolicyButtonClick
// (Final, Native, Public)

void UOverlayMenuScreen::OnPrivacyPolicyButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnPrivacyPolicyButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnQuitButtonClick
// (Final, Native, Public)

void UOverlayMenuScreen::OnQuitButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnQuitButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnRequestKeyBindingInput
// (Final, Native, Public)
// Parameters:
// int32                                   id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnRequestKeyBindingInput(int32 id, const class FString& key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnRequestKeyBindingInput");

	Params::OverlayMenuScreen_OnRequestKeyBindingInput Parms{};

	Parms.id = id;
	Parms.key = std::move(key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnResetDefaultKeybindings
// (Final, Native, Public)

void UOverlayMenuScreen::OnResetDefaultKeybindings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnResetDefaultKeybindings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnResetDefaultSettings
// (Final, Native, Public)

void UOverlayMenuScreen::OnResetDefaultSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnResetDefaultSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnSelectTab
// (Final, Native, Public)
// Parameters:
// int32                                   tabIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnSelectTab(int32 tabIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnSelectTab");

	Params::OverlayMenuScreen_OnSelectTab Parms{};

	Parms.tabIndex = tabIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnSettingsOptionButtonClicked
// (Final, Native, Public)
// Parameters:
// int32                                   id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnSettingsOptionButtonClicked(int32 id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnSettingsOptionButtonClicked");

	Params::OverlayMenuScreen_OnSettingsOptionButtonClicked Parms{};

	Parms.id = id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnSettingsOptionCheckboxSelected
// (Final, Native, Public)
// Parameters:
// int32                                   id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isSelected                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnSettingsOptionCheckboxSelected(int32 id, bool isSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnSettingsOptionCheckboxSelected");

	Params::OverlayMenuScreen_OnSettingsOptionCheckboxSelected Parms{};

	Parms.id = id;
	Parms.isSelected = isSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnSettingsOptionIntValueChanged
// (Final, Native, Public)
// Parameters:
// int32                                   id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnSettingsOptionIntValueChanged(int32 id, int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnSettingsOptionIntValueChanged");

	Params::OverlayMenuScreen_OnSettingsOptionIntValueChanged Parms{};

	Parms.id = id;
	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.OnSurvivorCameraSensitivityChanged
// (Final, Native, Public)
// Parameters:
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::OnSurvivorCameraSensitivityChanged(int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "OnSurvivorCameraSensitivityChanged");

	Params::OverlayMenuScreen_OnSurvivorCameraSensitivityChanged Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.OverlayMenuScreen.SetGameType
// (Final, Native, Public)
// Parameters:
// EGameType                               gameType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isInCustomMatchManagerMode                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOverlayMenuScreen::SetGameType(EGameType gameType, bool isInCustomMatchManagerMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OverlayMenuScreen", "SetGameType");

	Params::OverlayMenuScreen_SetGameType Parms{};

	Parms.gameType = gameType;
	Parms.isInCustomMatchManagerMode = isInCustomMatchManagerMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.Authority_OnOverlapPushBox
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              overlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           otherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              otherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   otherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                sweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APallet::Authority_OnOverlapPushBox(class UPrimitiveComponent* overlappedComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "Authority_OnOverlapPushBox");

	Params::Pallet_Authority_OnOverlapPushBox Parms{};

	Parms.overlappedComponent = overlappedComponent;
	Parms.otherActor = otherActor;
	Parms.otherComp = otherComp;
	Parms.otherBodyIndex = otherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.sweepResult = std::move(sweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.Cosmetic_OnPalletPulldownBlockedByEntityHide
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)

void APallet::Cosmetic_OnPalletPulldownBlockedByEntityHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "Cosmetic_OnPalletPulldownBlockedByEntityHide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Pallet.Cosmetic_OnPalletPulldownBlockedByEntityShow
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)

void APallet::Cosmetic_OnPalletPulldownBlockedByEntityShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "Cosmetic_OnPalletPulldownBlockedByEntityShow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Pallet.Cosmetic_PalletPullDownFXImmediateHide
// (BlueprintCosmetic, Event, Protected, BlueprintCallable, BlueprintEvent)

void APallet::Cosmetic_PalletPullDownFXImmediateHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "Cosmetic_PalletPullDownFXImmediateHide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Pallet.EntityExplodePallet
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::EntityExplodePallet(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "EntityExplodePallet");

	Params::Pallet_EntityExplodePallet Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Pallet.ExplodePallet
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::ExplodePallet(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "ExplodePallet");

	Params::Pallet_ExplodePallet Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Pallet.ExplodeStunPallet
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::ExplodeStunPallet(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "ExplodeStunPallet");

	Params::Pallet_ExplodeStunPallet Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Pallet.Multicast_EntityExplodePallet
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::Multicast_EntityExplodePallet(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "Multicast_EntityExplodePallet");

	Params::Pallet_Multicast_EntityExplodePallet Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.Multicast_PulldownPallet
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void APallet::Multicast_PulldownPallet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "Multicast_PulldownPallet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.Multicast_ResetPallet
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void APallet::Multicast_ResetPallet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "Multicast_ResetPallet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.Multicast_StunActor
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class AActor*                           actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    stunBreakPallet                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::Multicast_StunActor(class AActor* actor, class ACamperPlayer* survivor, bool stunBreakPallet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "Multicast_StunActor");

	Params::Pallet_Multicast_StunActor Parms{};

	Parms.actor = actor;
	Parms.survivor = survivor;
	Parms.stunBreakPallet = stunBreakPallet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.OnFallen
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void APallet::OnFallen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "OnFallen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Pallet.OnPalletPulledUp_BP
// (Event, Protected, BlueprintEvent)

void APallet::OnPalletPulledUp_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "OnPalletPulledUp_BP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Pallet.OnPalletStunHit
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void APallet::OnPalletStunHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "OnPalletStunHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Pallet.OnStunOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              overlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           otherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              otherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   otherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                sweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APallet::OnStunOverlap(class UPrimitiveComponent* overlappedComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "OnStunOverlap");

	Params::Pallet_OnStunOverlap Parms{};

	Parms.overlappedComponent = overlappedComponent;
	Parms.otherActor = otherActor;
	Parms.otherComp = otherComp;
	Parms.otherBodyIndex = otherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.sweepResult = std::move(sweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.PullDown
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPalletPushSettings&       pushSettings                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const EPalletStunZoneSideStrategy       stunZoneSideStrategy                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::PullDown(class ADBDPlayer* player, const struct FPalletPushSettings& pushSettings, const EPalletStunZoneSideStrategy stunZoneSideStrategy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "PullDown");

	Params::Pallet_PullDown Parms{};

	Parms.player = player;
	Parms.pushSettings = std::move(pushSettings);
	Parms.stunZoneSideStrategy = stunZoneSideStrategy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.PulldownPallet
// (Event, Public, BlueprintCallable, BlueprintEvent)

void APallet::PulldownPallet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "PulldownPallet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Pallet.ResetPallet
// (Event, Protected, BlueprintEvent)

void APallet::ResetPallet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "ResetPallet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.Pallet.SetPalletState
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EPalletState                            state                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::SetPalletState(EPalletState state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "SetPalletState");

	Params::Pallet_SetPalletState Parms{};

	Parms.state = state;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.SetPendingDestruction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isPendingDestruction                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APallet::SetPendingDestruction(bool isPendingDestruction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "SetPendingDestruction");

	Params::Pallet_SetPendingDestruction Parms{};

	Parms.isPendingDestruction = isPendingDestruction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Pallet.CanPulldown
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   interactionAxis                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              isStationary                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APallet::CanPulldown(const class ADBDPlayer* player, const struct FVector& interactionAxis, const bool isStationary) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "CanPulldown");

	Params::Pallet_CanPulldown Parms{};

	Parms.player = player;
	Parms.interactionAxis = std::move(interactionAxis);
	Parms.isStationary = isStationary;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.GetDestructibleAreaPrimitiveComponents
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TArray<class UPrimitiveComponent*>*     prims                                                  (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APallet::GetDestructibleAreaPrimitiveComponents(TArray<class UPrimitiveComponent*>* prims) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "GetDestructibleAreaPrimitiveComponents");

	Params::Pallet_GetDestructibleAreaPrimitiveComponents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (prims != nullptr)
		*prims = std::move(Parms.prims);
}


// Function DeadByDaylight.Pallet.GetFallDuration
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float APallet::GetFallDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "GetFallDuration");

	Params::Pallet_GetFallDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.GetIsDreamPallet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APallet::GetIsDreamPallet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "GetIsDreamPallet");

	Params::Pallet_GetIsDreamPallet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.GetIsPulledDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APallet::GetIsPulledDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "GetIsPulledDown");

	Params::Pallet_GetIsPulledDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.GetPalletSkeletalMeshComponent
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* APallet::GetPalletSkeletalMeshComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "GetPalletSkeletalMeshComponent");

	Params::Pallet_GetPalletSkeletalMeshComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.GetPlayerDoingPulldown
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* APallet::GetPlayerDoingPulldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "GetPlayerDoingPulldown");

	Params::Pallet_GetPlayerDoingPulldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.IsDestroyedByEntity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APallet::IsDestroyedByEntity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "IsDestroyedByEntity");

	Params::Pallet_IsDestroyedByEntity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.IsPendingDestruction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APallet::IsPendingDestruction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "IsPendingDestruction");

	Params::Pallet_IsPendingDestruction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Pallet.IsPulldownBlockedByEntity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APallet::IsPulldownBlockedByEntity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Pallet", "IsPulldownBlockedByEntity");

	Params::Pallet_IsPulldownBlockedByEntity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PalletPulldownBlockerComponent.Multicast_PalletPulldownBlockedHideCosmetic
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UObject*                          palletToUnblock                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPalletPulldownBlockerComponent::Multicast_PalletPulldownBlockedHideCosmetic(class UObject* palletToUnblock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletPulldownBlockerComponent", "Multicast_PalletPulldownBlockedHideCosmetic");

	Params::PalletPulldownBlockerComponent_Multicast_PalletPulldownBlockedHideCosmetic Parms{};

	Parms.palletToUnblock = palletToUnblock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PalletPulldownBlockerComponent.Multicast_PalletPulldownBlockedShowCosmetic
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UObject*                          palletToBlock                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPalletPulldownBlockerComponent::Multicast_PalletPulldownBlockedShowCosmetic(class UObject* palletToBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletPulldownBlockerComponent", "Multicast_PalletPulldownBlockedShowCosmetic");

	Params::PalletPulldownBlockerComponent_Multicast_PalletPulldownBlockedShowCosmetic Parms{};

	Parms.palletToBlock = palletToBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PalletPulldownBlockerComponent.OnRep_PalletToBlock
// (Final, Native, Private)
// Parameters:
// class UObject*                          oldPalletToBlock                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPalletPulldownBlockerComponent::OnRep_PalletToBlock(class UObject* oldPalletToBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletPulldownBlockerComponent", "OnRep_PalletToBlock");

	Params::PalletPulldownBlockerComponent_OnRep_PalletToBlock Parms{};

	Parms.oldPalletToBlock = oldPalletToBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PalletTracker.EnableSelectedEffectToLocalPlayer
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    activated                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APalletTracker::EnableSelectedEffectToLocalPlayer(bool activated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletTracker", "EnableSelectedEffectToLocalPlayer");

	Params::PalletTracker_EnableSelectedEffectToLocalPlayer Parms{};

	Parms.activated = activated;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.PalletTracker.InitializeTunableValues
// (Final, Native, Private)
// Parameters:
// class ASlasherPlayer*                   slasher                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APalletTracker::InitializeTunableValues(class ASlasherPlayer* slasher)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletTracker", "InitializeTunableValues");

	Params::PalletTracker_InitializeTunableValues Parms{};

	Parms.slasher = slasher;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PalletTracker.RevealToLocalPlayerBP
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    shown                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APalletTracker::RevealToLocalPlayerBP(bool shown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletTracker", "RevealToLocalPlayerBP");

	Params::PalletTracker_RevealToLocalPlayerBP Parms{};

	Parms.shown = shown;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.PalletTracker.CanSpawnDreamPalletAtLocation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APalletTracker::CanSpawnDreamPalletAtLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PalletTracker", "CanSpawnDreamPalletAtLocation");

	Params::PalletTracker_CanSpawnDreamPalletAtLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PalletUtilities.GetDreamPalletBP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> UPalletUtilities::GetDreamPalletBP(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PalletUtilities", "GetDreamPalletBP");

	Params::PalletUtilities_GetDreamPalletBP Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PalletUtilities.GetIllusionaryPalletStaticMesh
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    worldContextObjec                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UStaticMesh>       ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UStaticMesh> UPalletUtilities::GetIllusionaryPalletStaticMesh(const class UObject* worldContextObjec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PalletUtilities", "GetIllusionaryPalletStaticMesh");

	Params::PalletUtilities_GetIllusionaryPalletStaticMesh Parms{};

	Parms.worldContextObjec = worldContextObjec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PalletUtilities.GetPalletTrackerBP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> UPalletUtilities::GetPalletTrackerBP(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PalletUtilities", "GetPalletTrackerBP");

	Params::PalletUtilities_GetPalletTrackerBP Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PanelScreen.OnAvailableItemClicked
// (Final, Native, Public)
// Parameters:
// int32                                   clickedItemIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnAvailableItemClicked(int32 clickedItemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnAvailableItemClicked");

	Params::PanelScreen_OnAvailableItemClicked Parms{};

	Parms.clickedItemIndex = clickedItemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnAvailableItemsSortingChange
// (Final, Native, Public)
// Parameters:
// int32                                   newSorting                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnAvailableItemsSortingChange(int32 newSorting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnAvailableItemsSortingChange");

	Params::PanelScreen_OnAvailableItemsSortingChange Parms{};

	Parms.newSorting = newSorting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnBloodwebCenterButtonSelected
// (Final, Native, Public)

void UPanelScreen::OnBloodwebCenterButtonSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnBloodwebCenterButtonSelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnCharacterInfoClick
// (Final, Native, Public)

void UPanelScreen::OnCharacterInfoClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnCharacterInfoClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnCharacterSlotButtonClick
// (Final, Native, Public)
// Parameters:
// int32                                   characterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnCharacterSlotButtonClick(int32 characterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnCharacterSlotButtonClick");

	Params::PanelScreen_OnCharacterSlotButtonClick Parms{};

	Parms.characterIndex = characterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnCharInfoClick
// (Final, Native, Public)

void UPanelScreen::OnCharInfoClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnCharInfoClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnConfirmCollectSelectedNode
// (Final, Native, Public)
// Parameters:
// int32                                   characterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnConfirmCollectSelectedNode(int32 characterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnConfirmCollectSelectedNode");

	Params::PanelScreen_OnConfirmCollectSelectedNode Parms{};

	Parms.characterId = characterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnCrowdChoiceCharacterClick
// (Final, Native, Public)

void UPanelScreen::OnCrowdChoiceCharacterClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnCrowdChoiceCharacterClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnCustomizationPresetClick
// (Final, Native, Public)
// Parameters:
// int32                                   index                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnCustomizationPresetClick(int32 index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnCustomizationPresetClick");

	Params::PanelScreen_OnCustomizationPresetClick Parms{};

	Parms.index = index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnEquipableSlotClicked
// (Final, Native, Public)
// Parameters:
// int32                                   clickedSlotCategory                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   clickedSlotIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnEquipableSlotClicked(int32 clickedSlotCategory, int32 clickedSlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnEquipableSlotClicked");

	Params::PanelScreen_OnEquipableSlotClicked Parms{};

	Parms.clickedSlotCategory = clickedSlotCategory;
	Parms.clickedSlotIndex = clickedSlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnEventButtonClick
// (Final, Native, Public)

void UPanelScreen::OnEventButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnEventButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnItemSelected
// (Final, Native, Public)
// Parameters:
// int32                                   itemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnItemSelected(int32 itemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnItemSelected");

	Params::PanelScreen_OnItemSelected Parms{};

	Parms.itemIndex = itemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnItemUnselected
// (Final, Native, Public)
// Parameters:
// int32                                   itemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnItemUnselected(int32 itemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnItemUnselected");

	Params::PanelScreen_OnItemUnselected Parms{};

	Parms.itemIndex = itemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnLoadoutPresetClick
// (Final, Native, Public)
// Parameters:
// int32                                   index                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnLoadoutPresetClick(int32 index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnLoadoutPresetClick");

	Params::PanelScreen_OnLoadoutPresetClick Parms{};

	Parms.index = index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnLoadoutSlotButtonClick
// (Final, Native, Public)
// Parameters:
// int32                                   slotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnLoadoutSlotButtonClick(int32 slotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnLoadoutSlotButtonClick");

	Params::PanelScreen_OnLoadoutSlotButtonClick Parms{};

	Parms.slotIndex = slotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnNodeCollectionAnimDone
// (Final, Native, Public)

void UPanelScreen::OnNodeCollectionAnimDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnNodeCollectionAnimDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnNodeConsumptionAnimDone
// (Final, Native, Public)

void UPanelScreen::OnNodeConsumptionAnimDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnNodeConsumptionAnimDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnPanelsHidden
// (Final, Native, Public)

void UPanelScreen::OnPanelsHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnPanelsHidden");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnPrestigeUp
// (Final, Native, Public)
// Parameters:
// int32                                   characterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnPrestigeUp(int32 characterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnPrestigeUp");

	Params::PanelScreen_OnPrestigeUp Parms{};

	Parms.characterId = characterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnRegenerateButtonClick
// (Final, Native, Public)
// Parameters:
// int32                                   characterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnRegenerateButtonClick(int32 characterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnRegenerateButtonClick");

	Params::PanelScreen_OnRegenerateButtonClick Parms{};

	Parms.characterId = characterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnReservedBloodPoints
// (Final, Native, Public)
// Parameters:
// int32                                   characterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   bloodPoints                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    fullCost                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnReservedBloodPoints(int32 characterId, int32 bloodPoints, bool fullCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnReservedBloodPoints");

	Params::PanelScreen_OnReservedBloodPoints Parms{};

	Parms.characterId = characterId;
	Parms.bloodPoints = bloodPoints;
	Parms.fullCost = fullCost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnRoleButtonClick
// (Final, Native, Public)

void UPanelScreen::OnRoleButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnRoleButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnRotateCharacter
// (Final, Native, Public)
// Parameters:
// float                                   mouseDistanceChange                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnRotateCharacter(float mouseDistanceChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnRotateCharacter");

	Params::PanelScreen_OnRotateCharacter Parms{};

	Parms.mouseDistanceChange = mouseDistanceChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnSelectedEquipableSlotZoomChange
// (Final, Native, Public)
// Parameters:
// bool                                    zoomIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnSelectedEquipableSlotZoomChange(bool zoomIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnSelectedEquipableSlotZoomChange");

	Params::PanelScreen_OnSelectedEquipableSlotZoomChange Parms{};

	Parms.zoomIn = zoomIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnSequenceStepCompleted
// (Final, Native, Public)
// Parameters:
// int32                                   characterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnSequenceStepCompleted(int32 characterId, int32 id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnSequenceStepCompleted");

	Params::PanelScreen_OnSequenceStepCompleted Parms{};

	Parms.characterId = characterId;
	Parms.id = id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnSideTabButtonClick
// (Final, Native, Public)
// Parameters:
// int32                                   tabIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnSideTabButtonClick(int32 tabIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnSideTabButtonClick");

	Params::PanelScreen_OnSideTabButtonClick Parms{};

	Parms.tabIndex = tabIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnStoreButtonClick
// (Final, Native, Public)

void UPanelScreen::OnStoreButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnStoreButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnWebBuilt
// (Final, Native, Public)
// Parameters:
// int32                                   characterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isEmpty                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnWebBuilt(int32 characterId, bool isEmpty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnWebBuilt");

	Params::PanelScreen_OnWebBuilt Parms{};

	Parms.characterId = characterId;
	Parms.isEmpty = isEmpty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnWebNodeHovered
// (Final, Native, Public)
// Parameters:
// int32                                   id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnWebNodeHovered(int32 id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnWebNodeHovered");

	Params::PanelScreen_OnWebNodeHovered Parms{};

	Parms.id = id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PanelScreen.OnWebNodeSelected
// (Final, Native, Public)
// Parameters:
// int32                                   characterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   nodeDepth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPanelScreen::OnWebNodeSelected(int32 characterId, int32 id, int32 nodeDepth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PanelScreen", "OnWebNodeSelected");

	Params::PanelScreen_OnWebNodeSelected Parms{};

	Parms.characterId = characterId;
	Parms.id = id;
	Parms.nodeDepth = nodeDepth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkActionButton.CallHidePerkLevel
// (Event, Public, BlueprintEvent)

void UPerkActionButton::CallHidePerkLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkActionButton", "CallHidePerkLevel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.PerkActionButton.CallSetPerkLevel
// (Event, Public, BlueprintEvent)
// Parameters:
// const int32                             level                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkActionButton::CallSetPerkLevel(const int32 level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkActionButton", "CallSetPerkLevel");

	Params::PerkActionButton_CallSetPerkLevel Parms{};

	Parms.level = level;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.PerkActionButton.SetCanEverBeActivated
// (Event, Public, BlueprintEvent)

void UPerkActionButton::SetCanEverBeActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkActionButton", "SetCanEverBeActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.PerkActionButton.SetIsActivatable
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isClickable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkActionButton::SetIsActivatable(bool isClickable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkActionButton", "SetIsActivatable");

	Params::PerkActionButton_SetIsActivatable Parms{};

	Parms.isClickable = isClickable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.PerkActionButton.UpdateWidgetPercentage
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkActionButton::UpdateWidgetPercentage(float percentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkActionButton", "UpdateWidgetPercentage");

	Params::PerkActionButton_UpdateWidgetPercentage Parms{};

	Parms.percentage = percentage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.PerkHudWidget.OnPerkClickedHandler
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             perkID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkHudWidget::OnPerkClickedHandler(class FName perkID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkHudWidget", "OnPerkClickedHandler");

	Params::PerkHudWidget_OnPerkClickedHandler Parms{};

	Parms.perkID = perkID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.PerkHudWidget.RemoveExistingPerk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             perkID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isExternal                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkHudWidget::RemoveExistingPerk(class FName perkID, bool isExternal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkHudWidget", "RemoveExistingPerk");

	Params::PerkHudWidget_RemoveExistingPerk Parms{};

	Parms.perkID = perkID;
	Parms.isExternal = isExternal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkManager.Authority_EndStatusEffectByID
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             statusEffectId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveAllWithID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkManager::Authority_EndStatusEffectByID(class FName statusEffectId, bool bRemoveAllWithID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_EndStatusEffectByID");

	Params::PerkManager_Authority_EndStatusEffectByID Parms{};

	Parms.statusEffectId = statusEffectId;
	Parms.bRemoveAllWithID = bRemoveAllWithID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkManager.Authority_ImposeDynamicStatusEffect_DEPRECATED
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             statusEffectID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       originatingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   customParam                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer*       originatingEffect                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStatusEffect* UPerkManager::Authority_ImposeDynamicStatusEffect_DEPRECATED(class FName statusEffectID, class ADBDPlayer* originatingPlayer, float customParam, class UGameplayModifierContainer* originatingEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_ImposeDynamicStatusEffect_DEPRECATED");

	Params::PerkManager_Authority_ImposeDynamicStatusEffect_DEPRECATED Parms{};

	Parms.statusEffectID = statusEffectID;
	Parms.originatingPlayer = originatingPlayer;
	Parms.customParam = customParam;
	Parms.originatingEffect = originatingEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.Authority_ImposeNewStatusEffectOfClassOrChangeLifeTime
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UStatusEffect>        effectClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       originatingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   lifeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   customParam                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer*       originatingEffect                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    shouldDisplay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStatusEffect* UPerkManager::Authority_ImposeNewStatusEffectOfClassOrChangeLifeTime(TSubclassOf<class UStatusEffect> effectClass, class ADBDPlayer* originatingPlayer, float lifeTime, float customParam, class UGameplayModifierContainer* originatingEffect, bool shouldDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_ImposeNewStatusEffectOfClassOrChangeLifeTime");

	Params::PerkManager_Authority_ImposeNewStatusEffectOfClassOrChangeLifeTime Parms{};

	Parms.effectClass = effectClass;
	Parms.originatingPlayer = originatingPlayer;
	Parms.lifeTime = lifeTime;
	Parms.customParam = customParam;
	Parms.originatingEffect = originatingEffect;
	Parms.shouldDisplay = shouldDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.Authority_ImposeNewStatusEffectOrChangeLifeTime_DEPRECATED
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             statusEffectID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       originatingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   lifeTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   customParam                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer*       originatingEffect                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    shouldDisplay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStatusEffect* UPerkManager::Authority_ImposeNewStatusEffectOrChangeLifeTime_DEPRECATED(class FName statusEffectID, class ADBDPlayer* originatingPlayer, float lifeTime, float customParam, class UGameplayModifierContainer* originatingEffect, bool shouldDisplay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_ImposeNewStatusEffectOrChangeLifeTime_DEPRECATED");

	Params::PerkManager_Authority_ImposeNewStatusEffectOrChangeLifeTime_DEPRECATED Parms{};

	Parms.statusEffectID = statusEffectID;
	Parms.originatingPlayer = originatingPlayer;
	Parms.lifeTime = lifeTime;
	Parms.customParam = customParam;
	Parms.originatingEffect = originatingEffect;
	Parms.shouldDisplay = shouldDisplay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.Authority_ImposeStatusEffect_DEPRECATED
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             statusEffectID                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       originatingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   customParam                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer*       originatingEffect                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    shouldDisplay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStatusEffect* UPerkManager::Authority_ImposeStatusEffect_DEPRECATED(class FName statusEffectID, class ADBDPlayer* originatingPlayer, float customParam, class UGameplayModifierContainer* originatingEffect, bool shouldDisplay, float lifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_ImposeStatusEffect_DEPRECATED");

	Params::PerkManager_Authority_ImposeStatusEffect_DEPRECATED Parms{};

	Parms.statusEffectID = statusEffectID;
	Parms.originatingPlayer = originatingPlayer;
	Parms.customParam = customParam;
	Parms.originatingEffect = originatingEffect;
	Parms.shouldDisplay = shouldDisplay;
	Parms.lifetime = lifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.Authority_ImposeStatusEffectOfClass
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UStatusEffect>        effectClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       originatingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   customParam                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer*       originatingEffect                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    shouldDisplay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStatusEffect* UPerkManager::Authority_ImposeStatusEffectOfClass(TSubclassOf<class UStatusEffect> effectClass, class ADBDPlayer* originatingPlayer, float customParam, class UGameplayModifierContainer* originatingEffect, bool shouldDisplay, float lifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_ImposeStatusEffectOfClass");

	Params::PerkManager_Authority_ImposeStatusEffectOfClass Parms{};

	Parms.effectClass = effectClass;
	Parms.originatingPlayer = originatingPlayer;
	Parms.customParam = customParam;
	Parms.originatingEffect = originatingEffect;
	Parms.shouldDisplay = shouldDisplay;
	Parms.lifetime = lifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.Authority_RemovePerks
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UPerkManager::Authority_RemovePerks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_RemovePerks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkManager.Authority_RemoveStatusEffect
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UStatusEffect*                    statusEffect                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkManager::Authority_RemoveStatusEffect(class UStatusEffect* statusEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_RemoveStatusEffect");

	Params::PerkManager_Authority_RemoveStatusEffect Parms{};

	Parms.statusEffect = statusEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkManager.Authority_RemoveStatusEffectByID
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             statusEffectId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveAllWithID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkManager::Authority_RemoveStatusEffectByID(class FName statusEffectId, bool bRemoveAllWithID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_RemoveStatusEffectByID");

	Params::PerkManager_Authority_RemoveStatusEffectByID Parms{};

	Parms.statusEffectId = statusEffectId;
	Parms.bRemoveAllWithID = bRemoveAllWithID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkManager.Authority_SpawnPerk
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             perkID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   perkLevel                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkManager::Authority_SpawnPerk(class FName perkID, int32 perkLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "Authority_SpawnPerk");

	Params::PerkManager_Authority_SpawnPerk Parms{};

	Parms.perkID = perkID;
	Parms.perkLevel = perkLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerkManager.GetAllSourcesWithFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              flag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UGameplayModifierContainer*>ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UGameplayModifierContainer*> UPerkManager::GetAllSourcesWithFlag(const struct FGameplayTag& flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetAllSourcesWithFlag");

	Params::PerkManager_GetAllSourcesWithFlag Parms{};

	Parms.flag = std::move(flag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetAllSourcesWithModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UGameplayModifierContainer*>ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UGameplayModifierContainer*> UPerkManager::GetAllSourcesWithModifier(const struct FGameplayTag& type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetAllSourcesWithModifier");

	Params::PerkManager_GetAllSourcesWithModifier Parms{};

	Parms.type = std::move(type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetAllStatusEffects
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UStatusEffect*>            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UStatusEffect*> UPerkManager::GetAllStatusEffects() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetAllStatusEffects");

	Params::PerkManager_GetAllStatusEffects Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetAllStatusEffectsByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UClass*                     type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UStatusEffect*>            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UStatusEffect*> UPerkManager::GetAllStatusEffectsByClass(const class UClass* type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetAllStatusEffectsByClass");

	Params::PerkManager_GetAllStatusEffectsByClass Parms{};

	Parms.type = type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetAllStatusEffectsByID
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      id                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UStatusEffect*>            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UStatusEffect*> UPerkManager::GetAllStatusEffectsByID(const class FName& id) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetAllStatusEffectsByID");

	Params::PerkManager_GetAllStatusEffectsByID Parms{};

	Parms.id = id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetCompoundedModifierValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetCompoundedModifierValue(const struct FGameplayTag& type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetCompoundedModifierValue");

	Params::PerkManager_GetCompoundedModifierValue Parms{};

	Parms.type = std::move(type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetMultiplicativeModifierValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetMultiplicativeModifierValue(const struct FGameplayTag& type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetMultiplicativeModifierValue");

	Params::PerkManager_GetMultiplicativeModifierValue Parms{};

	Parms.type = std::move(type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetMultiplicativeModifierValueOfContainerWithCompoundNegative
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTagContainer&     container                                              (Parm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetMultiplicativeModifierValueOfContainerWithCompoundNegative(const struct FGameplayTagContainer& container) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetMultiplicativeModifierValueOfContainerWithCompoundNegative");

	Params::PerkManager_GetMultiplicativeModifierValueOfContainerWithCompoundNegative Parms{};

	Parms.container = std::move(container);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetMultiplicativeModifierValueWithCompoundNegative
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetMultiplicativeModifierValueWithCompoundNegative(const struct FGameplayTag& type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetMultiplicativeModifierValueWithCompoundNegative");

	Params::PerkManager_GetMultiplicativeModifierValueWithCompoundNegative Parms{};

	Parms.type = std::move(type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetPerk
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPerk*                            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPerk* UPerkManager::GetPerk(class FName id) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetPerk");

	Params::PerkManager_GetPerk Parms{};

	Parms.id = id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetPerkModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetPerkModifier(const struct FGameplayTag& type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetPerkModifier");

	Params::PerkManager_GetPerkModifier Parms{};

	Parms.type = std::move(type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetPerkModifierAdditiveValue
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             baseValue                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetPerkModifierAdditiveValue(const struct FGameplayTag& type, const float baseValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetPerkModifierAdditiveValue");

	Params::PerkManager_GetPerkModifierAdditiveValue Parms{};

	Parms.type = std::move(type);
	Parms.baseValue = baseValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetPerkModifierMaxValue
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetPerkModifierMaxValue(const struct FGameplayTag& type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetPerkModifierMaxValue");

	Params::PerkManager_GetPerkModifierMaxValue Parms{};

	Parms.type = std::move(type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetPerkModifierMaxValueAndSource
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer**      outSource                                              (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetPerkModifierMaxValueAndSource(const struct FGameplayTag& type, class UGameplayModifierContainer** outSource) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetPerkModifierMaxValueAndSource");

	Params::PerkManager_GetPerkModifierMaxValueAndSource Parms{};

	Parms.type = std::move(type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outSource != nullptr)
		*outSource = Parms.outSource;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetPerkModifierMinValue
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   startValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetPerkModifierMinValue(const struct FGameplayTag& type, float startValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetPerkModifierMinValue");

	Params::PerkManager_GetPerkModifierMinValue Parms{};

	Parms.type = std::move(type);
	Parms.startValue = startValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetPerkModifierMinValueAndSource
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   startValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer**      outSource                                              (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPerkManager::GetPerkModifierMinValueAndSource(const struct FGameplayTag& type, float startValue, class UGameplayModifierContainer** outSource) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetPerkModifierMinValueAndSource");

	Params::PerkManager_GetPerkModifierMinValueAndSource Parms{};

	Parms.type = std::move(type);
	Parms.startValue = startValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outSource != nullptr)
		*outSource = Parms.outSource;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetPerks
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UPerk*>              ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UPerk*> UPerkManager::GetPerks() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetPerks");

	Params::PerkManager_GetPerks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetSourceWithFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              flag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayModifierContainer* UPerkManager::GetSourceWithFlag(const struct FGameplayTag& flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetSourceWithFlag");

	Params::PerkManager_GetSourceWithFlag Parms{};

	Parms.flag = std::move(flag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetSourceWithModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayModifierContainer*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameplayModifierContainer* UPerkManager::GetSourceWithModifier(const struct FGameplayTag& type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetSourceWithModifier");

	Params::PerkManager_GetSourceWithModifier Parms{};

	Parms.type = std::move(type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.GetStatusEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStatusEffect*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStatusEffect* UPerkManager::GetStatusEffect(class FName id) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "GetStatusEffect");

	Params::PerkManager_GetStatusEffect Parms{};

	Parms.id = id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasAllCharacterPerksEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasAllCharacterPerksEquipped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasAllCharacterPerksEquipped");

	Params::PerkManager_HasAllCharacterPerksEquipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasAnyAddonWithTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasAnyAddonWithTag(class FName tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasAnyAddonWithTag");

	Params::PerkManager_HasAnyAddonWithTag Parms{};

	Parms.tag = tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasAnyEffectWithID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             id                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasAnyEffectWithID(class FName id) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasAnyEffectWithID");

	Params::PerkManager_HasAnyEffectWithID Parms{};

	Parms.id = id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasPerkFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              flag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasPerkFlag(const struct FGameplayTag& flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasPerkFlag");

	Params::PerkManager_HasPerkFlag Parms{};

	Parms.flag = std::move(flag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasPerkFlagFromSource
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              flag                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameplayModifierSource                 modifierSource                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasPerkFlagFromSource(const struct FGameplayTag& flag, EGameplayModifierSource modifierSource) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasPerkFlagFromSource");

	Params::PerkManager_HasPerkFlagFromSource Parms{};

	Parms.flag = std::move(flag);
	Parms.modifierSource = modifierSource;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasPerkFlags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FGameplayTag>&      flags                                                  (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasPerkFlags(const TArray<struct FGameplayTag>& flags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasPerkFlags");

	Params::PerkManager_HasPerkFlags Parms{};

	Parms.flags = std::move(flags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasPerkModifierOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              type                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasPerkModifierOfType(const struct FGameplayTag& type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasPerkModifierOfType");

	Params::PerkManager_HasPerkModifierOfType Parms{};

	Parms.type = std::move(type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasPerkSubFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              subFlag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasPerkSubFlag(const struct FGameplayTag& subFlag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasPerkSubFlag");

	Params::PerkManager_HasPerkSubFlag Parms{};

	Parms.subFlag = std::move(subFlag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasStatusEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       statusEffectID                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasStatusEffect(const class FName statusEffectID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasStatusEffect");

	Params::PerkManager_HasStatusEffect Parms{};

	Parms.statusEffectID = statusEffectID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkManager.HasStatusEffectOfClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UClass*                     type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkManager::HasStatusEffectOfClass(const class UClass* type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManager", "HasStatusEffectOfClass");

	Params::PerkManager_HasStatusEffectOfClass Parms{};

	Parms.type = type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerkSelectionSlotWidget.OnButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UPerkSelectionSlotWidget::OnButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkSelectionSlotWidget", "OnButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerspectiveEffectActivator.IsEffectActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             effectName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerspectiveEffectActivator::IsEffectActive(class FName effectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerspectiveEffectActivator", "IsEffectActive");

	Params::PerspectiveEffectActivator_IsEffectActive Parms{};

	Parms.effectName = effectName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PerspectiveEffectActivator.RegisterEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             effectName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPerspectiveEffectData&    effectData                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPerspectiveEffectActivator::RegisterEffect(class FName effectName, const struct FPerspectiveEffectData& effectData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerspectiveEffectActivator", "RegisterEffect");

	Params::PerspectiveEffectActivator_RegisterEffect Parms{};

	Parms.effectName = effectName;
	Parms.effectData = std::move(effectData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerspectiveEffectActivator.SetWantsActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             effectName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    wantsActive                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerspectiveEffectActivator::SetWantsActive(class FName effectName, bool wantsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerspectiveEffectActivator", "SetWantsActive");

	Params::PerspectiveEffectActivator_SetWantsActive Parms{};

	Parms.effectName = effectName;
	Parms.wantsActive = wantsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PerspectiveEffectActivator.UnregisterEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             effectName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerspectiveEffectActivator::UnregisterEffect(class FName effectName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerspectiveEffectActivator", "UnregisterEffect");

	Params::PerspectiveEffectActivator_UnregisterEffect Parms{};

	Parms.effectName = effectName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlagueUtilities.Authority_AddSicknessToPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   sicknessToAdd                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlagueUtilities::Authority_AddSicknessToPlayer(class ADBDPlayer* player, float sicknessToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlagueUtilities", "Authority_AddSicknessToPlayer");

	Params::PlagueUtilities_Authority_AddSicknessToPlayer Parms{};

	Parms.player = player;
	Parms.sicknessToAdd = sicknessToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlagueUtilities.GetPlagueEffect
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USurvivorPlagueEffect*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USurvivorPlagueEffect* UPlagueUtilities::GetPlagueEffect(const class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlagueUtilities", "GetPlagueEffect");

	Params::PlagueUtilities_GetPlagueEffect Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlagueUtilities.HasMaxLevelSickness
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlagueUtilities::HasMaxLevelSickness(const class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlagueUtilities", "HasMaxLevelSickness");

	Params::PlagueUtilities_HasMaxLevelSickness Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlagueUtilities.IsInfected
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlagueUtilities::IsInfected(const class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlagueUtilities", "IsInfected");

	Params::PlagueUtilities_IsInfected Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlagueUtilities.IsPlagueDebugModeActive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlagueUtilities::IsPlagueDebugModeActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlagueUtilities", "IsPlagueDebugModeActive");

	Params::PlagueUtilities_IsPlagueDebugModeActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Window.Authority_OnVaultInternal
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    canBlockVault                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindow::Authority_OnVaultInternal(class ADBDPlayer* player, bool canBlockVault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "Authority_OnVaultInternal");

	Params::Window_Authority_OnVaultInternal Parms{};

	Parms.player = player;
	Parms.canBlockVault = canBlockVault;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Window.Authority_SetBlockedByLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isBlockedByLevel                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindow::Authority_SetBlockedByLevel(bool isBlockedByLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "Authority_SetBlockedByLevel");

	Params::Window_Authority_SetBlockedByLevel Parms{};

	Parms.isBlockedByLevel = isBlockedByLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Window.ForceBlockLocalWindowInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    blockInteraction                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindow::ForceBlockLocalWindowInteraction(bool blockInteraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "ForceBlockLocalWindowInteraction");

	Params::Window_ForceBlockLocalWindowInteraction Parms{};

	Parms.blockInteraction = blockInteraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Window.NotifyOnFastVault
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindow::NotifyOnFastVault(class ADBDPlayer* player, class UInteractionDefinition* interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "NotifyOnFastVault");

	Params::Window_NotifyOnFastVault Parms{};

	Parms.player = player;
	Parms.interaction = interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Window.OnFastVault
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWindow::OnFastVault(class ADBDPlayer* player, class UInteractionDefinition* interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "OnFastVault");

	Params::Window_OnFastVault Parms{};

	Parms.player = player;
	Parms.interaction = interaction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Window.OnLocallyObservedChanged
// (Final, Native, Private)

void AWindow::OnLocallyObservedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "OnLocallyObservedChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Window.OnRep_blockedByLevel
// (Final, Native, Private)

void AWindow::OnRep_blockedByLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "OnRep_blockedByLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Window.GetAudioComponent
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UAkComponent*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkComponent* AWindow::GetAudioComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "GetAudioComponent");

	Params::Window_GetAudioComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Window.GetBlockedByLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWindow::GetBlockedByLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "GetBlockedByLevel");

	Params::Window_GetBlockedByLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Window.GetEntityAssets
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UChildActorComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChildActorComponent* AWindow::GetEntityAssets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "GetEntityAssets");

	Params::Window_GetEntityAssets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Window.GetMaterialHelper
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UMaterialHelper*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialHelper* AWindow::GetMaterialHelper() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "GetMaterialHelper");

	Params::Window_GetMaterialHelper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Window.IsWindowVaultBlockedFor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWindow::IsWindowVaultBlockedFor(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "IsWindowVaultBlockedFor");

	Params::Window_IsWindowVaultBlockedFor Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Window.IsWindowVaultBlockedForAnyPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWindow::IsWindowVaultBlockedForAnyPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Window", "IsWindowVaultBlockedForAnyPlayer");

	Params::Window_IsWindowVaultBlockedForAnyPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.AddInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionDefinition*           interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::AddInteraction(class UInteractionDefinition* interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "AddInteraction");

	Params::PlayerInteractionHandler_AddInteraction Parms{};

	Parms.interaction = interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.AddSelfInteractions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     interactionRoot                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::AddSelfInteractions(const class AActor* interactionRoot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "AddSelfInteractions");

	Params::PlayerInteractionHandler_AddSelfInteractions Parms{};

	Parms.interactionRoot = interactionRoot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Authority_ClearPlayerDependencies
// (Final, Native, Public, BlueprintCallable)

void UPlayerInteractionHandler::Authority_ClearPlayerDependencies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Authority_ClearPlayerDependencies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Authority_ClearPlayerDependency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       playerDependency                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Authority_ClearPlayerDependency(class ADBDPlayer* playerDependency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Authority_ClearPlayerDependency");

	Params::PlayerInteractionHandler_Authority_ClearPlayerDependency Parms{};

	Parms.playerDependency = playerDependency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Authority_TriggerCustomSkillCheck
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const ESkillCheckCustomType             type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   warningSoundDelay                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Authority_TriggerCustomSkillCheck(const ESkillCheckCustomType type, float warningSoundDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Authority_TriggerCustomSkillCheck");

	Params::PlayerInteractionHandler_Authority_TriggerCustomSkillCheck Parms{};

	Parms.type = type;
	Parms.warningSoundDelay = warningSoundDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Broadcast_Multicast_ConfirmChargedCompleted
// (Net, NetReliable, Native, Event, NetMulticast, Public, NetValidate)
// Parameters:
// bool                                    chargeComplete                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Broadcast_Multicast_ConfirmChargedCompleted(bool chargeComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Broadcast_Multicast_ConfirmChargedCompleted");

	Params::PlayerInteractionHandler_Broadcast_Multicast_ConfirmChargedCompleted Parms{};

	Parms.chargeComplete = chargeComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.CleanInteractionArray
// (Final, Native, Public)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::CleanInteractionArray(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "CleanInteractionArray");

	Params::PlayerInteractionHandler_CleanInteractionArray Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Client_Cheat_SetInteractionScanInterval
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// float                                   interval                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Client_Cheat_SetInteractionScanInterval(float interval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Client_Cheat_SetInteractionScanInterval");

	Params::PlayerInteractionHandler_Client_Cheat_SetInteractionScanInterval Parms{};

	Parms.interval = interval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Client_NotifyChargeCompleted
// (Net, NetReliable, Native, Event, Public, NetClient, NetValidate)
// Parameters:
// const class UInteractionDefinition*     interaction                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Client_NotifyChargeCompleted(const class UInteractionDefinition* interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Client_NotifyChargeCompleted");

	Params::PlayerInteractionHandler_Client_NotifyChargeCompleted Parms{};

	Parms.interaction = interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Client_StopSkillCheck
// (Net, NetReliable, Native, Event, Public, NetClient)

void UPlayerInteractionHandler::Client_StopSkillCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Client_StopSkillCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.HasAvailableInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInteractionHandler::HasAvailableInteraction(EInputInteractionType interactionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "HasAvailableInteraction");

	Params::PlayerInteractionHandler_HasAvailableInteraction Parms{};

	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.IncrementSuccessiveSkillCheckCount
// (Final, Native, Public, BlueprintCallable)

void UPlayerInteractionHandler::IncrementSuccessiveSkillCheckCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "IncrementSuccessiveSkillCheckCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Multicast_CancelCurrentInteractionByInput
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UPlayerInteractionHandler::Multicast_CancelCurrentInteractionByInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Multicast_CancelCurrentInteractionByInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Multicast_InteractionPredictionValidationResult
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UInteractionDefinition*           interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInteractionValidationState             state                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Multicast_InteractionPredictionValidationResult(class UInteractionDefinition* interaction, EInteractionValidationState state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Multicast_InteractionPredictionValidationResult");

	Params::PlayerInteractionHandler_Multicast_InteractionPredictionValidationResult Parms{};

	Parms.interaction = interaction;
	Parms.state = state;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Multicast_InterruptionRequestResult_Interruptor
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, NetValidate)
// Parameters:
// ERequestState                           state                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    grantInterruptScore                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Multicast_InterruptionRequestResult_Interruptor(ERequestState state, bool grantInterruptScore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Multicast_InterruptionRequestResult_Interruptor");

	Params::PlayerInteractionHandler_Multicast_InterruptionRequestResult_Interruptor Parms{};

	Parms.state = state;
	Parms.grantInterruptScore = grantInterruptScore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Multicast_RequestInterruption_Interruptee
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, NetValidate)
// Parameters:
// class ADBDPlayer*                       interruptionOtherParty                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterruptionDefinition*          interruptionDefinition                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Multicast_RequestInterruption_Interruptee(class ADBDPlayer* interruptionOtherParty, class UInterruptionDefinition* interruptionDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Multicast_RequestInterruption_Interruptee");

	Params::PlayerInteractionHandler_Multicast_RequestInterruption_Interruptee Parms{};

	Parms.interruptionOtherParty = interruptionOtherParty;
	Parms.interruptionDefinition = interruptionDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Multicast_SetInteractionToSwapTo
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UInteractionDefinition*           interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Multicast_SetInteractionToSwapTo(class UInteractionDefinition* interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Multicast_SetInteractionToSwapTo");

	Params::PlayerInteractionHandler_Multicast_SetInteractionToSwapTo Parms{};

	Parms.interaction = interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Multicast_StoreInteraction
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FStoredInteraction&        interactionToStore                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Multicast_StoreInteraction(const struct FStoredInteraction& interactionToStore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Multicast_StoreInteraction");

	Params::PlayerInteractionHandler_Multicast_StoreInteraction Parms{};

	Parms.interactionToStore = std::move(interactionToStore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Multicast_StoreInterruption_Interruptor
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, NetValidate)
// Parameters:
// class ADBDPlayer*                       interruptionOtherParty                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterruptionDefinition*          interruptionDefinition                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Multicast_StoreInterruption_Interruptor(class ADBDPlayer* interruptionOtherParty, class UInterruptionDefinition* interruptionDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Multicast_StoreInterruption_Interruptor");

	Params::PlayerInteractionHandler_Multicast_StoreInterruption_Interruptor Parms{};

	Parms.interruptionOtherParty = interruptionOtherParty;
	Parms.interruptionDefinition = interruptionDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.OnAttachedInteractorOwnerEndPlay
// (Final, Native, Private)
// Parameters:
// class AActor*                           actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEndPlayReason                          endPlayReason                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::OnAttachedInteractorOwnerEndPlay(class AActor* actor, EEndPlayReason endPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "OnAttachedInteractorOwnerEndPlay");

	Params::PlayerInteractionHandler_OnAttachedInteractorOwnerEndPlay Parms{};

	Parms.actor = actor;
	Parms.endPlayReason = endPlayReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.PauseSkillCheckTimer
// (Final, Native, Public, BlueprintCallable)

void UPlayerInteractionHandler::PauseSkillCheckTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "PauseSkillCheckTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.RemoveInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionDefinition*           interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::RemoveInteraction(class UInteractionDefinition* interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "RemoveInteraction");

	Params::PlayerInteractionHandler_RemoveInteraction Parms{};

	Parms.interaction = interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.ResetSuccessiveSkillCheckCount
// (Final, Native, Public, BlueprintCallable)

void UPlayerInteractionHandler::ResetSuccessiveSkillCheckCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "ResetSuccessiveSkillCheckCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_AnswerInterruption_Interruptee
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// ERequestState                           state                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Server_AnswerInterruption_Interruptee(ERequestState state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_AnswerInterruption_Interruptee");

	Params::PlayerInteractionHandler_Server_AnswerInterruption_Interruptee Parms{};

	Parms.state = state;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_Broadcast_ConfirmChargedCompleted
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// bool                                    chargeComplete                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Server_Broadcast_ConfirmChargedCompleted(bool chargeComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_Broadcast_ConfirmChargedCompleted");

	Params::PlayerInteractionHandler_Server_Broadcast_ConfirmChargedCompleted Parms{};

	Parms.chargeComplete = chargeComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_Broadcast_StoreInteraction
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const struct FStoredInteraction&        interactionToStore                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Server_Broadcast_StoreInteraction(const struct FStoredInteraction& interactionToStore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_Broadcast_StoreInteraction");

	Params::PlayerInteractionHandler_Server_Broadcast_StoreInteraction Parms{};

	Parms.interactionToStore = std::move(interactionToStore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_CancelCurrentInteractionByInput
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void UPlayerInteractionHandler::Server_CancelCurrentInteractionByInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_CancelCurrentInteractionByInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_Cheat_SetInteractionScanInterval
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// float                                   interval                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Server_Cheat_SetInteractionScanInterval(float interval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_Cheat_SetInteractionScanInterval");

	Params::PlayerInteractionHandler_Server_Cheat_SetInteractionScanInterval Parms{};

	Parms.interval = interval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_DebugRequestInteraction
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const class FString&                    interactionName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    interactorName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    interactableName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Server_DebugRequestInteraction(const class FString& interactionName, const class FString& interactorName, const class FString& interactableName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_DebugRequestInteraction");

	Params::PlayerInteractionHandler_Server_DebugRequestInteraction Parms{};

	Parms.interactionName = std::move(interactionName);
	Parms.interactorName = std::move(interactorName);
	Parms.interactableName = std::move(interactableName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_RequestInterruption_Interruptor
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void UPlayerInteractionHandler::Server_RequestInterruption_Interruptor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_RequestInterruption_Interruptor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_SetInteractionToSwapTo
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class UInteractionDefinition*           interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Server_SetInteractionToSwapTo(class UInteractionDefinition* interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_SetInteractionToSwapTo");

	Params::PlayerInteractionHandler_Server_SetInteractionToSwapTo Parms{};

	Parms.interaction = interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.Server_StoreInterruption_Interruptor
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class ADBDPlayer*                       interruptionOtherParty                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInterruptionDefinition*          interruptionDefinition                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::Server_StoreInterruption_Interruptor(class ADBDPlayer* interruptionOtherParty, class UInterruptionDefinition* interruptionDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "Server_StoreInterruption_Interruptor");

	Params::PlayerInteractionHandler_Server_StoreInterruption_Interruptor Parms{};

	Parms.interruptionOtherParty = interruptionOtherParty;
	Parms.interruptionDefinition = interruptionDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.SetScanForInteractionsEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::SetScanForInteractionsEnabled(bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "SetScanForInteractionsEnabled");

	Params::PlayerInteractionHandler_SetScanForInteractionsEnabled Parms{};

	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.UnPauseSkillCheckTimer
// (Final, Native, Public, BlueprintCallable)

void UPlayerInteractionHandler::UnPauseSkillCheckTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "UnPauseSkillCheckTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerInteractionHandler.CanPerformInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    interactionName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInteractionHandler::CanPerformInteraction(const class FString& interactionName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "CanPerformInteraction");

	Params::PlayerInteractionHandler_CanPerformInteraction Parms{};

	Parms.interactionName = std::move(interactionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.GetAdditiveSkillCheckProbabilityModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerInteractionHandler::GetAdditiveSkillCheckProbabilityModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "GetAdditiveSkillCheckProbabilityModifier");

	Params::PlayerInteractionHandler_GetAdditiveSkillCheckProbabilityModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.GetAvailableInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UPlayerInteractionHandler::GetAvailableInteraction(EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "GetAvailableInteraction");

	Params::PlayerInteractionHandler_GetAvailableInteraction Parms{};

	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.GetAvailableInteractionByID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    interactionID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UPlayerInteractionHandler::GetAvailableInteractionByID(const class FString& interactionID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "GetAvailableInteractionByID");

	Params::PlayerInteractionHandler_GetAvailableInteractionByID Parms{};

	Parms.interactionID = std::move(interactionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.GetAvailableInteractions
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UInteractionDefinition*>*  result                                                 (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPlayerInteractionHandler::GetAvailableInteractions(TArray<class UInteractionDefinition*>* result) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "GetAvailableInteractions");

	Params::PlayerInteractionHandler_GetAvailableInteractions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (result != nullptr)
		*result = std::move(Parms.result);
}


// Function DeadByDaylight.PlayerInteractionHandler.GetCurrentInteraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UPlayerInteractionHandler::GetCurrentInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "GetCurrentInteraction");

	Params::PlayerInteractionHandler_GetCurrentInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.GetCurrentInteractionOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInputInteractionType                   interactionInputType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UPlayerInteractionHandler::GetCurrentInteractionOfType(EInputInteractionType interactionInputType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "GetCurrentInteractionOfType");

	Params::PlayerInteractionHandler_GetCurrentInteractionOfType Parms{};

	Parms.interactionInputType = interactionInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.GetMultiplicativeSkillCheckProbabilityModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerInteractionHandler::GetMultiplicativeSkillCheckProbabilityModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "GetMultiplicativeSkillCheckProbabilityModifier");

	Params::PlayerInteractionHandler_GetMultiplicativeSkillCheckProbabilityModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.GetSkillCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkillCheck*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkillCheck* UPlayerInteractionHandler::GetSkillCheck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "GetSkillCheck");

	Params::PlayerInteractionHandler_GetSkillCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.HasActiveSkillCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInteractionHandler::HasActiveSkillCheck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "HasActiveSkillCheck");

	Params::PlayerInteractionHandler_HasActiveSkillCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerInteractionHandler.NumInteractionsInZone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlayerInteractionHandler::NumInteractionsInZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionHandler", "NumInteractionsInZone");

	Params::PlayerInteractionHandler_NumInteractionsInZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PlayerMoveBackAndForthComponent.OnMoveTimerDone
// (Final, Native, Private)

void UPlayerMoveBackAndForthComponent::OnMoveTimerDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerMoveBackAndForthComponent", "OnMoveTimerDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerPerspectiveComponent.OnPawnControllerChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      oldController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      newController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerPerspectiveComponent::OnPawnControllerChanged(class APawn* pawn, class AController* oldController, class AController* newController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerPerspectiveComponent", "OnPawnControllerChanged");

	Params::PlayerPerspectiveComponent_OnPawnControllerChanged Parms{};

	Parms.pawn = pawn;
	Parms.oldController = oldController;
	Parms.newController = newController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerPerspectiveComponent.UpdateLocallyObserved
// (Final, Native, Private)

void UPlayerPerspectiveComponent::UpdateLocallyObserved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerPerspectiveComponent", "UpdateLocallyObserved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PlayerPerspectiveComponent.IsLocallyObserved
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerPerspectiveComponent::IsLocallyObserved() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerPerspectiveComponent", "IsLocallyObserved");

	Params::PlayerPerspectiveComponent_IsLocallyObserved Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGStatusEffectsWidget.RemoveExistingStatusEffect
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    statusEffectID                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGStatusEffectsWidget::RemoveExistingStatusEffect(const class FString& statusEffectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGStatusEffectsWidget", "RemoveExistingStatusEffect");

	Params::UMGStatusEffectsWidget_RemoveExistingStatusEffect Parms{};

	Parms.statusEffectID = std::move(statusEffectID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSwitcherScreen.BroadcastBloodNodePurchase
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   characterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSwitcherScreen::BroadcastBloodNodePurchase(int32 characterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSwitcherScreen", "BroadcastBloodNodePurchase");

	Params::UMGSwitcherScreen_BroadcastBloodNodePurchase Parms{};

	Parms.characterId = characterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSwitcherScreen.BroadcastBloodNodeSelected
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   characterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   nodeId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   nodeDepth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSwitcherScreen::BroadcastBloodNodeSelected(int32 characterId, int32 nodeId, int32 nodeDepth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSwitcherScreen", "BroadcastBloodNodeSelected");

	Params::UMGSwitcherScreen_BroadcastBloodNodeSelected Parms{};

	Parms.characterId = characterId;
	Parms.nodeId = nodeId;
	Parms.nodeDepth = nodeDepth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSwitcherScreen.BroadcastBloodStoreRegenerate
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   characterId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSwitcherScreen::BroadcastBloodStoreRegenerate(int32 characterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSwitcherScreen", "BroadcastBloodStoreRegenerate");

	Params::UMGSwitcherScreen_BroadcastBloodStoreRegenerate Parms{};

	Parms.characterId = characterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSwitcherScreen.BroadcastCharacterInfoButtonClickedEvent
// (Final, Native, Protected, BlueprintCallable)

void UUMGSwitcherScreen::BroadcastCharacterInfoButtonClickedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSwitcherScreen", "BroadcastCharacterInfoButtonClickedEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSwitcherScreen.BroadcastCharacterRoleButtonClickedEvent
// (Final, Native, Protected, BlueprintCallable)

void UUMGSwitcherScreen::BroadcastCharacterRoleButtonClickedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSwitcherScreen", "BroadcastCharacterRoleButtonClickedEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSwitcherScreen.BroadcastCharacterSelectedEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   characterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSwitcherScreen::BroadcastCharacterSelectedEvent(int32 characterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSwitcherScreen", "BroadcastCharacterSelectedEvent");

	Params::UMGSwitcherScreen_BroadcastCharacterSelectedEvent Parms{};

	Parms.characterIndex = characterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSwitcherScreen.BroadcastItemSelectedEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   itemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSwitcherScreen::BroadcastItemSelectedEvent(int32 itemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSwitcherScreen", "BroadcastItemSelectedEvent");

	Params::UMGSwitcherScreen_BroadcastItemSelectedEvent Parms{};

	Parms.itemIndex = itemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSwitcherScreen.BroadcastItemUnSelectedEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   itemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSwitcherScreen::BroadcastItemUnSelectedEvent(int32 itemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSwitcherScreen", "BroadcastItemUnSelectedEvent");

	Params::UMGSwitcherScreen_BroadcastItemUnSelectedEvent Parms{};

	Parms.itemIndex = itemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSwitcherScreen.BroadcastSlotClickedEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   loadoutSlot                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSwitcherScreen::BroadcastSlotClickedEvent(int32 loadoutSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSwitcherScreen", "BroadcastSlotClickedEvent");

	Params::UMGSwitcherScreen_BroadcastSlotClickedEvent Parms{};

	Parms.loadoutSlot = loadoutSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PostProcessUpdate.PostProcessToggle
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    toggle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APostProcessUpdate::PostProcessToggle(bool toggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PostProcessUpdate", "PostProcessToggle");

	Params::PostProcessUpdate_PostProcessToggle Parms{};

	Parms.toggle = toggle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.PowerButton.GetActionButton
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UActionButton*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UActionButton* UPowerButton::GetActionButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerButton", "GetActionButton");

	Params::PowerButton_GetActionButton Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PowerButton.IsRadialProgressBarActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPowerButton::IsRadialProgressBarActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerButton", "IsRadialProgressBarActive");

	Params::PowerButton_IsRadialProgressBarActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.PowerButton.OnTierChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   previousTier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   currentTier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isFirstTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPowerButton::OnTierChanged(int32 previousTier, int32 currentTier, bool isFirstTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerButton", "OnTierChanged");

	Params::PowerButton_OnTierChanged Parms{};

	Parms.previousTier = previousTier;
	Parms.currentTier = currentTier;
	Parms.isFirstTime = isFirstTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.PowerButton.SetFillProgressPercentage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             chargeProgressionPercentage                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPowerButton::SetFillProgressPercentage(const float chargeProgressionPercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerButton", "SetFillProgressPercentage");

	Params::PowerButton_SetFillProgressPercentage Parms{};

	Parms.chargeProgressionPercentage = chargeProgressionPercentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PowerButton.SetPowerIntensityOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   opacity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPowerButton::SetPowerIntensityOpacity(float opacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerButton", "SetPowerIntensityOpacity");

	Params::PowerButton_SetPowerIntensityOpacity Parms{};

	Parms.opacity = opacity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PowerButton.SetRadialProgressBarActice
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPowerButton::SetRadialProgressBarActice(bool active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerButton", "SetRadialProgressBarActice");

	Params::PowerButton_SetRadialProgressBarActice Parms{};

	Parms.active = active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PowerButton.SetRadialProgressPercentage
// (Event, Public, BlueprintEvent)
// Parameters:
// const float                             progression                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERadialProgressBarType                  progressBarType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPowerButton::SetRadialProgressPercentage(const float progression, ERadialProgressBarType progressBarType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerButton", "SetRadialProgressPercentage");

	Params::PowerButton_SetRadialProgressPercentage Parms{};

	Parms.progression = progression;
	Parms.progressBarType = progressBarType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.PowerButton.SetState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EActionButtonState                      state                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPowerButton::SetState(EActionButtonState state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerButton", "SetState");

	Params::PowerButton_SetState Parms{};

	Parms.state = state;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PowerButton.SetSwitchIconActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPowerButton::SetSwitchIconActive(bool active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerButton", "SetSwitchIconActive");

	Params::PowerButton_SetSwitchIconActive Parms{};

	Parms.active = active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ProceduralLevelBuilder.ApplyMist
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   modifier                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProceduralLevelBuilder::ApplyMist(float modifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralLevelBuilder", "ApplyMist");

	Params::ProceduralLevelBuilder_ApplyMist Parms{};

	Parms.modifier = modifier;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ProceduralLevelBuilder.BuildFromSeed
// (Final, Native, Private)

void AProceduralLevelBuilder::BuildFromSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralLevelBuilder", "BuildFromSeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ProceduralLevelBuilder.Multicast_DebugShareGenerationData
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FGenerationParams&         usedParams                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AProceduralLevelBuilder::Multicast_DebugShareGenerationData(const struct FGenerationParams& usedParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralLevelBuilder", "Multicast_DebugShareGenerationData");

	Params::ProceduralLevelBuilder_Multicast_DebugShareGenerationData Parms{};

	Parms.usedParams = std::move(usedParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ProceduralLevelBuilder.RemoveMist
// (Event, Public, BlueprintEvent)

void AProceduralLevelBuilder::RemoveMist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralLevelBuilder", "RemoveMist");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.ProceduralLevelBuilder.SpawnActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           actorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETileSpawnPointType                     spawnPointType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AProceduralLevelBuilder::SpawnActor(class UClass* actorClass, ETileSpawnPointType spawnPointType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralLevelBuilder", "SpawnActor");

	Params::ProceduralLevelBuilder_SpawnActor Parms{};

	Parms.actorClass = actorClass;
	Parms.spawnPointType = spawnPointType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ProceduralLevelBuilder.StartGenerationOnSyncerReady
// (Final, Native, Private)

void AProceduralLevelBuilder::StartGenerationOnSyncerReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralLevelBuilder", "StartGenerationOnSyncerReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ProceduralLevelBuilder.SyncSeeds
// (Final, Native, Private)

void AProceduralLevelBuilder::SyncSeeds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralLevelBuilder", "SyncSeeds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGObjectivesWidget.UpdateGeneratorCount
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGObjectivesWidget::UpdateGeneratorCount(int32 count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGObjectivesWidget", "UpdateGeneratorCount");

	Params::UMGObjectivesWidget_UpdateGeneratorCount Parms{};

	Parms.count = count;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGObjectivesWidget.UpdateTextMessage
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      textFind                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      textExit                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      textOr                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGObjectivesWidget::UpdateTextMessage(const class FText& textFind, const class FText& textExit, const class FText& textOr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGObjectivesWidget", "UpdateTextMessage");

	Params::UMGObjectivesWidget_UpdateTextMessage Parms{};

	Parms.textFind = std::move(textFind);
	Parms.textExit = std::move(textExit);
	Parms.textOr = std::move(textOr);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGPopupButton.OnButtonClicked
// (Native, Public)

void UUMGPopupButton::OnButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPopupButton", "OnButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGPopupButton.OnButtonPressed
// (Native, Public)

void UUMGPopupButton::OnButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPopupButton", "OnButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGPopupButton.OnButtonReleased
// (Native, Public)

void UUMGPopupButton::OnButtonReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPopupButton", "OnButtonReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ProtectionHitComponent.Authority_HandleProtectionScoringEvents
// (Final, Native, Public, BlueprintCallable)

void UProtectionHitComponent::Authority_HandleProtectionScoringEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProtectionHitComponent", "Authority_HandleProtectionScoringEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.PurpleGlyphBloodTrailComponent.DeactivateGlyphBloodTrail
// (Final, Native, Public, BlueprintCallable)

void UPurpleGlyphBloodTrailComponent::DeactivateGlyphBloodTrail()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PurpleGlyphBloodTrailComponent", "DeactivateGlyphBloodTrail");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RBTOutlineUpdateStrategy.IsRevealedToLocalPlayer_BP
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URBTOutlineUpdateStrategy::IsRevealedToLocalPlayer_BP(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RBTOutlineUpdateStrategy", "IsRevealedToLocalPlayer_BP");

	Params::RBTOutlineUpdateStrategy_IsRevealedToLocalPlayer_BP Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.RedStainComponent.DBD_HideRedStain
// (Final, Exec, Native, Public)
// Parameters:
// const bool                              hideStain                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URedStainComponent::DBD_HideRedStain(const bool hideStain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RedStainComponent", "DBD_HideRedStain");

	Params::RedStainComponent_DBD_HideRedStain Parms{};

	Parms.hideStain = hideStain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RedStainComponent.UpdateRedStain
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    shouldBeHidden                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             alpha                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URedStainComponent::UpdateRedStain(bool shouldBeHidden, const float alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RedStainComponent", "UpdateRedStain");

	Params::RedStainComponent_UpdateRedStain Parms{};

	Parms.shouldBeHidden = shouldBeHidden;
	Parms.alpha = alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.VomitStateComponent.SetObjectState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayTagContainerComponent*   objectState                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVomitStateComponent::SetObjectState(class UGameplayTagContainerComponent* objectState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VomitStateComponent", "SetObjectState");

	Params::VomitStateComponent_SetObjectState Parms{};

	Parms.objectState = objectState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.VomitStateComponent.SetVomitState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELinkedVomitState                       newVomitState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVomitStateComponent::SetVomitState(ELinkedVomitState newVomitState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VomitStateComponent", "SetVomitState");

	Params::VomitStateComponent_SetVomitState Parms{};

	Parms.newVomitState = newVomitState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.VomitStateComponent.getVomitState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELinkedVomitState                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELinkedVomitState UVomitStateComponent::getVomitState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VomitStateComponent", "getVomitState");

	Params::VomitStateComponent_getVomitState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.VomitStateComponent.IsVomiting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVomitStateComponent::IsVomiting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VomitStateComponent", "IsVomiting");

	Params::VomitStateComponent_IsVomiting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.RootMovie.AddCursorBlockingWidget
// (Final, Native, Public)
// Parameters:
// const class FString&                    id                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   x                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::AddCursorBlockingWidget(const class FString& id, float x, float y, float width, float height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "AddCursorBlockingWidget");

	Params::RootMovie_AddCursorBlockingWidget Parms{};

	Parms.id = std::move(id);
	Parms.x = x;
	Parms.y = y;
	Parms.width = width;
	Parms.height = height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.OnAssert
// (Final, Native, Public)
// Parameters:
// int32                                   type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::OnAssert(int32 type, const class FString& message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "OnAssert");

	Params::RootMovie_OnAssert Parms{};

	Parms.type = type;
	Parms.message = std::move(message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.OnFlashReady
// (Final, Native, Public)

void URootMovie::OnFlashReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "OnFlashReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.OnMovieClosed
// (Final, Native, Public)

void URootMovie::OnMovieClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "OnMovieClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.OnScreenEnter
// (Final, Native, Public)
// Parameters:
// const class FString&                    screenId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::OnScreenEnter(const class FString& screenId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "OnScreenEnter");

	Params::RootMovie_OnScreenEnter Parms{};

	Parms.screenId = std::move(screenId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.OnScreenLeave
// (Final, Native, Public)
// Parameters:
// const class FString&                    screenId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::OnScreenLeave(const class FString& screenId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "OnScreenLeave");

	Params::RootMovie_OnScreenLeave Parms{};

	Parms.screenId = std::move(screenId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.OnScreenReady
// (Final, Native, Public)
// Parameters:
// const class FString&                    screenId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::OnScreenReady(const class FString& screenId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "OnScreenReady");

	Params::RootMovie_OnScreenReady Parms{};

	Parms.screenId = std::move(screenId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.OpenLinkInBrowser
// (Final, Native, Public)
// Parameters:
// const class FString&                    linkAddress                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::OpenLinkInBrowser(const class FString& linkAddress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "OpenLinkInBrowser");

	Params::RootMovie_OpenLinkInBrowser Parms{};

	Parms.linkAddress = std::move(linkAddress);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.PlaySound
// (Final, Native, Public)
// Parameters:
// const class FString&                    soundId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::PlaySound(const class FString& soundId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "PlaySound");

	Params::RootMovie_PlaySound Parms{};

	Parms.soundId = std::move(soundId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.RegisterScreenControl
// (Final, Native, Public)
// Parameters:
// class UGFxObject*                       flashObj                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::RegisterScreenControl(class UGFxObject* flashObj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "RegisterScreenControl");

	Params::RootMovie_RegisterScreenControl Parms{};

	Parms.flashObj = flashObj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.RegisterUIControl
// (Final, Native, Public)
// Parameters:
// class UGFxObject*                       flashObj                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::RegisterUIControl(class UGFxObject* flashObj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "RegisterUIControl");

	Params::RootMovie_RegisterUIControl Parms{};

	Parms.flashObj = flashObj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.RegisterView
// (Final, Native, Public)
// Parameters:
// const class FString&                    screenId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGFxObject*                       screenObject                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::RegisterView(const class FString& screenId, class UGFxObject* screenObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "RegisterView");

	Params::RootMovie_RegisterView Parms{};

	Parms.screenId = std::move(screenId);
	Parms.screenObject = screenObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.RemoveCursorBlockingWidget
// (Final, Native, Public)
// Parameters:
// const class FString&                    id                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::RemoveCursorBlockingWidget(const class FString& id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "RemoveCursorBlockingWidget");

	Params::RootMovie_RemoveCursorBlockingWidget Parms{};

	Parms.id = std::move(id);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.RootMovie.SetCursorAsSticky
// (Final, Native, Public)
// Parameters:
// bool                                    isSticky                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    lockVertical                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    lockHorizontal                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   stickinessOverride                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMovie::SetCursorAsSticky(bool isSticky, bool lockVertical, bool lockHorizontal, float stickinessOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMovie", "SetCursorAsSticky");

	Params::RootMovie_SetCursorAsSticky Parms{};

	Parms.isSticky = isSticky;
	Parms.lockVertical = lockVertical;
	Parms.lockHorizontal = lockHorizontal;
	Parms.stickinessOverride = stickinessOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScourgeHookManagerComponent.OnRep_ScourgeHooks
// (Final, Native, Private)

void UScourgeHookManagerComponent::OnRep_ScourgeHooks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScourgeHookManagerComponent", "OnRep_ScourgeHooks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreamComponent.OnDamageStateChanged
// (Final, Native, Private)
// Parameters:
// ECamperDamageState                      oldDamageState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECamperDamageState                      newDamageState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UScreamComponent::OnDamageStateChanged(ECamperDamageState oldDamageState, ECamperDamageState newDamageState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreamComponent", "OnDamageStateChanged");

	Params::ScreamComponent_OnDamageStateChanged Parms{};

	Parms.oldDamageState = oldDamageState;
	Parms.newDamageState = newDamageState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreamComponent.TriggerScreamEventsAndAndAnimationIfPossible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    fireLoudNoiseEvent                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMontagePlaybackDefinition&montageDefinition                                      (Parm, NativeAccessSpecifierPublic)
// float                                   audibleRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScreamComponent::TriggerScreamEventsAndAndAnimationIfPossible(bool fireLoudNoiseEvent, const struct FMontagePlaybackDefinition& montageDefinition, float audibleRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreamComponent", "TriggerScreamEventsAndAndAnimationIfPossible");

	Params::ScreamComponent_TriggerScreamEventsAndAndAnimationIfPossible Parms{};

	Parms.fireLoudNoiseEvent = fireLoudNoiseEvent;
	Parms.montageDefinition = std::move(montageDefinition);
	Parms.audibleRange = audibleRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ScreamComponent.TriggerScreamEventsIfPossible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    fireLoudNoiseEvent                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   audibleRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScreamComponent::TriggerScreamEventsIfPossible(bool fireLoudNoiseEvent, float audibleRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreamComponent", "TriggerScreamEventsIfPossible");

	Params::ScreamComponent_TriggerScreamEventsIfPossible Parms{};

	Parms.fireLoudNoiseEvent = fireLoudNoiseEvent;
	Parms.audibleRange = audibleRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ScreamComponent.CanScream
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UScreamComponent::CanScream() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ScreamComponent", "CanScream");

	Params::ScreamComponent_CanScream Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.ScreenshotToolHook.PostBatchItems
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<struct FCharacterToolItemData>&items                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PostBatchItems(const TArray<struct FCharacterToolItemData>& items)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PostBatchItems");

	Params::ScreenshotToolHook_PostBatchItems Parms{};

	Parms.items = std::move(items);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PostHookConstruction
// (Native, Event, Public, BlueprintEvent)

void IScreenshotToolHook::PostHookConstruction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PostHookConstruction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PostSpawnCharacter
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ADBDMenuPlayer*                   character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PostSpawnCharacter(class ADBDMenuPlayer* character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PostSpawnCharacter");

	Params::ScreenshotToolHook_PostSpawnCharacter Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PostSpawnCharm
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ACharm*                           charm                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PostSpawnCharm(class ACharm* charm)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PostSpawnCharm");

	Params::ScreenshotToolHook_PostSpawnCharm Parms{};

	Parms.charm = charm;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PostStateChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// EScreenshotToolState                    previousState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EScreenshotToolState                    currentState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PostStateChanged(EScreenshotToolState previousState, EScreenshotToolState currentState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PostStateChanged");

	Params::ScreenshotToolHook_PostStateChanged Parms{};

	Parms.previousState = previousState;
	Parms.currentState = currentState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PostTakeItemScreenshot
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FCharacterToolItemData&    item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PostTakeItemScreenshot(const struct FCharacterToolItemData& item, bool success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PostTakeItemScreenshot");

	Params::ScreenshotToolHook_PostTakeItemScreenshot Parms{};

	Parms.item = std::move(item);
	Parms.success = success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PostUpdateCharacter
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ADBDMenuPlayer*                   character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PostUpdateCharacter(class ADBDMenuPlayer* character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PostUpdateCharacter");

	Params::ScreenshotToolHook_PostUpdateCharacter Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PreBatchItems
// (Native, Event, Public, BlueprintEvent)

void IScreenshotToolHook::PreBatchItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PreBatchItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PreDestroyCharacter
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ADBDMenuPlayer*                   character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PreDestroyCharacter(class ADBDMenuPlayer* character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PreDestroyCharacter");

	Params::ScreenshotToolHook_PreDestroyCharacter Parms{};

	Parms.character = character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PreDestroyCharm
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ACharm*                           charm                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PreDestroyCharm(class ACharm* charm)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PreDestroyCharm");

	Params::ScreenshotToolHook_PreDestroyCharm Parms{};

	Parms.charm = charm;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PreHookDestruction
// (Native, Event, Public, BlueprintEvent)

void IScreenshotToolHook::PreHookDestruction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PreHookDestruction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PreSpawnCharacter
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FCharacterDescription&     description                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FCharacterToolSpawnParameters*   spawnParams                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PreSpawnCharacter(const struct FCharacterDescription& description, struct FCharacterToolSpawnParameters* spawnParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PreSpawnCharacter");

	Params::ScreenshotToolHook_PreSpawnCharacter Parms{};

	Parms.description = std::move(description);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (spawnParams != nullptr)
		*spawnParams = std::move(Parms.spawnParams);
}


// Function DeadByDaylight.ScreenshotToolHook.PreSpawnCharm
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FCustomizationItemData&    item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PreSpawnCharm(const struct FCustomizationItemData& item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PreSpawnCharm");

	Params::ScreenshotToolHook_PreSpawnCharm Parms{};

	Parms.item = std::move(item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.PreTakeItemScreenshot
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FCharacterToolItemData&    item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IScreenshotToolHook::PreTakeItemScreenshot(const struct FCharacterToolItemData& item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "PreTakeItemScreenshot");

	Params::ScreenshotToolHook_PreTakeItemScreenshot Parms{};

	Parms.item = std::move(item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.ScreenshotBeginPlay
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isPIE                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IScreenshotToolHook::ScreenshotBeginPlay(bool isPIE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "ScreenshotBeginPlay");

	Params::ScreenshotToolHook_ScreenshotBeginPlay Parms{};

	Parms.isPIE = isPIE;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ScreenshotToolHook.IsPIEOnly
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IScreenshotToolHook::IsPIEOnly() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ScreenshotToolHook", "IsPIEOnly");

	Params::ScreenshotToolHook_IsPIEOnly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Searchable.Authority_SpawnObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACollectable*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACollectable* ASearchable::Authority_SpawnObject(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "Authority_SpawnObject");

	Params::Searchable_Authority_SpawnObject Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Searchable.SetHasBeenSearched
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    newHasBeenSearched                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASearchable::SetHasBeenSearched(bool newHasBeenSearched)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "SetHasBeenSearched");

	Params::Searchable_SetHasBeenSearched Parms{};

	Parms.newHasBeenSearched = newHasBeenSearched;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Searchable.ContainsSpawnedItem
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASearchable::ContainsSpawnedItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "ContainsSpawnedItem");

	Params::Searchable_ContainsSpawnedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Searchable.GetInteractorPrimitiveComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* ASearchable::GetInteractorPrimitiveComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "GetInteractorPrimitiveComponent");

	Params::Searchable_GetInteractorPrimitiveComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Searchable.HasBeenSearched
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASearchable::HasBeenSearched() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Searchable", "HasBeenSearched");

	Params::Searchable_HasBeenSearched Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TileSpawnPoint.OnRep_SpawnObject
// (Native, Protected)

void UTileSpawnPoint::OnRep_SpawnObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TileSpawnPoint", "OnRep_SpawnObject");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TileSpawnPoint.SetActivated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    activated                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTileSpawnPoint::SetActivated(bool activated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TileSpawnPoint", "SetActivated");

	Params::TileSpawnPoint_SetActivated Parms{};

	Parms.activated = activated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TileSpawnPoint.GetSpawnedObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UTileSpawnPoint::GetSpawnedObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TileSpawnPoint", "GetSpawnedObject");

	Params::TileSpawnPoint_GetSpawnedObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TileSpawnPoint.IsActivated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTileSpawnPoint::IsActivated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TileSpawnPoint", "IsActivated");

	Params::TileSpawnPoint_IsActivated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGFogWidget.HandleOnSettingButtonClick
// (Final, Native, Protected, BlueprintCallable)

void UUMGFogWidget::HandleOnSettingButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGFogWidget", "HandleOnSettingButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGFogWidget.OnCurrencyTooltipTriggered
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FTooltipPressedData&       tooltipPressedData                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const ECurrencyType                     currencyType                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGFogWidget::OnCurrencyTooltipTriggered(const struct FTooltipPressedData& tooltipPressedData, const ECurrencyType currencyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGFogWidget", "OnCurrencyTooltipTriggered");

	Params::UMGFogWidget_OnCurrencyTooltipTriggered Parms{};

	Parms.tooltipPressedData = std::move(tooltipPressedData);
	Parms.currencyType = currencyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGFogWidget.OnLevelTooltipTriggered
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FTooltipPressedData&       tooltipPressedData                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUMGFogWidget::OnLevelTooltipTriggered(const struct FTooltipPressedData& tooltipPressedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGFogWidget", "OnLevelTooltipTriggered");

	Params::UMGFogWidget_OnLevelTooltipTriggered Parms{};

	Parms.tooltipPressedData = std::move(tooltipPressedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGFogWidget.OnRankTooltipTriggered
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FTooltipPressedData&       tooltipPressedData                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUMGFogWidget::OnRankTooltipTriggered(const struct FTooltipPressedData& tooltipPressedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGFogWidget", "OnRankTooltipTriggered");

	Params::UMGFogWidget_OnRankTooltipTriggered Parms{};

	Parms.tooltipPressedData = std::move(tooltipPressedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.CanSkillCheckTypeGrantScore
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ESkillCheckCustomType                   type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkillCheck::CanSkillCheckTypeGrantScore(ESkillCheckCustomType type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SkillCheck", "CanSkillCheckTypeGrantScore");

	Params::SkillCheck_CanSkillCheckTypeGrantScore Parms{};

	Parms.type = type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SkillCheck.Authority_OnSkillCheckTimeout
// (Final, Native, Public)

void USkillCheck::Authority_OnSkillCheckTimeout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Authority_OnSkillCheckTimeout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Multicast_ActivateSkillCheck
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UChargeableInteractionDefinition* interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   skillCheckCustomType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSkillCheckDefinition&     definition                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    executeOnlyOnNotControlled                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillCheck::Multicast_ActivateSkillCheck(class UChargeableInteractionDefinition* interaction, ESkillCheckCustomType skillCheckCustomType, const struct FSkillCheckDefinition& definition, bool executeOnlyOnNotControlled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Multicast_ActivateSkillCheck");

	Params::SkillCheck_Multicast_ActivateSkillCheck Parms{};

	Parms.interaction = interaction;
	Parms.skillCheckCustomType = skillCheckCustomType;
	Parms.definition = std::move(definition);
	Parms.executeOnlyOnNotControlled = executeOnlyOnNotControlled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Multicast_DeactivateSkillCheck
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void USkillCheck::Multicast_DeactivateSkillCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Multicast_DeactivateSkillCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Multicast_OnTriggerContinuousCustomSkillCheck
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UChargeableInteractionDefinition* currentInteraction                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   skillCheckCustomType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSkillCheckDefinition&     definition                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USkillCheck::Multicast_OnTriggerContinuousCustomSkillCheck(class UChargeableInteractionDefinition* currentInteraction, ESkillCheckCustomType skillCheckCustomType, const struct FSkillCheckDefinition& definition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Multicast_OnTriggerContinuousCustomSkillCheck");

	Params::SkillCheck_Multicast_OnTriggerContinuousCustomSkillCheck Parms{};

	Parms.currentInteraction = currentInteraction;
	Parms.skillCheckCustomType = skillCheckCustomType;
	Parms.definition = std::move(definition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Multicast_OnTriggerCustomSkillCheck
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class UChargeableInteractionDefinition* currentInteraction                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   skillCheckCustomType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    id                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    salt                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSkillCheckDefinition&     definition                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USkillCheck::Multicast_OnTriggerCustomSkillCheck(class UChargeableInteractionDefinition* currentInteraction, ESkillCheckCustomType skillCheckCustomType, const class FString& id, const class FString& salt, const struct FSkillCheckDefinition& definition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Multicast_OnTriggerCustomSkillCheck");

	Params::SkillCheck_Multicast_OnTriggerCustomSkillCheck Parms{};

	Parms.currentInteraction = currentInteraction;
	Parms.skillCheckCustomType = skillCheckCustomType;
	Parms.id = std::move(id);
	Parms.salt = std::move(salt);
	Parms.definition = std::move(definition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Multicast_SkillCheckResponse
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FSkillCheckResponse&       skillCheckResponse                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    executeOnlyOnNotControlled                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillCheck::Multicast_SkillCheckResponse(const struct FSkillCheckResponse& skillCheckResponse, bool executeOnlyOnNotControlled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Multicast_SkillCheckResponse");

	Params::SkillCheck_Multicast_SkillCheckResponse Parms{};

	Parms.skillCheckResponse = std::move(skillCheckResponse);
	Parms.executeOnlyOnNotControlled = executeOnlyOnNotControlled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.OnSkillCheckFailureTrigger
// (Final, Native, Private)
// Parameters:
// const bool                              hadInput                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              insane                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   skillCheckCustomType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillCheck::OnSkillCheckFailureTrigger(const bool hadInput, const bool insane, ESkillCheckCustomType skillCheckCustomType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "OnSkillCheckFailureTrigger");

	Params::SkillCheck_OnSkillCheckFailureTrigger Parms{};

	Parms.hadInput = hadInput;
	Parms.insane = insane;
	Parms.skillCheckCustomType = skillCheckCustomType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.OnSkillCheckSuccessTrigger
// (Final, Native, Private)
// Parameters:
// const bool                              bonus                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              insane                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   skillCheckCustomType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              failedCountedAsGood                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillCheck::OnSkillCheckSuccessTrigger(const bool bonus, const bool insane, ESkillCheckCustomType skillCheckCustomType, const bool failedCountedAsGood)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "OnSkillCheckSuccessTrigger");

	Params::SkillCheck_OnSkillCheckSuccessTrigger Parms{};

	Parms.bonus = bonus;
	Parms.insane = insane;
	Parms.skillCheckCustomType = skillCheckCustomType;
	Parms.failedCountedAsGood = failedCountedAsGood;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Server_ActivateSkillCheck
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class UChargeableInteractionDefinition* interaction                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESkillCheckCustomType                   skillCheckCustomType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSkillCheckDefinition&     definition                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USkillCheck::Server_ActivateSkillCheck(class UChargeableInteractionDefinition* interaction, ESkillCheckCustomType skillCheckCustomType, const struct FSkillCheckDefinition& definition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Server_ActivateSkillCheck");

	Params::SkillCheck_Server_ActivateSkillCheck Parms{};

	Parms.interaction = interaction;
	Parms.skillCheckCustomType = skillCheckCustomType;
	Parms.definition = std::move(definition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Server_DeactivateSkillCheck
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void USkillCheck::Server_DeactivateSkillCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Server_DeactivateSkillCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Server_OnSkillCheckFailure
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FSkillCheckResponse&       skillCheckResponse                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USkillCheck::Server_OnSkillCheckFailure(const struct FSkillCheckResponse& skillCheckResponse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Server_OnSkillCheckFailure");

	Params::SkillCheck_Server_OnSkillCheckFailure Parms{};

	Parms.skillCheckResponse = std::move(skillCheckResponse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.Server_OnSkillCheckSuccess
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FSkillCheckResponse&       skillCheckResponse                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USkillCheck::Server_OnSkillCheckSuccess(const struct FSkillCheckResponse& skillCheckResponse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "Server_OnSkillCheckSuccess");

	Params::SkillCheck_Server_OnSkillCheckSuccess Parms{};

	Parms.skillCheckResponse = std::move(skillCheckResponse);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SkillCheck.ShouldShowWarning
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkillCheck::ShouldShowWarning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "ShouldShowWarning");

	Params::SkillCheck_ShouldShowWarning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SkillCheck.IsDisplayed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkillCheck::IsDisplayed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "IsDisplayed");

	Params::SkillCheck_IsDisplayed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SkillCheck.IsHexSkillCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       dbdPlayer                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkillCheck::IsHexSkillCheck(class ADBDPlayer* dbdPlayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "IsHexSkillCheck");

	Params::SkillCheck_IsHexSkillCheck Parms{};

	Parms.dbdPlayer = dbdPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SkillCheck.IsOffCenterSkillCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USkillCheck::IsOffCenterSkillCheck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillCheck", "IsOffCenterSkillCheck");

	Params::SkillCheck_IsOffCenterSkillCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlashableActivationSourceCollection.AddSource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlashableActivationSourceCollection::AddSource(class UObject* source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SlashableActivationSourceCollection", "AddSource");

	Params::SlashableActivationSourceCollection_AddSource Parms{};

	Parms.source = source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlashableActivationSourceCollection.ForceActivate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    worldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlashableActivationSourceCollection::ForceActivate(const class UObject* worldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SlashableActivationSourceCollection", "ForceActivate");

	Params::SlashableActivationSourceCollection_ForceActivate Parms{};

	Parms.worldContextObject = worldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlashableActivationSourceCollection.RemoveSource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          source                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlashableActivationSourceCollection::RemoveSource(class UObject* source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SlashableActivationSourceCollection", "RemoveSource");

	Params::SlashableActivationSourceCollection_RemoveSource Parms{};

	Parms.source = source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherAnimInstance.CallOnFootTrapped
// (Final, Native, Protected, BlueprintCallable)

void USlasherAnimInstance::CallOnFootTrapped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherAnimInstance", "CallOnFootTrapped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherAnimInstance.SetIsCrouched
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlasherAnimInstance::SetIsCrouched(const bool value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherAnimInstance", "SetIsCrouched");

	Params::SlasherAnimInstance_SetIsCrouched Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherMovementComponent.Client_Debug_SetKillerMaxSpeedMultiplier
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const float                             maxSpeedMultiplier                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlasherMovementComponent::Client_Debug_SetKillerMaxSpeedMultiplier(const float maxSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherMovementComponent", "Client_Debug_SetKillerMaxSpeedMultiplier");

	Params::SlasherMovementComponent_Client_Debug_SetKillerMaxSpeedMultiplier Parms{};

	Parms.maxSpeedMultiplier = maxSpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherMovementComponent.DBD_KillerMaxSpeedMultiplier
// (Final, Exec, Native, Private)
// Parameters:
// const float                             maxSpeedMultiplier                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlasherMovementComponent::DBD_KillerMaxSpeedMultiplier(const float maxSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherMovementComponent", "DBD_KillerMaxSpeedMultiplier");

	Params::SlasherMovementComponent_DBD_KillerMaxSpeedMultiplier Parms{};

	Parms.maxSpeedMultiplier = maxSpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherMovementComponent.DBD_SimulateHack_LocalKillerMaxSpeedMultiplier
// (Final, Exec, Native, Private)
// Parameters:
// const float                             maxSpeedMultiplier                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlasherMovementComponent::DBD_SimulateHack_LocalKillerMaxSpeedMultiplier(const float maxSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherMovementComponent", "DBD_SimulateHack_LocalKillerMaxSpeedMultiplier");

	Params::SlasherMovementComponent_DBD_SimulateHack_LocalKillerMaxSpeedMultiplier Parms{};

	Parms.maxSpeedMultiplier = maxSpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherMovementComponent.GetBaseMaxSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USlasherMovementComponent::GetBaseMaxSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherMovementComponent", "GetBaseMaxSpeed");

	Params::SlasherMovementComponent_GetBaseMaxSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.ActionKillerPressed
// (Final, Native, Public, BlueprintCallable)

void ASlasherPlayer::ActionKillerPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "ActionKillerPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.ActionKillerReleased
// (Final, Native, Public, BlueprintCallable)

void ASlasherPlayer::ActionKillerReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "ActionKillerReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.AttackInputPressed
// (Final, Native, Public, BlueprintCallable)

void ASlasherPlayer::AttackInputPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "AttackInputPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.AttackInputReleased
// (Final, Native, Public, BlueprintCallable)

void ASlasherPlayer::AttackInputReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "AttackInputReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.Authority_AllowKilling
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   numKills                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::Authority_AllowKilling(int32 numKills)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "Authority_AllowKilling");

	Params::SlasherPlayer_Authority_AllowKilling Parms{};

	Parms.numKills = numKills;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.Authority_AttemptEscapeCarry
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::Authority_AttemptEscapeCarry(class ACamperPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "Authority_AttemptEscapeCarry");

	Params::SlasherPlayer_Authority_AttemptEscapeCarry Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.Authority_HandleKillerInterruptingSurvivor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::Authority_HandleKillerInterruptingSurvivor(class ADBDPlayer* target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "Authority_HandleKillerInterruptingSurvivor");

	Params::SlasherPlayer_Authority_HandleKillerInterruptingSurvivor Parms{};

	Parms.target = target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.Authority_SetInStalkMode
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    stalkMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    forced                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::Authority_SetInStalkMode(bool stalkMode, bool forced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "Authority_SetInStalkMode");

	Params::SlasherPlayer_Authority_SetInStalkMode Parms{};

	Parms.stalkMode = stalkMode;
	Parms.forced = forced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.BroadcastOnInstantTeleport
// (Final, Native, Public, BlueprintCallable)

void ASlasherPlayer::BroadcastOnInstantTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "BroadcastOnInstantTeleport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.CancelAttackByInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::CancelAttackByInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "CancelAttackByInput");

	Params::SlasherPlayer_CancelAttackByInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.Client_RequestStun
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EStunType                               stunType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       stunner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::Client_RequestStun(EStunType stunType, class ADBDPlayer* stunner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "Client_RequestStun");

	Params::SlasherPlayer_Client_RequestStun Parms{};

	Parms.stunType = stunType;
	Parms.stunner = stunner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.Cosmetic_OnCancelCarry
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void ASlasherPlayer::Cosmetic_OnCancelCarry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "Cosmetic_OnCancelCarry");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SlasherPlayer.Cosmetic_OnDropCamperEnd
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void ASlasherPlayer::Cosmetic_OnDropCamperEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "Cosmetic_OnDropCamperEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SlasherPlayer.Cosmetic_OnPickUpEnd
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void ASlasherPlayer::Cosmetic_OnPickUpEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "Cosmetic_OnPickUpEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SlasherPlayer.DBD_AllowKilling
// (Final, Exec, Native, Public)

void ASlasherPlayer::DBD_AllowKilling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "DBD_AllowKilling");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.DBD_DisplayAttackZones
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    display                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::DBD_DisplayAttackZones(bool display)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "DBD_DisplayAttackZones");

	Params::SlasherPlayer_DBD_DisplayAttackZones Parms{};

	Parms.display = display;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.DBD_MergeLockOnDamageZones
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::DBD_MergeLockOnDamageZones(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "DBD_MergeLockOnDamageZones");

	Params::SlasherPlayer_DBD_MergeLockOnDamageZones Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.DBD_SetAttackZones
// (Final, Exec, Native, Public)
// Parameters:
// EAttackZoneSet                          attackZoneSet                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::DBD_SetAttackZones(EAttackZoneSet attackZoneSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "DBD_SetAttackZones");

	Params::SlasherPlayer_DBD_SetAttackZones Parms{};

	Parms.attackZoneSet = attackZoneSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.DecrementInterruptBlock
// (Final, Native, Public, BlueprintCallable)

void ASlasherPlayer::DecrementInterruptBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "DecrementInterruptBlock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.DisplayAttackZones
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    display                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::DisplayAttackZones(bool display)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "DisplayAttackZones");

	Params::SlasherPlayer_DisplayAttackZones Parms{};

	Parms.display = display;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SlasherPlayer.GetCurrentRotationYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASlasherPlayer::GetCurrentRotationYaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetCurrentRotationYaw");

	Params::SlasherPlayer_GetCurrentRotationYaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.IncrementInterruptBlock
// (Final, Native, Public, BlueprintCallable)

void ASlasherPlayer::IncrementInterruptBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "IncrementInterruptBlock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.IsCrouchAvailable_BP
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::IsCrouchAvailable_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "IsCrouchAvailable_BP");

	Params::SlasherPlayer_IsCrouchAvailable_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.IsIdling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::IsIdling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "IsIdling");

	Params::SlasherPlayer_IsIdling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.IsWalkLocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::IsWalkLocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "IsWalkLocked");

	Params::SlasherPlayer_IsWalkLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.Local_CancelAttack
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::Local_CancelAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "Local_CancelAttack");

	Params::SlasherPlayer_Local_CancelAttack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.MergeLockOnDamageZones
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::MergeLockOnDamageZones(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "MergeLockOnDamageZones");

	Params::SlasherPlayer_MergeLockOnDamageZones Parms{};

	Parms.enable = enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SlasherPlayer.Multicast_Cheat_SetAttackDetectionZoneSet
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// EAttackZoneSet                          attackZoneSet                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::Multicast_Cheat_SetAttackDetectionZoneSet(EAttackZoneSet attackZoneSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "Multicast_Cheat_SetAttackDetectionZoneSet");

	Params::SlasherPlayer_Multicast_Cheat_SetAttackDetectionZoneSet Parms{};

	Parms.attackZoneSet = attackZoneSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.Multicast_DisplayAttackZones
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    display                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::Multicast_DisplayAttackZones(bool display)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "Multicast_DisplayAttackZones");

	Params::SlasherPlayer_Multicast_DisplayAttackZones Parms{};

	Parms.display = display;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.Multicast_MergeLockOnDamageZones
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::Multicast_MergeLockOnDamageZones(bool enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "Multicast_MergeLockOnDamageZones");

	Params::SlasherPlayer_Multicast_MergeLockOnDamageZones Parms{};

	Parms.enable = enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.Multicast_SetGuidedAction
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// ESlasherGuidedAction                    action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::Multicast_SetGuidedAction(ESlasherGuidedAction action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "Multicast_SetGuidedAction");

	Params::SlasherPlayer_Multicast_SetGuidedAction Parms{};

	Parms.action = action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.OnAttackFinish
// (Final, Native, Private)
// Parameters:
// const EAttackType                       attackType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnAttackFinish(const EAttackType attackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnAttackFinish");

	Params::SlasherPlayer_OnAttackFinish Parms{};

	Parms.attackType = attackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.OnAttackStart
// (Final, Native, Private)
// Parameters:
// const EAttackType                       attackType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnAttackStart(const EAttackType attackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnAttackStart");

	Params::SlasherPlayer_OnAttackStart Parms{};

	Parms.attackType = attackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.OnCamperHit
// (Event, Public, BlueprintEvent)
// Parameters:
// class ACamperPlayer*                    camper                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnCamperHit(class ACamperPlayer* camper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnCamperHit");

	Params::SlasherPlayer_OnCamperHit Parms{};

	Parms.camper = camper;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SlasherPlayer.OnDropCamperEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADBDPlayer*                       camper                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnDropCamperEnd(class ADBDPlayer* camper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnDropCamperEnd");

	Params::SlasherPlayer_OnDropCamperEnd Parms{};

	Parms.camper = camper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.OnIsKillingSurvivorWithMoriUpdated
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isKillingSurvivorWithMori                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnIsKillingSurvivorWithMoriUpdated(bool isKillingSurvivorWithMori)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnIsKillingSurvivorWithMoriUpdated");

	Params::SlasherPlayer_OnIsKillingSurvivorWithMoriUpdated Parms{};

	Parms.isKillingSurvivorWithMori = isKillingSurvivorWithMori;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SlasherPlayer.OnKillerAbilityBeginActivate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EKillerAbilities                        killerAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnKillerAbilityBeginActivate(EKillerAbilities killerAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnKillerAbilityBeginActivate");

	Params::SlasherPlayer_OnKillerAbilityBeginActivate Parms{};

	Parms.killerAbility = killerAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.OnKillerAbilityBeginDeactivate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EKillerAbilities                        killerAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    forced                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnKillerAbilityBeginDeactivate(EKillerAbilities killerAbility, bool forced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnKillerAbilityBeginDeactivate");

	Params::SlasherPlayer_OnKillerAbilityBeginDeactivate Parms{};

	Parms.killerAbility = killerAbility;
	Parms.forced = forced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.OnKillerAbilityEndActivate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EKillerAbilities                        killerAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnKillerAbilityEndActivate(EKillerAbilities killerAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnKillerAbilityEndActivate");

	Params::SlasherPlayer_OnKillerAbilityEndActivate Parms{};

	Parms.killerAbility = killerAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.OnKillerAbilityEndDeactivate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EKillerAbilities                        killerAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    forced                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnKillerAbilityEndDeactivate(EKillerAbilities killerAbility, bool forced)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnKillerAbilityEndDeactivate");

	Params::SlasherPlayer_OnKillerAbilityEndDeactivate Parms{};

	Parms.killerAbility = killerAbility;
	Parms.forced = forced;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.OnKillerAbilityUpdateActivate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EKillerAbilities                        killerAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnKillerAbilityUpdateActivate(EKillerAbilities killerAbility, float percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnKillerAbilityUpdateActivate");

	Params::SlasherPlayer_OnKillerAbilityUpdateActivate Parms{};

	Parms.killerAbility = killerAbility;
	Parms.percent = percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.OnLoudNoiseIndicatorDestroyed
// (Final, Native, Private)

void ASlasherPlayer::OnLoudNoiseIndicatorDestroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnLoudNoiseIndicatorDestroyed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.OnLoudNoiseTriggered
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           originator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           instigatingActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    shouldTrack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  audibleRange                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isQuickAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isDeceivingNoise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnLoudNoiseTriggered(class AActor* originator, class AActor* instigatingActor, const struct FVector& location, bool shouldTrack, float* audibleRange, bool isQuickAction, bool isDeceivingNoise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnLoudNoiseTriggered");

	Params::SlasherPlayer_OnLoudNoiseTriggered Parms{};

	Parms.originator = originator;
	Parms.instigatingActor = instigatingActor;
	Parms.location = std::move(location);
	Parms.shouldTrack = shouldTrack;
	Parms.isQuickAction = isQuickAction;
	Parms.isDeceivingNoise = isDeceivingNoise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (audibleRange != nullptr)
		*audibleRange = Parms.audibleRange;
}


// Function DeadByDaylight.SlasherPlayer.OnPerformingChargableInteraction
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnPerformingChargableInteraction(float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnPerformingChargableInteraction");

	Params::SlasherPlayer_OnPerformingChargableInteraction Parms{};

	Parms.Progress = Progress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SlasherPlayer.OnStalkModeChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    stalkMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnStalkModeChanged(bool stalkMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnStalkModeChanged");

	Params::SlasherPlayer_OnStalkModeChanged Parms{};

	Parms.stalkMode = stalkMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SlasherPlayer.OnStalkModeChangedCosmetic
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    stalkMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnStalkModeChangedCosmetic(bool stalkMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnStalkModeChangedCosmetic");

	Params::SlasherPlayer_OnStalkModeChangedCosmetic Parms{};

	Parms.stalkMode = stalkMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SlasherPlayer.OnStealthChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    stealth                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnStealthChanged(bool stealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnStealthChanged");

	Params::SlasherPlayer_OnStealthChanged Parms{};

	Parms.stealth = stealth;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SlasherPlayer.OnSuccessfulInterruption
// (Event, Public, BlueprintEvent)
// Parameters:
// class ACamperPlayer*                    interruptedSurvivor                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnSuccessfulInterruption(class ACamperPlayer* interruptedSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnSuccessfulInterruption");

	Params::SlasherPlayer_OnSuccessfulInterruption Parms{};

	Parms.interruptedSurvivor = interruptedSurvivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SlasherPlayer.OnSurvivorKilled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    playerToKill                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    consumeKill                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    delayedSurvivorDeath                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnSurvivorKilled(class ACamperPlayer* playerToKill, bool consumeKill, bool delayedSurvivorDeath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnSurvivorKilled");

	Params::SlasherPlayer_OnSurvivorKilled Parms{};

	Parms.playerToKill = playerToKill;
	Parms.consumeKill = consumeKill;
	Parms.delayedSurvivorDeath = delayedSurvivorDeath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.OnSurvivorsLeftChanged
// (Final, Native, Private)
// Parameters:
// int32                                   survivorRemaining                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::OnSurvivorsLeftChanged(int32 survivorRemaining)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "OnSurvivorsLeftChanged");

	Params::SlasherPlayer_OnSurvivorsLeftChanged Parms{};

	Parms.survivorRemaining = survivorRemaining;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.PlayBloodHitsEffects
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)

void ASlasherPlayer::PlayBloodHitsEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "PlayBloodHitsEffects");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SlasherPlayer.Server_SendAttackInput
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::Server_SendAttackInput(bool pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "Server_SendAttackInput");

	Params::SlasherPlayer_Server_SendAttackInput Parms{};

	Parms.pressed = pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.SetAttackDetectionZoneSet
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EAttackZoneSet                          attackZoneSet                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::SetAttackDetectionZoneSet(EAttackZoneSet attackZoneSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "SetAttackDetectionZoneSet");

	Params::SlasherPlayer_SetAttackDetectionZoneSet Parms{};

	Parms.attackZoneSet = attackZoneSet;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SlasherPlayer.SetAttackZonePivot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  attackZonePivot                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::SetAttackZonePivot(class USceneComponent* attackZonePivot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "SetAttackZonePivot");

	Params::SlasherPlayer_SetAttackZonePivot Parms{};

	Parms.attackZonePivot = attackZonePivot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.SetCarriedCamper
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    camper                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::SetCarriedCamper(class ACamperPlayer* camper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "SetCarriedCamper");

	Params::SlasherPlayer_SetCarriedCamper Parms{};

	Parms.camper = camper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.SetChainsawSprinting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    chainsawSprinting                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::SetChainsawSprinting(bool chainsawSprinting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "SetChainsawSprinting");

	Params::SlasherPlayer_SetChainsawSprinting Parms{};

	Parms.chainsawSprinting = chainsawSprinting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.SetGuidedAction
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// ESlasherGuidedAction                    action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::SetGuidedAction(ESlasherGuidedAction action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "SetGuidedAction");

	Params::SlasherPlayer_SetGuidedAction Parms{};

	Parms.action = action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.SetIsHookingSurvivor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::SetIsHookingSurvivor(const bool value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "SetIsHookingSurvivor");

	Params::SlasherPlayer_SetIsHookingSurvivor Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.SetIsKilling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isKilling                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::SetIsKilling(bool isKilling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "SetIsKilling");

	Params::SlasherPlayer_SetIsKilling Parms{};

	Parms.isKilling = isKilling;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.SetLightIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   intensity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::SetLightIntensity(float intensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "SetLightIntensity");

	Params::SlasherPlayer_SetLightIntensity Parms{};

	Parms.intensity = intensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.SetStalkTierWalkSpeedMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   stalkTierWalkSpeedMultiplier                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::SetStalkTierWalkSpeedMultiplier(float stalkTierWalkSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "SetStalkTierWalkSpeedMultiplier");

	Params::SlasherPlayer_SetStalkTierWalkSpeedMultiplier Parms{};

	Parms.stalkTierWalkSpeedMultiplier = stalkTierWalkSpeedMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.SetSurvivorBeingKilled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACamperPlayer*                    survivor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::SetSurvivorBeingKilled(class ACamperPlayer* survivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "SetSurvivorBeingKilled");

	Params::SlasherPlayer_SetSurvivorBeingKilled Parms{};

	Parms.survivor = survivor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.SpawnSlasherPower
// (Native, Event, Protected, BlueprintEvent)

void ASlasherPlayer::SpawnSlasherPower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "SpawnSlasherPower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.TriggerPickUpAnimation
// (Event, Public, BlueprintEvent)

void ASlasherPlayer::TriggerPickUpAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "TriggerPickUpAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SlasherPlayer.TriggerPutDownAnimation
// (Event, Public, BlueprintEvent)

void ASlasherPlayer::TriggerPutDownAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "TriggerPutDownAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SlasherPlayer.UpdateRageTierEffect
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   previousTier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   currentTier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASlasherPlayer::UpdateRageTierEffect(int32 previousTier, int32 currentTier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "UpdateRageTierEffect");

	Params::SlasherPlayer_UpdateRageTierEffect Parms{};

	Parms.previousTier = previousTier;
	Parms.currentTier = currentTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.BroadcastOffensiveAction
// (Final, Native, Public, BlueprintCallable, Const)

void ASlasherPlayer::BroadcastOffensiveAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "BroadcastOffensiveAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherPlayer.CanAffectLocalPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::CanAffectLocalPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "CanAffectLocalPlayer");

	Params::SlasherPlayer_CanAffectLocalPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.CanAttack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const EAttackType                       attackType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::CanAttack(const EAttackType attackType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "CanAttack");

	Params::SlasherPlayer_CanAttack Parms{};

	Parms.attackType = attackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.CanAttack_BP
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// const EAttackType                       attackType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::CanAttack_BP(const EAttackType attackType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "CanAttack_BP");

	Params::SlasherPlayer_CanAttack_BP Parms{};

	Parms.attackType = attackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.CanEscapeCarry
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACamperPlayer*                    player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::CanEscapeCarry(class ACamperPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "CanEscapeCarry");

	Params::SlasherPlayer_CanEscapeCarry Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.CanGainRage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::CanGainRage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "CanGainRage");

	Params::SlasherPlayer_CanGainRage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.CanPerformKillerAbility
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EKillerAbilities                        killerAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::CanPerformKillerAbility(EKillerAbilities killerAbility) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "CanPerformKillerAbility");

	Params::SlasherPlayer_CanPerformKillerAbility Parms{};

	Parms.killerAbility = killerAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.CanPickupSurvivor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::CanPickupSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "CanPickupSurvivor");

	Params::SlasherPlayer_CanPickupSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.CanSlashAttack_BP
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::CanSlashAttack_BP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "CanSlashAttack_BP");

	Params::SlasherPlayer_CanSlashAttack_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetAnimDirection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASlasherPlayer::GetAnimDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetAnimDirection");

	Params::SlasherPlayer_GetAnimDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetBlindedPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASlasherPlayer::GetBlindedPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetBlindedPercent");

	Params::SlasherPlayer_GetBlindedPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetCarriedCamper
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACamperPlayer*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACamperPlayer* ASlasherPlayer::GetCarriedCamper() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetCarriedCamper");

	Params::SlasherPlayer_GetCarriedCamper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetCharacterCustomAnimTags
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ASlasherPlayer::GetCharacterCustomAnimTags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetCharacterCustomAnimTags");

	Params::SlasherPlayer_GetCharacterCustomAnimTags Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetChaserCharacterComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UChaserCharacterComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChaserCharacterComponent* ASlasherPlayer::GetChaserCharacterComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetChaserCharacterComponent");

	Params::SlasherPlayer_GetChaserCharacterComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetGuidedAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESlasherGuidedAction                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlasherGuidedAction ASlasherPlayer::GetGuidedAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetGuidedAction");

	Params::SlasherPlayer_GetGuidedAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetIsAttacking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::GetIsAttacking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetIsAttacking");

	Params::SlasherPlayer_GetIsAttacking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetLightIntensity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASlasherPlayer::GetLightIntensity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetLightIntensity");

	Params::SlasherPlayer_GetLightIntensity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetLookRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ASlasherPlayer::GetLookRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetLookRotation");

	Params::SlasherPlayer_GetLookRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetObsessionTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACamperPlayer*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACamperPlayer* ASlasherPlayer::GetObsessionTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetObsessionTarget");

	Params::SlasherPlayer_GetObsessionTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetPlayerDropOffPoint
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ASlasherPlayer::GetPlayerDropOffPoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetPlayerDropOffPoint");

	Params::SlasherPlayer_GetPlayerDropOffPoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetPresenceTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ASlasherPlayer::GetPresenceTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetPresenceTag");

	Params::SlasherPlayer_GetPresenceTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetRageTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASlasherPlayer::GetRageTier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetRageTier");

	Params::SlasherPlayer_GetRageTier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetSlasherMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USlasherMovementComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USlasherMovementComponent* ASlasherPlayer::GetSlasherMovement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetSlasherMovement");

	Params::SlasherPlayer_GetSlasherMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetStalkTierWalkSpeedMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASlasherPlayer::GetStalkTierWalkSpeedMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetStalkTierWalkSpeedMultiplier");

	Params::SlasherPlayer_GetStalkTierWalkSpeedMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetStealthRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ASlasherPlayer::GetStealthRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetStealthRatio");

	Params::SlasherPlayer_GetStealthRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetStillnessStartTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime ASlasherPlayer::GetStillnessStartTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetStillnessStartTime");

	Params::SlasherPlayer_GetStillnessStartTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.GetSurvivorBeingKilled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACamperPlayer*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACamperPlayer* ASlasherPlayer::GetSurvivorBeingKilled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "GetSurvivorBeingKilled");

	Params::SlasherPlayer_GetSurvivorBeingKilled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.HasKillerAbility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EKillerAbilities                        killerAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::HasKillerAbility(EKillerAbilities killerAbility) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "HasKillerAbility");

	Params::SlasherPlayer_HasKillerAbility Parms{};

	Parms.killerAbility = killerAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.HasPreLevelGenerationModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             modifierID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::HasPreLevelGenerationModifier(class FName modifierID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "HasPreLevelGenerationModifier");

	Params::SlasherPlayer_HasPreLevelGenerationModifier Parms{};

	Parms.modifierID = modifierID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.IsAllowedToKill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ACamperPlayer*              camper                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::IsAllowedToKill(const class ACamperPlayer* camper) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "IsAllowedToKill");

	Params::SlasherPlayer_IsAllowedToKill Parms{};

	Parms.camper = camper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.IsCarrying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::IsCarrying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "IsCarrying");

	Params::SlasherPlayer_IsCarrying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.IsChainsawSprinting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::IsChainsawSprinting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "IsChainsawSprinting");

	Params::SlasherPlayer_IsChainsawSprinting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.IsCloaking
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::IsCloaking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "IsCloaking");

	Params::SlasherPlayer_IsCloaking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.IsHooking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::IsHooking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "IsHooking");

	Params::SlasherPlayer_IsHooking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.IsImmuneToObservingPlayerDetection
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 observingPlayer                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::IsImmuneToObservingPlayerDetection(const class ADBDPlayer* observingPlayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "IsImmuneToObservingPlayerDetection");

	Params::SlasherPlayer_IsImmuneToObservingPlayerDetection Parms{};

	Parms.observingPlayer = observingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.IsInterruptBlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::IsInterruptBlocked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "IsInterruptBlocked");

	Params::SlasherPlayer_IsInterruptBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.IsKilling
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::IsKilling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "IsKilling");

	Params::SlasherPlayer_IsKilling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.IsOfferingAllowingKill
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ACamperPlayer*              camper                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::IsOfferingAllowingKill(const class ACamperPlayer* camper) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "IsOfferingAllowingKill");

	Params::SlasherPlayer_IsOfferingAllowingKill Parms{};

	Parms.camper = camper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.IsStunned
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::IsStunned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "IsStunned");

	Params::SlasherPlayer_IsStunned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.IsUncloaking
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::IsUncloaking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "IsUncloaking");

	Params::SlasherPlayer_IsUncloaking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.ShouldApplyBloodlustSpeedModifier
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::ShouldApplyBloodlustSpeedModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "ShouldApplyBloodlustSpeedModifier");

	Params::SlasherPlayer_ShouldApplyBloodlustSpeedModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherPlayer.WasRecentlyCloaked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASlasherPlayer::WasRecentlyCloaked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherPlayer", "WasRecentlyCloaked");

	Params::SlasherPlayer_WasRecentlyCloaked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherStunnableComponent.Server_NotifyStunHasBeenProcessed
// (Net, NetReliable, Native, Event, Public, NetServer)

void USlasherStunnableComponent::Server_NotifyStunHasBeenProcessed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherStunnableComponent", "Server_NotifyStunHasBeenProcessed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyProgressBar.SetPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTallyProgressBar::SetPercent(float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyProgressBar", "SetPercent");

	Params::UMGTallyProgressBar_SetPercent Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyProgressBar.GetPipsCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const int32 UUMGTallyProgressBar::GetPipsCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyProgressBar", "GetPipsCount");

	Params::UMGTallyProgressBar_GetPipsCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.VaultDefinition.GetSpeedCurveToUse
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCurveFloat*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCurveFloat* UVaultDefinition::GetSpeedCurveToUse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultDefinition", "GetSpeedCurveToUse");

	Params::VaultDefinition_GetSpeedCurveToUse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.VaultDefinition.IsWindowVaultable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVaultDefinition::IsWindowVaultable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultDefinition", "IsWindowVaultable");

	Params::VaultDefinition_IsWindowVaultable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.VaultDefinition.IsWithinHeightDelta
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVaultDefinition::IsWithinHeightDelta(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultDefinition", "IsWithinHeightDelta");

	Params::VaultDefinition_IsWithinHeightDelta Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.VaultDefinition.ShouldLaunchCharacter
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVaultDefinition::ShouldLaunchCharacter(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultDefinition", "ShouldLaunchCharacter");

	Params::VaultDefinition_ShouldLaunchCharacter Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SlasherVaultDefinition.OnMontageBlendingOut
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    interrupted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlasherVaultDefinition::OnMontageBlendingOut(class UAnimMontage* montage, bool interrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherVaultDefinition", "OnMontageBlendingOut");

	Params::SlasherVaultDefinition_OnMontageBlendingOut Parms{};

	Parms.montage = montage;
	Parms.interrupted = interrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SlasherVaultDefinition.OnMovementModeChanged
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           prevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   previousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USlasherVaultDefinition::OnMovementModeChanged(class ACharacter* character, EMovementMode prevMovementMode, uint8 previousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlasherVaultDefinition", "OnMovementModeChanged");

	Params::SlasherVaultDefinition_OnMovementModeChanged Parms{};

	Parms.character = character;
	Parms.prevMovementMode = prevMovementMode;
	Parms.previousCustomMode = previousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyScoreboardPlayerInfoWidget.HandleAddFriendEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             buttonID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTallyScoreboardPlayerInfoWidget::HandleAddFriendEvent(class FName buttonID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyScoreboardPlayerInfoWidget", "HandleAddFriendEvent");

	Params::UMGTallyScoreboardPlayerInfoWidget_HandleAddFriendEvent Parms{};

	Parms.buttonID = buttonID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyScoreboardPlayerInfoWidget.HandleReportEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             buttonID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTallyScoreboardPlayerInfoWidget::HandleReportEvent(class FName buttonID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyScoreboardPlayerInfoWidget", "HandleReportEvent");

	Params::UMGTallyScoreboardPlayerInfoWidget_HandleReportEvent Parms{};

	Parms.buttonID = buttonID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyScoreboardPlayerInfoWidget.SetPlayerLoadoutBlocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isBlock                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTallyScoreboardPlayerInfoWidget::SetPlayerLoadoutBlocked(bool isBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyScoreboardPlayerInfoWidget", "SetPlayerLoadoutBlocked");

	Params::UMGTallyScoreboardPlayerInfoWidget_SetPlayerLoadoutBlocked Parms{};

	Parms.isBlock = isBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyScoreboardPlayerInfoWidget.SetPlayerReported
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isReport                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTallyScoreboardPlayerInfoWidget::SetPlayerReported(bool isReport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyScoreboardPlayerInfoWidget", "SetPlayerReported");

	Params::UMGTallyScoreboardPlayerInfoWidget_SetPlayerReported Parms{};

	Parms.isReport = isReport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyScoreboardPlayerInfoWidget.SetPlayerScoreData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FTallyPlayerResultData&    resultData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGTallyScoreboardPlayerInfoWidget::SetPlayerScoreData(const struct FTallyPlayerResultData& resultData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyScoreboardPlayerInfoWidget", "SetPlayerScoreData");

	Params::UMGTallyScoreboardPlayerInfoWidget_SetPlayerScoreData Parms{};

	Parms.resultData = std::move(resultData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyScoreboardPlayerInfoWidget.UpdateLoadout
// (Final, Native, Protected, BlueprintCallable)

void UUMGTallyScoreboardPlayerInfoWidget::UpdateLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyScoreboardPlayerInfoWidget", "UpdateLoadout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyScoreboardPlayerInfoWidget.UpdateReported
// (Event, Protected, BlueprintEvent)

void UUMGTallyScoreboardPlayerInfoWidget::UpdateReported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyScoreboardPlayerInfoWidget", "UpdateReported");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGTallyScoreboardPlayerInfoWidget.UpdateWidget
// (Event, Protected, BlueprintEvent)

void UUMGTallyScoreboardPlayerInfoWidget::UpdateWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyScoreboardPlayerInfoWidget", "UpdateWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SpecialEventGameplaySpawnerComponent.Multicast_OnComponentSpawned
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void USpecialEventGameplaySpawnerComponent::Multicast_OnComponentSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpecialEventGameplaySpawnerComponent", "Multicast_OnComponentSpawned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SplashScreen.OnSaveGamePopupComplete
// (Final, Native, Protected)

void USplashScreen::OnSaveGamePopupComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplashScreen", "OnSaveGamePopupComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SplashScreen.HidePressKeyState
// (Final, Native, Public, Const)

void USplashScreen::HidePressKeyState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplashScreen", "HidePressKeyState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SplashScreen.SetVersionText
// (Final, Native, Public, Const)
// Parameters:
// const class FString&                    versionText                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplashScreen::SetVersionText(const class FString& versionText) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplashScreen", "SetVersionText");

	Params::SplashScreen_SetVersionText Parms{};

	Parms.versionText = std::move(versionText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SplashScreen.ShowLoadingState
// (Final, Native, Public, Const)

void USplashScreen::ShowLoadingState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplashScreen", "ShowLoadingState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SplashScreen.ShowPressKeyState
// (Final, Native, Public, Const)

void USplashScreen::ShowPressKeyState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplashScreen", "ShowPressKeyState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SplashScreen.ShowSaveGamePopup
// (Final, Native, Public, Const)

void USplashScreen::ShowSaveGamePopup() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplashScreen", "ShowSaveGamePopup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SplashScreen.ShowSpecialEventVisual
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// const struct FSpecialEventUIInfo&       eventInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USplashScreen::ShowSpecialEventVisual(const struct FSpecialEventUIInfo& eventInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplashScreen", "ShowSpecialEventVisual");

	Params::SplashScreen_ShowSpecialEventVisual Parms{};

	Parms.eventInfo = std::move(eventInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SplashScreen.UpdateLoadingProgression
// (Final, Native, Public, Const)
// Parameters:
// const class FString&                    loadingProgression                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplashScreen::UpdateLoadingProgression(const class FString& loadingProgression) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplashScreen", "UpdateLoadingProgression");

	Params::SplashScreen_UpdateLoadingProgression Parms{};

	Parms.loadingProgression = std::move(loadingProgression);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StalkedComponent.OnRep_IsBeingStalked
// (Final, Native, Private)

void UStalkedComponent::OnRep_IsBeingStalked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkedComponent", "OnRep_IsBeingStalked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StalkedComponent.OnRep_MaxStalkPoints
// (Final, Native, Private)

void UStalkedComponent::OnRep_MaxStalkPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkedComponent", "OnRep_MaxStalkPoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StalkedComponent.HasStalkPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStalkedComponent::HasStalkPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkedComponent", "HasStalkPoints");

	Params::StalkedComponent_HasStalkPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StalkerComponent.OnPlayerBeingStalkedChanged
// (Final, Native, Private)
// Parameters:
// bool                                    isBeingStalked                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStalkerComponent::OnPlayerBeingStalkedChanged(bool isBeingStalked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkerComponent", "OnPlayerBeingStalkedChanged");

	Params::StalkerComponent_OnPlayerBeingStalkedChanged Parms{};

	Parms.isBeingStalked = isBeingStalked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StalkerComponent.CanStalk
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStalkerComponent::CanStalk() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkerComponent", "CanStalk");

	Params::StalkerComponent_CanStalk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StalkerComponent.GetMaxStalkingPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStalkerComponent::GetMaxStalkingPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkerComponent", "GetMaxStalkingPoints");

	Params::StalkerComponent_GetMaxStalkingPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StalkerComponent.GetPercentStalkingPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStalkerComponent::GetPercentStalkingPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkerComponent", "GetPercentStalkingPoints");

	Params::StalkerComponent_GetPercentStalkingPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StalkerComponent.GetScoreMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStalkerComponent::GetScoreMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkerComponent", "GetScoreMultiplier");

	Params::StalkerComponent_GetScoreMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StalkerComponent.GetTotalStalkingPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UStalkerComponent::GetTotalStalkingPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkerComponent", "GetTotalStalkingPoints");

	Params::StalkerComponent_GetTotalStalkingPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StalkerComponent.HasMaxStalkPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStalkerComponent::HasMaxStalkPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkerComponent", "HasMaxStalkPoints");

	Params::StalkerComponent_HasMaxStalkPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StalkerComponent.IsStalkingSomeone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStalkerComponent::IsStalkingSomeone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StalkerComponent", "IsStalkingSomeone");

	Params::StalkerComponent_IsStalkingSomeone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StartScreenBase.BeginDestroyTravelSequence
// (Event, Public, BlueprintEvent)

void AStartScreenBase::BeginDestroyTravelSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StartScreenBase", "BeginDestroyTravelSequence");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.StartScreenBase.TravelToMenu
// (Final, Native, Public, BlueprintCallable)

void AStartScreenBase::TravelToMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StartScreenBase", "TravelToMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StateTagUtilities.AddStateTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TScriptInterface<class IObjectStateProvider>objectStateProvider                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateTagUtilities::AddStateTag(const TScriptInterface<class IObjectStateProvider> objectStateProvider, const struct FGameplayTag& tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "AddStateTag");

	Params::StateTagUtilities_AddStateTag Parms{};

	Parms.objectStateProvider = objectStateProvider;
	Parms.tag = std::move(tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StateTagUtilities.AddStateTagToPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateTagUtilities::AddStateTagToPlayer(const class ADBDPlayer* player, const struct FGameplayTag& tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "AddStateTagToPlayer");

	Params::StateTagUtilities_AddStateTagToPlayer Parms{};

	Parms.player = player;
	Parms.tag = std::move(tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StateTagUtilities.CurrentInteractionHasAnyStateTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateTagUtilities::CurrentInteractionHasAnyStateTag(const class ADBDPlayer* player, const struct FGameplayTagContainer& tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "CurrentInteractionHasAnyStateTag");

	Params::StateTagUtilities_CurrentInteractionHasAnyStateTag Parms{};

	Parms.player = player;
	Parms.tags = std::move(tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StateTagUtilities.CurrentInteractionHasStateTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateTagUtilities::CurrentInteractionHasStateTag(const class ADBDPlayer* player, const struct FGameplayTag& tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "CurrentInteractionHasStateTag");

	Params::StateTagUtilities_CurrentInteractionHasStateTag Parms{};

	Parms.player = player;
	Parms.tag = std::move(tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StateTagUtilities.HasAnyStateTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TScriptInterface<class IObjectStateProvider>objectStateProvider                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateTagUtilities::HasAnyStateTags(const TScriptInterface<class IObjectStateProvider> objectStateProvider, const struct FGameplayTagContainer& tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "HasAnyStateTags");

	Params::StateTagUtilities_HasAnyStateTags Parms{};

	Parms.objectStateProvider = objectStateProvider;
	Parms.tags = std::move(tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StateTagUtilities.HasStateTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TScriptInterface<class IObjectStateProvider>objectStateProvider                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UStateTagUtilities::HasStateTag(const TScriptInterface<class IObjectStateProvider> objectStateProvider, const struct FGameplayTag& tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "HasStateTag");

	Params::StateTagUtilities_HasStateTag Parms{};

	Parms.objectStateProvider = objectStateProvider;
	Parms.tag = std::move(tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.StateTagUtilities.RemoveStateTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const TScriptInterface<class IObjectStateProvider>objectStateProvider                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateTagUtilities::RemoveStateTag(const TScriptInterface<class IObjectStateProvider> objectStateProvider, const struct FGameplayTag& tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "RemoveStateTag");

	Params::StateTagUtilities_RemoveStateTag Parms{};

	Parms.objectStateProvider = objectStateProvider;
	Parms.tag = std::move(tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StateTagUtilities.RemoveStateTagToPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStateTagUtilities::RemoveStateTagToPlayer(const class ADBDPlayer* player, const struct FGameplayTag& tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StateTagUtilities", "RemoveStateTagToPlayer");

	Params::StateTagUtilities_RemoveStateTagToPlayer Parms{};

	Parms.player = player;
	Parms.tag = std::move(tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterSelectionWidget.BroadcastRoleButtonClicked
// (Final, Native, Protected)

void UUMGCharacterSelectionWidget::BroadcastRoleButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterSelectionWidget", "BroadcastRoleButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterSelectionWidget.BroadcastSelectedCharacter
// (Final, Native, Protected)
// Parameters:
// int32                                   characterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCharacterSelectionWidget::BroadcastSelectedCharacter(int32 characterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterSelectionWidget", "BroadcastSelectedCharacter");

	Params::UMGCharacterSelectionWidget_BroadcastSelectedCharacter Parms{};

	Parms.characterIndex = characterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterSelectionWidget.SwitchPanel
// (Final, Native, Protected)

void UUMGCharacterSelectionWidget::SwitchPanel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterSelectionWidget", "SwitchPanel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StatusEffectCollectionComponent.OnRep_Array
// (Final, Native, Private)

void UStatusEffectCollectionComponent::OnRep_Array()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatusEffectCollectionComponent", "OnRep_Array");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGChargeableInteractionWidget.ClearProficienciesData
// (Event, Protected, BlueprintEvent)

void UUMGChargeableInteractionWidget::ClearProficienciesData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGChargeableInteractionWidget", "ClearProficienciesData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGChargeableInteractionWidget.SetItemChargeColor
// (Event, Public, BlueprintEvent)
// Parameters:
// const EBarColor                         barColor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGChargeableInteractionWidget::SetItemChargeColor(const EBarColor barColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGChargeableInteractionWidget", "SetItemChargeColor");

	Params::UMGChargeableInteractionWidget_SetItemChargeColor Parms{};

	Parms.barColor = barColor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGChargeableInteractionWidget.SetItemChargeValue
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGChargeableInteractionWidget::SetItemChargeValue(float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGChargeableInteractionWidget", "SetItemChargeValue");

	Params::UMGChargeableInteractionWidget_SetItemChargeValue Parms{};

	Parms.value = value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGChargeableInteractionWidget.SetMessage
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class FString&                    message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGChargeableInteractionWidget::SetMessage(const class FString& message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGChargeableInteractionWidget", "SetMessage");

	Params::UMGChargeableInteractionWidget_SetMessage Parms{};

	Parms.message = std::move(message);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGChargeableInteractionWidget.SetOpacity
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   opacity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGChargeableInteractionWidget::SetOpacity(float opacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGChargeableInteractionWidget", "SetOpacity");

	Params::UMGChargeableInteractionWidget_SetOpacity Parms{};

	Parms.opacity = opacity;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGChargeableInteractionWidget.SetProficiencyData
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// int32                                   index                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FStatusEffectSlotData&     proficiencyData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGChargeableInteractionWidget::SetProficiencyData(int32 index, const struct FStatusEffectSlotData& proficiencyData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGChargeableInteractionWidget", "SetProficiencyData");

	Params::UMGChargeableInteractionWidget_SetProficiencyData Parms{};

	Parms.index = index;
	Parms.proficiencyData = std::move(proficiencyData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGChargeableInteractionWidget.SetProgressBarColor
// (Event, Public, BlueprintEvent)
// Parameters:
// const EBarColor                         barColor                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGChargeableInteractionWidget::SetProgressBarColor(const EBarColor barColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGChargeableInteractionWidget", "SetProgressBarColor");

	Params::UMGChargeableInteractionWidget_SetProgressBarColor Parms{};

	Parms.barColor = barColor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGChargeableInteractionWidget.SetProgressbarValue
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGChargeableInteractionWidget::SetProgressbarValue(float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGChargeableInteractionWidget", "SetProgressbarValue");

	Params::UMGChargeableInteractionWidget_SetProgressbarValue Parms{};

	Parms.value = value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGChargeableInteractionWidget.SetSecondaryMessage
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class FString&                    secondMessage                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGChargeableInteractionWidget::SetSecondaryMessage(const class FString& secondMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGChargeableInteractionWidget", "SetSecondaryMessage");

	Params::UMGChargeableInteractionWidget_SetSecondaryMessage Parms{};

	Parms.secondMessage = std::move(secondMessage);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.StoreScreen.OnBuyCurrencyBundle
// (Final, Native, Protected)
// Parameters:
// int32                                   index                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnBuyCurrencyBundle(int32 index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnBuyCurrencyBundle");

	Params::StoreScreen_OnBuyCurrencyBundle Parms{};

	Parms.index = index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnEquipItem
// (Final, Native, Protected)
// Parameters:
// const class FString&                    itemId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnEquipItem(const class FString& itemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnEquipItem");

	Params::StoreScreen_OnEquipItem Parms{};

	Parms.itemId = std::move(itemId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnFeaturedBannerDlcSelected
// (Final, Native, Protected)
// Parameters:
// const class FString&                    dlcId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnFeaturedBannerDlcSelected(const class FString& dlcId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnFeaturedBannerDlcSelected");

	Params::StoreScreen_OnFeaturedBannerDlcSelected Parms{};

	Parms.dlcId = std::move(dlcId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnFeaturedBannerItemSelected
// (Final, Native, Protected)
// Parameters:
// const class FString&                    itemId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isOutfit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnFeaturedBannerItemSelected(const class FString& itemId, bool isOutfit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnFeaturedBannerItemSelected");

	Params::StoreScreen_OnFeaturedBannerItemSelected Parms{};

	Parms.itemId = std::move(itemId);
	Parms.isOutfit = isOutfit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnFeaturedButtonSelected
// (Final, Native, Protected)
// Parameters:
// int32                                   linkIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnFeaturedButtonSelected(int32 linkIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnFeaturedButtonSelected");

	Params::StoreScreen_OnFeaturedButtonSelected Parms{};

	Parms.linkIndex = linkIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnFeaturedCharacterSelected
// (Final, Native, Protected)
// Parameters:
// int32                                   characterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnFeaturedCharacterSelected(int32 characterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnFeaturedCharacterSelected");

	Params::StoreScreen_OnFeaturedCharacterSelected Parms{};

	Parms.characterIndex = characterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnFeaturedStoreItemSelected
// (Final, Native, Protected)
// Parameters:
// const class FString&                    itemId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isOutfit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnFeaturedStoreItemSelected(const class FString& itemId, bool isOutfit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnFeaturedStoreItemSelected");

	Params::StoreScreen_OnFeaturedStoreItemSelected Parms{};

	Parms.itemId = std::move(itemId);
	Parms.isOutfit = isOutfit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnFiltersUpdated
// (Final, Native, Protected)
// Parameters:
// bool                                    all                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    rarityCommon                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    rarityUncommon                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    rarityRare                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    rarityVeryRare                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    rarityUltraRare                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    rarityArtifact                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    rarityLegendary                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    raritySpecialEvent                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    includeAllOwnedItems                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnFiltersUpdated(bool all, bool rarityCommon, bool rarityUncommon, bool rarityRare, bool rarityVeryRare, bool rarityUltraRare, bool rarityArtifact, bool rarityLegendary, bool raritySpecialEvent, bool includeAllOwnedItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnFiltersUpdated");

	Params::StoreScreen_OnFiltersUpdated Parms{};

	Parms.all = all;
	Parms.rarityCommon = rarityCommon;
	Parms.rarityUncommon = rarityUncommon;
	Parms.rarityRare = rarityRare;
	Parms.rarityVeryRare = rarityVeryRare;
	Parms.rarityUltraRare = rarityUltraRare;
	Parms.rarityArtifact = rarityArtifact;
	Parms.rarityLegendary = rarityLegendary;
	Parms.raritySpecialEvent = raritySpecialEvent;
	Parms.includeAllOwnedItems = includeAllOwnedItems;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnMarketSlotButtonClick
// (Final, Native, Protected)
// Parameters:
// int32                                   slotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnMarketSlotButtonClick(int32 slotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnMarketSlotButtonClick");

	Params::StoreScreen_OnMarketSlotButtonClick Parms{};

	Parms.slotIndex = slotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnNotEnoughTokens
// (Final, Native, Protected)

void UStoreScreen::OnNotEnoughTokens()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnNotEnoughTokens");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnPromoCodeButtonClicked
// (Final, Native, Protected)

void UStoreScreen::OnPromoCodeButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnPromoCodeButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnRotateCharacter
// (Final, Native, Protected)
// Parameters:
// float                                   mouseDistanceChange                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnRotateCharacter(float mouseDistanceChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnRotateCharacter");

	Params::StoreScreen_OnRotateCharacter Parms{};

	Parms.mouseDistanceChange = mouseDistanceChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnSearchInputChanged
// (Final, Native, Protected)
// Parameters:
// const class FString&                    searchInput                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnSearchInputChanged(const class FString& searchInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnSearchInputChanged");

	Params::StoreScreen_OnSearchInputChanged Parms{};

	Parms.searchInput = std::move(searchInput);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnStoreCatalogCategorySelected
// (Final, Native, Protected)
// Parameters:
// int32                                   categoryIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnStoreCatalogCategorySelected(int32 categoryIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnStoreCatalogCategorySelected");

	Params::StoreScreen_OnStoreCatalogCategorySelected Parms{};

	Parms.categoryIndex = categoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnStoreCharacterSelected
// (Final, Native, Protected)
// Parameters:
// int32                                   characterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnStoreCharacterSelected(int32 characterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnStoreCharacterSelected");

	Params::StoreScreen_OnStoreCharacterSelected Parms{};

	Parms.characterIndex = characterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnStoreItemLinkSelected
// (Final, Native, Protected)
// Parameters:
// const class FString&                    itemId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnStoreItemLinkSelected(const class FString& itemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnStoreItemLinkSelected");

	Params::StoreScreen_OnStoreItemLinkSelected Parms{};

	Parms.itemId = std::move(itemId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnStoreItemSelected
// (Final, Native, Protected)
// Parameters:
// const class FString&                    itemId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnStoreItemSelected(const class FString& itemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnStoreItemSelected");

	Params::StoreScreen_OnStoreItemSelected Parms{};

	Parms.itemId = std::move(itemId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnTabSelected
// (Final, Native, Protected)
// Parameters:
// int32                                   index                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnTabSelected(int32 index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnTabSelected");

	Params::StoreScreen_OnTabSelected Parms{};

	Parms.index = index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnUnlockWithCurrency
// (Final, Native, Protected)
// Parameters:
// int32                                   currencyId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    combinedItem                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnUnlockWithCurrency(int32 currencyId, const class FString& combinedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnUnlockWithCurrency");

	Params::StoreScreen_OnUnlockWithCurrency Parms{};

	Parms.currencyId = currencyId;
	Parms.combinedItem = std::move(combinedItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnCatalogSelected
// (Final, Native, Protected, Const)

void UStoreScreen::OnCatalogSelected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnCatalogSelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnStorySelected
// (Final, Native, Protected, Const)

void UStoreScreen::OnStorySelected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnStorySelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StoreScreen.OnUnlockDlc
// (Final, Native, Protected, Const)
// Parameters:
// const class FString&                    dlcId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStoreScreen::OnUnlockDlc(const class FString& dlcId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StoreScreen", "OnUnlockDlc");

	Params::StoreScreen_OnUnlockDlc Parms{};

	Parms.dlcId = std::move(dlcId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGControlTypeWidget.HandleButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UUMGControlTypeWidget::HandleButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGControlTypeWidget", "HandleButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGControlTypeWidget.InitializeDefaultLayout
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// EAtlantaControlTypeSetting              controlType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGControlTypeWidget::InitializeDefaultLayout(EAtlantaControlTypeSetting controlType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGControlTypeWidget", "InitializeDefaultLayout");

	Params::UMGControlTypeWidget_InitializeDefaultLayout Parms{};

	Parms.controlType = controlType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGControlTypeWidget.IsChecked
// (Event, Protected, BlueprintEvent)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UUMGControlTypeWidget::IsChecked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGControlTypeWidget", "IsChecked");

	Params::UMGControlTypeWidget_IsChecked Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGControlTypeWidget.SetOptionChecked
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    isChecked                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGControlTypeWidget::SetOptionChecked(bool isChecked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGControlTypeWidget", "SetOptionChecked");

	Params::UMGControlTypeWidget_SetOptionChecked Parms{};

	Parms.isChecked = isChecked;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.StreamVideoManager.OnStreamVideoDone
// (Final, Native, Public)

void UStreamVideoManager::OnStreamVideoDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StreamVideoManager", "OnStreamVideoDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.StreamVideoScreenUMG.OnCloseTriggered
// (Final, Native, Private)

void UStreamVideoScreenUMG::OnCloseTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StreamVideoScreenUMG", "OnCloseTriggered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCustomizationItemBuyButton.BroadcastUnlockWithCurrency
// (Final, Native, Protected, BlueprintCallable)

void UUMGCustomizationItemBuyButton::BroadcastUnlockWithCurrency()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCustomizationItemBuyButton", "BroadcastUnlockWithCurrency");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SubtitlesManager.IsDebuggingSubtitles
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USubtitlesManager::IsDebuggingSubtitles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SubtitlesManager", "IsDebuggingSubtitles");

	Params::SubtitlesManager_IsDebuggingSubtitles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SubtitlesManager.PostAkEventWithSubtitles
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UAkGameObject*                    target                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FAkEventWithSubtitle>&akEventRandomizer                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   maxSubtitleDistance                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   callbackMask                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>&postEventCallback                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// const TArray<struct FAkExternalSourceInfo>&externalSources                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, AdvancedDisplay, NativeAccessSpecifierPublic)
// class UAkAudioEvent**                   akEventPlayed                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USubtitlesManager::PostAkEventWithSubtitles(class UAkGameObject* target, const TArray<struct FAkEventWithSubtitle>& akEventRandomizer, float maxSubtitleDistance, int32 callbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& postEventCallback, const TArray<struct FAkExternalSourceInfo>& externalSources, class UAkAudioEvent** akEventPlayed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SubtitlesManager", "PostAkEventWithSubtitles");

	Params::SubtitlesManager_PostAkEventWithSubtitles Parms{};

	Parms.target = target;
	Parms.akEventRandomizer = std::move(akEventRandomizer);
	Parms.maxSubtitleDistance = maxSubtitleDistance;
	Parms.callbackMask = callbackMask;
	Parms.postEventCallback = postEventCallback;
	Parms.externalSources = std::move(externalSources);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (akEventPlayed != nullptr)
		*akEventPlayed = Parms.akEventPlayed;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SupplyCrateAnimInstance.OnBeingPriedOpenStarted
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USupplyCrateAnimInstance::OnBeingPriedOpenStarted(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupplyCrateAnimInstance", "OnBeingPriedOpenStarted");

	Params::SupplyCrateAnimInstance_OnBeingPriedOpenStarted Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SupplyCrateAnimInstance.OnBeingPriedOpenStopped
// (Final, Native, Private)

void USupplyCrateAnimInstance::OnBeingPriedOpenStopped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupplyCrateAnimInstance", "OnBeingPriedOpenStopped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SupplyCrateInteractable.OnIsClosing
// (Event, Public, BlueprintEvent)

void ASupplyCrateInteractable::OnIsClosing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupplyCrateInteractable", "OnIsClosing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SupplyCrateInteractable.OnIsOpened
// (Event, Public, BlueprintEvent)

void ASupplyCrateInteractable::OnIsOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupplyCrateInteractable", "OnIsOpened");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SupplyCrateInteractable.OnRep_IsAutoClosing
// (Final, Native, Private)

void ASupplyCrateInteractable::OnRep_IsAutoClosing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupplyCrateInteractable", "OnRep_IsAutoClosing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SupplyCrateInteractable.OnRep_IsOpen
// (Final, Native, Private)

void ASupplyCrateInteractable::OnRep_IsOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SupplyCrateInteractable", "OnRep_IsOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurviveTimerScoreEventComponent.Authority_OnGameStarted
// (Final, Native, Private)

void USurviveTimerScoreEventComponent::Authority_OnGameStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurviveTimerScoreEventComponent", "Authority_OnGameStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGRankBanner.HandleTooltipLongPressedEvent
// (Final, Native, Private)

void UUMGRankBanner::HandleTooltipLongPressedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGRankBanner", "HandleTooltipLongPressedEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGRankBanner.SetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerRole                             playerRole                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGRankBanner::SetData(int32 rank, EPlayerRole playerRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGRankBanner", "SetData");

	Params::UMGRankBanner_SetData Parms{};

	Parms.rank = rank;
	Parms.playerRole = playerRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGRankBanner.StartHighlight
// (Native, Public, BlueprintCallable)

void UUMGRankBanner::StartHighlight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGRankBanner", "StartHighlight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGRankBanner.StopHighlight
// (Native, Public, BlueprintCallable)

void UUMGRankBanner::StopHighlight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGRankBanner", "StopHighlight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorActivityIndicatorComponent.Authority_OnCamperEscape
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameplayTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USurvivorActivityIndicatorComponent::Authority_OnCamperEscape(const struct FGameplayTag& gameplayTag, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorActivityIndicatorComponent", "Authority_OnCamperEscape");

	Params::SurvivorActivityIndicatorComponent_Authority_OnCamperEscape Parms{};

	Parms.gameplayTag = std::move(gameplayTag);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorActivityIndicatorComponent.HandleStartActivityIfStillInEffect
// (Final, Native, Private)
// Parameters:
// const struct FSurvivorActivity&         activityViewInfo                                       (ConstParm, Parm, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorActivityIndicatorComponent::HandleStartActivityIfStillInEffect(const struct FSurvivorActivity& activityViewInfo, const struct FGameplayTag& tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorActivityIndicatorComponent", "HandleStartActivityIfStillInEffect");

	Params::SurvivorActivityIndicatorComponent_HandleStartActivityIfStillInEffect Parms{};

	Parms.activityViewInfo = std::move(activityViewInfo);
	Parms.tag = std::move(tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorActivityIndicatorComponent.Multicast_OnCamperEscape
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void USurvivorActivityIndicatorComponent::Multicast_OnCamperEscape()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorActivityIndicatorComponent", "Multicast_OnCamperEscape");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorActivityIndicatorComponent.OnChargeableProgressChanged
// (Final, Native, Private)
// Parameters:
// class UChargeableComponent*             chargeableComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   totalPercentComplete                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorActivityIndicatorComponent::OnChargeableProgressChanged(class UChargeableComponent* chargeableComponent, float totalPercentComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorActivityIndicatorComponent", "OnChargeableProgressChanged");

	Params::SurvivorActivityIndicatorComponent_OnChargeableProgressChanged Parms{};

	Parms.chargeableComponent = chargeableComponent;
	Parms.totalPercentComplete = totalPercentComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorActivityIndicatorComponent.OnDamageStateChanged
// (Final, Native, Private)
// Parameters:
// ECamperDamageState                      oldDamageState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECamperDamageState                      currentDamageState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorActivityIndicatorComponent::OnDamageStateChanged(ECamperDamageState oldDamageState, ECamperDamageState currentDamageState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorActivityIndicatorComponent", "OnDamageStateChanged");

	Params::SurvivorActivityIndicatorComponent_OnDamageStateChanged Parms{};

	Parms.oldDamageState = oldDamageState;
	Parms.currentDamageState = currentDamageState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorActivityIndicatorComponent.OnPlayerDropped
// (Final, Native, Private)

void USurvivorActivityIndicatorComponent::OnPlayerDropped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorActivityIndicatorComponent", "OnPlayerDropped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorActivityIndicatorComponent.OnPlayerImmobilizeStateChanged
// (Final, Native, Private)
// Parameters:
// const ECamperImmobilizeState            oldImmobilizeState                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ECamperImmobilizeState            newImmobilizeState                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorActivityIndicatorComponent::OnPlayerImmobilizeStateChanged(const ECamperImmobilizeState oldImmobilizeState, const ECamperImmobilizeState newImmobilizeState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorActivityIndicatorComponent", "OnPlayerImmobilizeStateChanged");

	Params::SurvivorActivityIndicatorComponent_OnPlayerImmobilizeStateChanged Parms{};

	Parms.oldImmobilizeState = oldImmobilizeState;
	Parms.newImmobilizeState = newImmobilizeState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorActivityIndicatorComponent.OnPlayerPickedUp
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       picker                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorActivityIndicatorComponent::OnPlayerPickedUp(class ADBDPlayer* picker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorActivityIndicatorComponent", "OnPlayerPickedUp");

	Params::SurvivorActivityIndicatorComponent_OnPlayerPickedUp Parms{};

	Parms.picker = picker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorAttackableComponent.Authority_HitCosmetic
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     attacker                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAttackType                             attackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    causeKO                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isWeaponHit                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorAttackableComponent::Authority_HitCosmetic(const class AActor* attacker, EAttackType attackType, bool causeKO, bool isWeaponHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorAttackableComponent", "Authority_HitCosmetic");

	Params::SurvivorAttackableComponent_Authority_HitCosmetic Parms{};

	Parms.attacker = attacker;
	Parms.attackType = attackType;
	Parms.causeKO = causeKO;
	Parms.isWeaponHit = isWeaponHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorAttackableComponent.Multicast_HitCosmetic
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, BlueprintCallable)
// Parameters:
// const struct FPlayerHitCosmeticParams&  params                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USurvivorAttackableComponent::Multicast_HitCosmetic(const struct FPlayerHitCosmeticParams& params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorAttackableComponent", "Multicast_HitCosmetic");

	Params::SurvivorAttackableComponent_Multicast_HitCosmetic Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorAttackableComponent.Multicast_HitCosmetic_NonLocal
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FPlayerHitCosmeticParams&  params                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USurvivorAttackableComponent::Multicast_HitCosmetic_NonLocal(const struct FPlayerHitCosmeticParams& params)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorAttackableComponent", "Multicast_HitCosmetic_NonLocal");

	Params::SurvivorAttackableComponent_Multicast_HitCosmetic_NonLocal Parms{};

	Parms.params = std::move(params);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorBloodFXComponent.SpawnBloodSpurts
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UNiagaraComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraComponent* USurvivorBloodFXComponent::SpawnBloodSpurts()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorBloodFXComponent", "SpawnBloodSpurts");

	Params::SurvivorBloodFXComponent_SpawnBloodSpurts Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGRitualRefreshButton.SetRefreshButton
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   currency                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECurrencyType                           currentyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isAdsRefresh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGRitualRefreshButton::SetRefreshButton(int32 currency, ECurrencyType currentyType, bool isAdsRefresh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGRitualRefreshButton", "SetRefreshButton");

	Params::UMGRitualRefreshButton_SetRefreshButton Parms{};

	Parms.currency = currency;
	Parms.currentyType = currentyType;
	Parms.isAdsRefresh = isAdsRefresh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorDisconnectionComponent.Authority_OnPlayerDisconnected
// (Final, Native, Protected)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorDisconnectionComponent::Authority_OnPlayerDisconnected(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorDisconnectionComponent", "Authority_OnPlayerDisconnected");

	Params::SurvivorDisconnectionComponent_Authority_OnPlayerDisconnected Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorHitCosmeticHandler.OnMontageStarted
// (Final, Native, Private)
// Parameters:
// const struct FAnimationMontageDescriptor&animMontageID                                          (ConstParm, Parm, NativeAccessSpecifierPublic)
// const float                             playRate                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorHitCosmeticHandler::OnMontageStarted(const struct FAnimationMontageDescriptor& animMontageID, const float playRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorHitCosmeticHandler", "OnMontageStarted");

	Params::SurvivorHitCosmeticHandler_OnMontageStarted Parms{};

	Parms.animMontageID = std::move(animMontageID);
	Parms.playRate = playRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorOutlineUpdateStrategy.GetEffectsProtectingFromKillerAuraReading
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ACamperPlayer*              subject                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ASlasherPlayer*             killer                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UGameplayModifierContainer*>ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UGameplayModifierContainer*> USurvivorOutlineUpdateStrategy::GetEffectsProtectingFromKillerAuraReading(const class ACamperPlayer* subject, const class ASlasherPlayer* killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SurvivorOutlineUpdateStrategy", "GetEffectsProtectingFromKillerAuraReading");

	Params::SurvivorOutlineUpdateStrategy_GetEffectsProtectingFromKillerAuraReading Parms{};

	Parms.subject = subject;
	Parms.killer = killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorOutlineUpdateStrategy.IsActivelyHidingAuraFromKiller
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ACamperPlayer*              subject                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ASlasherPlayer*             witness                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USurvivorOutlineUpdateStrategy::IsActivelyHidingAuraFromKiller(const class ACamperPlayer* subject, const class ASlasherPlayer* witness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SurvivorOutlineUpdateStrategy", "IsActivelyHidingAuraFromKiller");

	Params::SurvivorOutlineUpdateStrategy_IsActivelyHidingAuraFromKiller Parms{};

	Parms.subject = subject;
	Parms.witness = witness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorOutlineUpdateStrategy.SetTrappedIconActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorOutlineUpdateStrategy::SetTrappedIconActive(bool value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorOutlineUpdateStrategy", "SetTrappedIconActive");

	Params::SurvivorOutlineUpdateStrategy_SetTrappedIconActive Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorOutlineUpdateStrategy.IsBlockingAuraReadingFromKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ASlasherPlayer*             killer                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USurvivorOutlineUpdateStrategy::IsBlockingAuraReadingFromKiller(const class ASlasherPlayer* killer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorOutlineUpdateStrategy", "IsBlockingAuraReadingFromKiller");

	Params::SurvivorOutlineUpdateStrategy_IsBlockingAuraReadingFromKiller Parms{};

	Parms.killer = killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGHudEditorScreen.Quit
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorScreen::Quit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorScreen", "Quit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorScreen.RegisterEditorLayoutScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerRole                             role                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUMGHudEditorLayoutScreen*        screen                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHudEditorScreen::RegisterEditorLayoutScreen(EPlayerRole role, class UUMGHudEditorLayoutScreen* screen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorScreen", "RegisterEditorLayoutScreen");

	Params::UMGHudEditorScreen_RegisterEditorLayoutScreen Parms{};

	Parms.role = role;
	Parms.screen = screen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorScreen.SetEditorDropErrorOverlapSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    onDropOverlapSound                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHudEditorScreen::SetEditorDropErrorOverlapSound(class UAkAudioEvent* onDropOverlapSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorScreen", "SetEditorDropErrorOverlapSound");

	Params::UMGHudEditorScreen_SetEditorDropErrorOverlapSound Parms{};

	Parms.onDropOverlapSound = onDropOverlapSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorScreen.SetWidgets
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUMGHudEditorLayoutWidget*        hudEditorLayoutWidget                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUMGHudEditorVersionWidget*       versionSwapWidget                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHudEditorScreen::SetWidgets(class UUMGHudEditorLayoutWidget* hudEditorLayoutWidget, class UUMGHudEditorVersionWidget* versionSwapWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorScreen", "SetWidgets");

	Params::UMGHudEditorScreen_SetWidgets Parms{};

	Parms.hudEditorLayoutWidget = hudEditorLayoutWidget;
	Parms.versionSwapWidget = versionSwapWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorScreen.ShowHudLayout
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerRole                             role                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHudEditorScreen::ShowHudLayout(EPlayerRole role)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorScreen", "ShowHudLayout");

	Params::UMGHudEditorScreen_ShowHudLayout Parms{};

	Parms.role = role;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorScreen.GetVersionSwapWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUMGHudEditorVersionWidget*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUMGHudEditorVersionWidget* UUMGHudEditorScreen::GetVersionSwapWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorScreen", "GetVersionSwapWidget");

	Params::UMGHudEditorScreen_GetVersionSwapWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Authority_AddSickness
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   sicknessToAdd                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::Authority_AddSickness(float sicknessToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Authority_AddSickness");

	Params::SurvivorPlagueEffect_Authority_AddSickness Parms{};

	Parms.sicknessToAdd = sicknessToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Authority_InfectInteractable
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AInteractable*                    interactable                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::Authority_InfectInteractable(class AInteractable* interactable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Authority_InfectInteractable");

	Params::SurvivorPlagueEffect_Authority_InfectInteractable Parms{};

	Parms.interactable = interactable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SurvivorPlagueEffect.Authority_OnHitBySuperVomitProjectile
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void USurvivorPlagueEffect::Authority_OnHitBySuperVomitProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Authority_OnHitBySuperVomitProjectile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Authority_OnHitByVomitProjectile
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   sicknessToAdd                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::Authority_OnHitByVomitProjectile(float sicknessToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Authority_OnHitByVomitProjectile");

	Params::SurvivorPlagueEffect_Authority_OnHitByVomitProjectile Parms{};

	Parms.sicknessToAdd = sicknessToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Authority_OnHitByVomitProjectileAesthetic
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void USurvivorPlagueEffect::Authority_OnHitByVomitProjectileAesthetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Authority_OnHitByVomitProjectileAesthetic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Authority_ResetSickness
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   newSickness                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::Authority_ResetSickness(float newSickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Authority_ResetSickness");

	Params::SurvivorPlagueEffect_Authority_ResetSickness Parms{};

	Parms.newSickness = newSickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Multicast_AddOnScreenDebugMessage
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// uint64                                  key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FColor&                    displayColor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    debugMessage                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::Multicast_AddOnScreenDebugMessage(uint64 key, float duration, const struct FColor& displayColor, const class FString& debugMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Multicast_AddOnScreenDebugMessage");

	Params::SurvivorPlagueEffect_Multicast_AddOnScreenDebugMessage Parms{};

	Parms.key = key;
	Parms.duration = duration;
	Parms.displayColor = std::move(displayColor);
	Parms.debugMessage = std::move(debugMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Multicast_OnMaxSicknessReached
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void USurvivorPlagueEffect::Multicast_OnMaxSicknessReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Multicast_OnMaxSicknessReached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Multicast_OnSicknessChanged
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// float                                   newSickness                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::Multicast_OnSicknessChanged(float newSickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Multicast_OnSicknessChanged");

	Params::SurvivorPlagueEffect_Multicast_OnSicknessChanged Parms{};

	Parms.newSickness = newSickness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Multicast_OnSicknessCured
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void USurvivorPlagueEffect::Multicast_OnSicknessCured()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Multicast_OnSicknessCured");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Multicast_OnSurvivorBecomesInfected
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void USurvivorPlagueEffect::Multicast_OnSurvivorBecomesInfected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Multicast_OnSurvivorBecomesInfected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.Multicast_OnSurvivorVomit
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void USurvivorPlagueEffect::Multicast_OnSurvivorVomit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "Multicast_OnSurvivorVomit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.OnHitByVomit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isSuperVomit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::OnHitByVomit(bool isSuperVomit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "OnHitByVomit");

	Params::SurvivorPlagueEffect_OnHitByVomit Parms{};

	Parms.isSuperVomit = isSuperVomit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.OnMaxSicknessReached_Aesthetic
// (Event, Protected, BlueprintEvent)

void USurvivorPlagueEffect::OnMaxSicknessReached_Aesthetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "OnMaxSicknessReached_Aesthetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SurvivorPlagueEffect.OnRep_SicknessAmount
// (Final, Native, Public)

void USurvivorPlagueEffect::OnRep_SicknessAmount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "OnRep_SicknessAmount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.OnSicknessChanged_Aesthetic
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   newSickness                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorPlagueEffect::OnSicknessChanged_Aesthetic(float newSickness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "OnSicknessChanged_Aesthetic");

	Params::SurvivorPlagueEffect_OnSicknessChanged_Aesthetic Parms{};

	Parms.newSickness = newSickness;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.SurvivorPlagueEffect.OnSicknessCured_Aesthetic
// (Event, Protected, BlueprintEvent)

void USurvivorPlagueEffect::OnSicknessCured_Aesthetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "OnSicknessCured_Aesthetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SurvivorPlagueEffect.OnSurvivorBecomesInfected_Aesthetic
// (Event, Protected, BlueprintEvent)

void USurvivorPlagueEffect::OnSurvivorBecomesInfected_Aesthetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "OnSurvivorBecomesInfected_Aesthetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SurvivorPlagueEffect.OnSurvivorVomit_Aesthetic
// (Event, Protected, BlueprintEvent)

void USurvivorPlagueEffect::OnSurvivorVomit_Aesthetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "OnSurvivorVomit_Aesthetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.SurvivorPlagueEffect.RefreshSicknessGainValues
// (Final, Native, Public, BlueprintCallable)

void USurvivorPlagueEffect::RefreshSicknessGainValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "RefreshSicknessGainValues");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.SurvivorPlagueEffect.GetMaxSicknessLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 USurvivorPlagueEffect::GetMaxSicknessLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "GetMaxSicknessLevel");

	Params::SurvivorPlagueEffect_GetMaxSicknessLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorPlagueEffect.GetSicknessAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USurvivorPlagueEffect::GetSicknessAmount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "GetSicknessAmount");

	Params::SurvivorPlagueEffect_GetSicknessAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorPlagueEffect.GetSicknessLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 USurvivorPlagueEffect::GetSicknessLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "GetSicknessLevel");

	Params::SurvivorPlagueEffect_GetSicknessLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorPlagueEffect.GetSicknessPercentage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USurvivorPlagueEffect::GetSicknessPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "GetSicknessPercentage");

	Params::SurvivorPlagueEffect_GetSicknessPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorPlagueEffect.GetSicknessThresholds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> USurvivorPlagueEffect::GetSicknessThresholds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "GetSicknessThresholds");

	Params::SurvivorPlagueEffect_GetSicknessThresholds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorPlagueEffect.HasMaxLevelSickness
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USurvivorPlagueEffect::HasMaxLevelSickness() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "HasMaxLevelSickness");

	Params::SurvivorPlagueEffect_HasMaxLevelSickness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorPlagueEffect.IsDebugModeActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USurvivorPlagueEffect::IsDebugModeActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "IsDebugModeActive");

	Params::SurvivorPlagueEffect_IsDebugModeActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.SurvivorPlagueEffect.IsInfected
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USurvivorPlagueEffect::IsInfected() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorPlagueEffect", "IsInfected");

	Params::SurvivorPlagueEffect_IsInfected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TerrorRadiusIndicatorWidget.SetSoundDistancePercentage
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   distancePercentage                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrorRadiusIndicatorWidget::SetSoundDistancePercentage(float distancePercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrorRadiusIndicatorWidget", "SetSoundDistancePercentage");

	Params::TerrorRadiusIndicatorWidget_SetSoundDistancePercentage Parms{};

	Parms.distancePercentage = distancePercentage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLoadoutFilterButton.InitFilterButton
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      filterName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class UTexture2D>  filterTexture                                          (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutFilterButton::InitFilterButton(const class FName& filterName, const TSoftObjectPtr<class UTexture2D> filterTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutFilterButton", "InitFilterButton");

	Params::UMGLoadoutFilterButton_InitFilterButton Parms{};

	Parms.filterName = filterName;
	Parms.filterTexture = filterTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutFilterButton.OnActionButtonClick
// (Final, Native, Public)

void UUMGLoadoutFilterButton::OnActionButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutFilterButton", "OnActionButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutFilterButton.SetIcon
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const TSoftObjectPtr<class UTexture2D>& icon                                                   (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutFilterButton::SetIcon(const TSoftObjectPtr<class UTexture2D>& icon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutFilterButton", "SetIcon");

	Params::UMGLoadoutFilterButton_SetIcon Parms{};

	Parms.icon = icon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLoadoutFilterButton.SetIsSelected
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isSelected                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutFilterButton::SetIsSelected(bool isSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutFilterButton", "SetIsSelected");

	Params::UMGLoadoutFilterButton_SetIsSelected Parms{};

	Parms.isSelected = isSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.TimerGate.AddTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATimerGate::AddTime(float time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerGate", "AddTime");

	Params::TimerGate_AddTime Parms{};

	Parms.time = time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TimerGate.RemoveTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATimerGate::RemoveTime(float time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerGate", "RemoveTime");

	Params::TimerGate_RemoveTime Parms{};

	Parms.time = time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TimerGate.Reset
// (Final, Native, Public, BlueprintCallable)

void ATimerGate::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerGate", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TimerGate.Rushed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATimerGate::Rushed(bool success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerGate", "Rushed");

	Params::TimerGate_Rushed Parms{};

	Parms.success = success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TimerGate.SetValues
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimerDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RushGain                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RushBlockDuration                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATimerGate::SetValues(float TimerDuration, float RushGain, float RushBlockDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerGate", "SetValues");

	Params::TimerGate_SetValues Parms{};

	Parms.TimerDuration = TimerDuration;
	Parms.RushGain = RushGain;
	Parms.RushBlockDuration = RushBlockDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TimerGate.Update
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   deltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATimerGate::Update(float deltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerGate", "Update");

	Params::TimerGate_Update Parms{};

	Parms.deltaTime = deltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TimerGateDecrease.Update
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   deltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATimerGateDecrease::Update(float deltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimerGateDecrease", "Update");

	Params::TimerGateDecrease_Update Parms{};

	Parms.deltaTime = deltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreRowWidget.BroadcastBloodNodeSelected
// (Final, Native, Private)
// Parameters:
// const class FString&                    id                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBloodStoreRowWidget::BroadcastBloodNodeSelected(const class FString& id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreRowWidget", "BroadcastBloodNodeSelected");

	Params::UMGBloodStoreRowWidget_BroadcastBloodNodeSelected Parms{};

	Parms.id = std::move(id);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreRowWidget.BroadcastUnlockAnimationFinished
// (Final, Native, Protected, BlueprintCallable)

void UUMGBloodStoreRowWidget::BroadcastUnlockAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreRowWidget", "BroadcastUnlockAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreRowWidget.LockRow
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    playAnim                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBloodStoreRowWidget::LockRow(bool playAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreRowWidget", "LockRow");

	Params::UMGBloodStoreRowWidget_LockRow Parms{};

	Parms.playAnim = playAnim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGBloodStoreRowWidget.UnlockRow
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    playAnim                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBloodStoreRowWidget::UnlockRow(bool playAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreRowWidget", "UnlockRow");

	Params::UMGBloodStoreRowWidget_UnlockRow Parms{};

	Parms.playAnim = playAnim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.ToastNotificationScreen.OnButtonSelected
// (Final, Native, Public)
// Parameters:
// int32                                   buttonId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   notificationId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToastNotificationScreen::OnButtonSelected(int32 buttonId, int32 notificationId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToastNotificationScreen", "OnButtonSelected");

	Params::ToastNotificationScreen_OnButtonSelected Parms{};

	Parms.buttonId = buttonId;
	Parms.notificationId = notificationId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ToastNotificationScreen.OnNotificationDisplayEnd
// (Final, Native, Public)
// Parameters:
// int32                                   notificationId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToastNotificationScreen::OnNotificationDisplayEnd(int32 notificationId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToastNotificationScreen", "OnNotificationDisplayEnd");

	Params::ToastNotificationScreen_OnNotificationDisplayEnd Parms{};

	Parms.notificationId = notificationId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ToastNotificationScreen.OnPromptSelected
// (Final, Native, Public)
// Parameters:
// int32                                   notificationId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UToastNotificationScreen::OnPromptSelected(int32 notificationId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ToastNotificationScreen", "OnPromptSelected");

	Params::ToastNotificationScreen_OnPromptSelected Parms{};

	Parms.notificationId = notificationId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TokenProvider.GetTokenProvider
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTokenCounter*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTokenCounter* ITokenProvider::GetTokenProvider() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("TokenProvider", "GetTokenProvider");

	Params::TokenProvider_GetTokenProvider Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGCharacterButton.BroadcastClickedEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   characterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCharacterButton::BroadcastClickedEvent(int32 characterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterButton", "BroadcastClickedEvent");

	Params::UMGCharacterButton_BroadcastClickedEvent Parms{};

	Parms.characterIndex = characterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterButton.SetCharacterData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FCharacterSlotData&        characterData                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGCharacterButton::SetCharacterData(const struct FCharacterSlotData& characterData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterButton", "SetCharacterData");

	Params::UMGCharacterButton_SetCharacterData Parms{};

	Parms.characterData = std::move(characterData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterButton.SetIsSelected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isSelected                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCharacterButton::SetIsSelected(bool isSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterButton", "SetIsSelected");

	Params::UMGCharacterButton_SetIsSelected Parms{};

	Parms.isSelected = isSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ToolBoxInterface.GetChargerComponent
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UChargerComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargerComponent* IToolBoxInterface::GetChargerComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("ToolBoxInterface", "GetChargerComponent");

	Params::ToolBoxInterface_GetChargerComponent Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TooltipScreenUMG.OnCloseTriggered
// (Final, Native, Private)

void UTooltipScreenUMG::OnCloseTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TooltipScreenUMG", "OnCloseTriggered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Totem.Authority_BindToPerk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTotemBoundPerk*                  perk                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATotem::Authority_BindToPerk(class UTotemBoundPerk* perk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "Authority_BindToPerk");

	Params::Totem_Authority_BindToPerk Parms{};

	Parms.perk = perk;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Totem.Authority_Cleanse
// (Final, Native, Public, BlueprintCallable)

void ATotem::Authority_Cleanse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "Authority_Cleanse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Totem.Authority_UnbindFromAllPerks
// (Final, Native, Public, BlueprintCallable)

void ATotem::Authority_UnbindFromAllPerks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "Authority_UnbindFromAllPerks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Totem.Authority_UnbindFromPerk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTotemBoundPerk*                  perk                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATotem::Authority_UnbindFromPerk(class UTotemBoundPerk* perk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "Authority_UnbindFromPerk");

	Params::Totem_Authority_UnbindFromPerk Parms{};

	Parms.perk = perk;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Totem.OnBlockTotemCosmetic
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATotem::OnBlockTotemCosmetic(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "OnBlockTotemCosmetic");

	Params::Totem_OnBlockTotemCosmetic Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Totem.OnCleanseTotem
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ATotem*                           totem                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ETotemState                       oldTotemState                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATotem::OnCleanseTotem(class ATotem* totem, const ETotemState oldTotemState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "OnCleanseTotem");

	Params::Totem_OnCleanseTotem Parms{};

	Parms.totem = totem;
	Parms.oldTotemState = oldTotemState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Totem.OnLocallyObservedChanged
// (Final, Native, Private)

void ATotem::OnLocallyObservedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "OnLocallyObservedChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Totem.OnRep_TotemState
// (Final, Native, Private)
// Parameters:
// const ETotemState                       oldTotemState                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATotem::OnRep_TotemState(const ETotemState oldTotemState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "OnRep_TotemState");

	Params::Totem_OnRep_TotemState Parms{};

	Parms.oldTotemState = oldTotemState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Totem.OnTotemBlockChanged
// (Final, Native, Private)

void ATotem::OnTotemBlockChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "OnTotemBlockChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.Totem.OnTotemStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// const ETotemState                       oldTotemState                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const ETotemState                       newTotemState                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATotem::OnTotemStateChanged(const ETotemState oldTotemState, const ETotemState newTotemState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "OnTotemStateChanged");

	Params::Totem_OnTotemStateChanged Parms{};

	Parms.oldTotemState = oldTotemState;
	Parms.newTotemState = newTotemState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Totem.OnUnblockTotemCosmetic
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATotem::OnUnblockTotemCosmetic(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "OnUnblockTotemCosmetic");

	Params::Totem_OnUnblockTotemCosmetic Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.Totem.GetAkAudioComponent
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UAkComponent*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkComponent* ATotem::GetAkAudioComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "GetAkAudioComponent");

	Params::Totem_GetAkAudioComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.GetBlessTotemInteraction
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UChargeableInteractionDefinition* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableInteractionDefinition* ATotem::GetBlessTotemInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "GetBlessTotemInteraction");

	Params::Totem_GetBlessTotemInteraction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.GetBoonAuraRevealColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ATotem::GetBoonAuraRevealColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "GetBoonAuraRevealColor");

	Params::Totem_GetBoonAuraRevealColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.GetBoonTotemAuraRevealRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATotem::GetBoonTotemAuraRevealRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "GetBoonTotemAuraRevealRange");

	Params::Totem_GetBoonTotemAuraRevealRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.GetBoonTotemBlessingRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATotem::GetBoonTotemBlessingRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "GetBoonTotemBlessingRange");

	Params::Totem_GetBoonTotemBlessingRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.GetCleanseTotemInteraction
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UChargeableInteractionDefinition* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UChargeableInteractionDefinition* ATotem::GetCleanseTotemInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "GetCleanseTotemInteraction");

	Params::Totem_GetCleanseTotemInteraction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.GetMainInteractor
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UInteractor*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractor* ATotem::GetMainInteractor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "GetMainInteractor");

	Params::Totem_GetMainInteractor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.GetTotemState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETotemState                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETotemState ATotem::GetTotemState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "GetTotemState");

	Params::Totem_GetTotemState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.IsBoundToPerk
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATotem::IsBoundToPerk() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "IsBoundToPerk");

	Params::Totem_IsBoundToPerk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.Totem.IsTotemBlockedForPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADBDPlayer*                 player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATotem::IsTotemBlockedForPlayer(const class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Totem", "IsTotemBlockedForPlayer");

	Params::Totem_IsTotemBlockedForPlayer Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGCharacterInfoScreen.HandlePowerItemTooltipLongPressedEvent
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// const struct FInventorySlotData&        slotData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector2D&                 position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCharacterInfoScreen::HandlePowerItemTooltipLongPressedEvent(const struct FInventorySlotData& slotData, const struct FVector2D& position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterInfoScreen", "HandlePowerItemTooltipLongPressedEvent");

	Params::UMGCharacterInfoScreen_HandlePowerItemTooltipLongPressedEvent Parms{};

	Parms.slotData = std::move(slotData);
	Parms.position = std::move(position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterInfoScreen.HandleProgressionButtonClickEvent
// (Final, Native, Protected, BlueprintCallable)

void UUMGCharacterInfoScreen::HandleProgressionButtonClickEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterInfoScreen", "HandleProgressionButtonClickEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterInfoScreen.HandleTeachablePerkTooltipLongPressedEvent
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// const struct FTeachableData&            teachableData                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector2D&                 position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCharacterInfoScreen::HandleTeachablePerkTooltipLongPressedEvent(const struct FTeachableData& teachableData, const struct FVector2D& position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterInfoScreen", "HandleTeachablePerkTooltipLongPressedEvent");

	Params::UMGCharacterInfoScreen_HandleTeachablePerkTooltipLongPressedEvent Parms{};

	Parms.teachableData = std::move(teachableData);
	Parms.position = std::move(position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TotemOutlineUpdateStrategy.GetRevealColorToSurvivor
// (Final, Native, Public, HasDefaults, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UTotemOutlineUpdateStrategy::GetRevealColorToSurvivor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TotemOutlineUpdateStrategy", "GetRevealColorToSurvivor");

	Params::TotemOutlineUpdateStrategy_GetRevealColorToSurvivor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TriggerableActivatorComponent.Authority_OnLevelReadyToPlay
// (Final, Native, Private)

void UTriggerableActivatorComponent::Authority_OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerableActivatorComponent", "Authority_OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TriplanarDecalComponent.UpdateTriplanarDecal
// (Event, Public, BlueprintEvent)

void UTriplanarDecalComponent::UpdateTriplanarDecal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriplanarDecalComponent", "UpdateTriplanarDecal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGCharacterPrestigeButton.OnPrestigeButtonClicked
// (Final, Native, Protected)

void UUMGCharacterPrestigeButton::OnPrestigeButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterPrestigeButton", "OnPrestigeButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterPrestigeButton.SetCharacterPrestigeData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    canPrestige                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             prestigeLevel                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EPlayerRole                       role                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCharacterPrestigeButton::SetCharacterPrestigeData(bool canPrestige, const int32 prestigeLevel, const EPlayerRole role)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterPrestigeButton", "SetCharacterPrestigeData");

	Params::UMGCharacterPrestigeButton_SetCharacterPrestigeData Parms{};

	Parms.canPrestige = canPrestige;
	Parms.prestigeLevel = prestigeLevel;
	Parms.role = role;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialEndGameComponent.SetTimerMaxCompletionPercentage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const float&                            percentage                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialEndGameComponent::SetTimerMaxCompletionPercentage(const float& percentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialEndGameComponent", "SetTimerMaxCompletionPercentage");

	Params::TutorialEndGameComponent_SetTimerMaxCompletionPercentage Parms{};

	Parms.percentage = percentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialGameMode.SetEscapeActivated
// (Final, Native, Public, BlueprintCallable)

void ATutorialGameMode::SetEscapeActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameMode", "SetEscapeActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialGameMode.SetEscapeGenerators
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AGenerator*>&        escapeGenerators                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   requiredActivationCount                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialGameMode::SetEscapeGenerators(const TArray<class AGenerator*>& escapeGenerators, int32 requiredActivationCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameMode", "SetEscapeGenerators");

	Params::TutorialGameMode_SetEscapeGenerators Parms{};

	Parms.escapeGenerators = std::move(escapeGenerators);
	Parms.requiredActivationCount = requiredActivationCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialGameMode.GetAtlantaTutorialPlayerHudController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAtlantaTutorialPlayerHudController*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtlantaTutorialPlayerHudController* ATutorialGameMode::GetAtlantaTutorialPlayerHudController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameMode", "GetAtlantaTutorialPlayerHudController");

	Params::TutorialGameMode_GetAtlantaTutorialPlayerHudController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialGameMode.GetTutorialHighlightController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTutorialHighlightController*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTutorialHighlightController* ATutorialGameMode::GetTutorialHighlightController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameMode", "GetTutorialHighlightController");

	Params::TutorialGameMode_GetTutorialHighlightController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialGameMode.GetTutorialNotificationController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTutorialNotificationController*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTutorialNotificationController* ATutorialGameMode::GetTutorialNotificationController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameMode", "GetTutorialNotificationController");

	Params::TutorialGameMode_GetTutorialNotificationController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialGameMode.GetTutorialObjectiveController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTutorialObjectiveController*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTutorialObjectiveController* ATutorialGameMode::GetTutorialObjectiveController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialGameMode", "GetTutorialObjectiveController");

	Params::TutorialGameMode_GetTutorialObjectiveController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialHighlightController.SetHudComponentHighlight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHudComponent                           hudComponent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialHighlightController::SetHudComponentHighlight(EHudComponent hudComponent, bool show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialHighlightController", "SetHudComponentHighlight");

	Params::TutorialHighlightController_SetHudComponentHighlight Parms{};

	Parms.hudComponent = hudComponent;
	Parms.show = show;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialObjectiveController.AddObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             tutorialObjectiveId                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialObjectiveController::AddObjective(class FName tutorialObjectiveId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialObjectiveController", "AddObjective");

	Params::TutorialObjectiveController_AddObjective Parms{};

	Parms.tutorialObjectiveId = tutorialObjectiveId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialObjectiveController.CompleteObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             tutorialObjectiveId                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    removeAfterCompletion                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialObjectiveController::CompleteObjective(class FName tutorialObjectiveId, bool removeAfterCompletion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialObjectiveController", "CompleteObjective");

	Params::TutorialObjectiveController_CompleteObjective Parms{};

	Parms.tutorialObjectiveId = tutorialObjectiveId;
	Parms.removeAfterCompletion = removeAfterCompletion;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialObjectiveController.RemoveAllObjectives
// (Final, Native, Public, BlueprintCallable)

void UTutorialObjectiveController::RemoveAllObjectives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialObjectiveController", "RemoveAllObjectives");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialObjectiveController.RemoveObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             tutorialObjectiveId                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTutorialObjectiveController::RemoveObjective(class FName tutorialObjectiveId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialObjectiveController", "RemoveObjective");

	Params::TutorialObjectiveController_RemoveObjective Parms{};

	Parms.tutorialObjectiveId = tutorialObjectiveId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGPlayerRankInfo.SetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   pipsRequiredForNextRank                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   filledPips                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      titleLabel                                             (Parm, NativeAccessSpecifierPublic)
// const class FText&                      pipLabel                                               (Parm, NativeAccessSpecifierPublic)
// EPlayerRole                             playerRole                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsHighlight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGPlayerRankInfo::SetData(int32 rank, int32 pipsRequiredForNextRank, int32 filledPips, const class FText& titleLabel, const class FText& pipLabel, EPlayerRole playerRole, bool IsHighlight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPlayerRankInfo", "SetData");

	Params::UMGPlayerRankInfo_SetData Parms{};

	Parms.rank = rank;
	Parms.pipsRequiredForNextRank = pipsRequiredForNextRank;
	Parms.filledPips = filledPips;
	Parms.titleLabel = std::move(titleLabel);
	Parms.pipLabel = std::move(pipLabel);
	Parms.playerRole = playerRole;
	Parms.IsHighlight = IsHighlight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialsUtilities.DestroyAI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAIController*                    aiController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATutorialsUtilities::DestroyAI(class AAIController* aiController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialsUtilities", "DestroyAI");

	Params::TutorialsUtilities_DestroyAI Parms{};

	Parms.aiController = aiController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialsUtilities.GetTutorialsUtilities
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATutorialsUtilities*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATutorialsUtilities* ATutorialsUtilities::GetTutorialsUtilities(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TutorialsUtilities", "GetTutorialsUtilities");

	Params::TutorialsUtilities_GetTutorialsUtilities Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.TutorialsUtilities.TriggerTutorialHudFadeIn
// (Final, Native, Public, BlueprintCallable)

void ATutorialsUtilities::TriggerTutorialHudFadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialsUtilities", "TriggerTutorialHudFadeIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.TutorialsUtilities.TriggerTutorialHudFadeOut
// (Final, Native, Public, BlueprintCallable)

void ATutorialsUtilities::TriggerTutorialHudFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TutorialsUtilities", "TriggerTutorialHudFadeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationWidget.SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimationWidget::SetPlayRate(float rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationWidget", "SetPlayRate");

	Params::AnimationWidget_SetPlayRate Parms{};

	Parms.rate = rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.AnimationWidget.GetPlayRate
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimationWidget::GetPlayRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationWidget", "GetPlayRate");

	Params::AnimationWidget_GetPlayRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGAddonButton.UpdateAddonButton
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UItemAddon*                       addon                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAddonButton::UpdateAddonButton(class UItemAddon* addon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAddonButton", "UpdateAddonButton");

	Params::UMGAddonButton_UpdateAddonButton Parms{};

	Parms.addon = addon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaEventsDescription.HandleButtonClicked
// (Final, Native, Private)

void UUMGAtlantaEventsDescription::HandleButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaEventsDescription", "HandleButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaEventsScreen.BroadcastDeepLinkRequest
// (Final, Native, Private)
// Parameters:
// const class FString&                    id                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaEventsScreen::BroadcastDeepLinkRequest(const class FString& id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaEventsScreen", "BroadcastDeepLinkRequest");

	Params::UMGAtlantaEventsScreen_BroadcastDeepLinkRequest Parms{};

	Parms.id = std::move(id);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaEventsScreen.BroadcastOnCloseButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UUMGAtlantaEventsScreen::BroadcastOnCloseButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaEventsScreen", "BroadcastOnCloseButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaEventsScreen.HandleEventTabClicked
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const class FString&                    id                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaEventsScreen::HandleEventTabClicked(const class FString& id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaEventsScreen", "HandleEventTabClicked");

	Params::UMGAtlantaEventsScreen_HandleEventTabClicked Parms{};

	Parms.id = std::move(id);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaEventsTab.SetHotTag
// (Event, Protected, BlueprintEvent)

void UUMGAtlantaEventsTab::SetHotTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaEventsTab", "SetHotTag");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGAtlantaEventsTab.SetNewTag
// (Event, Protected, BlueprintEvent)

void UUMGAtlantaEventsTab::SetNewTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaEventsTab", "SetNewTag");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGAtlantaEventsTab.SetSelectionVisuals
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    isSelected                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaEventsTab::SetSelectionVisuals(bool isSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaEventsTab", "SetSelectionVisuals");

	Params::UMGAtlantaEventsTab_SetSelectionVisuals Parms{};

	Parms.isSelected = isSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGAtlantaFreeTicketConfirmToUsePopup.GetDecorator
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UUMGRichTextFreeTicketDecorator*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUMGRichTextFreeTicketDecorator* UUMGAtlantaFreeTicketConfirmToUsePopup::GetDecorator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaFreeTicketConfirmToUsePopup", "GetDecorator");

	Params::UMGAtlantaFreeTicketConfirmToUsePopup_GetDecorator Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGAtlantaFreeTicketConfirmToUsePopup.SetFreeTicketIconTexture
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isSlasher                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaFreeTicketConfirmToUsePopup::SetFreeTicketIconTexture(bool isSlasher)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaFreeTicketConfirmToUsePopup", "SetFreeTicketIconTexture");

	Params::UMGAtlantaFreeTicketConfirmToUsePopup_SetFreeTicketIconTexture Parms{};

	Parms.isSlasher = isSlasher;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGAtlantaFreeTicketConfirmToUsePopup.SetPopupTitle
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      characterName                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGAtlantaFreeTicketConfirmToUsePopup::SetPopupTitle(const class FText& characterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaFreeTicketConfirmToUsePopup", "SetPopupTitle");

	Params::UMGAtlantaFreeTicketConfirmToUsePopup_SetPopupTitle Parms{};

	Parms.characterName = std::move(characterName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGAtlantaLevelUpPopup.OnSetData
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// int32                                   level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   prestige                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    prestigeIncreased                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FRewardItemData>&   rewards                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGAtlantaLevelUpPopup::OnSetData(int32 level, int32 prestige, bool prestigeIncreased, const TArray<struct FRewardItemData>& rewards)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaLevelUpPopup", "OnSetData");

	Params::UMGAtlantaLevelUpPopup_OnSetData Parms{};

	Parms.level = level;
	Parms.prestige = prestige;
	Parms.prestigeIncreased = prestigeIncreased;
	Parms.rewards = std::move(rewards);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGSelectedCharacterWidget.OnPrestigeButtonClicked
// (Final, Native, Protected)

void UUMGSelectedCharacterWidget::OnPrestigeButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSelectedCharacterWidget", "OnPrestigeButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSelectedCharacterWidget.SetVisualsForPartyState
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              triggerPartyVisuals                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSelectedCharacterWidget::SetVisualsForPartyState(const bool triggerPartyVisuals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSelectedCharacterWidget", "SetVisualsForPartyState");

	Params::UMGSelectedCharacterWidget_SetVisualsForPartyState Parms{};

	Parms.triggerPartyVisuals = triggerPartyVisuals;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGSelectedCharacterWidget.SetVisualsForReadyState
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              isPlayerReady                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSelectedCharacterWidget::SetVisualsForReadyState(const bool isPlayerReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSelectedCharacterWidget", "SetVisualsForReadyState");

	Params::UMGSelectedCharacterWidget_SetVisualsForReadyState Parms{};

	Parms.isPlayerReady = isPlayerReady;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGAtlantaRankUpPopup.PlayRankUpBannerAnimation
// (Final, Native, Private)

void UUMGAtlantaRankUpPopup::PlayRankUpBannerAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaRankUpPopup", "PlayRankUpBannerAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAltantaRitual.BroadcastOnClaimRewardsButtonPressed
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const int32                             ritualId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAltantaRitual::BroadcastOnClaimRewardsButtonPressed(const int32 ritualId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAltantaRitual", "BroadcastOnClaimRewardsButtonPressed");

	Params::UMGAltantaRitual_BroadcastOnClaimRewardsButtonPressed Parms{};

	Parms.ritualId = ritualId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAltantaRitual.SetData
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FAtlantaRitualUIData&      ritual                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGAltantaRitual::SetData(const struct FAtlantaRitualUIData& ritual)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAltantaRitual", "SetData");

	Params::UMGAltantaRitual_SetData Parms{};

	Parms.ritual = std::move(ritual);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGAtlantaRitualsScreen.BroadcastOnBackButtonPressed
// (Final, Native, Protected, BlueprintCallable)

void UUMGAtlantaRitualsScreen::BroadcastOnBackButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaRitualsScreen", "BroadcastOnBackButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaRitualsScreen.BroadcastOnClaimRewardButtonPressed
// (Final, Native, Private)
// Parameters:
// const int32                             ritualId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaRitualsScreen::BroadcastOnClaimRewardButtonPressed(const int32 ritualId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaRitualsScreen", "BroadcastOnClaimRewardButtonPressed");

	Params::UMGAtlantaRitualsScreen_BroadcastOnClaimRewardButtonPressed Parms{};

	Parms.ritualId = ritualId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaRitualsScreen.SetNewRitualNumbers
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   newDailyRitualNumber                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   newWeeklyRitualNumber                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaRitualsScreen::SetNewRitualNumbers(int32 newDailyRitualNumber, int32 newWeeklyRitualNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaRitualsScreen", "SetNewRitualNumbers");

	Params::UMGAtlantaRitualsScreen_SetNewRitualNumbers Parms{};

	Parms.newDailyRitualNumber = newDailyRitualNumber;
	Parms.newWeeklyRitualNumber = newWeeklyRitualNumber;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGAtlantaRitualTab.BroadcastOnClaimRewardsButtonPressed
// (Final, Native, Private)
// Parameters:
// const int32                             ritualId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaRitualTab::BroadcastOnClaimRewardsButtonPressed(const int32 ritualId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaRitualTab", "BroadcastOnClaimRewardsButtonPressed");

	Params::UMGAtlantaRitualTab_BroadcastOnClaimRewardsButtonPressed Parms{};

	Parms.ritualId = ritualId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingControlsContextWidget.HandleAimAssistToggleClick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    toggleValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingControlsContextWidget::HandleAimAssistToggleClick(bool toggleValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingControlsContextWidget", "HandleAimAssistToggleClick");

	Params::UMGSettingControlsContextWidget_HandleAimAssistToggleClick Parms{};

	Parms.toggleValue = toggleValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingControlsContextWidget.HandleHandSideToggleClick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   index                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingControlsContextWidget::HandleHandSideToggleClick(int32 index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingControlsContextWidget", "HandleHandSideToggleClick");

	Params::UMGSettingControlsContextWidget_HandleHandSideToggleClick Parms{};

	Parms.index = index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingControlsContextWidget.HandleInteractionButtonToggleClick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   index                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingControlsContextWidget::HandleInteractionButtonToggleClick(int32 index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingControlsContextWidget", "HandleInteractionButtonToggleClick");

	Params::UMGSettingControlsContextWidget_HandleInteractionButtonToggleClick Parms{};

	Parms.index = index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingControlsContextWidget.HandleInvertYToggleClick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    toggleValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingControlsContextWidget::HandleInvertYToggleClick(bool toggleValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingControlsContextWidget", "HandleInvertYToggleClick");

	Params::UMGSettingControlsContextWidget_HandleInvertYToggleClick Parms{};

	Parms.toggleValue = toggleValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingControlsContextWidget.HandleKillerCameraSensitivityChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   sliderValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingControlsContextWidget::HandleKillerCameraSensitivityChanged(float sliderValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingControlsContextWidget", "HandleKillerCameraSensitivityChanged");

	Params::UMGSettingControlsContextWidget_HandleKillerCameraSensitivityChanged Parms{};

	Parms.sliderValue = sliderValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingControlsContextWidget.HandleSurvivorCameraSensitivityChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   sliderValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingControlsContextWidget::HandleSurvivorCameraSensitivityChanged(float sliderValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingControlsContextWidget", "HandleSurvivorCameraSensitivityChanged");

	Params::UMGSettingControlsContextWidget_HandleSurvivorCameraSensitivityChanged Parms{};

	Parms.sliderValue = sliderValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaSeasonEndPopup.PlayNewRankFadeInAnimation
// (Final, Native, Private)

void UUMGAtlantaSeasonEndPopup::PlayNewRankFadeInAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaSeasonEndPopup", "PlayNewRankFadeInAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaSeasonEndPopup.TriggerFadeOutAnimationTimer
// (Final, Native, Private)

void UUMGAtlantaSeasonEndPopup::TriggerFadeOutAnimationTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaSeasonEndPopup", "TriggerFadeOutAnimationTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaSettingScreen.HandleAimAssistToggleClick
// (Final, Native, Protected)
// Parameters:
// bool                                    toggleValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaSettingScreen::HandleAimAssistToggleClick(bool toggleValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaSettingScreen", "HandleAimAssistToggleClick");

	Params::UMGAtlantaSettingScreen_HandleAimAssistToggleClick Parms{};

	Parms.toggleValue = toggleValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaSettingScreen.HandleAlwaysDisplayButtonClick
// (Final, Native, Protected)
// Parameters:
// int32                                   tabIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaSettingScreen::HandleAlwaysDisplayButtonClick(int32 tabIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaSettingScreen", "HandleAlwaysDisplayButtonClick");

	Params::UMGAtlantaSettingScreen_HandleAlwaysDisplayButtonClick Parms{};

	Parms.tabIndex = tabIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaSettingScreen.HandleContextButtonClickEvent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   index                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaSettingScreen::HandleContextButtonClickEvent(int32 index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaSettingScreen", "HandleContextButtonClickEvent");

	Params::UMGAtlantaSettingScreen_HandleContextButtonClickEvent Parms{};

	Parms.index = index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaSettingScreen.HandleHandSideToggleClick
// (Final, Native, Protected)
// Parameters:
// int32                                   index                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaSettingScreen::HandleHandSideToggleClick(int32 index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaSettingScreen", "HandleHandSideToggleClick");

	Params::UMGAtlantaSettingScreen_HandleHandSideToggleClick Parms{};

	Parms.index = index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaSettingScreen.HandleInteractionButtonToggleClick
// (Final, Native, Protected)
// Parameters:
// int32                                   index                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaSettingScreen::HandleInteractionButtonToggleClick(int32 index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaSettingScreen", "HandleInteractionButtonToggleClick");

	Params::UMGAtlantaSettingScreen_HandleInteractionButtonToggleClick Parms{};

	Parms.index = index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaSettingScreen.HandleInvertYToggleClick
// (Final, Native, Protected)
// Parameters:
// bool                                    toggleValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaSettingScreen::HandleInvertYToggleClick(bool toggleValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaSettingScreen", "HandleInvertYToggleClick");

	Params::UMGAtlantaSettingScreen_HandleInvertYToggleClick Parms{};

	Parms.toggleValue = toggleValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaSettingScreen.HandleKillerCameraSensitivityChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaSettingScreen::HandleKillerCameraSensitivityChanged(int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaSettingScreen", "HandleKillerCameraSensitivityChanged");

	Params::UMGAtlantaSettingScreen_HandleKillerCameraSensitivityChanged Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaSettingScreen.HandleLanguageButtonClick
// (Final, Native, Protected)
// Parameters:
// int32                                   index                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaSettingScreen::HandleLanguageButtonClick(int32 index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaSettingScreen", "HandleLanguageButtonClick");

	Params::UMGAtlantaSettingScreen_HandleLanguageButtonClick Parms{};

	Parms.index = index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaSettingScreen.HandleLeaveButtonClick
// (Final, Native, Protected, BlueprintCallable)

void UUMGAtlantaSettingScreen::HandleLeaveButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaSettingScreen", "HandleLeaveButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaSettingScreen.HandleSettingTabClick
// (Final, Native, Protected)
// Parameters:
// int32                                   tabIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaSettingScreen::HandleSettingTabClick(int32 tabIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaSettingScreen", "HandleSettingTabClick");

	Params::UMGAtlantaSettingScreen_HandleSettingTabClick Parms{};

	Parms.tabIndex = tabIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaSettingScreen.HandleSurvivorCameraSensitivityChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaSettingScreen::HandleSurvivorCameraSensitivityChanged(int32 value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaSettingScreen", "HandleSurvivorCameraSensitivityChanged");

	Params::UMGAtlantaSettingScreen_HandleSurvivorCameraSensitivityChanged Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGAtlantaSettingScreen.SetRightTopTextInfo
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      title                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    content                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESlateVisibility                        textVisibility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaSettingScreen::SetRightTopTextInfo(const class FText& title, const class FString& content, ESlateVisibility textVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaSettingScreen", "SetRightTopTextInfo");

	Params::UMGAtlantaSettingScreen_SetRightTopTextInfo Parms{};

	Parms.title = std::move(title);
	Parms.content = std::move(content);
	Parms.textVisibility = textVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGAtlantaSettingScreen.ShowCreditsOrConsentsPopup
// (Event, Public, BlueprintEvent)
// Parameters:
// const class FString&                    title                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    content                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGAtlantaSettingScreen::ShowCreditsOrConsentsPopup(const class FString& title, const class FString& content)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGAtlantaSettingScreen", "ShowCreditsOrConsentsPopup");

	Params::UMGAtlantaSettingScreen_ShowCreditsOrConsentsPopup Parms{};

	Parms.title = std::move(title);
	Parms.content = std::move(content);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGSplashScreen.OnTapButtonClicked
// (Final, Native, Private)

void UUMGSplashScreen::OnTapButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSplashScreen", "OnTapButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSplashScreen.OnSaveGamePopupComplete
// (Final, Native, Public, BlueprintCallable, Const)

void UUMGSplashScreen::OnSaveGamePopupComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSplashScreen", "OnSaveGamePopupComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBasePassStorefrontWidget.HandleBuySubscriptionPackButtonClickedEvent
// (Final, Native, Private)
// Parameters:
// class FName                             subscriptionPackID                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBasePassStorefrontWidget::HandleBuySubscriptionPackButtonClickedEvent(class FName subscriptionPackID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBasePassStorefrontWidget", "HandleBuySubscriptionPackButtonClickedEvent");

	Params::UMGBasePassStorefrontWidget_HandleBuySubscriptionPackButtonClickedEvent Parms{};

	Parms.subscriptionPackID = subscriptionPackID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBasePassStorefrontWidget.HandleSubscriptionInfoButtonClickedEvent
// (Final, Native, Private)
// Parameters:
// const class FString&                    subscriptionDetails                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBasePassStorefrontWidget::HandleSubscriptionInfoButtonClickedEvent(const class FString& subscriptionDetails)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBasePassStorefrontWidget", "HandleSubscriptionInfoButtonClickedEvent");

	Params::UMGBasePassStorefrontWidget_HandleSubscriptionInfoButtonClickedEvent Parms{};

	Parms.subscriptionDetails = std::move(subscriptionDetails);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLobbyJoinedWidget.AddPlayerInfo
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// int32                                   playerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlayerInfoData&           playerInfoData                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    isPlayerReady                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FInventorySlotData>&loadoutData                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGLobbyJoinedWidget::AddPlayerInfo(int32 playerId, const struct FPlayerInfoData& playerInfoData, bool isPlayerReady, const TArray<struct FInventorySlotData>& loadoutData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbyJoinedWidget", "AddPlayerInfo");

	Params::UMGLobbyJoinedWidget_AddPlayerInfo Parms{};

	Parms.playerId = playerId;
	Parms.playerInfoData = std::move(playerInfoData);
	Parms.isPlayerReady = isPlayerReady;
	Parms.loadoutData = std::move(loadoutData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLobbyJoinedWidget.HandleLeaveButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UUMGLobbyJoinedWidget::HandleLeaveButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbyJoinedWidget", "HandleLeaveButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLobbyJoinedWidget.RemovePlayersInfo
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   playerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLobbyJoinedWidget::RemovePlayersInfo(int32 playerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbyJoinedWidget", "RemovePlayersInfo");

	Params::UMGLobbyJoinedWidget_RemovePlayersInfo Parms{};

	Parms.playerId = playerId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLobbyJoinedWidget.SetLoadoutDataForLocalPlayer
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<struct FInventorySlotData>&loadoutData                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    usingMatchRules                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    perkSlotsLockedByAdmin                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isSlasher                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLobbyJoinedWidget::SetLoadoutDataForLocalPlayer(const TArray<struct FInventorySlotData>& loadoutData, bool usingMatchRules, bool perkSlotsLockedByAdmin, bool isSlasher)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbyJoinedWidget", "SetLoadoutDataForLocalPlayer");

	Params::UMGLobbyJoinedWidget_SetLoadoutDataForLocalPlayer Parms{};

	Parms.loadoutData = std::move(loadoutData);
	Parms.usingMatchRules = usingMatchRules;
	Parms.perkSlotsLockedByAdmin = perkSlotsLockedByAdmin;
	Parms.isSlasher = isSlasher;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLobbyJoinedWidget.SetLobbyTimer
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLobbyJoinedWidget::SetLobbyTimer(int32 seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbyJoinedWidget", "SetLobbyTimer");

	Params::UMGLobbyJoinedWidget_SetLobbyTimer Parms{};

	Parms.seconds = seconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLobbyJoinedWidget.SetLocalPlayerInfo
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FPlayerInfoData&           playerInfoData                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGLobbyJoinedWidget::SetLocalPlayerInfo(const struct FPlayerInfoData& playerInfoData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbyJoinedWidget", "SetLocalPlayerInfo");

	Params::UMGLobbyJoinedWidget_SetLocalPlayerInfo Parms{};

	Parms.playerInfoData = std::move(playerInfoData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLobbyJoinedWidget.SetReadyStatus
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<struct FPlayerReadyStatusData>&playersReadyStatusData                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGLobbyJoinedWidget::SetReadyStatus(const TArray<struct FPlayerReadyStatusData>& playersReadyStatusData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbyJoinedWidget", "SetReadyStatus");

	Params::UMGLobbyJoinedWidget_SetReadyStatus Parms{};

	Parms.playersReadyStatusData = std::move(playersReadyStatusData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLobbyJoinedWidget.SetWidgetsVisibility
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              widgetsVisibilty                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLobbyJoinedWidget::SetWidgetsVisibility(const bool widgetsVisibilty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbyJoinedWidget", "SetWidgetsVisibility");

	Params::UMGLobbyJoinedWidget_SetWidgetsVisibility Parms{};

	Parms.widgetsVisibilty = widgetsVisibilty;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLobbyJoinedWidget.UpdatePlayersLatency
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TMap<int32, float>&               playersLatency                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    isHost                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLobbyJoinedWidget::UpdatePlayersLatency(const TMap<int32, float>& playersLatency, bool isHost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbyJoinedWidget", "UpdatePlayersLatency");

	Params::UMGLobbyJoinedWidget_UpdatePlayersLatency Parms{};

	Parms.playersLatency = std::move(playersLatency);
	Parms.isHost = isHost;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLobbySearchingWidget.HandleLeaveButtonClicked
// (Final, Native, Protected)

void UUMGLobbySearchingWidget::HandleLeaveButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbySearchingWidget", "HandleLeaveButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLobbySearchingWidget.OnCurrencyTooltipTriggered
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FTooltipPressedData&       tooltipPressedData                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// ECurrencyType                           currencyType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLobbySearchingWidget::OnCurrencyTooltipTriggered(const struct FTooltipPressedData& tooltipPressedData, ECurrencyType currencyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbySearchingWidget", "OnCurrencyTooltipTriggered");

	Params::UMGLobbySearchingWidget_OnCurrencyTooltipTriggered Parms{};

	Parms.tooltipPressedData = std::move(tooltipPressedData);
	Parms.currencyType = currencyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLobbySearchingWidget.OnLevelTooltipTriggered
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FTooltipPressedData&       tooltipPressedData                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUMGLobbySearchingWidget::OnLevelTooltipTriggered(const struct FTooltipPressedData& tooltipPressedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbySearchingWidget", "OnLevelTooltipTriggered");

	Params::UMGLobbySearchingWidget_OnLevelTooltipTriggered Parms{};

	Parms.tooltipPressedData = std::move(tooltipPressedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLobbySearchingWidget.OnRankTooltipTriggered
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FTooltipPressedData&       tooltipPressedData                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUMGLobbySearchingWidget::OnRankTooltipTriggered(const struct FTooltipPressedData& tooltipPressedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbySearchingWidget", "OnRankTooltipTriggered");

	Params::UMGLobbySearchingWidget_OnRankTooltipTriggered Parms{};

	Parms.tooltipPressedData = std::move(tooltipPressedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLobbySearchingWidget.SetEstimatedWaitingTimer
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLobbySearchingWidget::SetEstimatedWaitingTimer(int32 seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbySearchingWidget", "SetEstimatedWaitingTimer");

	Params::UMGLobbySearchingWidget_SetEstimatedWaitingTimer Parms{};

	Parms.seconds = seconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLobbySearchingWidget.SetWaitingTimer
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLobbySearchingWidget::SetWaitingTimer(int32 seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbySearchingWidget", "SetWaitingTimer");

	Params::UMGLobbySearchingWidget_SetWaitingTimer Parms{};

	Parms.seconds = seconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGCurrencyWidget.HandleTooltipLongPressEvent
// (Final, Native, Protected)

void UUMGCurrencyWidget::HandleTooltipLongPressEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCurrencyWidget", "HandleTooltipLongPressEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBankAndPlayerInfoWidget.OnCancelPartyButtonClicked
// (Final, Native, Private)

void UUMGBankAndPlayerInfoWidget::OnCancelPartyButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBankAndPlayerInfoWidget", "OnCancelPartyButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBankAndPlayerInfoWidget.OnMainMenuSubscriptionClicked
// (Final, Native, Public)

void UUMGBankAndPlayerInfoWidget::OnMainMenuSubscriptionClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBankAndPlayerInfoWidget", "OnMainMenuSubscriptionClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBankAndPlayerInfoWidget.OnPrestigeButtonClicked
// (Final, Native, Public)

void UUMGBankAndPlayerInfoWidget::OnPrestigeButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBankAndPlayerInfoWidget", "OnPrestigeButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBankAndPlayerInfoWidget.OnPurchaseAuricCellsButtonClicked
// (Final, Native, Public)

void UUMGBankAndPlayerInfoWidget::OnPurchaseAuricCellsButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBankAndPlayerInfoWidget", "OnPurchaseAuricCellsButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBankAndPlayerInfoWidget.OnTooltipTriggeredByCurrency
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FTooltipPressedData&       tooltipPressedData                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const ECurrencyType                     currencyType                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBankAndPlayerInfoWidget::OnTooltipTriggeredByCurrency(const struct FTooltipPressedData& tooltipPressedData, const ECurrencyType currencyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBankAndPlayerInfoWidget", "OnTooltipTriggeredByCurrency");

	Params::UMGBankAndPlayerInfoWidget_OnTooltipTriggeredByCurrency Parms{};

	Parms.tooltipPressedData = std::move(tooltipPressedData);
	Parms.currencyType = currencyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBankAndPlayerInfoWidget.OnTooltipTriggeredByLevelBannerWidget
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FTooltipPressedData&       tooltipPressedData                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUMGBankAndPlayerInfoWidget::OnTooltipTriggeredByLevelBannerWidget(const struct FTooltipPressedData& tooltipPressedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBankAndPlayerInfoWidget", "OnTooltipTriggeredByLevelBannerWidget");

	Params::UMGBankAndPlayerInfoWidget_OnTooltipTriggeredByLevelBannerWidget Parms{};

	Parms.tooltipPressedData = std::move(tooltipPressedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBankAndPlayerInfoWidget.OnTooltipTriggeredByRankBanner
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FTooltipPressedData&       tooltipPressedData                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UUMGBankAndPlayerInfoWidget::OnTooltipTriggeredByRankBanner(const struct FTooltipPressedData& tooltipPressedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBankAndPlayerInfoWidget", "OnTooltipTriggeredByRankBanner");

	Params::UMGBankAndPlayerInfoWidget_OnTooltipTriggeredByRankBanner Parms{};

	Parms.tooltipPressedData = std::move(tooltipPressedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBankAndPlayerInfoWidget.SetPlayerLevelBP
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   devotion                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   currentLevelXp                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   totalLevelXp                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isSlasher                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    playUpdateAnim                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBankAndPlayerInfoWidget::SetPlayerLevelBP(int32 level, int32 devotion, int32 currentLevelXp, int32 totalLevelXp, bool isSlasher, bool playUpdateAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBankAndPlayerInfoWidget", "SetPlayerLevelBP");

	Params::UMGBankAndPlayerInfoWidget_SetPlayerLevelBP Parms{};

	Parms.level = level;
	Parms.devotion = devotion;
	Parms.currentLevelXp = currentLevelXp;
	Parms.totalLevelXp = totalLevelXp;
	Parms.isSlasher = isSlasher;
	Parms.playUpdateAnim = playUpdateAnim;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGBankWidget.OnCurrencyTooltipRequested
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FTooltipPressedData&       tooltipPressedData                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const ECurrencyType                     currencyType                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBankWidget::OnCurrencyTooltipRequested(const struct FTooltipPressedData& tooltipPressedData, const ECurrencyType currencyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBankWidget", "OnCurrencyTooltipRequested");

	Params::UMGBankWidget_OnCurrencyTooltipRequested Parms{};

	Parms.tooltipPressedData = std::move(tooltipPressedData);
	Parms.currencyType = currencyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBankWidget.OnPurchaseAuricCellsClicked
// (Final, Native, Protected)

void UUMGBankWidget::OnPurchaseAuricCellsClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBankWidget", "OnPurchaseAuricCellsClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBaseToastWidget.OnTimerFinished
// (Final, Native, Private)

void UUMGBaseToastWidget::OnTimerFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBaseToastWidget", "OnTimerFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBaseToastWidget.TriggerToastInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   inputCode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBaseToastWidget::TriggerToastInput(int32 inputCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBaseToastWidget", "TriggerToastInput");

	Params::UMGBaseToastWidget_TriggerToastInput Parms{};

	Parms.inputCode = inputCode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreArrayWidget.BroadcastBloodNodeSelected
// (Final, Native, Private)
// Parameters:
// const class FString&                    id                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBloodStoreArrayWidget::BroadcastBloodNodeSelected(const class FString& id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreArrayWidget", "BroadcastBloodNodeSelected");

	Params::UMGBloodStoreArrayWidget_BroadcastBloodNodeSelected Parms{};

	Parms.id = std::move(id);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreItemPreviewWidget.BroadcastPurchasePressed
// (Final, Native, Protected, BlueprintCallable)

void UUMGBloodStoreItemPreviewWidget::BroadcastPurchasePressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreItemPreviewWidget", "BroadcastPurchasePressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreItemPreviewWidget.BroadcastRefreshPressed
// (Final, Native, Protected, BlueprintCallable)

void UUMGBloodStoreItemPreviewWidget::BroadcastRefreshPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreItemPreviewWidget", "BroadcastRefreshPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreItemPreviewWidget.BroadcastUnselectPressed
// (Final, Native, Protected, BlueprintCallable)

void UUMGBloodStoreItemPreviewWidget::BroadcastUnselectPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreItemPreviewWidget", "BroadcastUnselectPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreItemPreviewWidget.DisplayItem
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isItemPurchaseable                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isItemAffordable                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBloodStoreItemPreviewWidget::DisplayItem(bool isItemPurchaseable, bool isItemAffordable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreItemPreviewWidget", "DisplayItem");

	Params::UMGBloodStoreItemPreviewWidget_DisplayItem Parms{};

	Parms.isItemPurchaseable = isItemPurchaseable;
	Parms.isItemAffordable = isItemAffordable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGBloodStoreItemPreviewWidget.ShowPurchaseButton
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    showPurchaseButton                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBloodStoreItemPreviewWidget::ShowPurchaseButton(bool showPurchaseButton)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreItemPreviewWidget", "ShowPurchaseButton");

	Params::UMGBloodStoreItemPreviewWidget_ShowPurchaseButton Parms{};

	Parms.showPurchaseButton = showPurchaseButton;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGBloodStoreItemPreviewWidget.ShowRefreshButton
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    showRefreshButton                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isRefreshFree                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBloodStoreItemPreviewWidget::ShowRefreshButton(bool showRefreshButton, bool isRefreshFree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreItemPreviewWidget", "ShowRefreshButton");

	Params::UMGBloodStoreItemPreviewWidget_ShowRefreshButton Parms{};

	Parms.showRefreshButton = showRefreshButton;
	Parms.isRefreshFree = isRefreshFree;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGBloodStoreItemPreviewWidget.UnselectItem
// (Event, Public, BlueprintEvent)

void UUMGBloodStoreItemPreviewWidget::UnselectItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreItemPreviewWidget", "UnselectItem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGBloodStoreItemWidget.BroadcastBloodNodeSelected
// (Final, Native, Private, BlueprintCallable)

void UUMGBloodStoreItemWidget::BroadcastBloodNodeSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreItemWidget", "BroadcastBloodNodeSelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreItemWidget.CollectNode
// (Native, Event, Public, BlueprintEvent)

void UUMGBloodStoreItemWidget::CollectNode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreItemWidget", "CollectNode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreItemWidget.ConsumeNode
// (Native, Event, Public, BlueprintEvent)

void UUMGBloodStoreItemWidget::ConsumeNode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreItemWidget", "ConsumeNode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreItemWidget.FocusNode
// (Native, Event, Public, BlueprintEvent)

void UUMGBloodStoreItemWidget::FocusNode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreItemWidget", "FocusNode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreItemWidget.PlayConsumedAnimation
// (Event, Public, BlueprintEvent)
// Parameters:
// const bool                              skipIntro                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBloodStoreItemWidget::PlayConsumedAnimation(const bool skipIntro)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreItemWidget", "PlayConsumedAnimation");

	Params::UMGBloodStoreItemWidget_PlayConsumedAnimation Parms{};

	Parms.skipIntro = skipIntro;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGBloodStoreItemWidget.SetBackgroundImages
// (Event, Protected, BlueprintEvent)

void UUMGBloodStoreItemWidget::SetBackgroundImages()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreItemWidget", "SetBackgroundImages");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGBloodStoreItemWidget.SetSelectedVisibilities
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isSelected                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBloodStoreItemWidget::SetSelectedVisibilities(bool isSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreItemWidget", "SetSelectedVisibilities");

	Params::UMGBloodStoreItemWidget_SetSelectedVisibilities Parms{};

	Parms.isSelected = isSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGBloodStoreItemWidget.UnFocusNode
// (Native, Event, Public, BlueprintEvent)

void UUMGBloodStoreItemWidget::UnFocusNode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreItemWidget", "UnFocusNode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreSubMenu.BroadcastCharacterRoleButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UUMGBloodStoreSubMenu::BroadcastCharacterRoleButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreSubMenu", "BroadcastCharacterRoleButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreSubMenu.BroadcastExpiredBloodWeb
// (Final, Native, Protected)

void UUMGBloodStoreSubMenu::BroadcastExpiredBloodWeb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreSubMenu", "BroadcastExpiredBloodWeb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGBloodStoreSubMenu.SetFaction
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isKiller                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGBloodStoreSubMenu::SetFaction(bool isKiller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGBloodStoreSubMenu", "SetFaction");

	Params::UMGBloodStoreSubMenu_SetFaction Parms{};

	Parms.isKiller = isKiller;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGCharacterFreeTicketItemButton.BroadcastClickEvent
// (Final, Native, Public, BlueprintCallable)

void UUMGCharacterFreeTicketItemButton::BroadcastClickEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterFreeTicketItemButton", "BroadcastClickEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterFreeTicketItemButton.UpdateWidget
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FString&                    bgPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isSlasher                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   durationInHours                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   itemCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSlateColor&               iconColor                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGCharacterFreeTicketItemButton::UpdateWidget(const class FString& bgPath, bool isSlasher, int32 durationInHours, int32 itemCount, const struct FSlateColor& iconColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterFreeTicketItemButton", "UpdateWidget");

	Params::UMGCharacterFreeTicketItemButton_UpdateWidget Parms{};

	Parms.bgPath = std::move(bgPath);
	Parms.isSlasher = isSlasher;
	Parms.durationInHours = durationInHours;
	Parms.itemCount = itemCount;
	Parms.iconColor = std::move(iconColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGCharacterFreeTicketWidget.HandleButtonClickEvent
// (Final, Native, Public)
// Parameters:
// const class FString&                    ticketID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    characterName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCharacterFreeTicketWidget::HandleButtonClickEvent(const class FString& ticketID, const class FString& characterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterFreeTicketWidget", "HandleButtonClickEvent");

	Params::UMGCharacterFreeTicketWidget_HandleButtonClickEvent Parms{};

	Parms.ticketID = std::move(ticketID);
	Parms.characterName = std::move(characterName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterFreeTicketWidget.UpdateBGColor
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isSlasher                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCharacterFreeTicketWidget::UpdateBGColor(bool isSlasher)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterFreeTicketWidget", "UpdateBGColor");

	Params::UMGCharacterFreeTicketWidget_UpdateBGColor Parms{};

	Parms.isSlasher = isSlasher;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGCharacterInfoWidget.HandlePowerItemTooltipLongPressedEvent
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// const struct FInventorySlotData&        slotData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector2D&                 position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCharacterInfoWidget::HandlePowerItemTooltipLongPressedEvent(const struct FInventorySlotData& slotData, const struct FVector2D& position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterInfoWidget", "HandlePowerItemTooltipLongPressedEvent");

	Params::UMGCharacterInfoWidget_HandlePowerItemTooltipLongPressedEvent Parms{};

	Parms.slotData = std::move(slotData);
	Parms.position = std::move(position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterInfoWidget.HandleTooltipLongPressedEvent
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// const struct FTeachableData&            teachableData                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector2D&                 position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCharacterInfoWidget::HandleTooltipLongPressedEvent(const struct FTeachableData& teachableData, const struct FVector2D& position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterInfoWidget", "HandleTooltipLongPressedEvent");

	Params::UMGCharacterInfoWidget_HandleTooltipLongPressedEvent Parms{};

	Parms.teachableData = std::move(teachableData);
	Parms.position = std::move(position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterPageScrollWidget.HandleCharacterClicked
// (Final, Native, Protected)
// Parameters:
// int32                                   characterIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCharacterPageScrollWidget::HandleCharacterClicked(int32 characterIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterPageScrollWidget", "HandleCharacterClicked");

	Params::UMGCharacterPageScrollWidget_HandleCharacterClicked Parms{};

	Parms.characterIndex = characterIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterScrollingInfoWidget.HandleTooltipLongPressedEvent
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// const struct FTeachableData&            teachableData                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector2D&                 position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCharacterScrollingInfoWidget::HandleTooltipLongPressedEvent(const struct FTeachableData& teachableData, const struct FVector2D& position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterScrollingInfoWidget", "HandleTooltipLongPressedEvent");

	Params::UMGCharacterScrollingInfoWidget_HandleTooltipLongPressedEvent Parms{};

	Parms.teachableData = std::move(teachableData);
	Parms.position = std::move(position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterScrollingInfoWidget.HandleTooltipLongPressedKillerPowerEvent
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// const struct FInventorySlotData&        itemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector2D&                 position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCharacterScrollingInfoWidget::HandleTooltipLongPressedKillerPowerEvent(const struct FInventorySlotData& itemData, const struct FVector2D& position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterScrollingInfoWidget", "HandleTooltipLongPressedKillerPowerEvent");

	Params::UMGCharacterScrollingInfoWidget_HandleTooltipLongPressedKillerPowerEvent Parms{};

	Parms.itemData = std::move(itemData);
	Parms.position = std::move(position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterSelectSubmenu.BroadcastInfoButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UUMGCharacterSelectSubmenu::BroadcastInfoButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterSelectSubmenu", "BroadcastInfoButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterSelectSubmenu.BroadcastRoleButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UUMGCharacterSelectSubmenu::BroadcastRoleButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterSelectSubmenu", "BroadcastRoleButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterSelectSubmenu.SetCurrentRole
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isKiller                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCharacterSelectSubmenu::SetCurrentRole(bool isKiller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterSelectSubmenu", "SetCurrentRole");

	Params::UMGCharacterSelectSubmenu_SetCurrentRole Parms{};

	Parms.isKiller = isKiller;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGCharacterSelectSubmenu.SetInInfoPanelMode
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isInInfoPanel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCharacterSelectSubmenu::SetInInfoPanelMode(bool isInInfoPanel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterSelectSubmenu", "SetInInfoPanelMode");

	Params::UMGCharacterSelectSubmenu_SetInInfoPanelMode Parms{};

	Parms.isInInfoPanel = isInInfoPanel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGCharacterSlideShowWidget.DisplayCharacterSlide
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FCharacterSlideData&       characterSlide                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGCharacterSlideShowWidget::DisplayCharacterSlide(const struct FCharacterSlideData& characterSlide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterSlideShowWidget", "DisplayCharacterSlide");

	Params::UMGCharacterSlideShowWidget_DisplayCharacterSlide Parms{};

	Parms.characterSlide = std::move(characterSlide);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGCharacterSlideShowWidget.FadeIn
// (Final, Native, Private)

void UUMGCharacterSlideShowWidget::FadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterSlideShowWidget", "FadeIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterSlideShowWidget.FadeOut
// (Final, Native, Private)

void UUMGCharacterSlideShowWidget::FadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterSlideShowWidget", "FadeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterSlideShowWidget.SwitchCharacterSlide
// (Final, Native, Private)

void UUMGCharacterSlideShowWidget::SwitchCharacterSlide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterSlideShowWidget", "SwitchCharacterSlide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCharacterSlideShowWidget.WaitAndFadeOut
// (Final, Native, Private)

void UUMGCharacterSlideShowWidget::WaitAndFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCharacterSlideShowWidget", "WaitAndFadeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCommandDebugButton.TriggerCommand
// (Final, Native, Private)

void UUMGCommandDebugButton::TriggerCommand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCommandDebugButton", "TriggerCommand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGControlTypeSelectionWidget.UpdateControlType
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EAtlantaControlTypeSetting              controlType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGControlTypeSelectionWidget::UpdateControlType(EAtlantaControlTypeSetting controlType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGControlTypeSelectionWidget", "UpdateControlType");

	Params::UMGControlTypeSelectionWidget_UpdateControlType Parms{};

	Parms.controlType = controlType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGCustomizationCategoriesBar.BroadcastCustomizationCategoryButtonPressed
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// ECustomizationCategory                  categoryIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCustomizationCategoriesBar::BroadcastCustomizationCategoryButtonPressed(ECustomizationCategory categoryIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCustomizationCategoriesBar", "BroadcastCustomizationCategoryButtonPressed");

	Params::UMGCustomizationCategoriesBar_BroadcastCustomizationCategoryButtonPressed Parms{};

	Parms.categoryIndex = categoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCustomizationCategoriesBar.SetRole
// (Event, Public, BlueprintEvent)
// Parameters:
// const bool                              isKiller                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCustomizationCategoriesBar::SetRole(const bool isKiller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCustomizationCategoriesBar", "SetRole");

	Params::UMGCustomizationCategoriesBar_SetRole Parms{};

	Parms.isKiller = isKiller;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGCustomizationCategoriesBar.SetSelectedCategory
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const ECustomizationCategory            category                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCustomizationCategoriesBar::SetSelectedCategory(const ECustomizationCategory category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCustomizationCategoriesBar", "SetSelectedCategory");

	Params::UMGCustomizationCategoriesBar_SetSelectedCategory Parms{};

	Parms.category = category;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGCustomizationItemWidget.BroadcastAvailableItemSelected
// (Final, Native, Protected, BlueprintCallable)

void UUMGCustomizationItemWidget::BroadcastAvailableItemSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCustomizationItemWidget", "BroadcastAvailableItemSelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCustomizationPageScrollWidget.OnAvailableItemSelectedCallback
// (Final, Native, Private)
// Parameters:
// int32                                   itemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCustomizationPageScrollWidget::OnAvailableItemSelectedCallback(int32 itemIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCustomizationPageScrollWidget", "OnAvailableItemSelectedCallback");

	Params::UMGCustomizationPageScrollWidget_OnAvailableItemSelectedCallback Parms{};

	Parms.itemIndex = itemIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCustomizationScreenWidget.BroadcastAvailableItemSelectedEvent
// (Final, Native, Private, HasOutParams)
// Parameters:
// int32                                   itemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FStoreItemSlotData&        selectedItem                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FStoreItemSlotData&        parentItem                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGCustomizationScreenWidget::BroadcastAvailableItemSelectedEvent(int32 itemIndex, const struct FStoreItemSlotData& selectedItem, const struct FStoreItemSlotData& parentItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCustomizationScreenWidget", "BroadcastAvailableItemSelectedEvent");

	Params::UMGCustomizationScreenWidget_BroadcastAvailableItemSelectedEvent Parms{};

	Parms.itemIndex = itemIndex;
	Parms.selectedItem = std::move(selectedItem);
	Parms.parentItem = std::move(parentItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCustomizationScreenWidget.BroadcastCustomizationCategoryButtonPressed
// (Final, Native, Private)
// Parameters:
// int32                                   categoryIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCustomizationScreenWidget::BroadcastCustomizationCategoryButtonPressed(int32 categoryIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCustomizationScreenWidget", "BroadcastCustomizationCategoryButtonPressed");

	Params::UMGCustomizationScreenWidget_BroadcastCustomizationCategoryButtonPressed Parms{};

	Parms.categoryIndex = categoryIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCustomizationScreenWidget.BroadcastUnlockWithCurrencyEvent
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// int32                                   currencyId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    combinedItem                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCustomizationScreenWidget::BroadcastUnlockWithCurrencyEvent(int32 currencyId, const class FString& combinedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCustomizationScreenWidget", "BroadcastUnlockWithCurrencyEvent");

	Params::UMGCustomizationScreenWidget_BroadcastUnlockWithCurrencyEvent Parms{};

	Parms.currencyId = currencyId;
	Parms.combinedItem = std::move(combinedItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGCustomizationScreenWidget.SetCategoryLabel
// (Event, Protected, BlueprintEvent)
// Parameters:
// const ECustomizationCategory            category                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGCustomizationScreenWidget::SetCategoryLabel(const ECustomizationCategory category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCustomizationScreenWidget", "SetCategoryLabel");

	Params::UMGCustomizationScreenWidget_SetCategoryLabel Parms{};

	Parms.category = category;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGCustomizationTooltipHeaderWidget.SetOutfitComposition
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const bool                              isUnbreakable                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<ECustomizationCategory>&   composition                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGCustomizationTooltipHeaderWidget::SetOutfitComposition(const bool isUnbreakable, const TArray<ECustomizationCategory>& composition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGCustomizationTooltipHeaderWidget", "SetOutfitComposition");

	Params::UMGCustomizationTooltipHeaderWidget_SetOutfitComposition Parms{};

	Parms.isUnbreakable = isUnbreakable;
	Parms.composition = std::move(composition);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGDailyRewardWidget.CollectReward
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UUMGDailyRewardWidget::CollectReward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDailyRewardWidget", "CollectReward");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGDailyRewardWidget.DiscoverMysteryReward
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UUMGDailyRewardWidget::DiscoverMysteryReward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDailyRewardWidget", "DiscoverMysteryReward");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGDailyRewardWidget.HandleCollectButtonClick
// (Final, Native, Protected, BlueprintCallable)

void UUMGDailyRewardWidget::HandleCollectButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDailyRewardWidget", "HandleCollectButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGDailyRewardWidget.HandleCollectRewardAnimationFinished
// (Final, Native, Protected, BlueprintCallable)

void UUMGDailyRewardWidget::HandleCollectRewardAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDailyRewardWidget", "HandleCollectRewardAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGDailyRewardWidget.HandleDiscoverRewardAnimationFinished
// (Final, Native, Protected, BlueprintCallable)

void UUMGDailyRewardWidget::HandleDiscoverRewardAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDailyRewardWidget", "HandleDiscoverRewardAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGDailyRewardWidget.HandleUnlockMysteryRewardAnimationFinished
// (Final, Native, Protected, BlueprintCallable)

void UUMGDailyRewardWidget::HandleUnlockMysteryRewardAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDailyRewardWidget", "HandleUnlockMysteryRewardAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGDailyRewardWidget.HandleUnlockRewardAnimationFinished
// (Final, Native, Protected, BlueprintCallable)

void UUMGDailyRewardWidget::HandleUnlockRewardAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDailyRewardWidget", "HandleUnlockRewardAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGDailyRewardWidget.PlayIdleAnimationForState
// (Event, Protected, BlueprintEvent)
// Parameters:
// const EUMGDailyRewardWidgetState        inState                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGDailyRewardWidget::PlayIdleAnimationForState(const EUMGDailyRewardWidgetState inState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDailyRewardWidget", "PlayIdleAnimationForState");

	Params::UMGDailyRewardWidget_PlayIdleAnimationForState Parms{};

	Parms.inState = inState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGDailyRewardWidget.SetRarityColors
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FColor&                    backgroundColor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FColor&                    tintColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGDailyRewardWidget::SetRarityColors(const struct FColor& backgroundColor, const struct FColor& tintColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDailyRewardWidget", "SetRarityColors");

	Params::UMGDailyRewardWidget_SetRarityColors Parms{};

	Parms.backgroundColor = std::move(backgroundColor);
	Parms.tintColor = std::move(tintColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGDailyRewardWidget.SetStateVisuals
// (Event, Protected, BlueprintEvent)
// Parameters:
// const EUMGDailyRewardWidgetState        inState                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGDailyRewardWidget::SetStateVisuals(const EUMGDailyRewardWidgetState inState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDailyRewardWidget", "SetStateVisuals");

	Params::UMGDailyRewardWidget_SetStateVisuals Parms{};

	Parms.inState = inState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGDailyRewardWidget.StopIdleAnimationForState
// (Event, Protected, BlueprintEvent)
// Parameters:
// const EUMGDailyRewardWidgetState        inState                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGDailyRewardWidget::StopIdleAnimationForState(const EUMGDailyRewardWidgetState inState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGDailyRewardWidget", "StopIdleAnimationForState");

	Params::UMGDailyRewardWidget_StopIdleAnimationForState Parms{};

	Parms.inState = inState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGEndGameCollapseWidget.PlayToZeroAnimation
// (Event, Protected, BlueprintEvent)

void UUMGEndGameCollapseWidget::PlayToZeroAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGEndGameCollapseWidget", "PlayToZeroAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGGameplayAlertWidget.UpdateWidget
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FStatusEffectSlotData&     statusEffectData                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FInventorySlotData&        originatorData                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGGameplayAlertWidget::UpdateWidget(const struct FStatusEffectSlotData& statusEffectData, const struct FInventorySlotData& originatorData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGGameplayAlertWidget", "UpdateWidget");

	Params::UMGGameplayAlertWidget_UpdateWidget Parms{};

	Parms.statusEffectData = std::move(statusEffectData);
	Parms.originatorData = std::move(originatorData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGHtmlRichText.SetHtmlText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InText                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHtmlRichText::SetHtmlText(const class FString& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHtmlRichText", "SetHtmlText");

	Params::UMGHtmlRichText_SetHtmlText Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.FlagSaveAsDirty
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorLayoutWidget::FlagSaveAsDirty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "FlagSaveAsDirty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.FlipLayout
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorLayoutWidget::FlipLayout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "FlipLayout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.OnSaveDirty
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    isDirty                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHudEditorLayoutWidget::OnSaveDirty(bool isDirty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "OnSaveDirty");

	Params::UMGHudEditorLayoutWidget_OnSaveDirty Parms{};

	Parms.isDirty = isDirty;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.ResetLayout
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorLayoutWidget::ResetLayout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "ResetLayout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.SaveLayout
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorLayoutWidget::SaveLayout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "SaveLayout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.SetHudEditorScreen
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUMGHudEditorScreen*              hudEditorScreen                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHudEditorLayoutWidget::SetHudEditorScreen(class UUMGHudEditorScreen* hudEditorScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "SetHudEditorScreen");

	Params::UMGHudEditorLayoutWidget_SetHudEditorScreen Parms{};

	Parms.hudEditorScreen = hudEditorScreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.SetSaveOverlapSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAkAudioEvent*                    onSaveOverlapSound                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHudEditorLayoutWidget::SetSaveOverlapSound(class UAkAudioEvent* onSaveOverlapSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "SetSaveOverlapSound");

	Params::UMGHudEditorLayoutWidget_SetSaveOverlapSound Parms{};

	Parms.onSaveOverlapSound = onSaveOverlapSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.SetWidgetToEdit
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUMGDragWidget_HudEditor*         widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGHudEditorLayoutWidget::SetWidgetToEdit(class UUMGDragWidget_HudEditor* widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "SetWidgetToEdit");

	Params::UMGHudEditorLayoutWidget_SetWidgetToEdit Parms{};

	Parms.widget = widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.ShowKillerLayout
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorLayoutWidget::ShowKillerLayout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "ShowKillerLayout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.ShowSurvivorLayout
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorLayoutWidget::ShowSurvivorLayout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "ShowSurvivorLayout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.GetCurrentDragWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUMGDragWidget_HudEditor*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUMGDragWidget_HudEditor* UUMGHudEditorLayoutWidget::GetCurrentDragWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "GetCurrentDragWidget");

	Params::UMGHudEditorLayoutWidget_GetCurrentDragWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGHudEditorLayoutWidget.GetHudEditorWrapperToEdit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCustomWidgetWrapper_HudEditor*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCustomWidgetWrapper_HudEditor* UUMGHudEditorLayoutWidget::GetHudEditorWrapperToEdit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorLayoutWidget", "GetHudEditorWrapperToEdit");

	Params::UMGHudEditorLayoutWidget_GetHudEditorWrapperToEdit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGHudEditorVersionWidget.Hide
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorVersionWidget::Hide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorVersionWidget", "Hide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorVersionWidget.OnButtonClick
// (Final, Native, Protected, BlueprintCallable)

void UUMGHudEditorVersionWidget::OnButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorVersionWidget", "OnButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGHudEditorVersionWidget.Show
// (Final, Native, Public, BlueprintCallable)

void UUMGHudEditorVersionWidget::Show()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGHudEditorVersionWidget", "Show");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGInboxMessageEntryWidget.GetElapsedTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInboxMessageElapsedTime         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FInboxMessageElapsedTime UUMGInboxMessageEntryWidget::GetElapsedTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxMessageEntryWidget", "GetElapsedTime");

	Params::UMGInboxMessageEntryWidget_GetElapsedTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGInboxMessageEntryWidget.SetMessageData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FInboxMessageUIData&       messageData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGInboxMessageEntryWidget::SetMessageData(const struct FInboxMessageUIData& messageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxMessageEntryWidget", "SetMessageData");

	Params::UMGInboxMessageEntryWidget_SetMessageData Parms{};

	Parms.messageData = std::move(messageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGInboxMessageEntryWidget.UpdateMessageData
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// const struct FInboxMessageUIData&       messageData                                            (Parm, NativeAccessSpecifierPublic)

void UUMGInboxMessageEntryWidget::UpdateMessageData(const struct FInboxMessageUIData& messageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGInboxMessageEntryWidget", "UpdateMessageData");

	Params::UMGInboxMessageEntryWidget_UpdateMessageData Parms{};

	Parms.messageData = std::move(messageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgKillerHud.HandleOnAttackButtonPressed
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UUmgKillerHud::HandleOnAttackButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "HandleOnAttackButtonPressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UmgKillerHud.HandleOnAttackButtonReleased
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UUmgKillerHud::HandleOnAttackButtonReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "HandleOnAttackButtonReleased");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UmgKillerHud.InitializePowerAttackJoystickPosition
// (Event, Protected, BlueprintEvent)

void UUmgKillerHud::InitializePowerAttackJoystickPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "InitializePowerAttackJoystickPosition");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UmgKillerHud.OnActionButtonPressed
// (Final, Native, Protected, BlueprintCallable)

void UUmgKillerHud::OnActionButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "OnActionButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgKillerHud.OnActionButtonReleased
// (Final, Native, Protected, BlueprintCallable)

void UUmgKillerHud::OnActionButtonReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "OnActionButtonReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgKillerHud.OnAttackButtonPressed
// (Final, Native, Protected, BlueprintCallable)

void UUmgKillerHud::OnAttackButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "OnAttackButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgKillerHud.OnAttackButtonReleased
// (Final, Native, Protected, BlueprintCallable)

void UUmgKillerHud::OnAttackButtonReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "OnAttackButtonReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgKillerHud.OnCancelButtonPressed
// (Final, Native, Protected, BlueprintCallable)

void UUmgKillerHud::OnCancelButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "OnCancelButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgKillerHud.OnCancelButtonReleased
// (Final, Native, Protected, BlueprintCallable)

void UUmgKillerHud::OnCancelButtonReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "OnCancelButtonReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgKillerHud.OnPowerButtonPressed
// (Final, Native, Protected, BlueprintCallable)

void UUmgKillerHud::OnPowerButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "OnPowerButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgKillerHud.OnPowerButtonReleased
// (Final, Native, Protected, BlueprintCallable)

void UUmgKillerHud::OnPowerButtonReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "OnPowerButtonReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgKillerHud.OnSecondAbilityButtonLongPressed
// (Final, Native, Protected, BlueprintCallable)

void UUmgKillerHud::OnSecondAbilityButtonLongPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "OnSecondAbilityButtonLongPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgKillerHud.OnSecondAbilityButtonPressed
// (Final, Native, Protected, BlueprintCallable)

void UUmgKillerHud::OnSecondAbilityButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "OnSecondAbilityButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgKillerHud.RespondToVirtualJoystickPressChanged
// (Final, Native, Public)
// Parameters:
// int32                                   controlIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgKillerHud::RespondToVirtualJoystickPressChanged(int32 controlIndex, bool pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "RespondToVirtualJoystickPressChanged");

	Params::UmgKillerHud_RespondToVirtualJoystickPressChanged Parms{};

	Parms.controlIndex = controlIndex;
	Parms.pressed = pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgKillerHud.SetPowerAttackJoystickPosition
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D&                       position                                               (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgKillerHud::SetPowerAttackJoystickPosition(struct FVector2D& position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "SetPowerAttackJoystickPosition");

	Params::UmgKillerHud_SetPowerAttackJoystickPosition Parms{};

	Parms.position = std::move(position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	position = std::move(Parms.position);
}


// Function DeadByDaylight.UmgKillerHud.SetPowerAttackJoystickThumbImage
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgKillerHud::SetPowerAttackJoystickThumbImage(bool pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "SetPowerAttackJoystickThumbImage");

	Params::UmgKillerHud_SetPowerAttackJoystickThumbImage Parms{};

	Parms.pressed = pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgKillerHud.SetPowerIconFromItem
// (Final, Native, Protected)
// Parameters:
// class ACollectable*                     item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventoryType                          inventoryType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgKillerHud::SetPowerIconFromItem(class ACollectable* item, EInventoryType inventoryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "SetPowerIconFromItem");

	Params::UmgKillerHud_SetPowerIconFromItem Parms{};

	Parms.item = item;
	Parms.inventoryType = inventoryType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgKillerHud.UpdatePowerButtonTier
// (Final, Native, Private)
// Parameters:
// int32                                   previousTier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   currentTier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isFirstTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgKillerHud::UpdatePowerButtonTier(int32 previousTier, int32 currentTier, bool isFirstTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "UpdatePowerButtonTier");

	Params::UmgKillerHud_UpdatePowerButtonTier Parms{};

	Parms.previousTier = previousTier;
	Parms.currentTier = currentTier;
	Parms.isFirstTime = isFirstTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UmgKillerHud.GetCurrentPowerUseInteraction
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionDefinition*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionDefinition* UUmgKillerHud::GetCurrentPowerUseInteraction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "GetCurrentPowerUseInteraction");

	Params::UmgKillerHud_GetCurrentPowerUseInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UmgKillerHud.IsAttackButtonVisible
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUmgKillerHud::IsAttackButtonVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "IsAttackButtonVisible");

	Params::UmgKillerHud_IsAttackButtonVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UmgKillerHud.IsCancelPowerButtonAvailable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUmgKillerHud::IsCancelPowerButtonAvailable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "IsCancelPowerButtonAvailable");

	Params::UmgKillerHud_IsCancelPowerButtonAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UmgKillerHud.IsPowerButtonAvailable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUmgKillerHud::IsPowerButtonAvailable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "IsPowerButtonAvailable");

	Params::UmgKillerHud_IsPowerButtonAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UmgKillerHud.ShouldShowInteractionHighlight
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInputInteractionType                   interactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UUmgKillerHud::ShouldShowInteractionHighlight(EInputInteractionType interactionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgKillerHud", "ShouldShowInteractionHighlight");

	Params::UmgKillerHud_ShouldShowInteractionHighlight Parms{};

	Parms.interactionType = interactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGLacerationStatusEffectUI.OnFinishedBoomAnimation
// (Final, Native, Private)

void UUMGLacerationStatusEffectUI::OnFinishedBoomAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLacerationStatusEffectUI", "OnFinishedBoomAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLevelBannerWidget.OnTooltipButtonLongPressEvent
// (Final, Native, Protected)

void UUMGLevelBannerWidget::OnTooltipButtonLongPressEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLevelBannerWidget", "OnTooltipButtonLongPressEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLevelBannerWidget.SetExperienceVisibilityBP
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// const bool                              isExperienceVisible                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              isBig                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLevelBannerWidget::SetExperienceVisibilityBP(const bool isExperienceVisible, const bool isBig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLevelBannerWidget", "SetExperienceVisibilityBP");

	Params::UMGLevelBannerWidget_SetExperienceVisibilityBP Parms{};

	Parms.isExperienceVisible = isExperienceVisible;
	Parms.isBig = isBig;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLevelBannerWidget.SetInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const int32                             playerLevel                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             playerPrestige                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             currentExperience                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             nextLevelExperience                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLevelBannerWidget::SetInfo(const int32 playerLevel, const int32 playerPrestige, const int32 currentExperience, const int32 nextLevelExperience)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLevelBannerWidget", "SetInfo");

	Params::UMGLevelBannerWidget_SetInfo Parms{};

	Parms.playerLevel = playerLevel;
	Parms.playerPrestige = playerPrestige;
	Parms.currentExperience = currentExperience;
	Parms.nextLevelExperience = nextLevelExperience;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLevelBannerWidget.SetInfoBP
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// const int32                             playerLevel                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             playerPrestige                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             currentExperience                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             nextLevelExperience                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLevelBannerWidget::SetInfoBP(const int32 playerLevel, const int32 playerPrestige, const int32 currentExperience, const int32 nextLevelExperience)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLevelBannerWidget", "SetInfoBP");

	Params::UMGLevelBannerWidget_SetInfoBP Parms{};

	Parms.playerLevel = playerLevel;
	Parms.playerPrestige = playerPrestige;
	Parms.currentExperience = currentExperience;
	Parms.nextLevelExperience = nextLevelExperience;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLevelBannerWidget.SetProgressBarValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             progress                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLevelBannerWidget::SetProgressBarValue(const float progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLevelBannerWidget", "SetProgressBarValue");

	Params::UMGLevelBannerWidget_SetProgressBarValue Parms{};

	Parms.progress = progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLevelBannerWidget.StartHighlight
// (Native, Public, BlueprintCallable)

void UUMGLevelBannerWidget::StartHighlight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLevelBannerWidget", "StartHighlight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLevelBannerWidget.StopHighlight
// (Native, Public, BlueprintCallable)

void UUMGLevelBannerWidget::StopHighlight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLevelBannerWidget", "StopHighlight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutPageScrollWidget.HandleItemClicked
// (Final, Native, Protected)
// Parameters:
// class FName                             itemID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutPageScrollWidget::HandleItemClicked(class FName itemID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutPageScrollWidget", "HandleItemClicked");

	Params::UMGLoadoutPageScrollWidget_HandleItemClicked Parms{};

	Parms.itemID = itemID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutPageScrollWidget.SetInventoryData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EInventoryGridFormat                    gridFormat                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FInventorySlotData>&inventoryData                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<int32>&                    selectedItemsIndexes                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    trackingItemName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    subtitle                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutPageScrollWidget::SetInventoryData(EInventoryGridFormat gridFormat, const TArray<struct FInventorySlotData>& inventoryData, const TArray<int32>& selectedItemsIndexes, const class FString& trackingItemName, const class FString& subtitle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutPageScrollWidget", "SetInventoryData");

	Params::UMGLoadoutPageScrollWidget_SetInventoryData Parms{};

	Parms.gridFormat = gridFormat;
	Parms.inventoryData = std::move(inventoryData);
	Parms.selectedItemsIndexes = std::move(selectedItemsIndexes);
	Parms.trackingItemName = std::move(trackingItemName);
	Parms.subtitle = std::move(subtitle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLoadoutPageScrollWidget.SetItemIsSelected
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   index                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isSelected                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutPageScrollWidget::SetItemIsSelected(int32 index, bool isSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutPageScrollWidget", "SetItemIsSelected");

	Params::UMGLoadoutPageScrollWidget_SetItemIsSelected Parms{};

	Parms.index = index;
	Parms.isSelected = isSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLoadoutPageScrollWidget.SetItemWidgetClass
// (Event, Protected, BlueprintEvent)

void UUMGLoadoutPageScrollWidget::SetItemWidgetClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutPageScrollWidget", "SetItemWidgetClass");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGLoadoutWidget.SetInventoryData
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// EInventoryGridFormat                    gridFormat                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FInventorySlotData>&inventoryData                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<int32>&                    selectedItemsIndexes                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    trackingItemName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    subtitle                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGLoadoutWidget::SetInventoryData(EInventoryGridFormat gridFormat, const TArray<struct FInventorySlotData>& inventoryData, const TArray<int32>& selectedItemsIndexes, const class FString& trackingItemName, const class FString& subtitle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLoadoutWidget", "SetInventoryData");

	Params::UMGLoadoutWidget_SetInventoryData Parms{};

	Parms.gridFormat = gridFormat;
	Parms.inventoryData = std::move(inventoryData);
	Parms.selectedItemsIndexes = std::move(selectedItemsIndexes);
	Parms.trackingItemName = std::move(trackingItemName);
	Parms.subtitle = std::move(subtitle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGLobbyOfferingItemWidget.GetOfferingIcons
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TMap<class FName, TSoftObjectPtr<class UTexture2D>>ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TMap<class FName, TSoftObjectPtr<class UTexture2D>> UUMGLobbyOfferingItemWidget::GetOfferingIcons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbyOfferingItemWidget", "GetOfferingIcons");

	Params::UMGLobbyOfferingItemWidget_GetOfferingIcons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGLobbyOfferingItemWidget.HideOfferingItem
// (Final, Native, Public)

void UUMGLobbyOfferingItemWidget::HideOfferingItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbyOfferingItemWidget", "HideOfferingItem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGLobbyOfferingItemWidget.SetOfferingData
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FInventorySlotData&        data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGLobbyOfferingItemWidget::SetOfferingData(const struct FInventorySlotData& data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGLobbyOfferingItemWidget", "SetOfferingData");

	Params::UMGLobbyOfferingItemWidget_SetOfferingData Parms{};

	Parms.data = std::move(data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGMainMenuMonthlyPassButton.OnButtonClick
// (Final, Native, Protected, BlueprintCallable)

void UUMGMainMenuMonthlyPassButton::OnButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGMainMenuMonthlyPassButton", "OnButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGMapThemeWidget.SetMapName
// (Event, Public, BlueprintEvent)
// Parameters:
// const class FString&                    mapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGMapThemeWidget::SetMapName(const class FString& mapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGMapThemeWidget", "SetMapName");

	Params::UMGMapThemeWidget_SetMapName Parms{};

	Parms.mapName = std::move(mapName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGMapThemeWidget.SetThemeName
// (Event, Public, BlueprintEvent)
// Parameters:
// const class FString&                    themeName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGMapThemeWidget::SetThemeName(const class FString& themeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGMapThemeWidget", "SetThemeName");

	Params::UMGMapThemeWidget_SetThemeName Parms{};

	Parms.themeName = std::move(themeName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGMenuEventsBanner.SetCustomWidgetLayout
// (Event, Protected, BlueprintEvent)

void UUMGMenuEventsBanner::SetCustomWidgetLayout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGMenuEventsBanner", "SetCustomWidgetLayout");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGMenuEventsBanner.SetDefaultWidgetLayout
// (Event, Protected, BlueprintEvent)

void UUMGMenuEventsBanner::SetDefaultWidgetLayout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGMenuEventsBanner", "SetDefaultWidgetLayout");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGNavigationButtonWidget.SetIcon
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTexture2D*                       Icon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGNavigationButtonWidget::SetIcon(class UTexture2D* Icon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGNavigationButtonWidget", "SetIcon");

	Params::UMGNavigationButtonWidget_SetIcon Parms{};

	Parms.Icon = Icon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGNavigationButtonWidget.SetIsSelected
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    isSelected                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGNavigationButtonWidget::SetIsSelected(bool isSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGNavigationButtonWidget", "SetIsSelected");

	Params::UMGNavigationButtonWidget_SetIsSelected Parms{};

	Parms.isSelected = isSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGPartyCountdownWidget.OnUnreadyButtonClicked
// (Final, Native, Private)

void UUMGPartyCountdownWidget::OnUnreadyButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPartyCountdownWidget", "OnUnreadyButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGPartyPlayerSlotWidget.HandleKickPlayerButtonEvent
// (Final, Native, Private)

void UUMGPartyPlayerSlotWidget::HandleKickPlayerButtonEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPartyPlayerSlotWidget", "HandleKickPlayerButtonEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGPartyPlayerSlotWidget.SetVisualsFromState
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPartyPlayerSlotWidgetState             widgetState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGPartyPlayerSlotWidget::SetVisualsFromState(EPartyPlayerSlotWidgetState widgetState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGPartyPlayerSlotWidget", "SetVisualsFromState");

	Params::UMGPartyPlayerSlotWidget_SetVisualsFromState Parms{};

	Parms.widgetState = widgetState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGRefundDataWidget.SetDataAndUpdateWidget
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FRefundUIData&             RefundUIData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGRefundDataWidget::SetDataAndUpdateWidget(const struct FRefundUIData& RefundUIData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGRefundDataWidget", "SetDataAndUpdateWidget");

	Params::UMGRefundDataWidget_SetDataAndUpdateWidget Parms{};

	Parms.RefundUIData = std::move(RefundUIData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGRewardWidget.SetData
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FRewardItemData&           RewardData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGRewardWidget::SetData(const struct FRewardItemData& RewardData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGRewardWidget", "SetData");

	Params::UMGRewardWidget_SetData Parms{};

	Parms.RewardData = std::move(RewardData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGScoreAlertWidget.UpdateWidget
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// EDBDScoreCategory                       scoreType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    title                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   scoreValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      defaultScoreText                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGScoreAlertWidget::UpdateWidget(EDBDScoreCategory scoreType, const class FString& title, int32 scoreValue, float progress, const class FText& defaultScoreText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGScoreAlertWidget", "UpdateWidget");

	Params::UMGScoreAlertWidget_UpdateWidget Parms{};

	Parms.scoreType = scoreType;
	Parms.title = std::move(title);
	Parms.scoreValue = scoreValue;
	Parms.progress = progress;
	Parms.defaultScoreText = std::move(defaultScoreText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGSettingAboutContextWidget.SetVersionNumber
// (Event, Public, BlueprintEvent)
// Parameters:
// const class FString&                    versionNumber                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingAboutContextWidget::SetVersionNumber(const class FString& versionNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingAboutContextWidget", "SetVersionNumber");

	Params::UMGSettingAboutContextWidget_SetVersionNumber Parms{};

	Parms.versionNumber = std::move(versionNumber);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGSettingMenuButton.HandleSettingTabButtonClick
// (Final, Native, Protected, BlueprintCallable)

void UUMGSettingMenuButton::HandleSettingTabButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingMenuButton", "HandleSettingTabButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingMenuButton.SetIsSelected
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isSelected                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingMenuButton::SetIsSelected(bool isSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingMenuButton", "SetIsSelected");

	Params::UMGSettingMenuButton_SetIsSelected Parms{};

	Parms.isSelected = isSelected;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGSettingMenuButton.SetTabButtonText
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      buttonText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGSettingMenuButton::SetTabButtonText(const class FText& buttonText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingMenuButton", "SetTabButtonText");

	Params::UMGSettingMenuButton_SetTabButtonText Parms{};

	Parms.buttonText = std::move(buttonText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGSettingSettingsContextWidget.HandleAutoDeclineFriendRequestToggleClick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    toggleValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingSettingsContextWidget::HandleAutoDeclineFriendRequestToggleClick(bool toggleValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingSettingsContextWidget", "HandleAutoDeclineFriendRequestToggleClick");

	Params::UMGSettingSettingsContextWidget_HandleAutoDeclineFriendRequestToggleClick Parms{};

	Parms.toggleValue = toggleValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingSettingsContextWidget.HandleLeaveTutorialButtonClick
// (Final, Native, Public, BlueprintCallable)

void UUMGSettingSettingsContextWidget::HandleLeaveTutorialButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingSettingsContextWidget", "HandleLeaveTutorialButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingSettingsContextWidget.HandleLogInButtonClick
// (Final, Native, Public, BlueprintCallable)

void UUMGSettingSettingsContextWidget::HandleLogInButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingSettingsContextWidget", "HandleLogInButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingSettingsContextWidget.HandleLogOutButtonClick
// (Final, Native, Public, BlueprintCallable)

void UUMGSettingSettingsContextWidget::HandleLogOutButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingSettingsContextWidget", "HandleLogOutButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingSettingsContextWidget.HandleMainVolumeChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   sliderValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingSettingsContextWidget::HandleMainVolumeChanged(float sliderValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingSettingsContextWidget", "HandleMainVolumeChanged");

	Params::UMGSettingSettingsContextWidget_HandleMainVolumeChanged Parms{};

	Parms.sliderValue = sliderValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingSettingsContextWidget.HandleMainVolumeToggleClick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    toggleValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingSettingsContextWidget::HandleMainVolumeToggleClick(bool toggleValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingSettingsContextWidget", "HandleMainVolumeToggleClick");

	Params::UMGSettingSettingsContextWidget_HandleMainVolumeToggleClick Parms{};

	Parms.toggleValue = toggleValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingSettingsContextWidget.HandleMenuVolumeChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   sliderValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingSettingsContextWidget::HandleMenuVolumeChanged(float sliderValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingSettingsContextWidget", "HandleMenuVolumeChanged");

	Params::UMGSettingSettingsContextWidget_HandleMenuVolumeChanged Parms{};

	Parms.sliderValue = sliderValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingSettingsContextWidget.HandleMenuVolumeToggleClick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    toggleValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingSettingsContextWidget::HandleMenuVolumeToggleClick(bool toggleValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingSettingsContextWidget", "HandleMenuVolumeToggleClick");

	Params::UMGSettingSettingsContextWidget_HandleMenuVolumeToggleClick Parms{};

	Parms.toggleValue = toggleValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingSettingsContextWidget.HandleUserCenterButtonClick
// (Final, Native, Public, BlueprintCallable)

void UUMGSettingSettingsContextWidget::HandleUserCenterButtonClick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingSettingsContextWidget", "HandleUserCenterButtonClick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSettingSettingsContextWidget.ShowLinkAccountRow
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSettingSettingsContextWidget::ShowLinkAccountRow(bool isShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSettingSettingsContextWidget", "ShowLinkAccountRow");

	Params::UMGSettingSettingsContextWidget_ShowLinkAccountRow Parms{};

	Parms.isShow = isShow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGStatusEffectIcon.UpdatePercentageFill
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGStatusEffectIcon::UpdatePercentageFill(float percentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGStatusEffectIcon", "UpdatePercentageFill");

	Params::UMGStatusEffectIcon_UpdatePercentageFill Parms{};

	Parms.percentage = percentage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGStatusEffectIcon.UpdateWidget
// (Event, Public, BlueprintEvent)

void UUMGStatusEffectIcon::UpdateWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGStatusEffectIcon", "UpdateWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGStoreEventItemsPackButton.HandleButtonClicked
// (Final, Native, Private)

void UUMGStoreEventItemsPackButton::HandleButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGStoreEventItemsPackButton", "HandleButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGStoreEventItemsPackButton.HandleEndDateTimerReached
// (Final, Native, Private)

void UUMGStoreEventItemsPackButton::HandleEndDateTimerReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGStoreEventItemsPackButton", "HandleEndDateTimerReached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGStoreEventItemsPackButton.HideSelectedCanvas
// (Final, Native, Private)

void UUMGStoreEventItemsPackButton::HideSelectedCanvas()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGStoreEventItemsPackButton", "HideSelectedCanvas");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGStoreEventItemsPackButton.ShowSelectedCanvas
// (Final, Native, Private)

void UUMGStoreEventItemsPackButton::ShowSelectedCanvas()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGStoreEventItemsPackButton", "ShowSelectedCanvas");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGStreamVideoWidget.OnSkipButtonClicked
// (Final, Native, Protected, BlueprintCallable)

void UUMGStreamVideoWidget::OnSkipButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGStreamVideoWidget", "OnSkipButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGStreamVideoWidget.OnTapButtonClicked
// (Final, Native, Protected)

void UUMGStreamVideoWidget::OnTapButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGStreamVideoWidget", "OnTapButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSubscriptionPackButtonWidget.OnInfoButtonClicked
// (Final, Native, Private, BlueprintCallable)

void UUMGSubscriptionPackButtonWidget::OnInfoButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSubscriptionPackButtonWidget", "OnInfoButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSubscriptionsPageScrollWidget.HandleBuySubscriptionPackButtonClickedEvent
// (Final, Native, Private)
// Parameters:
// class FName                             subscriptionPackID                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSubscriptionsPageScrollWidget::HandleBuySubscriptionPackButtonClickedEvent(class FName subscriptionPackID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSubscriptionsPageScrollWidget", "HandleBuySubscriptionPackButtonClickedEvent");

	Params::UMGSubscriptionsPageScrollWidget_HandleBuySubscriptionPackButtonClickedEvent Parms{};

	Parms.subscriptionPackID = subscriptionPackID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGSubscriptionsPageScrollWidget.HandleSubscriptionInfoButtonClickedEvent
// (Final, Native, Private)
// Parameters:
// const class FString&                    subscriptionDetails                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGSubscriptionsPageScrollWidget::HandleSubscriptionInfoButtonClickedEvent(const class FString& subscriptionDetails)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGSubscriptionsPageScrollWidget", "HandleSubscriptionInfoButtonClickedEvent");

	Params::UMGSubscriptionsPageScrollWidget_HandleSubscriptionInfoButtonClickedEvent Parms{};

	Parms.subscriptionDetails = std::move(subscriptionDetails);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyBloodpointsWidget.ShowTallyItemWidget
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTallyBloodpointsWidget::ShowTallyItemWidget(bool isShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyBloodpointsWidget", "ShowTallyItemWidget");

	Params::UMGTallyBloodpointsWidget_ShowTallyItemWidget Parms{};

	Parms.isShow = isShow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGTallyBloodpointsWidget.UpdateTallyItemWidget
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FTallyItemChangedData&     data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UUMGTallyBloodpointsWidget::UpdateTallyItemWidget(const struct FTallyItemChangedData& data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyBloodpointsWidget", "UpdateTallyItemWidget");

	Params::UMGTallyBloodpointsWidget_UpdateTallyItemWidget Parms{};

	Parms.data = std::move(data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGTallyBloodpointsWidget.UpdateTallyRewardWidget
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class FString&                    rewardName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   existReward                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   addReward                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTallyBloodpointsWidget::UpdateTallyRewardWidget(const class FString& rewardName, int32 existReward, int32 addReward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyBloodpointsWidget", "UpdateTallyRewardWidget");

	Params::UMGTallyBloodpointsWidget_UpdateTallyRewardWidget Parms{};

	Parms.rewardName = std::move(rewardName);
	Parms.existReward = existReward;
	Parms.addReward = addReward;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGTallyBloodpointsWidget.UpdateTallyTotalBloodpoints
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   totalValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTallyBloodpointsWidget::UpdateTallyTotalBloodpoints(int32 totalValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyBloodpointsWidget", "UpdateTallyTotalBloodpoints");

	Params::UMGTallyBloodpointsWidget_UpdateTallyTotalBloodpoints Parms{};

	Parms.totalValue = totalValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DeadByDaylight.UMGTallyCharacterProgressionWidget.OnFullBarIn
// (Final, Native, Private)

void UUMGTallyCharacterProgressionWidget::OnFullBarIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyCharacterProgressionWidget", "OnFullBarIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyCharacterProgressionWidget.OnFullBarOut
// (Final, Native, Private)

void UUMGTallyCharacterProgressionWidget::OnFullBarOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyCharacterProgressionWidget", "OnFullBarOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyCharacterProgressionWidget.SetWidgetToFinalState
// (Final, Native, Public, BlueprintCallable)

void UUMGTallyCharacterProgressionWidget::SetWidgetToFinalState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyCharacterProgressionWidget", "SetWidgetToFinalState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyCharacterProgressionWidget.StartNewLevel
// (Final, Native, Private)

void UUMGTallyCharacterProgressionWidget::StartNewLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyCharacterProgressionWidget", "StartNewLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyCharacterProgressionWidget.StartSequence
// (Final, Native, Public, BlueprintCallable)

void UUMGTallyCharacterProgressionWidget::StartSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyCharacterProgressionWidget", "StartSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyEmblemsWidget.GetEmblems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UUMGTallyEmblemWidget*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UUMGTallyEmblemWidget*> UUMGTallyEmblemsWidget::GetEmblems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyEmblemsWidget", "GetEmblems");

	Params::UMGTallyEmblemsWidget_GetEmblems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGTallyEmblemWidget.PlayFadeInAnimation
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UUMGTallyEmblemWidget::PlayFadeInAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyEmblemWidget", "PlayFadeInAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGTallyPip.HideFilling
// (Final, Native, Protected)

void UUMGTallyPip::HideFilling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyPip", "HideFilling");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyPipsContainer.SetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   pipsRequiredForNextRank                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   filledPips                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTallyPipsContainer::SetData(int32 rank, int32 pipsRequiredForNextRank, int32 filledPips)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyPipsContainer", "SetData");

	Params::UMGTallyPipsContainer_SetData Parms{};

	Parms.rank = rank;
	Parms.pipsRequiredForNextRank = pipsRequiredForNextRank;
	Parms.filledPips = filledPips;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyRankFrame.SetData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerRole                             playerRole                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTallyRankFrame::SetData(int32 rank, EPlayerRole playerRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyRankFrame", "SetData");

	Params::UMGTallyRankFrame_SetData Parms{};

	Parms.rank = rank;
	Parms.playerRole = playerRole;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyRankWidget.GetEmblems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UUMGTallyEmblemWidget*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UUMGTallyEmblemWidget*> UUMGTallyRankWidget::GetEmblems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyRankWidget", "GetEmblems");

	Params::UMGTallyRankWidget_GetEmblems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGTallyRankWidget.GetScoreData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FTallyScorePipsData        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FTallyScorePipsData UUMGTallyRankWidget::GetScoreData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyRankWidget", "GetScoreData");

	Params::UMGTallyRankWidget_GetScoreData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DeadByDaylight.UMGTallyScoreboardWidget.HandleAddFriendEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    playerID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTallyScoreboardWidget::HandleAddFriendEvent(const class FString& playerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyScoreboardWidget", "HandleAddFriendEvent");

	Params::UMGTallyScoreboardWidget_HandleAddFriendEvent Parms{};

	Parms.playerID = std::move(playerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyScoreboardWidget.HandleReportEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    playerID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTallyScoreboardWidget::HandleReportEvent(const class FString& playerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyScoreboardWidget", "HandleReportEvent");

	Params::UMGTallyScoreboardWidget_HandleReportEvent Parms{};

	Parms.playerID = std::move(playerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.UMGTallyScoreboardWidget.SetFadeOut
// (Event, Protected, BlueprintEvent)

void UUMGTallyScoreboardWidget::SetFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTallyScoreboardWidget", "SetFadeOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DeadByDaylight.UMGTeachablePerkButton.HandleTooltipLongPressedEvent
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// const struct FInventorySlotData&        itemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector2D&                 position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUMGTeachablePerkButton::HandleTooltipLongPressedEvent(const struct FInventorySlotData& itemData, const struct FVector2D& position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGTeachablePerkButton", "HandleTooltipLongPressedEvent");

	Params::UMGTeachablePerkButton_HandleTooltipLongPressedEvent Parms{};

	Parms.itemData = std::move(itemData);
	Parms.position = std::move(position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ZoneDetectorComponent.OnOverlapEnter
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UZoneDetectorComponent::OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZoneDetectorComponent", "OnOverlapEnter");

	Params::ZoneDetectorComponent_OnOverlapEnter Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DeadByDaylight.ZoneDetectorComponent.OnOverlapExit
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UZoneDetectorComponent::OnOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZoneDetectorComponent", "OnOverlapExit");

	Params::ZoneDetectorComponent_OnOverlapExit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

