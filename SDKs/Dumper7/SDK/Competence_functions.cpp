#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Competence

#include "Basic.hpp"

#include "Competence_classes.hpp"
#include "Competence_parameters.hpp"


namespace SDK
{

// Function Competence.BaseModifierCondition.InitializeSubjectProviderClass
// (Native, Event, Protected, BlueprintEvent)

void UBaseModifierCondition::InitializeSubjectProviderClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierCondition", "InitializeSubjectProviderClass");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Competence.BaseModifierCondition.OnRep_OwningModifier
// (Final, Native, Private)

void UBaseModifierCondition::OnRep_OwningModifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierCondition", "OnRep_OwningModifier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Competence.BaseModifierCondition.OnRep_SubjectProviderClass
// (Final, Native, Private)

void UBaseModifierCondition::OnRep_SubjectProviderClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierCondition", "OnRep_SubjectProviderClass");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Competence.BaseModifierCondition.SetSubjectProviderClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           subjectProviderClass                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseModifierCondition::SetSubjectProviderClass(class UClass* subjectProviderClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierCondition", "SetSubjectProviderClass");

	Params::BaseModifierCondition_SetSubjectProviderClass Parms{};

	Parms.subjectProviderClass = subjectProviderClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Competence.BaseModifierCondition.GetOwningActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UBaseModifierCondition::GetOwningActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierCondition", "GetOwningActor");

	Params::BaseModifierCondition_GetOwningActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.CompositeModifierCondition.OnRep_Conditions
// (Final, Native, Private)

void UCompositeModifierCondition::OnRep_Conditions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompositeModifierCondition", "OnRep_Conditions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Competence.BaseModifierContainer.Authority_OnInstantiateModifierConditions
// (BlueprintAuthorityOnly, Event, Protected, BlueprintEvent)

void UBaseModifierContainer::Authority_OnInstantiateModifierConditions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierContainer", "Authority_OnInstantiateModifierConditions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Competence.BaseModifierContainer.CreateAndSetEventDrivenCondition
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UEventDrivenModifierCondition>conditionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEventDrivenModifierCondition*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEventDrivenModifierCondition* UBaseModifierContainer::CreateAndSetEventDrivenCondition(TSubclassOf<class UEventDrivenModifierCondition> conditionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierContainer", "CreateAndSetEventDrivenCondition");

	Params::BaseModifierContainer_CreateAndSetEventDrivenCondition Parms{};

	Parms.conditionType = conditionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.BaseModifierContainer.OnRep_EventDrivenConditionData_Internal
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FModifierReplicatedEventConditionData&oldReplicatedCondition                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBaseModifierContainer::OnRep_EventDrivenConditionData_Internal(const struct FModifierReplicatedEventConditionData& oldReplicatedCondition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierContainer", "OnRep_EventDrivenConditionData_Internal");

	Params::BaseModifierContainer_OnRep_EventDrivenConditionData_Internal Parms{};

	Parms.oldReplicatedCondition = std::move(oldReplicatedCondition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Competence.BaseModifierContainer.IsApplicable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseModifierContainer::IsApplicable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseModifierContainer", "IsApplicable");

	Params::BaseModifierContainer_IsApplicable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.IsTimerDoneCondition.OnRep_Timer
// (Final, Native, Private)

void UIsTimerDoneCondition::OnRep_Timer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IsTimerDoneCondition", "OnRep_Timer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Competence.IsTimerDoneCondition.SetTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTimerObject*                     timer                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIsTimerDoneCondition::SetTimer(class UTimerObject* timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IsTimerDoneCondition", "SetTimer");

	Params::IsTimerDoneCondition_SetTimer Parms{};

	Parms.timer = timer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Competence.RangeBasedCondition.OnRep_Range
// (Final, Native, Private)

void URangeBasedCondition::OnRep_Range()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangeBasedCondition", "OnRep_Range");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Competence.RangeBasedCondition.SetRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URangeBasedCondition::SetRange(float range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RangeBasedCondition", "SetRange");

	Params::RangeBasedCondition_SetRange Parms{};

	Parms.range = range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Competence.ConditionFactory.And
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>conditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// class UAndModifierCondition*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAndModifierCondition* UConditionFactory::And(TScriptInterface<class IConditionReceiver> conditionReceiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "And");

	Params::ConditionFactory_And Parms{};

	Parms.conditionReceiver = conditionReceiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.CreateAndReceiveConditionForBP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>conditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TSubclassOf<class UEventDrivenModifierCondition>conditionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEventDrivenModifierCondition*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEventDrivenModifierCondition* UConditionFactory::CreateAndReceiveConditionForBP(TScriptInterface<class IConditionReceiver> conditionReceiver, TSubclassOf<class UEventDrivenModifierCondition> conditionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "CreateAndReceiveConditionForBP");

	Params::ConditionFactory_CreateAndReceiveConditionForBP Parms{};

	Parms.conditionReceiver = conditionReceiver;
	Parms.conditionType = conditionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.CreateAndReceiveConditionWithSubjectForBP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>conditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TSubclassOf<class UEventDrivenModifierCondition>conditionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           subjectProviderClass                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEventDrivenModifierCondition*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEventDrivenModifierCondition* UConditionFactory::CreateAndReceiveConditionWithSubjectForBP(TScriptInterface<class IConditionReceiver> conditionReceiver, TSubclassOf<class UEventDrivenModifierCondition> conditionType, class UClass* subjectProviderClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "CreateAndReceiveConditionWithSubjectForBP");

	Params::ConditionFactory_CreateAndReceiveConditionWithSubjectForBP Parms{};

	Parms.conditionReceiver = conditionReceiver;
	Parms.conditionType = conditionType;
	Parms.subjectProviderClass = subjectProviderClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.CreateRangeBasedCondition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>conditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TSubclassOf<class URangeBasedCondition> conditionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URangeBasedCondition*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URangeBasedCondition* UConditionFactory::CreateRangeBasedCondition(TScriptInterface<class IConditionReceiver> conditionReceiver, TSubclassOf<class URangeBasedCondition> conditionType, float range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "CreateRangeBasedCondition");

	Params::ConditionFactory_CreateRangeBasedCondition Parms{};

	Parms.conditionReceiver = conditionReceiver;
	Parms.conditionType = conditionType;
	Parms.range = range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.CreateRangeBasedConditionWithSubject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>conditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TSubclassOf<class URangeBasedCondition> conditionType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           subjectProviderClass                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class URangeBasedCondition*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URangeBasedCondition* UConditionFactory::CreateRangeBasedConditionWithSubject(TScriptInterface<class IConditionReceiver> conditionReceiver, TSubclassOf<class URangeBasedCondition> conditionType, float range, class UClass* subjectProviderClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "CreateRangeBasedConditionWithSubject");

	Params::ConditionFactory_CreateRangeBasedConditionWithSubject Parms{};

	Parms.conditionReceiver = conditionReceiver;
	Parms.conditionType = conditionType;
	Parms.range = range;
	Parms.subjectProviderClass = subjectProviderClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.IsTimerDone
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>conditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// class UTimerObject*                     timer                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UIsTimerDoneCondition*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UIsTimerDoneCondition* UConditionFactory::IsTimerDone(TScriptInterface<class IConditionReceiver> conditionReceiver, class UTimerObject* timer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "IsTimerDone");

	Params::ConditionFactory_IsTimerDone Parms{};

	Parms.conditionReceiver = conditionReceiver;
	Parms.timer = timer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.Lingering
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>conditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// float                                   timeToTrack                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULingeringModifierCondition*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULingeringModifierCondition* UConditionFactory::Lingering(TScriptInterface<class IConditionReceiver> conditionReceiver, float timeToTrack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "Lingering");

	Params::ConditionFactory_Lingering Parms{};

	Parms.conditionReceiver = conditionReceiver;
	Parms.timeToTrack = timeToTrack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.Not
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>conditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// class UNotModifierCondition*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNotModifierCondition* UConditionFactory::Not(TScriptInterface<class IConditionReceiver> conditionReceiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "Not");

	Params::ConditionFactory_Not Parms{};

	Parms.conditionReceiver = conditionReceiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.ConditionFactory.Or
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IConditionReceiver>conditionReceiver                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// class UOrModifierCondition*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOrModifierCondition* UConditionFactory::Or(TScriptInterface<class IConditionReceiver> conditionReceiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConditionFactory", "Or");

	Params::ConditionFactory_Or Parms{};

	Parms.conditionReceiver = conditionReceiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Competence.HasObjectState.SetState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              state                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHasObjectState::SetState(const struct FGameplayTag& state)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HasObjectState", "SetState");

	Params::HasObjectState_SetState Parms{};

	Parms.state = std::move(state);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Competence.HasObjectStateWithMaxDuration.SetMaxDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHasObjectStateWithMaxDuration::SetMaxDuration(float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HasObjectStateWithMaxDuration", "SetMaxDuration");

	Params::HasObjectStateWithMaxDuration_SetMaxDuration Parms{};

	Parms.duration = duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Competence.SingleModifierCondition.OnRep_Condition
// (Final, Native, Protected)

void USingleModifierCondition::OnRep_Condition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SingleModifierCondition", "OnRep_Condition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Competence.LingeringModifierCondition.OnTimerEnd
// (Final, Native, Private)

void ULingeringModifierCondition::OnTimerEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LingeringModifierCondition", "OnTimerEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

