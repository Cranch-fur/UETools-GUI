#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK29

#include "Basic.hpp"

#include "DBDGameplay_classes.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDBots_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "TheK29_structs.hpp"
#include "DBDCompetence_classes.hpp"
#include "Engine_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "StatSystem_structs.hpp"
#include "DBDCosmetic_classes.hpp"


namespace SDK
{

// Class TheK29.AISkill_FindCollectable_K29SupplyCrate
// 0x0010 (0x0158 - 0x0148)
class UAISkill_FindCollectable_K29SupplyCrate final : public UAISkill_FindCollectable_Searchable
{
public:
	struct FAITunableParameter                    UrgencyGoalWeight;                                 // 0x0148(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable_K29SupplyCrate">();
	}
	static class UAISkill_FindCollectable_K29SupplyCrate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable_K29SupplyCrate>();
	}
};
static_assert(alignof(UAISkill_FindCollectable_K29SupplyCrate) == 0x000008, "Wrong alignment on UAISkill_FindCollectable_K29SupplyCrate");
static_assert(sizeof(UAISkill_FindCollectable_K29SupplyCrate) == 0x000158, "Wrong size on UAISkill_FindCollectable_K29SupplyCrate");
static_assert(offsetof(UAISkill_FindCollectable_K29SupplyCrate, UrgencyGoalWeight) == 0x000148, "Member 'UAISkill_FindCollectable_K29SupplyCrate::UrgencyGoalWeight' has a wrong offset!");

// Class TheK29.AISkill_InteractionUseItem_K29StabilizingSpray
// 0x0000 (0x0188 - 0x0188)
class UAISkill_InteractionUseItem_K29StabilizingSpray final : public UAISkill_InteractionUseItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_K29StabilizingSpray">();
	}
	static class UAISkill_InteractionUseItem_K29StabilizingSpray* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_K29StabilizingSpray>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_K29StabilizingSpray) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_K29StabilizingSpray");
static_assert(sizeof(UAISkill_InteractionUseItem_K29StabilizingSpray) == 0x000188, "Wrong size on UAISkill_InteractionUseItem_K29StabilizingSpray");

// Class TheK29.AISkill_InteractionUseItem_K29StabilizingSprayOther
// 0x0000 (0x0188 - 0x0188)
class UAISkill_InteractionUseItem_K29StabilizingSprayOther final : public UAISkill_InteractionUseItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_K29StabilizingSprayOther">();
	}
	static class UAISkill_InteractionUseItem_K29StabilizingSprayOther* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_K29StabilizingSprayOther>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_K29StabilizingSprayOther) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_K29StabilizingSprayOther");
static_assert(sizeof(UAISkill_InteractionUseItem_K29StabilizingSprayOther) == 0x000188, "Wrong size on UAISkill_InteractionUseItem_K29StabilizingSprayOther");

// Class TheK29.K29AnimInstance
// 0x0030 (0x0630 - 0x0600)
class UK29AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isRushing;                                        // 0x0600(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingSurvivor;                                // 0x0601(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingRushing;                                // 0x0602(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBetweenRushes;                                  // 0x0603(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isThrowing;                                       // 0x0604(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBouncingBack;                                   // 0x0605(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasStartedFinalRush;                              // 0x0606(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasRushEndedInSurvivorImpact;                     // 0x0607(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasRushEndedInLedgeDrop;                          // 0x0608(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasInstantlyPickedUpSurvivor;                     // 0x0609(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isReadyToRushButHasNoPath;                        // 0x060A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60B[0x25];                                     // 0x060B(0x0025)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameEventReceived(const struct FGameplayTag& gameplayTag, const struct FGameEventData& gameEventData);
	void OnHasInstantlyPickedUpSurvivor();
	void OnHasRushEndedInLedgeDrop();
	void OnHasRushEndedInSurvivorImpact();
	void OnStartThrowingSurvivor();
	void ResetHasInstantlyPickedUpSurvivor();
	void ResetHasRushEndedInLedgeDrop();
	void ResetHasRushEndedInSurvivorImpact();
	void ResetStartThrowingSurvivor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29AnimInstance">();
	}
	static class UK29AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29AnimInstance>();
	}
};
static_assert(alignof(UK29AnimInstance) == 0x000010, "Wrong alignment on UK29AnimInstance");
static_assert(sizeof(UK29AnimInstance) == 0x000630, "Wrong size on UK29AnimInstance");
static_assert(offsetof(UK29AnimInstance, _isRushing) == 0x000600, "Member 'UK29AnimInstance::_isRushing' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isHoldingSurvivor) == 0x000601, "Member 'UK29AnimInstance::_isHoldingSurvivor' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isChargingRushing) == 0x000602, "Member 'UK29AnimInstance::_isChargingRushing' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isBetweenRushes) == 0x000603, "Member 'UK29AnimInstance::_isBetweenRushes' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isThrowing) == 0x000604, "Member 'UK29AnimInstance::_isThrowing' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isBouncingBack) == 0x000605, "Member 'UK29AnimInstance::_isBouncingBack' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _hasStartedFinalRush) == 0x000606, "Member 'UK29AnimInstance::_hasStartedFinalRush' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _hasRushEndedInSurvivorImpact) == 0x000607, "Member 'UK29AnimInstance::_hasRushEndedInSurvivorImpact' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _hasRushEndedInLedgeDrop) == 0x000608, "Member 'UK29AnimInstance::_hasRushEndedInLedgeDrop' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _hasInstantlyPickedUpSurvivor) == 0x000609, "Member 'UK29AnimInstance::_hasInstantlyPickedUpSurvivor' has a wrong offset!");
static_assert(offsetof(UK29AnimInstance, _isReadyToRushButHasNoPath) == 0x00060A, "Member 'UK29AnimInstance::_isReadyToRushButHasNoPath' has a wrong offset!");

// Class TheK29.K29GateBlockerStatusEffect
// 0x0020 (0x03F0 - 0x03D0)
class UK29GateBlockerStatusEffect final : public ULingeringMultiStateTagStatusEffect
{
public:
	class FName                                   _escapeZoneBoxComponentTagName;                    // 0x03D0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DC[0x14];                                     // 0x03DC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29GateBlockerStatusEffect">();
	}
	static class UK29GateBlockerStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29GateBlockerStatusEffect>();
	}
};
static_assert(alignof(UK29GateBlockerStatusEffect) == 0x000008, "Wrong alignment on UK29GateBlockerStatusEffect");
static_assert(sizeof(UK29GateBlockerStatusEffect) == 0x0003F0, "Wrong size on UK29GateBlockerStatusEffect");
static_assert(offsetof(UK29GateBlockerStatusEffect, _escapeZoneBoxComponentTagName) == 0x0003D0, "Member 'UK29GateBlockerStatusEffect::_escapeZoneBoxComponentTagName' has a wrong offset!");

// Class TheK29.K29HinderedStatusEffect
// 0x00D0 (0x0420 - 0x0350)
class UK29HinderedStatusEffect final : public UStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _maximumMovementSpeedDecrease;                     // 0x0350(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _minimumMovementSpeedDecrease;                     // 0x0378(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x80];                                     // 0x03A0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29HinderedStatusEffect">();
	}
	static class UK29HinderedStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29HinderedStatusEffect>();
	}
};
static_assert(alignof(UK29HinderedStatusEffect) == 0x000008, "Wrong alignment on UK29HinderedStatusEffect");
static_assert(sizeof(UK29HinderedStatusEffect) == 0x000420, "Wrong size on UK29HinderedStatusEffect");
static_assert(offsetof(UK29HinderedStatusEffect, _maximumMovementSpeedDecrease) == 0x000350, "Member 'UK29HinderedStatusEffect::_maximumMovementSpeedDecrease' has a wrong offset!");
static_assert(offsetof(UK29HinderedStatusEffect, _minimumMovementSpeedDecrease) == 0x000378, "Member 'UK29HinderedStatusEffect::_minimumMovementSpeedDecrease' has a wrong offset!");

// Class TheK29.K29InfectionRemovalCollectable
// 0x0048 (0x0540 - 0x04F8)
class AK29InfectionRemovalCollectable final : public ABaseCamperCollectable
{
public:
	class UK29InfectionRemovalItemOutlineUpdateStrategy* _outlineUpdateStrategy;                     // 0x04F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maxCharges;                                       // 0x0500(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_528[0x18];                                     // 0x0528(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29InfectionRemovalCollectable">();
	}
	static class AK29InfectionRemovalCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK29InfectionRemovalCollectable>();
	}
};
static_assert(alignof(AK29InfectionRemovalCollectable) == 0x000008, "Wrong alignment on AK29InfectionRemovalCollectable");
static_assert(sizeof(AK29InfectionRemovalCollectable) == 0x000540, "Wrong size on AK29InfectionRemovalCollectable");
static_assert(offsetof(AK29InfectionRemovalCollectable, _outlineUpdateStrategy) == 0x0004F8, "Member 'AK29InfectionRemovalCollectable::_outlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AK29InfectionRemovalCollectable, _maxCharges) == 0x000500, "Member 'AK29InfectionRemovalCollectable::_maxCharges' has a wrong offset!");

// Class TheK29.K29InfectionRemovalItemOutlineUpdateStrategy
// 0x0008 (0x00C8 - 0x00C0)
class UK29InfectionRemovalItemOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	bool                                          _isOutlineEnabled;                                 // 0x00C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 _outlineColour;                                    // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetOutlineVisibility(bool isActive);

	bool IsOutlineVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29InfectionRemovalItemOutlineUpdateStrategy">();
	}
	static class UK29InfectionRemovalItemOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29InfectionRemovalItemOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK29InfectionRemovalItemOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK29InfectionRemovalItemOutlineUpdateStrategy");
static_assert(sizeof(UK29InfectionRemovalItemOutlineUpdateStrategy) == 0x0000C8, "Wrong size on UK29InfectionRemovalItemOutlineUpdateStrategy");
static_assert(offsetof(UK29InfectionRemovalItemOutlineUpdateStrategy, _isOutlineEnabled) == 0x0000C0, "Member 'UK29InfectionRemovalItemOutlineUpdateStrategy::_isOutlineEnabled' has a wrong offset!");
static_assert(offsetof(UK29InfectionRemovalItemOutlineUpdateStrategy, _outlineColour) == 0x0000C4, "Member 'UK29InfectionRemovalItemOutlineUpdateStrategy::_outlineColour' has a wrong offset!");

// Class TheK29.K29P01
// 0x0010 (0x03D8 - 0x03C8)
class UK29P01 final : public UPerk
{
public:
	float                                         _survivorVaultRushedEventRange;                    // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cooldownTime;                                     // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x8];                                      // 0x03D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetSurvivorVaultRushedEventRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29P01">();
	}
	static class UK29P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29P01>();
	}
};
static_assert(alignof(UK29P01) == 0x000008, "Wrong alignment on UK29P01");
static_assert(sizeof(UK29P01) == 0x0003D8, "Wrong size on UK29P01");
static_assert(offsetof(UK29P01, _survivorVaultRushedEventRange) == 0x0003C8, "Member 'UK29P01::_survivorVaultRushedEventRange' has a wrong offset!");
static_assert(offsetof(UK29P01, _cooldownTime) == 0x0003CC, "Member 'UK29P01::_cooldownTime' has a wrong offset!");

// Class TheK29.K29P02
// 0x00C8 (0x0490 - 0x03C8)
class UK29P02 final : public UPerk
{
public:
	float                                         _revealRange[0x3];                                 // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _effectClass;                                      // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class ACamperPlayer>, TWeakObjectPtr<class UStatusEffect>> _survivorRevealedEffects; // 0x03E0(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_430[0x60];                                     // 0x0430(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnInRangeChanged(const bool inRange, class ACamperPlayer* survivor);
	const float GetRevealRange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29P02">();
	}
	static class UK29P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29P02>();
	}
};
static_assert(alignof(UK29P02) == 0x000008, "Wrong alignment on UK29P02");
static_assert(sizeof(UK29P02) == 0x000490, "Wrong size on UK29P02");
static_assert(offsetof(UK29P02, _revealRange) == 0x0003C8, "Member 'UK29P02::_revealRange' has a wrong offset!");
static_assert(offsetof(UK29P02, _effectClass) == 0x0003D8, "Member 'UK29P02::_effectClass' has a wrong offset!");
static_assert(offsetof(UK29P02, _survivorRevealedEffects) == 0x0003E0, "Member 'UK29P02::_survivorRevealedEffects' has a wrong offset!");

// Class TheK29.K29P03
// 0x0018 (0x03E0 - 0x03C8)
class UK29P03 final : public UPerk
{
public:
	float                                         _brokenEffectDuration[0x3];                        // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _effectClass;                                      // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29P03">();
	}
	static class UK29P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29P03>();
	}
};
static_assert(alignof(UK29P03) == 0x000008, "Wrong alignment on UK29P03");
static_assert(sizeof(UK29P03) == 0x0003E0, "Wrong size on UK29P03");
static_assert(offsetof(UK29P03, _brokenEffectDuration) == 0x0003C8, "Member 'UK29P03::_brokenEffectDuration' has a wrong offset!");
static_assert(offsetof(UK29P03, _effectClass) == 0x0003D8, "Member 'UK29P03::_effectClass' has a wrong offset!");

// Class TheK29.K29P03StatusEffect
// 0x0000 (0x0360 - 0x0360)
class UK29P03StatusEffect final : public UAdjustableCooldownStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29P03StatusEffect">();
	}
	static class UK29P03StatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29P03StatusEffect>();
	}
};
static_assert(alignof(UK29P03StatusEffect) == 0x000008, "Wrong alignment on UK29P03StatusEffect");
static_assert(sizeof(UK29P03StatusEffect) == 0x000360, "Wrong size on UK29P03StatusEffect");

// Class TheK29.K29PathingCalculatorComponent
// 0x0200 (0x02B8 - 0x00B8)
class UK29PathingCalculatorComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _maxStepHeight;                                    // 0x00B8(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maxStepHeightDownwards;                           // 0x00E0(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _horizontalAngle;                                  // 0x0108(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _verticalAngle;                                    // 0x0130(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _gridLength;                                       // 0x0158(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _detectionHeightOffset;                            // 0x0180(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _floorSearchLengthFromActorLocation;               // 0x01A8(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _minimumWallDashDistanceCarryingSurvivor;          // 0x01D0(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _floorCheckDistance;                               // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _lineOfSightCapsuleRadius;                         // 0x0200(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _lineOfSightCapsuleHeight;                         // 0x0228(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _lineOfSightCapsuleHeightOffset;                   // 0x0250(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _maximumWalkableAngle;                             // 0x0278(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _groundCollisionDetectionRadius;                   // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _allowedGroundBlockerHeight;                       // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _minimalLedgeDistance;                             // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0xC];                                      // 0x02AC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29PathingCalculatorComponent">();
	}
	static class UK29PathingCalculatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29PathingCalculatorComponent>();
	}
};
static_assert(alignof(UK29PathingCalculatorComponent) == 0x000008, "Wrong alignment on UK29PathingCalculatorComponent");
static_assert(sizeof(UK29PathingCalculatorComponent) == 0x0002B8, "Wrong size on UK29PathingCalculatorComponent");
static_assert(offsetof(UK29PathingCalculatorComponent, _maxStepHeight) == 0x0000B8, "Member 'UK29PathingCalculatorComponent::_maxStepHeight' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _maxStepHeightDownwards) == 0x0000E0, "Member 'UK29PathingCalculatorComponent::_maxStepHeightDownwards' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _horizontalAngle) == 0x000108, "Member 'UK29PathingCalculatorComponent::_horizontalAngle' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _verticalAngle) == 0x000130, "Member 'UK29PathingCalculatorComponent::_verticalAngle' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _gridLength) == 0x000158, "Member 'UK29PathingCalculatorComponent::_gridLength' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _detectionHeightOffset) == 0x000180, "Member 'UK29PathingCalculatorComponent::_detectionHeightOffset' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _floorSearchLengthFromActorLocation) == 0x0001A8, "Member 'UK29PathingCalculatorComponent::_floorSearchLengthFromActorLocation' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _minimumWallDashDistanceCarryingSurvivor) == 0x0001D0, "Member 'UK29PathingCalculatorComponent::_minimumWallDashDistanceCarryingSurvivor' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _floorCheckDistance) == 0x0001F8, "Member 'UK29PathingCalculatorComponent::_floorCheckDistance' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _lineOfSightCapsuleRadius) == 0x000200, "Member 'UK29PathingCalculatorComponent::_lineOfSightCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _lineOfSightCapsuleHeight) == 0x000228, "Member 'UK29PathingCalculatorComponent::_lineOfSightCapsuleHeight' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _lineOfSightCapsuleHeightOffset) == 0x000250, "Member 'UK29PathingCalculatorComponent::_lineOfSightCapsuleHeightOffset' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _maximumWalkableAngle) == 0x000278, "Member 'UK29PathingCalculatorComponent::_maximumWalkableAngle' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _groundCollisionDetectionRadius) == 0x0002A0, "Member 'UK29PathingCalculatorComponent::_groundCollisionDetectionRadius' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _allowedGroundBlockerHeight) == 0x0002A4, "Member 'UK29PathingCalculatorComponent::_allowedGroundBlockerHeight' has a wrong offset!");
static_assert(offsetof(UK29PathingCalculatorComponent, _minimalLedgeDistance) == 0x0002A8, "Member 'UK29PathingCalculatorComponent::_minimalLedgeDistance' has a wrong offset!");

// Class TheK29.K29Power
// 0x01A0 (0x0650 - 0x04B0)
class AK29Power final : public ACollectable
{
public:
	class UChargeableComponent*                   _rushChargeableComponent;                          // 0x04B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _interactor;                                       // 0x04B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxPlayerOverlapComponent*             _interactionVolume;                                // 0x04C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK29PowerChargePresentationItemProgressComponent* _powerChargePresentationItemProgressComponent; // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK29PowerChargePresentationPowerFadeComponent* _powerChargePresentationPowerFadeComponent; // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK29PowerStatusHandlerComponent> _powerStatusHandlerComponentClass;            // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK29RushChargesHandlerComponent> _rushChargesHandlerComponentClass;            // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK29PathingCalculatorComponent> _pathingCalculatorComponentClass;              // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _blindnessProtectionStatusEffectClass;             // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _rushChargeTime;                                   // 0x04F8(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FStatProperty                          _scorePercent;                                     // 0x0578(0x0088)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AAnimationFollowerActor>    _moriTentaclesAnimationFollowerActorClass;         // 0x0600(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_608[0x8];                                      // 0x0608(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UK29PowerStatusHandlerComponent*        _powerStatusHandlerComponent;                      // 0x0610(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK29RushChargesHandlerComponent*        _rushChargesHandlerComponent;                      // 0x0618(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK29PathingCalculatorComponent*         _pathingCalculatorComponent;                       // 0x0620(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_628[0x28];                                     // 0x0628(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnStun(const struct FGameplayTag& gameplayTag, const struct FGameEventData& gameEventData);
	class UK29RushCooldownInteraction* GetDropSurvivorCooldownInteraction();
	class UK29PowerStatusHandlerComponent* GetPowerStatusHandlerComponent();
	class UInteractionDefinition* GetPushSurvivorOverLedgeInteraction();
	class UK29RushCooldownInteraction* GetRushBreakableCooldownInteraction();
	class UK29RushChargeableInteraction* GetRushChargeableInteraction();
	class UK29RushCooldownInteraction* GetRushChargeCancelCooldownInteraction();
	class UK29RushChargesHandlerComponent* GetRushChargesHandlerComponent();
	class UK29RushCooldownInteraction* GetRushCompleteNoSurvivorCooldownInteraction();
	class UK29RushCooldownInteraction* GetRushCompleteSurvivorHitCooldownInteraction();
	class UK29RushCooldownInteraction* GetRushCompleteSurvivorThrowCooldownInteraction();
	class UStaticMeshComponent* GetRushSurvivorDetectionBox();
	class UK29RushCooldownInteraction* GetRushVaultCooldownInteraction();
	class UInteractionDefinition* GetSlashBreakableInteraction();
	class UInteractionDefinition* GetSlashSurvivorInteraction();

	float GetScorePercent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29Power">();
	}
	static class AK29Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK29Power>();
	}
};
static_assert(alignof(AK29Power) == 0x000008, "Wrong alignment on AK29Power");
static_assert(sizeof(AK29Power) == 0x000650, "Wrong size on AK29Power");
static_assert(offsetof(AK29Power, _rushChargeableComponent) == 0x0004B0, "Member 'AK29Power::_rushChargeableComponent' has a wrong offset!");
static_assert(offsetof(AK29Power, _interactor) == 0x0004B8, "Member 'AK29Power::_interactor' has a wrong offset!");
static_assert(offsetof(AK29Power, _interactionVolume) == 0x0004C0, "Member 'AK29Power::_interactionVolume' has a wrong offset!");
static_assert(offsetof(AK29Power, _powerChargePresentationItemProgressComponent) == 0x0004C8, "Member 'AK29Power::_powerChargePresentationItemProgressComponent' has a wrong offset!");
static_assert(offsetof(AK29Power, _powerChargePresentationPowerFadeComponent) == 0x0004D0, "Member 'AK29Power::_powerChargePresentationPowerFadeComponent' has a wrong offset!");
static_assert(offsetof(AK29Power, _powerStatusHandlerComponentClass) == 0x0004D8, "Member 'AK29Power::_powerStatusHandlerComponentClass' has a wrong offset!");
static_assert(offsetof(AK29Power, _rushChargesHandlerComponentClass) == 0x0004E0, "Member 'AK29Power::_rushChargesHandlerComponentClass' has a wrong offset!");
static_assert(offsetof(AK29Power, _pathingCalculatorComponentClass) == 0x0004E8, "Member 'AK29Power::_pathingCalculatorComponentClass' has a wrong offset!");
static_assert(offsetof(AK29Power, _blindnessProtectionStatusEffectClass) == 0x0004F0, "Member 'AK29Power::_blindnessProtectionStatusEffectClass' has a wrong offset!");
static_assert(offsetof(AK29Power, _rushChargeTime) == 0x0004F8, "Member 'AK29Power::_rushChargeTime' has a wrong offset!");
static_assert(offsetof(AK29Power, _scorePercent) == 0x000578, "Member 'AK29Power::_scorePercent' has a wrong offset!");
static_assert(offsetof(AK29Power, _moriTentaclesAnimationFollowerActorClass) == 0x000600, "Member 'AK29Power::_moriTentaclesAnimationFollowerActorClass' has a wrong offset!");
static_assert(offsetof(AK29Power, _powerStatusHandlerComponent) == 0x000610, "Member 'AK29Power::_powerStatusHandlerComponent' has a wrong offset!");
static_assert(offsetof(AK29Power, _rushChargesHandlerComponent) == 0x000618, "Member 'AK29Power::_rushChargesHandlerComponent' has a wrong offset!");
static_assert(offsetof(AK29Power, _pathingCalculatorComponent) == 0x000620, "Member 'AK29Power::_pathingCalculatorComponent' has a wrong offset!");

// Class TheK29.K29PowerChargePresentationItemProgressComponent
// 0x0018 (0x00D0 - 0x00B8)
class UK29PowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	class UK29PowerStatusHandlerComponent*        _statusHandlerComponent;                           // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK29RushChargesHandlerComponent*        _rushChargesHandlerComponent;                      // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK29RushChargeableInteraction*          _rushInteraction;                                  // 0x00C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29PowerChargePresentationItemProgressComponent">();
	}
	static class UK29PowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29PowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK29PowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK29PowerChargePresentationItemProgressComponent");
static_assert(sizeof(UK29PowerChargePresentationItemProgressComponent) == 0x0000D0, "Wrong size on UK29PowerChargePresentationItemProgressComponent");
static_assert(offsetof(UK29PowerChargePresentationItemProgressComponent, _statusHandlerComponent) == 0x0000B8, "Member 'UK29PowerChargePresentationItemProgressComponent::_statusHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK29PowerChargePresentationItemProgressComponent, _rushChargesHandlerComponent) == 0x0000C0, "Member 'UK29PowerChargePresentationItemProgressComponent::_rushChargesHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK29PowerChargePresentationItemProgressComponent, _rushInteraction) == 0x0000C8, "Member 'UK29PowerChargePresentationItemProgressComponent::_rushInteraction' has a wrong offset!");

// Class TheK29.K29PowerChargePresentationPowerFadeComponent
// 0x0018 (0x00D0 - 0x00B8)
class UK29PowerChargePresentationPowerFadeComponent final : public UPresentationPowerFadeComponent
{
public:
	class UK29RushChargesHandlerComponent*        _rushChargesHandlerComponent;                      // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKillerSet(class ASlasherPlayer* killer);
	void SetDependencies(class UK29RushChargesHandlerComponent* ammoHandler);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29PowerChargePresentationPowerFadeComponent">();
	}
	static class UK29PowerChargePresentationPowerFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29PowerChargePresentationPowerFadeComponent>();
	}
};
static_assert(alignof(UK29PowerChargePresentationPowerFadeComponent) == 0x000008, "Wrong alignment on UK29PowerChargePresentationPowerFadeComponent");
static_assert(sizeof(UK29PowerChargePresentationPowerFadeComponent) == 0x0000D0, "Wrong size on UK29PowerChargePresentationPowerFadeComponent");
static_assert(offsetof(UK29PowerChargePresentationPowerFadeComponent, _rushChargesHandlerComponent) == 0x0000B8, "Member 'UK29PowerChargePresentationPowerFadeComponent::_rushChargesHandlerComponent' has a wrong offset!");

// Class TheK29.K29PowerStatusHandlerComponent
// 0x0370 (0x0428 - 0x00B8)
class UK29PowerStatusHandlerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxInfectionLevel;                                // 0x00E8(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _infectionAddedPerTickWhileActive;                 // 0x0110(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _stabilizingHealAmountByUsage;                     // 0x0190(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _initialInfectionLevel;                            // 0x0198(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _addedInfectionLevelsOnGrab;                       // 0x0218(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _infectionHealingMultiplier;                       // 0x0298(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _infectionIncubationThreshold;                     // 0x0318(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _useInfectionRemoverChargeTime;                    // 0x0340(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _hinderedStatusEffectClass;                        // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _gateBlockerStatusEffectClass;                     // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UK29SurvivorThrowableComponent> _survivorThrowableClass;                       // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UChargeableInteractionDefinition> _useInfectionRemoverInteractionSelfClass;    // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UChargeableInteractionDefinition> _useInfectionRemoverInteractionOtherClass;   // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _maxInfectionLevelWhenHooked;                      // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _recentlyGrabbedThresholdSeconds;                  // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FK29SurvivorStatus>             _survivorStatusList;                               // 0x03F0(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x28];                                     // 0x0400(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToTimesCuredByHeal(const class ACamperPlayer* survivor);
	void Authority_AddInfectionLevels(const class ACamperPlayer* survivor, const int32 infectionToAdd);
	void Authority_HealAllSurvivorsInfectionWithStabilizingSpray();
	void Authority_HealInfectionLevels(const class ACamperPlayer* survivor, const int32 infectionLevelsToHeal, const bool shouldSetInfectionActiveToFalse);
	void Authority_OnIntroCompleted();
	void Authority_OnSlash(class ACamperPlayer* targetSurvivor);
	void Authority_OnSurvivorAdded(class ACamperPlayer* survivor);
	void Authority_OnSurvivorImmoblizedChanged();
	void Authority_SetAllSurvivorsToInitialInfection();
	void Authority_SetAllSurvivorsToMaxInfection();
	void Authority_UseStabilizingSpray(class ACamperPlayer* instigatingSurvivor, class ACamperPlayer* targetSurvivor);
	void Cosmetic_OnGrabbingInfectedSurvivor();
	void Cosmetic_OnGrabbingNonInfectedSurvivor();
	int32 GetInfectionLevel(const class ACamperPlayer* survivor);
	int32 GetMaxInfectionLevel();
	void Multicast_DropSurvivor(class ACamperPlayer* leftSurvivor);
	void Multicast_GrabSurvivor(class ACamperPlayer* survivor, const bool isProcessingInitialInfection);
	void Multicast_ReleaseSurvivor(class ACamperPlayer* survivor, bool isForced);
	void Multicast_RemoveSurvivorFromCloset(class ACamperPlayer* survivor);
	void Multicast_UseStabilizingSpray(class ACamperPlayer* targetSurvivor);
	void OnKillerSet(class ASlasherPlayer* killer);
	void OnRep_SurvivorStatusList(const TArray<struct FK29SurvivorStatus>& oldSurvivorStatus);
	void Server_GrabSurvivor(class ACamperPlayer* survivor, const bool isProcessingInitialInfection);
	void Server_ReleaseSurvivor(class ACamperPlayer* survivor, bool isForced);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29PowerStatusHandlerComponent">();
	}
	static class UK29PowerStatusHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29PowerStatusHandlerComponent>();
	}
};
static_assert(alignof(UK29PowerStatusHandlerComponent) == 0x000008, "Wrong alignment on UK29PowerStatusHandlerComponent");
static_assert(sizeof(UK29PowerStatusHandlerComponent) == 0x000428, "Wrong size on UK29PowerStatusHandlerComponent");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _maxInfectionLevel) == 0x0000E8, "Member 'UK29PowerStatusHandlerComponent::_maxInfectionLevel' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _infectionAddedPerTickWhileActive) == 0x000110, "Member 'UK29PowerStatusHandlerComponent::_infectionAddedPerTickWhileActive' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _stabilizingHealAmountByUsage) == 0x000190, "Member 'UK29PowerStatusHandlerComponent::_stabilizingHealAmountByUsage' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _initialInfectionLevel) == 0x000198, "Member 'UK29PowerStatusHandlerComponent::_initialInfectionLevel' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _addedInfectionLevelsOnGrab) == 0x000218, "Member 'UK29PowerStatusHandlerComponent::_addedInfectionLevelsOnGrab' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _infectionHealingMultiplier) == 0x000298, "Member 'UK29PowerStatusHandlerComponent::_infectionHealingMultiplier' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _infectionIncubationThreshold) == 0x000318, "Member 'UK29PowerStatusHandlerComponent::_infectionIncubationThreshold' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _useInfectionRemoverChargeTime) == 0x000340, "Member 'UK29PowerStatusHandlerComponent::_useInfectionRemoverChargeTime' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _hinderedStatusEffectClass) == 0x0003C0, "Member 'UK29PowerStatusHandlerComponent::_hinderedStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _gateBlockerStatusEffectClass) == 0x0003C8, "Member 'UK29PowerStatusHandlerComponent::_gateBlockerStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _survivorThrowableClass) == 0x0003D0, "Member 'UK29PowerStatusHandlerComponent::_survivorThrowableClass' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _useInfectionRemoverInteractionSelfClass) == 0x0003D8, "Member 'UK29PowerStatusHandlerComponent::_useInfectionRemoverInteractionSelfClass' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _useInfectionRemoverInteractionOtherClass) == 0x0003E0, "Member 'UK29PowerStatusHandlerComponent::_useInfectionRemoverInteractionOtherClass' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _maxInfectionLevelWhenHooked) == 0x0003E8, "Member 'UK29PowerStatusHandlerComponent::_maxInfectionLevelWhenHooked' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _recentlyGrabbedThresholdSeconds) == 0x0003EC, "Member 'UK29PowerStatusHandlerComponent::_recentlyGrabbedThresholdSeconds' has a wrong offset!");
static_assert(offsetof(UK29PowerStatusHandlerComponent, _survivorStatusList) == 0x0003F0, "Member 'UK29PowerStatusHandlerComponent::_survivorStatusList' has a wrong offset!");

// Class TheK29.K29RushChargeableInteraction
// 0x0800 (0x0F40 - 0x0740)
class UK29RushChargeableInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_740[0x10];                                     // 0x0740(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UK29RushChargesHandlerComponent*        _rushChargesHandlerComponent;                      // 0x0750(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK29PowerStatusHandlerComponent*        _powerStatusHandlerComponent;                      // 0x0758(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK29PathingCalculatorComponent*         _pathingCalculatorComponent;                       // 0x0760(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AK29Power*                              _powerCollectable;                                 // 0x0768(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EK29RushPhase, struct FK29RushMovementSpeedSetting> _movementSpeedSettingsByState;          // 0x0770(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _subsequentRushTimerTimeoutMovementSpeedMultiplierCurve; // 0x07C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _subsequentRushTimerTimeoutMovementSpeedReductionDuration; // 0x07C8(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _subsequentRushOpportunityTimerDuration;           // 0x0848(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _rushDuration;                                     // 0x08C8(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _rushDurationAfterFirst;                           // 0x0948(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleRadius;                                    // 0x09C8(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _survivorRevealTimeOnInstantPickup;                // 0x09F0(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleHeight;                                    // 0x0A18(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleHeightOffset;                              // 0x0A40(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _bounceDuration;                                   // 0x0A68(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _rushAccelerationMultiplier;                       // 0x0A90(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _instantCarryAnimationDuration;                    // 0x0AB8(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _percentageForRushChargeEndAvailability;           // 0x0AE0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _distanceInCmForNearMiss;                          // 0x0AE4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rushDetectionBackwardsOffset;                     // 0x0AE8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AEC[0x4];                                      // 0x0AEC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _revealToSurvivorsStatusEffect;                    // 0x0AF0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _rushMovementSpeedInCmPerSecond;                   // 0x0AF8(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _rushGrabMovementSpeedInCmPerSecond;               // 0x0B20(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _grabRushDuration;                                 // 0x0B48(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rotationStrengthTransitionTime;                   // 0x0BC8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BCC[0x4];                                      // 0x0BCC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _minimumRushDistance;                              // 0x0BD0(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _intoGrabbingTime;                                 // 0x0BF8(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _smashOutTimerDuration;                            // 0x0C20(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _isStoppingMomentumAtIntoGrabbing;                 // 0x0C48(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _movementSpeedCurveBetweenRushesIncreased;         // 0x0C70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _movementSpeedCurveChargingIncreased;              // 0x0C78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _rushMovementSpeedCurve;                           // 0x0C80(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _rushMovementSpeedCurveWithSurvivor;               // 0x0C88(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _killerRushSmashAnimationName;                     // 0x0C90(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _survivorRushSmashAnimationName;                   // 0x0C9C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _killerRushToCarryAnimationName;                   // 0x0CA8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _survivorRushToCarryAnimationName;                 // 0x0CB4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _survivorRushDropAnimationName;                    // 0x0CC0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _killerRushCooldownAnimationName;                  // 0x0CCC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _animTagFPV;                                       // 0x0CD8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lagInSecondsUntilRushIsInvalid;                   // 0x0CE4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rushDropForwardDistance;                          // 0x0CE8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _decisiveStrikeSkillCheckDelay;                    // 0x0CEC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isLagChecked;                                     // 0x0CF0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CF1[0x7];                                      // 0x0CF1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UInteractionDefinition>> _survivorInteractionPreventingGrab;            // 0x0CF8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_D08[0x238];                                    // 0x0D08(0x0238)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BounceComplete();
	void Cosmetic_DamageSurvivorAsCollision(class ACamperPlayer* survivor, const ECamperDamageState survivorTargetDamageState);
	void Cosmetic_HideEndIndicator();
	void Cosmetic_OnChargeEnd();
	void Cosmetic_OnChargeStart();
	void Cosmetic_OnRushEnd();
	void Cosmetic_OnRushPhaseChanged(EK29RushPhase previousPhase, EK29RushPhase newPhase);
	void Cosmetic_OnRushStart();
	void Cosmetic_OnSlashAtSurvivor(class ACamperPlayer* survivor, const ECamperDamageState survivorTargetDamageState);
	void Cosmetic_ShowEndIndicator(const struct FVector& endIndicatorLocation, const struct FRotator& forwardRotation);
	void Multicast_CancelInteraction();
	void Multicast_CarrySurvivor(class ACamperPlayer* survivorToCarry);
	void Multicast_ChangeRushPhase(const EK29RushPhase newRushPhase, const bool forceLocallyControlled);
	void Multicast_DamageSurvivorAsCollision(const struct FVector& currentKillerPosition, class ACamperPlayer* collidedSurvivor, const ECamperDamageState survivorTargetDamageState);
	void Multicast_DestroyPalletOrBreakable(class AActor* destroyable);
	void Multicast_RushInvalid();
	void Multicast_RushValid();
	void Multicast_SetCurrentRush(const struct FK29GuidedMovementInstance& newRushInstance);
	void Multicast_SetCurrentRushAsEndingAtLedge();
	void Multicast_SetCurrentRushAsEndingInCollision();
	void Multicast_SlashAtSurvivor(class ACamperPlayer* survivor, const struct FVector& currentKillerPosition, const ECamperDamageState survivorTargetDamageState);
	void Multicast_SmashSurvivor(class ACamperPlayer* survivorToCarry);
	void OnCollisionEnableTimerComplete();
	void OnGrabbingTransitionComplete();
	void OnInstantCarryTimerComplete(class ACamperPlayer* survivorToCarry);
	void OnSmashOutTimerCompleted();
	void OnSubsequentRushOpportunityTimeout();
	void RushComplete(const bool rushEndedNaturally);
	void Server_CancelInteraction();
	void Server_ChangeRushPhase(const EK29RushPhase newRushPhase, const bool forceLocallyControlled);
	void Server_DamageSurvivorAsCollision(class ACamperPlayer* survivor, const struct FVector& currentKillerPosition);
	void Server_DestroyPalletOrBreakable(class AActor* destroyable);
	void Server_SetCurrentRush(const struct FK29GuidedMovementInstance& newRushInstance, const EK29RushPhase targetPhase);
	void Server_SetCurrentRushAsEndingAtLedge();
	void Server_SetCurrentRushAsEndingInCollision(bool hitOtherSurvivor);
	void Server_SlashAtSurvivor(class ACamperPlayer* survivor, const struct FVector& currentKillerPosition);

	float GetRushTimeLeft() const;
	void OnWindowOfOpportunityTimeoutCooldownEnd() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29RushChargeableInteraction">();
	}
	static class UK29RushChargeableInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29RushChargeableInteraction>();
	}
};
static_assert(alignof(UK29RushChargeableInteraction) == 0x000010, "Wrong alignment on UK29RushChargeableInteraction");
static_assert(sizeof(UK29RushChargeableInteraction) == 0x000F40, "Wrong size on UK29RushChargeableInteraction");
static_assert(offsetof(UK29RushChargeableInteraction, _rushChargesHandlerComponent) == 0x000750, "Member 'UK29RushChargeableInteraction::_rushChargesHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _powerStatusHandlerComponent) == 0x000758, "Member 'UK29RushChargeableInteraction::_powerStatusHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _pathingCalculatorComponent) == 0x000760, "Member 'UK29RushChargeableInteraction::_pathingCalculatorComponent' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _powerCollectable) == 0x000768, "Member 'UK29RushChargeableInteraction::_powerCollectable' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _movementSpeedSettingsByState) == 0x000770, "Member 'UK29RushChargeableInteraction::_movementSpeedSettingsByState' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _subsequentRushTimerTimeoutMovementSpeedMultiplierCurve) == 0x0007C0, "Member 'UK29RushChargeableInteraction::_subsequentRushTimerTimeoutMovementSpeedMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _subsequentRushTimerTimeoutMovementSpeedReductionDuration) == 0x0007C8, "Member 'UK29RushChargeableInteraction::_subsequentRushTimerTimeoutMovementSpeedReductionDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _subsequentRushOpportunityTimerDuration) == 0x000848, "Member 'UK29RushChargeableInteraction::_subsequentRushOpportunityTimerDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushDuration) == 0x0008C8, "Member 'UK29RushChargeableInteraction::_rushDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushDurationAfterFirst) == 0x000948, "Member 'UK29RushChargeableInteraction::_rushDurationAfterFirst' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _capsuleRadius) == 0x0009C8, "Member 'UK29RushChargeableInteraction::_capsuleRadius' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _survivorRevealTimeOnInstantPickup) == 0x0009F0, "Member 'UK29RushChargeableInteraction::_survivorRevealTimeOnInstantPickup' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _capsuleHeight) == 0x000A18, "Member 'UK29RushChargeableInteraction::_capsuleHeight' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _capsuleHeightOffset) == 0x000A40, "Member 'UK29RushChargeableInteraction::_capsuleHeightOffset' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _bounceDuration) == 0x000A68, "Member 'UK29RushChargeableInteraction::_bounceDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushAccelerationMultiplier) == 0x000A90, "Member 'UK29RushChargeableInteraction::_rushAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _instantCarryAnimationDuration) == 0x000AB8, "Member 'UK29RushChargeableInteraction::_instantCarryAnimationDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _percentageForRushChargeEndAvailability) == 0x000AE0, "Member 'UK29RushChargeableInteraction::_percentageForRushChargeEndAvailability' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _distanceInCmForNearMiss) == 0x000AE4, "Member 'UK29RushChargeableInteraction::_distanceInCmForNearMiss' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushDetectionBackwardsOffset) == 0x000AE8, "Member 'UK29RushChargeableInteraction::_rushDetectionBackwardsOffset' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _revealToSurvivorsStatusEffect) == 0x000AF0, "Member 'UK29RushChargeableInteraction::_revealToSurvivorsStatusEffect' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushMovementSpeedInCmPerSecond) == 0x000AF8, "Member 'UK29RushChargeableInteraction::_rushMovementSpeedInCmPerSecond' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushGrabMovementSpeedInCmPerSecond) == 0x000B20, "Member 'UK29RushChargeableInteraction::_rushGrabMovementSpeedInCmPerSecond' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _grabRushDuration) == 0x000B48, "Member 'UK29RushChargeableInteraction::_grabRushDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rotationStrengthTransitionTime) == 0x000BC8, "Member 'UK29RushChargeableInteraction::_rotationStrengthTransitionTime' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _minimumRushDistance) == 0x000BD0, "Member 'UK29RushChargeableInteraction::_minimumRushDistance' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _intoGrabbingTime) == 0x000BF8, "Member 'UK29RushChargeableInteraction::_intoGrabbingTime' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _smashOutTimerDuration) == 0x000C20, "Member 'UK29RushChargeableInteraction::_smashOutTimerDuration' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _isStoppingMomentumAtIntoGrabbing) == 0x000C48, "Member 'UK29RushChargeableInteraction::_isStoppingMomentumAtIntoGrabbing' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _movementSpeedCurveBetweenRushesIncreased) == 0x000C70, "Member 'UK29RushChargeableInteraction::_movementSpeedCurveBetweenRushesIncreased' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _movementSpeedCurveChargingIncreased) == 0x000C78, "Member 'UK29RushChargeableInteraction::_movementSpeedCurveChargingIncreased' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushMovementSpeedCurve) == 0x000C80, "Member 'UK29RushChargeableInteraction::_rushMovementSpeedCurve' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushMovementSpeedCurveWithSurvivor) == 0x000C88, "Member 'UK29RushChargeableInteraction::_rushMovementSpeedCurveWithSurvivor' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _killerRushSmashAnimationName) == 0x000C90, "Member 'UK29RushChargeableInteraction::_killerRushSmashAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _survivorRushSmashAnimationName) == 0x000C9C, "Member 'UK29RushChargeableInteraction::_survivorRushSmashAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _killerRushToCarryAnimationName) == 0x000CA8, "Member 'UK29RushChargeableInteraction::_killerRushToCarryAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _survivorRushToCarryAnimationName) == 0x000CB4, "Member 'UK29RushChargeableInteraction::_survivorRushToCarryAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _survivorRushDropAnimationName) == 0x000CC0, "Member 'UK29RushChargeableInteraction::_survivorRushDropAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _killerRushCooldownAnimationName) == 0x000CCC, "Member 'UK29RushChargeableInteraction::_killerRushCooldownAnimationName' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _animTagFPV) == 0x000CD8, "Member 'UK29RushChargeableInteraction::_animTagFPV' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _lagInSecondsUntilRushIsInvalid) == 0x000CE4, "Member 'UK29RushChargeableInteraction::_lagInSecondsUntilRushIsInvalid' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _rushDropForwardDistance) == 0x000CE8, "Member 'UK29RushChargeableInteraction::_rushDropForwardDistance' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _decisiveStrikeSkillCheckDelay) == 0x000CEC, "Member 'UK29RushChargeableInteraction::_decisiveStrikeSkillCheckDelay' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _isLagChecked) == 0x000CF0, "Member 'UK29RushChargeableInteraction::_isLagChecked' has a wrong offset!");
static_assert(offsetof(UK29RushChargeableInteraction, _survivorInteractionPreventingGrab) == 0x000CF8, "Member 'UK29RushChargeableInteraction::_survivorInteractionPreventingGrab' has a wrong offset!");

// Class TheK29.K29RushChargesHandlerComponent
// 0x0170 (0x0228 - 0x00B8)
class UK29RushChargesHandlerComponent final : public UActorComponent
{
public:
	struct FTunableStat                           _maximumRushCharges;                               // 0x00B8(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _rechargeTimeByChargesLeft;                        // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _rechargeDurationMultiplier;                       // 0x0140(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _reducedChargeTimePerInfectionPlayers;             // 0x01C0(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E8[0x40];                                     // 0x01E8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSingleCharge();
	void Cosmetic_OnOutOfRushCharges();
	void Cosmetic_OnRushChargeAdded();
	void OnKillerSet(class ASlasherPlayer* killer);
	void OnMaximumChargesChanged(const float newValue);
	void SetToFullCharge();

	int32 GetAvailableCharges() const;
	int32 GetMaximumCharges() const;
	float GetPercentageRemainingUntilNextCharge() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29RushChargesHandlerComponent">();
	}
	static class UK29RushChargesHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29RushChargesHandlerComponent>();
	}
};
static_assert(alignof(UK29RushChargesHandlerComponent) == 0x000008, "Wrong alignment on UK29RushChargesHandlerComponent");
static_assert(sizeof(UK29RushChargesHandlerComponent) == 0x000228, "Wrong size on UK29RushChargesHandlerComponent");
static_assert(offsetof(UK29RushChargesHandlerComponent, _maximumRushCharges) == 0x0000B8, "Member 'UK29RushChargesHandlerComponent::_maximumRushCharges' has a wrong offset!");
static_assert(offsetof(UK29RushChargesHandlerComponent, _rechargeTimeByChargesLeft) == 0x000138, "Member 'UK29RushChargesHandlerComponent::_rechargeTimeByChargesLeft' has a wrong offset!");
static_assert(offsetof(UK29RushChargesHandlerComponent, _rechargeDurationMultiplier) == 0x000140, "Member 'UK29RushChargesHandlerComponent::_rechargeDurationMultiplier' has a wrong offset!");
static_assert(offsetof(UK29RushChargesHandlerComponent, _reducedChargeTimePerInfectionPlayers) == 0x0001C0, "Member 'UK29RushChargesHandlerComponent::_reducedChargeTimePerInfectionPlayers' has a wrong offset!");

// Class TheK29.K29RushCooldownInteraction
// 0x00E0 (0x0700 - 0x0620)
class UK29RushCooldownInteraction final : public UInteractionDefinition
{
public:
	struct FTunableStat                           _cooldownTime;                                     // 0x0618(0x0080)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCameraRestrictedForDuration;                    // 0x0698(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_699[0x7];                                      // 0x0699(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _cameraRestrictionTime;                            // 0x06A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C8[0x38];                                     // 0x06C8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetCameraInputLimit();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29RushCooldownInteraction">();
	}
	static class UK29RushCooldownInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29RushCooldownInteraction>();
	}
};
static_assert(alignof(UK29RushCooldownInteraction) == 0x000010, "Wrong alignment on UK29RushCooldownInteraction");
static_assert(sizeof(UK29RushCooldownInteraction) == 0x000700, "Wrong size on UK29RushCooldownInteraction");
static_assert(offsetof(UK29RushCooldownInteraction, _cooldownTime) == 0x000618, "Member 'UK29RushCooldownInteraction::_cooldownTime' has a wrong offset!");
static_assert(offsetof(UK29RushCooldownInteraction, _isCameraRestrictedForDuration) == 0x000698, "Member 'UK29RushCooldownInteraction::_isCameraRestrictedForDuration' has a wrong offset!");
static_assert(offsetof(UK29RushCooldownInteraction, _cameraRestrictionTime) == 0x0006A0, "Member 'UK29RushCooldownInteraction::_cameraRestrictionTime' has a wrong offset!");

// Class TheK29.K29SurvivorAnimInstance
// 0x0060 (0x05B0 - 0x0550)
class UK29SurvivorAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isBeingGrabbed;                                   // 0x0550(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingThrown;                                    // 0x0551(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isKillerLocallyControlled;                        // 0x0552(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingInfectionRemoverOnSelf;                    // 0x0553(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingInfectionRemoverOnOther;                   // 0x0554(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInfectionRemoverUsedOnSelf;                     // 0x0555(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasLastThrowResultedInDamage;                     // 0x0556(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInfectionActive;                                // 0x0557(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasBeenThrown;                                    // 0x0558(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCoughing;                                       // 0x0559(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55A[0x2];                                      // 0x055A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeBetweenRandomCoughingTry;                     // 0x055C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _randomCoughMinProbabilityRange;                   // 0x0560(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _randomCoughMaxProbabilityRange;                   // 0x0564(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _randomCoughProbabilityThreshold;                  // 0x0568(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x056C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInsideCloset;                                   // 0x056D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDead;                                           // 0x056E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInteracting;                                    // 0x056F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInjured;                                        // 0x0570(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingObject;                                  // 0x0571(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x0572(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHooked;                                         // 0x0573(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x0574(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingAimItem;                                   // 0x0575(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInAir;                                          // 0x0576(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingHealed;                                    // 0x0577(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_578[0x38];                                     // 0x0578(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameEventReceived(const struct FGameplayTag& gameplayTag, const struct FGameEventData& gameEventData);
	void OnHasBeenThrown();
	void ResetHasBeenThrown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SurvivorAnimInstance">();
	}
	static class UK29SurvivorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29SurvivorAnimInstance>();
	}
};
static_assert(alignof(UK29SurvivorAnimInstance) == 0x000010, "Wrong alignment on UK29SurvivorAnimInstance");
static_assert(sizeof(UK29SurvivorAnimInstance) == 0x0005B0, "Wrong size on UK29SurvivorAnimInstance");
static_assert(offsetof(UK29SurvivorAnimInstance, _isBeingGrabbed) == 0x000550, "Member 'UK29SurvivorAnimInstance::_isBeingGrabbed' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isBeingThrown) == 0x000551, "Member 'UK29SurvivorAnimInstance::_isBeingThrown' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isKillerLocallyControlled) == 0x000552, "Member 'UK29SurvivorAnimInstance::_isKillerLocallyControlled' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isUsingInfectionRemoverOnSelf) == 0x000553, "Member 'UK29SurvivorAnimInstance::_isUsingInfectionRemoverOnSelf' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isUsingInfectionRemoverOnOther) == 0x000554, "Member 'UK29SurvivorAnimInstance::_isUsingInfectionRemoverOnOther' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInfectionRemoverUsedOnSelf) == 0x000555, "Member 'UK29SurvivorAnimInstance::_isInfectionRemoverUsedOnSelf' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _hasLastThrowResultedInDamage) == 0x000556, "Member 'UK29SurvivorAnimInstance::_hasLastThrowResultedInDamage' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInfectionActive) == 0x000557, "Member 'UK29SurvivorAnimInstance::_isInfectionActive' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _hasBeenThrown) == 0x000558, "Member 'UK29SurvivorAnimInstance::_hasBeenThrown' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isCoughing) == 0x000559, "Member 'UK29SurvivorAnimInstance::_isCoughing' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _timeBetweenRandomCoughingTry) == 0x00055C, "Member 'UK29SurvivorAnimInstance::_timeBetweenRandomCoughingTry' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _randomCoughMinProbabilityRange) == 0x000560, "Member 'UK29SurvivorAnimInstance::_randomCoughMinProbabilityRange' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _randomCoughMaxProbabilityRange) == 0x000564, "Member 'UK29SurvivorAnimInstance::_randomCoughMaxProbabilityRange' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _randomCoughProbabilityThreshold) == 0x000568, "Member 'UK29SurvivorAnimInstance::_randomCoughProbabilityThreshold' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isCrawling) == 0x00056C, "Member 'UK29SurvivorAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInsideCloset) == 0x00056D, "Member 'UK29SurvivorAnimInstance::_isInsideCloset' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isDead) == 0x00056E, "Member 'UK29SurvivorAnimInstance::_isDead' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInteracting) == 0x00056F, "Member 'UK29SurvivorAnimInstance::_isInteracting' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInjured) == 0x000570, "Member 'UK29SurvivorAnimInstance::_isInjured' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isHoldingObject) == 0x000571, "Member 'UK29SurvivorAnimInstance::_isHoldingObject' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isCrouched) == 0x000572, "Member 'UK29SurvivorAnimInstance::_isCrouched' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isHooked) == 0x000573, "Member 'UK29SurvivorAnimInstance::_isHooked' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isIdle) == 0x000574, "Member 'UK29SurvivorAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isUsingAimItem) == 0x000575, "Member 'UK29SurvivorAnimInstance::_isUsingAimItem' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isInAir) == 0x000576, "Member 'UK29SurvivorAnimInstance::_isInAir' has a wrong offset!");
static_assert(offsetof(UK29SurvivorAnimInstance, _isBeingHealed) == 0x000577, "Member 'UK29SurvivorAnimInstance::_isBeingHealed' has a wrong offset!");

// Class TheK29.K29SurvivorCarriableComponent
// 0x0078 (0x0130 - 0x00B8)
class UK29SurvivorCarriableComponent final : public UActorComponent
{
public:
	class FName                                   _rootJointName;                                    // 0x00B8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               _startingRotation;                                 // 0x00C4(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                _startingPosition;                                 // 0x00D0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isCarriedByK29Rush;                               // 0x00DC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _killerIngoreTime;                                 // 0x00E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ACamperPlayer>           _owningSurvivor;                                   // 0x00E4(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC[0x44];                                      // 0x00EC(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableCollision();
	bool IsBeingCarriedByK29RushOrMarkedForThrow();
	void OnKillerSet(class ASlasherPlayer* killer);
	void OnRep_OwningSurvivor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SurvivorCarriableComponent">();
	}
	static class UK29SurvivorCarriableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29SurvivorCarriableComponent>();
	}
};
static_assert(alignof(UK29SurvivorCarriableComponent) == 0x000008, "Wrong alignment on UK29SurvivorCarriableComponent");
static_assert(sizeof(UK29SurvivorCarriableComponent) == 0x000130, "Wrong size on UK29SurvivorCarriableComponent");
static_assert(offsetof(UK29SurvivorCarriableComponent, _rootJointName) == 0x0000B8, "Member 'UK29SurvivorCarriableComponent::_rootJointName' has a wrong offset!");
static_assert(offsetof(UK29SurvivorCarriableComponent, _startingRotation) == 0x0000C4, "Member 'UK29SurvivorCarriableComponent::_startingRotation' has a wrong offset!");
static_assert(offsetof(UK29SurvivorCarriableComponent, _startingPosition) == 0x0000D0, "Member 'UK29SurvivorCarriableComponent::_startingPosition' has a wrong offset!");
static_assert(offsetof(UK29SurvivorCarriableComponent, _isCarriedByK29Rush) == 0x0000DC, "Member 'UK29SurvivorCarriableComponent::_isCarriedByK29Rush' has a wrong offset!");
static_assert(offsetof(UK29SurvivorCarriableComponent, _killerIngoreTime) == 0x0000E0, "Member 'UK29SurvivorCarriableComponent::_killerIngoreTime' has a wrong offset!");
static_assert(offsetof(UK29SurvivorCarriableComponent, _owningSurvivor) == 0x0000E4, "Member 'UK29SurvivorCarriableComponent::_owningSurvivor' has a wrong offset!");

// Class TheK29.K29SurvivorCosmeticHelperActor
// 0x00C8 (0x0330 - 0x0268)
class AK29SurvivorCosmeticHelperActor final : public ASurvivorCosmeticHelperActor
{
public:
	uint8                                         Pad_268[0xC8];                                     // 0x0268(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_GrabbedByKiller();
	void Cosmetic_IsInfectedActiveChanged(const bool isInfectionActive);
	void Cosmetic_IsInfectedChanged(const bool isInfected);
	void Cosmetic_IsInfectionCriticalChanged(const bool isInfectionCritical);
	void Cosmetic_IsInfectionIncubatedChanged(const bool isInfectionIncubated);
	void Cosmetic_OnInfectionLevelsChanged(const bool isActive);
	void Cosmetic_OnInfectionRemovalCollectableUsed();
	void Cosmetic_OnLocallyObservedChanged();
	void Cosmetic_OnOwningSurvivorDied();
	void Cosmetic_OnOwningSurvivorHitCollisionWithRush();
	void OnInfectionLevelsChanged(class ACamperPlayer* targetSurvivor, bool isActive);
	void OnInfectionRemovalCollectableUsed(class ACamperPlayer* survivor);
	void OnLevelReadyToPlay();
	void OnOwnerLocallyObserved(bool locallyObserved);
	void OnSurvivorGrabbed(class ACamperPlayer* survivor);

	int32 GetCurrentInfectionLevels() const;
	float GetCurrentInfectionPercentage() const;
	int32 GetMaximumInfectionLevels() const;
	bool IsInfected() const;
	bool IsInfectionActive() const;
	bool IsInfectionCritical() const;
	bool IsInfectionIncubated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SurvivorCosmeticHelperActor">();
	}
	static class AK29SurvivorCosmeticHelperActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK29SurvivorCosmeticHelperActor>();
	}
};
static_assert(alignof(AK29SurvivorCosmeticHelperActor) == 0x000008, "Wrong alignment on AK29SurvivorCosmeticHelperActor");
static_assert(sizeof(AK29SurvivorCosmeticHelperActor) == 0x000330, "Wrong size on AK29SurvivorCosmeticHelperActor");

// Class TheK29.K29SurvivorStatusComponent
// 0x0018 (0x00D0 - 0x00B8)
class UK29SurvivorStatusComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UK29PowerStatusHandlerComponent> _powerStatusHandlerComponent;              // 0x00C0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ACamperPlayer>           _owningSurvivor;                                   // 0x00C8(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SurvivorStatusComponent">();
	}
	static class UK29SurvivorStatusComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29SurvivorStatusComponent>();
	}
};
static_assert(alignof(UK29SurvivorStatusComponent) == 0x000008, "Wrong alignment on UK29SurvivorStatusComponent");
static_assert(sizeof(UK29SurvivorStatusComponent) == 0x0000D0, "Wrong size on UK29SurvivorStatusComponent");
static_assert(offsetof(UK29SurvivorStatusComponent, _powerStatusHandlerComponent) == 0x0000C0, "Member 'UK29SurvivorStatusComponent::_powerStatusHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK29SurvivorStatusComponent, _owningSurvivor) == 0x0000C8, "Member 'UK29SurvivorStatusComponent::_owningSurvivor' has a wrong offset!");

// Class TheK29.K29SurvivorThrowableComponent
// 0x0318 (0x03D0 - 0x00B8)
class UK29SurvivorThrowableComponent final : public UActorComponent
{
public:
	struct FTunableStat                           _throwDuration;                                    // 0x00B8(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleRadius;                                    // 0x0138(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleHeight;                                    // 0x0160(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _capsuleHeightOffset;                              // 0x0188(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _minimumThrowDistance;                             // 0x01B0(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _throwMovementSpeedInCmPerSecond;                  // 0x01D8(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _movingDelay;                                      // 0x0200(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _throwDelay;                                       // 0x0228(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _throwLedgeDropDistance;                           // 0x0250(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _throwLedgeDropTime;                               // 0x0278(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _throwMovementSpeedMultiplierCurve;                // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _throwAccelerationMultiplier;                      // 0x02A8(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D0[0x100];                                    // 0x02D0(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnSurvivorUsedAsCollision(class ACamperPlayer* survivor);
	void EndThrow();
	void Multicast_CancelThrowOnOtherSurvivorCollision(const struct FVector& collisionPosition, class ACamperPlayer* survivorUsedAsCollision);
	void Multicast_EndThrow();
	void Multicast_InstantlyLetGoSurvivor(const bool hasDealtDamage);
	void Multicast_SetCurrentThrow(const struct FK29GuidedMovementInstance& throwInstance, class ACamperPlayer* thrownSurvivor);
	void OnThrowTimeout();
	void OnWalkingAllowedAfterFall();
	void Server_CancelThrowOnOtherSurvivorCollision(const struct FVector& collisionPosition, class ACamperPlayer* survivorUsedAsCollision);
	void Server_EndThrow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29SurvivorThrowableComponent">();
	}
	static class UK29SurvivorThrowableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29SurvivorThrowableComponent>();
	}
};
static_assert(alignof(UK29SurvivorThrowableComponent) == 0x000008, "Wrong alignment on UK29SurvivorThrowableComponent");
static_assert(sizeof(UK29SurvivorThrowableComponent) == 0x0003D0, "Wrong size on UK29SurvivorThrowableComponent");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwDuration) == 0x0000B8, "Member 'UK29SurvivorThrowableComponent::_throwDuration' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _capsuleRadius) == 0x000138, "Member 'UK29SurvivorThrowableComponent::_capsuleRadius' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _capsuleHeight) == 0x000160, "Member 'UK29SurvivorThrowableComponent::_capsuleHeight' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _capsuleHeightOffset) == 0x000188, "Member 'UK29SurvivorThrowableComponent::_capsuleHeightOffset' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _minimumThrowDistance) == 0x0001B0, "Member 'UK29SurvivorThrowableComponent::_minimumThrowDistance' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwMovementSpeedInCmPerSecond) == 0x0001D8, "Member 'UK29SurvivorThrowableComponent::_throwMovementSpeedInCmPerSecond' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _movingDelay) == 0x000200, "Member 'UK29SurvivorThrowableComponent::_movingDelay' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwDelay) == 0x000228, "Member 'UK29SurvivorThrowableComponent::_throwDelay' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwLedgeDropDistance) == 0x000250, "Member 'UK29SurvivorThrowableComponent::_throwLedgeDropDistance' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwLedgeDropTime) == 0x000278, "Member 'UK29SurvivorThrowableComponent::_throwLedgeDropTime' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwMovementSpeedMultiplierCurve) == 0x0002A0, "Member 'UK29SurvivorThrowableComponent::_throwMovementSpeedMultiplierCurve' has a wrong offset!");
static_assert(offsetof(UK29SurvivorThrowableComponent, _throwAccelerationMultiplier) == 0x0002A8, "Member 'UK29SurvivorThrowableComponent::_throwAccelerationMultiplier' has a wrong offset!");

// Class TheK29.K29UseInfectionRemoverInteraction
// 0x0040 (0x0780 - 0x0740)
#pragma pack(push, 0x1)
class alignas(0x10) UK29UseInfectionRemoverInteraction : public UChargeableInteractionDefinition
{
public:
	TSubclassOf<class UStatusEffect>              _killerInstinctClass;                              // 0x0740(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _killerInstinctDuration;                           // 0x0748(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_770[0x8];                                      // 0x0770(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSurvivorCured_Cosmetic();

	class ACamperPlayer* GetInteractionTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29UseInfectionRemoverInteraction">();
	}
	static class UK29UseInfectionRemoverInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29UseInfectionRemoverInteraction>();
	}
};
#pragma pack(pop)
static_assert(alignof(UK29UseInfectionRemoverInteraction) == 0x000010, "Wrong alignment on UK29UseInfectionRemoverInteraction");
static_assert(sizeof(UK29UseInfectionRemoverInteraction) == 0x000780, "Wrong size on UK29UseInfectionRemoverInteraction");
static_assert(offsetof(UK29UseInfectionRemoverInteraction, _killerInstinctClass) == 0x000740, "Member 'UK29UseInfectionRemoverInteraction::_killerInstinctClass' has a wrong offset!");
static_assert(offsetof(UK29UseInfectionRemoverInteraction, _killerInstinctDuration) == 0x000748, "Member 'UK29UseInfectionRemoverInteraction::_killerInstinctDuration' has a wrong offset!");

// Class TheK29.K29UseInfectionRemoverInteractionOther
// 0x0010 (0x0790 - 0x0780)
class UK29UseInfectionRemoverInteractionOther final : public UK29UseInfectionRemoverInteraction
{
public:
	TSubclassOf<class UStatusEffect>              _crouchBlockStatusEffectClass;                     // 0x0778(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_780[0x8];                                      // 0x0780(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _crouchBlockStatusEffect;                          // 0x0788(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29UseInfectionRemoverInteractionOther">();
	}
	static class UK29UseInfectionRemoverInteractionOther* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29UseInfectionRemoverInteractionOther>();
	}
};
static_assert(alignof(UK29UseInfectionRemoverInteractionOther) == 0x000010, "Wrong alignment on UK29UseInfectionRemoverInteractionOther");
static_assert(sizeof(UK29UseInfectionRemoverInteractionOther) == 0x000790, "Wrong size on UK29UseInfectionRemoverInteractionOther");
static_assert(offsetof(UK29UseInfectionRemoverInteractionOther, _crouchBlockStatusEffectClass) == 0x000778, "Member 'UK29UseInfectionRemoverInteractionOther::_crouchBlockStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UK29UseInfectionRemoverInteractionOther, _crouchBlockStatusEffect) == 0x000788, "Member 'UK29UseInfectionRemoverInteractionOther::_crouchBlockStatusEffect' has a wrong offset!");

// Class TheK29.K29UseInfectionRemoverInteractionSelf
// 0x0000 (0x0780 - 0x0780)
class UK29UseInfectionRemoverInteractionSelf final : public UK29UseInfectionRemoverInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29UseInfectionRemoverInteractionSelf">();
	}
	static class UK29UseInfectionRemoverInteractionSelf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29UseInfectionRemoverInteractionSelf>();
	}
};
static_assert(alignof(UK29UseInfectionRemoverInteractionSelf) == 0x000010, "Wrong alignment on UK29UseInfectionRemoverInteractionSelf");
static_assert(sizeof(UK29UseInfectionRemoverInteractionSelf) == 0x000780, "Wrong size on UK29UseInfectionRemoverInteractionSelf");

// Class TheK29.K29Utilities
// 0x0000 (0x0030 - 0x0030)
class UK29Utilities final : public UBlueprintFunctionLibrary
{
public:
	static class AK29Power* GetK29Power(const class UObject* worldContextObject);
	static bool IsSurvivorAbleToBeAffectedByPower(const class AActor* survivorAsActor, const class ASlasherPlayer* killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K29Utilities">();
	}
	static class UK29Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK29Utilities>();
	}
};
static_assert(alignof(UK29Utilities) == 0x000008, "Wrong alignment on UK29Utilities");
static_assert(sizeof(UK29Utilities) == 0x000030, "Wrong size on UK29Utilities");

// Class TheK29.ReassuranceCondition
// 0x0050 (0x0230 - 0x01E0)
class UReassuranceCondition final : public UIsInRangeOfHookedSurvivor
{
public:
	uint8                                         Pad_1E0[0x50];                                     // 0x01E0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReassuranceCondition">();
	}
	static class UReassuranceCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReassuranceCondition>();
	}
};
static_assert(alignof(UReassuranceCondition) == 0x000008, "Wrong alignment on UReassuranceCondition");
static_assert(sizeof(UReassuranceCondition) == 0x000230, "Wrong size on UReassuranceCondition");

// Class TheK29.S32P01
// 0x0040 (0x04F8 - 0x04B8)
class US32P01 final : public UGeneratorTrapPerk
{
public:
	float                                         _generatorRevealRange;                             // 0x04B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _revealEffect;                                     // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _revealStatus;                                     // 0x04C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isKillerInRange;                                  // 0x04D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D1[0x27];                                     // 0x04D1(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsKillerInRange();

	float GetGeneratorRevealRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S32P01">();
	}
	static class US32P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<US32P01>();
	}
};
static_assert(alignof(US32P01) == 0x000008, "Wrong alignment on US32P01");
static_assert(sizeof(US32P01) == 0x0004F8, "Wrong size on US32P01");
static_assert(offsetof(US32P01, _generatorRevealRange) == 0x0004B8, "Member 'US32P01::_generatorRevealRange' has a wrong offset!");
static_assert(offsetof(US32P01, _revealEffect) == 0x0004C0, "Member 'US32P01::_revealEffect' has a wrong offset!");
static_assert(offsetof(US32P01, _revealStatus) == 0x0004C8, "Member 'US32P01::_revealStatus' has a wrong offset!");
static_assert(offsetof(US32P01, _isKillerInRange) == 0x0004D0, "Member 'US32P01::_isKillerInRange' has a wrong offset!");

// Class TheK29.S32P02
// 0x0018 (0x03E0 - 0x03C8)
class US32P02 final : public UPerk
{
public:
	float                                         _hitDistanceToTriggerPerkEffect[0x3];              // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _healingProgressionIncreasedOnHit[0x3];            // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S32P02">();
	}
	static class US32P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<US32P02>();
	}
};
static_assert(alignof(US32P02) == 0x000008, "Wrong alignment on US32P02");
static_assert(sizeof(US32P02) == 0x0003E0, "Wrong size on US32P02");
static_assert(offsetof(US32P02, _hitDistanceToTriggerPerkEffect) == 0x0003C8, "Member 'US32P02::_hitDistanceToTriggerPerkEffect' has a wrong offset!");
static_assert(offsetof(US32P02, _healingProgressionIncreasedOnHit) == 0x0003D4, "Member 'US32P02::_healingProgressionIncreasedOnHit' has a wrong offset!");

// Class TheK29.S32P03
// 0x0018 (0x03E0 - 0x03C8)
class US32P03 final : public UPerk
{
public:
	float                                         _activationTime[0x3];                              // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0xC];                                      // 0x03D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetActivationTimeForLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S32P03">();
	}
	static class US32P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<US32P03>();
	}
};
static_assert(alignof(US32P03) == 0x000008, "Wrong alignment on US32P03");
static_assert(sizeof(US32P03) == 0x0003E0, "Wrong size on US32P03");
static_assert(offsetof(US32P03, _activationTime) == 0x0003C8, "Member 'US32P03::_activationTime' has a wrong offset!");

// Class TheK29.S33P01
// 0x0018 (0x03E0 - 0x03C8)
class US33P01 final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _S33P01StatusEffect;                               // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _interactionProgressionAmount[0x3];                // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S33P01">();
	}
	static class US33P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<US33P01>();
	}
};
static_assert(alignof(US33P01) == 0x000008, "Wrong alignment on US33P01");
static_assert(sizeof(US33P01) == 0x0003E0, "Wrong size on US33P01");
static_assert(offsetof(US33P01, _S33P01StatusEffect) == 0x0003C8, "Member 'US33P01::_S33P01StatusEffect' has a wrong offset!");
static_assert(offsetof(US33P01, _interactionProgressionAmount) == 0x0003D0, "Member 'US33P01::_interactionProgressionAmount' has a wrong offset!");

// Class TheK29.S33P01StatusEffect
// 0x0008 (0x0358 - 0x0350)
class US33P01StatusEffect final : public UStatusEffect
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S33P01StatusEffect">();
	}
	static class US33P01StatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<US33P01StatusEffect>();
	}
};
static_assert(alignof(US33P01StatusEffect) == 0x000008, "Wrong alignment on US33P01StatusEffect");
static_assert(sizeof(US33P01StatusEffect) == 0x000358, "Wrong size on US33P01StatusEffect");

// Class TheK29.S33P02
// 0x0038 (0x0400 - 0x03C8)
class US33P02 final : public UPerk
{
public:
	float                                         _distanceRadius;                                   // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _struggleProgressionPausedDuration[0x3];           // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _S33P02StatusEffect;                               // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACamperPlayer*>                  _reassuredSurvivors;                               // 0x03E0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x10];                                     // 0x03F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Local_EffectTriggered(const struct FTransform& location);
	void OnRep_ReassuredSurvivors();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S33P02">();
	}
	static class US33P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<US33P02>();
	}
};
static_assert(alignof(US33P02) == 0x000008, "Wrong alignment on US33P02");
static_assert(sizeof(US33P02) == 0x000400, "Wrong size on US33P02");
static_assert(offsetof(US33P02, _distanceRadius) == 0x0003C8, "Member 'US33P02::_distanceRadius' has a wrong offset!");
static_assert(offsetof(US33P02, _struggleProgressionPausedDuration) == 0x0003CC, "Member 'US33P02::_struggleProgressionPausedDuration' has a wrong offset!");
static_assert(offsetof(US33P02, _S33P02StatusEffect) == 0x0003D8, "Member 'US33P02::_S33P02StatusEffect' has a wrong offset!");
static_assert(offsetof(US33P02, _reassuredSurvivors) == 0x0003E0, "Member 'US33P02::_reassuredSurvivors' has a wrong offset!");

// Class TheK29.S33P02Interaction
// 0x0000 (0x0620 - 0x0620)
class US33P02Interaction final : public UInteractionDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S33P02Interaction">();
	}
	static class US33P02Interaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<US33P02Interaction>();
	}
};
static_assert(alignof(US33P02Interaction) == 0x000010, "Wrong alignment on US33P02Interaction");
static_assert(sizeof(US33P02Interaction) == 0x000620, "Wrong size on US33P02Interaction");

// Class TheK29.S33p02StatusEffect
// 0x0008 (0x0358 - 0x0350)
class US33p02StatusEffect final : public UStatusEffect
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S33p02StatusEffect">();
	}
	static class US33p02StatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<US33p02StatusEffect>();
	}
};
static_assert(alignof(US33p02StatusEffect) == 0x000008, "Wrong alignment on US33p02StatusEffect");
static_assert(sizeof(US33p02StatusEffect) == 0x000358, "Wrong size on US33p02StatusEffect");

// Class TheK29.S33P03
// 0x0038 (0x0400 - 0x03C8)
class US33P03 final : public UPerk
{
public:
	float                                         _skillCheckTriggerPercentPerToken;                 // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _skillCheckCursorSpeedPerToken;                    // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _skillCheckBonusPercentPerToken[0x3];              // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DC[0x24];                                     // 0x03DC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetSkillCheckBonusPercentPerTokenAtLevel();
	float GetSkillCheckCursorSpeedPerToken();
	float GetSkillCheckTriggerPercentPerToken();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S33P03">();
	}
	static class US33P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<US33P03>();
	}
};
static_assert(alignof(US33P03) == 0x000008, "Wrong alignment on US33P03");
static_assert(sizeof(US33P03) == 0x000400, "Wrong size on US33P03");
static_assert(offsetof(US33P03, _skillCheckTriggerPercentPerToken) == 0x0003C8, "Member 'US33P03::_skillCheckTriggerPercentPerToken' has a wrong offset!");
static_assert(offsetof(US33P03, _skillCheckCursorSpeedPerToken) == 0x0003CC, "Member 'US33P03::_skillCheckCursorSpeedPerToken' has a wrong offset!");
static_assert(offsetof(US33P03, _skillCheckBonusPercentPerToken) == 0x0003D0, "Member 'US33P03::_skillCheckBonusPercentPerToken' has a wrong offset!");

}

