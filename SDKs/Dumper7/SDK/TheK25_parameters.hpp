#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK25

#include "Basic.hpp"

#include "DeadByDaylight_structs.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "TheK25_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Projectile_structs.hpp"


namespace SDK::Params
{

// Function TheK25.LamentConfiguration.Authority_OnEndGameOver
// 0x0038 (0x0038 - 0x0000)
struct LamentConfiguration_Authority_OnEndGameOver final
{
public:
	struct FGameplayTag                           gameEventType;                                     // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         gameEventData;                                     // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Authority_OnEndGameOver) == 0x000008, "Wrong alignment on LamentConfiguration_Authority_OnEndGameOver");
static_assert(sizeof(LamentConfiguration_Authority_OnEndGameOver) == 0x000038, "Wrong size on LamentConfiguration_Authority_OnEndGameOver");
static_assert(offsetof(LamentConfiguration_Authority_OnEndGameOver, gameEventType) == 0x000000, "Member 'LamentConfiguration_Authority_OnEndGameOver::gameEventType' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnEndGameOver, gameEventData) == 0x000010, "Member 'LamentConfiguration_Authority_OnEndGameOver::gameEventData' has a wrong offset!");

// Function TheK25.LamentConfiguration.Authority_OnGameEnded
// 0x0038 (0x0038 - 0x0000)
struct LamentConfiguration_Authority_OnGameEnded final
{
public:
	struct FGameplayTag                           gameEventType;                                     // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         gameEventData;                                     // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Authority_OnGameEnded) == 0x000008, "Wrong alignment on LamentConfiguration_Authority_OnGameEnded");
static_assert(sizeof(LamentConfiguration_Authority_OnGameEnded) == 0x000038, "Wrong size on LamentConfiguration_Authority_OnGameEnded");
static_assert(offsetof(LamentConfiguration_Authority_OnGameEnded, gameEventType) == 0x000000, "Member 'LamentConfiguration_Authority_OnGameEnded::gameEventType' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnGameEnded, gameEventData) == 0x000010, "Member 'LamentConfiguration_Authority_OnGameEnded::gameEventData' has a wrong offset!");

// Function TheK25.LamentConfiguration.Authority_OnOverlapBegin
// 0x00B0 (0x00B0 - 0x0000)
struct LamentConfiguration_Authority_OnOverlapBegin final
{
public:
	class UPrimitiveComponent*                    overlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    otherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         otherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             sweepResult;                                       // 0x0020(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Authority_OnOverlapBegin) == 0x000008, "Wrong alignment on LamentConfiguration_Authority_OnOverlapBegin");
static_assert(sizeof(LamentConfiguration_Authority_OnOverlapBegin) == 0x0000B0, "Wrong size on LamentConfiguration_Authority_OnOverlapBegin");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapBegin, overlappedComponent) == 0x000000, "Member 'LamentConfiguration_Authority_OnOverlapBegin::overlappedComponent' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapBegin, other) == 0x000008, "Member 'LamentConfiguration_Authority_OnOverlapBegin::other' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapBegin, otherComp) == 0x000010, "Member 'LamentConfiguration_Authority_OnOverlapBegin::otherComp' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapBegin, otherBodyIndex) == 0x000018, "Member 'LamentConfiguration_Authority_OnOverlapBegin::otherBodyIndex' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapBegin, bFromSweep) == 0x00001C, "Member 'LamentConfiguration_Authority_OnOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapBegin, sweepResult) == 0x000020, "Member 'LamentConfiguration_Authority_OnOverlapBegin::sweepResult' has a wrong offset!");

// Function TheK25.LamentConfiguration.Authority_OnOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct LamentConfiguration_Authority_OnOverlapEnd final
{
public:
	class UPrimitiveComponent*                    overlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 otherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    otherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         otherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LamentConfiguration_Authority_OnOverlapEnd) == 0x000008, "Wrong alignment on LamentConfiguration_Authority_OnOverlapEnd");
static_assert(sizeof(LamentConfiguration_Authority_OnOverlapEnd) == 0x000020, "Wrong size on LamentConfiguration_Authority_OnOverlapEnd");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapEnd, overlappedComponent) == 0x000000, "Member 'LamentConfiguration_Authority_OnOverlapEnd::overlappedComponent' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapEnd, otherActor) == 0x000008, "Member 'LamentConfiguration_Authority_OnOverlapEnd::otherActor' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapEnd, otherComp) == 0x000010, "Member 'LamentConfiguration_Authority_OnOverlapEnd::otherComp' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnOverlapEnd, otherBodyIndex) == 0x000018, "Member 'LamentConfiguration_Authority_OnOverlapEnd::otherBodyIndex' has a wrong offset!");

// Function TheK25.LamentConfiguration.Authority_OnSurvivorHitByControlledProjectile
// 0x0038 (0x0038 - 0x0000)
struct LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile final
{
public:
	struct FGameplayTag                           gameEventType;                                     // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         gameEventData;                                     // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile) == 0x000008, "Wrong alignment on LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile");
static_assert(sizeof(LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile) == 0x000038, "Wrong size on LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile");
static_assert(offsetof(LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile, gameEventType) == 0x000000, "Member 'LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile::gameEventType' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile, gameEventData) == 0x000010, "Member 'LamentConfiguration_Authority_OnSurvivorHitByControlledProjectile::gameEventData' has a wrong offset!");

// Function TheK25.LamentConfiguration.Authority_RespawnLamentConfiguration
// 0x0001 (0x0001 - 0x0000)
struct LamentConfiguration_Authority_RespawnLamentConfiguration final
{
public:
	bool                                          triggerChainHuntUponSpawning;                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Authority_RespawnLamentConfiguration) == 0x000001, "Wrong alignment on LamentConfiguration_Authority_RespawnLamentConfiguration");
static_assert(sizeof(LamentConfiguration_Authority_RespawnLamentConfiguration) == 0x000001, "Wrong size on LamentConfiguration_Authority_RespawnLamentConfiguration");
static_assert(offsetof(LamentConfiguration_Authority_RespawnLamentConfiguration, triggerChainHuntUponSpawning) == 0x000000, "Member 'LamentConfiguration_Authority_RespawnLamentConfiguration::triggerChainHuntUponSpawning' has a wrong offset!");

// Function TheK25.LamentConfiguration.Cosmetic_EndSolvingCubeSFX
// 0x0001 (0x0001 - 0x0000)
struct LamentConfiguration_Cosmetic_EndSolvingCubeSFX final
{
public:
	bool                                          hasBeenSolved;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Cosmetic_EndSolvingCubeSFX) == 0x000001, "Wrong alignment on LamentConfiguration_Cosmetic_EndSolvingCubeSFX");
static_assert(sizeof(LamentConfiguration_Cosmetic_EndSolvingCubeSFX) == 0x000001, "Wrong size on LamentConfiguration_Cosmetic_EndSolvingCubeSFX");
static_assert(offsetof(LamentConfiguration_Cosmetic_EndSolvingCubeSFX, hasBeenSolved) == 0x000000, "Member 'LamentConfiguration_Cosmetic_EndSolvingCubeSFX::hasBeenSolved' has a wrong offset!");

// Function TheK25.LamentConfiguration.Cosmetic_OnChainHuntChargeStart
// 0x0004 (0x0004 - 0x0000)
struct LamentConfiguration_Cosmetic_OnChainHuntChargeStart final
{
public:
	float                                         chargeTime;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Cosmetic_OnChainHuntChargeStart) == 0x000004, "Wrong alignment on LamentConfiguration_Cosmetic_OnChainHuntChargeStart");
static_assert(sizeof(LamentConfiguration_Cosmetic_OnChainHuntChargeStart) == 0x000004, "Wrong size on LamentConfiguration_Cosmetic_OnChainHuntChargeStart");
static_assert(offsetof(LamentConfiguration_Cosmetic_OnChainHuntChargeStart, chargeTime) == 0x000000, "Member 'LamentConfiguration_Cosmetic_OnChainHuntChargeStart::chargeTime' has a wrong offset!");

// Function TheK25.LamentConfiguration.Cosmetic_OnHoldingSurvivorHostageEnd
// 0x0001 (0x0001 - 0x0000)
struct LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageEnd final
{
public:
	bool                                          hasEndedThroughKillerAttack;                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageEnd) == 0x000001, "Wrong alignment on LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageEnd");
static_assert(sizeof(LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageEnd) == 0x000001, "Wrong size on LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageEnd");
static_assert(offsetof(LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageEnd, hasEndedThroughKillerAttack) == 0x000000, "Member 'LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageEnd::hasEndedThroughKillerAttack' has a wrong offset!");

// Function TheK25.LamentConfiguration.Cosmetic_OnHoldingSurvivorHostageStart
// 0x0004 (0x0004 - 0x0000)
struct LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageStart final
{
public:
	float                                         hostageDuration;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageStart) == 0x000004, "Wrong alignment on LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageStart");
static_assert(sizeof(LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageStart) == 0x000004, "Wrong size on LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageStart");
static_assert(offsetof(LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageStart, hostageDuration) == 0x000000, "Member 'LamentConfiguration_Cosmetic_OnHoldingSurvivorHostageStart::hostageDuration' has a wrong offset!");

// Function TheK25.LamentConfiguration.Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration
// 0x0010 (0x0010 - 0x0000)
struct LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACamperPlayer*                          survivorDowned;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration) == 0x000008, "Wrong alignment on LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration");
static_assert(sizeof(LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration) == 0x000010, "Wrong size on LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration");
static_assert(offsetof(LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration, killer) == 0x000000, "Member 'LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration::killer' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration, survivorDowned) == 0x000008, "Member 'LamentConfiguration_Cosmetic_OnKillerDownedSurvivorHoldingLamentConfiguration::survivorDowned' has a wrong offset!");

// Function TheK25.LamentConfiguration.Multicast_CorrectLamentConfigurationPosition
// 0x000C (0x000C - 0x0000)
struct LamentConfiguration_Multicast_CorrectLamentConfigurationPosition final
{
public:
	struct FVector                                newPosition;                                       // 0x0000(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Multicast_CorrectLamentConfigurationPosition) == 0x000004, "Wrong alignment on LamentConfiguration_Multicast_CorrectLamentConfigurationPosition");
static_assert(sizeof(LamentConfiguration_Multicast_CorrectLamentConfigurationPosition) == 0x00000C, "Wrong size on LamentConfiguration_Multicast_CorrectLamentConfigurationPosition");
static_assert(offsetof(LamentConfiguration_Multicast_CorrectLamentConfigurationPosition, newPosition) == 0x000000, "Member 'LamentConfiguration_Multicast_CorrectLamentConfigurationPosition::newPosition' has a wrong offset!");

// Function TheK25.LamentConfiguration.Multicast_DownedSurvivorHoldingLamentConfiguration
// 0x0008 (0x0008 - 0x0000)
struct LamentConfiguration_Multicast_DownedSurvivorHoldingLamentConfiguration final
{
public:
	class ACamperPlayer*                          survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Multicast_DownedSurvivorHoldingLamentConfiguration) == 0x000008, "Wrong alignment on LamentConfiguration_Multicast_DownedSurvivorHoldingLamentConfiguration");
static_assert(sizeof(LamentConfiguration_Multicast_DownedSurvivorHoldingLamentConfiguration) == 0x000008, "Wrong size on LamentConfiguration_Multicast_DownedSurvivorHoldingLamentConfiguration");
static_assert(offsetof(LamentConfiguration_Multicast_DownedSurvivorHoldingLamentConfiguration, survivor) == 0x000000, "Member 'LamentConfiguration_Multicast_DownedSurvivorHoldingLamentConfiguration::survivor' has a wrong offset!");

// Function TheK25.LamentConfiguration.Multicast_TriggerKillerPickUpSFX
// 0x0010 (0x0010 - 0x0000)
struct LamentConfiguration_Multicast_TriggerKillerPickUpSFX final
{
public:
	TArray<class ACamperPlayer*>                  affectedSurvivors;                                 // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_Multicast_TriggerKillerPickUpSFX) == 0x000008, "Wrong alignment on LamentConfiguration_Multicast_TriggerKillerPickUpSFX");
static_assert(sizeof(LamentConfiguration_Multicast_TriggerKillerPickUpSFX) == 0x000010, "Wrong size on LamentConfiguration_Multicast_TriggerKillerPickUpSFX");
static_assert(offsetof(LamentConfiguration_Multicast_TriggerKillerPickUpSFX, affectedSurvivors) == 0x000000, "Member 'LamentConfiguration_Multicast_TriggerKillerPickUpSFX::affectedSurvivors' has a wrong offset!");

// Function TheK25.LamentConfiguration.OnCamperEscaped
// 0x0038 (0x0038 - 0x0000)
struct LamentConfiguration_OnCamperEscaped final
{
public:
	struct FGameplayTag                           gameEventType;                                     // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         gameEventData;                                     // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_OnCamperEscaped) == 0x000008, "Wrong alignment on LamentConfiguration_OnCamperEscaped");
static_assert(sizeof(LamentConfiguration_OnCamperEscaped) == 0x000038, "Wrong size on LamentConfiguration_OnCamperEscaped");
static_assert(offsetof(LamentConfiguration_OnCamperEscaped, gameEventType) == 0x000000, "Member 'LamentConfiguration_OnCamperEscaped::gameEventType' has a wrong offset!");
static_assert(offsetof(LamentConfiguration_OnCamperEscaped, gameEventData) == 0x000010, "Member 'LamentConfiguration_OnCamperEscaped::gameEventData' has a wrong offset!");

// Function TheK25.LamentConfiguration.OnRep_SurvivorHeldHostage
// 0x0008 (0x0008 - 0x0000)
struct LamentConfiguration_OnRep_SurvivorHeldHostage final
{
public:
	class ACamperPlayer*                          oldSurvivorHeldHostage;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_OnRep_SurvivorHeldHostage) == 0x000008, "Wrong alignment on LamentConfiguration_OnRep_SurvivorHeldHostage");
static_assert(sizeof(LamentConfiguration_OnRep_SurvivorHeldHostage) == 0x000008, "Wrong size on LamentConfiguration_OnRep_SurvivorHeldHostage");
static_assert(offsetof(LamentConfiguration_OnRep_SurvivorHeldHostage, oldSurvivorHeldHostage) == 0x000000, "Member 'LamentConfiguration_OnRep_SurvivorHeldHostage::oldSurvivorHeldHostage' has a wrong offset!");

// Function TheK25.LamentConfiguration.TriggerKillerPickUpSFX
// 0x0010 (0x0010 - 0x0000)
struct LamentConfiguration_TriggerKillerPickUpSFX final
{
public:
	TArray<class ACamperPlayer*>                  affectedSurvivors;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_TriggerKillerPickUpSFX) == 0x000008, "Wrong alignment on LamentConfiguration_TriggerKillerPickUpSFX");
static_assert(sizeof(LamentConfiguration_TriggerKillerPickUpSFX) == 0x000010, "Wrong size on LamentConfiguration_TriggerKillerPickUpSFX");
static_assert(offsetof(LamentConfiguration_TriggerKillerPickUpSFX, affectedSurvivors) == 0x000000, "Member 'LamentConfiguration_TriggerKillerPickUpSFX::affectedSurvivors' has a wrong offset!");

// Function TheK25.LamentConfiguration.GetChainHuntProgressPercentage
// 0x0004 (0x0004 - 0x0000)
struct LamentConfiguration_GetChainHuntProgressPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfiguration_GetChainHuntProgressPercentage) == 0x000004, "Wrong alignment on LamentConfiguration_GetChainHuntProgressPercentage");
static_assert(sizeof(LamentConfiguration_GetChainHuntProgressPercentage) == 0x000004, "Wrong size on LamentConfiguration_GetChainHuntProgressPercentage");
static_assert(offsetof(LamentConfiguration_GetChainHuntProgressPercentage, ReturnValue) == 0x000000, "Member 'LamentConfiguration_GetChainHuntProgressPercentage::ReturnValue' has a wrong offset!");

// Function TheK25.ChainAttachedGateBlockerEffect.OnSurvivorDamageStateChanged
// 0x0002 (0x0002 - 0x0000)
struct ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged final
{
public:
	ECamperDamageState                            oldState;                                          // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECamperDamageState                            newState;                                          // 0x0001(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged) == 0x000001, "Wrong alignment on ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged");
static_assert(sizeof(ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged) == 0x000002, "Wrong size on ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged");
static_assert(offsetof(ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged, oldState) == 0x000000, "Member 'ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged::oldState' has a wrong offset!");
static_assert(offsetof(ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged, newState) == 0x000001, "Member 'ChainAttachedGateBlockerEffect_OnSurvivorDamageStateChanged::newState' has a wrong offset!");

// Function TheK25.K25AttackSubAnimInstance.OnAttackStart
// 0x0001 (0x0001 - 0x0000)
struct K25AttackSubAnimInstance_OnAttackStart final
{
public:
	EAttackType                                   attackType;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25AttackSubAnimInstance_OnAttackStart) == 0x000001, "Wrong alignment on K25AttackSubAnimInstance_OnAttackStart");
static_assert(sizeof(K25AttackSubAnimInstance_OnAttackStart) == 0x000001, "Wrong size on K25AttackSubAnimInstance_OnAttackStart");
static_assert(offsetof(K25AttackSubAnimInstance_OnAttackStart, attackType) == 0x000000, "Member 'K25AttackSubAnimInstance_OnAttackStart::attackType' has a wrong offset!");

// Function TheK25.K25Chain.Cosmetic_OnChainAttachedToSurvivor
// 0x0001 (0x0001 - 0x0000)
struct K25Chain_Cosmetic_OnChainAttachedToSurvivor final
{
public:
	bool                                          wasReachingSurvivorAnchorPoint;                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_Cosmetic_OnChainAttachedToSurvivor) == 0x000001, "Wrong alignment on K25Chain_Cosmetic_OnChainAttachedToSurvivor");
static_assert(sizeof(K25Chain_Cosmetic_OnChainAttachedToSurvivor) == 0x000001, "Wrong size on K25Chain_Cosmetic_OnChainAttachedToSurvivor");
static_assert(offsetof(K25Chain_Cosmetic_OnChainAttachedToSurvivor, wasReachingSurvivorAnchorPoint) == 0x000000, "Member 'K25Chain_Cosmetic_OnChainAttachedToSurvivor::wasReachingSurvivorAnchorPoint' has a wrong offset!");

// Function TheK25.K25Chain.Cosmetic_OnChainDetachedFromSurvivor
// 0x0001 (0x0001 - 0x0000)
struct K25Chain_Cosmetic_OnChainDetachedFromSurvivor final
{
public:
	EK25ChainDetachmentReason                     detachmentReason;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_Cosmetic_OnChainDetachedFromSurvivor) == 0x000001, "Wrong alignment on K25Chain_Cosmetic_OnChainDetachedFromSurvivor");
static_assert(sizeof(K25Chain_Cosmetic_OnChainDetachedFromSurvivor) == 0x000001, "Wrong size on K25Chain_Cosmetic_OnChainDetachedFromSurvivor");
static_assert(offsetof(K25Chain_Cosmetic_OnChainDetachedFromSurvivor, detachmentReason) == 0x000000, "Member 'K25Chain_Cosmetic_OnChainDetachedFromSurvivor::detachmentReason' has a wrong offset!");

// Function TheK25.K25Chain.Cosmetic_OnSurvivorStoppedRemovingChainSFX
// 0x0001 (0x0001 - 0x0000)
struct K25Chain_Cosmetic_OnSurvivorStoppedRemovingChainSFX final
{
public:
	bool                                          hasRemovedChainDueToInteraction;                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_Cosmetic_OnSurvivorStoppedRemovingChainSFX) == 0x000001, "Wrong alignment on K25Chain_Cosmetic_OnSurvivorStoppedRemovingChainSFX");
static_assert(sizeof(K25Chain_Cosmetic_OnSurvivorStoppedRemovingChainSFX) == 0x000001, "Wrong size on K25Chain_Cosmetic_OnSurvivorStoppedRemovingChainSFX");
static_assert(offsetof(K25Chain_Cosmetic_OnSurvivorStoppedRemovingChainSFX, hasRemovedChainDueToInteraction) == 0x000000, "Member 'K25Chain_Cosmetic_OnSurvivorStoppedRemovingChainSFX::hasRemovedChainDueToInteraction' has a wrong offset!");

// Function TheK25.K25Chain.SetInstancedMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct K25Chain_SetInstancedMeshComponent final
{
public:
	class UInstancedStaticMeshComponent*          instancedMesh;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_SetInstancedMeshComponent) == 0x000008, "Wrong alignment on K25Chain_SetInstancedMeshComponent");
static_assert(sizeof(K25Chain_SetInstancedMeshComponent) == 0x000008, "Wrong size on K25Chain_SetInstancedMeshComponent");
static_assert(offsetof(K25Chain_SetInstancedMeshComponent, instancedMesh) == 0x000000, "Member 'K25Chain_SetInstancedMeshComponent::instancedMesh' has a wrong offset!");

// Function TheK25.K25Chain.SetSplineComponent
// 0x0008 (0x0008 - 0x0000)
struct K25Chain_SetSplineComponent final
{
public:
	class USplineComponent*                       component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_SetSplineComponent) == 0x000008, "Wrong alignment on K25Chain_SetSplineComponent");
static_assert(sizeof(K25Chain_SetSplineComponent) == 0x000008, "Wrong size on K25Chain_SetSplineComponent");
static_assert(offsetof(K25Chain_SetSplineComponent, component) == 0x000000, "Member 'K25Chain_SetSplineComponent::component' has a wrong offset!");

// Function TheK25.K25Chain.GetChainEndLocation
// 0x000C (0x000C - 0x0000)
struct K25Chain_GetChainEndLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_GetChainEndLocation) == 0x000004, "Wrong alignment on K25Chain_GetChainEndLocation");
static_assert(sizeof(K25Chain_GetChainEndLocation) == 0x00000C, "Wrong size on K25Chain_GetChainEndLocation");
static_assert(offsetof(K25Chain_GetChainEndLocation, ReturnValue) == 0x000000, "Member 'K25Chain_GetChainEndLocation::ReturnValue' has a wrong offset!");

// Function TheK25.K25Chain.GetChainStartLocation
// 0x000C (0x000C - 0x0000)
struct K25Chain_GetChainStartLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_GetChainStartLocation) == 0x000004, "Wrong alignment on K25Chain_GetChainStartLocation");
static_assert(sizeof(K25Chain_GetChainStartLocation) == 0x00000C, "Wrong size on K25Chain_GetChainStartLocation");
static_assert(offsetof(K25Chain_GetChainStartLocation, ReturnValue) == 0x000000, "Member 'K25Chain_GetChainStartLocation::ReturnValue' has a wrong offset!");

// Function TheK25.K25Chain.GetSurvivorChainAttachmentAnchor
// 0x0008 (0x0008 - 0x0000)
struct K25Chain_GetSurvivorChainAttachmentAnchor final
{
public:
	class AK25SurvivorChainAttachmentAnchor*      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_GetSurvivorChainAttachmentAnchor) == 0x000008, "Wrong alignment on K25Chain_GetSurvivorChainAttachmentAnchor");
static_assert(sizeof(K25Chain_GetSurvivorChainAttachmentAnchor) == 0x000008, "Wrong size on K25Chain_GetSurvivorChainAttachmentAnchor");
static_assert(offsetof(K25Chain_GetSurvivorChainAttachmentAnchor, ReturnValue) == 0x000000, "Member 'K25Chain_GetSurvivorChainAttachmentAnchor::ReturnValue' has a wrong offset!");

// Function TheK25.K25Chain.IsAttachedToControlledProjectile
// 0x0001 (0x0001 - 0x0000)
struct K25Chain_IsAttachedToControlledProjectile final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Chain_IsAttachedToControlledProjectile) == 0x000001, "Wrong alignment on K25Chain_IsAttachedToControlledProjectile");
static_assert(sizeof(K25Chain_IsAttachedToControlledProjectile) == 0x000001, "Wrong size on K25Chain_IsAttachedToControlledProjectile");
static_assert(offsetof(K25Chain_IsAttachedToControlledProjectile, ReturnValue) == 0x000000, "Member 'K25Chain_IsAttachedToControlledProjectile::ReturnValue' has a wrong offset!");

// Function TheK25.K25ChainAttachmentReplicationComponent.Multicast_AttachChainToAnchor
// 0x0018 (0x0018 - 0x0000)
struct K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor final
{
public:
	class UK25SurvivorChainAttachmentComponent*   chainAttachementComponent;                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25Chain*                              chainToAttach;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25SurvivorChainAttachmentAnchor*      anchorPoint;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor) == 0x000008, "Wrong alignment on K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor");
static_assert(sizeof(K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor) == 0x000018, "Wrong size on K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor, chainAttachementComponent) == 0x000000, "Member 'K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor::chainAttachementComponent' has a wrong offset!");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor, chainToAttach) == 0x000008, "Member 'K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor::chainToAttach' has a wrong offset!");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor, anchorPoint) == 0x000010, "Member 'K25ChainAttachmentReplicationComponent_Multicast_AttachChainToAnchor::anchorPoint' has a wrong offset!");

// Function TheK25.K25ChainAttachmentReplicationComponent.Multicast_DetachChains
// 0x0030 (0x0030 - 0x0000)
struct K25ChainAttachmentReplicationComponent_Multicast_DetachChains final
{
public:
	class UK25SurvivorChainAttachmentComponent*   chainAttachementComponent;                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AK25Chain*>                      chainsToDetach;                                    // 0x0008(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EK25ChainDetachmentReason                     detachmentReason;                                  // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AK25Chain*>                      chainsAttached;                                    // 0x0020(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainAttachmentReplicationComponent_Multicast_DetachChains) == 0x000008, "Wrong alignment on K25ChainAttachmentReplicationComponent_Multicast_DetachChains");
static_assert(sizeof(K25ChainAttachmentReplicationComponent_Multicast_DetachChains) == 0x000030, "Wrong size on K25ChainAttachmentReplicationComponent_Multicast_DetachChains");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_DetachChains, chainAttachementComponent) == 0x000000, "Member 'K25ChainAttachmentReplicationComponent_Multicast_DetachChains::chainAttachementComponent' has a wrong offset!");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_DetachChains, chainsToDetach) == 0x000008, "Member 'K25ChainAttachmentReplicationComponent_Multicast_DetachChains::chainsToDetach' has a wrong offset!");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_DetachChains, detachmentReason) == 0x000018, "Member 'K25ChainAttachmentReplicationComponent_Multicast_DetachChains::detachmentReason' has a wrong offset!");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_DetachChains, chainsAttached) == 0x000020, "Member 'K25ChainAttachmentReplicationComponent_Multicast_DetachChains::chainsAttached' has a wrong offset!");

// Function TheK25.K25ChainAttachmentReplicationComponent.Multicast_LaunchInstantHitChainTowardsSurvivor
// 0x0020 (0x0020 - 0x0000)
struct K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor final
{
public:
	class AK25Chain*                              newChainToAttach;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25SurvivorChainAttachmentAnchor*      targetAnchor;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                startPosition;                                     // 0x0010(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor) == 0x000008, "Wrong alignment on K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor");
static_assert(sizeof(K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor) == 0x000020, "Wrong size on K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor, newChainToAttach) == 0x000000, "Member 'K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor::newChainToAttach' has a wrong offset!");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor, targetAnchor) == 0x000008, "Member 'K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor::targetAnchor' has a wrong offset!");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor, startPosition) == 0x000010, "Member 'K25ChainAttachmentReplicationComponent_Multicast_LaunchInstantHitChainTowardsSurvivor::startPosition' has a wrong offset!");

// Function TheK25.K25ChainAttachmentReplicationComponent.Multicast_StartChainReelback
// 0x0008 (0x0008 - 0x0000)
struct K25ChainAttachmentReplicationComponent_Multicast_StartChainReelback final
{
public:
	class AK25Chain*                              chainToAttach;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainAttachmentReplicationComponent_Multicast_StartChainReelback) == 0x000008, "Wrong alignment on K25ChainAttachmentReplicationComponent_Multicast_StartChainReelback");
static_assert(sizeof(K25ChainAttachmentReplicationComponent_Multicast_StartChainReelback) == 0x000008, "Wrong size on K25ChainAttachmentReplicationComponent_Multicast_StartChainReelback");
static_assert(offsetof(K25ChainAttachmentReplicationComponent_Multicast_StartChainReelback, chainToAttach) == 0x000000, "Member 'K25ChainAttachmentReplicationComponent_Multicast_StartChainReelback::chainToAttach' has a wrong offset!");

// Function TheK25.K25ChainHuntEffectsComponent.Cosmetic_ActivateChainHuntEffects
// 0x0001 (0x0001 - 0x0000)
struct K25ChainHuntEffectsComponent_Cosmetic_ActivateChainHuntEffects final
{
public:
	bool                                          hasChainHuntStarted;                               // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainHuntEffectsComponent_Cosmetic_ActivateChainHuntEffects) == 0x000001, "Wrong alignment on K25ChainHuntEffectsComponent_Cosmetic_ActivateChainHuntEffects");
static_assert(sizeof(K25ChainHuntEffectsComponent_Cosmetic_ActivateChainHuntEffects) == 0x000001, "Wrong size on K25ChainHuntEffectsComponent_Cosmetic_ActivateChainHuntEffects");
static_assert(offsetof(K25ChainHuntEffectsComponent_Cosmetic_ActivateChainHuntEffects, hasChainHuntStarted) == 0x000000, "Member 'K25ChainHuntEffectsComponent_Cosmetic_ActivateChainHuntEffects::hasChainHuntStarted' has a wrong offset!");

// Function TheK25.K25ChainHuntEffectsComponent.GetOwningPlayer
// 0x0008 (0x0008 - 0x0000)
struct K25ChainHuntEffectsComponent_GetOwningPlayer final
{
public:
	class ADBDPlayer*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainHuntEffectsComponent_GetOwningPlayer) == 0x000008, "Wrong alignment on K25ChainHuntEffectsComponent_GetOwningPlayer");
static_assert(sizeof(K25ChainHuntEffectsComponent_GetOwningPlayer) == 0x000008, "Wrong size on K25ChainHuntEffectsComponent_GetOwningPlayer");
static_assert(offsetof(K25ChainHuntEffectsComponent_GetOwningPlayer, ReturnValue) == 0x000000, "Member 'K25ChainHuntEffectsComponent_GetOwningPlayer::ReturnValue' has a wrong offset!");

// Function TheK25.K25ChainLocomotionSurvivorAnimInstance.OnChainAttached
// 0x0010 (0x0010 - 0x0000)
struct K25ChainLocomotionSurvivorAnimInstance_OnChainAttached final
{
public:
	class AK25Chain*                              chain;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25SurvivorChainAttachmentAnchor*      chainAttachmentAnchor;                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainLocomotionSurvivorAnimInstance_OnChainAttached) == 0x000008, "Wrong alignment on K25ChainLocomotionSurvivorAnimInstance_OnChainAttached");
static_assert(sizeof(K25ChainLocomotionSurvivorAnimInstance_OnChainAttached) == 0x000010, "Wrong size on K25ChainLocomotionSurvivorAnimInstance_OnChainAttached");
static_assert(offsetof(K25ChainLocomotionSurvivorAnimInstance_OnChainAttached, chain) == 0x000000, "Member 'K25ChainLocomotionSurvivorAnimInstance_OnChainAttached::chain' has a wrong offset!");
static_assert(offsetof(K25ChainLocomotionSurvivorAnimInstance_OnChainAttached, chainAttachmentAnchor) == 0x000008, "Member 'K25ChainLocomotionSurvivorAnimInstance_OnChainAttached::chainAttachmentAnchor' has a wrong offset!");

// Function TheK25.K25ChainLocomotionSurvivorAnimInstance.OnChainDetached
// 0x0018 (0x0018 - 0x0000)
struct K25ChainLocomotionSurvivorAnimInstance_OnChainDetached final
{
public:
	class AK25Chain*                              chain;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25SurvivorChainAttachmentAnchor*      chainAttachmentAnchor;                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EK25ChainDetachmentReason                     detachmentReason;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25ChainLocomotionSurvivorAnimInstance_OnChainDetached) == 0x000008, "Wrong alignment on K25ChainLocomotionSurvivorAnimInstance_OnChainDetached");
static_assert(sizeof(K25ChainLocomotionSurvivorAnimInstance_OnChainDetached) == 0x000018, "Wrong size on K25ChainLocomotionSurvivorAnimInstance_OnChainDetached");
static_assert(offsetof(K25ChainLocomotionSurvivorAnimInstance_OnChainDetached, chain) == 0x000000, "Member 'K25ChainLocomotionSurvivorAnimInstance_OnChainDetached::chain' has a wrong offset!");
static_assert(offsetof(K25ChainLocomotionSurvivorAnimInstance_OnChainDetached, chainAttachmentAnchor) == 0x000008, "Member 'K25ChainLocomotionSurvivorAnimInstance_OnChainDetached::chainAttachmentAnchor' has a wrong offset!");
static_assert(offsetof(K25ChainLocomotionSurvivorAnimInstance_OnChainDetached, detachmentReason) == 0x000010, "Member 'K25ChainLocomotionSurvivorAnimInstance_OnChainDetached::detachmentReason' has a wrong offset!");

// Function TheK25.K25ChainStrikeBaseState.GetK25Gateway
// 0x0008 (0x0008 - 0x0000)
struct K25ChainStrikeBaseState_GetK25Gateway final
{
public:
	class AK25Gateway*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeBaseState_GetK25Gateway) == 0x000008, "Wrong alignment on K25ChainStrikeBaseState_GetK25Gateway");
static_assert(sizeof(K25ChainStrikeBaseState_GetK25Gateway) == 0x000008, "Wrong size on K25ChainStrikeBaseState_GetK25Gateway");
static_assert(offsetof(K25ChainStrikeBaseState_GetK25Gateway, ReturnValue) == 0x000000, "Member 'K25ChainStrikeBaseState_GetK25Gateway::ReturnValue' has a wrong offset!");

// Function TheK25.K25ChainStrikeBaseState.GetK25Power
// 0x0008 (0x0008 - 0x0000)
struct K25ChainStrikeBaseState_GetK25Power final
{
public:
	class AK25Power*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeBaseState_GetK25Power) == 0x000008, "Wrong alignment on K25ChainStrikeBaseState_GetK25Power");
static_assert(sizeof(K25ChainStrikeBaseState_GetK25Power) == 0x000008, "Wrong size on K25ChainStrikeBaseState_GetK25Power");
static_assert(offsetof(K25ChainStrikeBaseState_GetK25Power, ReturnValue) == 0x000000, "Member 'K25ChainStrikeBaseState_GetK25Power::ReturnValue' has a wrong offset!");

// Function TheK25.K25ChainStrikeBaseState.GetPlayerOwner
// 0x0008 (0x0008 - 0x0000)
struct K25ChainStrikeBaseState_GetPlayerOwner final
{
public:
	class ADBDPlayer*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeBaseState_GetPlayerOwner) == 0x000008, "Wrong alignment on K25ChainStrikeBaseState_GetPlayerOwner");
static_assert(sizeof(K25ChainStrikeBaseState_GetPlayerOwner) == 0x000008, "Wrong size on K25ChainStrikeBaseState_GetPlayerOwner");
static_assert(offsetof(K25ChainStrikeBaseState_GetPlayerOwner, ReturnValue) == 0x000000, "Member 'K25ChainStrikeBaseState_GetPlayerOwner::ReturnValue' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Cosmetic_ResetAllVignetteValues
// 0x0008 (0x0008 - 0x0000)
struct K25ChainStrikeInteraction_Cosmetic_ResetAllVignetteValues final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Cosmetic_ResetAllVignetteValues) == 0x000008, "Wrong alignment on K25ChainStrikeInteraction_Cosmetic_ResetAllVignetteValues");
static_assert(sizeof(K25ChainStrikeInteraction_Cosmetic_ResetAllVignetteValues) == 0x000008, "Wrong size on K25ChainStrikeInteraction_Cosmetic_ResetAllVignetteValues");
static_assert(offsetof(K25ChainStrikeInteraction_Cosmetic_ResetAllVignetteValues, killer) == 0x000000, "Member 'K25ChainStrikeInteraction_Cosmetic_ResetAllVignetteValues::killer' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Cosmetic_TriggerGatewayPossessionEffects
// 0x0004 (0x0004 - 0x0000)
struct K25ChainStrikeInteraction_Cosmetic_TriggerGatewayPossessionEffects final
{
public:
	float                                         transitionTime;                                    // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Cosmetic_TriggerGatewayPossessionEffects) == 0x000004, "Wrong alignment on K25ChainStrikeInteraction_Cosmetic_TriggerGatewayPossessionEffects");
static_assert(sizeof(K25ChainStrikeInteraction_Cosmetic_TriggerGatewayPossessionEffects) == 0x000004, "Wrong size on K25ChainStrikeInteraction_Cosmetic_TriggerGatewayPossessionEffects");
static_assert(offsetof(K25ChainStrikeInteraction_Cosmetic_TriggerGatewayPossessionEffects, transitionTime) == 0x000000, "Member 'K25ChainStrikeInteraction_Cosmetic_TriggerGatewayPossessionEffects::transitionTime' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Cosmetic_TriggerKillerRepossessionFadeInEffects
// 0x0010 (0x0010 - 0x0000)
struct K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          hasHitSurvivor;                                    // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          preventAudioTriggers;                              // 0x0009(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects) == 0x000008, "Wrong alignment on K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects");
static_assert(sizeof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects) == 0x000010, "Wrong size on K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects");
static_assert(offsetof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects, killer) == 0x000000, "Member 'K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects::killer' has a wrong offset!");
static_assert(offsetof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects, hasHitSurvivor) == 0x000008, "Member 'K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects::hasHitSurvivor' has a wrong offset!");
static_assert(offsetof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects, preventAudioTriggers) == 0x000009, "Member 'K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeInEffects::preventAudioTriggers' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Cosmetic_TriggerKillerRepossessionFadeOutEffects
// 0x0010 (0x0010 - 0x0000)
struct K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          preventAudioTriggers;                              // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects) == 0x000008, "Wrong alignment on K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects");
static_assert(sizeof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects) == 0x000010, "Wrong size on K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects");
static_assert(offsetof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects, killer) == 0x000000, "Member 'K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects::killer' has a wrong offset!");
static_assert(offsetof(K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects, preventAudioTriggers) == 0x000008, "Member 'K25ChainStrikeInteraction_Cosmetic_TriggerKillerRepossessionFadeOutEffects::preventAudioTriggers' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Multicast_AddStateTagToPlayer
// 0x000C (0x000C - 0x0000)
struct K25ChainStrikeInteraction_Multicast_AddStateTagToPlayer final
{
public:
	struct FGameplayTag                           tag;                                               // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Multicast_AddStateTagToPlayer) == 0x000004, "Wrong alignment on K25ChainStrikeInteraction_Multicast_AddStateTagToPlayer");
static_assert(sizeof(K25ChainStrikeInteraction_Multicast_AddStateTagToPlayer) == 0x00000C, "Wrong size on K25ChainStrikeInteraction_Multicast_AddStateTagToPlayer");
static_assert(offsetof(K25ChainStrikeInteraction_Multicast_AddStateTagToPlayer, tag) == 0x000000, "Member 'K25ChainStrikeInteraction_Multicast_AddStateTagToPlayer::tag' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Multicast_RemoveStateTagFromPlayer
// 0x000C (0x000C - 0x0000)
struct K25ChainStrikeInteraction_Multicast_RemoveStateTagFromPlayer final
{
public:
	struct FGameplayTag                           tag;                                               // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Multicast_RemoveStateTagFromPlayer) == 0x000004, "Wrong alignment on K25ChainStrikeInteraction_Multicast_RemoveStateTagFromPlayer");
static_assert(sizeof(K25ChainStrikeInteraction_Multicast_RemoveStateTagFromPlayer) == 0x00000C, "Wrong size on K25ChainStrikeInteraction_Multicast_RemoveStateTagFromPlayer");
static_assert(offsetof(K25ChainStrikeInteraction_Multicast_RemoveStateTagFromPlayer, tag) == 0x000000, "Member 'K25ChainStrikeInteraction_Multicast_RemoveStateTagFromPlayer::tag' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Multicast_SetFallbackEndReason
// 0x0001 (0x0001 - 0x0000)
struct K25ChainStrikeInteraction_Multicast_SetFallbackEndReason final
{
public:
	EChainStrikeEndReason                         chainStrikeEndReason;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Multicast_SetFallbackEndReason) == 0x000001, "Wrong alignment on K25ChainStrikeInteraction_Multicast_SetFallbackEndReason");
static_assert(sizeof(K25ChainStrikeInteraction_Multicast_SetFallbackEndReason) == 0x000001, "Wrong size on K25ChainStrikeInteraction_Multicast_SetFallbackEndReason");
static_assert(offsetof(K25ChainStrikeInteraction_Multicast_SetFallbackEndReason, chainStrikeEndReason) == 0x000000, "Member 'K25ChainStrikeInteraction_Multicast_SetFallbackEndReason::chainStrikeEndReason' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Server_AddStateTagToPlayer
// 0x000C (0x000C - 0x0000)
struct K25ChainStrikeInteraction_Server_AddStateTagToPlayer final
{
public:
	struct FGameplayTag                           tag;                                               // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Server_AddStateTagToPlayer) == 0x000004, "Wrong alignment on K25ChainStrikeInteraction_Server_AddStateTagToPlayer");
static_assert(sizeof(K25ChainStrikeInteraction_Server_AddStateTagToPlayer) == 0x00000C, "Wrong size on K25ChainStrikeInteraction_Server_AddStateTagToPlayer");
static_assert(offsetof(K25ChainStrikeInteraction_Server_AddStateTagToPlayer, tag) == 0x000000, "Member 'K25ChainStrikeInteraction_Server_AddStateTagToPlayer::tag' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Server_RemoveStateTagFromPlayer
// 0x000C (0x000C - 0x0000)
struct K25ChainStrikeInteraction_Server_RemoveStateTagFromPlayer final
{
public:
	struct FGameplayTag                           tag;                                               // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Server_RemoveStateTagFromPlayer) == 0x000004, "Wrong alignment on K25ChainStrikeInteraction_Server_RemoveStateTagFromPlayer");
static_assert(sizeof(K25ChainStrikeInteraction_Server_RemoveStateTagFromPlayer) == 0x00000C, "Wrong size on K25ChainStrikeInteraction_Server_RemoveStateTagFromPlayer");
static_assert(offsetof(K25ChainStrikeInteraction_Server_RemoveStateTagFromPlayer, tag) == 0x000000, "Member 'K25ChainStrikeInteraction_Server_RemoveStateTagFromPlayer::tag' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Server_SetFallbackEndReason
// 0x0001 (0x0001 - 0x0000)
struct K25ChainStrikeInteraction_Server_SetFallbackEndReason final
{
public:
	EChainStrikeEndReason                         chainStrikeEndReason;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Server_SetFallbackEndReason) == 0x000001, "Wrong alignment on K25ChainStrikeInteraction_Server_SetFallbackEndReason");
static_assert(sizeof(K25ChainStrikeInteraction_Server_SetFallbackEndReason) == 0x000001, "Wrong size on K25ChainStrikeInteraction_Server_SetFallbackEndReason");
static_assert(offsetof(K25ChainStrikeInteraction_Server_SetFallbackEndReason, chainStrikeEndReason) == 0x000000, "Member 'K25ChainStrikeInteraction_Server_SetFallbackEndReason::chainStrikeEndReason' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Server_SetShouldIncrementChargeableComponent
// 0x0001 (0x0001 - 0x0000)
struct K25ChainStrikeInteraction_Server_SetShouldIncrementChargeableComponent final
{
public:
	bool                                          shouldIncrement;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Server_SetShouldIncrementChargeableComponent) == 0x000001, "Wrong alignment on K25ChainStrikeInteraction_Server_SetShouldIncrementChargeableComponent");
static_assert(sizeof(K25ChainStrikeInteraction_Server_SetShouldIncrementChargeableComponent) == 0x000001, "Wrong size on K25ChainStrikeInteraction_Server_SetShouldIncrementChargeableComponent");
static_assert(offsetof(K25ChainStrikeInteraction_Server_SetShouldIncrementChargeableComponent, shouldIncrement) == 0x000000, "Member 'K25ChainStrikeInteraction_Server_SetShouldIncrementChargeableComponent::shouldIncrement' has a wrong offset!");

// Function TheK25.K25ChainStrikeInteraction.Server_UpdateCameraViewTargetForObservers
// 0x0001 (0x0001 - 0x0000)
struct K25ChainStrikeInteraction_Server_UpdateCameraViewTargetForObservers final
{
public:
	EChainStrikeCameraViewTarget                  newViewTarget;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ChainStrikeInteraction_Server_UpdateCameraViewTargetForObservers) == 0x000001, "Wrong alignment on K25ChainStrikeInteraction_Server_UpdateCameraViewTargetForObservers");
static_assert(sizeof(K25ChainStrikeInteraction_Server_UpdateCameraViewTargetForObservers) == 0x000001, "Wrong size on K25ChainStrikeInteraction_Server_UpdateCameraViewTargetForObservers");
static_assert(offsetof(K25ChainStrikeInteraction_Server_UpdateCameraViewTargetForObservers, newViewTarget) == 0x000000, "Member 'K25ChainStrikeInteraction_Server_UpdateCameraViewTargetForObservers::newViewTarget' has a wrong offset!");

// Function TheK25.K25ChainStrikeReplicationComponent.Multicast_EndChainStrike
// 0x0010 (0x0010 - 0x0000)
struct K25ChainStrikeReplicationComponent_Multicast_EndChainStrike final
{
public:
	class UK25ChainStrikeInteraction*             interaction;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChainStrikeEndReason                         endReason;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25ChainStrikeReplicationComponent_Multicast_EndChainStrike) == 0x000008, "Wrong alignment on K25ChainStrikeReplicationComponent_Multicast_EndChainStrike");
static_assert(sizeof(K25ChainStrikeReplicationComponent_Multicast_EndChainStrike) == 0x000010, "Wrong size on K25ChainStrikeReplicationComponent_Multicast_EndChainStrike");
static_assert(offsetof(K25ChainStrikeReplicationComponent_Multicast_EndChainStrike, interaction) == 0x000000, "Member 'K25ChainStrikeReplicationComponent_Multicast_EndChainStrike::interaction' has a wrong offset!");
static_assert(offsetof(K25ChainStrikeReplicationComponent_Multicast_EndChainStrike, endReason) == 0x000008, "Member 'K25ChainStrikeReplicationComponent_Multicast_EndChainStrike::endReason' has a wrong offset!");

// Function TheK25.K25ChainStrikeReplicationComponent.Server_EndChainStrike
// 0x0010 (0x0010 - 0x0000)
struct K25ChainStrikeReplicationComponent_Server_EndChainStrike final
{
public:
	class UK25ChainStrikeInteraction*             interaction;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChainStrikeEndReason                         endReason;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25ChainStrikeReplicationComponent_Server_EndChainStrike) == 0x000008, "Wrong alignment on K25ChainStrikeReplicationComponent_Server_EndChainStrike");
static_assert(sizeof(K25ChainStrikeReplicationComponent_Server_EndChainStrike) == 0x000010, "Wrong size on K25ChainStrikeReplicationComponent_Server_EndChainStrike");
static_assert(offsetof(K25ChainStrikeReplicationComponent_Server_EndChainStrike, interaction) == 0x000000, "Member 'K25ChainStrikeReplicationComponent_Server_EndChainStrike::interaction' has a wrong offset!");
static_assert(offsetof(K25ChainStrikeReplicationComponent_Server_EndChainStrike, endReason) == 0x000008, "Member 'K25ChainStrikeReplicationComponent_Server_EndChainStrike::endReason' has a wrong offset!");

// Function TheK25.K25CheatComponent.DBD_K25ComeToPositionLamentConfiguration
// 0x000C (0x000C - 0x0000)
struct K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration final
{
public:
	float                                         x;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         y;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         z;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration) == 0x000004, "Wrong alignment on K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration");
static_assert(sizeof(K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration) == 0x00000C, "Wrong size on K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration");
static_assert(offsetof(K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration, x) == 0x000000, "Member 'K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration::x' has a wrong offset!");
static_assert(offsetof(K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration, y) == 0x000004, "Member 'K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration::y' has a wrong offset!");
static_assert(offsetof(K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration, z) == 0x000008, "Member 'K25CheatComponent_DBD_K25ComeToPositionLamentConfiguration::z' has a wrong offset!");

// Function TheK25.K25CheatComponent.DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition
// 0x000C (0x000C - 0x0000)
struct K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition final
{
public:
	float                                         x;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         y;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         z;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition) == 0x000004, "Wrong alignment on K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition");
static_assert(sizeof(K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition) == 0x00000C, "Wrong size on K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition");
static_assert(offsetof(K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition, x) == 0x000000, "Member 'K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition::x' has a wrong offset!");
static_assert(offsetof(K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition, y) == 0x000004, "Member 'K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition::y' has a wrong offset!");
static_assert(offsetof(K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition, z) == 0x000008, "Member 'K25CheatComponent_DBD_K25ForceRemoveAllChainsOnClosestsSurvivorToPosition::z' has a wrong offset!");

// Function TheK25.K25CheatComponent.DBD_K25RevealLamentConfigurationLocation
// 0x0004 (0x0004 - 0x0000)
struct K25CheatComponent_DBD_K25RevealLamentConfigurationLocation final
{
public:
	float                                         timeDisplayed;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25CheatComponent_DBD_K25RevealLamentConfigurationLocation) == 0x000004, "Wrong alignment on K25CheatComponent_DBD_K25RevealLamentConfigurationLocation");
static_assert(sizeof(K25CheatComponent_DBD_K25RevealLamentConfigurationLocation) == 0x000004, "Wrong size on K25CheatComponent_DBD_K25RevealLamentConfigurationLocation");
static_assert(offsetof(K25CheatComponent_DBD_K25RevealLamentConfigurationLocation, timeDisplayed) == 0x000000, "Member 'K25CheatComponent_DBD_K25RevealLamentConfigurationLocation::timeDisplayed' has a wrong offset!");

// Function TheK25.K25CheatComponent.DBD_K25SetPowerNoCooldown
// 0x0001 (0x0001 - 0x0000)
struct K25CheatComponent_DBD_K25SetPowerNoCooldown final
{
public:
	bool                                          noCooldown;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25CheatComponent_DBD_K25SetPowerNoCooldown) == 0x000001, "Wrong alignment on K25CheatComponent_DBD_K25SetPowerNoCooldown");
static_assert(sizeof(K25CheatComponent_DBD_K25SetPowerNoCooldown) == 0x000001, "Wrong size on K25CheatComponent_DBD_K25SetPowerNoCooldown");
static_assert(offsetof(K25CheatComponent_DBD_K25SetPowerNoCooldown, noCooldown) == 0x000000, "Member 'K25CheatComponent_DBD_K25SetPowerNoCooldown::noCooldown' has a wrong offset!");

// Function TheK25.K25CheatComponent.DBD_K25ShowAllLamentConfigurationSpawnPoints
// 0x0004 (0x0004 - 0x0000)
struct K25CheatComponent_DBD_K25ShowAllLamentConfigurationSpawnPoints final
{
public:
	float                                         timeDisplayed;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25CheatComponent_DBD_K25ShowAllLamentConfigurationSpawnPoints) == 0x000004, "Wrong alignment on K25CheatComponent_DBD_K25ShowAllLamentConfigurationSpawnPoints");
static_assert(sizeof(K25CheatComponent_DBD_K25ShowAllLamentConfigurationSpawnPoints) == 0x000004, "Wrong size on K25CheatComponent_DBD_K25ShowAllLamentConfigurationSpawnPoints");
static_assert(offsetof(K25CheatComponent_DBD_K25ShowAllLamentConfigurationSpawnPoints, timeDisplayed) == 0x000000, "Member 'K25CheatComponent_DBD_K25ShowAllLamentConfigurationSpawnPoints::timeDisplayed' has a wrong offset!");

// Function TheK25.K25CheatComponent.DBD_K25TriggerUncontrolledChainsOnAllSurvivors
// 0x0004 (0x0004 - 0x0000)
struct K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnAllSurvivors final
{
public:
	int32                                         numbChains;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnAllSurvivors) == 0x000004, "Wrong alignment on K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnAllSurvivors");
static_assert(sizeof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnAllSurvivors) == 0x000004, "Wrong size on K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnAllSurvivors");
static_assert(offsetof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnAllSurvivors, numbChains) == 0x000000, "Member 'K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnAllSurvivors::numbChains' has a wrong offset!");

// Function TheK25.K25CheatComponent.DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition
// 0x0010 (0x0010 - 0x0000)
struct K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition final
{
public:
	float                                         x;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         y;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         z;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         numbChains;                                        // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition) == 0x000004, "Wrong alignment on K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition");
static_assert(sizeof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition) == 0x000010, "Wrong size on K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition");
static_assert(offsetof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition, x) == 0x000000, "Member 'K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition::x' has a wrong offset!");
static_assert(offsetof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition, y) == 0x000004, "Member 'K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition::y' has a wrong offset!");
static_assert(offsetof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition, z) == 0x000008, "Member 'K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition::z' has a wrong offset!");
static_assert(offsetof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition, numbChains) == 0x00000C, "Member 'K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnClosestsSurvivorToPosition::numbChains' has a wrong offset!");

// Function TheK25.K25CheatComponent.DBD_K25TriggerUncontrolledChainsOnLocalSurvivor
// 0x0004 (0x0004 - 0x0000)
struct K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnLocalSurvivor final
{
public:
	int32                                         numbChains;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnLocalSurvivor) == 0x000004, "Wrong alignment on K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnLocalSurvivor");
static_assert(sizeof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnLocalSurvivor) == 0x000004, "Wrong size on K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnLocalSurvivor");
static_assert(offsetof(K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnLocalSurvivor, numbChains) == 0x000000, "Member 'K25CheatComponent_DBD_K25TriggerUncontrolledChainsOnLocalSurvivor::numbChains' has a wrong offset!");

// Function TheK25.K25Projectile.Cosmetic_OnProjectileDeactivated
// 0x0020 (0x0020 - 0x0000)
struct K25Projectile_Cosmetic_OnProjectileDeactivated final
{
public:
	struct FK25ProjectileDeactivationData         deactivationData;                                  // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Projectile_Cosmetic_OnProjectileDeactivated) == 0x000008, "Wrong alignment on K25Projectile_Cosmetic_OnProjectileDeactivated");
static_assert(sizeof(K25Projectile_Cosmetic_OnProjectileDeactivated) == 0x000020, "Wrong size on K25Projectile_Cosmetic_OnProjectileDeactivated");
static_assert(offsetof(K25Projectile_Cosmetic_OnProjectileDeactivated, deactivationData) == 0x000000, "Member 'K25Projectile_Cosmetic_OnProjectileDeactivated::deactivationData' has a wrong offset!");

// Function TheK25.K25Projectile.OnProjectileStopped
// 0x0090 (0x0090 - 0x0000)
struct K25Projectile_OnProjectileStopped final
{
public:
	struct FHitResult                             result;                                            // 0x0000(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Projectile_OnProjectileStopped) == 0x000004, "Wrong alignment on K25Projectile_OnProjectileStopped");
static_assert(sizeof(K25Projectile_OnProjectileStopped) == 0x000090, "Wrong size on K25Projectile_OnProjectileStopped");
static_assert(offsetof(K25Projectile_OnProjectileStopped, result) == 0x000000, "Member 'K25Projectile_OnProjectileStopped::result' has a wrong offset!");

// Function TheK25.K25Projectile.Server_RequestDisableProjectile
// 0x0001 (0x0001 - 0x0000)
struct K25Projectile_Server_RequestDisableProjectile final
{
public:
	EK25ProjectileDeactivateReason                deactivateReason;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Projectile_Server_RequestDisableProjectile) == 0x000001, "Wrong alignment on K25Projectile_Server_RequestDisableProjectile");
static_assert(sizeof(K25Projectile_Server_RequestDisableProjectile) == 0x000001, "Wrong size on K25Projectile_Server_RequestDisableProjectile");
static_assert(offsetof(K25Projectile_Server_RequestDisableProjectile, deactivateReason) == 0x000000, "Member 'K25Projectile_Server_RequestDisableProjectile::deactivateReason' has a wrong offset!");

// Function TheK25.K25Projectile.GetChainAttachmentLocation
// 0x000C (0x000C - 0x0000)
struct K25Projectile_GetChainAttachmentLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Projectile_GetChainAttachmentLocation) == 0x000004, "Wrong alignment on K25Projectile_GetChainAttachmentLocation");
static_assert(sizeof(K25Projectile_GetChainAttachmentLocation) == 0x00000C, "Wrong size on K25Projectile_GetChainAttachmentLocation");
static_assert(offsetof(K25Projectile_GetChainAttachmentLocation, ReturnValue) == 0x000000, "Member 'K25Projectile_GetChainAttachmentLocation::ReturnValue' has a wrong offset!");

// Function TheK25.K25Projectile.GetMovementComponent
// 0x0008 (0x0008 - 0x0000)
struct K25Projectile_GetMovementComponent final
{
public:
	class UDBDProjectileMovementComponent*        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Projectile_GetMovementComponent) == 0x000008, "Wrong alignment on K25Projectile_GetMovementComponent");
static_assert(sizeof(K25Projectile_GetMovementComponent) == 0x000008, "Wrong size on K25Projectile_GetMovementComponent");
static_assert(offsetof(K25Projectile_GetMovementComponent, ReturnValue) == 0x000000, "Member 'K25Projectile_GetMovementComponent::ReturnValue' has a wrong offset!");

// Function TheK25.K25ControlledProjectile.Server_ProcessPitchInput
// 0x0008 (0x0008 - 0x0000)
struct K25ControlledProjectile_Server_ProcessPitchInput final
{
public:
	float                                         deltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         scaledInput;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ControlledProjectile_Server_ProcessPitchInput) == 0x000004, "Wrong alignment on K25ControlledProjectile_Server_ProcessPitchInput");
static_assert(sizeof(K25ControlledProjectile_Server_ProcessPitchInput) == 0x000008, "Wrong size on K25ControlledProjectile_Server_ProcessPitchInput");
static_assert(offsetof(K25ControlledProjectile_Server_ProcessPitchInput, deltaTime) == 0x000000, "Member 'K25ControlledProjectile_Server_ProcessPitchInput::deltaTime' has a wrong offset!");
static_assert(offsetof(K25ControlledProjectile_Server_ProcessPitchInput, scaledInput) == 0x000004, "Member 'K25ControlledProjectile_Server_ProcessPitchInput::scaledInput' has a wrong offset!");

// Function TheK25.K25ControlledProjectile.Server_ProcessYawInput
// 0x0008 (0x0008 - 0x0000)
struct K25ControlledProjectile_Server_ProcessYawInput final
{
public:
	float                                         deltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         scaledInput;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ControlledProjectile_Server_ProcessYawInput) == 0x000004, "Wrong alignment on K25ControlledProjectile_Server_ProcessYawInput");
static_assert(sizeof(K25ControlledProjectile_Server_ProcessYawInput) == 0x000008, "Wrong size on K25ControlledProjectile_Server_ProcessYawInput");
static_assert(offsetof(K25ControlledProjectile_Server_ProcessYawInput, deltaTime) == 0x000000, "Member 'K25ControlledProjectile_Server_ProcessYawInput::deltaTime' has a wrong offset!");
static_assert(offsetof(K25ControlledProjectile_Server_ProcessYawInput, scaledInput) == 0x000004, "Member 'K25ControlledProjectile_Server_ProcessYawInput::scaledInput' has a wrong offset!");

// Function TheK25.K25Gateway.Cosmetic_SetIsGatewayPositionValid
// 0x0001 (0x0001 - 0x0000)
struct K25Gateway_Cosmetic_SetIsGatewayPositionValid final
{
public:
	bool                                          isGatewayPlacementValid;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_Cosmetic_SetIsGatewayPositionValid) == 0x000001, "Wrong alignment on K25Gateway_Cosmetic_SetIsGatewayPositionValid");
static_assert(sizeof(K25Gateway_Cosmetic_SetIsGatewayPositionValid) == 0x000001, "Wrong size on K25Gateway_Cosmetic_SetIsGatewayPositionValid");
static_assert(offsetof(K25Gateway_Cosmetic_SetIsGatewayPositionValid, isGatewayPlacementValid) == 0x000000, "Member 'K25Gateway_Cosmetic_SetIsGatewayPositionValid::isGatewayPlacementValid' has a wrong offset!");

// Function TheK25.K25Gateway.Cosmetic_SetKillerVisualVisibility
// 0x0001 (0x0001 - 0x0000)
struct K25Gateway_Cosmetic_SetKillerVisualVisibility final
{
public:
	bool                                          isVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_Cosmetic_SetKillerVisualVisibility) == 0x000001, "Wrong alignment on K25Gateway_Cosmetic_SetKillerVisualVisibility");
static_assert(sizeof(K25Gateway_Cosmetic_SetKillerVisualVisibility) == 0x000001, "Wrong size on K25Gateway_Cosmetic_SetKillerVisualVisibility");
static_assert(offsetof(K25Gateway_Cosmetic_SetKillerVisualVisibility, isVisible) == 0x000000, "Member 'K25Gateway_Cosmetic_SetKillerVisualVisibility::isVisible' has a wrong offset!");

// Function TheK25.K25Gateway.Cosmetic_TriggerGatewayPossessedEffects
// 0x0004 (0x0004 - 0x0000)
struct K25Gateway_Cosmetic_TriggerGatewayPossessedEffects final
{
public:
	float                                         transitionTime;                                    // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_Cosmetic_TriggerGatewayPossessedEffects) == 0x000004, "Wrong alignment on K25Gateway_Cosmetic_TriggerGatewayPossessedEffects");
static_assert(sizeof(K25Gateway_Cosmetic_TriggerGatewayPossessedEffects) == 0x000004, "Wrong size on K25Gateway_Cosmetic_TriggerGatewayPossessedEffects");
static_assert(offsetof(K25Gateway_Cosmetic_TriggerGatewayPossessedEffects, transitionTime) == 0x000000, "Member 'K25Gateway_Cosmetic_TriggerGatewayPossessedEffects::transitionTime' has a wrong offset!");

// Function TheK25.K25Gateway.Multicast_SetGatewayLocation
// 0x000C (0x000C - 0x0000)
struct K25Gateway_Multicast_SetGatewayLocation final
{
public:
	struct FVector                                possessionLocation;                                // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_Multicast_SetGatewayLocation) == 0x000004, "Wrong alignment on K25Gateway_Multicast_SetGatewayLocation");
static_assert(sizeof(K25Gateway_Multicast_SetGatewayLocation) == 0x00000C, "Wrong size on K25Gateway_Multicast_SetGatewayLocation");
static_assert(offsetof(K25Gateway_Multicast_SetGatewayLocation, possessionLocation) == 0x000000, "Member 'K25Gateway_Multicast_SetGatewayLocation::possessionLocation' has a wrong offset!");

// Function TheK25.K25Gateway.Multicast_SetGatewayOrientation
// 0x000C (0x000C - 0x0000)
struct K25Gateway_Multicast_SetGatewayOrientation final
{
public:
	struct FRotator                               rotation;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_Multicast_SetGatewayOrientation) == 0x000004, "Wrong alignment on K25Gateway_Multicast_SetGatewayOrientation");
static_assert(sizeof(K25Gateway_Multicast_SetGatewayOrientation) == 0x00000C, "Wrong size on K25Gateway_Multicast_SetGatewayOrientation");
static_assert(offsetof(K25Gateway_Multicast_SetGatewayOrientation, rotation) == 0x000000, "Member 'K25Gateway_Multicast_SetGatewayOrientation::rotation' has a wrong offset!");

// Function TheK25.K25Gateway.Multicast_SetGatewayTargetLocation
// 0x0010 (0x0010 - 0x0000)
struct K25Gateway_Multicast_SetGatewayTargetLocation final
{
public:
	struct FVector                                targetLocation;                                    // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isValidLocation;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25Gateway_Multicast_SetGatewayTargetLocation) == 0x000004, "Wrong alignment on K25Gateway_Multicast_SetGatewayTargetLocation");
static_assert(sizeof(K25Gateway_Multicast_SetGatewayTargetLocation) == 0x000010, "Wrong size on K25Gateway_Multicast_SetGatewayTargetLocation");
static_assert(offsetof(K25Gateway_Multicast_SetGatewayTargetLocation, targetLocation) == 0x000000, "Member 'K25Gateway_Multicast_SetGatewayTargetLocation::targetLocation' has a wrong offset!");
static_assert(offsetof(K25Gateway_Multicast_SetGatewayTargetLocation, isValidLocation) == 0x00000C, "Member 'K25Gateway_Multicast_SetGatewayTargetLocation::isValidLocation' has a wrong offset!");

// Function TheK25.K25Gateway.Server_SetGatewayOrientation
// 0x000C (0x000C - 0x0000)
struct K25Gateway_Server_SetGatewayOrientation final
{
public:
	struct FRotator                               rotation;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_Server_SetGatewayOrientation) == 0x000004, "Wrong alignment on K25Gateway_Server_SetGatewayOrientation");
static_assert(sizeof(K25Gateway_Server_SetGatewayOrientation) == 0x00000C, "Wrong size on K25Gateway_Server_SetGatewayOrientation");
static_assert(offsetof(K25Gateway_Server_SetGatewayOrientation, rotation) == 0x000000, "Member 'K25Gateway_Server_SetGatewayOrientation::rotation' has a wrong offset!");

// Function TheK25.K25Gateway.Server_SetGatewayTargetLocation
// 0x0010 (0x0010 - 0x0000)
struct K25Gateway_Server_SetGatewayTargetLocation final
{
public:
	struct FVector                                targetLocation;                                    // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isValidLocation;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25Gateway_Server_SetGatewayTargetLocation) == 0x000004, "Wrong alignment on K25Gateway_Server_SetGatewayTargetLocation");
static_assert(sizeof(K25Gateway_Server_SetGatewayTargetLocation) == 0x000010, "Wrong size on K25Gateway_Server_SetGatewayTargetLocation");
static_assert(offsetof(K25Gateway_Server_SetGatewayTargetLocation, targetLocation) == 0x000000, "Member 'K25Gateway_Server_SetGatewayTargetLocation::targetLocation' has a wrong offset!");
static_assert(offsetof(K25Gateway_Server_SetGatewayTargetLocation, isValidLocation) == 0x00000C, "Member 'K25Gateway_Server_SetGatewayTargetLocation::isValidLocation' has a wrong offset!");

// Function TheK25.K25Gateway.Server_SetIsGatewayBeingPositionned
// 0x0001 (0x0001 - 0x0000)
struct K25Gateway_Server_SetIsGatewayBeingPositionned final
{
public:
	bool                                          isBeingPositionned;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_Server_SetIsGatewayBeingPositionned) == 0x000001, "Wrong alignment on K25Gateway_Server_SetIsGatewayBeingPositionned");
static_assert(sizeof(K25Gateway_Server_SetIsGatewayBeingPositionned) == 0x000001, "Wrong size on K25Gateway_Server_SetIsGatewayBeingPositionned");
static_assert(offsetof(K25Gateway_Server_SetIsGatewayBeingPositionned, isBeingPositionned) == 0x000000, "Member 'K25Gateway_Server_SetIsGatewayBeingPositionned::isBeingPositionned' has a wrong offset!");

// Function TheK25.K25Gateway.Server_StartGatewayPossession
// 0x0018 (0x0018 - 0x0000)
struct K25Gateway_Server_StartGatewayPossession final
{
public:
	struct FVector                                possessionLocation;                                // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               gatewayRotation;                                   // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_Server_StartGatewayPossession) == 0x000004, "Wrong alignment on K25Gateway_Server_StartGatewayPossession");
static_assert(sizeof(K25Gateway_Server_StartGatewayPossession) == 0x000018, "Wrong size on K25Gateway_Server_StartGatewayPossession");
static_assert(offsetof(K25Gateway_Server_StartGatewayPossession, possessionLocation) == 0x000000, "Member 'K25Gateway_Server_StartGatewayPossession::possessionLocation' has a wrong offset!");
static_assert(offsetof(K25Gateway_Server_StartGatewayPossession, gatewayRotation) == 0x00000C, "Member 'K25Gateway_Server_StartGatewayPossession::gatewayRotation' has a wrong offset!");

// Function TheK25.K25Gateway.GetCameraComponent
// 0x0008 (0x0008 - 0x0000)
struct K25Gateway_GetCameraComponent final
{
public:
	class UCameraComponent*                       ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_GetCameraComponent) == 0x000008, "Wrong alignment on K25Gateway_GetCameraComponent");
static_assert(sizeof(K25Gateway_GetCameraComponent) == 0x000008, "Wrong size on K25Gateway_GetCameraComponent");
static_assert(offsetof(K25Gateway_GetCameraComponent, ReturnValue) == 0x000000, "Member 'K25Gateway_GetCameraComponent::ReturnValue' has a wrong offset!");

// Function TheK25.K25Gateway.IsGatewayPossessed
// 0x0001 (0x0001 - 0x0000)
struct K25Gateway_IsGatewayPossessed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Gateway_IsGatewayPossessed) == 0x000001, "Wrong alignment on K25Gateway_IsGatewayPossessed");
static_assert(sizeof(K25Gateway_IsGatewayPossessed) == 0x000001, "Wrong size on K25Gateway_IsGatewayPossessed");
static_assert(offsetof(K25Gateway_IsGatewayPossessed, ReturnValue) == 0x000000, "Member 'K25Gateway_IsGatewayPossessed::ReturnValue' has a wrong offset!");

// Function TheK25.K25LamentConfigurationTeleportIndicator.Cosmetic_UpdateIndicatorVisibility
// 0x0001 (0x0001 - 0x0000)
struct K25LamentConfigurationTeleportIndicator_Cosmetic_UpdateIndicatorVisibility final
{
public:
	bool                                          isVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25LamentConfigurationTeleportIndicator_Cosmetic_UpdateIndicatorVisibility) == 0x000001, "Wrong alignment on K25LamentConfigurationTeleportIndicator_Cosmetic_UpdateIndicatorVisibility");
static_assert(sizeof(K25LamentConfigurationTeleportIndicator_Cosmetic_UpdateIndicatorVisibility) == 0x000001, "Wrong size on K25LamentConfigurationTeleportIndicator_Cosmetic_UpdateIndicatorVisibility");
static_assert(offsetof(K25LamentConfigurationTeleportIndicator_Cosmetic_UpdateIndicatorVisibility, isVisible) == 0x000000, "Member 'K25LamentConfigurationTeleportIndicator_Cosmetic_UpdateIndicatorVisibility::isVisible' has a wrong offset!");

// Function TheK25.K25P01.Authority_OnBlockTimerDone
// 0x0008 (0x0008 - 0x0000)
struct K25P01_Authority_OnBlockTimerDone final
{
public:
	class AGenerator*                             generator;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P01_Authority_OnBlockTimerDone) == 0x000008, "Wrong alignment on K25P01_Authority_OnBlockTimerDone");
static_assert(sizeof(K25P01_Authority_OnBlockTimerDone) == 0x000008, "Wrong size on K25P01_Authority_OnBlockTimerDone");
static_assert(offsetof(K25P01_Authority_OnBlockTimerDone, generator) == 0x000000, "Member 'K25P01_Authority_OnBlockTimerDone::generator' has a wrong offset!");

// Function TheK25.K25P02.GetTotemAuraRevealRadius
// 0x0004 (0x0004 - 0x0000)
struct K25P02_GetTotemAuraRevealRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P02_GetTotemAuraRevealRadius) == 0x000004, "Wrong alignment on K25P02_GetTotemAuraRevealRadius");
static_assert(sizeof(K25P02_GetTotemAuraRevealRadius) == 0x000004, "Wrong size on K25P02_GetTotemAuraRevealRadius");
static_assert(offsetof(K25P02_GetTotemAuraRevealRadius, ReturnValue) == 0x000000, "Member 'K25P02_GetTotemAuraRevealRadius::ReturnValue' has a wrong offset!");

// Function TheK25.K25P02.GetTotemBlockerDuration
// 0x0004 (0x0004 - 0x0000)
struct K25P02_GetTotemBlockerDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P02_GetTotemBlockerDuration) == 0x000004, "Wrong alignment on K25P02_GetTotemBlockerDuration");
static_assert(sizeof(K25P02_GetTotemBlockerDuration) == 0x000004, "Wrong size on K25P02_GetTotemBlockerDuration");
static_assert(offsetof(K25P02_GetTotemBlockerDuration, ReturnValue) == 0x000000, "Member 'K25P02_GetTotemBlockerDuration::ReturnValue' has a wrong offset!");

// Function TheK25.K25P02.GetTotemBlockerHasLifetime
// 0x0001 (0x0001 - 0x0000)
struct K25P02_GetTotemBlockerHasLifetime final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P02_GetTotemBlockerHasLifetime) == 0x000001, "Wrong alignment on K25P02_GetTotemBlockerHasLifetime");
static_assert(sizeof(K25P02_GetTotemBlockerHasLifetime) == 0x000001, "Wrong size on K25P02_GetTotemBlockerHasLifetime");
static_assert(offsetof(K25P02_GetTotemBlockerHasLifetime, ReturnValue) == 0x000000, "Member 'K25P02_GetTotemBlockerHasLifetime::ReturnValue' has a wrong offset!");

// Function TheK25.K25P03.OnCamperUnhookedFromScourgeHook
// 0x0028 (0x0028 - 0x0000)
struct K25P03_OnCamperUnhookedFromScourgeHook final
{
public:
	struct FGameEventData                         gameEventData;                                     // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P03_OnCamperUnhookedFromScourgeHook) == 0x000008, "Wrong alignment on K25P03_OnCamperUnhookedFromScourgeHook");
static_assert(sizeof(K25P03_OnCamperUnhookedFromScourgeHook) == 0x000028, "Wrong size on K25P03_OnCamperUnhookedFromScourgeHook");
static_assert(offsetof(K25P03_OnCamperUnhookedFromScourgeHook, gameEventData) == 0x000000, "Member 'K25P03_OnCamperUnhookedFromScourgeHook::gameEventData' has a wrong offset!");

// Function TheK25.K25P03.OnDamageStateChanged
// 0x0038 (0x0038 - 0x0000)
struct K25P03_OnDamageStateChanged final
{
public:
	struct FGameplayTag                           gameplayTag;                                       // 0x0000(0x000C)(ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameEventData                         gameEventData;                                     // 0x0010(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P03_OnDamageStateChanged) == 0x000008, "Wrong alignment on K25P03_OnDamageStateChanged");
static_assert(sizeof(K25P03_OnDamageStateChanged) == 0x000038, "Wrong size on K25P03_OnDamageStateChanged");
static_assert(offsetof(K25P03_OnDamageStateChanged, gameplayTag) == 0x000000, "Member 'K25P03_OnDamageStateChanged::gameplayTag' has a wrong offset!");
static_assert(offsetof(K25P03_OnDamageStateChanged, gameEventData) == 0x000010, "Member 'K25P03_OnDamageStateChanged::gameEventData' has a wrong offset!");

// Function TheK25.K25P03.OnSurvivorRemoved
// 0x0008 (0x0008 - 0x0000)
struct K25P03_OnSurvivorRemoved final
{
public:
	class ACamperPlayer*                          survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25P03_OnSurvivorRemoved) == 0x000008, "Wrong alignment on K25P03_OnSurvivorRemoved");
static_assert(sizeof(K25P03_OnSurvivorRemoved) == 0x000008, "Wrong size on K25P03_OnSurvivorRemoved");
static_assert(offsetof(K25P03_OnSurvivorRemoved, survivor) == 0x000000, "Member 'K25P03_OnSurvivorRemoved::survivor' has a wrong offset!");

// Function TheK25.K25Power.Cosmetic_OnKillerInterruptOpenHatchSFX
// 0x0008 (0x0008 - 0x0000)
struct K25Power_Cosmetic_OnKillerInterruptOpenHatchSFX final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Power_Cosmetic_OnKillerInterruptOpenHatchSFX) == 0x000008, "Wrong alignment on K25Power_Cosmetic_OnKillerInterruptOpenHatchSFX");
static_assert(sizeof(K25Power_Cosmetic_OnKillerInterruptOpenHatchSFX) == 0x000008, "Wrong size on K25Power_Cosmetic_OnKillerInterruptOpenHatchSFX");
static_assert(offsetof(K25Power_Cosmetic_OnKillerInterruptOpenHatchSFX, killer) == 0x000000, "Member 'K25Power_Cosmetic_OnKillerInterruptOpenHatchSFX::killer' has a wrong offset!");

// Function TheK25.K25Power.Cosmetic_OnKillerInterruptSFX
// 0x0008 (0x0008 - 0x0000)
struct K25Power_Cosmetic_OnKillerInterruptSFX final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Power_Cosmetic_OnKillerInterruptSFX) == 0x000008, "Wrong alignment on K25Power_Cosmetic_OnKillerInterruptSFX");
static_assert(sizeof(K25Power_Cosmetic_OnKillerInterruptSFX) == 0x000008, "Wrong size on K25Power_Cosmetic_OnKillerInterruptSFX");
static_assert(offsetof(K25Power_Cosmetic_OnKillerInterruptSFX, killer) == 0x000000, "Member 'K25Power_Cosmetic_OnKillerInterruptSFX::killer' has a wrong offset!");

// Function TheK25.K25Power.OnKillerAdded
// 0x0008 (0x0008 - 0x0000)
struct K25Power_OnKillerAdded final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Power_OnKillerAdded) == 0x000008, "Wrong alignment on K25Power_OnKillerAdded");
static_assert(sizeof(K25Power_OnKillerAdded) == 0x000008, "Wrong size on K25Power_OnKillerAdded");
static_assert(offsetof(K25Power_OnKillerAdded, killer) == 0x000000, "Member 'K25Power_OnKillerAdded::killer' has a wrong offset!");

// Function TheK25.K25Power.OnSurvivorAdded
// 0x0010 (0x0010 - 0x0000)
struct K25Power_OnSurvivorAdded final
{
public:
	class ACamperPlayer*                          survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASlasherPlayer*                         killer;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Power_OnSurvivorAdded) == 0x000008, "Wrong alignment on K25Power_OnSurvivorAdded");
static_assert(sizeof(K25Power_OnSurvivorAdded) == 0x000010, "Wrong size on K25Power_OnSurvivorAdded");
static_assert(offsetof(K25Power_OnSurvivorAdded, survivor) == 0x000000, "Member 'K25Power_OnSurvivorAdded::survivor' has a wrong offset!");
static_assert(offsetof(K25Power_OnSurvivorAdded, killer) == 0x000008, "Member 'K25Power_OnSurvivorAdded::killer' has a wrong offset!");

// Function TheK25.K25ProjectileReplicationComponent.Multicast_DeactivateProjectile
// 0x0028 (0x0028 - 0x0000)
struct K25ProjectileReplicationComponent_Multicast_DeactivateProjectile final
{
public:
	class AK25Projectile*                         projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FK25ProjectileDeactivationData         deactivationData;                                  // 0x0008(0x0020)(ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25ProjectileReplicationComponent_Multicast_DeactivateProjectile) == 0x000008, "Wrong alignment on K25ProjectileReplicationComponent_Multicast_DeactivateProjectile");
static_assert(sizeof(K25ProjectileReplicationComponent_Multicast_DeactivateProjectile) == 0x000028, "Wrong size on K25ProjectileReplicationComponent_Multicast_DeactivateProjectile");
static_assert(offsetof(K25ProjectileReplicationComponent_Multicast_DeactivateProjectile, projectile) == 0x000000, "Member 'K25ProjectileReplicationComponent_Multicast_DeactivateProjectile::projectile' has a wrong offset!");
static_assert(offsetof(K25ProjectileReplicationComponent_Multicast_DeactivateProjectile, deactivationData) == 0x000008, "Member 'K25ProjectileReplicationComponent_Multicast_DeactivateProjectile::deactivationData' has a wrong offset!");

// Function TheK25.K25ProjectileReplicationComponent.Multicast_SetAttachedChain
// 0x0030 (0x0030 - 0x0000)
struct K25ProjectileReplicationComponent_Multicast_SetAttachedChain final
{
public:
	class AK25Projectile*                         projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25Chain*                              chainToAttach;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLaunchInfo                            launchInfo;                                        // 0x0010(0x001C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25ProjectileReplicationComponent_Multicast_SetAttachedChain) == 0x000008, "Wrong alignment on K25ProjectileReplicationComponent_Multicast_SetAttachedChain");
static_assert(sizeof(K25ProjectileReplicationComponent_Multicast_SetAttachedChain) == 0x000030, "Wrong size on K25ProjectileReplicationComponent_Multicast_SetAttachedChain");
static_assert(offsetof(K25ProjectileReplicationComponent_Multicast_SetAttachedChain, projectile) == 0x000000, "Member 'K25ProjectileReplicationComponent_Multicast_SetAttachedChain::projectile' has a wrong offset!");
static_assert(offsetof(K25ProjectileReplicationComponent_Multicast_SetAttachedChain, chainToAttach) == 0x000008, "Member 'K25ProjectileReplicationComponent_Multicast_SetAttachedChain::chainToAttach' has a wrong offset!");
static_assert(offsetof(K25ProjectileReplicationComponent_Multicast_SetAttachedChain, launchInfo) == 0x000010, "Member 'K25ProjectileReplicationComponent_Multicast_SetAttachedChain::launchInfo' has a wrong offset!");

// Function TheK25.K25SolveLamentConfigurationInteraction.Authority_OnSkillCheckResponseAuthority
// 0x0018 (0x0018 - 0x0000)
struct K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority final
{
public:
	bool                                          success;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bonus;                                             // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          triggerLoudNoise;                                  // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         type;                                              // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority) == 0x000008, "Wrong alignment on K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority");
static_assert(sizeof(K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority) == 0x000018, "Wrong size on K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority");
static_assert(offsetof(K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority, success) == 0x000000, "Member 'K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority::success' has a wrong offset!");
static_assert(offsetof(K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority, bonus) == 0x000001, "Member 'K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority::bonus' has a wrong offset!");
static_assert(offsetof(K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority, player) == 0x000008, "Member 'K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority::player' has a wrong offset!");
static_assert(offsetof(K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority, triggerLoudNoise) == 0x000010, "Member 'K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority::triggerLoudNoise' has a wrong offset!");
static_assert(offsetof(K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority, type) == 0x000011, "Member 'K25SolveLamentConfigurationInteraction_Authority_OnSkillCheckResponseAuthority::type' has a wrong offset!");

// Function TheK25.K25SolveLamentConfigurationInteraction.Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX
// 0x0008 (0x0008 - 0x0000)
struct K25SolveLamentConfigurationInteraction_Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SolveLamentConfigurationInteraction_Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX) == 0x000008, "Wrong alignment on K25SolveLamentConfigurationInteraction_Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX");
static_assert(sizeof(K25SolveLamentConfigurationInteraction_Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX) == 0x000008, "Wrong size on K25SolveLamentConfigurationInteraction_Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX");
static_assert(offsetof(K25SolveLamentConfigurationInteraction_Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX, killer) == 0x000000, "Member 'K25SolveLamentConfigurationInteraction_Cosmetic_TriggerKillerStoppedInteractionViaAttackSFX::killer' has a wrong offset!");

// Function TheK25.K25SolveLamentConfigurationInteraction.Multicast_TriggerKillerStoppedInteractionViaAttackSFX
// 0x0008 (0x0008 - 0x0000)
struct K25SolveLamentConfigurationInteraction_Multicast_TriggerKillerStoppedInteractionViaAttackSFX final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SolveLamentConfigurationInteraction_Multicast_TriggerKillerStoppedInteractionViaAttackSFX) == 0x000008, "Wrong alignment on K25SolveLamentConfigurationInteraction_Multicast_TriggerKillerStoppedInteractionViaAttackSFX");
static_assert(sizeof(K25SolveLamentConfigurationInteraction_Multicast_TriggerKillerStoppedInteractionViaAttackSFX) == 0x000008, "Wrong size on K25SolveLamentConfigurationInteraction_Multicast_TriggerKillerStoppedInteractionViaAttackSFX");
static_assert(offsetof(K25SolveLamentConfigurationInteraction_Multicast_TriggerKillerStoppedInteractionViaAttackSFX, killer) == 0x000000, "Member 'K25SolveLamentConfigurationInteraction_Multicast_TriggerKillerStoppedInteractionViaAttackSFX::killer' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentAnchor.Cosmetic_OnChainAttached
// 0x0008 (0x0008 - 0x0000)
struct K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainAttached final
{
public:
	class AK25Chain*                              chainToAttach;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainAttached) == 0x000008, "Wrong alignment on K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainAttached");
static_assert(sizeof(K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainAttached) == 0x000008, "Wrong size on K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainAttached");
static_assert(offsetof(K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainAttached, chainToAttach) == 0x000000, "Member 'K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainAttached::chainToAttach' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentAnchor.Cosmetic_OnChainDetached
// 0x0008 (0x0008 - 0x0000)
struct K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainDetached final
{
public:
	class AK25Chain*                              chainToDetach;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainDetached) == 0x000008, "Wrong alignment on K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainDetached");
static_assert(sizeof(K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainDetached) == 0x000008, "Wrong size on K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainDetached");
static_assert(offsetof(K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainDetached, chainToDetach) == 0x000000, "Member 'K25SurvivorChainAttachmentAnchor_Cosmetic_OnChainDetached::chainToDetach' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentAnchor.GetChainAttachmentData
// 0x0028 (0x0028 - 0x0000)
struct K25SurvivorChainAttachmentAnchor_GetChainAttachmentData final
{
public:
	struct FK25SurvivorChainAttachmentData        ReturnValue;                                       // 0x0000(0x0028)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentAnchor_GetChainAttachmentData) == 0x000008, "Wrong alignment on K25SurvivorChainAttachmentAnchor_GetChainAttachmentData");
static_assert(sizeof(K25SurvivorChainAttachmentAnchor_GetChainAttachmentData) == 0x000028, "Wrong size on K25SurvivorChainAttachmentAnchor_GetChainAttachmentData");
static_assert(offsetof(K25SurvivorChainAttachmentAnchor_GetChainAttachmentData, ReturnValue) == 0x000000, "Member 'K25SurvivorChainAttachmentAnchor_GetChainAttachmentData::ReturnValue' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentAnchor.GetChainAttachmentLocation
// 0x000C (0x000C - 0x0000)
struct K25SurvivorChainAttachmentAnchor_GetChainAttachmentLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentAnchor_GetChainAttachmentLocation) == 0x000004, "Wrong alignment on K25SurvivorChainAttachmentAnchor_GetChainAttachmentLocation");
static_assert(sizeof(K25SurvivorChainAttachmentAnchor_GetChainAttachmentLocation) == 0x00000C, "Wrong size on K25SurvivorChainAttachmentAnchor_GetChainAttachmentLocation");
static_assert(offsetof(K25SurvivorChainAttachmentAnchor_GetChainAttachmentLocation, ReturnValue) == 0x000000, "Member 'K25SurvivorChainAttachmentAnchor_GetChainAttachmentLocation::ReturnValue' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentAnchor.GetChainPullDirectionAngle
// 0x0004 (0x0004 - 0x0000)
struct K25SurvivorChainAttachmentAnchor_GetChainPullDirectionAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentAnchor_GetChainPullDirectionAngle) == 0x000004, "Wrong alignment on K25SurvivorChainAttachmentAnchor_GetChainPullDirectionAngle");
static_assert(sizeof(K25SurvivorChainAttachmentAnchor_GetChainPullDirectionAngle) == 0x000004, "Wrong size on K25SurvivorChainAttachmentAnchor_GetChainPullDirectionAngle");
static_assert(offsetof(K25SurvivorChainAttachmentAnchor_GetChainPullDirectionAngle, ReturnValue) == 0x000000, "Member 'K25SurvivorChainAttachmentAnchor_GetChainPullDirectionAngle::ReturnValue' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentAnchor.GetChainsPullDirection
// 0x000C (0x000C - 0x0000)
struct K25SurvivorChainAttachmentAnchor_GetChainsPullDirection final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentAnchor_GetChainsPullDirection) == 0x000004, "Wrong alignment on K25SurvivorChainAttachmentAnchor_GetChainsPullDirection");
static_assert(sizeof(K25SurvivorChainAttachmentAnchor_GetChainsPullDirection) == 0x00000C, "Wrong size on K25SurvivorChainAttachmentAnchor_GetChainsPullDirection");
static_assert(offsetof(K25SurvivorChainAttachmentAnchor_GetChainsPullDirection, ReturnValue) == 0x000000, "Member 'K25SurvivorChainAttachmentAnchor_GetChainsPullDirection::ReturnValue' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentAnchor.GetChainsPullLocation
// 0x000C (0x000C - 0x0000)
struct K25SurvivorChainAttachmentAnchor_GetChainsPullLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentAnchor_GetChainsPullLocation) == 0x000004, "Wrong alignment on K25SurvivorChainAttachmentAnchor_GetChainsPullLocation");
static_assert(sizeof(K25SurvivorChainAttachmentAnchor_GetChainsPullLocation) == 0x00000C, "Wrong size on K25SurvivorChainAttachmentAnchor_GetChainsPullLocation");
static_assert(offsetof(K25SurvivorChainAttachmentAnchor_GetChainsPullLocation, ReturnValue) == 0x000000, "Member 'K25SurvivorChainAttachmentAnchor_GetChainsPullLocation::ReturnValue' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentAnchor.GetNumberOfChainsAttached
// 0x0004 (0x0004 - 0x0000)
struct K25SurvivorChainAttachmentAnchor_GetNumberOfChainsAttached final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentAnchor_GetNumberOfChainsAttached) == 0x000004, "Wrong alignment on K25SurvivorChainAttachmentAnchor_GetNumberOfChainsAttached");
static_assert(sizeof(K25SurvivorChainAttachmentAnchor_GetNumberOfChainsAttached) == 0x000004, "Wrong size on K25SurvivorChainAttachmentAnchor_GetNumberOfChainsAttached");
static_assert(offsetof(K25SurvivorChainAttachmentAnchor_GetNumberOfChainsAttached, ReturnValue) == 0x000000, "Member 'K25SurvivorChainAttachmentAnchor_GetNumberOfChainsAttached::ReturnValue' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentComponent.Cosmetic_TriggerHitSurvivorInExitAreaSFX
// 0x0008 (0x0008 - 0x0000)
struct K25SurvivorChainAttachmentComponent_Cosmetic_TriggerHitSurvivorInExitAreaSFX final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentComponent_Cosmetic_TriggerHitSurvivorInExitAreaSFX) == 0x000008, "Wrong alignment on K25SurvivorChainAttachmentComponent_Cosmetic_TriggerHitSurvivorInExitAreaSFX");
static_assert(sizeof(K25SurvivorChainAttachmentComponent_Cosmetic_TriggerHitSurvivorInExitAreaSFX) == 0x000008, "Wrong size on K25SurvivorChainAttachmentComponent_Cosmetic_TriggerHitSurvivorInExitAreaSFX");
static_assert(offsetof(K25SurvivorChainAttachmentComponent_Cosmetic_TriggerHitSurvivorInExitAreaSFX, killer) == 0x000000, "Member 'K25SurvivorChainAttachmentComponent_Cosmetic_TriggerHitSurvivorInExitAreaSFX::killer' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentComponent.Multicast_TriggerHitSurvivorInExitAreaSFX
// 0x0008 (0x0008 - 0x0000)
struct K25SurvivorChainAttachmentComponent_Multicast_TriggerHitSurvivorInExitAreaSFX final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentComponent_Multicast_TriggerHitSurvivorInExitAreaSFX) == 0x000008, "Wrong alignment on K25SurvivorChainAttachmentComponent_Multicast_TriggerHitSurvivorInExitAreaSFX");
static_assert(sizeof(K25SurvivorChainAttachmentComponent_Multicast_TriggerHitSurvivorInExitAreaSFX) == 0x000008, "Wrong size on K25SurvivorChainAttachmentComponent_Multicast_TriggerHitSurvivorInExitAreaSFX");
static_assert(offsetof(K25SurvivorChainAttachmentComponent_Multicast_TriggerHitSurvivorInExitAreaSFX, killer) == 0x000000, "Member 'K25SurvivorChainAttachmentComponent_Multicast_TriggerHitSurvivorInExitAreaSFX::killer' has a wrong offset!");

// Function TheK25.K25SurvivorChainAttachmentComponent.GetFirstChainToRelease
// 0x0008 (0x0008 - 0x0000)
struct K25SurvivorChainAttachmentComponent_GetFirstChainToRelease final
{
public:
	class AK25Chain*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainAttachmentComponent_GetFirstChainToRelease) == 0x000008, "Wrong alignment on K25SurvivorChainAttachmentComponent_GetFirstChainToRelease");
static_assert(sizeof(K25SurvivorChainAttachmentComponent_GetFirstChainToRelease) == 0x000008, "Wrong size on K25SurvivorChainAttachmentComponent_GetFirstChainToRelease");
static_assert(offsetof(K25SurvivorChainAttachmentComponent_GetFirstChainToRelease, ReturnValue) == 0x000000, "Member 'K25SurvivorChainAttachmentComponent_GetFirstChainToRelease::ReturnValue' has a wrong offset!");

// Function TheK25.K25SurvivorChainHuntEffectsComponent.GetOwningSurvivor
// 0x0008 (0x0008 - 0x0000)
struct K25SurvivorChainHuntEffectsComponent_GetOwningSurvivor final
{
public:
	class ACamperPlayer*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainHuntEffectsComponent_GetOwningSurvivor) == 0x000008, "Wrong alignment on K25SurvivorChainHuntEffectsComponent_GetOwningSurvivor");
static_assert(sizeof(K25SurvivorChainHuntEffectsComponent_GetOwningSurvivor) == 0x000008, "Wrong size on K25SurvivorChainHuntEffectsComponent_GetOwningSurvivor");
static_assert(offsetof(K25SurvivorChainHuntEffectsComponent_GetOwningSurvivor, ReturnValue) == 0x000000, "Member 'K25SurvivorChainHuntEffectsComponent_GetOwningSurvivor::ReturnValue' has a wrong offset!");

// Function TheK25.K25SurvivorChainTargetterComponent.Authority_OnSurvivorHealthStateChanged
// 0x0002 (0x0002 - 0x0000)
struct K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged final
{
public:
	ECamperDamageState                            oldDamageState;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECamperDamageState                            currentDamageState;                                // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged) == 0x000001, "Wrong alignment on K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged");
static_assert(sizeof(K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged) == 0x000002, "Wrong size on K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged");
static_assert(offsetof(K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged, oldDamageState) == 0x000000, "Member 'K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged::oldDamageState' has a wrong offset!");
static_assert(offsetof(K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged, currentDamageState) == 0x000001, "Member 'K25SurvivorChainTargetterComponent_Authority_OnSurvivorHealthStateChanged::currentDamageState' has a wrong offset!");

// Function TheK25.K25SurvivorChainTargetterComponent.Multicast_DebugPositionFind
// 0x0038 (0x0038 - 0x0000)
struct K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind final
{
public:
	struct FVector                                startSweepPosition;                                // 0x0000(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                endSweepPosition;                                  // 0x000C(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          hasFoundPosition;                                  // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                foundPosition;                                     // 0x001C(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          hasFoundCollision;                                 // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                collisionPosition;                                 // 0x002C(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind) == 0x000004, "Wrong alignment on K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind");
static_assert(sizeof(K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind) == 0x000038, "Wrong size on K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind");
static_assert(offsetof(K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind, startSweepPosition) == 0x000000, "Member 'K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind::startSweepPosition' has a wrong offset!");
static_assert(offsetof(K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind, endSweepPosition) == 0x00000C, "Member 'K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind::endSweepPosition' has a wrong offset!");
static_assert(offsetof(K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind, hasFoundPosition) == 0x000018, "Member 'K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind::hasFoundPosition' has a wrong offset!");
static_assert(offsetof(K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind, foundPosition) == 0x00001C, "Member 'K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind::foundPosition' has a wrong offset!");
static_assert(offsetof(K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind, hasFoundCollision) == 0x000028, "Member 'K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind::hasFoundCollision' has a wrong offset!");
static_assert(offsetof(K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind, collisionPosition) == 0x00002C, "Member 'K25SurvivorChainTargetterComponent_Multicast_DebugPositionFind::collisionPosition' has a wrong offset!");

// Function TheK25.K25TeleportInteraction.Cosmetic_TeleportAbortedEffects
// 0x0008 (0x0008 - 0x0000)
struct K25TeleportInteraction_Cosmetic_TeleportAbortedEffects final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25TeleportInteraction_Cosmetic_TeleportAbortedEffects) == 0x000008, "Wrong alignment on K25TeleportInteraction_Cosmetic_TeleportAbortedEffects");
static_assert(sizeof(K25TeleportInteraction_Cosmetic_TeleportAbortedEffects) == 0x000008, "Wrong size on K25TeleportInteraction_Cosmetic_TeleportAbortedEffects");
static_assert(offsetof(K25TeleportInteraction_Cosmetic_TeleportAbortedEffects, killer) == 0x000000, "Member 'K25TeleportInteraction_Cosmetic_TeleportAbortedEffects::killer' has a wrong offset!");

// Function TheK25.K25TeleportInteraction.Cosmetic_TeleportEndEffects
// 0x0008 (0x0008 - 0x0000)
struct K25TeleportInteraction_Cosmetic_TeleportEndEffects final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25TeleportInteraction_Cosmetic_TeleportEndEffects) == 0x000008, "Wrong alignment on K25TeleportInteraction_Cosmetic_TeleportEndEffects");
static_assert(sizeof(K25TeleportInteraction_Cosmetic_TeleportEndEffects) == 0x000008, "Wrong size on K25TeleportInteraction_Cosmetic_TeleportEndEffects");
static_assert(offsetof(K25TeleportInteraction_Cosmetic_TeleportEndEffects, killer) == 0x000000, "Member 'K25TeleportInteraction_Cosmetic_TeleportEndEffects::killer' has a wrong offset!");

// Function TheK25.K25TeleportInteraction.Cosmetic_TeleportStartEffects
// 0x0008 (0x0008 - 0x0000)
struct K25TeleportInteraction_Cosmetic_TeleportStartEffects final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25TeleportInteraction_Cosmetic_TeleportStartEffects) == 0x000008, "Wrong alignment on K25TeleportInteraction_Cosmetic_TeleportStartEffects");
static_assert(sizeof(K25TeleportInteraction_Cosmetic_TeleportStartEffects) == 0x000008, "Wrong size on K25TeleportInteraction_Cosmetic_TeleportStartEffects");
static_assert(offsetof(K25TeleportInteraction_Cosmetic_TeleportStartEffects, killer) == 0x000000, "Member 'K25TeleportInteraction_Cosmetic_TeleportStartEffects::killer' has a wrong offset!");

// Function TheK25.K25TeleportInteraction.Multicast_InitializeHusk
// 0x0018 (0x0018 - 0x0000)
struct K25TeleportInteraction_Multicast_InitializeHusk final
{
public:
	struct FVector                                location;                                          // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               rotation;                                          // 0x000C(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25TeleportInteraction_Multicast_InitializeHusk) == 0x000004, "Wrong alignment on K25TeleportInteraction_Multicast_InitializeHusk");
static_assert(sizeof(K25TeleportInteraction_Multicast_InitializeHusk) == 0x000018, "Wrong size on K25TeleportInteraction_Multicast_InitializeHusk");
static_assert(offsetof(K25TeleportInteraction_Multicast_InitializeHusk, location) == 0x000000, "Member 'K25TeleportInteraction_Multicast_InitializeHusk::location' has a wrong offset!");
static_assert(offsetof(K25TeleportInteraction_Multicast_InitializeHusk, rotation) == 0x00000C, "Member 'K25TeleportInteraction_Multicast_InitializeHusk::rotation' has a wrong offset!");

// Function TheK25.K25TeleportInteraction.Multicast_TeleportKillerToTargetPosition
// 0x0020 (0x0020 - 0x0000)
struct K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                location;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               rotation;                                          // 0x0014(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition) == 0x000008, "Wrong alignment on K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition");
static_assert(sizeof(K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition) == 0x000020, "Wrong size on K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition");
static_assert(offsetof(K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition, killer) == 0x000000, "Member 'K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition::killer' has a wrong offset!");
static_assert(offsetof(K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition, location) == 0x000008, "Member 'K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition::location' has a wrong offset!");
static_assert(offsetof(K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition, rotation) == 0x000014, "Member 'K25TeleportInteraction_Multicast_TeleportKillerToTargetPosition::rotation' has a wrong offset!");

// Function TheK25.K25UncontrolledProjectileReplicationComponent.Multicast_LaunchProjectile
// 0x0028 (0x0028 - 0x0000)
struct K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile final
{
public:
	class AK25UncontrolledProjectile*             projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLaunchInfo                            launchInfo;                                        // 0x0008(0x001C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile) == 0x000008, "Wrong alignment on K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile");
static_assert(sizeof(K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile) == 0x000028, "Wrong size on K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile");
static_assert(offsetof(K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile, projectile) == 0x000000, "Member 'K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile::projectile' has a wrong offset!");
static_assert(offsetof(K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile, launchInfo) == 0x000008, "Member 'K25UncontrolledProjectileReplicationComponent_Multicast_LaunchProjectile::launchInfo' has a wrong offset!");

// Function TheK25.K25Utilities.GetK25ControlledProjectile
// 0x0010 (0x0010 - 0x0000)
struct K25Utilities_GetK25ControlledProjectile final
{
public:
	class UObject*                                worldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25ControlledProjectile*               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Utilities_GetK25ControlledProjectile) == 0x000008, "Wrong alignment on K25Utilities_GetK25ControlledProjectile");
static_assert(sizeof(K25Utilities_GetK25ControlledProjectile) == 0x000010, "Wrong size on K25Utilities_GetK25ControlledProjectile");
static_assert(offsetof(K25Utilities_GetK25ControlledProjectile, worldContextObject) == 0x000000, "Member 'K25Utilities_GetK25ControlledProjectile::worldContextObject' has a wrong offset!");
static_assert(offsetof(K25Utilities_GetK25ControlledProjectile, ReturnValue) == 0x000008, "Member 'K25Utilities_GetK25ControlledProjectile::ReturnValue' has a wrong offset!");

// Function TheK25.K25Utilities.GetK25Gateway
// 0x0010 (0x0010 - 0x0000)
struct K25Utilities_GetK25Gateway final
{
public:
	class UObject*                                worldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25Gateway*                            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Utilities_GetK25Gateway) == 0x000008, "Wrong alignment on K25Utilities_GetK25Gateway");
static_assert(sizeof(K25Utilities_GetK25Gateway) == 0x000010, "Wrong size on K25Utilities_GetK25Gateway");
static_assert(offsetof(K25Utilities_GetK25Gateway, worldContextObject) == 0x000000, "Member 'K25Utilities_GetK25Gateway::worldContextObject' has a wrong offset!");
static_assert(offsetof(K25Utilities_GetK25Gateway, ReturnValue) == 0x000008, "Member 'K25Utilities_GetK25Gateway::ReturnValue' has a wrong offset!");

// Function TheK25.K25Utilities.GetK25Husk
// 0x0010 (0x0010 - 0x0000)
struct K25Utilities_GetK25Husk final
{
public:
	class UObject*                                worldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25Husk*                               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Utilities_GetK25Husk) == 0x000008, "Wrong alignment on K25Utilities_GetK25Husk");
static_assert(sizeof(K25Utilities_GetK25Husk) == 0x000010, "Wrong size on K25Utilities_GetK25Husk");
static_assert(offsetof(K25Utilities_GetK25Husk, worldContextObject) == 0x000000, "Member 'K25Utilities_GetK25Husk::worldContextObject' has a wrong offset!");
static_assert(offsetof(K25Utilities_GetK25Husk, ReturnValue) == 0x000008, "Member 'K25Utilities_GetK25Husk::ReturnValue' has a wrong offset!");

// Function TheK25.K25Utilities.GetK25Power
// 0x0010 (0x0010 - 0x0000)
struct K25Utilities_GetK25Power final
{
public:
	class UObject*                                worldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK25Power*                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Utilities_GetK25Power) == 0x000008, "Wrong alignment on K25Utilities_GetK25Power");
static_assert(sizeof(K25Utilities_GetK25Power) == 0x000010, "Wrong size on K25Utilities_GetK25Power");
static_assert(offsetof(K25Utilities_GetK25Power, worldContextObject) == 0x000000, "Member 'K25Utilities_GetK25Power::worldContextObject' has a wrong offset!");
static_assert(offsetof(K25Utilities_GetK25Power, ReturnValue) == 0x000008, "Member 'K25Utilities_GetK25Power::ReturnValue' has a wrong offset!");

// Function TheK25.K25Utilities.GetLamentConfiguration
// 0x0010 (0x0010 - 0x0000)
struct K25Utilities_GetLamentConfiguration final
{
public:
	class UObject*                                worldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALamentConfiguration*                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25Utilities_GetLamentConfiguration) == 0x000008, "Wrong alignment on K25Utilities_GetLamentConfiguration");
static_assert(sizeof(K25Utilities_GetLamentConfiguration) == 0x000010, "Wrong size on K25Utilities_GetLamentConfiguration");
static_assert(offsetof(K25Utilities_GetLamentConfiguration, worldContextObject) == 0x000000, "Member 'K25Utilities_GetLamentConfiguration::worldContextObject' has a wrong offset!");
static_assert(offsetof(K25Utilities_GetLamentConfiguration, ReturnValue) == 0x000008, "Member 'K25Utilities_GetLamentConfiguration::ReturnValue' has a wrong offset!");

// Function TheK25.K25WeaponAnimInstance.OnAttackStart
// 0x0001 (0x0001 - 0x0000)
struct K25WeaponAnimInstance_OnAttackStart final
{
public:
	EAttackType                                   attackType;                                        // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K25WeaponAnimInstance_OnAttackStart) == 0x000001, "Wrong alignment on K25WeaponAnimInstance_OnAttackStart");
static_assert(sizeof(K25WeaponAnimInstance_OnAttackStart) == 0x000001, "Wrong size on K25WeaponAnimInstance_OnAttackStart");
static_assert(offsetof(K25WeaponAnimInstance_OnAttackStart, attackType) == 0x000000, "Member 'K25WeaponAnimInstance_OnAttackStart::attackType' has a wrong offset!");

// Function TheK25.LamentConfigurationChainHuntComponent.GetChainHuntProgressPercentage
// 0x0004 (0x0004 - 0x0000)
struct LamentConfigurationChainHuntComponent_GetChainHuntProgressPercentage final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LamentConfigurationChainHuntComponent_GetChainHuntProgressPercentage) == 0x000004, "Wrong alignment on LamentConfigurationChainHuntComponent_GetChainHuntProgressPercentage");
static_assert(sizeof(LamentConfigurationChainHuntComponent_GetChainHuntProgressPercentage) == 0x000004, "Wrong size on LamentConfigurationChainHuntComponent_GetChainHuntProgressPercentage");
static_assert(offsetof(LamentConfigurationChainHuntComponent_GetChainHuntProgressPercentage, ReturnValue) == 0x000000, "Member 'LamentConfigurationChainHuntComponent_GetChainHuntProgressPercentage::ReturnValue' has a wrong offset!");

// Function TheK25.S28P01.GetAuraRevealDuration
// 0x0004 (0x0004 - 0x0000)
struct S28P01_GetAuraRevealDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(S28P01_GetAuraRevealDuration) == 0x000004, "Wrong alignment on S28P01_GetAuraRevealDuration");
static_assert(sizeof(S28P01_GetAuraRevealDuration) == 0x000004, "Wrong size on S28P01_GetAuraRevealDuration");
static_assert(offsetof(S28P01_GetAuraRevealDuration, ReturnValue) == 0x000000, "Member 'S28P01_GetAuraRevealDuration::ReturnValue' has a wrong offset!");

// Function TheK25.S28P01.GetAuraRevealRange
// 0x0004 (0x0004 - 0x0000)
struct S28P01_GetAuraRevealRange final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(S28P01_GetAuraRevealRange) == 0x000004, "Wrong alignment on S28P01_GetAuraRevealRange");
static_assert(sizeof(S28P01_GetAuraRevealRange) == 0x000004, "Wrong size on S28P01_GetAuraRevealRange");
static_assert(offsetof(S28P01_GetAuraRevealRange, ReturnValue) == 0x000000, "Member 'S28P01_GetAuraRevealRange::ReturnValue' has a wrong offset!");

// Function TheK25.S28P02.CanSelfHeal
// 0x0001 (0x0001 - 0x0000)
struct S28P02_CanSelfHeal final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(S28P02_CanSelfHeal) == 0x000001, "Wrong alignment on S28P02_CanSelfHeal");
static_assert(sizeof(S28P02_CanSelfHeal) == 0x000001, "Wrong size on S28P02_CanSelfHeal");
static_assert(offsetof(S28P02_CanSelfHeal, ReturnValue) == 0x000000, "Member 'S28P02_CanSelfHeal::ReturnValue' has a wrong offset!");

// Function TheK25.S28P02.GetHealingSpeedGainPercentageAtLevel
// 0x0004 (0x0004 - 0x0000)
struct S28P02_GetHealingSpeedGainPercentageAtLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(S28P02_GetHealingSpeedGainPercentageAtLevel) == 0x000004, "Wrong alignment on S28P02_GetHealingSpeedGainPercentageAtLevel");
static_assert(sizeof(S28P02_GetHealingSpeedGainPercentageAtLevel) == 0x000004, "Wrong size on S28P02_GetHealingSpeedGainPercentageAtLevel");
static_assert(offsetof(S28P02_GetHealingSpeedGainPercentageAtLevel, ReturnValue) == 0x000000, "Member 'S28P02_GetHealingSpeedGainPercentageAtLevel::ReturnValue' has a wrong offset!");

// Function TheK25.S28P02.GetSelfHealSpeedPenaltyAtLevel
// 0x0004 (0x0004 - 0x0000)
struct S28P02_GetSelfHealSpeedPenaltyAtLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(S28P02_GetSelfHealSpeedPenaltyAtLevel) == 0x000004, "Wrong alignment on S28P02_GetSelfHealSpeedPenaltyAtLevel");
static_assert(sizeof(S28P02_GetSelfHealSpeedPenaltyAtLevel) == 0x000004, "Wrong size on S28P02_GetSelfHealSpeedPenaltyAtLevel");
static_assert(offsetof(S28P02_GetSelfHealSpeedPenaltyAtLevel, ReturnValue) == 0x000000, "Member 'S28P02_GetSelfHealSpeedPenaltyAtLevel::ReturnValue' has a wrong offset!");

// Function TheK25.S28P03.GetLingerDurationAtLevel
// 0x0004 (0x0004 - 0x0000)
struct S28P03_GetLingerDurationAtLevel final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(S28P03_GetLingerDurationAtLevel) == 0x000004, "Wrong alignment on S28P03_GetLingerDurationAtLevel");
static_assert(sizeof(S28P03_GetLingerDurationAtLevel) == 0x000004, "Wrong size on S28P03_GetLingerDurationAtLevel");
static_assert(offsetof(S28P03_GetLingerDurationAtLevel, ReturnValue) == 0x000000, "Member 'S28P03_GetLingerDurationAtLevel::ReturnValue' has a wrong offset!");

}

