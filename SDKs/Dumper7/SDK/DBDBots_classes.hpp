#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDBots

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "DBDBots_structs.hpp"
#include "NavigationSystem_classes.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"


namespace SDK
{

// Class DBDBots.BTService_StateMonitor
// 0x0060 (0x00D8 - 0x0078)
class UBTService_StateMonitor : public UBTService
{
public:
	struct FBlackboardKeySelector                 BBIsIntroCompleted;                                // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBDifficultyLevel;                                 // 0x00A8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_StateMonitor">();
	}
	static class UBTService_StateMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_StateMonitor>();
	}
};
static_assert(alignof(UBTService_StateMonitor) == 0x000008, "Wrong alignment on UBTService_StateMonitor");
static_assert(sizeof(UBTService_StateMonitor) == 0x0000D8, "Wrong size on UBTService_StateMonitor");
static_assert(offsetof(UBTService_StateMonitor, BBIsIntroCompleted) == 0x000078, "Member 'UBTService_StateMonitor::BBIsIntroCompleted' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor, BBDifficultyLevel) == 0x0000A8, "Member 'UBTService_StateMonitor::BBDifficultyLevel' has a wrong offset!");

// Class DBDBots.BTService_StateMonitor_Camper
// 0x03C8 (0x04A0 - 0x00D8)
class UBTService_StateMonitor_Camper final : public UBTService_StateMonitor
{
public:
	struct FBlackboardKeySelector                 BBDamageState;                                     // 0x00D8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBImmoblizedState;                                 // 0x0108(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBGuidedState;                                     // 0x0138(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBEscapedState;                                    // 0x0168(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsInInjuredBleedout;                             // 0x0198(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBDyingTimerPercentLeft;                           // 0x01C8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBItemType;                                        // 0x01F8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBItemCharge;                                      // 0x0228(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsChased;                                        // 0x0258(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBWasInStimulusSight;                              // 0x0288(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBWasBeingAimedAt;                                 // 0x02B8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsBeingAimedAt;                                  // 0x02E8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsBeingAttacked;                                 // 0x0318(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsChained;                                       // 0x0348(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsInPressureZone;                                // 0x0378(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsInActivatedRBT;                                // 0x03A8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsInDeathTimer;                                  // 0x03D8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         DeathTimerEndGamePrecent;                          // 0x0408(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40C[0x4];                                      // 0x040C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBHasCrowAttached;                                 // 0x0410(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBLastTrapSideStepExpirationTime;                  // 0x0440(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBLastAskedToMoveTime;                             // 0x0470(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_StateMonitor_Camper">();
	}
	static class UBTService_StateMonitor_Camper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_StateMonitor_Camper>();
	}
};
static_assert(alignof(UBTService_StateMonitor_Camper) == 0x000008, "Wrong alignment on UBTService_StateMonitor_Camper");
static_assert(sizeof(UBTService_StateMonitor_Camper) == 0x0004A0, "Wrong size on UBTService_StateMonitor_Camper");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBDamageState) == 0x0000D8, "Member 'UBTService_StateMonitor_Camper::BBDamageState' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBImmoblizedState) == 0x000108, "Member 'UBTService_StateMonitor_Camper::BBImmoblizedState' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBGuidedState) == 0x000138, "Member 'UBTService_StateMonitor_Camper::BBGuidedState' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBEscapedState) == 0x000168, "Member 'UBTService_StateMonitor_Camper::BBEscapedState' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsInInjuredBleedout) == 0x000198, "Member 'UBTService_StateMonitor_Camper::BBIsInInjuredBleedout' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBDyingTimerPercentLeft) == 0x0001C8, "Member 'UBTService_StateMonitor_Camper::BBDyingTimerPercentLeft' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBItemType) == 0x0001F8, "Member 'UBTService_StateMonitor_Camper::BBItemType' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBItemCharge) == 0x000228, "Member 'UBTService_StateMonitor_Camper::BBItemCharge' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsChased) == 0x000258, "Member 'UBTService_StateMonitor_Camper::BBIsChased' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBWasInStimulusSight) == 0x000288, "Member 'UBTService_StateMonitor_Camper::BBWasInStimulusSight' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBWasBeingAimedAt) == 0x0002B8, "Member 'UBTService_StateMonitor_Camper::BBWasBeingAimedAt' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsBeingAimedAt) == 0x0002E8, "Member 'UBTService_StateMonitor_Camper::BBIsBeingAimedAt' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsBeingAttacked) == 0x000318, "Member 'UBTService_StateMonitor_Camper::BBIsBeingAttacked' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsChained) == 0x000348, "Member 'UBTService_StateMonitor_Camper::BBIsChained' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsInPressureZone) == 0x000378, "Member 'UBTService_StateMonitor_Camper::BBIsInPressureZone' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsInActivatedRBT) == 0x0003A8, "Member 'UBTService_StateMonitor_Camper::BBIsInActivatedRBT' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBIsInDeathTimer) == 0x0003D8, "Member 'UBTService_StateMonitor_Camper::BBIsInDeathTimer' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, DeathTimerEndGamePrecent) == 0x000408, "Member 'UBTService_StateMonitor_Camper::DeathTimerEndGamePrecent' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBHasCrowAttached) == 0x000410, "Member 'UBTService_StateMonitor_Camper::BBHasCrowAttached' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBLastTrapSideStepExpirationTime) == 0x000440, "Member 'UBTService_StateMonitor_Camper::BBLastTrapSideStepExpirationTime' has a wrong offset!");
static_assert(offsetof(UBTService_StateMonitor_Camper, BBLastAskedToMoveTime) == 0x000470, "Member 'UBTService_StateMonitor_Camper::BBLastAskedToMoveTime' has a wrong offset!");

// Class DBDBots.AIDisplayDebugInterface
// 0x0000 (0x0000 - 0x0000)
class IAIDisplayDebugInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDisplayDebugInterface">();
	}
	static class IAIDisplayDebugInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAIDisplayDebugInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAIDisplayDebugInterface) == 0x000001, "Wrong alignment on IAIDisplayDebugInterface");
static_assert(sizeof(IAIDisplayDebugInterface) == 0x000001, "Wrong size on IAIDisplayDebugInterface");

// Class DBDBots.AIGoalGeneratorInterface
// 0x0000 (0x0000 - 0x0000)
class IAIGoalGeneratorInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIGoalGeneratorInterface">();
	}
	static class IAIGoalGeneratorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAIGoalGeneratorInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAIGoalGeneratorInterface) == 0x000001, "Wrong alignment on IAIGoalGeneratorInterface");
static_assert(sizeof(IAIGoalGeneratorInterface) == 0x000001, "Wrong size on IAIGoalGeneratorInterface");

// Class DBDBots.BTService_FindInteractor
// 0x0238 (0x02B0 - 0x0078)
class UBTService_FindInteractor : public UBTService
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBSearchAround;                                    // 0x0088(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         SearchInterval;                                    // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchHeightAmplifierActivationHeight;             // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchHeightAmplifier;                             // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RegisterAsDiscoveredWhenFound;                     // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBOnlyFromActor;                                   // 0x00D8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class FString>                         OnlyWithInteractorIDs;                             // 0x0108(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         RejectIfTerrorIsCloserThanSelfMargin;              // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RejectIfInTerrorRadius;                            // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfInPressureZone;                            // 0x0120(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseLastKnownPositionForTerrorRejects;              // 0x0121(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfWasInCooldownAndFocusedOnAnotherObject;    // 0x0122(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_123[0x1];                                      // 0x0123(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RejectCooldownContextName;                         // 0x0124(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfAnySiblingInteractorHasCooldown;           // 0x0130(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AbandonIfInChase;                                  // 0x0131(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfFocusedByOther;                            // 0x0132(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfNotFocusedBySelf;                          // 0x0133(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreFocusFilterInEndgameCollapse;                // 0x0134(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfNotInSight;                                // 0x0135(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreSightFilterIfDiscovered;                     // 0x0136(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreSightFilterIfInRange;                        // 0x0137(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RejectAboveRange;                                  // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreRangeFilterIfDiscovered;                     // 0x013C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreRangeFilterIfInSight;                        // 0x013D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13E[0x2];                                      // 0x013E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBInteractLocation;                                // 0x0140(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBInteractorObj;                                   // 0x0170(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CantInterruptGoalInteractionUnderRemainingTime;    // 0x01A0(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalBasicWeight;                                   // 0x01B0(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalWeightMaxDistance;                             // 0x01C0(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalWeightAtMinDistance;                           // 0x01D0(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalWeightAtEndgameStart;                          // 0x01E0(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalWeightAtEndgameEnd;                            // 0x01F0(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalWeightBonusWhileInteracting;                   // 0x0200(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsUnsafeAction;                                    // 0x0210(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x7];                                      // 0x0211(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBUnsafeActionID;                                  // 0x0218(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBUnsafeActionUsesItemAddons;                      // 0x0248(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FString                                 UnsafeInteractionID;                               // 0x0278(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UnsafeActionUsesItemAddons;                        // 0x0288(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ProjectGoalLocationToNavigationExtent;             // 0x028C(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractor*                            _goalInteractor;                                   // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDAIBTController*                     _aiOwner;                                          // 0x02A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor">();
	}
	static class UBTService_FindInteractor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor>();
	}
};
static_assert(alignof(UBTService_FindInteractor) == 0x000008, "Wrong alignment on UBTService_FindInteractor");
static_assert(sizeof(UBTService_FindInteractor) == 0x0002B0, "Wrong size on UBTService_FindInteractor");
static_assert(offsetof(UBTService_FindInteractor, BBSearchAround) == 0x000088, "Member 'UBTService_FindInteractor::BBSearchAround' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, SearchInterval) == 0x0000B8, "Member 'UBTService_FindInteractor::SearchInterval' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, SearchHeightAmplifierActivationHeight) == 0x0000BC, "Member 'UBTService_FindInteractor::SearchHeightAmplifierActivationHeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, SearchHeightAmplifier) == 0x0000C0, "Member 'UBTService_FindInteractor::SearchHeightAmplifier' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, FilterClass) == 0x0000C8, "Member 'UBTService_FindInteractor::FilterClass' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RegisterAsDiscoveredWhenFound) == 0x0000D0, "Member 'UBTService_FindInteractor::RegisterAsDiscoveredWhenFound' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, BBOnlyFromActor) == 0x0000D8, "Member 'UBTService_FindInteractor::BBOnlyFromActor' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, OnlyWithInteractorIDs) == 0x000108, "Member 'UBTService_FindInteractor::OnlyWithInteractorIDs' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfTerrorIsCloserThanSelfMargin) == 0x000118, "Member 'UBTService_FindInteractor::RejectIfTerrorIsCloserThanSelfMargin' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfInTerrorRadius) == 0x00011C, "Member 'UBTService_FindInteractor::RejectIfInTerrorRadius' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfInPressureZone) == 0x000120, "Member 'UBTService_FindInteractor::RejectIfInPressureZone' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, UseLastKnownPositionForTerrorRejects) == 0x000121, "Member 'UBTService_FindInteractor::UseLastKnownPositionForTerrorRejects' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfWasInCooldownAndFocusedOnAnotherObject) == 0x000122, "Member 'UBTService_FindInteractor::RejectIfWasInCooldownAndFocusedOnAnotherObject' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectCooldownContextName) == 0x000124, "Member 'UBTService_FindInteractor::RejectCooldownContextName' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfAnySiblingInteractorHasCooldown) == 0x000130, "Member 'UBTService_FindInteractor::RejectIfAnySiblingInteractorHasCooldown' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, AbandonIfInChase) == 0x000131, "Member 'UBTService_FindInteractor::AbandonIfInChase' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfFocusedByOther) == 0x000132, "Member 'UBTService_FindInteractor::RejectIfFocusedByOther' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfNotFocusedBySelf) == 0x000133, "Member 'UBTService_FindInteractor::RejectIfNotFocusedBySelf' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, IgnoreFocusFilterInEndgameCollapse) == 0x000134, "Member 'UBTService_FindInteractor::IgnoreFocusFilterInEndgameCollapse' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectIfNotInSight) == 0x000135, "Member 'UBTService_FindInteractor::RejectIfNotInSight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, IgnoreSightFilterIfDiscovered) == 0x000136, "Member 'UBTService_FindInteractor::IgnoreSightFilterIfDiscovered' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, IgnoreSightFilterIfInRange) == 0x000137, "Member 'UBTService_FindInteractor::IgnoreSightFilterIfInRange' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, RejectAboveRange) == 0x000138, "Member 'UBTService_FindInteractor::RejectAboveRange' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, IgnoreRangeFilterIfDiscovered) == 0x00013C, "Member 'UBTService_FindInteractor::IgnoreRangeFilterIfDiscovered' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, IgnoreRangeFilterIfInSight) == 0x00013D, "Member 'UBTService_FindInteractor::IgnoreRangeFilterIfInSight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, BBInteractLocation) == 0x000140, "Member 'UBTService_FindInteractor::BBInteractLocation' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, BBInteractorObj) == 0x000170, "Member 'UBTService_FindInteractor::BBInteractorObj' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, CantInterruptGoalInteractionUnderRemainingTime) == 0x0001A0, "Member 'UBTService_FindInteractor::CantInterruptGoalInteractionUnderRemainingTime' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, GoalBasicWeight) == 0x0001B0, "Member 'UBTService_FindInteractor::GoalBasicWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, GoalWeightMaxDistance) == 0x0001C0, "Member 'UBTService_FindInteractor::GoalWeightMaxDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, GoalWeightAtMinDistance) == 0x0001D0, "Member 'UBTService_FindInteractor::GoalWeightAtMinDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, GoalWeightAtEndgameStart) == 0x0001E0, "Member 'UBTService_FindInteractor::GoalWeightAtEndgameStart' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, GoalWeightAtEndgameEnd) == 0x0001F0, "Member 'UBTService_FindInteractor::GoalWeightAtEndgameEnd' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, GoalWeightBonusWhileInteracting) == 0x000200, "Member 'UBTService_FindInteractor::GoalWeightBonusWhileInteracting' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, IsUnsafeAction) == 0x000210, "Member 'UBTService_FindInteractor::IsUnsafeAction' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, BBUnsafeActionID) == 0x000218, "Member 'UBTService_FindInteractor::BBUnsafeActionID' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, BBUnsafeActionUsesItemAddons) == 0x000248, "Member 'UBTService_FindInteractor::BBUnsafeActionUsesItemAddons' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, UnsafeInteractionID) == 0x000278, "Member 'UBTService_FindInteractor::UnsafeInteractionID' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, UnsafeActionUsesItemAddons) == 0x000288, "Member 'UBTService_FindInteractor::UnsafeActionUsesItemAddons' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, ProjectGoalLocationToNavigationExtent) == 0x00028C, "Member 'UBTService_FindInteractor::ProjectGoalLocationToNavigationExtent' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, _goalInteractor) == 0x000298, "Member 'UBTService_FindInteractor::_goalInteractor' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor, _aiOwner) == 0x0002A0, "Member 'UBTService_FindInteractor::_aiOwner' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_Generator
// 0x0058 (0x0308 - 0x02B0)
class UBTService_FindInteractor_Generator final : public UBTService_FindInteractor
{
public:
	EFindInteractableGeneratorStatusFilter        StatusFilter;                                      // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    MinRepairRatioFilter;                              // 0x02B4(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          UsePerceptionToGetRepairRatio;                     // 0x02C4(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C5[0x3];                                      // 0x02C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    MaxRepairGoalWeight;                               // 0x02C8(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    InfectedStateGoalWeight;                           // 0x02D8(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    HexRuinGoalWeight;                                 // 0x02E8(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   HexRuinPerkId;                                     // 0x02F8(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Generator">();
	}
	static class UBTService_FindInteractor_Generator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Generator>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Generator) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Generator");
static_assert(sizeof(UBTService_FindInteractor_Generator) == 0x000308, "Wrong size on UBTService_FindInteractor_Generator");
static_assert(offsetof(UBTService_FindInteractor_Generator, StatusFilter) == 0x0002B0, "Member 'UBTService_FindInteractor_Generator::StatusFilter' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Generator, MinRepairRatioFilter) == 0x0002B4, "Member 'UBTService_FindInteractor_Generator::MinRepairRatioFilter' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Generator, UsePerceptionToGetRepairRatio) == 0x0002C4, "Member 'UBTService_FindInteractor_Generator::UsePerceptionToGetRepairRatio' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Generator, MaxRepairGoalWeight) == 0x0002C8, "Member 'UBTService_FindInteractor_Generator::MaxRepairGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Generator, InfectedStateGoalWeight) == 0x0002D8, "Member 'UBTService_FindInteractor_Generator::InfectedStateGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Generator, HexRuinGoalWeight) == 0x0002E8, "Member 'UBTService_FindInteractor_Generator::HexRuinGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Generator, HexRuinPerkId) == 0x0002F8, "Member 'UBTService_FindInteractor_Generator::HexRuinPerkId' has a wrong offset!");

// Class DBDBots.AIIntentionValidatorInterface
// 0x0000 (0x0000 - 0x0000)
class IAIIntentionValidatorInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIIntentionValidatorInterface">();
	}
	static class IAIIntentionValidatorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAIIntentionValidatorInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAIIntentionValidatorInterface) == 0x000001, "Wrong alignment on IAIIntentionValidatorInterface");
static_assert(sizeof(IAIIntentionValidatorInterface) == 0x000001, "Wrong size on IAIIntentionValidatorInterface");

// Class DBDBots.AIPathValidatorInterface
// 0x0000 (0x0000 - 0x0000)
class IAIPathValidatorInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIPathValidatorInterface">();
	}
	static class IAIPathValidatorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAIPathValidatorInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAIPathValidatorInterface) == 0x000001, "Wrong alignment on IAIPathValidatorInterface");
static_assert(sizeof(IAIPathValidatorInterface) == 0x000001, "Wrong size on IAIPathValidatorInterface");

// Class DBDBots.AISkill
// 0x00A0 (0x00D0 - 0x0030)
class UAISkill : public UObject
{
public:
	struct FGameplayTagContainer                  RunContexts;                                       // 0x0030(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          StopIfPausedByNavLinkProxy;                        // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RunTimeLimit;                                      // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunCooldownTime;                                   // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunCooldownTimeDeviation;                          // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     SkillNavigationFilterClass;                        // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAISenseConfig*>                 SkillSenseConfigs;                                 // 0x0068(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FKillerFilterItem>              KillerFilter;                                      // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          DynamicSubtree;                                    // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x18];                                      // 0x0090(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        _pausedByObjects;                                  // 0x00A8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDAIBTController*                     _aiControllerOwner;                                // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill">();
	}
	static class UAISkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill>();
	}
};
static_assert(alignof(UAISkill) == 0x000008, "Wrong alignment on UAISkill");
static_assert(sizeof(UAISkill) == 0x0000D0, "Wrong size on UAISkill");
static_assert(offsetof(UAISkill, RunContexts) == 0x000030, "Member 'UAISkill::RunContexts' has a wrong offset!");
static_assert(offsetof(UAISkill, StopIfPausedByNavLinkProxy) == 0x000050, "Member 'UAISkill::StopIfPausedByNavLinkProxy' has a wrong offset!");
static_assert(offsetof(UAISkill, RunTimeLimit) == 0x000054, "Member 'UAISkill::RunTimeLimit' has a wrong offset!");
static_assert(offsetof(UAISkill, RunCooldownTime) == 0x000058, "Member 'UAISkill::RunCooldownTime' has a wrong offset!");
static_assert(offsetof(UAISkill, RunCooldownTimeDeviation) == 0x00005C, "Member 'UAISkill::RunCooldownTimeDeviation' has a wrong offset!");
static_assert(offsetof(UAISkill, SkillNavigationFilterClass) == 0x000060, "Member 'UAISkill::SkillNavigationFilterClass' has a wrong offset!");
static_assert(offsetof(UAISkill, SkillSenseConfigs) == 0x000068, "Member 'UAISkill::SkillSenseConfigs' has a wrong offset!");
static_assert(offsetof(UAISkill, KillerFilter) == 0x000078, "Member 'UAISkill::KillerFilter' has a wrong offset!");
static_assert(offsetof(UAISkill, DynamicSubtree) == 0x000088, "Member 'UAISkill::DynamicSubtree' has a wrong offset!");
static_assert(offsetof(UAISkill, _pausedByObjects) == 0x0000A8, "Member 'UAISkill::_pausedByObjects' has a wrong offset!");
static_assert(offsetof(UAISkill, _aiControllerOwner) == 0x0000C8, "Member 'UAISkill::_aiControllerOwner' has a wrong offset!");

// Class DBDBots.AISkill_DirectionalMinigame
// 0x0068 (0x0138 - 0x00D0)
class UAISkill_DirectionalMinigame final : public UAISkill
{
public:
	struct FAIRoll                                InputRoll;                                         // 0x00D0(0x0024)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    InputTimeMinimum;                                  // 0x00F4(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    InputTimeVariance;                                 // 0x0104(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x24];                                     // 0x0114(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMinigameEnd(EDirectionalMinigameResult result);
	void OnMinigameStart(const TArray<EDirectionalInputKey>& sequence, int32 currentIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_DirectionalMinigame">();
	}
	static class UAISkill_DirectionalMinigame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_DirectionalMinigame>();
	}
};
static_assert(alignof(UAISkill_DirectionalMinigame) == 0x000008, "Wrong alignment on UAISkill_DirectionalMinigame");
static_assert(sizeof(UAISkill_DirectionalMinigame) == 0x000138, "Wrong size on UAISkill_DirectionalMinigame");
static_assert(offsetof(UAISkill_DirectionalMinigame, InputRoll) == 0x0000D0, "Member 'UAISkill_DirectionalMinigame::InputRoll' has a wrong offset!");
static_assert(offsetof(UAISkill_DirectionalMinigame, InputTimeMinimum) == 0x0000F4, "Member 'UAISkill_DirectionalMinigame::InputTimeMinimum' has a wrong offset!");
static_assert(offsetof(UAISkill_DirectionalMinigame, InputTimeVariance) == 0x000104, "Member 'UAISkill_DirectionalMinigame::InputTimeVariance' has a wrong offset!");

// Class DBDBots.BTService_FindInteractable
// 0x0168 (0x01E0 - 0x0078)
class UBTService_FindInteractable : public UBTService
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBSearchAround;                                    // 0x0088(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         SearchInterval;                                    // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchHeightAmplifierActivationHeight;             // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchHeightAmplifier;                             // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RegisterAsDiscoveredWhenFound;                     // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBOnlyFromActor;                                   // 0x00D8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          RejectIfInPressureZone;                            // 0x0108(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RejectCooldownContextName;                         // 0x010C(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AbandonIfInChase;                                  // 0x0118(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfFocusedByOther;                            // 0x0119(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfNotFocusedBySelf;                          // 0x011A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreFocusFilterInEndgameCollapse;                // 0x011B(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RejectIfNotInSight;                                // 0x011C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreSightFilterIfDiscovered;                     // 0x011D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreSightFilterIfInRange;                        // 0x011E(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11F[0x1];                                      // 0x011F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RejectAboveRange;                                  // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreRangeFilterIfDiscovered;                     // 0x0124(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreRangeFilterIfInSight;                        // 0x0125(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_126[0x2];                                      // 0x0126(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBInteractableLocation;                            // 0x0128(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBInteractableObj;                                 // 0x0158(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalBasicWeight;                                   // 0x0188(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalWeightMaxDistance;                             // 0x0198(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    GoalWeightAtMinDistance;                           // 0x01A8(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ProjectGoalLocationToNavigationExtent;             // 0x01B8(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AInteractable*                          _goalInteractable;                                 // 0x01C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDAIBTController*                     _aiOwner;                                          // 0x01D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D8[0x8];                                      // 0x01D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractable">();
	}
	static class UBTService_FindInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractable>();
	}
};
static_assert(alignof(UBTService_FindInteractable) == 0x000008, "Wrong alignment on UBTService_FindInteractable");
static_assert(sizeof(UBTService_FindInteractable) == 0x0001E0, "Wrong size on UBTService_FindInteractable");
static_assert(offsetof(UBTService_FindInteractable, BBSearchAround) == 0x000088, "Member 'UBTService_FindInteractable::BBSearchAround' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, SearchInterval) == 0x0000B8, "Member 'UBTService_FindInteractable::SearchInterval' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, SearchHeightAmplifierActivationHeight) == 0x0000BC, "Member 'UBTService_FindInteractable::SearchHeightAmplifierActivationHeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, SearchHeightAmplifier) == 0x0000C0, "Member 'UBTService_FindInteractable::SearchHeightAmplifier' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, FilterClass) == 0x0000C8, "Member 'UBTService_FindInteractable::FilterClass' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, RegisterAsDiscoveredWhenFound) == 0x0000D0, "Member 'UBTService_FindInteractable::RegisterAsDiscoveredWhenFound' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, BBOnlyFromActor) == 0x0000D8, "Member 'UBTService_FindInteractable::BBOnlyFromActor' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, RejectIfInPressureZone) == 0x000108, "Member 'UBTService_FindInteractable::RejectIfInPressureZone' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, RejectCooldownContextName) == 0x00010C, "Member 'UBTService_FindInteractable::RejectCooldownContextName' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, AbandonIfInChase) == 0x000118, "Member 'UBTService_FindInteractable::AbandonIfInChase' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, RejectIfFocusedByOther) == 0x000119, "Member 'UBTService_FindInteractable::RejectIfFocusedByOther' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, RejectIfNotFocusedBySelf) == 0x00011A, "Member 'UBTService_FindInteractable::RejectIfNotFocusedBySelf' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, IgnoreFocusFilterInEndgameCollapse) == 0x00011B, "Member 'UBTService_FindInteractable::IgnoreFocusFilterInEndgameCollapse' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, RejectIfNotInSight) == 0x00011C, "Member 'UBTService_FindInteractable::RejectIfNotInSight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, IgnoreSightFilterIfDiscovered) == 0x00011D, "Member 'UBTService_FindInteractable::IgnoreSightFilterIfDiscovered' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, IgnoreSightFilterIfInRange) == 0x00011E, "Member 'UBTService_FindInteractable::IgnoreSightFilterIfInRange' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, RejectAboveRange) == 0x000120, "Member 'UBTService_FindInteractable::RejectAboveRange' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, IgnoreRangeFilterIfDiscovered) == 0x000124, "Member 'UBTService_FindInteractable::IgnoreRangeFilterIfDiscovered' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, IgnoreRangeFilterIfInSight) == 0x000125, "Member 'UBTService_FindInteractable::IgnoreRangeFilterIfInSight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, BBInteractableLocation) == 0x000128, "Member 'UBTService_FindInteractable::BBInteractableLocation' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, BBInteractableObj) == 0x000158, "Member 'UBTService_FindInteractable::BBInteractableObj' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, GoalBasicWeight) == 0x000188, "Member 'UBTService_FindInteractable::GoalBasicWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, GoalWeightMaxDistance) == 0x000198, "Member 'UBTService_FindInteractable::GoalWeightMaxDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, GoalWeightAtMinDistance) == 0x0001A8, "Member 'UBTService_FindInteractable::GoalWeightAtMinDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, ProjectGoalLocationToNavigationExtent) == 0x0001B8, "Member 'UBTService_FindInteractable::ProjectGoalLocationToNavigationExtent' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, _goalInteractable) == 0x0001C8, "Member 'UBTService_FindInteractable::_goalInteractable' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractable, _aiOwner) == 0x0001D0, "Member 'UBTService_FindInteractable::_aiOwner' has a wrong offset!");

// Class DBDBots.BTService_FindInteractable_Totem
// 0x0030 (0x0210 - 0x01E0)
class UBTService_FindInteractable_Totem final : public UBTService_FindInteractable
{
public:
	uint8                                         Pad_1E0[0x30];                                     // 0x01E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractable_Totem">();
	}
	static class UBTService_FindInteractable_Totem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractable_Totem>();
	}
};
static_assert(alignof(UBTService_FindInteractable_Totem) == 0x000008, "Wrong alignment on UBTService_FindInteractable_Totem");
static_assert(sizeof(UBTService_FindInteractable_Totem) == 0x000210, "Wrong size on UBTService_FindInteractable_Totem");

// Class DBDBots.AISkill_Diversion
// 0x0050 (0x0120 - 0x00D0)
class UAISkill_Diversion final : public UAISkill
{
public:
	class FName                                   PerkId;                                            // 0x00D0(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             DiversionFromGoalClasses;                          // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	EAIDifficultyLevel                            ThrowOnInteractablesAtDifficultyLevel;             // 0x00F0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxThrowOnInteractableHalfAngle;                   // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMoveToTargetDistance;                           // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NavMeshFindLocationExtents;                        // 0x00FC(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlanInterval;                                      // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x14];                                     // 0x010C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Diversion">();
	}
	static class UAISkill_Diversion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Diversion>();
	}
};
static_assert(alignof(UAISkill_Diversion) == 0x000008, "Wrong alignment on UAISkill_Diversion");
static_assert(sizeof(UAISkill_Diversion) == 0x000120, "Wrong size on UAISkill_Diversion");
static_assert(offsetof(UAISkill_Diversion, PerkId) == 0x0000D0, "Member 'UAISkill_Diversion::PerkId' has a wrong offset!");
static_assert(offsetof(UAISkill_Diversion, DiversionFromGoalClasses) == 0x0000E0, "Member 'UAISkill_Diversion::DiversionFromGoalClasses' has a wrong offset!");
static_assert(offsetof(UAISkill_Diversion, ThrowOnInteractablesAtDifficultyLevel) == 0x0000F0, "Member 'UAISkill_Diversion::ThrowOnInteractablesAtDifficultyLevel' has a wrong offset!");
static_assert(offsetof(UAISkill_Diversion, MaxThrowOnInteractableHalfAngle) == 0x0000F4, "Member 'UAISkill_Diversion::MaxThrowOnInteractableHalfAngle' has a wrong offset!");
static_assert(offsetof(UAISkill_Diversion, MaxMoveToTargetDistance) == 0x0000F8, "Member 'UAISkill_Diversion::MaxMoveToTargetDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_Diversion, NavMeshFindLocationExtents) == 0x0000FC, "Member 'UAISkill_Diversion::NavMeshFindLocationExtents' has a wrong offset!");
static_assert(offsetof(UAISkill_Diversion, PlanInterval) == 0x000108, "Member 'UAISkill_Diversion::PlanInterval' has a wrong offset!");

// Class DBDBots.AISkill_Find
// 0x0040 (0x0110 - 0x00D0)
class UAISkill_Find : public UAISkill
{
public:
	TSubclassOf<class AActor>                     FindClass;                                         // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BlackboardWishListTag;                             // 0x00D8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchInterval;                                    // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MustBeSeen;                                        // 0x00E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        _currentWishedObjects;                             // 0x00F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Find">();
	}
	static class UAISkill_Find* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Find>();
	}
};
static_assert(alignof(UAISkill_Find) == 0x000008, "Wrong alignment on UAISkill_Find");
static_assert(sizeof(UAISkill_Find) == 0x000110, "Wrong size on UAISkill_Find");
static_assert(offsetof(UAISkill_Find, FindClass) == 0x0000D0, "Member 'UAISkill_Find::FindClass' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, BlackboardWishListTag) == 0x0000D8, "Member 'UAISkill_Find::BlackboardWishListTag' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, SearchInterval) == 0x0000E4, "Member 'UAISkill_Find::SearchInterval' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, MustBeSeen) == 0x0000E8, "Member 'UAISkill_Find::MustBeSeen' has a wrong offset!");
static_assert(offsetof(UAISkill_Find, _currentWishedObjects) == 0x0000F0, "Member 'UAISkill_Find::_currentWishedObjects' has a wrong offset!");

// Class DBDBots.BTTask_SetFocusCooldown
// 0x0048 (0x00C0 - 0x0078)
class UBTTask_SetFocusCooldown final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 BBOnObject;                                        // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FName                                   ContextName;                                       // 0x00A8(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InfiniteDuration;                                  // 0x00B4(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetFocusCooldown">();
	}
	static class UBTTask_SetFocusCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetFocusCooldown>();
	}
};
static_assert(alignof(UBTTask_SetFocusCooldown) == 0x000008, "Wrong alignment on UBTTask_SetFocusCooldown");
static_assert(sizeof(UBTTask_SetFocusCooldown) == 0x0000C0, "Wrong size on UBTTask_SetFocusCooldown");
static_assert(offsetof(UBTTask_SetFocusCooldown, BBOnObject) == 0x000078, "Member 'UBTTask_SetFocusCooldown::BBOnObject' has a wrong offset!");
static_assert(offsetof(UBTTask_SetFocusCooldown, ContextName) == 0x0000A8, "Member 'UBTTask_SetFocusCooldown::ContextName' has a wrong offset!");
static_assert(offsetof(UBTTask_SetFocusCooldown, InfiniteDuration) == 0x0000B4, "Member 'UBTTask_SetFocusCooldown::InfiniteDuration' has a wrong offset!");
static_assert(offsetof(UBTTask_SetFocusCooldown, Duration) == 0x0000B8, "Member 'UBTTask_SetFocusCooldown::Duration' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable
// 0x0018 (0x0128 - 0x0110)
class UAISkill_FindInteractable : public UAISkill_Find
{
public:
	class FString                                 RequiredInteractionId;                             // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputInteractionType                         RequiredInteractionInputType;                      // 0x0120(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable">();
	}
	static class UAISkill_FindInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable>();
	}
};
static_assert(alignof(UAISkill_FindInteractable) == 0x000008, "Wrong alignment on UAISkill_FindInteractable");
static_assert(sizeof(UAISkill_FindInteractable) == 0x000128, "Wrong size on UAISkill_FindInteractable");
static_assert(offsetof(UAISkill_FindInteractable, RequiredInteractionId) == 0x000110, "Member 'UAISkill_FindInteractable::RequiredInteractionId' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable, RequiredInteractionInputType) == 0x000120, "Member 'UAISkill_FindInteractable::RequiredInteractionInputType' has a wrong offset!");

// Class DBDBots.AISkill_FindCollectable
// 0x0008 (0x0130 - 0x0128)
class UAISkill_FindCollectable : public UAISkill_FindInteractable
{
public:
	int32                                         CollectUnderItemCount;                             // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollectOverItemChargeRatio;                        // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable">();
	}
	static class UAISkill_FindCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable>();
	}
};
static_assert(alignof(UAISkill_FindCollectable) == 0x000008, "Wrong alignment on UAISkill_FindCollectable");
static_assert(sizeof(UAISkill_FindCollectable) == 0x000130, "Wrong size on UAISkill_FindCollectable");
static_assert(offsetof(UAISkill_FindCollectable, CollectUnderItemCount) == 0x000128, "Member 'UAISkill_FindCollectable::CollectUnderItemCount' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable, CollectOverItemChargeRatio) == 0x00012C, "Member 'UAISkill_FindCollectable::CollectOverItemChargeRatio' has a wrong offset!");

// Class DBDBots.EnvQueryTest_IsValidDestination
// 0x0098 (0x02D0 - 0x0238)
class UEnvQueryTest_IsValidDestination final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           QuerierContext;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               Invert;                                            // 0x0240(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               ExcludeEscapeZoneIfReverseBearTrapIsActivated;     // 0x0280(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_IsValidDestination">();
	}
	static class UEnvQueryTest_IsValidDestination* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_IsValidDestination>();
	}
};
static_assert(alignof(UEnvQueryTest_IsValidDestination) == 0x000008, "Wrong alignment on UEnvQueryTest_IsValidDestination");
static_assert(sizeof(UEnvQueryTest_IsValidDestination) == 0x0002D0, "Wrong size on UEnvQueryTest_IsValidDestination");
static_assert(offsetof(UEnvQueryTest_IsValidDestination, QuerierContext) == 0x000238, "Member 'UEnvQueryTest_IsValidDestination::QuerierContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsValidDestination, Invert) == 0x000240, "Member 'UEnvQueryTest_IsValidDestination::Invert' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsValidDestination, ExcludeEscapeZoneIfReverseBearTrapIsActivated) == 0x000280, "Member 'UEnvQueryTest_IsValidDestination::ExcludeEscapeZoneIfReverseBearTrapIsActivated' has a wrong offset!");

// Class DBDBots.AISkill_FindCollectable_Camper
// 0x0008 (0x0138 - 0x0130)
class UAISkill_FindCollectable_Camper final : public UAISkill_FindCollectable
{
public:
	float                                         CollectUnderItemWeight;                            // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollectOverWeightRatioDifference;                  // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable_Camper">();
	}
	static class UAISkill_FindCollectable_Camper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable_Camper>();
	}
};
static_assert(alignof(UAISkill_FindCollectable_Camper) == 0x000008, "Wrong alignment on UAISkill_FindCollectable_Camper");
static_assert(sizeof(UAISkill_FindCollectable_Camper) == 0x000138, "Wrong size on UAISkill_FindCollectable_Camper");
static_assert(offsetof(UAISkill_FindCollectable_Camper, CollectUnderItemWeight) == 0x000130, "Member 'UAISkill_FindCollectable_Camper::CollectUnderItemWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_Camper, CollectOverWeightRatioDifference) == 0x000134, "Member 'UAISkill_FindCollectable_Camper::CollectOverWeightRatioDifference' has a wrong offset!");

// Class DBDBots.AISkill_FindCollectable_Hatchet
// 0x0000 (0x0130 - 0x0130)
class UAISkill_FindCollectable_Hatchet final : public UAISkill_FindCollectable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable_Hatchet">();
	}
	static class UAISkill_FindCollectable_Hatchet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable_Hatchet>();
	}
};
static_assert(alignof(UAISkill_FindCollectable_Hatchet) == 0x000008, "Wrong alignment on UAISkill_FindCollectable_Hatchet");
static_assert(sizeof(UAISkill_FindCollectable_Hatchet) == 0x000130, "Wrong size on UAISkill_FindCollectable_Hatchet");

// Class DBDBots.AISkill_FindCollectable_Searchable
// 0x0018 (0x0148 - 0x0130)
class UAISkill_FindCollectable_Searchable : public UAISkill_FindCollectable
{
public:
	float                                         SearchIntervalAfterOpenSearchable;                 // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenSearchableRelevancyDuration;                   // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x8];                                      // 0x0138(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ASearchable*                            _relevantSearchable;                               // 0x0140(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable_Searchable">();
	}
	static class UAISkill_FindCollectable_Searchable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable_Searchable>();
	}
};
static_assert(alignof(UAISkill_FindCollectable_Searchable) == 0x000008, "Wrong alignment on UAISkill_FindCollectable_Searchable");
static_assert(sizeof(UAISkill_FindCollectable_Searchable) == 0x000148, "Wrong size on UAISkill_FindCollectable_Searchable");
static_assert(offsetof(UAISkill_FindCollectable_Searchable, SearchIntervalAfterOpenSearchable) == 0x000130, "Member 'UAISkill_FindCollectable_Searchable::SearchIntervalAfterOpenSearchable' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_Searchable, OpenSearchableRelevancyDuration) == 0x000134, "Member 'UAISkill_FindCollectable_Searchable::OpenSearchableRelevancyDuration' has a wrong offset!");
static_assert(offsetof(UAISkill_FindCollectable_Searchable, _relevantSearchable) == 0x000140, "Member 'UAISkill_FindCollectable_Searchable::_relevantSearchable' has a wrong offset!");

// Class DBDBots.AISkill_FindCollectable_Trap
// 0x0000 (0x0130 - 0x0130)
class UAISkill_FindCollectable_Trap final : public UAISkill_FindCollectable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable_Trap">();
	}
	static class UAISkill_FindCollectable_Trap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable_Trap>();
	}
};
static_assert(alignof(UAISkill_FindCollectable_Trap) == 0x000008, "Wrong alignment on UAISkill_FindCollectable_Trap");
static_assert(sizeof(UAISkill_FindCollectable_Trap) == 0x000130, "Wrong size on UAISkill_FindCollectable_Trap");

// Class DBDBots.EnvQueryContext_TerrorRadius
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_TerrorRadius final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_TerrorRadius">();
	}
	static class UEnvQueryContext_TerrorRadius* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_TerrorRadius>();
	}
};
static_assert(alignof(UEnvQueryContext_TerrorRadius) == 0x000008, "Wrong alignment on UEnvQueryContext_TerrorRadius");
static_assert(sizeof(UEnvQueryContext_TerrorRadius) == 0x000030, "Wrong size on UEnvQueryContext_TerrorRadius");

// Class DBDBots.AISkill_FindInteractable_CloseTelevisionNearGenerator
// 0x0060 (0x0188 - 0x0128)
class UAISkill_FindInteractable_CloseTelevisionNearGenerator final : public UAISkill_FindInteractable
{
public:
	struct FAITunableParameter                    MaximumCondemnedPercentToCloseTelevision;          // 0x0128(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    DistanceBetweenGeneratorAndTelevisionThreshold;    // 0x0138(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BaseValue;                                         // 0x0148(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CloseTelevisionDistanceLinearWeight;               // 0x0158(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CloseTelevisionMaximumDistanceFromCamper;          // 0x0168(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxHeightDifferenceToCloseTelevisions;             // 0x0178(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_CloseTelevisionNearGenerator">();
	}
	static class UAISkill_FindInteractable_CloseTelevisionNearGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_CloseTelevisionNearGenerator>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_CloseTelevisionNearGenerator) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_CloseTelevisionNearGenerator");
static_assert(sizeof(UAISkill_FindInteractable_CloseTelevisionNearGenerator) == 0x000188, "Wrong size on UAISkill_FindInteractable_CloseTelevisionNearGenerator");
static_assert(offsetof(UAISkill_FindInteractable_CloseTelevisionNearGenerator, MaximumCondemnedPercentToCloseTelevision) == 0x000128, "Member 'UAISkill_FindInteractable_CloseTelevisionNearGenerator::MaximumCondemnedPercentToCloseTelevision' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_CloseTelevisionNearGenerator, DistanceBetweenGeneratorAndTelevisionThreshold) == 0x000138, "Member 'UAISkill_FindInteractable_CloseTelevisionNearGenerator::DistanceBetweenGeneratorAndTelevisionThreshold' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_CloseTelevisionNearGenerator, BaseValue) == 0x000148, "Member 'UAISkill_FindInteractable_CloseTelevisionNearGenerator::BaseValue' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_CloseTelevisionNearGenerator, CloseTelevisionDistanceLinearWeight) == 0x000158, "Member 'UAISkill_FindInteractable_CloseTelevisionNearGenerator::CloseTelevisionDistanceLinearWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_CloseTelevisionNearGenerator, CloseTelevisionMaximumDistanceFromCamper) == 0x000168, "Member 'UAISkill_FindInteractable_CloseTelevisionNearGenerator::CloseTelevisionMaximumDistanceFromCamper' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_CloseTelevisionNearGenerator, MaxHeightDifferenceToCloseTelevisions) == 0x000178, "Member 'UAISkill_FindInteractable_CloseTelevisionNearGenerator::MaxHeightDifferenceToCloseTelevisions' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_Drone
// 0x0048 (0x0170 - 0x0128)
class UAISkill_FindInteractable_Drone final : public UAISkill_FindInteractable
{
public:
	struct FAITunableParameter                    BaseActiveWeight;                                  // 0x0128(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BaseScoutingWeight;                                // 0x0138(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ClawTrapStateTag;                                  // 0x0148(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             ValidGoalObjectClasses;                            // 0x0158(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         DroneRadiusMargin;                                 // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_Drone">();
	}
	static class UAISkill_FindInteractable_Drone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_Drone>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_Drone) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_Drone");
static_assert(sizeof(UAISkill_FindInteractable_Drone) == 0x000170, "Wrong size on UAISkill_FindInteractable_Drone");
static_assert(offsetof(UAISkill_FindInteractable_Drone, BaseActiveWeight) == 0x000128, "Member 'UAISkill_FindInteractable_Drone::BaseActiveWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Drone, BaseScoutingWeight) == 0x000138, "Member 'UAISkill_FindInteractable_Drone::BaseScoutingWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Drone, ClawTrapStateTag) == 0x000148, "Member 'UAISkill_FindInteractable_Drone::ClawTrapStateTag' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Drone, ValidGoalObjectClasses) == 0x000158, "Member 'UAISkill_FindInteractable_Drone::ValidGoalObjectClasses' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_Drone, DroneRadiusMargin) == 0x000168, "Member 'UAISkill_FindInteractable_Drone::DroneRadiusMargin' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_SolveCondemned
// 0x0040 (0x0168 - 0x0128)
class UAISkill_FindInteractable_SolveCondemned final : public UAISkill_FindInteractable
{
public:
	struct FAITunableParameter                    NearCondemnedWeight;                               // 0x0128(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    HighCondemnedThreshold;                            // 0x0138(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SolveCondemnedBasicWeight;                         // 0x0148(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    CondemnedLevelProportionalWeight;                  // 0x0158(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_SolveCondemned">();
	}
	static class UAISkill_FindInteractable_SolveCondemned* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_SolveCondemned>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_SolveCondemned) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_SolveCondemned");
static_assert(sizeof(UAISkill_FindInteractable_SolveCondemned) == 0x000168, "Wrong size on UAISkill_FindInteractable_SolveCondemned");
static_assert(offsetof(UAISkill_FindInteractable_SolveCondemned, NearCondemnedWeight) == 0x000128, "Member 'UAISkill_FindInteractable_SolveCondemned::NearCondemnedWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SolveCondemned, HighCondemnedThreshold) == 0x000138, "Member 'UAISkill_FindInteractable_SolveCondemned::HighCondemnedThreshold' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SolveCondemned, SolveCondemnedBasicWeight) == 0x000148, "Member 'UAISkill_FindInteractable_SolveCondemned::SolveCondemnedBasicWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SolveCondemned, CondemnedLevelProportionalWeight) == 0x000158, "Member 'UAISkill_FindInteractable_SolveCondemned::CondemnedLevelProportionalWeight' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_SolveRBT
// 0x0020 (0x0148 - 0x0128)
class UAISkill_FindInteractable_SolveRBT final : public UAISkill_FindInteractable
{
public:
	struct FAITunableParameter                    UrgencyGoalWeight;                                 // 0x0128(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PriorityGoalWeight;                                // 0x0138(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_SolveRBT">();
	}
	static class UAISkill_FindInteractable_SolveRBT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_SolveRBT>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_SolveRBT) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_SolveRBT");
static_assert(sizeof(UAISkill_FindInteractable_SolveRBT) == 0x000148, "Wrong size on UAISkill_FindInteractable_SolveRBT");
static_assert(offsetof(UAISkill_FindInteractable_SolveRBT, UrgencyGoalWeight) == 0x000128, "Member 'UAISkill_FindInteractable_SolveRBT::UrgencyGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SolveRBT, PriorityGoalWeight) == 0x000138, "Member 'UAISkill_FindInteractable_SolveRBT::PriorityGoalWeight' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_SolveSickness
// 0x0030 (0x0158 - 0x0128)
class UAISkill_FindInteractable_SolveSickness final : public UAISkill_FindInteractable
{
public:
	struct FAITunableParameter                    BaseGoalWeight;                                    // 0x0128(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    UrgencyGoalWeight;                                 // 0x0138(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    InteractingGoalPenaltyWeight;                      // 0x0148(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_SolveSickness">();
	}
	static class UAISkill_FindInteractable_SolveSickness* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_SolveSickness>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_SolveSickness) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_SolveSickness");
static_assert(sizeof(UAISkill_FindInteractable_SolveSickness) == 0x000158, "Wrong size on UAISkill_FindInteractable_SolveSickness");
static_assert(offsetof(UAISkill_FindInteractable_SolveSickness, BaseGoalWeight) == 0x000128, "Member 'UAISkill_FindInteractable_SolveSickness::BaseGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SolveSickness, UrgencyGoalWeight) == 0x000138, "Member 'UAISkill_FindInteractable_SolveSickness::UrgencyGoalWeight' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_SolveSickness, InteractingGoalPenaltyWeight) == 0x000148, "Member 'UAISkill_FindInteractable_SolveSickness::InteractingGoalPenaltyWeight' has a wrong offset!");

// Class DBDBots.PathStrategy
// 0x0088 (0x00B8 - 0x0030)
class UPathStrategy : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPathBuilder*>                   DefaultPathBuilders;                               // 0x0040(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         RefreshPartialPathDelay;                           // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartNextBranchBuildDelay;                         // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDAIBTController*                     _aiOwner;                                          // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPathBuilder*>                   _pathBuilders;                                     // 0x0060(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x48];                                      // 0x0070(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathStrategy">();
	}
	static class UPathStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathStrategy>();
	}
};
static_assert(alignof(UPathStrategy) == 0x000008, "Wrong alignment on UPathStrategy");
static_assert(sizeof(UPathStrategy) == 0x0000B8, "Wrong size on UPathStrategy");
static_assert(offsetof(UPathStrategy, DefaultPathBuilders) == 0x000040, "Member 'UPathStrategy::DefaultPathBuilders' has a wrong offset!");
static_assert(offsetof(UPathStrategy, RefreshPartialPathDelay) == 0x000050, "Member 'UPathStrategy::RefreshPartialPathDelay' has a wrong offset!");
static_assert(offsetof(UPathStrategy, StartNextBranchBuildDelay) == 0x000054, "Member 'UPathStrategy::StartNextBranchBuildDelay' has a wrong offset!");
static_assert(offsetof(UPathStrategy, _aiOwner) == 0x000058, "Member 'UPathStrategy::_aiOwner' has a wrong offset!");
static_assert(offsetof(UPathStrategy, _pathBuilders) == 0x000060, "Member 'UPathStrategy::_pathBuilders' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_StatusEffect
// 0x0010 (0x0138 - 0x0128)
class UAISkill_FindInteractable_StatusEffect : public UAISkill_FindInteractable
{
public:
	struct FGameplayTag                           RequiredPerkFlag;                                  // 0x0128(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InvertCondition;                                   // 0x0134(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_StatusEffect">();
	}
	static class UAISkill_FindInteractable_StatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_StatusEffect>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_StatusEffect) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_StatusEffect");
static_assert(sizeof(UAISkill_FindInteractable_StatusEffect) == 0x000138, "Wrong size on UAISkill_FindInteractable_StatusEffect");
static_assert(offsetof(UAISkill_FindInteractable_StatusEffect, RequiredPerkFlag) == 0x000128, "Member 'UAISkill_FindInteractable_StatusEffect::RequiredPerkFlag' has a wrong offset!");
static_assert(offsetof(UAISkill_FindInteractable_StatusEffect, InvertCondition) == 0x000134, "Member 'UAISkill_FindInteractable_StatusEffect::InvertCondition' has a wrong offset!");

// Class DBDBots.BTService_SetMovementMode
// 0x0008 (0x0080 - 0x0078)
class UBTService_SetMovementMode final : public UBTService
{
public:
	ECharacterMovementTypes                       OnEnterMovementMode;                               // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterMovementTypes                       OnExitMovementMode;                                // 0x0079(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_SetMovementMode">();
	}
	static class UBTService_SetMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_SetMovementMode>();
	}
};
static_assert(alignof(UBTService_SetMovementMode) == 0x000008, "Wrong alignment on UBTService_SetMovementMode");
static_assert(sizeof(UBTService_SetMovementMode) == 0x000080, "Wrong size on UBTService_SetMovementMode");
static_assert(offsetof(UBTService_SetMovementMode, OnEnterMovementMode) == 0x000078, "Member 'UBTService_SetMovementMode::OnEnterMovementMode' has a wrong offset!");
static_assert(offsetof(UBTService_SetMovementMode, OnExitMovementMode) == 0x000079, "Member 'UBTService_SetMovementMode::OnExitMovementMode' has a wrong offset!");

// Class DBDBots.AISkill_FindInteractable_StatusEffect_Plague
// 0x0000 (0x0138 - 0x0138)
class UAISkill_FindInteractable_StatusEffect_Plague final : public UAISkill_FindInteractable_StatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_StatusEffect_Plague">();
	}
	static class UAISkill_FindInteractable_StatusEffect_Plague* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_StatusEffect_Plague>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_StatusEffect_Plague) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_StatusEffect_Plague");
static_assert(sizeof(UAISkill_FindInteractable_StatusEffect_Plague) == 0x000138, "Wrong size on UAISkill_FindInteractable_StatusEffect_Plague");

// Class DBDBots.AISkill_FindInteractable_Waker
// 0x0000 (0x0128 - 0x0128)
class UAISkill_FindInteractable_Waker final : public UAISkill_FindInteractable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindInteractable_Waker">();
	}
	static class UAISkill_FindInteractable_Waker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindInteractable_Waker>();
	}
};
static_assert(alignof(UAISkill_FindInteractable_Waker) == 0x000008, "Wrong alignment on UAISkill_FindInteractable_Waker");
static_assert(sizeof(UAISkill_FindInteractable_Waker) == 0x000128, "Wrong size on UAISkill_FindInteractable_Waker");

// Class DBDBots.BTService_GoalCoordinator
// 0x0068 (0x00E0 - 0x0078)
class UBTService_GoalCoordinator final : public UBTService
{
public:
	struct FAITunableParameter                    GoalChangeWeightBuffer;                            // 0x0078(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UObject*, struct FAIGoalWeightContainer> _managedGoals;                               // 0x0090(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_GoalCoordinator">();
	}
	static class UBTService_GoalCoordinator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_GoalCoordinator>();
	}
};
static_assert(alignof(UBTService_GoalCoordinator) == 0x000008, "Wrong alignment on UBTService_GoalCoordinator");
static_assert(sizeof(UBTService_GoalCoordinator) == 0x0000E0, "Wrong size on UBTService_GoalCoordinator");
static_assert(offsetof(UBTService_GoalCoordinator, GoalChangeWeightBuffer) == 0x000078, "Member 'UBTService_GoalCoordinator::GoalChangeWeightBuffer' has a wrong offset!");
static_assert(offsetof(UBTService_GoalCoordinator, _managedGoals) == 0x000090, "Member 'UBTService_GoalCoordinator::_managedGoals' has a wrong offset!");

// Class DBDBots.AISkill_Interaction
// 0x00B0 (0x0180 - 0x00D0)
class UAISkill_Interaction : public UAISkill
{
public:
	EPawnInputPressTypes                          InputType;                                         // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionSkillInputModes                   InputMode;                                         // 0x00D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPawnInputPressTypes                          CancelInputType;                                   // 0x00D2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionCancelInputModes                  CancelInputMode;                                   // 0x00D3(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoLockInput;                                     // 0x00D4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAIRoll                                StartRoll;                                         // 0x00D8(0x0024)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StartInteractionID;                                // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StopInteractionID;                                 // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinHoldInputTime;                                  // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoReleaseHoldInputWhenCharged;                   // 0x0124(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_125[0x5B];                                     // 0x0125(0x005B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction">();
	}
	static class UAISkill_Interaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction>();
	}
};
static_assert(alignof(UAISkill_Interaction) == 0x000008, "Wrong alignment on UAISkill_Interaction");
static_assert(sizeof(UAISkill_Interaction) == 0x000180, "Wrong size on UAISkill_Interaction");
static_assert(offsetof(UAISkill_Interaction, InputType) == 0x0000D0, "Member 'UAISkill_Interaction::InputType' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, InputMode) == 0x0000D1, "Member 'UAISkill_Interaction::InputMode' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, CancelInputType) == 0x0000D2, "Member 'UAISkill_Interaction::CancelInputType' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, CancelInputMode) == 0x0000D3, "Member 'UAISkill_Interaction::CancelInputMode' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, AutoLockInput) == 0x0000D4, "Member 'UAISkill_Interaction::AutoLockInput' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, StartRoll) == 0x0000D8, "Member 'UAISkill_Interaction::StartRoll' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, StartInteractionID) == 0x000100, "Member 'UAISkill_Interaction::StartInteractionID' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, StopInteractionID) == 0x000110, "Member 'UAISkill_Interaction::StopInteractionID' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, MinHoldInputTime) == 0x000120, "Member 'UAISkill_Interaction::MinHoldInputTime' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction, AutoReleaseHoldInputWhenCharged) == 0x000124, "Member 'UAISkill_Interaction::AutoReleaseHoldInputWhenCharged' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_AttachRBT
// 0x0000 (0x0180 - 0x0180)
class UAISkill_Interaction_AttachRBT final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_AttachRBT">();
	}
	static class UAISkill_Interaction_AttachRBT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_AttachRBT>();
	}
};
static_assert(alignof(UAISkill_Interaction_AttachRBT) == 0x000008, "Wrong alignment on UAISkill_Interaction_AttachRBT");
static_assert(sizeof(UAISkill_Interaction_AttachRBT) == 0x000180, "Wrong size on UAISkill_Interaction_AttachRBT");

// Class DBDBots.AISkill_Interaction_Clairvoyance
// 0x0018 (0x0198 - 0x0180)
class UAISkill_Interaction_Clairvoyance final : public UAISkill_Interaction
{
public:
	struct FGameplayTag                           DropCooldownTag;                                   // 0x0180(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropCooldownDuration;                              // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToExistingDuration;                            // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_Clairvoyance">();
	}
	static class UAISkill_Interaction_Clairvoyance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_Clairvoyance>();
	}
};
static_assert(alignof(UAISkill_Interaction_Clairvoyance) == 0x000008, "Wrong alignment on UAISkill_Interaction_Clairvoyance");
static_assert(sizeof(UAISkill_Interaction_Clairvoyance) == 0x000198, "Wrong size on UAISkill_Interaction_Clairvoyance");
static_assert(offsetof(UAISkill_Interaction_Clairvoyance, DropCooldownTag) == 0x000180, "Member 'UAISkill_Interaction_Clairvoyance::DropCooldownTag' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Clairvoyance, DropCooldownDuration) == 0x00018C, "Member 'UAISkill_Interaction_Clairvoyance::DropCooldownDuration' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_Clairvoyance, bAddToExistingDuration) == 0x000190, "Member 'UAISkill_Interaction_Clairvoyance::bAddToExistingDuration' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_ForThePeople
// 0x0018 (0x0198 - 0x0180)
class UAISkill_Interaction_ForThePeople final : public UAISkill_Interaction
{
public:
	uint8                                         Pad_180[0x8];                                      // 0x0180(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BlockInteractionId;                                // 0x0188(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_ForThePeople">();
	}
	static class UAISkill_Interaction_ForThePeople* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_ForThePeople>();
	}
};
static_assert(alignof(UAISkill_Interaction_ForThePeople) == 0x000008, "Wrong alignment on UAISkill_Interaction_ForThePeople");
static_assert(sizeof(UAISkill_Interaction_ForThePeople) == 0x000198, "Wrong size on UAISkill_Interaction_ForThePeople");
static_assert(offsetof(UAISkill_Interaction_ForThePeople, BlockInteractionId) == 0x000188, "Member 'UAISkill_Interaction_ForThePeople::BlockInteractionId' has a wrong offset!");

// Class DBDBots.BTDecorator_TickableBase
// 0x0000 (0x0070 - 0x0070)
class UBTDecorator_TickableBase : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_TickableBase">();
	}
	static class UBTDecorator_TickableBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_TickableBase>();
	}
};
static_assert(alignof(UBTDecorator_TickableBase) == 0x000008, "Wrong alignment on UBTDecorator_TickableBase");
static_assert(sizeof(UBTDecorator_TickableBase) == 0x000070, "Wrong size on UBTDecorator_TickableBase");

// Class DBDBots.BTDecorator_IsExitOpened
// 0x0030 (0x00A0 - 0x0070)
class UBTDecorator_IsExitOpened final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBExitObj;                                         // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsExitOpened">();
	}
	static class UBTDecorator_IsExitOpened* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsExitOpened>();
	}
};
static_assert(alignof(UBTDecorator_IsExitOpened) == 0x000008, "Wrong alignment on UBTDecorator_IsExitOpened");
static_assert(sizeof(UBTDecorator_IsExitOpened) == 0x0000A0, "Wrong size on UBTDecorator_IsExitOpened");
static_assert(offsetof(UBTDecorator_IsExitOpened, BBExitObj) == 0x000070, "Member 'UBTDecorator_IsExitOpened::BBExitObj' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_GeneratorSecondaryInteraction
// 0x0020 (0x01A0 - 0x0180)
class UAISkill_Interaction_GeneratorSecondaryInteraction : public UAISkill_Interaction
{
public:
	TArray<struct FPerkIdDropdown>                Perks;                                             // 0x0180(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   GeneratorSecondaryInteractionId;                   // 0x0190(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_GeneratorSecondaryInteraction">();
	}
	static class UAISkill_Interaction_GeneratorSecondaryInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_GeneratorSecondaryInteraction>();
	}
};
static_assert(alignof(UAISkill_Interaction_GeneratorSecondaryInteraction) == 0x000008, "Wrong alignment on UAISkill_Interaction_GeneratorSecondaryInteraction");
static_assert(sizeof(UAISkill_Interaction_GeneratorSecondaryInteraction) == 0x0001A0, "Wrong size on UAISkill_Interaction_GeneratorSecondaryInteraction");
static_assert(offsetof(UAISkill_Interaction_GeneratorSecondaryInteraction, Perks) == 0x000180, "Member 'UAISkill_Interaction_GeneratorSecondaryInteraction::Perks' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_GeneratorSecondaryInteraction, GeneratorSecondaryInteractionId) == 0x000190, "Member 'UAISkill_Interaction_GeneratorSecondaryInteraction::GeneratorSecondaryInteractionId' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_InLocker
// 0x0050 (0x01D0 - 0x0180)
class UAISkill_Interaction_InLocker : public UAISkill_Interaction
{
public:
	struct FDataTableDropdown                     PerkID;                                            // 0x0180(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CooldownTag;                                       // 0x01B0(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialRunningTime;                                // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartRefreshingTime;                               // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RefreshTimeMargin;                                 // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefreshTimeAmount;                                 // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_InLocker">();
	}
	static class UAISkill_Interaction_InLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_InLocker>();
	}
};
static_assert(alignof(UAISkill_Interaction_InLocker) == 0x000008, "Wrong alignment on UAISkill_Interaction_InLocker");
static_assert(sizeof(UAISkill_Interaction_InLocker) == 0x0001D0, "Wrong size on UAISkill_Interaction_InLocker");
static_assert(offsetof(UAISkill_Interaction_InLocker, PerkID) == 0x000180, "Member 'UAISkill_Interaction_InLocker::PerkID' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_InLocker, CooldownTag) == 0x0001B0, "Member 'UAISkill_Interaction_InLocker::CooldownTag' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_InLocker, InitialRunningTime) == 0x0001BC, "Member 'UAISkill_Interaction_InLocker::InitialRunningTime' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_InLocker, StartRefreshingTime) == 0x0001C0, "Member 'UAISkill_Interaction_InLocker::StartRefreshingTime' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_InLocker, RefreshTimeMargin) == 0x0001C4, "Member 'UAISkill_Interaction_InLocker::RefreshTimeMargin' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_InLocker, RefreshTimeAmount) == 0x0001C8, "Member 'UAISkill_Interaction_InLocker::RefreshTimeAmount' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_InLocker_BuiltToLast
// 0x0000 (0x01D0 - 0x01D0)
class UAISkill_Interaction_InLocker_BuiltToLast final : public UAISkill_Interaction_InLocker
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_InLocker_BuiltToLast">();
	}
	static class UAISkill_Interaction_InLocker_BuiltToLast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_InLocker_BuiltToLast>();
	}
};
static_assert(alignof(UAISkill_Interaction_InLocker_BuiltToLast) == 0x000008, "Wrong alignment on UAISkill_Interaction_InLocker_BuiltToLast");
static_assert(sizeof(UAISkill_Interaction_InLocker_BuiltToLast) == 0x0001D0, "Wrong size on UAISkill_Interaction_InLocker_BuiltToLast");

// Class DBDBots.AISkill_Interaction_InLocker_Flashbang
// 0x0000 (0x01D0 - 0x01D0)
class UAISkill_Interaction_InLocker_Flashbang final : public UAISkill_Interaction_InLocker
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_InLocker_Flashbang">();
	}
	static class UAISkill_Interaction_InLocker_Flashbang* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_InLocker_Flashbang>();
	}
};
static_assert(alignof(UAISkill_Interaction_InLocker_Flashbang) == 0x000008, "Wrong alignment on UAISkill_Interaction_InLocker_Flashbang");
static_assert(sizeof(UAISkill_Interaction_InLocker_Flashbang) == 0x0001D0, "Wrong size on UAISkill_Interaction_InLocker_Flashbang");

// Class DBDBots.AISkill_Interaction_InLocker_HeadOn
// 0x0010 (0x01E0 - 0x01D0)
class UAISkill_Interaction_InLocker_HeadOn final : public UAISkill_Interaction_InLocker
{
public:
	struct FAITunableParameter                    MaxKillerNearbyDistance;                           // 0x01D0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_InLocker_HeadOn">();
	}
	static class UAISkill_Interaction_InLocker_HeadOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_InLocker_HeadOn>();
	}
};
static_assert(alignof(UAISkill_Interaction_InLocker_HeadOn) == 0x000008, "Wrong alignment on UAISkill_Interaction_InLocker_HeadOn");
static_assert(sizeof(UAISkill_Interaction_InLocker_HeadOn) == 0x0001E0, "Wrong size on UAISkill_Interaction_InLocker_HeadOn");
static_assert(offsetof(UAISkill_Interaction_InLocker_HeadOn, MaxKillerNearbyDistance) == 0x0001D0, "Member 'UAISkill_Interaction_InLocker_HeadOn::MaxKillerNearbyDistance' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_InLocker_InnerHealing
// 0x0000 (0x01D0 - 0x01D0)
class UAISkill_Interaction_InLocker_InnerHealing final : public UAISkill_Interaction_InLocker
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_InLocker_InnerHealing">();
	}
	static class UAISkill_Interaction_InLocker_InnerHealing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_InLocker_InnerHealing>();
	}
};
static_assert(alignof(UAISkill_Interaction_InLocker_InnerHealing) == 0x000008, "Wrong alignment on UAISkill_Interaction_InLocker_InnerHealing");
static_assert(sizeof(UAISkill_Interaction_InLocker_InnerHealing) == 0x0001D0, "Wrong size on UAISkill_Interaction_InLocker_InnerHealing");

// Class DBDBots.AISkill_Interaction_Kill
// 0x0000 (0x0180 - 0x0180)
class UAISkill_Interaction_Kill final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_Kill">();
	}
	static class UAISkill_Interaction_Kill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_Kill>();
	}
};
static_assert(alignof(UAISkill_Interaction_Kill) == 0x000008, "Wrong alignment on UAISkill_Interaction_Kill");
static_assert(sizeof(UAISkill_Interaction_Kill) == 0x000180, "Wrong size on UAISkill_Interaction_Kill");

// Class DBDBots.AISkill_Interaction_RecoverWhileCrawling
// 0x0010 (0x0190 - 0x0180)
class UAISkill_Interaction_RecoverWhileCrawling final : public UAISkill_Interaction
{
public:
	TArray<struct FPerkIdDropdown>                Perks;                                             // 0x0180(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_RecoverWhileCrawling">();
	}
	static class UAISkill_Interaction_RecoverWhileCrawling* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_RecoverWhileCrawling>();
	}
};
static_assert(alignof(UAISkill_Interaction_RecoverWhileCrawling) == 0x000008, "Wrong alignment on UAISkill_Interaction_RecoverWhileCrawling");
static_assert(sizeof(UAISkill_Interaction_RecoverWhileCrawling) == 0x000190, "Wrong size on UAISkill_Interaction_RecoverWhileCrawling");
static_assert(offsetof(UAISkill_Interaction_RecoverWhileCrawling, Perks) == 0x000180, "Member 'UAISkill_Interaction_RecoverWhileCrawling::Perks' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_Reel
// 0x0000 (0x0180 - 0x0180)
class UAISkill_Interaction_Reel final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_Reel">();
	}
	static class UAISkill_Interaction_Reel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_Reel>();
	}
};
static_assert(alignof(UAISkill_Interaction_Reel) == 0x000008, "Wrong alignment on UAISkill_Interaction_Reel");
static_assert(sizeof(UAISkill_Interaction_Reel) == 0x000180, "Wrong size on UAISkill_Interaction_Reel");

// Class DBDBots.AISkill_Interaction_SendToDeathBed
// 0x0000 (0x0180 - 0x0180)
class UAISkill_Interaction_SendToDeathBed final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_SendToDeathBed">();
	}
	static class UAISkill_Interaction_SendToDeathBed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_SendToDeathBed>();
	}
};
static_assert(alignof(UAISkill_Interaction_SendToDeathBed) == 0x000008, "Wrong alignment on UAISkill_Interaction_SendToDeathBed");
static_assert(sizeof(UAISkill_Interaction_SendToDeathBed) == 0x000180, "Wrong size on UAISkill_Interaction_SendToDeathBed");

// Class DBDBots.BTDecorator_IsBeforeTimerExpiration
// 0x0040 (0x00B0 - 0x0070)
class UBTDecorator_IsBeforeTimerExpiration final : public UBTDecorator
{
public:
	struct FAITunableParameter                    AdditionalTime;                                    // 0x0070(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBFilterKey;                                       // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsBeforeTimerExpiration">();
	}
	static class UBTDecorator_IsBeforeTimerExpiration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsBeforeTimerExpiration>();
	}
};
static_assert(alignof(UBTDecorator_IsBeforeTimerExpiration) == 0x000008, "Wrong alignment on UBTDecorator_IsBeforeTimerExpiration");
static_assert(sizeof(UBTDecorator_IsBeforeTimerExpiration) == 0x0000B0, "Wrong size on UBTDecorator_IsBeforeTimerExpiration");
static_assert(offsetof(UBTDecorator_IsBeforeTimerExpiration, AdditionalTime) == 0x000070, "Member 'UBTDecorator_IsBeforeTimerExpiration::AdditionalTime' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsBeforeTimerExpiration, BBFilterKey) == 0x000080, "Member 'UBTDecorator_IsBeforeTimerExpiration::BBFilterKey' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_SetGeneratorTrap
// 0x0020 (0x01C0 - 0x01A0)
class UAISkill_Interaction_SetGeneratorTrap final : public UAISkill_Interaction_GeneratorSecondaryInteraction
{
public:
	uint8                                         Pad_1A0[0x4];                                      // 0x01A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckKillerDistanceInterval;                       // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinKillerApproachingSpeed;                         // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinKillerApproachingFastStreak;                    // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITerrorLevel                                TerrorLevelToSetTrap;                              // 0x01B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITerrorLevel                                TerrorLevelToSetTrapImmediately;                   // 0x01B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B2[0x2];                                      // 0x01B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TerrorLevelCloseRange;                             // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x8];                                      // 0x01B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_SetGeneratorTrap">();
	}
	static class UAISkill_Interaction_SetGeneratorTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_SetGeneratorTrap>();
	}
};
static_assert(alignof(UAISkill_Interaction_SetGeneratorTrap) == 0x000008, "Wrong alignment on UAISkill_Interaction_SetGeneratorTrap");
static_assert(sizeof(UAISkill_Interaction_SetGeneratorTrap) == 0x0001C0, "Wrong size on UAISkill_Interaction_SetGeneratorTrap");
static_assert(offsetof(UAISkill_Interaction_SetGeneratorTrap, CheckKillerDistanceInterval) == 0x0001A4, "Member 'UAISkill_Interaction_SetGeneratorTrap::CheckKillerDistanceInterval' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_SetGeneratorTrap, MinKillerApproachingSpeed) == 0x0001A8, "Member 'UAISkill_Interaction_SetGeneratorTrap::MinKillerApproachingSpeed' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_SetGeneratorTrap, MinKillerApproachingFastStreak) == 0x0001AC, "Member 'UAISkill_Interaction_SetGeneratorTrap::MinKillerApproachingFastStreak' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_SetGeneratorTrap, TerrorLevelToSetTrap) == 0x0001B0, "Member 'UAISkill_Interaction_SetGeneratorTrap::TerrorLevelToSetTrap' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_SetGeneratorTrap, TerrorLevelToSetTrapImmediately) == 0x0001B1, "Member 'UAISkill_Interaction_SetGeneratorTrap::TerrorLevelToSetTrapImmediately' has a wrong offset!");
static_assert(offsetof(UAISkill_Interaction_SetGeneratorTrap, TerrorLevelCloseRange) == 0x0001B4, "Member 'UAISkill_Interaction_SetGeneratorTrap::TerrorLevelCloseRange' has a wrong offset!");

// Class DBDBots.AISkill_Interaction_StaticBlast
// 0x0000 (0x0180 - 0x0180)
class UAISkill_Interaction_StaticBlast final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_StaticBlast">();
	}
	static class UAISkill_Interaction_StaticBlast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_StaticBlast>();
	}
};
static_assert(alignof(UAISkill_Interaction_StaticBlast) == 0x000008, "Wrong alignment on UAISkill_Interaction_StaticBlast");
static_assert(sizeof(UAISkill_Interaction_StaticBlast) == 0x000180, "Wrong size on UAISkill_Interaction_StaticBlast");

// Class DBDBots.BTService_StimuliMonitor
// 0x0168 (0x01E0 - 0x0078)
class UBTService_StimuliMonitor : public UBTService
{
public:
	struct FBlackboardKeySelector                 BBStimulusOriginLocation;                          // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBStimulusNavLocation;                             // 0x00A8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBStimulusActor;                                   // 0x00D8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBStimulusInSight;                                 // 0x0108(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBStimulusWasInSight;                              // 0x0138(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         StimulusWasInSightDuration;                        // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    StimuliRefreshInterval;                            // 0x016C(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ExtrapolateLoseSightDuration;                      // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NavMeshFindLocationExtents;                        // 0x0180(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SeenFriendlyStimuliExpiryInSeconds;                // 0x018C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class AActor*, float>                    _seenFriendlyStimuli;                              // 0x0190(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_StimuliMonitor">();
	}
	static class UBTService_StimuliMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_StimuliMonitor>();
	}
};
static_assert(alignof(UBTService_StimuliMonitor) == 0x000008, "Wrong alignment on UBTService_StimuliMonitor");
static_assert(sizeof(UBTService_StimuliMonitor) == 0x0001E0, "Wrong size on UBTService_StimuliMonitor");
static_assert(offsetof(UBTService_StimuliMonitor, BBStimulusOriginLocation) == 0x000078, "Member 'UBTService_StimuliMonitor::BBStimulusOriginLocation' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, BBStimulusNavLocation) == 0x0000A8, "Member 'UBTService_StimuliMonitor::BBStimulusNavLocation' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, BBStimulusActor) == 0x0000D8, "Member 'UBTService_StimuliMonitor::BBStimulusActor' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, BBStimulusInSight) == 0x000108, "Member 'UBTService_StimuliMonitor::BBStimulusInSight' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, BBStimulusWasInSight) == 0x000138, "Member 'UBTService_StimuliMonitor::BBStimulusWasInSight' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, StimulusWasInSightDuration) == 0x000168, "Member 'UBTService_StimuliMonitor::StimulusWasInSightDuration' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, StimuliRefreshInterval) == 0x00016C, "Member 'UBTService_StimuliMonitor::StimuliRefreshInterval' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, ExtrapolateLoseSightDuration) == 0x00017C, "Member 'UBTService_StimuliMonitor::ExtrapolateLoseSightDuration' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, NavMeshFindLocationExtents) == 0x000180, "Member 'UBTService_StimuliMonitor::NavMeshFindLocationExtents' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, SeenFriendlyStimuliExpiryInSeconds) == 0x00018C, "Member 'UBTService_StimuliMonitor::SeenFriendlyStimuliExpiryInSeconds' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor, _seenFriendlyStimuli) == 0x000190, "Member 'UBTService_StimuliMonitor::_seenFriendlyStimuli' has a wrong offset!");

// Class DBDBots.AISkill_InteractionSetTrap
// 0x0010 (0x0190 - 0x0180)
class UAISkill_InteractionSetTrap : public UAISkill_Interaction
{
public:
	TSubclassOf<class AActor>                     TrapClass;                                         // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceFromPointOfInterest;                    // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistanceFromAnotherSetTrap;                     // 0x018C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionSetTrap">();
	}
	static class UAISkill_InteractionSetTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionSetTrap>();
	}
};
static_assert(alignof(UAISkill_InteractionSetTrap) == 0x000008, "Wrong alignment on UAISkill_InteractionSetTrap");
static_assert(sizeof(UAISkill_InteractionSetTrap) == 0x000190, "Wrong size on UAISkill_InteractionSetTrap");
static_assert(offsetof(UAISkill_InteractionSetTrap, TrapClass) == 0x000180, "Member 'UAISkill_InteractionSetTrap::TrapClass' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionSetTrap, MaxDistanceFromPointOfInterest) == 0x000188, "Member 'UAISkill_InteractionSetTrap::MaxDistanceFromPointOfInterest' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionSetTrap, MaxDistanceFromAnotherSetTrap) == 0x00018C, "Member 'UAISkill_InteractionSetTrap::MaxDistanceFromAnotherSetTrap' has a wrong offset!");

// Class DBDBots.AISkill_InteractionSetTrap_Demogorgon
// 0x0000 (0x0190 - 0x0190)
class UAISkill_InteractionSetTrap_Demogorgon final : public UAISkill_InteractionSetTrap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionSetTrap_Demogorgon">();
	}
	static class UAISkill_InteractionSetTrap_Demogorgon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionSetTrap_Demogorgon>();
	}
};
static_assert(alignof(UAISkill_InteractionSetTrap_Demogorgon) == 0x000008, "Wrong alignment on UAISkill_InteractionSetTrap_Demogorgon");
static_assert(sizeof(UAISkill_InteractionSetTrap_Demogorgon) == 0x000190, "Wrong size on UAISkill_InteractionSetTrap_Demogorgon");

// Class DBDBots.EnvQueryContext_PinActor
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_PinActor final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_PinActor">();
	}
	static class UEnvQueryContext_PinActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_PinActor>();
	}
};
static_assert(alignof(UEnvQueryContext_PinActor) == 0x000008, "Wrong alignment on UEnvQueryContext_PinActor");
static_assert(sizeof(UEnvQueryContext_PinActor) == 0x000030, "Wrong size on UEnvQueryContext_PinActor");

// Class DBDBots.AISkill_InteractionSetTrap_DreamPallet
// 0x0000 (0x0190 - 0x0190)
class UAISkill_InteractionSetTrap_DreamPallet final : public UAISkill_InteractionSetTrap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionSetTrap_DreamPallet">();
	}
	static class UAISkill_InteractionSetTrap_DreamPallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionSetTrap_DreamPallet>();
	}
};
static_assert(alignof(UAISkill_InteractionSetTrap_DreamPallet) == 0x000008, "Wrong alignment on UAISkill_InteractionSetTrap_DreamPallet");
static_assert(sizeof(UAISkill_InteractionSetTrap_DreamPallet) == 0x000190, "Wrong size on UAISkill_InteractionSetTrap_DreamPallet");

// Class DBDBots.AISkill_InteractionSetTrap_DreamSnare
// 0x0000 (0x0190 - 0x0190)
class UAISkill_InteractionSetTrap_DreamSnare final : public UAISkill_InteractionSetTrap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionSetTrap_DreamSnare">();
	}
	static class UAISkill_InteractionSetTrap_DreamSnare* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionSetTrap_DreamSnare>();
	}
};
static_assert(alignof(UAISkill_InteractionSetTrap_DreamSnare) == 0x000008, "Wrong alignment on UAISkill_InteractionSetTrap_DreamSnare");
static_assert(sizeof(UAISkill_InteractionSetTrap_DreamSnare) == 0x000190, "Wrong size on UAISkill_InteractionSetTrap_DreamSnare");

// Class DBDBots.BTService_OnRelevantBase
// 0x0008 (0x0080 - 0x0078)
class UBTService_OnRelevantBase : public UBTService
{
public:
	EAINodeRelevancyOptions                       When;                                              // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_OnRelevantBase">();
	}
	static class UBTService_OnRelevantBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_OnRelevantBase>();
	}
};
static_assert(alignof(UBTService_OnRelevantBase) == 0x000008, "Wrong alignment on UBTService_OnRelevantBase");
static_assert(sizeof(UBTService_OnRelevantBase) == 0x000080, "Wrong size on UBTService_OnRelevantBase");
static_assert(offsetof(UBTService_OnRelevantBase, When) == 0x000078, "Member 'UBTService_OnRelevantBase::When' has a wrong offset!");

// Class DBDBots.BTService_ClearBBEntry
// 0x0030 (0x00B0 - 0x0080)
class UBTService_ClearBBEntry final : public UBTService_OnRelevantBase
{
public:
	struct FBlackboardKeySelector                 BBToResetKey;                                      // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_ClearBBEntry">();
	}
	static class UBTService_ClearBBEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_ClearBBEntry>();
	}
};
static_assert(alignof(UBTService_ClearBBEntry) == 0x000008, "Wrong alignment on UBTService_ClearBBEntry");
static_assert(sizeof(UBTService_ClearBBEntry) == 0x0000B0, "Wrong size on UBTService_ClearBBEntry");
static_assert(offsetof(UBTService_ClearBBEntry, BBToResetKey) == 0x000080, "Member 'UBTService_ClearBBEntry::BBToResetKey' has a wrong offset!");

// Class DBDBots.AISkill_InteractionSetTrap_Phantom
// 0x0000 (0x0190 - 0x0190)
class UAISkill_InteractionSetTrap_Phantom final : public UAISkill_InteractionSetTrap
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionSetTrap_Phantom">();
	}
	static class UAISkill_InteractionSetTrap_Phantom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionSetTrap_Phantom>();
	}
};
static_assert(alignof(UAISkill_InteractionSetTrap_Phantom) == 0x000008, "Wrong alignment on UAISkill_InteractionSetTrap_Phantom");
static_assert(sizeof(UAISkill_InteractionSetTrap_Phantom) == 0x000190, "Wrong size on UAISkill_InteractionSetTrap_Phantom");

// Class DBDBots.AISkill_InteractionTarget
// 0x00B0 (0x0230 - 0x0180)
class UAISkill_InteractionTarget : public UAISkill_Interaction
{
public:
	EInteractionTargetRequirements                TargetRequirement;                                 // 0x0180(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoSwapBestStimulusWithBestTarget;                // 0x0181(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_182[0x2];                                      // 0x0182(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartMinRange;                                     // 0x0184(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartMaxRange;                                     // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopMinRange;                                      // 0x018C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopMaxRange;                                      // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartMaxHalfAngle;                                 // 0x0194(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopMaxHalfAngle;                                  // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMaxHalfAngle2D;                                  // 0x019C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TestMaxHalfAngleOnPath;                            // 0x019D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19E[0x2];                                      // 0x019E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     MaxAngleFilterClass;                               // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionTargetInSightModes                InSightMode;                                       // 0x01A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0x3];                                      // 0x01A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutOfSightModeDelay;                               // 0x01AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMoveAwayTooFastStopDelay;                    // 0x01B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetMoveAwayTooFastCooldown;                     // 0x01B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysStrafeAroundTarget;                          // 0x01B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIDetectedStimulus>            _unfilteredTargets;                                // 0x01C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAIDetectedStimulus>            _filteredTargets;                                  // 0x01D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FTargetMoveAwayToFastInfo> _targetsMoveAwayTooFastInfo;               // 0x01E0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget">();
	}
	static class UAISkill_InteractionTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget");
static_assert(sizeof(UAISkill_InteractionTarget) == 0x000230, "Wrong size on UAISkill_InteractionTarget");
static_assert(offsetof(UAISkill_InteractionTarget, TargetRequirement) == 0x000180, "Member 'UAISkill_InteractionTarget::TargetRequirement' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, AutoSwapBestStimulusWithBestTarget) == 0x000181, "Member 'UAISkill_InteractionTarget::AutoSwapBestStimulusWithBestTarget' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, StartMinRange) == 0x000184, "Member 'UAISkill_InteractionTarget::StartMinRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, StartMaxRange) == 0x000188, "Member 'UAISkill_InteractionTarget::StartMaxRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, StopMinRange) == 0x00018C, "Member 'UAISkill_InteractionTarget::StopMinRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, StopMaxRange) == 0x000190, "Member 'UAISkill_InteractionTarget::StopMaxRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, StartMaxHalfAngle) == 0x000194, "Member 'UAISkill_InteractionTarget::StartMaxHalfAngle' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, StopMaxHalfAngle) == 0x000198, "Member 'UAISkill_InteractionTarget::StopMaxHalfAngle' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, IsMaxHalfAngle2D) == 0x00019C, "Member 'UAISkill_InteractionTarget::IsMaxHalfAngle2D' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, TestMaxHalfAngleOnPath) == 0x00019D, "Member 'UAISkill_InteractionTarget::TestMaxHalfAngleOnPath' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, MaxAngleFilterClass) == 0x0001A0, "Member 'UAISkill_InteractionTarget::MaxAngleFilterClass' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, InSightMode) == 0x0001A8, "Member 'UAISkill_InteractionTarget::InSightMode' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, OutOfSightModeDelay) == 0x0001AC, "Member 'UAISkill_InteractionTarget::OutOfSightModeDelay' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, TargetMoveAwayTooFastStopDelay) == 0x0001B0, "Member 'UAISkill_InteractionTarget::TargetMoveAwayTooFastStopDelay' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, TargetMoveAwayTooFastCooldown) == 0x0001B4, "Member 'UAISkill_InteractionTarget::TargetMoveAwayTooFastCooldown' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, AlwaysStrafeAroundTarget) == 0x0001B8, "Member 'UAISkill_InteractionTarget::AlwaysStrafeAroundTarget' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, _unfilteredTargets) == 0x0001C0, "Member 'UAISkill_InteractionTarget::_unfilteredTargets' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, _filteredTargets) == 0x0001D0, "Member 'UAISkill_InteractionTarget::_filteredTargets' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget, _targetsMoveAwayTooFastInfo) == 0x0001E0, "Member 'UAISkill_InteractionTarget::_targetsMoveAwayTooFastInfo' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_Aim
// 0x0000 (0x0230 - 0x0230)
class UAISkill_InteractionTarget_Aim final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_Aim">();
	}
	static class UAISkill_InteractionTarget_Aim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_Aim>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_Aim) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_Aim");
static_assert(sizeof(UAISkill_InteractionTarget_Aim) == 0x000230, "Wrong size on UAISkill_InteractionTarget_Aim");

// Class DBDBots.AISkill_InteractionTarget_AmbushAttack
// 0x0000 (0x0230 - 0x0230)
class UAISkill_InteractionTarget_AmbushAttack final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_AmbushAttack">();
	}
	static class UAISkill_InteractionTarget_AmbushAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_AmbushAttack>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_AmbushAttack) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_AmbushAttack");
static_assert(sizeof(UAISkill_InteractionTarget_AmbushAttack) == 0x000230, "Wrong size on UAISkill_InteractionTarget_AmbushAttack");

// Class DBDBots.PathStrategySelector
// 0x0038 (0x0068 - 0x0030)
class UPathStrategySelector : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDAIBTController*                     _aiOwner;                                          // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UPathStrategy*>                  _activePathStrategies;                             // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UPathStrategy*>                  _nextPathStrategies;                               // 0x0050(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathStrategySelector">();
	}
	static class UPathStrategySelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathStrategySelector>();
	}
};
static_assert(alignof(UPathStrategySelector) == 0x000008, "Wrong alignment on UPathStrategySelector");
static_assert(sizeof(UPathStrategySelector) == 0x000068, "Wrong size on UPathStrategySelector");
static_assert(offsetof(UPathStrategySelector, _aiOwner) == 0x000038, "Member 'UPathStrategySelector::_aiOwner' has a wrong offset!");
static_assert(offsetof(UPathStrategySelector, _activePathStrategies) == 0x000040, "Member 'UPathStrategySelector::_activePathStrategies' has a wrong offset!");
static_assert(offsetof(UPathStrategySelector, _nextPathStrategies) == 0x000050, "Member 'UPathStrategySelector::_nextPathStrategies' has a wrong offset!");

// Class DBDBots.PathStrategySelector_Flee
// 0x00A8 (0x0110 - 0x0068)
class UPathStrategySelector_Flee final : public UPathStrategySelector
{
public:
	TMap<EAIFleePathStrategy, class UPathStrategy*> FleePathStrategies;                              // 0x0068(0x0050)(Edit, ExportObject, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAIFleePathStrategy, class UPathStrategy*> _activeFleePathStrategiesMap;                    // 0x00C0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathStrategySelector_Flee">();
	}
	static class UPathStrategySelector_Flee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathStrategySelector_Flee>();
	}
};
static_assert(alignof(UPathStrategySelector_Flee) == 0x000008, "Wrong alignment on UPathStrategySelector_Flee");
static_assert(sizeof(UPathStrategySelector_Flee) == 0x000110, "Wrong size on UPathStrategySelector_Flee");
static_assert(offsetof(UPathStrategySelector_Flee, FleePathStrategies) == 0x000068, "Member 'UPathStrategySelector_Flee::FleePathStrategies' has a wrong offset!");
static_assert(offsetof(UPathStrategySelector_Flee, _activeFleePathStrategiesMap) == 0x0000C0, "Member 'UPathStrategySelector_Flee::_activeFleePathStrategiesMap' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_AmbushMode
// 0x0000 (0x0230 - 0x0230)
class UAISkill_InteractionTarget_AmbushMode final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_AmbushMode">();
	}
	static class UAISkill_InteractionTarget_AmbushMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_AmbushMode>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_AmbushMode) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_AmbushMode");
static_assert(sizeof(UAISkill_InteractionTarget_AmbushMode) == 0x000230, "Wrong size on UAISkill_InteractionTarget_AmbushMode");

// Class DBDBots.AISkill_InteractionTarget_Cloak
// 0x0000 (0x0230 - 0x0230)
class UAISkill_InteractionTarget_Cloak final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_Cloak">();
	}
	static class UAISkill_InteractionTarget_Cloak* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_Cloak>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_Cloak) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_Cloak");
static_assert(sizeof(UAISkill_InteractionTarget_Cloak) == 0x000230, "Wrong size on UAISkill_InteractionTarget_Cloak");

// Class DBDBots.DBDNavMeshExplorerComponent
// 0x0088 (0x0140 - 0x00B8)
class UDBDNavMeshExplorerComponent final : public UActorComponent
{
public:
	float                                         ExploreAtAgentMoveDistance;                        // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExploreAtInterval;                                 // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ExplorationBoxHalfExtent;                          // 0x00C0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         FullyAutoExploredAtGameTime;                       // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDPathFollowingComponent*             _pathFollowingComponent;                           // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x60];                                      // 0x00E0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDNavMeshExplorerComponent">();
	}
	static class UDBDNavMeshExplorerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDNavMeshExplorerComponent>();
	}
};
static_assert(alignof(UDBDNavMeshExplorerComponent) == 0x000008, "Wrong alignment on UDBDNavMeshExplorerComponent");
static_assert(sizeof(UDBDNavMeshExplorerComponent) == 0x000140, "Wrong size on UDBDNavMeshExplorerComponent");
static_assert(offsetof(UDBDNavMeshExplorerComponent, ExploreAtAgentMoveDistance) == 0x0000B8, "Member 'UDBDNavMeshExplorerComponent::ExploreAtAgentMoveDistance' has a wrong offset!");
static_assert(offsetof(UDBDNavMeshExplorerComponent, ExploreAtInterval) == 0x0000BC, "Member 'UDBDNavMeshExplorerComponent::ExploreAtInterval' has a wrong offset!");
static_assert(offsetof(UDBDNavMeshExplorerComponent, ExplorationBoxHalfExtent) == 0x0000C0, "Member 'UDBDNavMeshExplorerComponent::ExplorationBoxHalfExtent' has a wrong offset!");
static_assert(offsetof(UDBDNavMeshExplorerComponent, FullyAutoExploredAtGameTime) == 0x0000D0, "Member 'UDBDNavMeshExplorerComponent::FullyAutoExploredAtGameTime' has a wrong offset!");
static_assert(offsetof(UDBDNavMeshExplorerComponent, _pathFollowingComponent) == 0x0000D8, "Member 'UDBDNavMeshExplorerComponent::_pathFollowingComponent' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_Dash
// 0x0000 (0x0230 - 0x0230)
class UAISkill_InteractionTarget_Dash : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_Dash">();
	}
	static class UAISkill_InteractionTarget_Dash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_Dash>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_Dash) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_Dash");
static_assert(sizeof(UAISkill_InteractionTarget_Dash) == 0x000230, "Wrong size on UAISkill_InteractionTarget_Dash");

// Class DBDBots.AISkill_InteractionTarget_DashAttack
// 0x0010 (0x0240 - 0x0230)
class UAISkill_InteractionTarget_DashAttack : public UAISkill_InteractionTarget_Dash
{
public:
	float                                         DashAttackUnderMaxRange;                           // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashAttackUnderMaxHalfAngle;                       // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttackType                                   ExpectedAttackType;                                // 0x0238(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_DashAttack">();
	}
	static class UAISkill_InteractionTarget_DashAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_DashAttack>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_DashAttack) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_DashAttack");
static_assert(sizeof(UAISkill_InteractionTarget_DashAttack) == 0x000240, "Wrong size on UAISkill_InteractionTarget_DashAttack");
static_assert(offsetof(UAISkill_InteractionTarget_DashAttack, DashAttackUnderMaxRange) == 0x000230, "Member 'UAISkill_InteractionTarget_DashAttack::DashAttackUnderMaxRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_DashAttack, DashAttackUnderMaxHalfAngle) == 0x000234, "Member 'UAISkill_InteractionTarget_DashAttack::DashAttackUnderMaxHalfAngle' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_DashAttack, ExpectedAttackType) == 0x000238, "Member 'UAISkill_InteractionTarget_DashAttack::ExpectedAttackType' has a wrong offset!");

// Class DBDBots.BTDecorator_Random
// 0x0010 (0x0080 - 0x0070)
class UBTDecorator_Random final : public UBTDecorator_TickableBase
{
public:
	struct FAITunableParameter                    PercentageRatio;                                   // 0x0070(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_Random">();
	}
	static class UBTDecorator_Random* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_Random>();
	}
};
static_assert(alignof(UBTDecorator_Random) == 0x000008, "Wrong alignment on UBTDecorator_Random");
static_assert(sizeof(UBTDecorator_Random) == 0x000080, "Wrong size on UBTDecorator_Random");
static_assert(offsetof(UBTDecorator_Random, PercentageRatio) == 0x000070, "Member 'UBTDecorator_Random::PercentageRatio' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_DashAttack_Cannibal
// 0x0000 (0x0240 - 0x0240)
class UAISkill_InteractionTarget_DashAttack_Cannibal final : public UAISkill_InteractionTarget_DashAttack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_DashAttack_Cannibal">();
	}
	static class UAISkill_InteractionTarget_DashAttack_Cannibal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_DashAttack_Cannibal>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_DashAttack_Cannibal) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_DashAttack_Cannibal");
static_assert(sizeof(UAISkill_InteractionTarget_DashAttack_Cannibal) == 0x000240, "Wrong size on UAISkill_InteractionTarget_DashAttack_Cannibal");

// Class DBDBots.AISkill_InteractionTarget_DashAttack_Chainsaw
// 0x0000 (0x0240 - 0x0240)
class UAISkill_InteractionTarget_DashAttack_Chainsaw final : public UAISkill_InteractionTarget_DashAttack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_DashAttack_Chainsaw">();
	}
	static class UAISkill_InteractionTarget_DashAttack_Chainsaw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_DashAttack_Chainsaw>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_DashAttack_Chainsaw) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_DashAttack_Chainsaw");
static_assert(sizeof(UAISkill_InteractionTarget_DashAttack_Chainsaw) == 0x000240, "Wrong size on UAISkill_InteractionTarget_DashAttack_Chainsaw");

// Class DBDBots.BTTask_ExtMoveTo
// 0x0188 (0x0248 - 0x00C0)
class UBTTask_ExtMoveTo : public UBTTask_MoveTo
{
public:
	struct FBlackboardKeySelector                 BBStrafeFocus;                                     // 0x00C0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EExtMoveToStrafeFocusOptions                  StrafeFocus;                                       // 0x00F0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StrafeFocusPitch;                                  // 0x00F1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x2];                                       // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StrafeNearFocusModeUnderDistance;                  // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntermittentOnStrafeFocusInterval;                 // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntermittentOnStrafeFocusDeviation;                // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntermittentOffStrafeFocusInterval;                // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntermittentOffStrafeFocusDeviation;               // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndMoveStrafeFocusPrecisionAngle;                  // 0x0108(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StrafeFocusOwnerOnComponentBBKey;                  // 0x010C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterMovementTypes                       ToGoalMovementMode;                                // 0x010D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterMovementTypes                       NearGoalMovementMode;                              // 0x010E(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10F[0x1];                                      // 0x010F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NearGoalModeUnderDistance;                         // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalMoveUnderNavLinkDistance;                    // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIgnoreGroupAvoidance;                            // 0x0118(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         BlockedCheckInterval;                              // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlockedContinueTimes;                              // 0x014C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockedSpeedPercent;                               // 0x0150(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxTriesToRepathAroundBlocker;                     // 0x0154(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMovementModeNearActor>         MovementModesNearActors;                           // 0x0158(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         RepathInterval;                                    // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAccelerationForPaths;                           // 0x016C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathReachedPointRadius;                            // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UseContextualAcceptableRadius;                     // 0x0174(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FindRelevantDangerInterval;                        // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateTraverseStatesInterval;                      // 0x0184(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FailTaskOnUndodgeableDangerObject;                 // 0x0188(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreDangerObjects;                               // 0x0189(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18A[0x16];                                     // 0x018A(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, bool>                     _seenActorsMap;                                    // 0x01A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F0[0x58];                                     // 0x01F0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ExtMoveTo">();
	}
	static class UBTTask_ExtMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ExtMoveTo>();
	}
};
static_assert(alignof(UBTTask_ExtMoveTo) == 0x000008, "Wrong alignment on UBTTask_ExtMoveTo");
static_assert(sizeof(UBTTask_ExtMoveTo) == 0x000248, "Wrong size on UBTTask_ExtMoveTo");
static_assert(offsetof(UBTTask_ExtMoveTo, BBStrafeFocus) == 0x0000C0, "Member 'UBTTask_ExtMoveTo::BBStrafeFocus' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, StrafeFocus) == 0x0000F0, "Member 'UBTTask_ExtMoveTo::StrafeFocus' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, StrafeFocusPitch) == 0x0000F1, "Member 'UBTTask_ExtMoveTo::StrafeFocusPitch' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, StrafeNearFocusModeUnderDistance) == 0x0000F4, "Member 'UBTTask_ExtMoveTo::StrafeNearFocusModeUnderDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, IntermittentOnStrafeFocusInterval) == 0x0000F8, "Member 'UBTTask_ExtMoveTo::IntermittentOnStrafeFocusInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, IntermittentOnStrafeFocusDeviation) == 0x0000FC, "Member 'UBTTask_ExtMoveTo::IntermittentOnStrafeFocusDeviation' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, IntermittentOffStrafeFocusInterval) == 0x000100, "Member 'UBTTask_ExtMoveTo::IntermittentOffStrafeFocusInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, IntermittentOffStrafeFocusDeviation) == 0x000104, "Member 'UBTTask_ExtMoveTo::IntermittentOffStrafeFocusDeviation' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, EndMoveStrafeFocusPrecisionAngle) == 0x000108, "Member 'UBTTask_ExtMoveTo::EndMoveStrafeFocusPrecisionAngle' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, StrafeFocusOwnerOnComponentBBKey) == 0x00010C, "Member 'UBTTask_ExtMoveTo::StrafeFocusOwnerOnComponentBBKey' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, ToGoalMovementMode) == 0x00010D, "Member 'UBTTask_ExtMoveTo::ToGoalMovementMode' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, NearGoalMovementMode) == 0x00010E, "Member 'UBTTask_ExtMoveTo::NearGoalMovementMode' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, NearGoalModeUnderDistance) == 0x000110, "Member 'UBTTask_ExtMoveTo::NearGoalModeUnderDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, NormalMoveUnderNavLinkDistance) == 0x000114, "Member 'UBTTask_ExtMoveTo::NormalMoveUnderNavLinkDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, BBIgnoreGroupAvoidance) == 0x000118, "Member 'UBTTask_ExtMoveTo::BBIgnoreGroupAvoidance' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, BlockedCheckInterval) == 0x000148, "Member 'UBTTask_ExtMoveTo::BlockedCheckInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, BlockedContinueTimes) == 0x00014C, "Member 'UBTTask_ExtMoveTo::BlockedContinueTimes' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, BlockedSpeedPercent) == 0x000150, "Member 'UBTTask_ExtMoveTo::BlockedSpeedPercent' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, MaxTriesToRepathAroundBlocker) == 0x000154, "Member 'UBTTask_ExtMoveTo::MaxTriesToRepathAroundBlocker' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, MovementModesNearActors) == 0x000158, "Member 'UBTTask_ExtMoveTo::MovementModesNearActors' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, RepathInterval) == 0x000168, "Member 'UBTTask_ExtMoveTo::RepathInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, UseAccelerationForPaths) == 0x00016C, "Member 'UBTTask_ExtMoveTo::UseAccelerationForPaths' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, PathReachedPointRadius) == 0x000170, "Member 'UBTTask_ExtMoveTo::PathReachedPointRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, UseContextualAcceptableRadius) == 0x000174, "Member 'UBTTask_ExtMoveTo::UseContextualAcceptableRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, FindRelevantDangerInterval) == 0x000180, "Member 'UBTTask_ExtMoveTo::FindRelevantDangerInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, UpdateTraverseStatesInterval) == 0x000184, "Member 'UBTTask_ExtMoveTo::UpdateTraverseStatesInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, FailTaskOnUndodgeableDangerObject) == 0x000188, "Member 'UBTTask_ExtMoveTo::FailTaskOnUndodgeableDangerObject' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, IgnoreDangerObjects) == 0x000189, "Member 'UBTTask_ExtMoveTo::IgnoreDangerObjects' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtMoveTo, _seenActorsMap) == 0x0001A0, "Member 'UBTTask_ExtMoveTo::_seenActorsMap' has a wrong offset!");

// Class DBDBots.BTTask_StealthMoveTo
// 0x0000 (0x0248 - 0x0248)
class UBTTask_StealthMoveTo final : public UBTTask_ExtMoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_StealthMoveTo">();
	}
	static class UBTTask_StealthMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_StealthMoveTo>();
	}
};
static_assert(alignof(UBTTask_StealthMoveTo) == 0x000008, "Wrong alignment on UBTTask_StealthMoveTo");
static_assert(sizeof(UBTTask_StealthMoveTo) == 0x000248, "Wrong size on UBTTask_StealthMoveTo");

// Class DBDBots.AISkill_InteractionTarget_DashAttack_Demogorgon
// 0x0000 (0x0240 - 0x0240)
class UAISkill_InteractionTarget_DashAttack_Demogorgon final : public UAISkill_InteractionTarget_DashAttack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_DashAttack_Demogorgon">();
	}
	static class UAISkill_InteractionTarget_DashAttack_Demogorgon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_DashAttack_Demogorgon>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_DashAttack_Demogorgon) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_DashAttack_Demogorgon");
static_assert(sizeof(UAISkill_InteractionTarget_DashAttack_Demogorgon) == 0x000240, "Wrong size on UAISkill_InteractionTarget_DashAttack_Demogorgon");

// Class DBDBots.AISkill_InteractionTarget_DashHillbilly
// 0x0000 (0x0230 - 0x0230)
class UAISkill_InteractionTarget_DashHillbilly final : public UAISkill_InteractionTarget_Dash
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_DashHillbilly">();
	}
	static class UAISkill_InteractionTarget_DashHillbilly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_DashHillbilly>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_DashHillbilly) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_DashHillbilly");
static_assert(sizeof(UAISkill_InteractionTarget_DashHillbilly) == 0x000230, "Wrong size on UAISkill_InteractionTarget_DashHillbilly");

// Class DBDBots.AISkill_InteractionTarget_DeadHard
// 0x0000 (0x0230 - 0x0230)
class UAISkill_InteractionTarget_DeadHard final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_DeadHard">();
	}
	static class UAISkill_InteractionTarget_DeadHard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_DeadHard>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_DeadHard) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_DeadHard");
static_assert(sizeof(UAISkill_InteractionTarget_DeadHard) == 0x000230, "Wrong size on UAISkill_InteractionTarget_DeadHard");

// Class DBDBots.AISkill_InteractionTarget_Fire
// 0x0000 (0x0230 - 0x0230)
class UAISkill_InteractionTarget_Fire final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_Fire">();
	}
	static class UAISkill_InteractionTarget_Fire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_Fire>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_Fire) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_Fire");
static_assert(sizeof(UAISkill_InteractionTarget_Fire) == 0x000230, "Wrong size on UAISkill_InteractionTarget_Fire");

// Class DBDBots.NavigationQueryFilter_Player
// 0x0020 (0x0070 - 0x0050)
class UNavigationQueryFilter_Player : public UNavigationQueryFilter
{
public:
	int32                                         MaxSearchNodes;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x1C];                                      // 0x0054(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_Player">();
	}
	static class UNavigationQueryFilter_Player* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_Player>();
	}
};
static_assert(alignof(UNavigationQueryFilter_Player) == 0x000008, "Wrong alignment on UNavigationQueryFilter_Player");
static_assert(sizeof(UNavigationQueryFilter_Player) == 0x000070, "Wrong size on UNavigationQueryFilter_Player");
static_assert(offsetof(UNavigationQueryFilter_Player, MaxSearchNodes) == 0x000050, "Member 'UNavigationQueryFilter_Player::MaxSearchNodes' has a wrong offset!");

// Class DBDBots.NavigationQueryFilter_Camper
// 0x0018 (0x0088 - 0x0070)
class UNavigationQueryFilter_Camper : public UNavigationQueryFilter_Player
{
public:
	float                                         SlasherAreaBoundsLimit;                            // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlasherAreaPenetrationCost;                        // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlasherInSightCost;                                // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlasherAreaExcludeUnderRange;                      // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlasherInExcludeAreaCost;                          // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_Camper">();
	}
	static class UNavigationQueryFilter_Camper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_Camper>();
	}
};
static_assert(alignof(UNavigationQueryFilter_Camper) == 0x000008, "Wrong alignment on UNavigationQueryFilter_Camper");
static_assert(sizeof(UNavigationQueryFilter_Camper) == 0x000088, "Wrong size on UNavigationQueryFilter_Camper");
static_assert(offsetof(UNavigationQueryFilter_Camper, SlasherAreaBoundsLimit) == 0x000070, "Member 'UNavigationQueryFilter_Camper::SlasherAreaBoundsLimit' has a wrong offset!");
static_assert(offsetof(UNavigationQueryFilter_Camper, SlasherAreaPenetrationCost) == 0x000074, "Member 'UNavigationQueryFilter_Camper::SlasherAreaPenetrationCost' has a wrong offset!");
static_assert(offsetof(UNavigationQueryFilter_Camper, SlasherInSightCost) == 0x000078, "Member 'UNavigationQueryFilter_Camper::SlasherInSightCost' has a wrong offset!");
static_assert(offsetof(UNavigationQueryFilter_Camper, SlasherAreaExcludeUnderRange) == 0x00007C, "Member 'UNavigationQueryFilter_Camper::SlasherAreaExcludeUnderRange' has a wrong offset!");
static_assert(offsetof(UNavigationQueryFilter_Camper, SlasherInExcludeAreaCost) == 0x000080, "Member 'UNavigationQueryFilter_Camper::SlasherInExcludeAreaCost' has a wrong offset!");

// Class DBDBots.NavigationQueryFilter_Camper_Cheap
// 0x0000 (0x0088 - 0x0088)
class UNavigationQueryFilter_Camper_Cheap final : public UNavigationQueryFilter_Camper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_Camper_Cheap">();
	}
	static class UNavigationQueryFilter_Camper_Cheap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_Camper_Cheap>();
	}
};
static_assert(alignof(UNavigationQueryFilter_Camper_Cheap) == 0x000008, "Wrong alignment on UNavigationQueryFilter_Camper_Cheap");
static_assert(sizeof(UNavigationQueryFilter_Camper_Cheap) == 0x000088, "Wrong size on UNavigationQueryFilter_Camper_Cheap");

// Class DBDBots.AISkill_InteractionTarget_Frenzy
// 0x0000 (0x0230 - 0x0230)
class UAISkill_InteractionTarget_Frenzy final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_Frenzy">();
	}
	static class UAISkill_InteractionTarget_Frenzy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_Frenzy>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_Frenzy) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_Frenzy");
static_assert(sizeof(UAISkill_InteractionTarget_Frenzy) == 0x000230, "Wrong size on UAISkill_InteractionTarget_Frenzy");

// Class DBDBots.AISkill_InteractionTarget_LungeAttack
// 0x0000 (0x0230 - 0x0230)
class UAISkill_InteractionTarget_LungeAttack final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_LungeAttack">();
	}
	static class UAISkill_InteractionTarget_LungeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_LungeAttack>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_LungeAttack) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_LungeAttack");
static_assert(sizeof(UAISkill_InteractionTarget_LungeAttack) == 0x000230, "Wrong size on UAISkill_InteractionTarget_LungeAttack");

// Class DBDBots.AISkill_InteractionTarget_PhaseWalk
// 0x0000 (0x0230 - 0x0230)
class UAISkill_InteractionTarget_PhaseWalk final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_PhaseWalk">();
	}
	static class UAISkill_InteractionTarget_PhaseWalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_PhaseWalk>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_PhaseWalk) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_PhaseWalk");
static_assert(sizeof(UAISkill_InteractionTarget_PhaseWalk) == 0x000230, "Wrong size on UAISkill_InteractionTarget_PhaseWalk");

// Class DBDBots.AISkill_InteractionTarget_ReloadDeathSlinger
// 0x0000 (0x0230 - 0x0230)
class UAISkill_InteractionTarget_ReloadDeathSlinger final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_ReloadDeathSlinger">();
	}
	static class UAISkill_InteractionTarget_ReloadDeathSlinger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_ReloadDeathSlinger>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_ReloadDeathSlinger) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_ReloadDeathSlinger");
static_assert(sizeof(UAISkill_InteractionTarget_ReloadDeathSlinger) == 0x000230, "Wrong size on UAISkill_InteractionTarget_ReloadDeathSlinger");

// Class DBDBots.BTDecorator_IsObjectFocused
// 0x0038 (0x00A8 - 0x0070)
class UBTDecorator_IsObjectFocused final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBObj;                                             // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EDecoratorIsObjFocusedFilter                  Filter;                                            // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsObjectFocused">();
	}
	static class UBTDecorator_IsObjectFocused* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsObjectFocused>();
	}
};
static_assert(alignof(UBTDecorator_IsObjectFocused) == 0x000008, "Wrong alignment on UBTDecorator_IsObjectFocused");
static_assert(sizeof(UBTDecorator_IsObjectFocused) == 0x0000A8, "Wrong size on UBTDecorator_IsObjectFocused");
static_assert(offsetof(UBTDecorator_IsObjectFocused, BBObj) == 0x000070, "Member 'UBTDecorator_IsObjectFocused::BBObj' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsObjectFocused, Filter) == 0x0000A0, "Member 'UBTDecorator_IsObjectFocused::Filter' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_ShockTherapy
// 0x0008 (0x0238 - 0x0230)
class UAISkill_InteractionTarget_ShockTherapy final : public UAISkill_InteractionTarget
{
public:
	float                                         TargetToEvadePointMaxDistance;                     // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CastShockTimeBuffer;                               // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_ShockTherapy">();
	}
	static class UAISkill_InteractionTarget_ShockTherapy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_ShockTherapy>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_ShockTherapy) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_ShockTherapy");
static_assert(sizeof(UAISkill_InteractionTarget_ShockTherapy) == 0x000238, "Wrong size on UAISkill_InteractionTarget_ShockTherapy");
static_assert(offsetof(UAISkill_InteractionTarget_ShockTherapy, TargetToEvadePointMaxDistance) == 0x000230, "Member 'UAISkill_InteractionTarget_ShockTherapy::TargetToEvadePointMaxDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_ShockTherapy, CastShockTimeBuffer) == 0x000234, "Member 'UAISkill_InteractionTarget_ShockTherapy::CastShockTimeBuffer' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_Stalk
// 0x0000 (0x0230 - 0x0230)
class UAISkill_InteractionTarget_Stalk : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_Stalk">();
	}
	static class UAISkill_InteractionTarget_Stalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_Stalk>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_Stalk) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_Stalk");
static_assert(sizeof(UAISkill_InteractionTarget_Stalk) == 0x000230, "Wrong size on UAISkill_InteractionTarget_Stalk");

// Class DBDBots.AISkill_InteractionTarget_StalkGhost
// 0x0010 (0x0240 - 0x0230)
class UAISkill_InteractionTarget_StalkGhost final : public UAISkill_InteractionTarget_Stalk
{
public:
	float                                         CautiousModeUnderTargetRange;                      // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CautiousModeSpeedFactor;                           // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackFromCautiousDelay;                             // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_StalkGhost">();
	}
	static class UAISkill_InteractionTarget_StalkGhost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_StalkGhost>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_StalkGhost) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_StalkGhost");
static_assert(sizeof(UAISkill_InteractionTarget_StalkGhost) == 0x000240, "Wrong size on UAISkill_InteractionTarget_StalkGhost");
static_assert(offsetof(UAISkill_InteractionTarget_StalkGhost, CautiousModeUnderTargetRange) == 0x000230, "Member 'UAISkill_InteractionTarget_StalkGhost::CautiousModeUnderTargetRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_StalkGhost, CautiousModeSpeedFactor) == 0x000234, "Member 'UAISkill_InteractionTarget_StalkGhost::CautiousModeSpeedFactor' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_StalkGhost, BackFromCautiousDelay) == 0x000238, "Member 'UAISkill_InteractionTarget_StalkGhost::BackFromCautiousDelay' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_StalkShape
// 0x0008 (0x0238 - 0x0230)
class UAISkill_InteractionTarget_StalkShape final : public UAISkill_InteractionTarget_Stalk
{
public:
	int32                                         StalkRangeLimitedAtEvilTier;                       // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxStalkRangeWhenLimitedByEvilTier;                // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_StalkShape">();
	}
	static class UAISkill_InteractionTarget_StalkShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_StalkShape>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_StalkShape) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_StalkShape");
static_assert(sizeof(UAISkill_InteractionTarget_StalkShape) == 0x000238, "Wrong size on UAISkill_InteractionTarget_StalkShape");
static_assert(offsetof(UAISkill_InteractionTarget_StalkShape, StalkRangeLimitedAtEvilTier) == 0x000230, "Member 'UAISkill_InteractionTarget_StalkShape::StalkRangeLimitedAtEvilTier' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_StalkShape, MaxStalkRangeWhenLimitedByEvilTier) == 0x000234, "Member 'UAISkill_InteractionTarget_StalkShape::MaxStalkRangeWhenLimitedByEvilTier' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_StealthGhost
// 0x0008 (0x0238 - 0x0230)
class UAISkill_InteractionTarget_StealthGhost final : public UAISkill_InteractionTarget
{
public:
	float                                         CrouchSwapDelay;                                   // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_StealthGhost">();
	}
	static class UAISkill_InteractionTarget_StealthGhost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_StealthGhost>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_StealthGhost) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_StealthGhost");
static_assert(sizeof(UAISkill_InteractionTarget_StealthGhost) == 0x000238, "Wrong size on UAISkill_InteractionTarget_StealthGhost");
static_assert(offsetof(UAISkill_InteractionTarget_StealthGhost, CrouchSwapDelay) == 0x000230, "Member 'UAISkill_InteractionTarget_StealthGhost::CrouchSwapDelay' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_Throw
// 0x0078 (0x02A8 - 0x0230)
class UAISkill_InteractionTarget_Throw : public UAISkill_InteractionTarget
{
public:
	EAIThrowPredictionModes                       ThrowPredictionMode;                               // 0x0230(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxAddPitchAngle;                                  // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIThrowProjectileModes                       ThrowProjectileMode;                               // 0x0238(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    HoldInputTimeRandDeviation;                        // 0x023C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PitchAngleRandDeviation;                           // 0x024C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4C];                                     // 0x025C(0x004C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_Throw">();
	}
	static class UAISkill_InteractionTarget_Throw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_Throw>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_Throw) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_Throw");
static_assert(sizeof(UAISkill_InteractionTarget_Throw) == 0x0002A8, "Wrong size on UAISkill_InteractionTarget_Throw");
static_assert(offsetof(UAISkill_InteractionTarget_Throw, ThrowPredictionMode) == 0x000230, "Member 'UAISkill_InteractionTarget_Throw::ThrowPredictionMode' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_Throw, MaxAddPitchAngle) == 0x000234, "Member 'UAISkill_InteractionTarget_Throw::MaxAddPitchAngle' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_Throw, ThrowProjectileMode) == 0x000238, "Member 'UAISkill_InteractionTarget_Throw::ThrowProjectileMode' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_Throw, HoldInputTimeRandDeviation) == 0x00023C, "Member 'UAISkill_InteractionTarget_Throw::HoldInputTimeRandDeviation' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_Throw, PitchAngleRandDeviation) == 0x00024C, "Member 'UAISkill_InteractionTarget_Throw::PitchAngleRandDeviation' has a wrong offset!");

// Class DBDBots.DBDAIStateComponent
// 0x0258 (0x0310 - 0x00B8)
class UDBDAIStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UnsafeStateAtHookedCount;                          // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DireStateAtHookedCount;                            // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MidObjectiveStateProgressionRatio;                 // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAIObjectiveState, struct FDangerStateGameStateMapContainer> GameStateTable;                // 0x00D0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAIDifficultyLevel, struct FGameStatePressureZoneLevelMapContainer> PressureZoneLevelTable; // 0x0120(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAIDifficultyLevel, float>               MinRadiusPressureZoneHabituation;                  // 0x0170(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAIPressureZoneLevel, float>             PressureZoneHighToLowRangeLerpRatios;              // 0x01C0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         DefaultChasedPhaseOutDuration;                     // 0x0210(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InjuredChasedPhaseOutDuration;                     // 0x0214(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultBeingAimedAtPhaseOutDuration;               // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InjuredBeingAimedAtPhaseOutDuration;               // 0x021C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StimulusWasInSightDuration;                        // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoSFoVToStimulusCheckPeriod;                       // 0x0224(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoSToStimulusValidDuration;                        // 0x0228(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FoVToStimulusValidDuration;                        // 0x022C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockingSurvivorLocationLifetime;                  // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlockingSurvivorLocationAcceptableDistSq;          // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumBlockingSurvivorLocationDist;               // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0xD4];                                     // 0x023C(0x00D4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSpecialAttackEventDispatched(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void OnStartAimingEventDispatched(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void OnUniqueGameplayEvent(EDBDScoreTypes eventType, float amount, class AActor* instigator, class AActor* target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIStateComponent">();
	}
	static class UDBDAIStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAIStateComponent>();
	}
};
static_assert(alignof(UDBDAIStateComponent) == 0x000008, "Wrong alignment on UDBDAIStateComponent");
static_assert(sizeof(UDBDAIStateComponent) == 0x000310, "Wrong size on UDBDAIStateComponent");
static_assert(offsetof(UDBDAIStateComponent, UnsafeStateAtHookedCount) == 0x0000C0, "Member 'UDBDAIStateComponent::UnsafeStateAtHookedCount' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, DireStateAtHookedCount) == 0x0000C4, "Member 'UDBDAIStateComponent::DireStateAtHookedCount' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, MidObjectiveStateProgressionRatio) == 0x0000C8, "Member 'UDBDAIStateComponent::MidObjectiveStateProgressionRatio' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, GameStateTable) == 0x0000D0, "Member 'UDBDAIStateComponent::GameStateTable' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, PressureZoneLevelTable) == 0x000120, "Member 'UDBDAIStateComponent::PressureZoneLevelTable' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, MinRadiusPressureZoneHabituation) == 0x000170, "Member 'UDBDAIStateComponent::MinRadiusPressureZoneHabituation' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, PressureZoneHighToLowRangeLerpRatios) == 0x0001C0, "Member 'UDBDAIStateComponent::PressureZoneHighToLowRangeLerpRatios' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, DefaultChasedPhaseOutDuration) == 0x000210, "Member 'UDBDAIStateComponent::DefaultChasedPhaseOutDuration' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, InjuredChasedPhaseOutDuration) == 0x000214, "Member 'UDBDAIStateComponent::InjuredChasedPhaseOutDuration' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, DefaultBeingAimedAtPhaseOutDuration) == 0x000218, "Member 'UDBDAIStateComponent::DefaultBeingAimedAtPhaseOutDuration' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, InjuredBeingAimedAtPhaseOutDuration) == 0x00021C, "Member 'UDBDAIStateComponent::InjuredBeingAimedAtPhaseOutDuration' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, StimulusWasInSightDuration) == 0x000220, "Member 'UDBDAIStateComponent::StimulusWasInSightDuration' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, LoSFoVToStimulusCheckPeriod) == 0x000224, "Member 'UDBDAIStateComponent::LoSFoVToStimulusCheckPeriod' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, LoSToStimulusValidDuration) == 0x000228, "Member 'UDBDAIStateComponent::LoSToStimulusValidDuration' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, FoVToStimulusValidDuration) == 0x00022C, "Member 'UDBDAIStateComponent::FoVToStimulusValidDuration' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, BlockingSurvivorLocationLifetime) == 0x000230, "Member 'UDBDAIStateComponent::BlockingSurvivorLocationLifetime' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, BlockingSurvivorLocationAcceptableDistSq) == 0x000234, "Member 'UDBDAIStateComponent::BlockingSurvivorLocationAcceptableDistSq' has a wrong offset!");
static_assert(offsetof(UDBDAIStateComponent, MaximumBlockingSurvivorLocationDist) == 0x000238, "Member 'UDBDAIStateComponent::MaximumBlockingSurvivorLocationDist' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_ThrowHatchet
// 0x0000 (0x02A8 - 0x02A8)
class UAISkill_InteractionTarget_ThrowHatchet final : public UAISkill_InteractionTarget_Throw
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_ThrowHatchet">();
	}
	static class UAISkill_InteractionTarget_ThrowHatchet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_ThrowHatchet>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_ThrowHatchet) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_ThrowHatchet");
static_assert(sizeof(UAISkill_InteractionTarget_ThrowHatchet) == 0x0002A8, "Wrong size on UAISkill_InteractionTarget_ThrowHatchet");

// Class DBDBots.AISkill_InteractionTarget_ThrowPlague
// 0x0010 (0x02B8 - 0x02A8)
class UAISkill_InteractionTarget_ThrowPlague final : public UAISkill_InteractionTarget_Throw
{
public:
	struct FGameplayTag                           ProjectileDamageSickTargetTag;                     // 0x02A8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_ThrowPlague">();
	}
	static class UAISkill_InteractionTarget_ThrowPlague* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_ThrowPlague>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_ThrowPlague) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_ThrowPlague");
static_assert(sizeof(UAISkill_InteractionTarget_ThrowPlague) == 0x0002B8, "Wrong size on UAISkill_InteractionTarget_ThrowPlague");
static_assert(offsetof(UAISkill_InteractionTarget_ThrowPlague, ProjectileDamageSickTargetTag) == 0x0002A8, "Member 'UAISkill_InteractionTarget_ThrowPlague::ProjectileDamageSickTargetTag' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_TormentAttack
// 0x0030 (0x0260 - 0x0230)
class UAISkill_InteractionTarget_TormentAttack final : public UAISkill_InteractionTarget
{
public:
	int32                                         AdvancedAtNbDetectedTargets;                       // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIRoll                                AdvancedStartRoll;                                 // 0x0234(0x0024)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_TormentAttack">();
	}
	static class UAISkill_InteractionTarget_TormentAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_TormentAttack>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_TormentAttack) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_TormentAttack");
static_assert(sizeof(UAISkill_InteractionTarget_TormentAttack) == 0x000260, "Wrong size on UAISkill_InteractionTarget_TormentAttack");
static_assert(offsetof(UAISkill_InteractionTarget_TormentAttack, AdvancedAtNbDetectedTargets) == 0x000230, "Member 'UAISkill_InteractionTarget_TormentAttack::AdvancedAtNbDetectedTargets' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_TormentAttack, AdvancedStartRoll) == 0x000234, "Member 'UAISkill_InteractionTarget_TormentAttack::AdvancedStartRoll' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTarget_TormentMode
// 0x0010 (0x0240 - 0x0230)
class UAISkill_InteractionTarget_TormentMode final : public UAISkill_InteractionTarget
{
public:
	float                                         ChasedTargetToEvadePointMaxDistance;               // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTormentInPatrolAboveChargeRatio;              // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTormentInChaseAboveChargeRatio;               // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_TormentMode">();
	}
	static class UAISkill_InteractionTarget_TormentMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_TormentMode>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_TormentMode) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_TormentMode");
static_assert(sizeof(UAISkill_InteractionTarget_TormentMode) == 0x000240, "Wrong size on UAISkill_InteractionTarget_TormentMode");
static_assert(offsetof(UAISkill_InteractionTarget_TormentMode, ChasedTargetToEvadePointMaxDistance) == 0x000230, "Member 'UAISkill_InteractionTarget_TormentMode::ChasedTargetToEvadePointMaxDistance' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_TormentMode, StartTormentInPatrolAboveChargeRatio) == 0x000234, "Member 'UAISkill_InteractionTarget_TormentMode::StartTormentInPatrolAboveChargeRatio' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTarget_TormentMode, StartTormentInChaseAboveChargeRatio) == 0x000238, "Member 'UAISkill_InteractionTarget_TormentMode::StartTormentInChaseAboveChargeRatio' has a wrong offset!");

// Class DBDBots.DBDAIBTUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDAIBTUtilities final : public UDBDAIUtilities
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIBTUtilities">();
	}
	static class UDBDAIBTUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAIBTUtilities>();
	}
};
static_assert(alignof(UDBDAIBTUtilities) == 0x000008, "Wrong alignment on UDBDAIBTUtilities");
static_assert(sizeof(UDBDAIBTUtilities) == 0x000030, "Wrong size on UDBDAIBTUtilities");

// Class DBDBots.AISkill_InteractionTeleport
// 0x0008 (0x0188 - 0x0180)
class UAISkill_InteractionTeleport : public UAISkill_Interaction
{
public:
	float                                         BlockTeleportWhenPathGoalUnderRange;               // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTeleport">();
	}
	static class UAISkill_InteractionTeleport* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTeleport>();
	}
};
static_assert(alignof(UAISkill_InteractionTeleport) == 0x000008, "Wrong alignment on UAISkill_InteractionTeleport");
static_assert(sizeof(UAISkill_InteractionTeleport) == 0x000188, "Wrong size on UAISkill_InteractionTeleport");
static_assert(offsetof(UAISkill_InteractionTeleport, BlockTeleportWhenPathGoalUnderRange) == 0x000180, "Member 'UAISkill_InteractionTeleport::BlockTeleportWhenPathGoalUnderRange' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTeleportEthereal
// 0x0060 (0x01E8 - 0x0188)
class UAISkill_InteractionTeleportEthereal : public UAISkill_InteractionTeleport
{
public:
	float                                         TeleportPlanInterval;                              // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTeleportAlignHalfAngle;                         // 0x018C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbortNotWorkingTeleportDelay;                      // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbortAddRunCooldownPenaltyTime;                    // 0x0194(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_198[0x18];                                     // 0x0198(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _onStimulusInstigator;                             // 0x01B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x30];                                     // 0x01B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTeleportEthereal">();
	}
	static class UAISkill_InteractionTeleportEthereal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTeleportEthereal>();
	}
};
static_assert(alignof(UAISkill_InteractionTeleportEthereal) == 0x000008, "Wrong alignment on UAISkill_InteractionTeleportEthereal");
static_assert(sizeof(UAISkill_InteractionTeleportEthereal) == 0x0001E8, "Wrong size on UAISkill_InteractionTeleportEthereal");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal, TeleportPlanInterval) == 0x000188, "Member 'UAISkill_InteractionTeleportEthereal::TeleportPlanInterval' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal, MaxTeleportAlignHalfAngle) == 0x00018C, "Member 'UAISkill_InteractionTeleportEthereal::MaxTeleportAlignHalfAngle' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal, AbortNotWorkingTeleportDelay) == 0x000190, "Member 'UAISkill_InteractionTeleportEthereal::AbortNotWorkingTeleportDelay' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal, AbortAddRunCooldownPenaltyTime) == 0x000194, "Member 'UAISkill_InteractionTeleportEthereal::AbortAddRunCooldownPenaltyTime' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal, _onStimulusInstigator) == 0x0001B0, "Member 'UAISkill_InteractionTeleportEthereal::_onStimulusInstigator' has a wrong offset!");

// Class DBDBots.PathStrategy_Flee
// 0x0000 (0x00B8 - 0x00B8)
class UPathStrategy_Flee : public UPathStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathStrategy_Flee">();
	}
	static class UPathStrategy_Flee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathStrategy_Flee>();
	}
};
static_assert(alignof(UPathStrategy_Flee) == 0x000008, "Wrong alignment on UPathStrategy_Flee");
static_assert(sizeof(UPathStrategy_Flee) == 0x0000B8, "Wrong size on UPathStrategy_Flee");

// Class DBDBots.PathStrategy_FleeLOS
// 0x0000 (0x00B8 - 0x00B8)
class UPathStrategy_FleeLOS final : public UPathStrategy_Flee
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathStrategy_FleeLOS">();
	}
	static class UPathStrategy_FleeLOS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathStrategy_FleeLOS>();
	}
};
static_assert(alignof(UPathStrategy_FleeLOS) == 0x000008, "Wrong alignment on UPathStrategy_FleeLOS");
static_assert(sizeof(UPathStrategy_FleeLOS) == 0x0000B8, "Wrong size on UPathStrategy_FleeLOS");

// Class DBDBots.AISkill_InteractionTeleportEthereal_Blink
// 0x0010 (0x01F8 - 0x01E8)
class UAISkill_InteractionTeleportEthereal_Blink final : public UAISkill_InteractionTeleportEthereal
{
public:
	float                                         StartBlinkAtWarpLocationRange;                     // 0x01E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValidateBlinkWarpRange;                            // 0x01EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlinkAboveSavedPathLength;                         // 0x01F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlinkIfTargetWillBeInRange;                        // 0x01F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTeleportEthereal_Blink">();
	}
	static class UAISkill_InteractionTeleportEthereal_Blink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTeleportEthereal_Blink>();
	}
};
static_assert(alignof(UAISkill_InteractionTeleportEthereal_Blink) == 0x000008, "Wrong alignment on UAISkill_InteractionTeleportEthereal_Blink");
static_assert(sizeof(UAISkill_InteractionTeleportEthereal_Blink) == 0x0001F8, "Wrong size on UAISkill_InteractionTeleportEthereal_Blink");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Blink, StartBlinkAtWarpLocationRange) == 0x0001E8, "Member 'UAISkill_InteractionTeleportEthereal_Blink::StartBlinkAtWarpLocationRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Blink, ValidateBlinkWarpRange) == 0x0001EC, "Member 'UAISkill_InteractionTeleportEthereal_Blink::ValidateBlinkWarpRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Blink, BlinkAboveSavedPathLength) == 0x0001F0, "Member 'UAISkill_InteractionTeleportEthereal_Blink::BlinkAboveSavedPathLength' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Blink, BlinkIfTargetWillBeInRange) == 0x0001F4, "Member 'UAISkill_InteractionTeleportEthereal_Blink::BlinkIfTargetWillBeInRange' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTeleportEthereal_Demogorgon
// 0x0018 (0x0200 - 0x01E8)
class UAISkill_InteractionTeleportEthereal_Demogorgon final : public UAISkill_InteractionTeleportEthereal
{
public:
	float                                         MaxRangeFromFirstPortal;                           // 0x01E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADemogorgonPortal*                      _firstPortal;                                      // 0x01F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADemogorgonPortal*                      _secondPortal;                                     // 0x01F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTeleportEthereal_Demogorgon">();
	}
	static class UAISkill_InteractionTeleportEthereal_Demogorgon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTeleportEthereal_Demogorgon>();
	}
};
static_assert(alignof(UAISkill_InteractionTeleportEthereal_Demogorgon) == 0x000008, "Wrong alignment on UAISkill_InteractionTeleportEthereal_Demogorgon");
static_assert(sizeof(UAISkill_InteractionTeleportEthereal_Demogorgon) == 0x000200, "Wrong size on UAISkill_InteractionTeleportEthereal_Demogorgon");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Demogorgon, MaxRangeFromFirstPortal) == 0x0001E8, "Member 'UAISkill_InteractionTeleportEthereal_Demogorgon::MaxRangeFromFirstPortal' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Demogorgon, _firstPortal) == 0x0001F0, "Member 'UAISkill_InteractionTeleportEthereal_Demogorgon::_firstPortal' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Demogorgon, _secondPortal) == 0x0001F8, "Member 'UAISkill_InteractionTeleportEthereal_Demogorgon::_secondPortal' has a wrong offset!");

// Class DBDBots.AISkill_InteractionTeleportEthereal_Nightmare
// 0x0010 (0x01F8 - 0x01E8)
class UAISkill_InteractionTeleportEthereal_Nightmare final : public UAISkill_InteractionTeleportEthereal
{
public:
	float                                         TeleportIfPathLengthSavedAboveRange;               // 0x01E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGenerator*                             _toGenerator;                                      // 0x01F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTeleportEthereal_Nightmare">();
	}
	static class UAISkill_InteractionTeleportEthereal_Nightmare* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTeleportEthereal_Nightmare>();
	}
};
static_assert(alignof(UAISkill_InteractionTeleportEthereal_Nightmare) == 0x000008, "Wrong alignment on UAISkill_InteractionTeleportEthereal_Nightmare");
static_assert(sizeof(UAISkill_InteractionTeleportEthereal_Nightmare) == 0x0001F8, "Wrong size on UAISkill_InteractionTeleportEthereal_Nightmare");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Nightmare, TeleportIfPathLengthSavedAboveRange) == 0x0001E8, "Member 'UAISkill_InteractionTeleportEthereal_Nightmare::TeleportIfPathLengthSavedAboveRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionTeleportEthereal_Nightmare, _toGenerator) == 0x0001F0, "Member 'UAISkill_InteractionTeleportEthereal_Nightmare::_toGenerator' has a wrong offset!");

// Class DBDBots.AISkill_InteractionUseItem
// 0x0008 (0x0188 - 0x0180)
class UAISkill_InteractionUseItem : public UAISkill_Interaction
{
public:
	ELoadoutItemType                              ItemType;                                          // 0x0180(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem">();
	}
	static class UAISkill_InteractionUseItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem");
static_assert(sizeof(UAISkill_InteractionUseItem) == 0x000188, "Wrong size on UAISkill_InteractionUseItem");
static_assert(offsetof(UAISkill_InteractionUseItem, ItemType) == 0x000180, "Member 'UAISkill_InteractionUseItem::ItemType' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_Camper
// 0x0028 (0x02D8 - 0x02B0)
class UBTService_FindInteractor_Camper final : public UBTService_FindInteractor
{
public:
	EFindInteractableCamperFilter                 StatusFilter;                                      // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    AllyDangerStateGoalWeight;                         // 0x02B4(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    IncapacitatedAlliesGoalWeight;                     // 0x02C4(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Camper">();
	}
	static class UBTService_FindInteractor_Camper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Camper>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Camper) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Camper");
static_assert(sizeof(UBTService_FindInteractor_Camper) == 0x0002D8, "Wrong size on UBTService_FindInteractor_Camper");
static_assert(offsetof(UBTService_FindInteractor_Camper, StatusFilter) == 0x0002B0, "Member 'UBTService_FindInteractor_Camper::StatusFilter' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Camper, AllyDangerStateGoalWeight) == 0x0002B4, "Member 'UBTService_FindInteractor_Camper::AllyDangerStateGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Camper, IncapacitatedAlliesGoalWeight) == 0x0002C4, "Member 'UBTService_FindInteractor_Camper::IncapacitatedAlliesGoalWeight' has a wrong offset!");

// Class DBDBots.AISkill_InteractionUseItem_FirecrackerLike
// 0x0018 (0x01A0 - 0x0188)
class UAISkill_InteractionUseItem_FirecrackerLike : public UAISkill_InteractionUseItem
{
public:
	struct FAITunableParameter                    StartMaxRange;                                     // 0x0188(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TargetFaceMeMaxAngle;                              // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_FirecrackerLike">();
	}
	static class UAISkill_InteractionUseItem_FirecrackerLike* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_FirecrackerLike>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_FirecrackerLike) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_FirecrackerLike");
static_assert(sizeof(UAISkill_InteractionUseItem_FirecrackerLike) == 0x0001A0, "Wrong size on UAISkill_InteractionUseItem_FirecrackerLike");
static_assert(offsetof(UAISkill_InteractionUseItem_FirecrackerLike, StartMaxRange) == 0x000188, "Member 'UAISkill_InteractionUseItem_FirecrackerLike::StartMaxRange' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionUseItem_FirecrackerLike, TargetFaceMeMaxAngle) == 0x000198, "Member 'UAISkill_InteractionUseItem_FirecrackerLike::TargetFaceMeMaxAngle' has a wrong offset!");

// Class DBDBots.AISkill_InteractionUseItem_Firecracker
// 0x0000 (0x01A0 - 0x01A0)
class UAISkill_InteractionUseItem_Firecracker final : public UAISkill_InteractionUseItem_FirecrackerLike
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_Firecracker">();
	}
	static class UAISkill_InteractionUseItem_Firecracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_Firecracker>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_Firecracker) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_Firecracker");
static_assert(sizeof(UAISkill_InteractionUseItem_Firecracker) == 0x0001A0, "Wrong size on UAISkill_InteractionUseItem_Firecracker");

// Class DBDBots.AISkill_InteractionUseItem_Flashbang
// 0x0000 (0x01A0 - 0x01A0)
class UAISkill_InteractionUseItem_Flashbang final : public UAISkill_InteractionUseItem_FirecrackerLike
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_Flashbang">();
	}
	static class UAISkill_InteractionUseItem_Flashbang* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_Flashbang>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_Flashbang) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_Flashbang");
static_assert(sizeof(UAISkill_InteractionUseItem_Flashbang) == 0x0001A0, "Wrong size on UAISkill_InteractionUseItem_Flashbang");

// Class DBDBots.AISkill_InteractionUseItem_Flashlight
// 0x0068 (0x01F0 - 0x0188)
class UAISkill_InteractionUseItem_Flashlight final : public UAISkill_InteractionUseItem
{
public:
	struct FAIRoll                                VulnerableTargetStartRoll;                         // 0x0188(0x0024)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TargetFaceMeMaxAngle;                              // 0x01AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 _targetActor;                                      // 0x01B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x38];                                     // 0x01B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_Flashlight">();
	}
	static class UAISkill_InteractionUseItem_Flashlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_Flashlight>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_Flashlight) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_Flashlight");
static_assert(sizeof(UAISkill_InteractionUseItem_Flashlight) == 0x0001F0, "Wrong size on UAISkill_InteractionUseItem_Flashlight");
static_assert(offsetof(UAISkill_InteractionUseItem_Flashlight, VulnerableTargetStartRoll) == 0x000188, "Member 'UAISkill_InteractionUseItem_Flashlight::VulnerableTargetStartRoll' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionUseItem_Flashlight, TargetFaceMeMaxAngle) == 0x0001AC, "Member 'UAISkill_InteractionUseItem_Flashlight::TargetFaceMeMaxAngle' has a wrong offset!");
static_assert(offsetof(UAISkill_InteractionUseItem_Flashlight, _targetActor) == 0x0001B0, "Member 'UAISkill_InteractionUseItem_Flashlight::_targetActor' has a wrong offset!");

// Class DBDBots.BTDecorator_IsInteractionAvailable
// 0x0050 (0x00C0 - 0x0070)
class UBTDecorator_IsInteractionAvailable final : public UBTDecorator_TickableBase
{
public:
	TArray<class FString>                         InteractionIds;                                    // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EIsInteractionAvailableOnFilter               OnFilter;                                          // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBInteractor;                                      // 0x0088(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          FailIfAnotherOngoingInteraction;                   // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FailIfNotPerformingInteraction;                    // 0x00B9(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsInteractionAvailable">();
	}
	static class UBTDecorator_IsInteractionAvailable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsInteractionAvailable>();
	}
};
static_assert(alignof(UBTDecorator_IsInteractionAvailable) == 0x000008, "Wrong alignment on UBTDecorator_IsInteractionAvailable");
static_assert(sizeof(UBTDecorator_IsInteractionAvailable) == 0x0000C0, "Wrong size on UBTDecorator_IsInteractionAvailable");
static_assert(offsetof(UBTDecorator_IsInteractionAvailable, InteractionIds) == 0x000070, "Member 'UBTDecorator_IsInteractionAvailable::InteractionIds' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsInteractionAvailable, OnFilter) == 0x000080, "Member 'UBTDecorator_IsInteractionAvailable::OnFilter' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsInteractionAvailable, BBInteractor) == 0x000088, "Member 'UBTDecorator_IsInteractionAvailable::BBInteractor' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsInteractionAvailable, FailIfAnotherOngoingInteraction) == 0x0000B8, "Member 'UBTDecorator_IsInteractionAvailable::FailIfAnotherOngoingInteraction' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsInteractionAvailable, FailIfNotPerformingInteraction) == 0x0000B9, "Member 'UBTDecorator_IsInteractionAvailable::FailIfNotPerformingInteraction' has a wrong offset!");

// Class DBDBots.AISkill_InteractionUseItem_Key_Addon
// 0x0008 (0x0190 - 0x0188)
class UAISkill_InteractionUseItem_Key_Addon final : public UAISkill_InteractionUseItem
{
public:
	float                                         RemainingPercentChargeToKeep;                      // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_Key_Addon">();
	}
	static class UAISkill_InteractionUseItem_Key_Addon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_Key_Addon>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_Key_Addon) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_Key_Addon");
static_assert(sizeof(UAISkill_InteractionUseItem_Key_Addon) == 0x000190, "Wrong size on UAISkill_InteractionUseItem_Key_Addon");
static_assert(offsetof(UAISkill_InteractionUseItem_Key_Addon, RemainingPercentChargeToKeep) == 0x000188, "Member 'UAISkill_InteractionUseItem_Key_Addon::RemainingPercentChargeToKeep' has a wrong offset!");

// Class DBDBots.AISkill_InteractionUseItem_Map
// 0x0000 (0x0188 - 0x0188)
class UAISkill_InteractionUseItem_Map final : public UAISkill_InteractionUseItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_Map">();
	}
	static class UAISkill_InteractionUseItem_Map* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_Map>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_Map) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_Map");
static_assert(sizeof(UAISkill_InteractionUseItem_Map) == 0x000188, "Wrong size on UAISkill_InteractionUseItem_Map");

// Class DBDBots.BTService_Patrol
// 0x00E0 (0x0158 - 0x0078)
class UBTService_Patrol : public UBTService
{
public:
	struct FBlackboardKeySelector                 BBFilterKey;                                       // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EBasicKeyOperation                            FilterOperation;                                   // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NavMeshFindLocationExtents;                        // 0x00AC(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinPatrolInvestigationDistance;                    // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PatrolPointsValidityCheckInterval;                 // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBPatrolPointOwner;                                // 0x00C0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBPatrolLocation;                                  // 0x00F0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBGoToNextPatrolLocation;                          // 0x0120(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_Patrol">();
	}
	static class UBTService_Patrol* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_Patrol>();
	}
};
static_assert(alignof(UBTService_Patrol) == 0x000008, "Wrong alignment on UBTService_Patrol");
static_assert(sizeof(UBTService_Patrol) == 0x000158, "Wrong size on UBTService_Patrol");
static_assert(offsetof(UBTService_Patrol, BBFilterKey) == 0x000078, "Member 'UBTService_Patrol::BBFilterKey' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol, FilterOperation) == 0x0000A8, "Member 'UBTService_Patrol::FilterOperation' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol, NavMeshFindLocationExtents) == 0x0000AC, "Member 'UBTService_Patrol::NavMeshFindLocationExtents' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol, MinPatrolInvestigationDistance) == 0x0000B8, "Member 'UBTService_Patrol::MinPatrolInvestigationDistance' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol, PatrolPointsValidityCheckInterval) == 0x0000BC, "Member 'UBTService_Patrol::PatrolPointsValidityCheckInterval' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol, BBPatrolPointOwner) == 0x0000C0, "Member 'UBTService_Patrol::BBPatrolPointOwner' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol, BBPatrolLocation) == 0x0000F0, "Member 'UBTService_Patrol::BBPatrolLocation' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol, BBGoToNextPatrolLocation) == 0x000120, "Member 'UBTService_Patrol::BBGoToNextPatrolLocation' has a wrong offset!");

// Class DBDBots.BTService_Patrol_PointOfInterest
// 0x0040 (0x0198 - 0x0158)
class UBTService_Patrol_PointOfInterest final : public UBTService_Patrol
{
public:
	float                                         OnEnterPatrolRefreshPointsDelay;                   // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBMoveAroundPatrolLocation;                        // 0x0160(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         MoveAroundPatrolPointAboveStimulusStrength;        // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_Patrol_PointOfInterest">();
	}
	static class UBTService_Patrol_PointOfInterest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_Patrol_PointOfInterest>();
	}
};
static_assert(alignof(UBTService_Patrol_PointOfInterest) == 0x000008, "Wrong alignment on UBTService_Patrol_PointOfInterest");
static_assert(sizeof(UBTService_Patrol_PointOfInterest) == 0x000198, "Wrong size on UBTService_Patrol_PointOfInterest");
static_assert(offsetof(UBTService_Patrol_PointOfInterest, OnEnterPatrolRefreshPointsDelay) == 0x000158, "Member 'UBTService_Patrol_PointOfInterest::OnEnterPatrolRefreshPointsDelay' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol_PointOfInterest, BBMoveAroundPatrolLocation) == 0x000160, "Member 'UBTService_Patrol_PointOfInterest::BBMoveAroundPatrolLocation' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol_PointOfInterest, MoveAroundPatrolPointAboveStimulusStrength) == 0x000190, "Member 'UBTService_Patrol_PointOfInterest::MoveAroundPatrolPointAboveStimulusStrength' has a wrong offset!");

// Class DBDBots.AISkill_InteractionUseItem_Medkit_Addon
// 0x0008 (0x0190 - 0x0188)
class UAISkill_InteractionUseItem_Medkit_Addon final : public UAISkill_InteractionUseItem
{
public:
	float                                         RemainingChargeThreshold;                          // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_Medkit_Addon">();
	}
	static class UAISkill_InteractionUseItem_Medkit_Addon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_Medkit_Addon>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_Medkit_Addon) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_Medkit_Addon");
static_assert(sizeof(UAISkill_InteractionUseItem_Medkit_Addon) == 0x000190, "Wrong size on UAISkill_InteractionUseItem_Medkit_Addon");
static_assert(offsetof(UAISkill_InteractionUseItem_Medkit_Addon, RemainingChargeThreshold) == 0x000188, "Member 'UAISkill_InteractionUseItem_Medkit_Addon::RemainingChargeThreshold' has a wrong offset!");

// Class DBDBots.AISkill_PossessTheKiller
// 0x0000 (0x0180 - 0x0180)
class UAISkill_PossessTheKiller final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_PossessTheKiller">();
	}
	static class UAISkill_PossessTheKiller* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_PossessTheKiller>();
	}
};
static_assert(alignof(UAISkill_PossessTheKiller) == 0x000008, "Wrong alignment on UAISkill_PossessTheKiller");
static_assert(sizeof(UAISkill_PossessTheKiller) == 0x000180, "Wrong size on UAISkill_PossessTheKiller");

// Class DBDBots.AISkill_SkillCheck
// 0x00B8 (0x0188 - 0x00D0)
class UAISkill_SkillCheck final : public UAISkill
{
public:
	struct FAIRoll                                BaseRegularZoneRoll;                               // 0x00D0(0x0024)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIRoll                                BaseBonusZoneRoll;                                 // 0x00F4(0x0024)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIRoll                                WiggleRegularZoneRoll;                             // 0x0118(0x0024)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIRoll                                WiggleBonusZoneRoll;                               // 0x013C(0x0024)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIRoll                                HookStruggleBonusZoneRoll;                         // 0x0160(0x0024)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_SkillCheck">();
	}
	static class UAISkill_SkillCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_SkillCheck>();
	}
};
static_assert(alignof(UAISkill_SkillCheck) == 0x000008, "Wrong alignment on UAISkill_SkillCheck");
static_assert(sizeof(UAISkill_SkillCheck) == 0x000188, "Wrong size on UAISkill_SkillCheck");
static_assert(offsetof(UAISkill_SkillCheck, BaseRegularZoneRoll) == 0x0000D0, "Member 'UAISkill_SkillCheck::BaseRegularZoneRoll' has a wrong offset!");
static_assert(offsetof(UAISkill_SkillCheck, BaseBonusZoneRoll) == 0x0000F4, "Member 'UAISkill_SkillCheck::BaseBonusZoneRoll' has a wrong offset!");
static_assert(offsetof(UAISkill_SkillCheck, WiggleRegularZoneRoll) == 0x000118, "Member 'UAISkill_SkillCheck::WiggleRegularZoneRoll' has a wrong offset!");
static_assert(offsetof(UAISkill_SkillCheck, WiggleBonusZoneRoll) == 0x00013C, "Member 'UAISkill_SkillCheck::WiggleBonusZoneRoll' has a wrong offset!");
static_assert(offsetof(UAISkill_SkillCheck, HookStruggleBonusZoneRoll) == 0x000160, "Member 'UAISkill_SkillCheck::HookStruggleBonusZoneRoll' has a wrong offset!");

// Class DBDBots.AISkill_Strafe
// 0x0078 (0x0148 - 0x00D0)
class UAISkill_Strafe : public UAISkill
{
public:
	float                                         StartMaxRange;                                     // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopMaxRange;                                      // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartMaxRangeAgainstRangedHostileStimulus;         // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopMaxRangeAgainstRangedHostileStimulus;          // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeBackwardRange;                               // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafeFowardRange;                                 // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IgnoreUnderNavLinkStartRange;                      // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PauseStrafeOnAnimation;                            // 0x00EC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    StrafeHoldInterval;                                // 0x00F0(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    StrafeHoldDeviation;                               // 0x0100(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    StrafePauseInterval;                               // 0x0110(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    StrafePauseDeviation;                              // 0x0120(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x18];                                     // 0x0130(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Strafe">();
	}
	static class UAISkill_Strafe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Strafe>();
	}
};
static_assert(alignof(UAISkill_Strafe) == 0x000008, "Wrong alignment on UAISkill_Strafe");
static_assert(sizeof(UAISkill_Strafe) == 0x000148, "Wrong size on UAISkill_Strafe");
static_assert(offsetof(UAISkill_Strafe, StartMaxRange) == 0x0000D0, "Member 'UAISkill_Strafe::StartMaxRange' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StopMaxRange) == 0x0000D4, "Member 'UAISkill_Strafe::StopMaxRange' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StartMaxRangeAgainstRangedHostileStimulus) == 0x0000D8, "Member 'UAISkill_Strafe::StartMaxRangeAgainstRangedHostileStimulus' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StopMaxRangeAgainstRangedHostileStimulus) == 0x0000DC, "Member 'UAISkill_Strafe::StopMaxRangeAgainstRangedHostileStimulus' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StrafeBackwardRange) == 0x0000E0, "Member 'UAISkill_Strafe::StrafeBackwardRange' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StrafeFowardRange) == 0x0000E4, "Member 'UAISkill_Strafe::StrafeFowardRange' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, IgnoreUnderNavLinkStartRange) == 0x0000E8, "Member 'UAISkill_Strafe::IgnoreUnderNavLinkStartRange' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, PauseStrafeOnAnimation) == 0x0000EC, "Member 'UAISkill_Strafe::PauseStrafeOnAnimation' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StrafeHoldInterval) == 0x0000F0, "Member 'UAISkill_Strafe::StrafeHoldInterval' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StrafeHoldDeviation) == 0x000100, "Member 'UAISkill_Strafe::StrafeHoldDeviation' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StrafePauseInterval) == 0x000110, "Member 'UAISkill_Strafe::StrafePauseInterval' has a wrong offset!");
static_assert(offsetof(UAISkill_Strafe, StrafePauseDeviation) == 0x000120, "Member 'UAISkill_Strafe::StrafePauseDeviation' has a wrong offset!");

// Class DBDBots.AISkill_StrafeChained
// 0x0000 (0x0148 - 0x0148)
class UAISkill_StrafeChained final : public UAISkill_Strafe
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_StrafeChained">();
	}
	static class UAISkill_StrafeChained* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_StrafeChained>();
	}
};
static_assert(alignof(UAISkill_StrafeChained) == 0x000008, "Wrong alignment on UAISkill_StrafeChained");
static_assert(sizeof(UAISkill_StrafeChained) == 0x000148, "Wrong size on UAISkill_StrafeChained");

// Class DBDBots.AISkill_StrafeDodge
// 0x0028 (0x0170 - 0x0148)
class UAISkill_StrafeDodge final : public UAISkill_Strafe
{
public:
	struct FAIRoll                                StartRoll;                                         // 0x0148(0x0024)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_StrafeDodge">();
	}
	static class UAISkill_StrafeDodge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_StrafeDodge>();
	}
};
static_assert(alignof(UAISkill_StrafeDodge) == 0x000008, "Wrong alignment on UAISkill_StrafeDodge");
static_assert(sizeof(UAISkill_StrafeDodge) == 0x000170, "Wrong size on UAISkill_StrafeDodge");
static_assert(offsetof(UAISkill_StrafeDodge, StartRoll) == 0x000148, "Member 'UAISkill_StrafeDodge::StartRoll' has a wrong offset!");

// Class DBDBots.AISkill_ThroughTorment
// 0x0008 (0x00D8 - 0x00D0)
class UAISkill_ThroughTorment final : public UAISkill
{
public:
	EAITerrorLevel                                ToleratedTerrorPressure;                           // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_ThroughTorment">();
	}
	static class UAISkill_ThroughTorment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_ThroughTorment>();
	}
};
static_assert(alignof(UAISkill_ThroughTorment) == 0x000008, "Wrong alignment on UAISkill_ThroughTorment");
static_assert(sizeof(UAISkill_ThroughTorment) == 0x0000D8, "Wrong size on UAISkill_ThroughTorment");
static_assert(offsetof(UAISkill_ThroughTorment, ToleratedTerrorPressure) == 0x0000D0, "Member 'UAISkill_ThroughTorment::ToleratedTerrorPressure' has a wrong offset!");

// Class DBDBots.BTDecorator_CanRecoverMore
// 0x0000 (0x0070 - 0x0070)
class UBTDecorator_CanRecoverMore final : public UBTDecorator_TickableBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_CanRecoverMore">();
	}
	static class UBTDecorator_CanRecoverMore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_CanRecoverMore>();
	}
};
static_assert(alignof(UBTDecorator_CanRecoverMore) == 0x000008, "Wrong alignment on UBTDecorator_CanRecoverMore");
static_assert(sizeof(UBTDecorator_CanRecoverMore) == 0x000070, "Wrong size on UBTDecorator_CanRecoverMore");

// Class DBDBots.NavigationQueryFilter_Slasher
// 0x00A0 (0x0110 - 0x0070)
class UNavigationQueryFilter_Slasher final : public UNavigationQueryFilter_Player
{
public:
	TMap<class FString, float>                    DefaultInteractionsTimeCost;                       // 0x0070(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    FrenzyInteractionsTimeCost;                        // 0x00C0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_Slasher">();
	}
	static class UNavigationQueryFilter_Slasher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_Slasher>();
	}
};
static_assert(alignof(UNavigationQueryFilter_Slasher) == 0x000008, "Wrong alignment on UNavigationQueryFilter_Slasher");
static_assert(sizeof(UNavigationQueryFilter_Slasher) == 0x000110, "Wrong size on UNavigationQueryFilter_Slasher");
static_assert(offsetof(UNavigationQueryFilter_Slasher, DefaultInteractionsTimeCost) == 0x000070, "Member 'UNavigationQueryFilter_Slasher::DefaultInteractionsTimeCost' has a wrong offset!");
static_assert(offsetof(UNavigationQueryFilter_Slasher, FrenzyInteractionsTimeCost) == 0x0000C0, "Member 'UNavigationQueryFilter_Slasher::FrenzyInteractionsTimeCost' has a wrong offset!");

// Class DBDBots.BTDecorator_CanRunSkill
// 0x0010 (0x0080 - 0x0070)
class UBTDecorator_CanRunSkill final : public UBTDecorator_TickableBase
{
public:
	struct FGameplayTag                           Context;                                           // 0x0070(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_CanRunSkill">();
	}
	static class UBTDecorator_CanRunSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_CanRunSkill>();
	}
};
static_assert(alignof(UBTDecorator_CanRunSkill) == 0x000008, "Wrong alignment on UBTDecorator_CanRunSkill");
static_assert(sizeof(UBTDecorator_CanRunSkill) == 0x000080, "Wrong size on UBTDecorator_CanRunSkill");
static_assert(offsetof(UBTDecorator_CanRunSkill, Context) == 0x000070, "Member 'UBTDecorator_CanRunSkill::Context' has a wrong offset!");

// Class DBDBots.BTDecorator_CanUnsafeAction
// 0x0098 (0x0108 - 0x0070)
class UBTDecorator_CanUnsafeAction final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBUnsafeActionID;                                  // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBUnsafeActionUsesItemAddons;                      // 0x00A0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBGoalInteractor;                                  // 0x00D0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         ExtraHealthyTime;                                  // 0x0100(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraInjuredTime;                                  // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_CanUnsafeAction">();
	}
	static class UBTDecorator_CanUnsafeAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_CanUnsafeAction>();
	}
};
static_assert(alignof(UBTDecorator_CanUnsafeAction) == 0x000008, "Wrong alignment on UBTDecorator_CanUnsafeAction");
static_assert(sizeof(UBTDecorator_CanUnsafeAction) == 0x000108, "Wrong size on UBTDecorator_CanUnsafeAction");
static_assert(offsetof(UBTDecorator_CanUnsafeAction, BBUnsafeActionID) == 0x000070, "Member 'UBTDecorator_CanUnsafeAction::BBUnsafeActionID' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CanUnsafeAction, BBUnsafeActionUsesItemAddons) == 0x0000A0, "Member 'UBTDecorator_CanUnsafeAction::BBUnsafeActionUsesItemAddons' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CanUnsafeAction, BBGoalInteractor) == 0x0000D0, "Member 'UBTDecorator_CanUnsafeAction::BBGoalInteractor' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CanUnsafeAction, ExtraHealthyTime) == 0x000100, "Member 'UBTDecorator_CanUnsafeAction::ExtraHealthyTime' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CanUnsafeAction, ExtraInjuredTime) == 0x000104, "Member 'UBTDecorator_CanUnsafeAction::ExtraInjuredTime' has a wrong offset!");

// Class DBDBots.BTService_Find_Character
// 0x0048 (0x00C0 - 0x0078)
class UBTService_Find_Character final : public UBTService
{
public:
	EPawnType                                     CharacterFilter;                                   // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKillerAbilities                              KillerAbility;                                     // 0x0079(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBCharacterLocation;                               // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class ADBDAIBTController*                     _aiOwner;                                          // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_Find_Character">();
	}
	static class UBTService_Find_Character* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_Find_Character>();
	}
};
static_assert(alignof(UBTService_Find_Character) == 0x000008, "Wrong alignment on UBTService_Find_Character");
static_assert(sizeof(UBTService_Find_Character) == 0x0000C0, "Wrong size on UBTService_Find_Character");
static_assert(offsetof(UBTService_Find_Character, CharacterFilter) == 0x000078, "Member 'UBTService_Find_Character::CharacterFilter' has a wrong offset!");
static_assert(offsetof(UBTService_Find_Character, KillerAbility) == 0x000079, "Member 'UBTService_Find_Character::KillerAbility' has a wrong offset!");
static_assert(offsetof(UBTService_Find_Character, BBCharacterLocation) == 0x000080, "Member 'UBTService_Find_Character::BBCharacterLocation' has a wrong offset!");
static_assert(offsetof(UBTService_Find_Character, _aiOwner) == 0x0000B0, "Member 'UBTService_Find_Character::_aiOwner' has a wrong offset!");

// Class DBDBots.BTDecorator_CompareInteractorCharge
// 0x0038 (0x00A8 - 0x0070)
class UBTDecorator_CompareInteractorCharge final : public UBTDecorator_TickableBase
{
public:
	EArithmeticKeyOperation                       ChargePercentQuery;                                // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChargePercentValue;                                // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBInteractorObj;                                   // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_CompareInteractorCharge">();
	}
	static class UBTDecorator_CompareInteractorCharge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_CompareInteractorCharge>();
	}
};
static_assert(alignof(UBTDecorator_CompareInteractorCharge) == 0x000008, "Wrong alignment on UBTDecorator_CompareInteractorCharge");
static_assert(sizeof(UBTDecorator_CompareInteractorCharge) == 0x0000A8, "Wrong size on UBTDecorator_CompareInteractorCharge");
static_assert(offsetof(UBTDecorator_CompareInteractorCharge, ChargePercentQuery) == 0x000070, "Member 'UBTDecorator_CompareInteractorCharge::ChargePercentQuery' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CompareInteractorCharge, ChargePercentValue) == 0x000074, "Member 'UBTDecorator_CompareInteractorCharge::ChargePercentValue' has a wrong offset!");
static_assert(offsetof(UBTDecorator_CompareInteractorCharge, BBInteractorObj) == 0x000078, "Member 'UBTDecorator_CompareInteractorCharge::BBInteractorObj' has a wrong offset!");

// Class DBDBots.BTDecorator_ContainsInteraction
// 0x0040 (0x00B0 - 0x0070)
class UBTDecorator_ContainsInteraction final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBInteractorObj;                                   // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class FString>                         InteractionIds;                                    // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_ContainsInteraction">();
	}
	static class UBTDecorator_ContainsInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_ContainsInteraction>();
	}
};
static_assert(alignof(UBTDecorator_ContainsInteraction) == 0x000008, "Wrong alignment on UBTDecorator_ContainsInteraction");
static_assert(sizeof(UBTDecorator_ContainsInteraction) == 0x0000B0, "Wrong size on UBTDecorator_ContainsInteraction");
static_assert(offsetof(UBTDecorator_ContainsInteraction, BBInteractorObj) == 0x000070, "Member 'UBTDecorator_ContainsInteraction::BBInteractorObj' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ContainsInteraction, InteractionIds) == 0x0000A0, "Member 'UBTDecorator_ContainsInteraction::InteractionIds' has a wrong offset!");

// Class DBDBots.BTDecorator_ExtCompareBBEntries
// 0x0008 (0x00E0 - 0x00D8)
class UBTDecorator_ExtCompareBBEntries final : public UBTDecorator_CompareBBEntries
{
public:
	float                                         Tolerance;                                         // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_ExtCompareBBEntries">();
	}
	static class UBTDecorator_ExtCompareBBEntries* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_ExtCompareBBEntries>();
	}
};
static_assert(alignof(UBTDecorator_ExtCompareBBEntries) == 0x000008, "Wrong alignment on UBTDecorator_ExtCompareBBEntries");
static_assert(sizeof(UBTDecorator_ExtCompareBBEntries) == 0x0000E0, "Wrong size on UBTDecorator_ExtCompareBBEntries");
static_assert(offsetof(UBTDecorator_ExtCompareBBEntries, Tolerance) == 0x0000D8, "Member 'UBTDecorator_ExtCompareBBEntries::Tolerance' has a wrong offset!");

// Class DBDBots.BTDecorator_ExtConeCheck
// 0x00A0 (0x0110 - 0x0070)
class UBTDecorator_ExtConeCheck final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBConeOrigin;                                      // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBConeDirection;                                   // 0x00A0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBWith;                                            // 0x00D0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ConeHalfAngle;                                     // 0x0100(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_ExtConeCheck">();
	}
	static class UBTDecorator_ExtConeCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_ExtConeCheck>();
	}
};
static_assert(alignof(UBTDecorator_ExtConeCheck) == 0x000008, "Wrong alignment on UBTDecorator_ExtConeCheck");
static_assert(sizeof(UBTDecorator_ExtConeCheck) == 0x000110, "Wrong size on UBTDecorator_ExtConeCheck");
static_assert(offsetof(UBTDecorator_ExtConeCheck, BBConeOrigin) == 0x000070, "Member 'UBTDecorator_ExtConeCheck::BBConeOrigin' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ExtConeCheck, BBConeDirection) == 0x0000A0, "Member 'UBTDecorator_ExtConeCheck::BBConeDirection' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ExtConeCheck, BBWith) == 0x0000D0, "Member 'UBTDecorator_ExtConeCheck::BBWith' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ExtConeCheck, ConeHalfAngle) == 0x000100, "Member 'UBTDecorator_ExtConeCheck::ConeHalfAngle' has a wrong offset!");

// Class DBDBots.BTDecorator_ExtIsAtLocation
// 0x0048 (0x00B8 - 0x0070)
class UBTDecorator_ExtIsAtLocation final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBLoc;                                             // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          UseAlternativeLoc;                                 // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    AcceptableRadius;                                  // 0x00A4(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_ExtIsAtLocation">();
	}
	static class UBTDecorator_ExtIsAtLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_ExtIsAtLocation>();
	}
};
static_assert(alignof(UBTDecorator_ExtIsAtLocation) == 0x000008, "Wrong alignment on UBTDecorator_ExtIsAtLocation");
static_assert(sizeof(UBTDecorator_ExtIsAtLocation) == 0x0000B8, "Wrong size on UBTDecorator_ExtIsAtLocation");
static_assert(offsetof(UBTDecorator_ExtIsAtLocation, BBLoc) == 0x000070, "Member 'UBTDecorator_ExtIsAtLocation::BBLoc' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ExtIsAtLocation, UseAlternativeLoc) == 0x0000A0, "Member 'UBTDecorator_ExtIsAtLocation::UseAlternativeLoc' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ExtIsAtLocation, AcceptableRadius) == 0x0000A4, "Member 'UBTDecorator_ExtIsAtLocation::AcceptableRadius' has a wrong offset!");

// Class DBDBots.BTDecorator_ExtIsBBEntryOfClass
// 0x0008 (0x00B0 - 0x00A8)
class UBTDecorator_ExtIsBBEntryOfClass final : public UBTDecorator_IsBBEntryOfClass
{
public:
	bool                                          InvertConditition;                                 // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_ExtIsBBEntryOfClass">();
	}
	static class UBTDecorator_ExtIsBBEntryOfClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_ExtIsBBEntryOfClass>();
	}
};
static_assert(alignof(UBTDecorator_ExtIsBBEntryOfClass) == 0x000008, "Wrong alignment on UBTDecorator_ExtIsBBEntryOfClass");
static_assert(sizeof(UBTDecorator_ExtIsBBEntryOfClass) == 0x0000B0, "Wrong size on UBTDecorator_ExtIsBBEntryOfClass");
static_assert(offsetof(UBTDecorator_ExtIsBBEntryOfClass, InvertConditition) == 0x0000A8, "Member 'UBTDecorator_ExtIsBBEntryOfClass::InvertConditition' has a wrong offset!");

// Class DBDBots.BTDecorator_ExtTimeLimit
// 0x0050 (0x00C8 - 0x0078)
class UBTDecorator_ExtTimeLimit final : public UBTDecorator_TimeLimit
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    MaxTimeLimit;                                      // 0x0080(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBFilterKey;                                       // 0x0090(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EBasicKeyOperation                            FilterOperation;                                   // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_ExtTimeLimit">();
	}
	static class UBTDecorator_ExtTimeLimit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_ExtTimeLimit>();
	}
};
static_assert(alignof(UBTDecorator_ExtTimeLimit) == 0x000008, "Wrong alignment on UBTDecorator_ExtTimeLimit");
static_assert(sizeof(UBTDecorator_ExtTimeLimit) == 0x0000C8, "Wrong size on UBTDecorator_ExtTimeLimit");
static_assert(offsetof(UBTDecorator_ExtTimeLimit, MaxTimeLimit) == 0x000080, "Member 'UBTDecorator_ExtTimeLimit::MaxTimeLimit' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ExtTimeLimit, BBFilterKey) == 0x000090, "Member 'UBTDecorator_ExtTimeLimit::BBFilterKey' has a wrong offset!");
static_assert(offsetof(UBTDecorator_ExtTimeLimit, FilterOperation) == 0x0000C0, "Member 'UBTDecorator_ExtTimeLimit::FilterOperation' has a wrong offset!");

// Class DBDBots.BTDecorator_GameplayModifierValue
// 0x0028 (0x0098 - 0x0070)
class UBTDecorator_GameplayModifierValue final : public UBTDecorator_TickableBase
{
public:
	EArithmeticKeyOperation                       ArithmeticOperation;                               // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ModifierTag;                                       // 0x0074(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CompareToValue;                                    // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EstimateWithSemantics;                             // 0x0084(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SemanticTag;                                       // 0x0088(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsesItemAddons;                                    // 0x0094(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_GameplayModifierValue">();
	}
	static class UBTDecorator_GameplayModifierValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_GameplayModifierValue>();
	}
};
static_assert(alignof(UBTDecorator_GameplayModifierValue) == 0x000008, "Wrong alignment on UBTDecorator_GameplayModifierValue");
static_assert(sizeof(UBTDecorator_GameplayModifierValue) == 0x000098, "Wrong size on UBTDecorator_GameplayModifierValue");
static_assert(offsetof(UBTDecorator_GameplayModifierValue, ArithmeticOperation) == 0x000070, "Member 'UBTDecorator_GameplayModifierValue::ArithmeticOperation' has a wrong offset!");
static_assert(offsetof(UBTDecorator_GameplayModifierValue, ModifierTag) == 0x000074, "Member 'UBTDecorator_GameplayModifierValue::ModifierTag' has a wrong offset!");
static_assert(offsetof(UBTDecorator_GameplayModifierValue, CompareToValue) == 0x000080, "Member 'UBTDecorator_GameplayModifierValue::CompareToValue' has a wrong offset!");
static_assert(offsetof(UBTDecorator_GameplayModifierValue, EstimateWithSemantics) == 0x000084, "Member 'UBTDecorator_GameplayModifierValue::EstimateWithSemantics' has a wrong offset!");
static_assert(offsetof(UBTDecorator_GameplayModifierValue, SemanticTag) == 0x000088, "Member 'UBTDecorator_GameplayModifierValue::SemanticTag' has a wrong offset!");
static_assert(offsetof(UBTDecorator_GameplayModifierValue, UsesItemAddons) == 0x000094, "Member 'UBTDecorator_GameplayModifierValue::UsesItemAddons' has a wrong offset!");

// Class DBDBots.BTService_StimuliMonitor_Slasher
// 0x0120 (0x0300 - 0x01E0)
class UBTService_StimuliMonitor_Slasher final : public UBTService_StimuliMonitor
{
public:
	struct FBlackboardKeySelector                 BBInvestigateStimulusLocation;                     // 0x01E0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBInvestigateStimulusActor;                        // 0x0210(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBInBehaviorInvestigationStep;                     // 0x0240(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsBlind;                                         // 0x0270(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBChasedActor;                                     // 0x02A0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    UseNextStimulusInvestigationAfterChaseDelay;       // 0x02D0(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	float                                         IgnorePreviousChasedStimulusActorDelay;            // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultStimulusToInvestigateMaxAge;                // 0x02E4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KOStimulusToInvestigateMaxAge;                     // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextStimulusInvestigationMinRange;                 // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CantSeeOverBlindRatio;                             // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FavorizeStandingTargetInRange;                     // 0x02F4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FavorizeStandingTargetOutRange;                    // 0x02F8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_StimuliMonitor_Slasher">();
	}
	static class UBTService_StimuliMonitor_Slasher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_StimuliMonitor_Slasher>();
	}
};
static_assert(alignof(UBTService_StimuliMonitor_Slasher) == 0x000008, "Wrong alignment on UBTService_StimuliMonitor_Slasher");
static_assert(sizeof(UBTService_StimuliMonitor_Slasher) == 0x000300, "Wrong size on UBTService_StimuliMonitor_Slasher");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, BBInvestigateStimulusLocation) == 0x0001E0, "Member 'UBTService_StimuliMonitor_Slasher::BBInvestigateStimulusLocation' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, BBInvestigateStimulusActor) == 0x000210, "Member 'UBTService_StimuliMonitor_Slasher::BBInvestigateStimulusActor' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, BBInBehaviorInvestigationStep) == 0x000240, "Member 'UBTService_StimuliMonitor_Slasher::BBInBehaviorInvestigationStep' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, BBIsBlind) == 0x000270, "Member 'UBTService_StimuliMonitor_Slasher::BBIsBlind' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, BBChasedActor) == 0x0002A0, "Member 'UBTService_StimuliMonitor_Slasher::BBChasedActor' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, UseNextStimulusInvestigationAfterChaseDelay) == 0x0002D0, "Member 'UBTService_StimuliMonitor_Slasher::UseNextStimulusInvestigationAfterChaseDelay' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, IgnorePreviousChasedStimulusActorDelay) == 0x0002E0, "Member 'UBTService_StimuliMonitor_Slasher::IgnorePreviousChasedStimulusActorDelay' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, DefaultStimulusToInvestigateMaxAge) == 0x0002E4, "Member 'UBTService_StimuliMonitor_Slasher::DefaultStimulusToInvestigateMaxAge' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, KOStimulusToInvestigateMaxAge) == 0x0002E8, "Member 'UBTService_StimuliMonitor_Slasher::KOStimulusToInvestigateMaxAge' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, NextStimulusInvestigationMinRange) == 0x0002EC, "Member 'UBTService_StimuliMonitor_Slasher::NextStimulusInvestigationMinRange' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, CantSeeOverBlindRatio) == 0x0002F0, "Member 'UBTService_StimuliMonitor_Slasher::CantSeeOverBlindRatio' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, FavorizeStandingTargetInRange) == 0x0002F4, "Member 'UBTService_StimuliMonitor_Slasher::FavorizeStandingTargetInRange' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Slasher, FavorizeStandingTargetOutRange) == 0x0002F8, "Member 'UBTService_StimuliMonitor_Slasher::FavorizeStandingTargetOutRange' has a wrong offset!");

// Class DBDBots.BTDecorator_HasActivatedBoonPerk
// 0x0000 (0x0070 - 0x0070)
class UBTDecorator_HasActivatedBoonPerk final : public UBTDecorator_TickableBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasActivatedBoonPerk">();
	}
	static class UBTDecorator_HasActivatedBoonPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasActivatedBoonPerk>();
	}
};
static_assert(alignof(UBTDecorator_HasActivatedBoonPerk) == 0x000008, "Wrong alignment on UBTDecorator_HasActivatedBoonPerk");
static_assert(sizeof(UBTDecorator_HasActivatedBoonPerk) == 0x000070, "Wrong size on UBTDecorator_HasActivatedBoonPerk");

// Class DBDBots.BTDecorator_HasBetterItemValue
// 0x0038 (0x00A8 - 0x0070)
class UBTDecorator_HasBetterItemValue final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBTargetObject;                                    // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         CollectUnderItemWeight;                            // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollectOverWeightRatioDifference;                  // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasBetterItemValue">();
	}
	static class UBTDecorator_HasBetterItemValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasBetterItemValue>();
	}
};
static_assert(alignof(UBTDecorator_HasBetterItemValue) == 0x000008, "Wrong alignment on UBTDecorator_HasBetterItemValue");
static_assert(sizeof(UBTDecorator_HasBetterItemValue) == 0x0000A8, "Wrong size on UBTDecorator_HasBetterItemValue");
static_assert(offsetof(UBTDecorator_HasBetterItemValue, BBTargetObject) == 0x000070, "Member 'UBTDecorator_HasBetterItemValue::BBTargetObject' has a wrong offset!");
static_assert(offsetof(UBTDecorator_HasBetterItemValue, CollectUnderItemWeight) == 0x0000A0, "Member 'UBTDecorator_HasBetterItemValue::CollectUnderItemWeight' has a wrong offset!");
static_assert(offsetof(UBTDecorator_HasBetterItemValue, CollectOverWeightRatioDifference) == 0x0000A4, "Member 'UBTDecorator_HasBetterItemValue::CollectOverWeightRatioDifference' has a wrong offset!");

// Class DBDBots.BTDecorator_HasDynamicSubtree
// 0x0010 (0x0080 - 0x0070)
class UBTDecorator_HasDynamicSubtree final : public UBTDecorator_TickableBase
{
public:
	struct FGameplayTag                           InjectTag;                                         // 0x0070(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasDynamicSubtree">();
	}
	static class UBTDecorator_HasDynamicSubtree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasDynamicSubtree>();
	}
};
static_assert(alignof(UBTDecorator_HasDynamicSubtree) == 0x000008, "Wrong alignment on UBTDecorator_HasDynamicSubtree");
static_assert(sizeof(UBTDecorator_HasDynamicSubtree) == 0x000080, "Wrong size on UBTDecorator_HasDynamicSubtree");
static_assert(offsetof(UBTDecorator_HasDynamicSubtree, InjectTag) == 0x000070, "Member 'UBTDecorator_HasDynamicSubtree::InjectTag' has a wrong offset!");

// Class DBDBots.BTDecorator_HasGoodHookEscapeChance
// 0x0008 (0x0078 - 0x0070)
class UBTDecorator_HasGoodHookEscapeChance final : public UBTDecorator_TickableBase
{
public:
	float                                         GoodHookEscapeProbability;                         // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasGoodHookEscapeChance">();
	}
	static class UBTDecorator_HasGoodHookEscapeChance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasGoodHookEscapeChance>();
	}
};
static_assert(alignof(UBTDecorator_HasGoodHookEscapeChance) == 0x000008, "Wrong alignment on UBTDecorator_HasGoodHookEscapeChance");
static_assert(sizeof(UBTDecorator_HasGoodHookEscapeChance) == 0x000078, "Wrong size on UBTDecorator_HasGoodHookEscapeChance");
static_assert(offsetof(UBTDecorator_HasGoodHookEscapeChance, GoodHookEscapeProbability) == 0x000070, "Member 'UBTDecorator_HasGoodHookEscapeChance::GoodHookEscapeProbability' has a wrong offset!");

// Class DBDBots.BTDecorator_HasItemAddon
// 0x0010 (0x0080 - 0x0070)
class UBTDecorator_HasItemAddon final : public UBTDecorator_TickableBase
{
public:
	TArray<struct FAIHasItemAddonCondition>       ItemAddons;                                        // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasItemAddon">();
	}
	static class UBTDecorator_HasItemAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasItemAddon>();
	}
};
static_assert(alignof(UBTDecorator_HasItemAddon) == 0x000008, "Wrong alignment on UBTDecorator_HasItemAddon");
static_assert(sizeof(UBTDecorator_HasItemAddon) == 0x000080, "Wrong size on UBTDecorator_HasItemAddon");
static_assert(offsetof(UBTDecorator_HasItemAddon, ItemAddons) == 0x000070, "Member 'UBTDecorator_HasItemAddon::ItemAddons' has a wrong offset!");

// Class DBDBots.BTDecorator_HasPerk
// 0x0028 (0x0098 - 0x0070)
class UBTDecorator_HasPerk final : public UBTDecorator_TickableBase
{
public:
	EPlayerFilter                                 PlayerFilter;                                      // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAIHasPerkCondition>            Perks;                                             // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class ADBDPlayer*>                     _players;                                          // 0x0088(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasPerk">();
	}
	static class UBTDecorator_HasPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasPerk>();
	}
};
static_assert(alignof(UBTDecorator_HasPerk) == 0x000008, "Wrong alignment on UBTDecorator_HasPerk");
static_assert(sizeof(UBTDecorator_HasPerk) == 0x000098, "Wrong size on UBTDecorator_HasPerk");
static_assert(offsetof(UBTDecorator_HasPerk, PlayerFilter) == 0x000070, "Member 'UBTDecorator_HasPerk::PlayerFilter' has a wrong offset!");
static_assert(offsetof(UBTDecorator_HasPerk, Perks) == 0x000078, "Member 'UBTDecorator_HasPerk::Perks' has a wrong offset!");
static_assert(offsetof(UBTDecorator_HasPerk, _players) == 0x000088, "Member 'UBTDecorator_HasPerk::_players' has a wrong offset!");

// Class DBDBots.BTDecorator_HasPerkFlag
// 0x0010 (0x0080 - 0x0070)
class UBTDecorator_HasPerkFlag final : public UBTDecorator_TickableBase
{
public:
	TArray<struct FGameplayTag>                   GameplayTags;                                      // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasPerkFlag">();
	}
	static class UBTDecorator_HasPerkFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasPerkFlag>();
	}
};
static_assert(alignof(UBTDecorator_HasPerkFlag) == 0x000008, "Wrong alignment on UBTDecorator_HasPerkFlag");
static_assert(sizeof(UBTDecorator_HasPerkFlag) == 0x000080, "Wrong size on UBTDecorator_HasPerkFlag");
static_assert(offsetof(UBTDecorator_HasPerkFlag, GameplayTags) == 0x000070, "Member 'UBTDecorator_HasPerkFlag::GameplayTags' has a wrong offset!");

// Class DBDBots.BTDecorator_HasStateTag
// 0x0010 (0x0080 - 0x0070)
class UBTDecorator_HasStateTag final : public UBTDecorator_TickableBase
{
public:
	TArray<struct FGameplayTag>                   StateTags;                                         // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasStateTag">();
	}
	static class UBTDecorator_HasStateTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasStateTag>();
	}
};
static_assert(alignof(UBTDecorator_HasStateTag) == 0x000008, "Wrong alignment on UBTDecorator_HasStateTag");
static_assert(sizeof(UBTDecorator_HasStateTag) == 0x000080, "Wrong size on UBTDecorator_HasStateTag");
static_assert(offsetof(UBTDecorator_HasStateTag, StateTags) == 0x000070, "Member 'UBTDecorator_HasStateTag::StateTags' has a wrong offset!");

// Class DBDBots.BTDecorator_HasStatusEffect
// 0x0010 (0x0080 - 0x0070)
class UBTDecorator_HasStatusEffect final : public UBTDecorator_TickableBase
{
public:
	TArray<class FName>                           StatusEffectIds;                                   // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasStatusEffect">();
	}
	static class UBTDecorator_HasStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasStatusEffect>();
	}
};
static_assert(alignof(UBTDecorator_HasStatusEffect) == 0x000008, "Wrong alignment on UBTDecorator_HasStatusEffect");
static_assert(sizeof(UBTDecorator_HasStatusEffect) == 0x000080, "Wrong size on UBTDecorator_HasStatusEffect");
static_assert(offsetof(UBTDecorator_HasStatusEffect, StatusEffectIds) == 0x000070, "Member 'UBTDecorator_HasStatusEffect::StatusEffectIds' has a wrong offset!");

// Class DBDBots.BTDecorator_IsCamperState
// 0x0040 (0x00B0 - 0x0070)
class UBTDecorator_IsCamperState final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBCamper;                                          // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	ECamperDamageState                            DamageState;                                       // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArithmeticKeyOperation                       DamageOp;                                          // 0x00A1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECamperImmobilizeState                        ImmobilizeState;                                   // 0x00A2(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArithmeticKeyOperation                       ImmobilizeOp;                                      // 0x00A3(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIsCamperStateOnFilter                        OnFilter;                                          // 0x00A4(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArithmeticKeyOperation                       OnOthersFilterOp;                                  // 0x00A5(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A6[0x2];                                       // 0x00A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NbOnOthersCampers;                                 // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsCamperState">();
	}
	static class UBTDecorator_IsCamperState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsCamperState>();
	}
};
static_assert(alignof(UBTDecorator_IsCamperState) == 0x000008, "Wrong alignment on UBTDecorator_IsCamperState");
static_assert(sizeof(UBTDecorator_IsCamperState) == 0x0000B0, "Wrong size on UBTDecorator_IsCamperState");
static_assert(offsetof(UBTDecorator_IsCamperState, BBCamper) == 0x000070, "Member 'UBTDecorator_IsCamperState::BBCamper' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsCamperState, DamageState) == 0x0000A0, "Member 'UBTDecorator_IsCamperState::DamageState' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsCamperState, DamageOp) == 0x0000A1, "Member 'UBTDecorator_IsCamperState::DamageOp' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsCamperState, ImmobilizeState) == 0x0000A2, "Member 'UBTDecorator_IsCamperState::ImmobilizeState' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsCamperState, ImmobilizeOp) == 0x0000A3, "Member 'UBTDecorator_IsCamperState::ImmobilizeOp' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsCamperState, OnFilter) == 0x0000A4, "Member 'UBTDecorator_IsCamperState::OnFilter' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsCamperState, OnOthersFilterOp) == 0x0000A5, "Member 'UBTDecorator_IsCamperState::OnOthersFilterOp' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsCamperState, NbOnOthersCampers) == 0x0000A8, "Member 'UBTDecorator_IsCamperState::NbOnOthersCampers' has a wrong offset!");

// Class DBDBots.BTDecorator_IsGameState
// 0x0010 (0x0080 - 0x0070)
class UBTDecorator_IsGameState final : public UBTDecorator_TickableBase
{
public:
	EArithmeticKeyOperation                       RemainingObjectiveOp;                              // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NbRemainingObjectives;                             // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArithmeticKeyOperation                       SurvivorsLeftOp;                                   // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NbSurvivorsLeft;                                   // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsGameState">();
	}
	static class UBTDecorator_IsGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsGameState>();
	}
};
static_assert(alignof(UBTDecorator_IsGameState) == 0x000008, "Wrong alignment on UBTDecorator_IsGameState");
static_assert(sizeof(UBTDecorator_IsGameState) == 0x000080, "Wrong size on UBTDecorator_IsGameState");
static_assert(offsetof(UBTDecorator_IsGameState, RemainingObjectiveOp) == 0x000070, "Member 'UBTDecorator_IsGameState::RemainingObjectiveOp' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsGameState, NbRemainingObjectives) == 0x000074, "Member 'UBTDecorator_IsGameState::NbRemainingObjectives' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsGameState, SurvivorsLeftOp) == 0x000078, "Member 'UBTDecorator_IsGameState::SurvivorsLeftOp' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsGameState, NbSurvivorsLeft) == 0x00007C, "Member 'UBTDecorator_IsGameState::NbSurvivorsLeft' has a wrong offset!");

// Class DBDBots.BTDecorator_IsInteractorAvailable
// 0x0030 (0x00A0 - 0x0070)
class UBTDecorator_IsInteractorAvailable final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBInteractorObj;                                   // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsInteractorAvailable">();
	}
	static class UBTDecorator_IsInteractorAvailable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsInteractorAvailable>();
	}
};
static_assert(alignof(UBTDecorator_IsInteractorAvailable) == 0x000008, "Wrong alignment on UBTDecorator_IsInteractorAvailable");
static_assert(sizeof(UBTDecorator_IsInteractorAvailable) == 0x0000A0, "Wrong size on UBTDecorator_IsInteractorAvailable");
static_assert(offsetof(UBTDecorator_IsInteractorAvailable, BBInteractorObj) == 0x000070, "Member 'UBTDecorator_IsInteractorAvailable::BBInteractorObj' has a wrong offset!");

// Class DBDBots.BTDecorator_IsLocationInPressureZone
// 0x0030 (0x00A0 - 0x0070)
class UBTDecorator_IsLocationInPressureZone final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBAtLocation;                                      // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsLocationInPressureZone">();
	}
	static class UBTDecorator_IsLocationInPressureZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsLocationInPressureZone>();
	}
};
static_assert(alignof(UBTDecorator_IsLocationInPressureZone) == 0x000008, "Wrong alignment on UBTDecorator_IsLocationInPressureZone");
static_assert(sizeof(UBTDecorator_IsLocationInPressureZone) == 0x0000A0, "Wrong size on UBTDecorator_IsLocationInPressureZone");
static_assert(offsetof(UBTDecorator_IsLocationInPressureZone, BBAtLocation) == 0x000070, "Member 'UBTDecorator_IsLocationInPressureZone::BBAtLocation' has a wrong offset!");

// Class DBDBots.BTDecorator_IsNearestThan
// 0x0070 (0x00E0 - 0x0070)
class UBTDecorator_IsNearestThan final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBFrom;                                            // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          CompareWithConstantDistance;                       // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThanDistance;                                      // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBThan;                                            // 0x00A8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         AddDistanceBuffer;                                 // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsNearestThan">();
	}
	static class UBTDecorator_IsNearestThan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsNearestThan>();
	}
};
static_assert(alignof(UBTDecorator_IsNearestThan) == 0x000008, "Wrong alignment on UBTDecorator_IsNearestThan");
static_assert(sizeof(UBTDecorator_IsNearestThan) == 0x0000E0, "Wrong size on UBTDecorator_IsNearestThan");
static_assert(offsetof(UBTDecorator_IsNearestThan, BBFrom) == 0x000070, "Member 'UBTDecorator_IsNearestThan::BBFrom' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsNearestThan, CompareWithConstantDistance) == 0x0000A0, "Member 'UBTDecorator_IsNearestThan::CompareWithConstantDistance' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsNearestThan, ThanDistance) == 0x0000A4, "Member 'UBTDecorator_IsNearestThan::ThanDistance' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsNearestThan, BBThan) == 0x0000A8, "Member 'UBTDecorator_IsNearestThan::BBThan' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsNearestThan, AddDistanceBuffer) == 0x0000D8, "Member 'UBTDecorator_IsNearestThan::AddDistanceBuffer' has a wrong offset!");

// Class DBDBots.BTDecorator_IsTunable
// 0x0018 (0x0088 - 0x0070)
class UBTDecorator_IsTunable final : public UBTDecorator_TickableBase
{
public:
	ETunableComparison                            Operator;                                          // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    TunableValue;                                      // 0x0074(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CompareToValue;                                    // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_IsTunable">();
	}
	static class UBTDecorator_IsTunable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_IsTunable>();
	}
};
static_assert(alignof(UBTDecorator_IsTunable) == 0x000008, "Wrong alignment on UBTDecorator_IsTunable");
static_assert(sizeof(UBTDecorator_IsTunable) == 0x000088, "Wrong size on UBTDecorator_IsTunable");
static_assert(offsetof(UBTDecorator_IsTunable, Operator) == 0x000070, "Member 'UBTDecorator_IsTunable::Operator' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsTunable, TunableValue) == 0x000074, "Member 'UBTDecorator_IsTunable::TunableValue' has a wrong offset!");
static_assert(offsetof(UBTDecorator_IsTunable, CompareToValue) == 0x000084, "Member 'UBTDecorator_IsTunable::CompareToValue' has a wrong offset!");

// Class DBDBots.BTDecorator_RandomByDistance
// 0x00E0 (0x0150 - 0x0070)
class UBTDecorator_RandomByDistance final : public UBTDecorator_TickableBase
{
public:
	struct FBlackboardKeySelector                 BBAroundLoc;                                       // 0x0070(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBRelativeFromTime;                                // 0x00A0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBRelativeToTime;                                  // 0x00D0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    StartDistance;                                     // 0x0100(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    EndDistance;                                       // 0x0110(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PercentageAtStartDistance;                         // 0x0120(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PercentageAtEndDistance;                           // 0x0130(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FAIRandomByDistancePercentagesAtTime> PercentagesAtTimes;                          // 0x0140(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RandomByDistance">();
	}
	static class UBTDecorator_RandomByDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RandomByDistance>();
	}
};
static_assert(alignof(UBTDecorator_RandomByDistance) == 0x000008, "Wrong alignment on UBTDecorator_RandomByDistance");
static_assert(sizeof(UBTDecorator_RandomByDistance) == 0x000150, "Wrong size on UBTDecorator_RandomByDistance");
static_assert(offsetof(UBTDecorator_RandomByDistance, BBAroundLoc) == 0x000070, "Member 'UBTDecorator_RandomByDistance::BBAroundLoc' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByDistance, BBRelativeFromTime) == 0x0000A0, "Member 'UBTDecorator_RandomByDistance::BBRelativeFromTime' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByDistance, BBRelativeToTime) == 0x0000D0, "Member 'UBTDecorator_RandomByDistance::BBRelativeToTime' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByDistance, StartDistance) == 0x000100, "Member 'UBTDecorator_RandomByDistance::StartDistance' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByDistance, EndDistance) == 0x000110, "Member 'UBTDecorator_RandomByDistance::EndDistance' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByDistance, PercentageAtStartDistance) == 0x000120, "Member 'UBTDecorator_RandomByDistance::PercentageAtStartDistance' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByDistance, PercentageAtEndDistance) == 0x000130, "Member 'UBTDecorator_RandomByDistance::PercentageAtEndDistance' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByDistance, PercentagesAtTimes) == 0x000140, "Member 'UBTDecorator_RandomByDistance::PercentagesAtTimes' has a wrong offset!");

// Class DBDBots.BTDecorator_RandomByRetry
// 0x0038 (0x00A8 - 0x0070)
class UBTDecorator_RandomByRetry final : public UBTDecorator_TickableBase
{
public:
	struct FAITunableParameter                    BaseSuccessRate;                                   // 0x0070(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PerRetrySuccessRate;                               // 0x0080(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ResetWhenValue;                                    // 0x0090(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    ResetAfterTime;                                    // 0x0094(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ResetOnCeaseRelevant;                              // 0x00A4(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_RandomByRetry">();
	}
	static class UBTDecorator_RandomByRetry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_RandomByRetry>();
	}
};
static_assert(alignof(UBTDecorator_RandomByRetry) == 0x000008, "Wrong alignment on UBTDecorator_RandomByRetry");
static_assert(sizeof(UBTDecorator_RandomByRetry) == 0x0000A8, "Wrong size on UBTDecorator_RandomByRetry");
static_assert(offsetof(UBTDecorator_RandomByRetry, BaseSuccessRate) == 0x000070, "Member 'UBTDecorator_RandomByRetry::BaseSuccessRate' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByRetry, PerRetrySuccessRate) == 0x000080, "Member 'UBTDecorator_RandomByRetry::PerRetrySuccessRate' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByRetry, ResetWhenValue) == 0x000090, "Member 'UBTDecorator_RandomByRetry::ResetWhenValue' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByRetry, ResetAfterTime) == 0x000094, "Member 'UBTDecorator_RandomByRetry::ResetAfterTime' has a wrong offset!");
static_assert(offsetof(UBTDecorator_RandomByRetry, ResetOnCeaseRelevant) == 0x0000A4, "Member 'UBTDecorator_RandomByRetry::ResetOnCeaseRelevant' has a wrong offset!");

// Class DBDBots.BTService_AroundEQS
// 0x0070 (0x0178 - 0x0108)
class UBTService_AroundEQS final : public UBTService_RunEQS
{
public:
	struct FBlackboardKeySelector                 BBAroundObj;                                       // 0x0108(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBAroundLocation;                                  // 0x0138(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         ValidLocationRefreshInterval;                      // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvalidLocationRefreshInterval;                    // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvalidateLocationUnderTargetDistance;             // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_AroundEQS">();
	}
	static class UBTService_AroundEQS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_AroundEQS>();
	}
};
static_assert(alignof(UBTService_AroundEQS) == 0x000008, "Wrong alignment on UBTService_AroundEQS");
static_assert(sizeof(UBTService_AroundEQS) == 0x000178, "Wrong size on UBTService_AroundEQS");
static_assert(offsetof(UBTService_AroundEQS, BBAroundObj) == 0x000108, "Member 'UBTService_AroundEQS::BBAroundObj' has a wrong offset!");
static_assert(offsetof(UBTService_AroundEQS, BBAroundLocation) == 0x000138, "Member 'UBTService_AroundEQS::BBAroundLocation' has a wrong offset!");
static_assert(offsetof(UBTService_AroundEQS, ValidLocationRefreshInterval) == 0x000168, "Member 'UBTService_AroundEQS::ValidLocationRefreshInterval' has a wrong offset!");
static_assert(offsetof(UBTService_AroundEQS, InvalidLocationRefreshInterval) == 0x00016C, "Member 'UBTService_AroundEQS::InvalidLocationRefreshInterval' has a wrong offset!");
static_assert(offsetof(UBTService_AroundEQS, InvalidateLocationUnderTargetDistance) == 0x000170, "Member 'UBTService_AroundEQS::InvalidateLocationUnderTargetDistance' has a wrong offset!");

// Class DBDBots.BTService_CopyBBEntry
// 0x0068 (0x00E8 - 0x0080)
class UBTService_CopyBBEntry final : public UBTService_OnRelevantBase
{
public:
	struct FBlackboardKeySelector                 BBFrom;                                            // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBTo;                                              // 0x00B0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          CopyOnlyValidKeyValue;                             // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_CopyBBEntry">();
	}
	static class UBTService_CopyBBEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_CopyBBEntry>();
	}
};
static_assert(alignof(UBTService_CopyBBEntry) == 0x000008, "Wrong alignment on UBTService_CopyBBEntry");
static_assert(sizeof(UBTService_CopyBBEntry) == 0x0000E8, "Wrong size on UBTService_CopyBBEntry");
static_assert(offsetof(UBTService_CopyBBEntry, BBFrom) == 0x000080, "Member 'UBTService_CopyBBEntry::BBFrom' has a wrong offset!");
static_assert(offsetof(UBTService_CopyBBEntry, BBTo) == 0x0000B0, "Member 'UBTService_CopyBBEntry::BBTo' has a wrong offset!");
static_assert(offsetof(UBTService_CopyBBEntry, CopyOnlyValidKeyValue) == 0x0000E0, "Member 'UBTService_CopyBBEntry::CopyOnlyValidKeyValue' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_Exit
// 0x0068 (0x0318 - 0x02B0)
class UBTService_FindInteractor_Exit final : public UBTService_FindInteractor
{
public:
	EFindInteractorExitOptions                    Filter;                                            // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFindInteractorOpenConditions                 OpenCondition;                                     // 0x02B1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2[0x6];                                      // 0x02B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBFinalExitLocation;                               // 0x02B8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         ClosedDoorOffset;                                  // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenDoorOffset;                                    // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AbortOnBlockedExitSwitch;                          // 0x02F0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F1[0x3];                                      // 0x02F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    OpenedExitGoalWeight;                              // 0x02F4(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    HatchBonusGoalWeight;                              // 0x0304(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Exit">();
	}
	static class UBTService_FindInteractor_Exit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Exit>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Exit) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Exit");
static_assert(sizeof(UBTService_FindInteractor_Exit) == 0x000318, "Wrong size on UBTService_FindInteractor_Exit");
static_assert(offsetof(UBTService_FindInteractor_Exit, Filter) == 0x0002B0, "Member 'UBTService_FindInteractor_Exit::Filter' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Exit, OpenCondition) == 0x0002B1, "Member 'UBTService_FindInteractor_Exit::OpenCondition' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Exit, BBFinalExitLocation) == 0x0002B8, "Member 'UBTService_FindInteractor_Exit::BBFinalExitLocation' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Exit, ClosedDoorOffset) == 0x0002E8, "Member 'UBTService_FindInteractor_Exit::ClosedDoorOffset' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Exit, OpenDoorOffset) == 0x0002EC, "Member 'UBTService_FindInteractor_Exit::OpenDoorOffset' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Exit, AbortOnBlockedExitSwitch) == 0x0002F0, "Member 'UBTService_FindInteractor_Exit::AbortOnBlockedExitSwitch' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Exit, OpenedExitGoalWeight) == 0x0002F4, "Member 'UBTService_FindInteractor_Exit::OpenedExitGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Exit, HatchBonusGoalWeight) == 0x000304, "Member 'UBTService_FindInteractor_Exit::HatchBonusGoalWeight' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_Locker
// 0x0028 (0x02D8 - 0x02B0)
class UBTService_FindInteractor_Locker final : public UBTService_FindInteractor
{
public:
	EFindInteractableLockerStatusFilter           StatusFilter;                                      // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LockerNeedsToBeOpenable;                           // 0x02B1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B2[0x6];                                      // 0x02B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInLockerPerk>                  PerksToRunInLocker;                                // 0x02B8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Locker">();
	}
	static class UBTService_FindInteractor_Locker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Locker>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Locker) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Locker");
static_assert(sizeof(UBTService_FindInteractor_Locker) == 0x0002D8, "Wrong size on UBTService_FindInteractor_Locker");
static_assert(offsetof(UBTService_FindInteractor_Locker, StatusFilter) == 0x0002B0, "Member 'UBTService_FindInteractor_Locker::StatusFilter' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Locker, LockerNeedsToBeOpenable) == 0x0002B1, "Member 'UBTService_FindInteractor_Locker::LockerNeedsToBeOpenable' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Locker, PerksToRunInLocker) == 0x0002B8, "Member 'UBTService_FindInteractor_Locker::PerksToRunInLocker' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_MeatHook
// 0x00D8 (0x0388 - 0x02B0)
class UBTService_FindInteractor_MeatHook final : public UBTService_FindInteractor
{
public:
	EFindInteractableMeatHookStatus               StatusFilter;                                      // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    AllyDangerStateGoalWeight;                         // 0x02B4(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BotDangerStateGoalWeight;                          // 0x02C4(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BotInjuredStateGoalWeight;                         // 0x02D4(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    HumanAllyHookedGoalWeight;                         // 0x02E4(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxHookTimeGoalWeight;                             // 0x02F4(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    IncapacitatedAlliesGoalWeight;                     // 0x0304(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    IdealKillerDistanceFromHook;                       // 0x0314(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MaxKillerProximityWeight;                          // 0x0324(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SabotageKillerDistanceToHookScore;                 // 0x0334(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SabotageKillerSpeedToHookScore;                    // 0x0344(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SabotageHookValidTargetTime;                       // 0x0354(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	float                                         KillerTargetUpdateInterval;                        // 0x0364(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnsafeSabotageHealthyMarginTime;                   // 0x0368(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnsafeSabotageInjuredMarginTime;                   // 0x036C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NoToolboxInteractionID;                            // 0x0370(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x8];                                      // 0x0380(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_MeatHook">();
	}
	static class UBTService_FindInteractor_MeatHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_MeatHook>();
	}
};
static_assert(alignof(UBTService_FindInteractor_MeatHook) == 0x000008, "Wrong alignment on UBTService_FindInteractor_MeatHook");
static_assert(sizeof(UBTService_FindInteractor_MeatHook) == 0x000388, "Wrong size on UBTService_FindInteractor_MeatHook");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, StatusFilter) == 0x0002B0, "Member 'UBTService_FindInteractor_MeatHook::StatusFilter' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, AllyDangerStateGoalWeight) == 0x0002B4, "Member 'UBTService_FindInteractor_MeatHook::AllyDangerStateGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, BotDangerStateGoalWeight) == 0x0002C4, "Member 'UBTService_FindInteractor_MeatHook::BotDangerStateGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, BotInjuredStateGoalWeight) == 0x0002D4, "Member 'UBTService_FindInteractor_MeatHook::BotInjuredStateGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, HumanAllyHookedGoalWeight) == 0x0002E4, "Member 'UBTService_FindInteractor_MeatHook::HumanAllyHookedGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, MaxHookTimeGoalWeight) == 0x0002F4, "Member 'UBTService_FindInteractor_MeatHook::MaxHookTimeGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, IncapacitatedAlliesGoalWeight) == 0x000304, "Member 'UBTService_FindInteractor_MeatHook::IncapacitatedAlliesGoalWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, IdealKillerDistanceFromHook) == 0x000314, "Member 'UBTService_FindInteractor_MeatHook::IdealKillerDistanceFromHook' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, MaxKillerProximityWeight) == 0x000324, "Member 'UBTService_FindInteractor_MeatHook::MaxKillerProximityWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, SabotageKillerDistanceToHookScore) == 0x000334, "Member 'UBTService_FindInteractor_MeatHook::SabotageKillerDistanceToHookScore' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, SabotageKillerSpeedToHookScore) == 0x000344, "Member 'UBTService_FindInteractor_MeatHook::SabotageKillerSpeedToHookScore' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, SabotageHookValidTargetTime) == 0x000354, "Member 'UBTService_FindInteractor_MeatHook::SabotageHookValidTargetTime' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, KillerTargetUpdateInterval) == 0x000364, "Member 'UBTService_FindInteractor_MeatHook::KillerTargetUpdateInterval' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, UnsafeSabotageHealthyMarginTime) == 0x000368, "Member 'UBTService_FindInteractor_MeatHook::UnsafeSabotageHealthyMarginTime' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, UnsafeSabotageInjuredMarginTime) == 0x00036C, "Member 'UBTService_FindInteractor_MeatHook::UnsafeSabotageInjuredMarginTime' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_MeatHook, NoToolboxInteractionID) == 0x000370, "Member 'UBTService_FindInteractor_MeatHook::NoToolboxInteractionID' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_Pallet
// 0x0138 (0x03E8 - 0x02B0)
class UBTService_FindInteractor_Pallet final : public UBTService_FindInteractor
{
public:
	struct FBlackboardKeySelector                 BBPickSideRelativelyFrom;                          // 0x02B0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EFindInteractablePalletIntentions             IntentionFilter;                                   // 0x02E0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x3];                                      // 0x02E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RaisePalletPerkId;                                 // 0x02E4(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BrokenGeneratorGoalMaxDistance;                    // 0x02F0(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    BrokenGeneratorGoalMaxDistanceWeight;              // 0x0300(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SpawnInSurvivorLOSPenalty;                         // 0x0310(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SpawnNearSurvivorMinDistanceSquared;               // 0x0320(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    SpawnNearSurvivorPenalty;                          // 0x0330(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PlacedNearGamePalletMinDistanceSquared;            // 0x0340(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PlacedNearGamePalletPenalty;                       // 0x0350(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ConvincingFactorTolerance;                         // 0x0360(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ShouldFallPalletUnderHostileRange;                 // 0x0370(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ExtraHealthySurvivorActionTime;                    // 0x0380(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExtraInjuredSurvivorActionTime;                    // 0x0384(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_388[0x60];                                     // 0x0388(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Pallet">();
	}
	static class UBTService_FindInteractor_Pallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Pallet>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Pallet) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Pallet");
static_assert(sizeof(UBTService_FindInteractor_Pallet) == 0x0003E8, "Wrong size on UBTService_FindInteractor_Pallet");
static_assert(offsetof(UBTService_FindInteractor_Pallet, BBPickSideRelativelyFrom) == 0x0002B0, "Member 'UBTService_FindInteractor_Pallet::BBPickSideRelativelyFrom' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, IntentionFilter) == 0x0002E0, "Member 'UBTService_FindInteractor_Pallet::IntentionFilter' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, RaisePalletPerkId) == 0x0002E4, "Member 'UBTService_FindInteractor_Pallet::RaisePalletPerkId' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, BrokenGeneratorGoalMaxDistance) == 0x0002F0, "Member 'UBTService_FindInteractor_Pallet::BrokenGeneratorGoalMaxDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, BrokenGeneratorGoalMaxDistanceWeight) == 0x000300, "Member 'UBTService_FindInteractor_Pallet::BrokenGeneratorGoalMaxDistanceWeight' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, SpawnInSurvivorLOSPenalty) == 0x000310, "Member 'UBTService_FindInteractor_Pallet::SpawnInSurvivorLOSPenalty' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, SpawnNearSurvivorMinDistanceSquared) == 0x000320, "Member 'UBTService_FindInteractor_Pallet::SpawnNearSurvivorMinDistanceSquared' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, SpawnNearSurvivorPenalty) == 0x000330, "Member 'UBTService_FindInteractor_Pallet::SpawnNearSurvivorPenalty' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, PlacedNearGamePalletMinDistanceSquared) == 0x000340, "Member 'UBTService_FindInteractor_Pallet::PlacedNearGamePalletMinDistanceSquared' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, PlacedNearGamePalletPenalty) == 0x000350, "Member 'UBTService_FindInteractor_Pallet::PlacedNearGamePalletPenalty' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, ConvincingFactorTolerance) == 0x000360, "Member 'UBTService_FindInteractor_Pallet::ConvincingFactorTolerance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, ShouldFallPalletUnderHostileRange) == 0x000370, "Member 'UBTService_FindInteractor_Pallet::ShouldFallPalletUnderHostileRange' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, ExtraHealthySurvivorActionTime) == 0x000380, "Member 'UBTService_FindInteractor_Pallet::ExtraHealthySurvivorActionTime' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Pallet, ExtraInjuredSurvivorActionTime) == 0x000384, "Member 'UBTService_FindInteractor_Pallet::ExtraInjuredSurvivorActionTime' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_Searchable
// 0x0000 (0x02B0 - 0x02B0)
class UBTService_FindInteractor_Searchable final : public UBTService_FindInteractor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Searchable">();
	}
	static class UBTService_FindInteractor_Searchable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Searchable>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Searchable) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Searchable");
static_assert(sizeof(UBTService_FindInteractor_Searchable) == 0x0002B0, "Wrong size on UBTService_FindInteractor_Searchable");

// Class DBDBots.BTService_FindInteractor_Totem
// 0x0050 (0x0300 - 0x02B0)
class UBTService_FindInteractor_Totem final : public UBTService_FindInteractor
{
public:
	struct FAITunableParameter                    InactiveGoalWeightMaxDistance;                     // 0x02B0(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    InactiveGoalWeightAtMinDistance;                   // 0x02C0(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FAICleansePerkCondition>        CleansePerks;                                      // 0x02D0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          SearchUsingBoundPerks;                             // 0x02E0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           BoundPerkIds;                                      // 0x02E8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          OnlyWhenInjured;                                   // 0x02F8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Totem">();
	}
	static class UBTService_FindInteractor_Totem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Totem>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Totem) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Totem");
static_assert(sizeof(UBTService_FindInteractor_Totem) == 0x000300, "Wrong size on UBTService_FindInteractor_Totem");
static_assert(offsetof(UBTService_FindInteractor_Totem, InactiveGoalWeightMaxDistance) == 0x0002B0, "Member 'UBTService_FindInteractor_Totem::InactiveGoalWeightMaxDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Totem, InactiveGoalWeightAtMinDistance) == 0x0002C0, "Member 'UBTService_FindInteractor_Totem::InactiveGoalWeightAtMinDistance' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Totem, CleansePerks) == 0x0002D0, "Member 'UBTService_FindInteractor_Totem::CleansePerks' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Totem, SearchUsingBoundPerks) == 0x0002E0, "Member 'UBTService_FindInteractor_Totem::SearchUsingBoundPerks' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Totem, BoundPerkIds) == 0x0002E8, "Member 'UBTService_FindInteractor_Totem::BoundPerkIds' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Totem, OnlyWhenInjured) == 0x0002F8, "Member 'UBTService_FindInteractor_Totem::OnlyWhenInjured' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_Trap
// 0x0038 (0x02E8 - 0x02B0)
class UBTService_FindInteractor_Trap final : public UBTService_FindInteractor
{
public:
	struct FAITunableParameter                    HelpDestroyDemoPortal;                             // 0x02B0(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIRoll                                SeeStandardTrapRoll;                               // 0x02C0(0x0024)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TrapGroundLocationOffset;                          // 0x02E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_Trap">();
	}
	static class UBTService_FindInteractor_Trap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_Trap>();
	}
};
static_assert(alignof(UBTService_FindInteractor_Trap) == 0x000008, "Wrong alignment on UBTService_FindInteractor_Trap");
static_assert(sizeof(UBTService_FindInteractor_Trap) == 0x0002E8, "Wrong size on UBTService_FindInteractor_Trap");
static_assert(offsetof(UBTService_FindInteractor_Trap, HelpDestroyDemoPortal) == 0x0002B0, "Member 'UBTService_FindInteractor_Trap::HelpDestroyDemoPortal' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Trap, SeeStandardTrapRoll) == 0x0002C0, "Member 'UBTService_FindInteractor_Trap::SeeStandardTrapRoll' has a wrong offset!");
static_assert(offsetof(UBTService_FindInteractor_Trap, TrapGroundLocationOffset) == 0x0002E4, "Member 'UBTService_FindInteractor_Trap::TrapGroundLocationOffset' has a wrong offset!");

// Class DBDBots.BTService_FindInteractor_WishList
// 0x0010 (0x02C0 - 0x02B0)
class UBTService_FindInteractor_WishList final : public UBTService_FindInteractor
{
public:
	struct FGameplayTag                           WishListTag;                                       // 0x02B0(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindInteractor_WishList">();
	}
	static class UBTService_FindInteractor_WishList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindInteractor_WishList>();
	}
};
static_assert(alignof(UBTService_FindInteractor_WishList) == 0x000008, "Wrong alignment on UBTService_FindInteractor_WishList");
static_assert(sizeof(UBTService_FindInteractor_WishList) == 0x0002C0, "Wrong size on UBTService_FindInteractor_WishList");
static_assert(offsetof(UBTService_FindInteractor_WishList, WishListTag) == 0x0002B0, "Member 'UBTService_FindInteractor_WishList::WishListTag' has a wrong offset!");

// Class DBDBots.BTService_FindObject
// 0x0048 (0x00C0 - 0x0078)
class UBTService_FindObject : public UBTService
{
public:
	EKillerAbilities                              KillerAbility;                                     // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBObjectLocation;                                  // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class ADBDAIBTController*                     _aiOwner;                                          // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASlasherPlayer*                         _killer;                                           // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_FindObject">();
	}
	static class UBTService_FindObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_FindObject>();
	}
};
static_assert(alignof(UBTService_FindObject) == 0x000008, "Wrong alignment on UBTService_FindObject");
static_assert(sizeof(UBTService_FindObject) == 0x0000C0, "Wrong size on UBTService_FindObject");
static_assert(offsetof(UBTService_FindObject, KillerAbility) == 0x000078, "Member 'UBTService_FindObject::KillerAbility' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject, BBObjectLocation) == 0x000080, "Member 'UBTService_FindObject::BBObjectLocation' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject, _aiOwner) == 0x0000B0, "Member 'UBTService_FindObject::_aiOwner' has a wrong offset!");
static_assert(offsetof(UBTService_FindObject, _killer) == 0x0000B8, "Member 'UBTService_FindObject::_killer' has a wrong offset!");

// Class DBDBots.BTService_Flee
// 0x00C0 (0x0138 - 0x0078)
class UBTService_Flee final : public UBTService
{
public:
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBFleePath;                                        // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBShouldFallPallet;                                // 0x00B0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TSubclassOf<class UPathStrategySelector>      PathStrategySelectorClass;                         // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnEndObjectInFocusCooldown;                        // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    ShouldFallPalletUnderHostileRange;                 // 0x00EC(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ClearFleePathBBKeyDelay;                           // 0x00FC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UNavMovePath*                           _activePath;                                       // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        _lostFocusedObjects;                               // 0x0118(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UPathStrategySelector*                  _strategySelector;                                 // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_Flee">();
	}
	static class UBTService_Flee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_Flee>();
	}
};
static_assert(alignof(UBTService_Flee) == 0x000008, "Wrong alignment on UBTService_Flee");
static_assert(sizeof(UBTService_Flee) == 0x000138, "Wrong size on UBTService_Flee");
static_assert(offsetof(UBTService_Flee, BBFleePath) == 0x000080, "Member 'UBTService_Flee::BBFleePath' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, BBShouldFallPallet) == 0x0000B0, "Member 'UBTService_Flee::BBShouldFallPallet' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, PathStrategySelectorClass) == 0x0000E0, "Member 'UBTService_Flee::PathStrategySelectorClass' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, OnEndObjectInFocusCooldown) == 0x0000E8, "Member 'UBTService_Flee::OnEndObjectInFocusCooldown' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, ShouldFallPalletUnderHostileRange) == 0x0000EC, "Member 'UBTService_Flee::ShouldFallPalletUnderHostileRange' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, ClearFleePathBBKeyDelay) == 0x0000FC, "Member 'UBTService_Flee::ClearFleePathBBKeyDelay' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, _activePath) == 0x000110, "Member 'UBTService_Flee::_activePath' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, _lostFocusedObjects) == 0x000118, "Member 'UBTService_Flee::_lostFocusedObjects' has a wrong offset!");
static_assert(offsetof(UBTService_Flee, _strategySelector) == 0x000128, "Member 'UBTService_Flee::_strategySelector' has a wrong offset!");

// Class DBDBots.BTService_GetPinLocation
// 0x0040 (0x00C0 - 0x0080)
class UBTService_GetPinLocation final : public UBTService_OnRelevantBase
{
public:
	struct FBlackboardKeySelector                 BBToSetKey;                                        // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PinTag;                                            // 0x00B0(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_GetPinLocation">();
	}
	static class UBTService_GetPinLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_GetPinLocation>();
	}
};
static_assert(alignof(UBTService_GetPinLocation) == 0x000008, "Wrong alignment on UBTService_GetPinLocation");
static_assert(sizeof(UBTService_GetPinLocation) == 0x0000C0, "Wrong size on UBTService_GetPinLocation");
static_assert(offsetof(UBTService_GetPinLocation, BBToSetKey) == 0x000080, "Member 'UBTService_GetPinLocation::BBToSetKey' has a wrong offset!");
static_assert(offsetof(UBTService_GetPinLocation, PinTag) == 0x0000B0, "Member 'UBTService_GetPinLocation::PinTag' has a wrong offset!");

// Class DBDBots.BTService_GetPinObject
// 0x0040 (0x00C0 - 0x0080)
class UBTService_GetPinObject final : public UBTService_OnRelevantBase
{
public:
	struct FBlackboardKeySelector                 BBToSetKey;                                        // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PinTag;                                            // 0x00B0(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_GetPinObject">();
	}
	static class UBTService_GetPinObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_GetPinObject>();
	}
};
static_assert(alignof(UBTService_GetPinObject) == 0x000008, "Wrong alignment on UBTService_GetPinObject");
static_assert(sizeof(UBTService_GetPinObject) == 0x0000C0, "Wrong size on UBTService_GetPinObject");
static_assert(offsetof(UBTService_GetPinObject, BBToSetKey) == 0x000080, "Member 'UBTService_GetPinObject::BBToSetKey' has a wrong offset!");
static_assert(offsetof(UBTService_GetPinObject, PinTag) == 0x0000B0, "Member 'UBTService_GetPinObject::PinTag' has a wrong offset!");

// Class DBDBots.BTService_InputAtTiming
// 0x0008 (0x0088 - 0x0080)
class UBTService_InputAtTiming final : public UBTService_OnRelevantBase
{
public:
	EPawnInputPressTypes                          InputType;                                         // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_InputAtTiming">();
	}
	static class UBTService_InputAtTiming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_InputAtTiming>();
	}
};
static_assert(alignof(UBTService_InputAtTiming) == 0x000008, "Wrong alignment on UBTService_InputAtTiming");
static_assert(sizeof(UBTService_InputAtTiming) == 0x000088, "Wrong size on UBTService_InputAtTiming");
static_assert(offsetof(UBTService_InputAtTiming, InputType) == 0x000080, "Member 'UBTService_InputAtTiming::InputType' has a wrong offset!");

// Class DBDBots.BTService_Patrol_Discovery
// 0x0010 (0x0168 - 0x0158)
class UBTService_Patrol_Discovery final : public UBTService_Patrol
{
public:
	bool                                          RejectPatrolPointIfInPressureZone;                 // 0x0158(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxFindRandomLocationOnTileAttempts;               // 0x015C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstFindOnNbNeighborTiles;                        // 0x0160(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_Patrol_Discovery">();
	}
	static class UBTService_Patrol_Discovery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_Patrol_Discovery>();
	}
};
static_assert(alignof(UBTService_Patrol_Discovery) == 0x000008, "Wrong alignment on UBTService_Patrol_Discovery");
static_assert(sizeof(UBTService_Patrol_Discovery) == 0x000168, "Wrong size on UBTService_Patrol_Discovery");
static_assert(offsetof(UBTService_Patrol_Discovery, RejectPatrolPointIfInPressureZone) == 0x000158, "Member 'UBTService_Patrol_Discovery::RejectPatrolPointIfInPressureZone' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol_Discovery, MaxFindRandomLocationOnTileAttempts) == 0x00015C, "Member 'UBTService_Patrol_Discovery::MaxFindRandomLocationOnTileAttempts' has a wrong offset!");
static_assert(offsetof(UBTService_Patrol_Discovery, FirstFindOnNbNeighborTiles) == 0x000160, "Member 'UBTService_Patrol_Discovery::FirstFindOnNbNeighborTiles' has a wrong offset!");

// Class DBDBots.BTService_PushObjectFocus
// 0x0030 (0x00A8 - 0x0078)
class UBTService_PushObjectFocus final : public UBTService
{
public:
	struct FBlackboardKeySelector                 BBFocusObj;                                        // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_PushObjectFocus">();
	}
	static class UBTService_PushObjectFocus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_PushObjectFocus>();
	}
};
static_assert(alignof(UBTService_PushObjectFocus) == 0x000008, "Wrong alignment on UBTService_PushObjectFocus");
static_assert(sizeof(UBTService_PushObjectFocus) == 0x0000A8, "Wrong size on UBTService_PushObjectFocus");
static_assert(offsetof(UBTService_PushObjectFocus, BBFocusObj) == 0x000078, "Member 'UBTService_PushObjectFocus::BBFocusObj' has a wrong offset!");

// Class DBDBots.BTService_RunSkills
// 0x0048 (0x00C0 - 0x0078)
class UBTService_RunSkills final : public UBTService
{
public:
	struct FGameplayTag                           Context;                                           // 0x0078(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBFilterKey;                                       // 0x0088(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EBasicKeyOperation                            FilterOperation;                                   // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_RunSkills">();
	}
	static class UBTService_RunSkills* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_RunSkills>();
	}
};
static_assert(alignof(UBTService_RunSkills) == 0x000008, "Wrong alignment on UBTService_RunSkills");
static_assert(sizeof(UBTService_RunSkills) == 0x0000C0, "Wrong size on UBTService_RunSkills");
static_assert(offsetof(UBTService_RunSkills, Context) == 0x000078, "Member 'UBTService_RunSkills::Context' has a wrong offset!");
static_assert(offsetof(UBTService_RunSkills, BBFilterKey) == 0x000088, "Member 'UBTService_RunSkills::BBFilterKey' has a wrong offset!");
static_assert(offsetof(UBTService_RunSkills, FilterOperation) == 0x0000B8, "Member 'UBTService_RunSkills::FilterOperation' has a wrong offset!");

// Class DBDBots.BTService_SetBBEntry
// 0x0050 (0x00D0 - 0x0080)
class UBTService_SetBBEntry final : public UBTService_OnRelevantBase
{
public:
	struct FBlackboardKeySelector                 BBToSetKey;                                        // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FString                                 ToSetValue;                                        // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    RandomSetChance;                                   // 0x00C0(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_SetBBEntry">();
	}
	static class UBTService_SetBBEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_SetBBEntry>();
	}
};
static_assert(alignof(UBTService_SetBBEntry) == 0x000008, "Wrong alignment on UBTService_SetBBEntry");
static_assert(sizeof(UBTService_SetBBEntry) == 0x0000D0, "Wrong size on UBTService_SetBBEntry");
static_assert(offsetof(UBTService_SetBBEntry, BBToSetKey) == 0x000080, "Member 'UBTService_SetBBEntry::BBToSetKey' has a wrong offset!");
static_assert(offsetof(UBTService_SetBBEntry, ToSetValue) == 0x0000B0, "Member 'UBTService_SetBBEntry::ToSetValue' has a wrong offset!");
static_assert(offsetof(UBTService_SetBBEntry, RandomSetChance) == 0x0000C0, "Member 'UBTService_SetBBEntry::RandomSetChance' has a wrong offset!");

// Class DBDBots.BTService_SetBBEntryTime
// 0x0030 (0x00B0 - 0x0080)
class UBTService_SetBBEntryTime final : public UBTService_OnRelevantBase
{
public:
	struct FBlackboardKeySelector                 BBToSetKey;                                        // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_SetBBEntryTime">();
	}
	static class UBTService_SetBBEntryTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_SetBBEntryTime>();
	}
};
static_assert(alignof(UBTService_SetBBEntryTime) == 0x000008, "Wrong alignment on UBTService_SetBBEntryTime");
static_assert(sizeof(UBTService_SetBBEntryTime) == 0x0000B0, "Wrong size on UBTService_SetBBEntryTime");
static_assert(offsetof(UBTService_SetBBEntryTime, BBToSetKey) == 0x000080, "Member 'UBTService_SetBBEntryTime::BBToSetKey' has a wrong offset!");

// Class DBDBots.BTService_SetFocusCooldown
// 0x0048 (0x00C8 - 0x0080)
class UBTService_SetFocusCooldown final : public UBTService_OnRelevantBase
{
public:
	struct FBlackboardKeySelector                 BBOnObject;                                        // 0x0080(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FName                                   ContextName;                                       // 0x00B0(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InfiniteDuration;                                  // 0x00BC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_SetFocusCooldown">();
	}
	static class UBTService_SetFocusCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_SetFocusCooldown>();
	}
};
static_assert(alignof(UBTService_SetFocusCooldown) == 0x000008, "Wrong alignment on UBTService_SetFocusCooldown");
static_assert(sizeof(UBTService_SetFocusCooldown) == 0x0000C8, "Wrong size on UBTService_SetFocusCooldown");
static_assert(offsetof(UBTService_SetFocusCooldown, BBOnObject) == 0x000080, "Member 'UBTService_SetFocusCooldown::BBOnObject' has a wrong offset!");
static_assert(offsetof(UBTService_SetFocusCooldown, ContextName) == 0x0000B0, "Member 'UBTService_SetFocusCooldown::ContextName' has a wrong offset!");
static_assert(offsetof(UBTService_SetFocusCooldown, InfiniteDuration) == 0x0000BC, "Member 'UBTService_SetFocusCooldown::InfiniteDuration' has a wrong offset!");
static_assert(offsetof(UBTService_SetFocusCooldown, Duration) == 0x0000C0, "Member 'UBTService_SetFocusCooldown::Duration' has a wrong offset!");

// Class DBDBots.BTService_SetPathSpeedFactor
// 0x0008 (0x0080 - 0x0078)
class UBTService_SetPathSpeedFactor final : public UBTService
{
public:
	float                                         SpeedFactor;                                       // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_SetPathSpeedFactor">();
	}
	static class UBTService_SetPathSpeedFactor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_SetPathSpeedFactor>();
	}
};
static_assert(alignof(UBTService_SetPathSpeedFactor) == 0x000008, "Wrong alignment on UBTService_SetPathSpeedFactor");
static_assert(sizeof(UBTService_SetPathSpeedFactor) == 0x000080, "Wrong size on UBTService_SetPathSpeedFactor");
static_assert(offsetof(UBTService_SetPathSpeedFactor, SpeedFactor) == 0x000078, "Member 'UBTService_SetPathSpeedFactor::SpeedFactor' has a wrong offset!");

// Class DBDBots.BTService_SetTagCooldown
// 0x0018 (0x0098 - 0x0080)
class UBTService_SetTagCooldown final : public UBTService_OnRelevantBase
{
public:
	struct FGameplayTag                           CooldownTag;                                       // 0x0080(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownDuration;                                  // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToExistingDuration;                            // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_SetTagCooldown">();
	}
	static class UBTService_SetTagCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_SetTagCooldown>();
	}
};
static_assert(alignof(UBTService_SetTagCooldown) == 0x000008, "Wrong alignment on UBTService_SetTagCooldown");
static_assert(sizeof(UBTService_SetTagCooldown) == 0x000098, "Wrong size on UBTService_SetTagCooldown");
static_assert(offsetof(UBTService_SetTagCooldown, CooldownTag) == 0x000080, "Member 'UBTService_SetTagCooldown::CooldownTag' has a wrong offset!");
static_assert(offsetof(UBTService_SetTagCooldown, CooldownDuration) == 0x00008C, "Member 'UBTService_SetTagCooldown::CooldownDuration' has a wrong offset!");
static_assert(offsetof(UBTService_SetTagCooldown, bAddToExistingDuration) == 0x000090, "Member 'UBTService_SetTagCooldown::bAddToExistingDuration' has a wrong offset!");

// Class DBDBots.BTService_StateMonitor_Slasher
// 0x0030 (0x0108 - 0x00D8)
class UBTService_StateMonitor_Slasher final : public UBTService_StateMonitor
{
public:
	struct FBlackboardKeySelector                 BBIsCarrying;                                      // 0x00D8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_StateMonitor_Slasher">();
	}
	static class UBTService_StateMonitor_Slasher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_StateMonitor_Slasher>();
	}
};
static_assert(alignof(UBTService_StateMonitor_Slasher) == 0x000008, "Wrong alignment on UBTService_StateMonitor_Slasher");
static_assert(sizeof(UBTService_StateMonitor_Slasher) == 0x000108, "Wrong size on UBTService_StateMonitor_Slasher");
static_assert(offsetof(UBTService_StateMonitor_Slasher, BBIsCarrying) == 0x0000D8, "Member 'UBTService_StateMonitor_Slasher::BBIsCarrying' has a wrong offset!");

// Class DBDBots.BTService_StimuliMonitor_Camper
// 0x0068 (0x0248 - 0x01E0)
class UBTService_StimuliMonitor_Camper final : public UBTService_StimuliMonitor
{
public:
	struct FBlackboardKeySelector                 BBTerrorPressure;                                  // 0x01E0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBIsFleeing;                                       // 0x0210(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         LastValidTerrorRadiusStimulusMemoryLifeTime;       // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IgnoreNonKillerStimulusWhileInSprintDistanceSquared; // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_StimuliMonitor_Camper">();
	}
	static class UBTService_StimuliMonitor_Camper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_StimuliMonitor_Camper>();
	}
};
static_assert(alignof(UBTService_StimuliMonitor_Camper) == 0x000008, "Wrong alignment on UBTService_StimuliMonitor_Camper");
static_assert(sizeof(UBTService_StimuliMonitor_Camper) == 0x000248, "Wrong size on UBTService_StimuliMonitor_Camper");
static_assert(offsetof(UBTService_StimuliMonitor_Camper, BBTerrorPressure) == 0x0001E0, "Member 'UBTService_StimuliMonitor_Camper::BBTerrorPressure' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Camper, BBIsFleeing) == 0x000210, "Member 'UBTService_StimuliMonitor_Camper::BBIsFleeing' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Camper, LastValidTerrorRadiusStimulusMemoryLifeTime) == 0x000240, "Member 'UBTService_StimuliMonitor_Camper::LastValidTerrorRadiusStimulusMemoryLifeTime' has a wrong offset!");
static_assert(offsetof(UBTService_StimuliMonitor_Camper, IgnoreNonKillerStimulusWhileInSprintDistanceSquared) == 0x000244, "Member 'UBTService_StimuliMonitor_Camper::IgnoreNonKillerStimulusWhileInSprintDistanceSquared' has a wrong offset!");

// Class DBDBots.BTTask_ClearBBEntry
// 0x0030 (0x00A8 - 0x0078)
class UBTTask_ClearBBEntry final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 BBToResetKey;                                      // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ClearBBEntry">();
	}
	static class UBTTask_ClearBBEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ClearBBEntry>();
	}
};
static_assert(alignof(UBTTask_ClearBBEntry) == 0x000008, "Wrong alignment on UBTTask_ClearBBEntry");
static_assert(sizeof(UBTTask_ClearBBEntry) == 0x0000A8, "Wrong size on UBTTask_ClearBBEntry");
static_assert(offsetof(UBTTask_ClearBBEntry, BBToResetKey) == 0x000078, "Member 'UBTTask_ClearBBEntry::BBToResetKey' has a wrong offset!");

// Class DBDBots.BTTask_CopyBBEntry
// 0x0068 (0x00E0 - 0x0078)
class UBTTask_CopyBBEntry final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 BBFrom;                                            // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBTo;                                              // 0x00A8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          CopyOnlyValidKeyValue;                             // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CopyBBEntry">();
	}
	static class UBTTask_CopyBBEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CopyBBEntry>();
	}
};
static_assert(alignof(UBTTask_CopyBBEntry) == 0x000008, "Wrong alignment on UBTTask_CopyBBEntry");
static_assert(sizeof(UBTTask_CopyBBEntry) == 0x0000E0, "Wrong size on UBTTask_CopyBBEntry");
static_assert(offsetof(UBTTask_CopyBBEntry, BBFrom) == 0x000078, "Member 'UBTTask_CopyBBEntry::BBFrom' has a wrong offset!");
static_assert(offsetof(UBTTask_CopyBBEntry, BBTo) == 0x0000A8, "Member 'UBTTask_CopyBBEntry::BBTo' has a wrong offset!");
static_assert(offsetof(UBTTask_CopyBBEntry, CopyOnlyValidKeyValue) == 0x0000D8, "Member 'UBTTask_CopyBBEntry::CopyOnlyValidKeyValue' has a wrong offset!");

// Class DBDBots.BTTask_ExtMoveDirecltyToward
// 0x0008 (0x00D0 - 0x00C8)
class UBTTask_ExtMoveDirecltyToward final : public UBTTask_MoveDirectlyToward
{
public:
	ECharacterMovementTypes                       MovementMode;                                      // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ExtMoveDirecltyToward">();
	}
	static class UBTTask_ExtMoveDirecltyToward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ExtMoveDirecltyToward>();
	}
};
static_assert(alignof(UBTTask_ExtMoveDirecltyToward) == 0x000008, "Wrong alignment on UBTTask_ExtMoveDirecltyToward");
static_assert(sizeof(UBTTask_ExtMoveDirecltyToward) == 0x0000D0, "Wrong size on UBTTask_ExtMoveDirecltyToward");
static_assert(offsetof(UBTTask_ExtMoveDirecltyToward, MovementMode) == 0x0000C8, "Member 'UBTTask_ExtMoveDirecltyToward::MovementMode' has a wrong offset!");

// Class DBDBots.BTTask_ExtWait
// 0x0020 (0x00A0 - 0x0080)
class UBTTask_ExtWait final : public UBTTask_Wait
{
public:
	struct FAITunableParameter                    WaitTimeInterval;                                  // 0x0080(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    WaitRandomDeviation;                               // 0x0090(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ExtWait">();
	}
	static class UBTTask_ExtWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ExtWait>();
	}
};
static_assert(alignof(UBTTask_ExtWait) == 0x000008, "Wrong alignment on UBTTask_ExtWait");
static_assert(sizeof(UBTTask_ExtWait) == 0x0000A0, "Wrong size on UBTTask_ExtWait");
static_assert(offsetof(UBTTask_ExtWait, WaitTimeInterval) == 0x000080, "Member 'UBTTask_ExtWait::WaitTimeInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_ExtWait, WaitRandomDeviation) == 0x000090, "Member 'UBTTask_ExtWait::WaitRandomDeviation' has a wrong offset!");

// Class DBDBots.BTTask_FleeMoveTo
// 0x0018 (0x0260 - 0x0248)
class UBTTask_FleeMoveTo final : public UBTTask_ExtMoveTo
{
public:
	float                                         InScrambleMovementMinDistance;                     // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutScrambleMovementMinDistance;                    // 0x024C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InScrambleMovementInterval;                        // 0x0250(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopScrambleMovementInterval;                      // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopScrambleMovementRandomDeviation;               // 0x0258(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchWithinLastEvadeLoopPointRadius;              // 0x025C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FleeMoveTo">();
	}
	static class UBTTask_FleeMoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FleeMoveTo>();
	}
};
static_assert(alignof(UBTTask_FleeMoveTo) == 0x000008, "Wrong alignment on UBTTask_FleeMoveTo");
static_assert(sizeof(UBTTask_FleeMoveTo) == 0x000260, "Wrong size on UBTTask_FleeMoveTo");
static_assert(offsetof(UBTTask_FleeMoveTo, InScrambleMovementMinDistance) == 0x000248, "Member 'UBTTask_FleeMoveTo::InScrambleMovementMinDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_FleeMoveTo, OutScrambleMovementMinDistance) == 0x00024C, "Member 'UBTTask_FleeMoveTo::OutScrambleMovementMinDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_FleeMoveTo, InScrambleMovementInterval) == 0x000250, "Member 'UBTTask_FleeMoveTo::InScrambleMovementInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_FleeMoveTo, LoopScrambleMovementInterval) == 0x000254, "Member 'UBTTask_FleeMoveTo::LoopScrambleMovementInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_FleeMoveTo, LoopScrambleMovementRandomDeviation) == 0x000258, "Member 'UBTTask_FleeMoveTo::LoopScrambleMovementRandomDeviation' has a wrong offset!");
static_assert(offsetof(UBTTask_FleeMoveTo, CrouchWithinLastEvadeLoopPointRadius) == 0x00025C, "Member 'UBTTask_FleeMoveTo::CrouchWithinLastEvadeLoopPointRadius' has a wrong offset!");

// Class DBDBots.BTTask_InputPress
// 0x0020 (0x0098 - 0x0078)
class UBTTask_InputPress final : public UBTTaskNode
{
public:
	EPawnInputPressTypes                          Input;                                             // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETaskInputPressModes                          InputMode;                                         // 0x0079(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    InputPressLoopInterval;                            // 0x007C(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          LockInput;                                         // 0x008C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0xB];                                       // 0x008D(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_InputPress">();
	}
	static class UBTTask_InputPress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_InputPress>();
	}
};
static_assert(alignof(UBTTask_InputPress) == 0x000008, "Wrong alignment on UBTTask_InputPress");
static_assert(sizeof(UBTTask_InputPress) == 0x000098, "Wrong size on UBTTask_InputPress");
static_assert(offsetof(UBTTask_InputPress, Input) == 0x000078, "Member 'UBTTask_InputPress::Input' has a wrong offset!");
static_assert(offsetof(UBTTask_InputPress, InputMode) == 0x000079, "Member 'UBTTask_InputPress::InputMode' has a wrong offset!");
static_assert(offsetof(UBTTask_InputPress, InputPressLoopInterval) == 0x00007C, "Member 'UBTTask_InputPress::InputPressLoopInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_InputPress, LockInput) == 0x00008C, "Member 'UBTTask_InputPress::LockInput' has a wrong offset!");

// Class DBDBots.BTTask_Interact
// 0x0040 (0x00B8 - 0x0078)
class UBTTask_Interact final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 BBInteractorObj;                                   // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EPawnInputPressTypes                          Input;                                             // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x3];                                       // 0x00A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OnFailFocusCooldownDuration;                       // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PropagateCooldownOnInteractable;                   // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FailStartInteractTimeLimit;                        // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_Interact">();
	}
	static class UBTTask_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_Interact>();
	}
};
static_assert(alignof(UBTTask_Interact) == 0x000008, "Wrong alignment on UBTTask_Interact");
static_assert(sizeof(UBTTask_Interact) == 0x0000B8, "Wrong size on UBTTask_Interact");
static_assert(offsetof(UBTTask_Interact, BBInteractorObj) == 0x000078, "Member 'UBTTask_Interact::BBInteractorObj' has a wrong offset!");
static_assert(offsetof(UBTTask_Interact, Input) == 0x0000A8, "Member 'UBTTask_Interact::Input' has a wrong offset!");
static_assert(offsetof(UBTTask_Interact, OnFailFocusCooldownDuration) == 0x0000AC, "Member 'UBTTask_Interact::OnFailFocusCooldownDuration' has a wrong offset!");
static_assert(offsetof(UBTTask_Interact, PropagateCooldownOnInteractable) == 0x0000B0, "Member 'UBTTask_Interact::PropagateCooldownOnInteractable' has a wrong offset!");
static_assert(offsetof(UBTTask_Interact, FailStartInteractTimeLimit) == 0x0000B4, "Member 'UBTTask_Interact::FailStartInteractTimeLimit' has a wrong offset!");

// Class DBDBots.BTTask_RotateToBBInteractor
// 0x0040 (0x00F0 - 0x00B0)
class UBTTask_RotateToBBInteractor final : public UBTTask_BlueprintBase
{
public:
	struct FBlackboardKeySelector                 BBInteractorObj;                                   // 0x00B0(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<class FString>                         InteractionIds;                                    // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RotateToBBInteractor">();
	}
	static class UBTTask_RotateToBBInteractor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RotateToBBInteractor>();
	}
};
static_assert(alignof(UBTTask_RotateToBBInteractor) == 0x000008, "Wrong alignment on UBTTask_RotateToBBInteractor");
static_assert(sizeof(UBTTask_RotateToBBInteractor) == 0x0000F0, "Wrong size on UBTTask_RotateToBBInteractor");
static_assert(offsetof(UBTTask_RotateToBBInteractor, BBInteractorObj) == 0x0000B0, "Member 'UBTTask_RotateToBBInteractor::BBInteractorObj' has a wrong offset!");
static_assert(offsetof(UBTTask_RotateToBBInteractor, InteractionIds) == 0x0000E0, "Member 'UBTTask_RotateToBBInteractor::InteractionIds' has a wrong offset!");

// Class DBDBots.BTTask_RunSkills
// 0x0010 (0x0088 - 0x0078)
class UBTTask_RunSkills final : public UBTTaskNode
{
public:
	struct FGameplayTag                           Context;                                           // 0x0078(0x000C)(Edit, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RunSkills">();
	}
	static class UBTTask_RunSkills* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RunSkills>();
	}
};
static_assert(alignof(UBTTask_RunSkills) == 0x000008, "Wrong alignment on UBTTask_RunSkills");
static_assert(sizeof(UBTTask_RunSkills) == 0x000088, "Wrong size on UBTTask_RunSkills");
static_assert(offsetof(UBTTask_RunSkills, Context) == 0x000078, "Member 'UBTTask_RunSkills::Context' has a wrong offset!");

// Class DBDBots.BTTask_SetBBEntry
// 0x0040 (0x00B8 - 0x0078)
class UBTTask_SetBBEntry final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 BBToSetKey;                                        // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class FString                                 ToSetValue;                                        // 0x00A8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetBBEntry">();
	}
	static class UBTTask_SetBBEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetBBEntry>();
	}
};
static_assert(alignof(UBTTask_SetBBEntry) == 0x000008, "Wrong alignment on UBTTask_SetBBEntry");
static_assert(sizeof(UBTTask_SetBBEntry) == 0x0000B8, "Wrong size on UBTTask_SetBBEntry");
static_assert(offsetof(UBTTask_SetBBEntry, BBToSetKey) == 0x000078, "Member 'UBTTask_SetBBEntry::BBToSetKey' has a wrong offset!");
static_assert(offsetof(UBTTask_SetBBEntry, ToSetValue) == 0x0000A8, "Member 'UBTTask_SetBBEntry::ToSetValue' has a wrong offset!");

// Class DBDBots.BTTask_SetBBEntryTime
// 0x0030 (0x00A8 - 0x0078)
class UBTTask_SetBBEntryTime final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 BBToSetKey;                                        // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetBBEntryTime">();
	}
	static class UBTTask_SetBBEntryTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetBBEntryTime>();
	}
};
static_assert(alignof(UBTTask_SetBBEntryTime) == 0x000008, "Wrong alignment on UBTTask_SetBBEntryTime");
static_assert(sizeof(UBTTask_SetBBEntryTime) == 0x0000A8, "Wrong size on UBTTask_SetBBEntryTime");
static_assert(offsetof(UBTTask_SetBBEntryTime, BBToSetKey) == 0x000078, "Member 'UBTTask_SetBBEntryTime::BBToSetKey' has a wrong offset!");

// Class DBDBots.BTTask_SetFleeLoopCooldown
// 0x0008 (0x0080 - 0x0078)
class UBTTask_SetFleeLoopCooldown final : public UBTTaskNode
{
public:
	float                                         Duration;                                          // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetFleeLoopCooldown">();
	}
	static class UBTTask_SetFleeLoopCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetFleeLoopCooldown>();
	}
};
static_assert(alignof(UBTTask_SetFleeLoopCooldown) == 0x000008, "Wrong alignment on UBTTask_SetFleeLoopCooldown");
static_assert(sizeof(UBTTask_SetFleeLoopCooldown) == 0x000080, "Wrong size on UBTTask_SetFleeLoopCooldown");
static_assert(offsetof(UBTTask_SetFleeLoopCooldown, Duration) == 0x000078, "Member 'UBTTask_SetFleeLoopCooldown::Duration' has a wrong offset!");

// Class DBDBots.BTTask_SetIsChased
// 0x0008 (0x0080 - 0x0078)
class UBTTask_SetIsChased final : public UBTTaskNode
{
public:
	bool                                          ToSetValue;                                        // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetIsChased">();
	}
	static class UBTTask_SetIsChased* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetIsChased>();
	}
};
static_assert(alignof(UBTTask_SetIsChased) == 0x000008, "Wrong alignment on UBTTask_SetIsChased");
static_assert(sizeof(UBTTask_SetIsChased) == 0x000080, "Wrong size on UBTTask_SetIsChased");
static_assert(offsetof(UBTTask_SetIsChased, ToSetValue) == 0x000078, "Member 'UBTTask_SetIsChased::ToSetValue' has a wrong offset!");

// Class DBDBots.BTTask_SetMovementMode
// 0x0008 (0x0080 - 0x0078)
class UBTTask_SetMovementMode final : public UBTTaskNode
{
public:
	ECharacterMovementTypes                       MovementMode;                                      // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetMovementMode">();
	}
	static class UBTTask_SetMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetMovementMode>();
	}
};
static_assert(alignof(UBTTask_SetMovementMode) == 0x000008, "Wrong alignment on UBTTask_SetMovementMode");
static_assert(sizeof(UBTTask_SetMovementMode) == 0x000080, "Wrong size on UBTTask_SetMovementMode");
static_assert(offsetof(UBTTask_SetMovementMode, MovementMode) == 0x000078, "Member 'UBTTask_SetMovementMode::MovementMode' has a wrong offset!");

// Class DBDBots.BTTask_SetRandomNavPoint
// 0x0078 (0x00F0 - 0x0078)
class UBTTask_SetRandomNavPoint final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 BBFromLocation;                                    // 0x0078(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 BBToLocation;                                      // 0x00A8(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         MinAroundRadius;                                   // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAroundRadius;                                   // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNbAttempts;                                     // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSafeNbAttempts;                                 // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetRandomNavPoint">();
	}
	static class UBTTask_SetRandomNavPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetRandomNavPoint>();
	}
};
static_assert(alignof(UBTTask_SetRandomNavPoint) == 0x000008, "Wrong alignment on UBTTask_SetRandomNavPoint");
static_assert(sizeof(UBTTask_SetRandomNavPoint) == 0x0000F0, "Wrong size on UBTTask_SetRandomNavPoint");
static_assert(offsetof(UBTTask_SetRandomNavPoint, BBFromLocation) == 0x000078, "Member 'UBTTask_SetRandomNavPoint::BBFromLocation' has a wrong offset!");
static_assert(offsetof(UBTTask_SetRandomNavPoint, BBToLocation) == 0x0000A8, "Member 'UBTTask_SetRandomNavPoint::BBToLocation' has a wrong offset!");
static_assert(offsetof(UBTTask_SetRandomNavPoint, MinAroundRadius) == 0x0000D8, "Member 'UBTTask_SetRandomNavPoint::MinAroundRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_SetRandomNavPoint, MaxAroundRadius) == 0x0000DC, "Member 'UBTTask_SetRandomNavPoint::MaxAroundRadius' has a wrong offset!");
static_assert(offsetof(UBTTask_SetRandomNavPoint, MaxNbAttempts) == 0x0000E0, "Member 'UBTTask_SetRandomNavPoint::MaxNbAttempts' has a wrong offset!");
static_assert(offsetof(UBTTask_SetRandomNavPoint, MaxSafeNbAttempts) == 0x0000E4, "Member 'UBTTask_SetRandomNavPoint::MaxSafeNbAttempts' has a wrong offset!");
static_assert(offsetof(UBTTask_SetRandomNavPoint, FilterClass) == 0x0000E8, "Member 'UBTTask_SetRandomNavPoint::FilterClass' has a wrong offset!");

// Class DBDBots.DBDAIBTController
// 0x0138 (0x0720 - 0x05E8)
class ADBDAIBTController : public ADBDAIController
{
public:
	class UBehaviorTree*                          BehaviorTree;                                      // 0x05E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAISkill*>                       BaseSkills;                                        // 0x05F0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UAISkill*>                       RoleSkills;                                        // 0x0600(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FAISkillPerk>                   PerkSkills;                                        // 0x0610(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ListenToAttackEvents;                              // 0x0620(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_621[0x7];                                      // 0x0621(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDAIPerceptionComponent*              _dbdPerception;                                    // 0x0628(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDBlackboardComponent*                _dbdBlackboard;                                    // 0x0630(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDPathFollowingComponent*             _dbdPathFollowing;                                 // 0x0638(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDBehaviorTreeComponent*              _dbdBehaviorTree;                                  // 0x0640(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDNavMeshExplorerComponent*           _navMeshExplorer;                                  // 0x0648(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAIStateComponent*                   _aiState;                                          // 0x0650(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAIGoalComponent*                    _aiGoal;                                           // 0x0658(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_660[0x8];                                      // 0x0660(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, class UBehaviorTree*> _setDynamicSubtrees;                             // 0x0668(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UAISkill*>                       _aiSkills;                                         // 0x06B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C8[0x58];                                     // 0x06C8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_FinishedPlaying();
	void OnPawnBump(class AActor* selfActor, class AActor* otherActor, const struct FVector& normalImpulse, const struct FHitResult& hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIBTController">();
	}
	static class ADBDAIBTController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDAIBTController>();
	}
};
static_assert(alignof(ADBDAIBTController) == 0x000008, "Wrong alignment on ADBDAIBTController");
static_assert(sizeof(ADBDAIBTController) == 0x000720, "Wrong size on ADBDAIBTController");
static_assert(offsetof(ADBDAIBTController, BehaviorTree) == 0x0005E8, "Member 'ADBDAIBTController::BehaviorTree' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, BaseSkills) == 0x0005F0, "Member 'ADBDAIBTController::BaseSkills' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, RoleSkills) == 0x000600, "Member 'ADBDAIBTController::RoleSkills' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, PerkSkills) == 0x000610, "Member 'ADBDAIBTController::PerkSkills' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, ListenToAttackEvents) == 0x000620, "Member 'ADBDAIBTController::ListenToAttackEvents' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _dbdPerception) == 0x000628, "Member 'ADBDAIBTController::_dbdPerception' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _dbdBlackboard) == 0x000630, "Member 'ADBDAIBTController::_dbdBlackboard' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _dbdPathFollowing) == 0x000638, "Member 'ADBDAIBTController::_dbdPathFollowing' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _dbdBehaviorTree) == 0x000640, "Member 'ADBDAIBTController::_dbdBehaviorTree' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _navMeshExplorer) == 0x000648, "Member 'ADBDAIBTController::_navMeshExplorer' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _aiState) == 0x000650, "Member 'ADBDAIBTController::_aiState' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _aiGoal) == 0x000658, "Member 'ADBDAIBTController::_aiGoal' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _setDynamicSubtrees) == 0x000668, "Member 'ADBDAIBTController::_setDynamicSubtrees' has a wrong offset!");
static_assert(offsetof(ADBDAIBTController, _aiSkills) == 0x0006B8, "Member 'ADBDAIBTController::_aiSkills' has a wrong offset!");

// Class DBDBots.DBDAIGoalComponent
// 0x00A8 (0x0160 - 0x00B8)
class UDBDAIGoalComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UObject*, struct FAIGoal>          _activeGoals;                                      // 0x00C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class UObject*, struct FAIGoalWeightContainer> _foundWeightedGoals;                         // 0x0110(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIGoalComponent">();
	}
	static class UDBDAIGoalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAIGoalComponent>();
	}
};
static_assert(alignof(UDBDAIGoalComponent) == 0x000008, "Wrong alignment on UDBDAIGoalComponent");
static_assert(sizeof(UDBDAIGoalComponent) == 0x000160, "Wrong size on UDBDAIGoalComponent");
static_assert(offsetof(UDBDAIGoalComponent, _activeGoals) == 0x0000C0, "Member 'UDBDAIGoalComponent::_activeGoals' has a wrong offset!");
static_assert(offsetof(UDBDAIGoalComponent, _foundWeightedGoals) == 0x000110, "Member 'UDBDAIGoalComponent::_foundWeightedGoals' has a wrong offset!");

// Class DBDBots.DBDAIPerceptionComponent
// 0x01E8 (0x0380 - 0x0198)
class UDBDAIPerceptionComponent final : public UAIPerceptionComponent
{
public:
	uint8                                         Pad_198[0x20];                                     // 0x0198(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EAttackType>                           RangedAttackTypes;                                 // 0x01B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EKillerAbilities>                      RangedKillerAbilities;                             // 0x01C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class UClass*, class UObject*>           _objOverridingSenses;                              // 0x01D8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UAISenseConfig*>                 _originalSenseConfigs;                             // 0x0228(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FAIDetectedStimulus>            _detectedHostileStimuli;                           // 0x0238(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FAIDetectedStimulus                    _bestDetectedHostileStimulus;                      // 0x0248(0x005C)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FAIDetectedStimulus                    _lastBestDetectedHostileStimulusInMemory;          // 0x02A4(0x005C)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x60];                                     // 0x0300(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAITunableParameter                    _activePhaseWalkingNoiseMaxRange;                  // 0x0360(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         ThreatDividerForNonControlledActor;                // 0x0370(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HighThreatDistanceForNonControlledActor;           // 0x0374(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TerrorDistanceMultiplierForNonControlledActor;     // 0x0378(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIPerceptionComponent">();
	}
	static class UDBDAIPerceptionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAIPerceptionComponent>();
	}
};
static_assert(alignof(UDBDAIPerceptionComponent) == 0x000008, "Wrong alignment on UDBDAIPerceptionComponent");
static_assert(sizeof(UDBDAIPerceptionComponent) == 0x000380, "Wrong size on UDBDAIPerceptionComponent");
static_assert(offsetof(UDBDAIPerceptionComponent, RangedAttackTypes) == 0x0001B8, "Member 'UDBDAIPerceptionComponent::RangedAttackTypes' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, RangedKillerAbilities) == 0x0001C8, "Member 'UDBDAIPerceptionComponent::RangedKillerAbilities' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, _objOverridingSenses) == 0x0001D8, "Member 'UDBDAIPerceptionComponent::_objOverridingSenses' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, _originalSenseConfigs) == 0x000228, "Member 'UDBDAIPerceptionComponent::_originalSenseConfigs' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, _detectedHostileStimuli) == 0x000238, "Member 'UDBDAIPerceptionComponent::_detectedHostileStimuli' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, _bestDetectedHostileStimulus) == 0x000248, "Member 'UDBDAIPerceptionComponent::_bestDetectedHostileStimulus' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, _lastBestDetectedHostileStimulusInMemory) == 0x0002A4, "Member 'UDBDAIPerceptionComponent::_lastBestDetectedHostileStimulusInMemory' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, _activePhaseWalkingNoiseMaxRange) == 0x000360, "Member 'UDBDAIPerceptionComponent::_activePhaseWalkingNoiseMaxRange' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, ThreatDividerForNonControlledActor) == 0x000370, "Member 'UDBDAIPerceptionComponent::ThreatDividerForNonControlledActor' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, HighThreatDistanceForNonControlledActor) == 0x000374, "Member 'UDBDAIPerceptionComponent::HighThreatDistanceForNonControlledActor' has a wrong offset!");
static_assert(offsetof(UDBDAIPerceptionComponent, TerrorDistanceMultiplierForNonControlledActor) == 0x000378, "Member 'UDBDAIPerceptionComponent::TerrorDistanceMultiplierForNonControlledActor' has a wrong offset!");

// Class DBDBots.DBDBehaviorTreeComponent
// 0x0068 (0x0308 - 0x02A0)
class UDBDBehaviorTreeComponent final : public UBehaviorTreeComponent
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UClass*, struct FRelevantNodeMemory> _lastRelevantNodeMemories;                       // 0x02A8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        _createdObjects;                                   // 0x02F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBehaviorTreeComponent">();
	}
	static class UDBDBehaviorTreeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBehaviorTreeComponent>();
	}
};
static_assert(alignof(UDBDBehaviorTreeComponent) == 0x000008, "Wrong alignment on UDBDBehaviorTreeComponent");
static_assert(sizeof(UDBDBehaviorTreeComponent) == 0x000308, "Wrong size on UDBDBehaviorTreeComponent");
static_assert(offsetof(UDBDBehaviorTreeComponent, _lastRelevantNodeMemories) == 0x0002A8, "Member 'UDBDBehaviorTreeComponent::_lastRelevantNodeMemories' has a wrong offset!");
static_assert(offsetof(UDBDBehaviorTreeComponent, _createdObjects) == 0x0002F8, "Member 'UDBDBehaviorTreeComponent::_createdObjects' has a wrong offset!");

// Class DBDBots.DBDBlackboardComponent
// 0x02E0 (0x04A0 - 0x01C0)
class UDBDBlackboardComponent final : public UBlackboardComponent
{
public:
	uint8                                         Pad_1C0[0x10];                                     // 0x01C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UObject*, struct FMindFocusObjectEntry> _mindFocusEntries;                            // 0x01D0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FVector>     _pinLocations;                                     // 0x0220(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, class UObject*>     _pinObjects;                                       // 0x0270(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class UObject*, float>                   _lostMindFocusEntries;                             // 0x02C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, struct FWeightedWishedObjectMapContainer> _objectWishListMap;          // 0x0310(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class UObject*>                          _discoveredObjects;                                // 0x0360(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class UObject*>                          _intentionValidators;                              // 0x03B0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FDistanceToTargetData> _killerToTargetDistances;                      // 0x0400(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class APallet*>                          _convincingDreamPallets;                           // 0x0450(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBlackboardComponent">();
	}
	static class UDBDBlackboardComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBlackboardComponent>();
	}
};
static_assert(alignof(UDBDBlackboardComponent) == 0x000008, "Wrong alignment on UDBDBlackboardComponent");
static_assert(sizeof(UDBDBlackboardComponent) == 0x0004A0, "Wrong size on UDBDBlackboardComponent");
static_assert(offsetof(UDBDBlackboardComponent, _mindFocusEntries) == 0x0001D0, "Member 'UDBDBlackboardComponent::_mindFocusEntries' has a wrong offset!");
static_assert(offsetof(UDBDBlackboardComponent, _pinLocations) == 0x000220, "Member 'UDBDBlackboardComponent::_pinLocations' has a wrong offset!");
static_assert(offsetof(UDBDBlackboardComponent, _pinObjects) == 0x000270, "Member 'UDBDBlackboardComponent::_pinObjects' has a wrong offset!");
static_assert(offsetof(UDBDBlackboardComponent, _lostMindFocusEntries) == 0x0002C0, "Member 'UDBDBlackboardComponent::_lostMindFocusEntries' has a wrong offset!");
static_assert(offsetof(UDBDBlackboardComponent, _objectWishListMap) == 0x000310, "Member 'UDBDBlackboardComponent::_objectWishListMap' has a wrong offset!");
static_assert(offsetof(UDBDBlackboardComponent, _discoveredObjects) == 0x000360, "Member 'UDBDBlackboardComponent::_discoveredObjects' has a wrong offset!");
static_assert(offsetof(UDBDBlackboardComponent, _intentionValidators) == 0x0003B0, "Member 'UDBDBlackboardComponent::_intentionValidators' has a wrong offset!");
static_assert(offsetof(UDBDBlackboardComponent, _killerToTargetDistances) == 0x000400, "Member 'UDBDBlackboardComponent::_killerToTargetDistances' has a wrong offset!");
static_assert(offsetof(UDBDBlackboardComponent, _convincingDreamPallets) == 0x000450, "Member 'UDBDBlackboardComponent::_convincingDreamPallets' has a wrong offset!");

// Class DBDBots.DBDNavLinkCustomComponent
// 0x0070 (0x0208 - 0x0198)
class UDBDNavLinkCustomComponent final : public UNavLinkCustomComponent
{
public:
	struct FVector                                BaseLinkRelativeStart;                             // 0x0198(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BaseLinkRelativeEnd;                               // 0x01A4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavLinkDirection                             BaseLinkDirection;                                 // 0x01B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x3];                                      // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoSnapSmartLinkPointsUpHeight;                   // 0x01B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSnapSmartLinkPointsDownHeight;                 // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             AutoSnapCollisionChannel;                          // 0x01BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BD[0x3];                                      // 0x01BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoSmartLinkDirectionMaxHeight;                   // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableSmartLinkOnPathObstruction;                 // 0x01C4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C5[0x3];                                      // 0x01C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathObstructionTestDistance;                       // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathObstructionTestShapeRadius;                    // 0x01CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathObstructionTestHeightOffset;                   // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             PathObstructionCollisionChannel;                   // 0x01D4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableOtherSmartLinkInProximityOnEnable;          // 0x01D5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableOtherSmartLinkInProximityOnDisable;          // 0x01D6(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D7[0x1];                                      // 0x01D7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OtherSmartLinkInProximitySearchDistance;           // 0x01D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowDebugInfo;                                     // 0x01DC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DD[0x1B];                                     // 0x01DD(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANavLinkProxy*>                  _navLinkProxyInProximity;                          // 0x01F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDNavLinkCustomComponent">();
	}
	static class UDBDNavLinkCustomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDNavLinkCustomComponent>();
	}
};
static_assert(alignof(UDBDNavLinkCustomComponent) == 0x000008, "Wrong alignment on UDBDNavLinkCustomComponent");
static_assert(sizeof(UDBDNavLinkCustomComponent) == 0x000208, "Wrong size on UDBDNavLinkCustomComponent");
static_assert(offsetof(UDBDNavLinkCustomComponent, BaseLinkRelativeStart) == 0x000198, "Member 'UDBDNavLinkCustomComponent::BaseLinkRelativeStart' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, BaseLinkRelativeEnd) == 0x0001A4, "Member 'UDBDNavLinkCustomComponent::BaseLinkRelativeEnd' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, BaseLinkDirection) == 0x0001B0, "Member 'UDBDNavLinkCustomComponent::BaseLinkDirection' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, AutoSnapSmartLinkPointsUpHeight) == 0x0001B4, "Member 'UDBDNavLinkCustomComponent::AutoSnapSmartLinkPointsUpHeight' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, AutoSnapSmartLinkPointsDownHeight) == 0x0001B8, "Member 'UDBDNavLinkCustomComponent::AutoSnapSmartLinkPointsDownHeight' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, AutoSnapCollisionChannel) == 0x0001BC, "Member 'UDBDNavLinkCustomComponent::AutoSnapCollisionChannel' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, AutoSmartLinkDirectionMaxHeight) == 0x0001C0, "Member 'UDBDNavLinkCustomComponent::AutoSmartLinkDirectionMaxHeight' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, DisableSmartLinkOnPathObstruction) == 0x0001C4, "Member 'UDBDNavLinkCustomComponent::DisableSmartLinkOnPathObstruction' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, PathObstructionTestDistance) == 0x0001C8, "Member 'UDBDNavLinkCustomComponent::PathObstructionTestDistance' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, PathObstructionTestShapeRadius) == 0x0001CC, "Member 'UDBDNavLinkCustomComponent::PathObstructionTestShapeRadius' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, PathObstructionTestHeightOffset) == 0x0001D0, "Member 'UDBDNavLinkCustomComponent::PathObstructionTestHeightOffset' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, PathObstructionCollisionChannel) == 0x0001D4, "Member 'UDBDNavLinkCustomComponent::PathObstructionCollisionChannel' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, DisableOtherSmartLinkInProximityOnEnable) == 0x0001D5, "Member 'UDBDNavLinkCustomComponent::DisableOtherSmartLinkInProximityOnEnable' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, EnableOtherSmartLinkInProximityOnDisable) == 0x0001D6, "Member 'UDBDNavLinkCustomComponent::EnableOtherSmartLinkInProximityOnDisable' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, OtherSmartLinkInProximitySearchDistance) == 0x0001D8, "Member 'UDBDNavLinkCustomComponent::OtherSmartLinkInProximitySearchDistance' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, ShowDebugInfo) == 0x0001DC, "Member 'UDBDNavLinkCustomComponent::ShowDebugInfo' has a wrong offset!");
static_assert(offsetof(UDBDNavLinkCustomComponent, _navLinkProxyInProximity) == 0x0001F8, "Member 'UDBDNavLinkCustomComponent::_navLinkProxyInProximity' has a wrong offset!");

// Class DBDBots.DBDPathFollowingComponent
// 0x0230 (0x0488 - 0x0258)
class UDBDPathFollowingComponent final : public UPathFollowingComponent
{
public:
	uint8                                         Pad_258[0x10];                                     // 0x0258(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnblockPathDeviationRadius;                        // 0x0268(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnblockPathTimeLimit;                              // 0x026C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnblockPathReachDistance;                          // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x124];                                    // 0x0274(0x0124)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ANavLinkProxy*>                    _onNavLinkProxies;                                 // 0x0398(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0xA0];                                     // 0x03E8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPathFollowingComponent">();
	}
	static class UDBDPathFollowingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPathFollowingComponent>();
	}
};
static_assert(alignof(UDBDPathFollowingComponent) == 0x000008, "Wrong alignment on UDBDPathFollowingComponent");
static_assert(sizeof(UDBDPathFollowingComponent) == 0x000488, "Wrong size on UDBDPathFollowingComponent");
static_assert(offsetof(UDBDPathFollowingComponent, UnblockPathDeviationRadius) == 0x000268, "Member 'UDBDPathFollowingComponent::UnblockPathDeviationRadius' has a wrong offset!");
static_assert(offsetof(UDBDPathFollowingComponent, UnblockPathTimeLimit) == 0x00026C, "Member 'UDBDPathFollowingComponent::UnblockPathTimeLimit' has a wrong offset!");
static_assert(offsetof(UDBDPathFollowingComponent, UnblockPathReachDistance) == 0x000270, "Member 'UDBDPathFollowingComponent::UnblockPathReachDistance' has a wrong offset!");
static_assert(offsetof(UDBDPathFollowingComponent, _onNavLinkProxies) == 0x000398, "Member 'UDBDPathFollowingComponent::_onNavLinkProxies' has a wrong offset!");

// Class DBDBots.EnvQueryContext_CenterOfMap
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_CenterOfMap final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_CenterOfMap">();
	}
	static class UEnvQueryContext_CenterOfMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_CenterOfMap>();
	}
};
static_assert(alignof(UEnvQueryContext_CenterOfMap) == 0x000008, "Wrong alignment on UEnvQueryContext_CenterOfMap");
static_assert(sizeof(UEnvQueryContext_CenterOfMap) == 0x000030, "Wrong size on UEnvQueryContext_CenterOfMap");

// Class DBDBots.EnvQueryContext_EscapeDoors
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_EscapeDoors final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_EscapeDoors">();
	}
	static class UEnvQueryContext_EscapeDoors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_EscapeDoors>();
	}
};
static_assert(alignof(UEnvQueryContext_EscapeDoors) == 0x000008, "Wrong alignment on UEnvQueryContext_EscapeDoors");
static_assert(sizeof(UEnvQueryContext_EscapeDoors) == 0x000030, "Wrong size on UEnvQueryContext_EscapeDoors");

// Class DBDBots.EnvQueryContext_Generators
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_Generators final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_Generators">();
	}
	static class UEnvQueryContext_Generators* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_Generators>();
	}
};
static_assert(alignof(UEnvQueryContext_Generators) == 0x000008, "Wrong alignment on UEnvQueryContext_Generators");
static_assert(sizeof(UEnvQueryContext_Generators) == 0x000030, "Wrong size on UEnvQueryContext_Generators");

// Class DBDBots.EnvQueryContext_Hooks
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_Hooks final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_Hooks">();
	}
	static class UEnvQueryContext_Hooks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_Hooks>();
	}
};
static_assert(alignof(UEnvQueryContext_Hooks) == 0x000008, "Wrong alignment on UEnvQueryContext_Hooks");
static_assert(sizeof(UEnvQueryContext_Hooks) == 0x000030, "Wrong size on UEnvQueryContext_Hooks");

// Class DBDBots.EnvQueryContext_Lockers
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_Lockers final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_Lockers">();
	}
	static class UEnvQueryContext_Lockers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_Lockers>();
	}
};
static_assert(alignof(UEnvQueryContext_Lockers) == 0x000008, "Wrong alignment on UEnvQueryContext_Lockers");
static_assert(sizeof(UEnvQueryContext_Lockers) == 0x000030, "Wrong size on UEnvQueryContext_Lockers");

// Class DBDBots.EnvQueryContext_PinLocation
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_PinLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_PinLocation">();
	}
	static class UEnvQueryContext_PinLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_PinLocation>();
	}
};
static_assert(alignof(UEnvQueryContext_PinLocation) == 0x000008, "Wrong alignment on UEnvQueryContext_PinLocation");
static_assert(sizeof(UEnvQueryContext_PinLocation) == 0x000030, "Wrong size on UEnvQueryContext_PinLocation");

// Class DBDBots.EnvQueryTest_IsInDangerObjectRange
// 0x0048 (0x0280 - 0x0238)
class UEnvQueryTest_IsInDangerObjectRange final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           QuerierContext;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               Invert;                                            // 0x0240(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_IsInDangerObjectRange">();
	}
	static class UEnvQueryTest_IsInDangerObjectRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_IsInDangerObjectRange>();
	}
};
static_assert(alignof(UEnvQueryTest_IsInDangerObjectRange) == 0x000008, "Wrong alignment on UEnvQueryTest_IsInDangerObjectRange");
static_assert(sizeof(UEnvQueryTest_IsInDangerObjectRange) == 0x000280, "Wrong size on UEnvQueryTest_IsInDangerObjectRange");
static_assert(offsetof(UEnvQueryTest_IsInDangerObjectRange, QuerierContext) == 0x000238, "Member 'UEnvQueryTest_IsInDangerObjectRange::QuerierContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_IsInDangerObjectRange, Invert) == 0x000240, "Member 'UEnvQueryTest_IsInDangerObjectRange::Invert' has a wrong offset!");

// Class DBDBots.EnvQueryTest_LineOfSight
// 0x00E8 (0x0320 - 0x0238)
class UEnvQueryTest_LineOfSight final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           QuerierContext;                                    // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           ToContext;                                         // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ItemHeightOffset;                                  // 0x0248(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               Invert;                                            // 0x0288(0x0040)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x58];                                     // 0x02C8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_LineOfSight">();
	}
	static class UEnvQueryTest_LineOfSight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_LineOfSight>();
	}
};
static_assert(alignof(UEnvQueryTest_LineOfSight) == 0x000008, "Wrong alignment on UEnvQueryTest_LineOfSight");
static_assert(sizeof(UEnvQueryTest_LineOfSight) == 0x000320, "Wrong size on UEnvQueryTest_LineOfSight");
static_assert(offsetof(UEnvQueryTest_LineOfSight, QuerierContext) == 0x000238, "Member 'UEnvQueryTest_LineOfSight::QuerierContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_LineOfSight, ToContext) == 0x000240, "Member 'UEnvQueryTest_LineOfSight::ToContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_LineOfSight, ItemHeightOffset) == 0x000248, "Member 'UEnvQueryTest_LineOfSight::ItemHeightOffset' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_LineOfSight, Invert) == 0x000288, "Member 'UEnvQueryTest_LineOfSight::Invert' has a wrong offset!");

// Class DBDBots.NavArea_Blink
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Blink final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Blink">();
	}
	static class UNavArea_Blink* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Blink>();
	}
};
static_assert(alignof(UNavArea_Blink) == 0x000008, "Wrong alignment on UNavArea_Blink");
static_assert(sizeof(UNavArea_Blink) == 0x000050, "Wrong size on UNavArea_Blink");

// Class DBDBots.NavArea_Breakable
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Breakable final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Breakable">();
	}
	static class UNavArea_Breakable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Breakable>();
	}
};
static_assert(alignof(UNavArea_Breakable) == 0x000008, "Wrong alignment on UNavArea_Breakable");
static_assert(sizeof(UNavArea_Breakable) == 0x000050, "Wrong size on UNavArea_Breakable");

// Class DBDBots.NavArea_Vault
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Vault final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Vault">();
	}
	static class UNavArea_Vault* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Vault>();
	}
};
static_assert(alignof(UNavArea_Vault) == 0x000008, "Wrong alignment on UNavArea_Vault");
static_assert(sizeof(UNavArea_Vault) == 0x000050, "Wrong size on UNavArea_Vault");

// Class DBDBots.NavigationQueryFilter_CamperStealth
// 0x0000 (0x0088 - 0x0088)
class UNavigationQueryFilter_CamperStealth final : public UNavigationQueryFilter_Camper
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_CamperStealth">();
	}
	static class UNavigationQueryFilter_CamperStealth* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_CamperStealth>();
	}
};
static_assert(alignof(UNavigationQueryFilter_CamperStealth) == 0x000008, "Wrong alignment on UNavigationQueryFilter_CamperStealth");
static_assert(sizeof(UNavigationQueryFilter_CamperStealth) == 0x000088, "Wrong size on UNavigationQueryFilter_CamperStealth");

// Class DBDBots.NavigationQueryFilter_Slasher_Limited
// 0x0000 (0x0070 - 0x0070)
class UNavigationQueryFilter_Slasher_Limited final : public UNavigationQueryFilter_Player
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_Slasher_Limited">();
	}
	static class UNavigationQueryFilter_Slasher_Limited* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_Slasher_Limited>();
	}
};
static_assert(alignof(UNavigationQueryFilter_Slasher_Limited) == 0x000008, "Wrong alignment on UNavigationQueryFilter_Slasher_Limited");
static_assert(sizeof(UNavigationQueryFilter_Slasher_Limited) == 0x000070, "Wrong size on UNavigationQueryFilter_Slasher_Limited");

// Class DBDBots.NavLinkProxy_Base
// 0x0070 (0x02F0 - 0x0280)
class ANavLinkProxy_Base : public ANavLinkProxy
{
public:
	float                                         WaitLinkOffset;                                    // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveOnEndPointTimeLimit;                           // 0x0284(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbMaxLinkUsers;                                    // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayer*, struct FMoveLinkPlayerInfo> _players;                                    // 0x0290(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class ADBDPlayer*>                     _linkUsedByPlayers;                                // 0x02E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void AutoAdjustSmartLinkPoints();
	void OnSmartLinkReachedCallback(class AActor* MovingActor, const struct FVector& DestinationPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkProxy_Base">();
	}
	static class ANavLinkProxy_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavLinkProxy_Base>();
	}
};
static_assert(alignof(ANavLinkProxy_Base) == 0x000008, "Wrong alignment on ANavLinkProxy_Base");
static_assert(sizeof(ANavLinkProxy_Base) == 0x0002F0, "Wrong size on ANavLinkProxy_Base");
static_assert(offsetof(ANavLinkProxy_Base, WaitLinkOffset) == 0x000280, "Member 'ANavLinkProxy_Base::WaitLinkOffset' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Base, MoveOnEndPointTimeLimit) == 0x000284, "Member 'ANavLinkProxy_Base::MoveOnEndPointTimeLimit' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Base, NbMaxLinkUsers) == 0x000288, "Member 'ANavLinkProxy_Base::NbMaxLinkUsers' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Base, _players) == 0x000290, "Member 'ANavLinkProxy_Base::_players' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Base, _linkUsedByPlayers) == 0x0002E0, "Member 'ANavLinkProxy_Base::_linkUsedByPlayers' has a wrong offset!");

// Class DBDBots.NavLinkProxy_DirectMove
// 0x0068 (0x0358 - 0x02F0)
class ANavLinkProxy_DirectMove final : public ANavLinkProxy_Base
{
public:
	TArray<struct FVector>                        CustomPathPoints;                                  // 0x02F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         MoveToPathPointTimeLimit;                          // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayer*, class UNavMovePath*>  _playersOnPath;                                    // 0x0308(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnDisplayDebugInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkProxy_DirectMove">();
	}
	static class ANavLinkProxy_DirectMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavLinkProxy_DirectMove>();
	}
};
static_assert(alignof(ANavLinkProxy_DirectMove) == 0x000008, "Wrong alignment on ANavLinkProxy_DirectMove");
static_assert(sizeof(ANavLinkProxy_DirectMove) == 0x000358, "Wrong size on ANavLinkProxy_DirectMove");
static_assert(offsetof(ANavLinkProxy_DirectMove, CustomPathPoints) == 0x0002F0, "Member 'ANavLinkProxy_DirectMove::CustomPathPoints' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_DirectMove, MoveToPathPointTimeLimit) == 0x000300, "Member 'ANavLinkProxy_DirectMove::MoveToPathPointTimeLimit' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_DirectMove, _playersOnPath) == 0x000308, "Member 'ANavLinkProxy_DirectMove::_playersOnPath' has a wrong offset!");

// Class DBDBots.NavLinkProxy_Interaction
// 0x00A8 (0x0398 - 0x02F0)
class ANavLinkProxy_Interaction final : public ANavLinkProxy_Base
{
public:
	TMap<EPlayerRole, struct FNavLinkInteractPlayerSetup> PlayerSetups;                              // 0x02F0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         InteractionStartTimeLimit;                         // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayer*, float>                _playersInteractionInputAtTime;                    // 0x0348(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavLinkProxy_Interaction">();
	}
	static class ANavLinkProxy_Interaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANavLinkProxy_Interaction>();
	}
};
static_assert(alignof(ANavLinkProxy_Interaction) == 0x000008, "Wrong alignment on ANavLinkProxy_Interaction");
static_assert(sizeof(ANavLinkProxy_Interaction) == 0x000398, "Wrong size on ANavLinkProxy_Interaction");
static_assert(offsetof(ANavLinkProxy_Interaction, PlayerSetups) == 0x0002F0, "Member 'ANavLinkProxy_Interaction::PlayerSetups' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Interaction, InteractionStartTimeLimit) == 0x000340, "Member 'ANavLinkProxy_Interaction::InteractionStartTimeLimit' has a wrong offset!");
static_assert(offsetof(ANavLinkProxy_Interaction, _playersInteractionInputAtTime) == 0x000348, "Member 'ANavLinkProxy_Interaction::_playersInteractionInputAtTime' has a wrong offset!");

// Class DBDBots.NavMovePath
// 0x0030 (0x0060 - 0x0030)
class UNavMovePath final : public UObject
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavMovePath">();
	}
	static class UNavMovePath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavMovePath>();
	}
};
static_assert(alignof(UNavMovePath) == 0x000008, "Wrong alignment on UNavMovePath");
static_assert(sizeof(UNavMovePath) == 0x000060, "Wrong size on UNavMovePath");

// Class DBDBots.PathBuilder
// 0x0020 (0x0050 - 0x0030)
class UPathBuilder : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathReachedPointRadius;                            // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAITerrorLevel                                ToleratedTerrorPressure;                           // 0x003C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverridePreviousPathStrategy;                      // 0x003D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UNavMovePath*                           _path;                                             // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDAIBTController*                     _aiOwner;                                          // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathBuilder">();
	}
	static class UPathBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathBuilder>();
	}
};
static_assert(alignof(UPathBuilder) == 0x000008, "Wrong alignment on UPathBuilder");
static_assert(sizeof(UPathBuilder) == 0x000050, "Wrong size on UPathBuilder");
static_assert(offsetof(UPathBuilder, PathReachedPointRadius) == 0x000038, "Member 'UPathBuilder::PathReachedPointRadius' has a wrong offset!");
static_assert(offsetof(UPathBuilder, ToleratedTerrorPressure) == 0x00003C, "Member 'UPathBuilder::ToleratedTerrorPressure' has a wrong offset!");
static_assert(offsetof(UPathBuilder, OverridePreviousPathStrategy) == 0x00003D, "Member 'UPathBuilder::OverridePreviousPathStrategy' has a wrong offset!");
static_assert(offsetof(UPathBuilder, _path) == 0x000040, "Member 'UPathBuilder::_path' has a wrong offset!");
static_assert(offsetof(UPathBuilder, _aiOwner) == 0x000048, "Member 'UPathBuilder::_aiOwner' has a wrong offset!");

// Class DBDBots.PathBuilder_EQS
// 0x0080 (0x00D0 - 0x0050)
class UPathBuilder_EQS final : public UPathBuilder
{
public:
	struct FEQSParametrizedQueryExecutionRequest  EQSRequest;                                        // 0x0050(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         NbMaxEQSRequests;                                  // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MergeToSinglePathPoint;                            // 0x00A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x23];                                      // 0x00A5(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	class UPathBuilder_EQS*                       _pendingEQSRequestBuilder;                         // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathBuilder_EQS">();
	}
	static class UPathBuilder_EQS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathBuilder_EQS>();
	}
};
static_assert(alignof(UPathBuilder_EQS) == 0x000008, "Wrong alignment on UPathBuilder_EQS");
static_assert(sizeof(UPathBuilder_EQS) == 0x0000D0, "Wrong size on UPathBuilder_EQS");
static_assert(offsetof(UPathBuilder_EQS, EQSRequest) == 0x000050, "Member 'UPathBuilder_EQS::EQSRequest' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EQS, NbMaxEQSRequests) == 0x0000A0, "Member 'UPathBuilder_EQS::NbMaxEQSRequests' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EQS, MergeToSinglePathPoint) == 0x0000A4, "Member 'UPathBuilder_EQS::MergeToSinglePathPoint' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EQS, _pendingEQSRequestBuilder) == 0x0000C8, "Member 'UPathBuilder_EQS::_pendingEQSRequestBuilder' has a wrong offset!");

// Class DBDBots.PathBuilder_EvadeLoop
// 0x00B0 (0x0100 - 0x0050)
class UPathBuilder_EvadeLoop final : public UPathBuilder
{
public:
	float                                         AddDistanceToRequiredEvadeGap;                     // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceEvadePointUnderDistance;                      // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaserCrossingEvadeTimePenalty;                    // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwapPathReachTimeBuffer;                           // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BreakPalletInteractionId;                          // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OnPathRadius;                                      // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxEvadeInteractableWeightDistance;                // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightAtMaxDistance;                               // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MaxWeightAtNearestDistanceIfHostileHasRangedAbility; // 0x007C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeightAtMaxSafety;                                 // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxNearAllyPenaltyPathPointDistance;               // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeightWhenNearAlly;                                // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MinSafetyRatingAgainstMeleeHostileStimulus;        // 0x008C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    MinSafetyRatingAgainstRangedHostileStimulus;       // 0x009C(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MinDistanceFromHostileStimulusToClosestPoint;      // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFromHostileStimulusToClosestPointBuffer;   // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNavMovePath*                           _originalEvadeLoopWorkPath;                        // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNavMovePath*                           _querierWorkPathA;                                 // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNavMovePath*                           _querierWorkPathB;                                 // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNavMovePath*                           _chaserWorkPath;                                   // 0x00D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDNavEvadeLoopComponent*              _pickedEvadeLoopComponent;                         // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x20];                                      // 0x00E0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathBuilder_EvadeLoop">();
	}
	static class UPathBuilder_EvadeLoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathBuilder_EvadeLoop>();
	}
};
static_assert(alignof(UPathBuilder_EvadeLoop) == 0x000008, "Wrong alignment on UPathBuilder_EvadeLoop");
static_assert(sizeof(UPathBuilder_EvadeLoop) == 0x000100, "Wrong size on UPathBuilder_EvadeLoop");
static_assert(offsetof(UPathBuilder_EvadeLoop, AddDistanceToRequiredEvadeGap) == 0x000050, "Member 'UPathBuilder_EvadeLoop::AddDistanceToRequiredEvadeGap' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, ForceEvadePointUnderDistance) == 0x000054, "Member 'UPathBuilder_EvadeLoop::ForceEvadePointUnderDistance' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, ChaserCrossingEvadeTimePenalty) == 0x000058, "Member 'UPathBuilder_EvadeLoop::ChaserCrossingEvadeTimePenalty' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, SwapPathReachTimeBuffer) == 0x00005C, "Member 'UPathBuilder_EvadeLoop::SwapPathReachTimeBuffer' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, BreakPalletInteractionId) == 0x000060, "Member 'UPathBuilder_EvadeLoop::BreakPalletInteractionId' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, OnPathRadius) == 0x000070, "Member 'UPathBuilder_EvadeLoop::OnPathRadius' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, MaxEvadeInteractableWeightDistance) == 0x000074, "Member 'UPathBuilder_EvadeLoop::MaxEvadeInteractableWeightDistance' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, WeightAtMaxDistance) == 0x000078, "Member 'UPathBuilder_EvadeLoop::WeightAtMaxDistance' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, MaxWeightAtNearestDistanceIfHostileHasRangedAbility) == 0x00007C, "Member 'UPathBuilder_EvadeLoop::MaxWeightAtNearestDistanceIfHostileHasRangedAbility' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, WeightAtMaxSafety) == 0x000080, "Member 'UPathBuilder_EvadeLoop::WeightAtMaxSafety' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, MaxNearAllyPenaltyPathPointDistance) == 0x000084, "Member 'UPathBuilder_EvadeLoop::MaxNearAllyPenaltyPathPointDistance' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, WeightWhenNearAlly) == 0x000088, "Member 'UPathBuilder_EvadeLoop::WeightWhenNearAlly' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, MinSafetyRatingAgainstMeleeHostileStimulus) == 0x00008C, "Member 'UPathBuilder_EvadeLoop::MinSafetyRatingAgainstMeleeHostileStimulus' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, MinSafetyRatingAgainstRangedHostileStimulus) == 0x00009C, "Member 'UPathBuilder_EvadeLoop::MinSafetyRatingAgainstRangedHostileStimulus' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, MinDistanceFromHostileStimulusToClosestPoint) == 0x0000AC, "Member 'UPathBuilder_EvadeLoop::MinDistanceFromHostileStimulusToClosestPoint' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, DistanceFromHostileStimulusToClosestPointBuffer) == 0x0000B0, "Member 'UPathBuilder_EvadeLoop::DistanceFromHostileStimulusToClosestPointBuffer' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, _originalEvadeLoopWorkPath) == 0x0000B8, "Member 'UPathBuilder_EvadeLoop::_originalEvadeLoopWorkPath' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, _querierWorkPathA) == 0x0000C0, "Member 'UPathBuilder_EvadeLoop::_querierWorkPathA' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, _querierWorkPathB) == 0x0000C8, "Member 'UPathBuilder_EvadeLoop::_querierWorkPathB' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, _chaserWorkPath) == 0x0000D0, "Member 'UPathBuilder_EvadeLoop::_chaserWorkPath' has a wrong offset!");
static_assert(offsetof(UPathBuilder_EvadeLoop, _pickedEvadeLoopComponent) == 0x0000D8, "Member 'UPathBuilder_EvadeLoop::_pickedEvadeLoopComponent' has a wrong offset!");

// Class DBDBots.PathBuilder_LastGoal
// 0x0000 (0x0050 - 0x0050)
class UPathBuilder_LastGoal final : public UPathBuilder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathBuilder_LastGoal">();
	}
	static class UPathBuilder_LastGoal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathBuilder_LastGoal>();
	}
};
static_assert(alignof(UPathBuilder_LastGoal) == 0x000008, "Wrong alignment on UPathBuilder_LastGoal");
static_assert(sizeof(UPathBuilder_LastGoal) == 0x000050, "Wrong size on UPathBuilder_LastGoal");

// Class DBDBots.PathStrategy_FleeLoop
// 0x0158 (0x0210 - 0x00B8)
class UPathStrategy_FleeLoop final : public UPathStrategy_Flee
{
public:
	TMap<EAIDifficultyLevel, struct FGameStateEvadeLoopStrategyMapContainer> GameStateFleeLoopStrategyTable; // 0x00B8(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EAIFleeLoopStrategy, class UPathBuilder_EvadeLoop*> FleeLoopStrategyPathBuilders;           // 0x0108(0x0050)(Edit, ExportObject, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         CanBranchUnderEndPathDistance;                     // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAIFleeLoopStrategy, struct FAIRoll>     BranchRolls;                                       // 0x0160(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         RejectLoopBranchUnderEndPointsDistance;            // 0x01B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RejectBranchPointNearerHostileSourceDistance;      // 0x01B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RejectBranchUnderNavLinkDistance;                  // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddDistanceToRequiredBranchEvadeGap;               // 0x01BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C0[0x50];                                     // 0x01C0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PathStrategy_FleeLoop">();
	}
	static class UPathStrategy_FleeLoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPathStrategy_FleeLoop>();
	}
};
static_assert(alignof(UPathStrategy_FleeLoop) == 0x000008, "Wrong alignment on UPathStrategy_FleeLoop");
static_assert(sizeof(UPathStrategy_FleeLoop) == 0x000210, "Wrong size on UPathStrategy_FleeLoop");
static_assert(offsetof(UPathStrategy_FleeLoop, GameStateFleeLoopStrategyTable) == 0x0000B8, "Member 'UPathStrategy_FleeLoop::GameStateFleeLoopStrategyTable' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLoop, FleeLoopStrategyPathBuilders) == 0x000108, "Member 'UPathStrategy_FleeLoop::FleeLoopStrategyPathBuilders' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLoop, CanBranchUnderEndPathDistance) == 0x000158, "Member 'UPathStrategy_FleeLoop::CanBranchUnderEndPathDistance' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLoop, BranchRolls) == 0x000160, "Member 'UPathStrategy_FleeLoop::BranchRolls' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLoop, RejectLoopBranchUnderEndPointsDistance) == 0x0001B0, "Member 'UPathStrategy_FleeLoop::RejectLoopBranchUnderEndPointsDistance' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLoop, RejectBranchPointNearerHostileSourceDistance) == 0x0001B4, "Member 'UPathStrategy_FleeLoop::RejectBranchPointNearerHostileSourceDistance' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLoop, RejectBranchUnderNavLinkDistance) == 0x0001B8, "Member 'UPathStrategy_FleeLoop::RejectBranchUnderNavLinkDistance' has a wrong offset!");
static_assert(offsetof(UPathStrategy_FleeLoop, AddDistanceToRequiredBranchEvadeGap) == 0x0001BC, "Member 'UPathStrategy_FleeLoop::AddDistanceToRequiredBranchEvadeGap' has a wrong offset!");

}

