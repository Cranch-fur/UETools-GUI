#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK24

#include "Basic.hpp"

#include "TheK24_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "DataTableUtilities_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "DBDCompetence_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DBDBots_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "SimpleStateMachine_classes.hpp"
#include "DBDGameplay_classes.hpp"
#include "AIModule_classes.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "StatSystem_structs.hpp"
#include "DBDInteraction_classes.hpp"
#include "DBDAttack_classes.hpp"
#include "GameplayTagUtilities_structs.hpp"


namespace SDK
{

// Class TheK24.ZombieAIController
// 0x02F0 (0x0630 - 0x0340)
class AZombieAIController final : public AAIController
{
public:
	uint8                                         Pad_340[0x18];                                     // 0x0340(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBehaviorTree*                          _zombieBehaviorTree;                               // 0x0358(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAIPerceptionComponent*                 _aiPerceptionComponent;                            // 0x0360(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACamperPlayer*>                  _survivorInVision;                                 // 0x0370(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class ACamperPlayer*                          _chaseTargetSurvivor;                              // 0x0380(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _goToLocation;                                     // 0x0388(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AMeatHook*                              _patrolArea;                                       // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACamperPlayer*>                  _survivorsInAttackDetector;                        // 0x03A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _cannotChaseWhileIdleTags;                         // 0x03B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _zombieAttackHitTime;                              // 0x03C0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _zombieAttackOpenTime;                             // 0x03E8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _zombieAnimSpawnTime;                              // 0x0410(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _zombieAnimDyingTime;                              // 0x0438(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _zombieSightRadius;                                // 0x0460(0x0080)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _zombieLoseSightRadius;                            // 0x04E0(0x0080)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _zombieVisionHalfAngle;                            // 0x0560(0x0080)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _zombieFallSmashTime;                              // 0x05E0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _zombieAttackCooldownTime;                         // 0x0608(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnTargetPerceptionUpdated(class AActor* actor, const struct FAIStimulus& stimulus);
	void OnSlasherSet(class ASlasherPlayer* slasher);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieAIController">();
	}
	static class AZombieAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZombieAIController>();
	}
};
static_assert(alignof(AZombieAIController) == 0x000008, "Wrong alignment on AZombieAIController");
static_assert(sizeof(AZombieAIController) == 0x000630, "Wrong size on AZombieAIController");
static_assert(offsetof(AZombieAIController, _zombieBehaviorTree) == 0x000358, "Member 'AZombieAIController::_zombieBehaviorTree' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _aiPerceptionComponent) == 0x000360, "Member 'AZombieAIController::_aiPerceptionComponent' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _survivorInVision) == 0x000370, "Member 'AZombieAIController::_survivorInVision' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _chaseTargetSurvivor) == 0x000380, "Member 'AZombieAIController::_chaseTargetSurvivor' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _goToLocation) == 0x000388, "Member 'AZombieAIController::_goToLocation' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _patrolArea) == 0x000398, "Member 'AZombieAIController::_patrolArea' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _survivorsInAttackDetector) == 0x0003A0, "Member 'AZombieAIController::_survivorsInAttackDetector' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _cannotChaseWhileIdleTags) == 0x0003B0, "Member 'AZombieAIController::_cannotChaseWhileIdleTags' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieAttackHitTime) == 0x0003C0, "Member 'AZombieAIController::_zombieAttackHitTime' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieAttackOpenTime) == 0x0003E8, "Member 'AZombieAIController::_zombieAttackOpenTime' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieAnimSpawnTime) == 0x000410, "Member 'AZombieAIController::_zombieAnimSpawnTime' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieAnimDyingTime) == 0x000438, "Member 'AZombieAIController::_zombieAnimDyingTime' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieSightRadius) == 0x000460, "Member 'AZombieAIController::_zombieSightRadius' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieLoseSightRadius) == 0x0004E0, "Member 'AZombieAIController::_zombieLoseSightRadius' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieVisionHalfAngle) == 0x000560, "Member 'AZombieAIController::_zombieVisionHalfAngle' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieFallSmashTime) == 0x0005E0, "Member 'AZombieAIController::_zombieFallSmashTime' has a wrong offset!");
static_assert(offsetof(AZombieAIController, _zombieAttackCooldownTime) == 0x000608, "Member 'AZombieAIController::_zombieAttackCooldownTime' has a wrong offset!");

// Class TheK24.ActivateK24PowerInteraction
// 0x0090 (0x07D0 - 0x0740)
class UActivateK24PowerInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_740[0x10];                                     // 0x0740(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _interactionViewPitchMax;                          // 0x0750(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _interactionViewPitchMin;                          // 0x0778(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maximumTimeToTriggerRegularAttack;                // 0x07A0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C8[0x8];                                      // 0x07C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetK24Power(class AK24Power* k24Power);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateK24PowerInteraction">();
	}
	static class UActivateK24PowerInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateK24PowerInteraction>();
	}
};
static_assert(alignof(UActivateK24PowerInteraction) == 0x000010, "Wrong alignment on UActivateK24PowerInteraction");
static_assert(sizeof(UActivateK24PowerInteraction) == 0x0007D0, "Wrong size on UActivateK24PowerInteraction");
static_assert(offsetof(UActivateK24PowerInteraction, _interactionViewPitchMax) == 0x000750, "Member 'UActivateK24PowerInteraction::_interactionViewPitchMax' has a wrong offset!");
static_assert(offsetof(UActivateK24PowerInteraction, _interactionViewPitchMin) == 0x000778, "Member 'UActivateK24PowerInteraction::_interactionViewPitchMin' has a wrong offset!");
static_assert(offsetof(UActivateK24PowerInteraction, _maximumTimeToTriggerRegularAttack) == 0x0007A0, "Member 'UActivateK24PowerInteraction::_maximumTimeToTriggerRegularAttack' has a wrong offset!");

// Class TheK24.ZombieAnimInstance
// 0x0090 (0x0350 - 0x02C0)
class UZombieAnimInstance final : public UAnimInstance
{
public:
	bool                                          _isChasing;                                        // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _chaseLocomotionPlayRate;                          // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _chaseSequenceMaxSpeed;                            // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _chaseLocomotionIndex;                             // 0x02CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _chaseLocomotionMaxIndex;                          // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRange                            _chaseLocomotionIndexChangeTimerDurationRange;     // 0x02D4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingFirstChaseLocomotionPlayer;                // 0x02E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttacking;                                      // 0x02E5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E6[0x2];                                      // 0x02E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _attackIndex;                                      // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _maxAttackIndex;                                   // 0x02EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPatrollingOrSearching;                          // 0x02F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isStunned;                                        // 0x02F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDying;                                          // 0x02F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSpawning;                                       // 0x02F3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInPool;                                         // 0x02F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F5[0x3];                                      // 0x02F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AZombieCharacter*                       _zombieCharacter;                                  // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _speed;                                            // 0x0300(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMoving;                                         // 0x0304(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFalling;                                        // 0x0305(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMale;                                           // 0x0306(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_307[0x1];                                      // 0x0307(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _currentDirection;                                 // 0x0308(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               _currentRotation;                                  // 0x030C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         _rotationInterpolationSpeed;                       // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rotationInterpolationSpeedDuringChase;            // 0x031C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x30];                                     // 0x0320(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieAnimInstance">();
	}
	static class UZombieAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieAnimInstance>();
	}
};
static_assert(alignof(UZombieAnimInstance) == 0x000010, "Wrong alignment on UZombieAnimInstance");
static_assert(sizeof(UZombieAnimInstance) == 0x000350, "Wrong size on UZombieAnimInstance");
static_assert(offsetof(UZombieAnimInstance, _isChasing) == 0x0002C0, "Member 'UZombieAnimInstance::_isChasing' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _chaseLocomotionPlayRate) == 0x0002C4, "Member 'UZombieAnimInstance::_chaseLocomotionPlayRate' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _chaseSequenceMaxSpeed) == 0x0002C8, "Member 'UZombieAnimInstance::_chaseSequenceMaxSpeed' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _chaseLocomotionIndex) == 0x0002CC, "Member 'UZombieAnimInstance::_chaseLocomotionIndex' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _chaseLocomotionMaxIndex) == 0x0002D0, "Member 'UZombieAnimInstance::_chaseLocomotionMaxIndex' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _chaseLocomotionIndexChangeTimerDurationRange) == 0x0002D4, "Member 'UZombieAnimInstance::_chaseLocomotionIndexChangeTimerDurationRange' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isUsingFirstChaseLocomotionPlayer) == 0x0002E4, "Member 'UZombieAnimInstance::_isUsingFirstChaseLocomotionPlayer' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isAttacking) == 0x0002E5, "Member 'UZombieAnimInstance::_isAttacking' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _attackIndex) == 0x0002E8, "Member 'UZombieAnimInstance::_attackIndex' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _maxAttackIndex) == 0x0002EC, "Member 'UZombieAnimInstance::_maxAttackIndex' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isPatrollingOrSearching) == 0x0002F0, "Member 'UZombieAnimInstance::_isPatrollingOrSearching' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isStunned) == 0x0002F1, "Member 'UZombieAnimInstance::_isStunned' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isDying) == 0x0002F2, "Member 'UZombieAnimInstance::_isDying' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isSpawning) == 0x0002F3, "Member 'UZombieAnimInstance::_isSpawning' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isInPool) == 0x0002F4, "Member 'UZombieAnimInstance::_isInPool' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _zombieCharacter) == 0x0002F8, "Member 'UZombieAnimInstance::_zombieCharacter' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _speed) == 0x000300, "Member 'UZombieAnimInstance::_speed' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isMoving) == 0x000304, "Member 'UZombieAnimInstance::_isMoving' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isFalling) == 0x000305, "Member 'UZombieAnimInstance::_isFalling' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _isMale) == 0x000306, "Member 'UZombieAnimInstance::_isMale' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _currentDirection) == 0x000308, "Member 'UZombieAnimInstance::_currentDirection' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _currentRotation) == 0x00030C, "Member 'UZombieAnimInstance::_currentRotation' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _rotationInterpolationSpeed) == 0x000318, "Member 'UZombieAnimInstance::_rotationInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UZombieAnimInstance, _rotationInterpolationSpeedDuringChase) == 0x00031C, "Member 'UZombieAnimInstance::_rotationInterpolationSpeedDuringChase' has a wrong offset!");

// Class TheK24.Addon_K24_04
// 0x0018 (0x02E0 - 0x02C8)
class UAddon_K24_04 final : public UOnEventBaseAddon
{
public:
	float                                         _effectTime;                                       // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           outlineColor;                                      // 0x02CC(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K24_04">();
	}
	static class UAddon_K24_04* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K24_04>();
	}
};
static_assert(alignof(UAddon_K24_04) == 0x000008, "Wrong alignment on UAddon_K24_04");
static_assert(sizeof(UAddon_K24_04) == 0x0002E0, "Wrong size on UAddon_K24_04");
static_assert(offsetof(UAddon_K24_04, _effectTime) == 0x0002C8, "Member 'UAddon_K24_04::_effectTime' has a wrong offset!");
static_assert(offsetof(UAddon_K24_04, outlineColor) == 0x0002CC, "Member 'UAddon_K24_04::outlineColor' has a wrong offset!");

// Class TheK24.ZombieAttackSurvivorBTTask
// 0x0000 (0x00B0 - 0x00B0)
class UZombieAttackSurvivorBTTask final : public UBTTask_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieAttackSurvivorBTTask">();
	}
	static class UZombieAttackSurvivorBTTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieAttackSurvivorBTTask>();
	}
};
static_assert(alignof(UZombieAttackSurvivorBTTask) == 0x000008, "Wrong alignment on UZombieAttackSurvivorBTTask");
static_assert(sizeof(UZombieAttackSurvivorBTTask) == 0x0000B0, "Wrong size on UZombieAttackSurvivorBTTask");

// Class TheK24.Addon_K24_18
// 0x0008 (0x02F0 - 0x02E8)
class UAddon_K24_18 final : public UImposeStatusEffectOnEventAddon
{
public:
	TSubclassOf<class AZombieEscapeDoorPointsActor> _zombieEscapeDoorPointsActor;                    // 0x02E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Addon_K24_18">();
	}
	static class UAddon_K24_18* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAddon_K24_18>();
	}
};
static_assert(alignof(UAddon_K24_18) == 0x000008, "Wrong alignment on UAddon_K24_18");
static_assert(sizeof(UAddon_K24_18) == 0x0002F0, "Wrong size on UAddon_K24_18");
static_assert(offsetof(UAddon_K24_18, _zombieEscapeDoorPointsActor) == 0x0002E8, "Member 'UAddon_K24_18::_zombieEscapeDoorPointsActor' has a wrong offset!");

// Class TheK24.ZombieAttractedByGeneratorBTService
// 0x0030 (0x00D0 - 0x00A0)
class UZombieAttractedByGeneratorBTService final : public UBTService_BlueprintBase
{
public:
	float                                         _genRepairingHearingRange;                         // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4[0x2C];                                      // 0x00A4(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInRangeChanged(const bool inRange, class AGenerator* generator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieAttractedByGeneratorBTService">();
	}
	static class UZombieAttractedByGeneratorBTService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieAttractedByGeneratorBTService>();
	}
};
static_assert(alignof(UZombieAttractedByGeneratorBTService) == 0x000008, "Wrong alignment on UZombieAttractedByGeneratorBTService");
static_assert(sizeof(UZombieAttractedByGeneratorBTService) == 0x0000D0, "Wrong size on UZombieAttractedByGeneratorBTService");
static_assert(offsetof(UZombieAttractedByGeneratorBTService, _genRepairingHearingRange) == 0x0000A0, "Member 'UZombieAttractedByGeneratorBTService::_genRepairingHearingRange' has a wrong offset!");

// Class TheK24.AISkill_FindCollectable_SupplyCrate
// 0x0010 (0x0158 - 0x0148)
class UAISkill_FindCollectable_SupplyCrate final : public UAISkill_FindCollectable_Searchable
{
public:
	struct FAITunableParameter                    UrgencyGoalWeight;                                 // 0x0148(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindCollectable_SupplyCrate">();
	}
	static class UAISkill_FindCollectable_SupplyCrate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindCollectable_SupplyCrate>();
	}
};
static_assert(alignof(UAISkill_FindCollectable_SupplyCrate) == 0x000008, "Wrong alignment on UAISkill_FindCollectable_SupplyCrate");
static_assert(sizeof(UAISkill_FindCollectable_SupplyCrate) == 0x000158, "Wrong size on UAISkill_FindCollectable_SupplyCrate");
static_assert(offsetof(UAISkill_FindCollectable_SupplyCrate, UrgencyGoalWeight) == 0x000148, "Member 'UAISkill_FindCollectable_SupplyCrate::UrgencyGoalWeight' has a wrong offset!");

// Class TheK24.AISkill_InteractionUseItem_Serum
// 0x0000 (0x0188 - 0x0188)
class UAISkill_InteractionUseItem_Serum final : public UAISkill_InteractionUseItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionUseItem_Serum">();
	}
	static class UAISkill_InteractionUseItem_Serum* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionUseItem_Serum>();
	}
};
static_assert(alignof(UAISkill_InteractionUseItem_Serum) == 0x000008, "Wrong alignment on UAISkill_InteractionUseItem_Serum");
static_assert(sizeof(UAISkill_InteractionUseItem_Serum) == 0x000188, "Wrong size on UAISkill_InteractionUseItem_Serum");

// Class TheK24.BiteTheBullet
// 0x0010 (0x03D8 - 0x03C8)
class UBiteTheBullet final : public UPerk
{
public:
	TSubclassOf<class UBiteTheBulletEffect>       _effectClass;                                      // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _server_healTarget;                                // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BiteTheBullet">();
	}
	static class UBiteTheBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBiteTheBullet>();
	}
};
static_assert(alignof(UBiteTheBullet) == 0x000008, "Wrong alignment on UBiteTheBullet");
static_assert(sizeof(UBiteTheBullet) == 0x0003D8, "Wrong size on UBiteTheBullet");
static_assert(offsetof(UBiteTheBullet, _effectClass) == 0x0003C8, "Member 'UBiteTheBullet::_effectClass' has a wrong offset!");
static_assert(offsetof(UBiteTheBullet, _server_healTarget) == 0x0003D0, "Member 'UBiteTheBullet::_server_healTarget' has a wrong offset!");

// Class TheK24.BiteTheBulletEffect
// 0x0008 (0x0360 - 0x0358)
class UBiteTheBulletEffect final : public UBaseLingeringStatusEffect
{
public:
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BiteTheBulletEffect">();
	}
	static class UBiteTheBulletEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBiteTheBulletEffect>();
	}
};
static_assert(alignof(UBiteTheBulletEffect) == 0x000008, "Wrong alignment on UBiteTheBulletEffect");
static_assert(sizeof(UBiteTheBulletEffect) == 0x000360, "Wrong size on UBiteTheBulletEffect");

// Class TheK24.BlastMine
// 0x0020 (0x04D8 - 0x04B8)
class UBlastMine final : public UGeneratorTrapPerk
{
public:
	TSubclassOf<class UGeneratorBlastMinePlacerComponent> _blastMinePlacerClass;                     // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ABlastMineFirecracker>      _blastMineFirecrackerClass;                        // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABlastMineFirecracker*                  _blastMine;                                        // 0x04C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_TrapActivatedLoudNotification(const struct FTransform& location);
	void ThrowBubbleIndicator_Cosmetic(const struct FTransform& location);
	void TrapAttachedToGenerator_Cosmetic(class AGenerator* trappedGenerator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMine">();
	}
	static class UBlastMine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastMine>();
	}
};
static_assert(alignof(UBlastMine) == 0x000008, "Wrong alignment on UBlastMine");
static_assert(sizeof(UBlastMine) == 0x0004D8, "Wrong size on UBlastMine");
static_assert(offsetof(UBlastMine, _blastMinePlacerClass) == 0x0004B8, "Member 'UBlastMine::_blastMinePlacerClass' has a wrong offset!");
static_assert(offsetof(UBlastMine, _blastMineFirecrackerClass) == 0x0004C0, "Member 'UBlastMine::_blastMineFirecrackerClass' has a wrong offset!");
static_assert(offsetof(UBlastMine, _blastMine) == 0x0004C8, "Member 'UBlastMine::_blastMine' has a wrong offset!");

// Class TheK24.BlastMineFirecracker
// 0x0080 (0x0400 - 0x0380)
class ABlastMineFirecracker final : public AFirecracker
{
public:
	uint8                                         Pad_380[0x30];                                     // 0x0380(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EBlastMineRemovedReason removedReason)> OnTrapRemovedBlueprintEvent; // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AGenerator*                             _trappedGenerator;                                 // 0x03C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USimpleStateMachine*                    _stateMachine;                                     // 0x03D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlastMineKickSensor*                   _kickSensor;                                       // 0x03D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlastMineVisibilityController*         _visibilityController;                             // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lifetime;                                         // 0x03E8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _authority_ExplosionCount;                         // 0x03EC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _authority_CurrentState;                           // 0x03F0(0x000C)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AuthorityCurrentState();
	void OnRep_AuthorityExplosionCount();
	void OnRep_Lifetime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMineFirecracker">();
	}
	static class ABlastMineFirecracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABlastMineFirecracker>();
	}
};
static_assert(alignof(ABlastMineFirecracker) == 0x000008, "Wrong alignment on ABlastMineFirecracker");
static_assert(sizeof(ABlastMineFirecracker) == 0x000400, "Wrong size on ABlastMineFirecracker");
static_assert(offsetof(ABlastMineFirecracker, OnTrapRemovedBlueprintEvent) == 0x0003B0, "Member 'ABlastMineFirecracker::OnTrapRemovedBlueprintEvent' has a wrong offset!");
static_assert(offsetof(ABlastMineFirecracker, _trappedGenerator) == 0x0003C0, "Member 'ABlastMineFirecracker::_trappedGenerator' has a wrong offset!");
static_assert(offsetof(ABlastMineFirecracker, _stateMachine) == 0x0003D0, "Member 'ABlastMineFirecracker::_stateMachine' has a wrong offset!");
static_assert(offsetof(ABlastMineFirecracker, _kickSensor) == 0x0003D8, "Member 'ABlastMineFirecracker::_kickSensor' has a wrong offset!");
static_assert(offsetof(ABlastMineFirecracker, _visibilityController) == 0x0003E0, "Member 'ABlastMineFirecracker::_visibilityController' has a wrong offset!");
static_assert(offsetof(ABlastMineFirecracker, _lifetime) == 0x0003E8, "Member 'ABlastMineFirecracker::_lifetime' has a wrong offset!");
static_assert(offsetof(ABlastMineFirecracker, _authority_ExplosionCount) == 0x0003EC, "Member 'ABlastMineFirecracker::_authority_ExplosionCount' has a wrong offset!");
static_assert(offsetof(ABlastMineFirecracker, _authority_CurrentState) == 0x0003F0, "Member 'ABlastMineFirecracker::_authority_CurrentState' has a wrong offset!");

// Class TheK24.BlastMineKickSensor
// 0x0060 (0x0118 - 0x00B8)
class UBlastMineKickSensor final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            _kickChargeTriggerRange;                           // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ASlasherPlayer*                         _kickingKiller;                                    // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _kickGeneratorChargeable;                          // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGenerator*                             _generator;                                        // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x20];                                      // 0x00F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnKickChargeablePercentChanged(class UChargeableComponent* chargeableComponent, float percentCompletionChange, float totalPercentComplete);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMineKickSensor">();
	}
	static class UBlastMineKickSensor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastMineKickSensor>();
	}
};
static_assert(alignof(UBlastMineKickSensor) == 0x000008, "Wrong alignment on UBlastMineKickSensor");
static_assert(sizeof(UBlastMineKickSensor) == 0x000118, "Wrong size on UBlastMineKickSensor");
static_assert(offsetof(UBlastMineKickSensor, _kickChargeTriggerRange) == 0x0000D0, "Member 'UBlastMineKickSensor::_kickChargeTriggerRange' has a wrong offset!");
static_assert(offsetof(UBlastMineKickSensor, _kickingKiller) == 0x0000E0, "Member 'UBlastMineKickSensor::_kickingKiller' has a wrong offset!");
static_assert(offsetof(UBlastMineKickSensor, _kickGeneratorChargeable) == 0x0000E8, "Member 'UBlastMineKickSensor::_kickGeneratorChargeable' has a wrong offset!");
static_assert(offsetof(UBlastMineKickSensor, _generator) == 0x0000F0, "Member 'UBlastMineKickSensor::_generator' has a wrong offset!");

// Class TheK24.BlastMineState_Explode
// 0x0028 (0x0070 - 0x0048)
class UBlastMineState_Explode final : public USimpleStateMachineBaseState
{
public:
	uint8                                         Pad_48[0x28];                                      // 0x0048(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMineState_Explode">();
	}
	static class UBlastMineState_Explode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastMineState_Explode>();
	}
};
static_assert(alignof(UBlastMineState_Explode) == 0x000008, "Wrong alignment on UBlastMineState_Explode");
static_assert(sizeof(UBlastMineState_Explode) == 0x000070, "Wrong size on UBlastMineState_Explode");

// Class TheK24.BlastMineTransition_ExplodeToHidden
// 0x0000 (0x0050 - 0x0050)
class UBlastMineTransition_ExplodeToHidden final : public USimpleStateMachineBaseTransition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMineTransition_ExplodeToHidden">();
	}
	static class UBlastMineTransition_ExplodeToHidden* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastMineTransition_ExplodeToHidden>();
	}
};
static_assert(alignof(UBlastMineTransition_ExplodeToHidden) == 0x000008, "Wrong alignment on UBlastMineTransition_ExplodeToHidden");
static_assert(sizeof(UBlastMineTransition_ExplodeToHidden) == 0x000050, "Wrong size on UBlastMineTransition_ExplodeToHidden");

// Class TheK24.BlastMineState_Hidden
// 0x0010 (0x0058 - 0x0048)
class UBlastMineState_Hidden final : public USimpleStateMachineBaseState
{
public:
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMineState_Hidden">();
	}
	static class UBlastMineState_Hidden* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastMineState_Hidden>();
	}
};
static_assert(alignof(UBlastMineState_Hidden) == 0x000008, "Wrong alignment on UBlastMineState_Hidden");
static_assert(sizeof(UBlastMineState_Hidden) == 0x000058, "Wrong size on UBlastMineState_Hidden");

// Class TheK24.BlastMineTransition_HiddenToSpawned
// 0x0000 (0x0050 - 0x0050)
class UBlastMineTransition_HiddenToSpawned final : public USimpleStateMachineBaseTransition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMineTransition_HiddenToSpawned">();
	}
	static class UBlastMineTransition_HiddenToSpawned* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastMineTransition_HiddenToSpawned>();
	}
};
static_assert(alignof(UBlastMineTransition_HiddenToSpawned) == 0x000008, "Wrong alignment on UBlastMineTransition_HiddenToSpawned");
static_assert(sizeof(UBlastMineTransition_HiddenToSpawned) == 0x000050, "Wrong size on UBlastMineTransition_HiddenToSpawned");

// Class TheK24.BlastMineState_Spawned
// 0x0050 (0x0098 - 0x0048)
class UBlastMineState_Spawned final : public USimpleStateMachineBaseState
{
public:
	uint8                                         Pad_48[0x50];                                      // 0x0048(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMineState_Spawned">();
	}
	static class UBlastMineState_Spawned* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastMineState_Spawned>();
	}
};
static_assert(alignof(UBlastMineState_Spawned) == 0x000008, "Wrong alignment on UBlastMineState_Spawned");
static_assert(sizeof(UBlastMineState_Spawned) == 0x000098, "Wrong size on UBlastMineState_Spawned");

// Class TheK24.BlastMineTransition_SpawnedToExplode
// 0x0000 (0x0050 - 0x0050)
class UBlastMineTransition_SpawnedToExplode final : public USimpleStateMachineBaseTransition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMineTransition_SpawnedToExplode">();
	}
	static class UBlastMineTransition_SpawnedToExplode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastMineTransition_SpawnedToExplode>();
	}
};
static_assert(alignof(UBlastMineTransition_SpawnedToExplode) == 0x000008, "Wrong alignment on UBlastMineTransition_SpawnedToExplode");
static_assert(sizeof(UBlastMineTransition_SpawnedToExplode) == 0x000050, "Wrong size on UBlastMineTransition_SpawnedToExplode");

// Class TheK24.BlastMineTransition_SpawnedToHidden
// 0x0000 (0x0050 - 0x0050)
class UBlastMineTransition_SpawnedToHidden final : public USimpleStateMachineBaseTransition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMineTransition_SpawnedToHidden">();
	}
	static class UBlastMineTransition_SpawnedToHidden* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastMineTransition_SpawnedToHidden>();
	}
};
static_assert(alignof(UBlastMineTransition_SpawnedToHidden) == 0x000008, "Wrong alignment on UBlastMineTransition_SpawnedToHidden");
static_assert(sizeof(UBlastMineTransition_SpawnedToHidden) == 0x000050, "Wrong size on UBlastMineTransition_SpawnedToHidden");

// Class TheK24.BlastMineVisibilityController
// 0x0118 (0x01D0 - 0x00B8)
class UBlastMineVisibilityController final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x70];                                      // 0x00B8(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UFXSystemComponent*>               _systems;                                          // 0x0128(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UMeshComponent*>                   _meshes;                                           // 0x0178(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddFXSystem(class UFXSystemComponent* system);
	void AddMeshComponent(class UMeshComponent* meshComponent);

	bool IsVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlastMineVisibilityController">();
	}
	static class UBlastMineVisibilityController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlastMineVisibilityController>();
	}
};
static_assert(alignof(UBlastMineVisibilityController) == 0x000008, "Wrong alignment on UBlastMineVisibilityController");
static_assert(sizeof(UBlastMineVisibilityController) == 0x0001D0, "Wrong size on UBlastMineVisibilityController");
static_assert(offsetof(UBlastMineVisibilityController, _systems) == 0x000128, "Member 'UBlastMineVisibilityController::_systems' has a wrong offset!");
static_assert(offsetof(UBlastMineVisibilityController, _meshes) == 0x000178, "Member 'UBlastMineVisibilityController::_meshes' has a wrong offset!");

// Class TheK24.BlindZombieFlashlightableLightingStrategy
// 0x0000 (0x0040 - 0x0040)
class UBlindZombieFlashlightableLightingStrategy final : public UFlashlightablePointsLightingStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindZombieFlashlightableLightingStrategy">();
	}
	static class UBlindZombieFlashlightableLightingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindZombieFlashlightableLightingStrategy>();
	}
};
static_assert(alignof(UBlindZombieFlashlightableLightingStrategy) == 0x000008, "Wrong alignment on UBlindZombieFlashlightableLightingStrategy");
static_assert(sizeof(UBlindZombieFlashlightableLightingStrategy) == 0x000040, "Wrong size on UBlindZombieFlashlightableLightingStrategy");

// Class TheK24.BTTask_MoveToAbortIfStuck
// 0x0018 (0x00D8 - 0x00C0)
class UBTTask_MoveToAbortIfStuck final : public UBTTask_MoveTo
{
public:
	uint8                                         Pad_C0[0x4];                                       // 0x00C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _deltaConsideredStuck;                             // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0xC];                                       // 0x00C8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxTimeStuck;                                     // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MoveToAbortIfStuck">();
	}
	static class UBTTask_MoveToAbortIfStuck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MoveToAbortIfStuck>();
	}
};
static_assert(alignof(UBTTask_MoveToAbortIfStuck) == 0x000008, "Wrong alignment on UBTTask_MoveToAbortIfStuck");
static_assert(sizeof(UBTTask_MoveToAbortIfStuck) == 0x0000D8, "Wrong size on UBTTask_MoveToAbortIfStuck");
static_assert(offsetof(UBTTask_MoveToAbortIfStuck, _deltaConsideredStuck) == 0x0000C4, "Member 'UBTTask_MoveToAbortIfStuck::_deltaConsideredStuck' has a wrong offset!");
static_assert(offsetof(UBTTask_MoveToAbortIfStuck, _maxTimeStuck) == 0x0000D4, "Member 'UBTTask_MoveToAbortIfStuck::_maxTimeStuck' has a wrong offset!");

// Class TheK24.ChangeZombieStateBTTask
// 0x0008 (0x00B8 - 0x00B0)
class UChangeZombieStateBTTask final : public UBTTask_BlueprintBase
{
public:
	EZombieState                                  _zombieState;                                      // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChangeZombieStateBTTask">();
	}
	static class UChangeZombieStateBTTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChangeZombieStateBTTask>();
	}
};
static_assert(alignof(UChangeZombieStateBTTask) == 0x000008, "Wrong alignment on UChangeZombieStateBTTask");
static_assert(sizeof(UChangeZombieStateBTTask) == 0x0000B8, "Wrong size on UChangeZombieStateBTTask");
static_assert(offsetof(UChangeZombieStateBTTask, _zombieState) == 0x0000B0, "Member 'UChangeZombieStateBTTask::_zombieState' has a wrong offset!");

// Class TheK24.ContaminationSerumCollectable
// 0x0018 (0x0510 - 0x04F8)
class AContaminationSerumCollectable final : public ABaseCamperCollectable
{
public:
	uint8                                         Pad_4F8[0x18];                                     // 0x04F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContaminationSerumCollectable">();
	}
	static class AContaminationSerumCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AContaminationSerumCollectable>();
	}
};
static_assert(alignof(AContaminationSerumCollectable) == 0x000008, "Wrong alignment on AContaminationSerumCollectable");
static_assert(sizeof(AContaminationSerumCollectable) == 0x000510, "Wrong size on AContaminationSerumCollectable");

// Class TheK24.ContaminationSubAnimInstance
// 0x0070 (0x05C0 - 0x0550)
class UContaminationSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isContaminated;                                   // 0x0550(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInjectingSerumSelf;                             // 0x0551(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInjectingSerumOther;                            // 0x0552(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingInjectedWithSerum;                         // 0x0553(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingHealed;                                    // 0x0554(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFirstContaminationHit;                          // 0x0555(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _triggerCough;                                     // 0x0556(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_557[0x1];                                      // 0x0557(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeBetweenCough;                                 // 0x0558(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x055C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x055D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInsideCloset;                                   // 0x055E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInteracting;                                    // 0x055F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingAimItem;                                 // 0x0560(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x0561(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHooked;                                         // 0x0562(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDead;                                           // 0x0563(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFrightScreaming;                                // 0x0564(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingSmallItem;                               // 0x0565(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingAimItem;                                   // 0x0566(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingHandleItem;                              // 0x0567(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInjured;                                        // 0x0568(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCarried;                                        // 0x0569(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionAnimation                         _interactionType;                                  // 0x056A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_56B[0x55];                                     // 0x056B(0x0055)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContaminationSubAnimInstance">();
	}
	static class UContaminationSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContaminationSubAnimInstance>();
	}
};
static_assert(alignof(UContaminationSubAnimInstance) == 0x000010, "Wrong alignment on UContaminationSubAnimInstance");
static_assert(sizeof(UContaminationSubAnimInstance) == 0x0005C0, "Wrong size on UContaminationSubAnimInstance");
static_assert(offsetof(UContaminationSubAnimInstance, _isContaminated) == 0x000550, "Member 'UContaminationSubAnimInstance::_isContaminated' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isInjectingSerumSelf) == 0x000551, "Member 'UContaminationSubAnimInstance::_isInjectingSerumSelf' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isInjectingSerumOther) == 0x000552, "Member 'UContaminationSubAnimInstance::_isInjectingSerumOther' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isBeingInjectedWithSerum) == 0x000553, "Member 'UContaminationSubAnimInstance::_isBeingInjectedWithSerum' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isBeingHealed) == 0x000554, "Member 'UContaminationSubAnimInstance::_isBeingHealed' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isFirstContaminationHit) == 0x000555, "Member 'UContaminationSubAnimInstance::_isFirstContaminationHit' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _triggerCough) == 0x000556, "Member 'UContaminationSubAnimInstance::_triggerCough' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _timeBetweenCough) == 0x000558, "Member 'UContaminationSubAnimInstance::_timeBetweenCough' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isIdle) == 0x00055C, "Member 'UContaminationSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isCrouched) == 0x00055D, "Member 'UContaminationSubAnimInstance::_isCrouched' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isInsideCloset) == 0x00055E, "Member 'UContaminationSubAnimInstance::_isInsideCloset' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isInteracting) == 0x00055F, "Member 'UContaminationSubAnimInstance::_isInteracting' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isHoldingAimItem) == 0x000560, "Member 'UContaminationSubAnimInstance::_isHoldingAimItem' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isCrawling) == 0x000561, "Member 'UContaminationSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isHooked) == 0x000562, "Member 'UContaminationSubAnimInstance::_isHooked' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isDead) == 0x000563, "Member 'UContaminationSubAnimInstance::_isDead' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isFrightScreaming) == 0x000564, "Member 'UContaminationSubAnimInstance::_isFrightScreaming' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isHoldingSmallItem) == 0x000565, "Member 'UContaminationSubAnimInstance::_isHoldingSmallItem' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isUsingAimItem) == 0x000566, "Member 'UContaminationSubAnimInstance::_isUsingAimItem' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isHoldingHandleItem) == 0x000567, "Member 'UContaminationSubAnimInstance::_isHoldingHandleItem' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isInjured) == 0x000568, "Member 'UContaminationSubAnimInstance::_isInjured' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _isCarried) == 0x000569, "Member 'UContaminationSubAnimInstance::_isCarried' has a wrong offset!");
static_assert(offsetof(UContaminationSubAnimInstance, _interactionType) == 0x00056A, "Member 'UContaminationSubAnimInstance::_interactionType' has a wrong offset!");

// Class TheK24.Counterforce
// 0x0028 (0x03F0 - 0x03C8)
class UCounterforce final : public UPerk
{
public:
	uint8                                         Pad_3C8[0x4];                                      // 0x03C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _totemAuraVisibleDuration[0x3];                    // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _startingTotemCleanseSpeedBonus[0x3];              // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _stackableTotemCleanseSpeedBonus[0x3];             // 0x03E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Multicast_ShowTotemAura(class ATotem* totem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Counterforce">();
	}
	static class UCounterforce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCounterforce>();
	}
};
static_assert(alignof(UCounterforce) == 0x000008, "Wrong alignment on UCounterforce");
static_assert(sizeof(UCounterforce) == 0x0003F0, "Wrong size on UCounterforce");
static_assert(offsetof(UCounterforce, _totemAuraVisibleDuration) == 0x0003CC, "Member 'UCounterforce::_totemAuraVisibleDuration' has a wrong offset!");
static_assert(offsetof(UCounterforce, _startingTotemCleanseSpeedBonus) == 0x0003D8, "Member 'UCounterforce::_startingTotemCleanseSpeedBonus' has a wrong offset!");
static_assert(offsetof(UCounterforce, _stackableTotemCleanseSpeedBonus) == 0x0003E4, "Member 'UCounterforce::_stackableTotemCleanseSpeedBonus' has a wrong offset!");

// Class TheK24.EnvQueryContext_ZombiePatrolAreaPoint
// 0x0000 (0x0030 - 0x0030)
class UEnvQueryContext_ZombiePatrolAreaPoint final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_ZombiePatrolAreaPoint">();
	}
	static class UEnvQueryContext_ZombiePatrolAreaPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_ZombiePatrolAreaPoint>();
	}
};
static_assert(alignof(UEnvQueryContext_ZombiePatrolAreaPoint) == 0x000008, "Wrong alignment on UEnvQueryContext_ZombiePatrolAreaPoint");
static_assert(sizeof(UEnvQueryContext_ZombiePatrolAreaPoint) == 0x000030, "Wrong size on UEnvQueryContext_ZombiePatrolAreaPoint");

// Class TheK24.Eruption
// 0x0050 (0x0418 - 0x03C8)
class UEruption final : public UPerk
{
public:
	TArray<class AGenerator*>                     _server_affectedGenerators;                        // 0x03C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          _isPerkEnabled;                                    // 0x03D8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D9[0x3];                                      // 0x03D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _generatorRegressPercentage[0x3];                  // 0x03DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorImposedStatusEffectDuration[0x3];         // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _perkCooldownDuration[0x3];                        // 0x03F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _screamRevealLocationDuration;                     // 0x0400(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _survivorEffectClass;                              // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnGeneratorHighlightEnd(class AGenerator* highlightedGenerator);
	void Cosmetic_OnGeneratorHighlightStart(class AGenerator* highlightedGenerator);
	void MakeSurvivorScreamCosmetic(const class ADBDPlayer* screamingSurvivor);
	void Multicast_HighlightGenerator(class AGenerator* generator);
	void Multicast_TriggerPerk(const TArray<class AGenerator*>& explodingGenerators);

	float GetGeneratorRegressPercentageAtLevel() const;
	float GetScreamRevealLocationDuration() const;
	float GetSurvivorImposedStatusEffectDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Eruption">();
	}
	static class UEruption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEruption>();
	}
};
static_assert(alignof(UEruption) == 0x000008, "Wrong alignment on UEruption");
static_assert(sizeof(UEruption) == 0x000418, "Wrong size on UEruption");
static_assert(offsetof(UEruption, _server_affectedGenerators) == 0x0003C8, "Member 'UEruption::_server_affectedGenerators' has a wrong offset!");
static_assert(offsetof(UEruption, _isPerkEnabled) == 0x0003D8, "Member 'UEruption::_isPerkEnabled' has a wrong offset!");
static_assert(offsetof(UEruption, _generatorRegressPercentage) == 0x0003DC, "Member 'UEruption::_generatorRegressPercentage' has a wrong offset!");
static_assert(offsetof(UEruption, _survivorImposedStatusEffectDuration) == 0x0003E8, "Member 'UEruption::_survivorImposedStatusEffectDuration' has a wrong offset!");
static_assert(offsetof(UEruption, _perkCooldownDuration) == 0x0003F4, "Member 'UEruption::_perkCooldownDuration' has a wrong offset!");
static_assert(offsetof(UEruption, _screamRevealLocationDuration) == 0x000400, "Member 'UEruption::_screamRevealLocationDuration' has a wrong offset!");
static_assert(offsetof(UEruption, _survivorEffectClass) == 0x000408, "Member 'UEruption::_survivorEffectClass' has a wrong offset!");

// Class TheK24.EruptionIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UEruptionIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EruptionIconStrategy">();
	}
	static class UEruptionIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEruptionIconStrategy>();
	}
};
static_assert(alignof(UEruptionIconStrategy) == 0x000008, "Wrong alignment on UEruptionIconStrategy");
static_assert(sizeof(UEruptionIconStrategy) == 0x000038, "Wrong size on UEruptionIconStrategy");

// Class TheK24.Flashbang
// 0x0028 (0x03F0 - 0x03C8)
class UFlashbang final : public UPerk
{
public:
	uint8                                         Pad_3C8[0x10];                                     // 0x03C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AGenerator*                             _generatorBeingRepaired;                           // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _generatorsRepairTargetProgression;                // 0x03E0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _generatorRepairPercentToCraftFlashbang[0x3];      // 0x03E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnRepairProgressApplied(float individualChargeAmount, float totalChargeAmount, class AActor* chargeInstigator, bool wasCoop, float deltaTime);
	void Client_OnGeneratorRepairProgressionTargetAchieved();
	void Cosmetic_OnGeneratorRepairProgressionTargetAchieved();
	void OnRep_GeneratorsRepairProgress();

	float GetGeneratorRepairPercentToCraftFlashbangAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Flashbang">();
	}
	static class UFlashbang* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlashbang>();
	}
};
static_assert(alignof(UFlashbang) == 0x000008, "Wrong alignment on UFlashbang");
static_assert(sizeof(UFlashbang) == 0x0003F0, "Wrong size on UFlashbang");
static_assert(offsetof(UFlashbang, _generatorBeingRepaired) == 0x0003D8, "Member 'UFlashbang::_generatorBeingRepaired' has a wrong offset!");
static_assert(offsetof(UFlashbang, _generatorsRepairTargetProgression) == 0x0003E0, "Member 'UFlashbang::_generatorsRepairTargetProgression' has a wrong offset!");
static_assert(offsetof(UFlashbang, _generatorRepairPercentToCraftFlashbang) == 0x0003E4, "Member 'UFlashbang::_generatorRepairPercentToCraftFlashbang' has a wrong offset!");

// Class TheK24.GeneratorBlastMinePlacerComponent
// 0x0028 (0x00E0 - 0x00B8)
class UGeneratorBlastMinePlacerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _mineRelativeHeightFromGenerator;                  // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABlastMineFirecracker*                  _blastMine;                                        // 0x00D8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_BlastMine();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorBlastMinePlacerComponent">();
	}
	static class UGeneratorBlastMinePlacerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorBlastMinePlacerComponent>();
	}
};
static_assert(alignof(UGeneratorBlastMinePlacerComponent) == 0x000008, "Wrong alignment on UGeneratorBlastMinePlacerComponent");
static_assert(sizeof(UGeneratorBlastMinePlacerComponent) == 0x0000E0, "Wrong size on UGeneratorBlastMinePlacerComponent");
static_assert(offsetof(UGeneratorBlastMinePlacerComponent, _mineRelativeHeightFromGenerator) == 0x0000D0, "Member 'UGeneratorBlastMinePlacerComponent::_mineRelativeHeightFromGenerator' has a wrong offset!");
static_assert(offsetof(UGeneratorBlastMinePlacerComponent, _blastMine) == 0x0000D8, "Member 'UGeneratorBlastMinePlacerComponent::_blastMine' has a wrong offset!");

// Class TheK24.Hysteria
// 0x0078 (0x0440 - 0x03C8)
class UHysteria final : public UPerk
{
public:
	float                                         _obliviousEffectDuration[0x3];                     // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _perkCooldownDuration[0x3];                        // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UHysteriaObliviousEffect>   _obliviousEffectClass;                             // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ACamperPlayer*, class UHysteriaObliviousEffect*> _obliviousEffectPerSurvivorMap;      // 0x03F0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Hysteria">();
	}
	static class UHysteria* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHysteria>();
	}
};
static_assert(alignof(UHysteria) == 0x000008, "Wrong alignment on UHysteria");
static_assert(sizeof(UHysteria) == 0x000440, "Wrong size on UHysteria");
static_assert(offsetof(UHysteria, _obliviousEffectDuration) == 0x0003C8, "Member 'UHysteria::_obliviousEffectDuration' has a wrong offset!");
static_assert(offsetof(UHysteria, _perkCooldownDuration) == 0x0003D4, "Member 'UHysteria::_perkCooldownDuration' has a wrong offset!");
static_assert(offsetof(UHysteria, _obliviousEffectClass) == 0x0003E8, "Member 'UHysteria::_obliviousEffectClass' has a wrong offset!");
static_assert(offsetof(UHysteria, _obliviousEffectPerSurvivorMap) == 0x0003F0, "Member 'UHysteria::_obliviousEffectPerSurvivorMap' has a wrong offset!");

// Class TheK24.HysteriaObliviousEffect
// 0x0000 (0x0360 - 0x0360)
class UHysteriaObliviousEffect final : public UTimedObliviousEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HysteriaObliviousEffect">();
	}
	static class UHysteriaObliviousEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHysteriaObliviousEffect>();
	}
};
static_assert(alignof(UHysteriaObliviousEffect) == 0x000008, "Wrong alignment on UHysteriaObliviousEffect");
static_assert(sizeof(UHysteriaObliviousEffect) == 0x000360, "Wrong size on UHysteriaObliviousEffect");

// Class TheK24.InClosetFlashbangItemCraftInteraction
// 0x0000 (0x0630 - 0x0630)
class UInClosetFlashbangItemCraftInteraction final : public UItemCraftInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InClosetFlashbangItemCraftInteraction">();
	}
	static class UInClosetFlashbangItemCraftInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInClosetFlashbangItemCraftInteraction>();
	}
};
static_assert(alignof(UInClosetFlashbangItemCraftInteraction) == 0x000010, "Wrong alignment on UInClosetFlashbangItemCraftInteraction");
static_assert(sizeof(UInClosetFlashbangItemCraftInteraction) == 0x000630, "Wrong size on UInClosetFlashbangItemCraftInteraction");

// Class TheK24.IncreaseZombiesSpeedStatusEffect
// 0x0008 (0x0358 - 0x0350)
class UIncreaseZombiesSpeedStatusEffect final : public UStatusEffect
{
public:
	float                                         _zombieSpeedAdditive;                              // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncreaseZombiesSpeedStatusEffect">();
	}
	static class UIncreaseZombiesSpeedStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIncreaseZombiesSpeedStatusEffect>();
	}
};
static_assert(alignof(UIncreaseZombiesSpeedStatusEffect) == 0x000008, "Wrong alignment on UIncreaseZombiesSpeedStatusEffect");
static_assert(sizeof(UIncreaseZombiesSpeedStatusEffect) == 0x000358, "Wrong size on UIncreaseZombiesSpeedStatusEffect");
static_assert(offsetof(UIncreaseZombiesSpeedStatusEffect, _zombieSpeedAdditive) == 0x000350, "Member 'UIncreaseZombiesSpeedStatusEffect::_zombieSpeedAdditive' has a wrong offset!");

// Class TheK24.InjectSerumInteraction
// 0x00C0 (0x0800 - 0x0740)
class UInjectSerumInteraction : public UChargeableInteractionDefinition
{
public:
	struct FTunableStat                           _injectSerumKillerInstinctTime;                    // 0x0740(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C0[0x8];                                      // 0x07C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _scoreEvent;                                       // 0x07C8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D4[0x4];                                      // 0x07D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _serumApplyHeal;                                   // 0x07D8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_CureSurvivor(class ACamperPlayer* camperPlayer);
	void OnKillerSet(class ASlasherPlayer* killer);
	void OnSurvivorCured_Cosmetic();

	class ACamperPlayer* GetInjectionTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InjectSerumInteraction">();
	}
	static class UInjectSerumInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInjectSerumInteraction>();
	}
};
static_assert(alignof(UInjectSerumInteraction) == 0x000010, "Wrong alignment on UInjectSerumInteraction");
static_assert(sizeof(UInjectSerumInteraction) == 0x000800, "Wrong size on UInjectSerumInteraction");
static_assert(offsetof(UInjectSerumInteraction, _injectSerumKillerInstinctTime) == 0x000740, "Member 'UInjectSerumInteraction::_injectSerumKillerInstinctTime' has a wrong offset!");
static_assert(offsetof(UInjectSerumInteraction, _scoreEvent) == 0x0007C8, "Member 'UInjectSerumInteraction::_scoreEvent' has a wrong offset!");
static_assert(offsetof(UInjectSerumInteraction, _serumApplyHeal) == 0x0007D8, "Member 'UInjectSerumInteraction::_serumApplyHeal' has a wrong offset!");

// Class TheK24.InjectSerumOther
// 0x0000 (0x0800 - 0x0800)
class UInjectSerumOther final : public UInjectSerumInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InjectSerumOther">();
	}
	static class UInjectSerumOther* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInjectSerumOther>();
	}
};
static_assert(alignof(UInjectSerumOther) == 0x000010, "Wrong alignment on UInjectSerumOther");
static_assert(sizeof(UInjectSerumOther) == 0x000800, "Wrong size on UInjectSerumOther");

// Class TheK24.InjectSerumSelf
// 0x0000 (0x0800 - 0x0800)
class UInjectSerumSelf final : public UInjectSerumInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InjectSerumSelf">();
	}
	static class UInjectSerumSelf* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInjectSerumSelf>();
	}
};
static_assert(alignof(UInjectSerumSelf) == 0x000010, "Wrong alignment on UInjectSerumSelf");
static_assert(sizeof(UInjectSerumSelf) == 0x000800, "Wrong size on UInjectSerumSelf");

// Class TheK24.K24AnimInstance
// 0x0020 (0x0620 - 0x0600)
class UK24AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isInPowerMode;                                    // 0x0600(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingPower;                                  // 0x0601(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isK24PowerAttacking;                              // 0x0602(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRequestingPowerAttack;                          // 0x0603(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _powerLevel;                                       // 0x0604(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_608[0x18];                                     // 0x0608(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKillerPowerLevelChanged(int32 powerLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24AnimInstance">();
	}
	static class UK24AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24AnimInstance>();
	}
};
static_assert(alignof(UK24AnimInstance) == 0x000010, "Wrong alignment on UK24AnimInstance");
static_assert(sizeof(UK24AnimInstance) == 0x000620, "Wrong size on UK24AnimInstance");
static_assert(offsetof(UK24AnimInstance, _isInPowerMode) == 0x000600, "Member 'UK24AnimInstance::_isInPowerMode' has a wrong offset!");
static_assert(offsetof(UK24AnimInstance, _isChargingPower) == 0x000601, "Member 'UK24AnimInstance::_isChargingPower' has a wrong offset!");
static_assert(offsetof(UK24AnimInstance, _isK24PowerAttacking) == 0x000602, "Member 'UK24AnimInstance::_isK24PowerAttacking' has a wrong offset!");
static_assert(offsetof(UK24AnimInstance, _isRequestingPowerAttack) == 0x000603, "Member 'UK24AnimInstance::_isRequestingPowerAttack' has a wrong offset!");
static_assert(offsetof(UK24AnimInstance, _powerLevel) == 0x000604, "Member 'UK24AnimInstance::_powerLevel' has a wrong offset!");

// Class TheK24.K24CharacterFXComponent
// 0x0058 (0x0110 - 0x00B8)
class UK24CharacterFXComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(int32 powerlevel)> OnPowerLevelChangedFx;                          // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AZombieCharacter* zombieCharater)> Local_OnKillerHitZombie;  // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              Local_OnKillerContaminatedSurvivor;                // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x28];                                      // 0x00E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Local_OnKillerPowerLevelChanged(int32 powerLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24CharacterFXComponent">();
	}
	static class UK24CharacterFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24CharacterFXComponent>();
	}
};
static_assert(alignof(UK24CharacterFXComponent) == 0x000008, "Wrong alignment on UK24CharacterFXComponent");
static_assert(sizeof(UK24CharacterFXComponent) == 0x000110, "Wrong size on UK24CharacterFXComponent");
static_assert(offsetof(UK24CharacterFXComponent, OnPowerLevelChangedFx) == 0x0000B8, "Member 'UK24CharacterFXComponent::OnPowerLevelChangedFx' has a wrong offset!");
static_assert(offsetof(UK24CharacterFXComponent, Local_OnKillerHitZombie) == 0x0000C8, "Member 'UK24CharacterFXComponent::Local_OnKillerHitZombie' has a wrong offset!");
static_assert(offsetof(UK24CharacterFXComponent, Local_OnKillerContaminatedSurvivor) == 0x0000D8, "Member 'UK24CharacterFXComponent::Local_OnKillerContaminatedSurvivor' has a wrong offset!");

// Class TheK24.K24CheatComponent
// 0x0010 (0x00C8 - 0x00B8)
class UK24CheatComponent final : public UActorComponent
{
public:
	TSubclassOf<class AZombiesManagement>         _zombieManagementClass;                            // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AZombiesManagement*                     _zombiesManagement;                                // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DBD_K24ComeToMeMyZombies();
	void DBD_K24SetContaminationOnSurvivor(const bool value);
	void DBD_K24SetPowerLevelPoints(const float value);
	void DBD_K24SpawnZombieOnKiller();
	void DBD_K24StartAllZombies();
	void DBD_K24StopAllZombies();
	void DBD_K24ZombieFall(const float Zvalue);
	void DBD_TeleportZombiesTo(float x, float y, float z);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24CheatComponent">();
	}
	static class UK24CheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24CheatComponent>();
	}
};
static_assert(alignof(UK24CheatComponent) == 0x000008, "Wrong alignment on UK24CheatComponent");
static_assert(sizeof(UK24CheatComponent) == 0x0000C8, "Wrong size on UK24CheatComponent");
static_assert(offsetof(UK24CheatComponent, _zombieManagementClass) == 0x0000B8, "Member 'UK24CheatComponent::_zombieManagementClass' has a wrong offset!");
static_assert(offsetof(UK24CheatComponent, _zombiesManagement) == 0x0000C0, "Member 'UK24CheatComponent::_zombiesManagement' has a wrong offset!");

// Class TheK24.K24PounceAttack
// 0x0000 (0x0380 - 0x0380)
class UK24PounceAttack : public UPounceAttack
{
public:
	void Server_HitZombie(class AZombieCharacter* zombie, const float targetLocationTimestamp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24PounceAttack">();
	}
	static class UK24PounceAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24PounceAttack>();
	}
};
static_assert(alignof(UK24PounceAttack) == 0x000010, "Wrong alignment on UK24PounceAttack");
static_assert(sizeof(UK24PounceAttack) == 0x000380, "Wrong size on UK24PounceAttack");

// Class TheK24.K24Power
// 0x0428 (0x08D8 - 0x04B0)
class AK24Power final : public ACollectable
{
public:
	uint8                                         Pad_4B0[0x88];                                     // 0x04B0(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _powerWalkSpeed;                                   // 0x0538(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerWalkSpeedLevel3;                             // 0x0560(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _normalWalkSpeed;                                  // 0x0588(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerMouseYawScale;                               // 0x05B0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerYawAdjustTime;                               // 0x05D8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerGamePadYawScale;                             // 0x0600(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _activateK24PowerCharge;                           // 0x0628(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _activateK24PowerSecondsToCharge;                  // 0x0630(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _activatePowerChargeSpeedCurve;                    // 0x0658(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _activatePowerChargeLvl3SpeedCurve;                // 0x0660(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _playedPowerChargeSpeedCurve;                      // 0x0668(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDefinition*                 _k24PowerCooldownInteraction;                      // 0x0670(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _whipLengthLevel1;                                 // 0x0678(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _whipLengthLevel2;                                 // 0x06A0(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _whipLengthLevel3;                                 // 0x06C8(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class USurvivorContaminationComponent> _contaminationComponentBP;                    // 0x06F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _powerChargeSurvivorContaminatedPoint;             // 0x06F8(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _powerChargeZombieKilledPoint;                     // 0x0778(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _powerChargeSurvivorHitPoint;                      // 0x07F8(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _powerLevelPoints;                                 // 0x0878(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_87C[0x4];                                      // 0x087C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _powerLevelPointsToLevel2;                         // 0x0880(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerLevelPointsToLevel3;                         // 0x08A8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D0[0x8];                                      // 0x08D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorContaminated(const EContaminator contaminator);
	void Multicast_PowerDestroyBreakable(class ABreakableBase* breakable);
	void Multicast_PowerDestroyPallet(class APallet* pallet);
	void OnPowerLevelChanged_Cosmetic(const int32 powerLevel);
	void OnPowerStartCharge_Cosmetic();
	void OnPowerStop_Cosmetic();
	void OnRep_PowerLevelPoints();
	void PowerCooldownEnd_Cosmetic();
	void PowerHitStateEnd_Cosmetic(const struct FVector& whipStartLocation, const struct FVector& whipEndLocation);
	void Server_KillAZombie(class AZombieCharacter* zombie, EAttackType attackType);
	void Server_PowerDestroyBreakable(class ABreakableBase* breakable);
	void Server_PowerDestroyPallet(class APallet* pallet);
	void WhipAttackEnd_Cosmetic();
	void WhipAttackHit_Cosmetic(const struct FVector& whipStartLocation, const struct FVector& impactPointLocation, const struct FVector& whipEndLocation, bool isFirstHit, const struct FVector& impactNormal, const class FName phyMaterial, bool hitACharacter);
	void WhipAttackMove_Cosmetic(const struct FVector& whipStartLocation, const struct FVector& whipEndLocation, bool isFirstRayCast);
	void WhipAttackStart_Cosmetic();

	int32 GetPowerLevel() const;
	float GetWhipLength() const;
	bool IsInPower() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24Power">();
	}
	static class AK24Power* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK24Power>();
	}
};
static_assert(alignof(AK24Power) == 0x000008, "Wrong alignment on AK24Power");
static_assert(sizeof(AK24Power) == 0x0008D8, "Wrong size on AK24Power");
static_assert(offsetof(AK24Power, _powerWalkSpeed) == 0x000538, "Member 'AK24Power::_powerWalkSpeed' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerWalkSpeedLevel3) == 0x000560, "Member 'AK24Power::_powerWalkSpeedLevel3' has a wrong offset!");
static_assert(offsetof(AK24Power, _normalWalkSpeed) == 0x000588, "Member 'AK24Power::_normalWalkSpeed' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerMouseYawScale) == 0x0005B0, "Member 'AK24Power::_powerMouseYawScale' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerYawAdjustTime) == 0x0005D8, "Member 'AK24Power::_powerYawAdjustTime' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerGamePadYawScale) == 0x000600, "Member 'AK24Power::_powerGamePadYawScale' has a wrong offset!");
static_assert(offsetof(AK24Power, _activateK24PowerCharge) == 0x000628, "Member 'AK24Power::_activateK24PowerCharge' has a wrong offset!");
static_assert(offsetof(AK24Power, _activateK24PowerSecondsToCharge) == 0x000630, "Member 'AK24Power::_activateK24PowerSecondsToCharge' has a wrong offset!");
static_assert(offsetof(AK24Power, _activatePowerChargeSpeedCurve) == 0x000658, "Member 'AK24Power::_activatePowerChargeSpeedCurve' has a wrong offset!");
static_assert(offsetof(AK24Power, _activatePowerChargeLvl3SpeedCurve) == 0x000660, "Member 'AK24Power::_activatePowerChargeLvl3SpeedCurve' has a wrong offset!");
static_assert(offsetof(AK24Power, _playedPowerChargeSpeedCurve) == 0x000668, "Member 'AK24Power::_playedPowerChargeSpeedCurve' has a wrong offset!");
static_assert(offsetof(AK24Power, _k24PowerCooldownInteraction) == 0x000670, "Member 'AK24Power::_k24PowerCooldownInteraction' has a wrong offset!");
static_assert(offsetof(AK24Power, _whipLengthLevel1) == 0x000678, "Member 'AK24Power::_whipLengthLevel1' has a wrong offset!");
static_assert(offsetof(AK24Power, _whipLengthLevel2) == 0x0006A0, "Member 'AK24Power::_whipLengthLevel2' has a wrong offset!");
static_assert(offsetof(AK24Power, _whipLengthLevel3) == 0x0006C8, "Member 'AK24Power::_whipLengthLevel3' has a wrong offset!");
static_assert(offsetof(AK24Power, _contaminationComponentBP) == 0x0006F0, "Member 'AK24Power::_contaminationComponentBP' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerChargeSurvivorContaminatedPoint) == 0x0006F8, "Member 'AK24Power::_powerChargeSurvivorContaminatedPoint' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerChargeZombieKilledPoint) == 0x000778, "Member 'AK24Power::_powerChargeZombieKilledPoint' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerChargeSurvivorHitPoint) == 0x0007F8, "Member 'AK24Power::_powerChargeSurvivorHitPoint' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerLevelPoints) == 0x000878, "Member 'AK24Power::_powerLevelPoints' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerLevelPointsToLevel2) == 0x000880, "Member 'AK24Power::_powerLevelPointsToLevel2' has a wrong offset!");
static_assert(offsetof(AK24Power, _powerLevelPointsToLevel3) == 0x0008A8, "Member 'AK24Power::_powerLevelPointsToLevel3' has a wrong offset!");

// Class TheK24.K24PowerAnimInstance
// 0x0160 (0x0420 - 0x02C0)
class UK24PowerAnimInstance final : public UAnimInstance
{
public:
	class ASlasherPlayer*                         _owningKiller;                                     // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInPowerMode;                                    // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isChargingPower;                                  // 0x02C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isK24PowerAttacking;                              // 0x02CA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRequestingPowerAttack;                          // 0x02CB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _tentacleLength;                                   // 0x02CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFirstPersonView;                                // 0x02D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackSubstate                               _attackSubState;                                   // 0x02D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIntroCompleted;                                 // 0x02D2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isLevelReadyToPlay;                               // 0x02D3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _powerLevel;                                       // 0x02D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _forwardVelocity;                                  // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _lateralVelocity;                                  // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x02E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isKilling;                                        // 0x02E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E2[0x6];                                      // 0x02E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          _swingIdleTPVSequences[0x3];                       // 0x02E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _wipeIdleTPVSequences[0x3];                        // 0x0300(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _missIdleTPVSequences[0x3];                        // 0x0318(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _bowIdleTPVSequences[0x3];                         // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _swingIdleTPVSequence;                             // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _wipeIdleTPVSequence;                              // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _missIdleTPVSequence;                              // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _bowIdleTPVSequence;                               // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _swingLocoTPVSequence;                             // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _wipeLocoTPVSequence;                              // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _missLocoTPVSequence;                              // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _bowLocoTPVSequence;                               // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _swingFPVSequences[0x3];                           // 0x0388(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _wipeFPVSequences[0x3];                            // 0x03A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _missFPVSequences[0x3];                            // 0x03B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _bowFPVSequences[0x3];                             // 0x03D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _swingFPVSequence;                                 // 0x03E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _wipeFPVSequence;                                  // 0x03F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _missFPVSequence;                                  // 0x03F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          _bowFPVSequence;                                   // 0x0400(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AK24Power*                              _k24Power;                                         // 0x0408(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x10];                                     // 0x0410(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIntroCompleted();
	void OnKillerPowerLevelChanged(int32 powerLevel);
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24PowerAnimInstance">();
	}
	static class UK24PowerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24PowerAnimInstance>();
	}
};
static_assert(alignof(UK24PowerAnimInstance) == 0x000010, "Wrong alignment on UK24PowerAnimInstance");
static_assert(sizeof(UK24PowerAnimInstance) == 0x000420, "Wrong size on UK24PowerAnimInstance");
static_assert(offsetof(UK24PowerAnimInstance, _owningKiller) == 0x0002C0, "Member 'UK24PowerAnimInstance::_owningKiller' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isInPowerMode) == 0x0002C8, "Member 'UK24PowerAnimInstance::_isInPowerMode' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isChargingPower) == 0x0002C9, "Member 'UK24PowerAnimInstance::_isChargingPower' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isK24PowerAttacking) == 0x0002CA, "Member 'UK24PowerAnimInstance::_isK24PowerAttacking' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isRequestingPowerAttack) == 0x0002CB, "Member 'UK24PowerAnimInstance::_isRequestingPowerAttack' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _tentacleLength) == 0x0002CC, "Member 'UK24PowerAnimInstance::_tentacleLength' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isFirstPersonView) == 0x0002D0, "Member 'UK24PowerAnimInstance::_isFirstPersonView' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _attackSubState) == 0x0002D1, "Member 'UK24PowerAnimInstance::_attackSubState' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isIntroCompleted) == 0x0002D2, "Member 'UK24PowerAnimInstance::_isIntroCompleted' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isLevelReadyToPlay) == 0x0002D3, "Member 'UK24PowerAnimInstance::_isLevelReadyToPlay' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _powerLevel) == 0x0002D4, "Member 'UK24PowerAnimInstance::_powerLevel' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _forwardVelocity) == 0x0002D8, "Member 'UK24PowerAnimInstance::_forwardVelocity' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _lateralVelocity) == 0x0002DC, "Member 'UK24PowerAnimInstance::_lateralVelocity' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isIdle) == 0x0002E0, "Member 'UK24PowerAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _isKilling) == 0x0002E1, "Member 'UK24PowerAnimInstance::_isKilling' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _swingIdleTPVSequences) == 0x0002E8, "Member 'UK24PowerAnimInstance::_swingIdleTPVSequences' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _wipeIdleTPVSequences) == 0x000300, "Member 'UK24PowerAnimInstance::_wipeIdleTPVSequences' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _missIdleTPVSequences) == 0x000318, "Member 'UK24PowerAnimInstance::_missIdleTPVSequences' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _bowIdleTPVSequences) == 0x000330, "Member 'UK24PowerAnimInstance::_bowIdleTPVSequences' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _swingIdleTPVSequence) == 0x000348, "Member 'UK24PowerAnimInstance::_swingIdleTPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _wipeIdleTPVSequence) == 0x000350, "Member 'UK24PowerAnimInstance::_wipeIdleTPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _missIdleTPVSequence) == 0x000358, "Member 'UK24PowerAnimInstance::_missIdleTPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _bowIdleTPVSequence) == 0x000360, "Member 'UK24PowerAnimInstance::_bowIdleTPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _swingLocoTPVSequence) == 0x000368, "Member 'UK24PowerAnimInstance::_swingLocoTPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _wipeLocoTPVSequence) == 0x000370, "Member 'UK24PowerAnimInstance::_wipeLocoTPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _missLocoTPVSequence) == 0x000378, "Member 'UK24PowerAnimInstance::_missLocoTPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _bowLocoTPVSequence) == 0x000380, "Member 'UK24PowerAnimInstance::_bowLocoTPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _swingFPVSequences) == 0x000388, "Member 'UK24PowerAnimInstance::_swingFPVSequences' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _wipeFPVSequences) == 0x0003A0, "Member 'UK24PowerAnimInstance::_wipeFPVSequences' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _missFPVSequences) == 0x0003B8, "Member 'UK24PowerAnimInstance::_missFPVSequences' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _bowFPVSequences) == 0x0003D0, "Member 'UK24PowerAnimInstance::_bowFPVSequences' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _swingFPVSequence) == 0x0003E8, "Member 'UK24PowerAnimInstance::_swingFPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _wipeFPVSequence) == 0x0003F0, "Member 'UK24PowerAnimInstance::_wipeFPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _missFPVSequence) == 0x0003F8, "Member 'UK24PowerAnimInstance::_missFPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _bowFPVSequence) == 0x000400, "Member 'UK24PowerAnimInstance::_bowFPVSequence' has a wrong offset!");
static_assert(offsetof(UK24PowerAnimInstance, _k24Power) == 0x000408, "Member 'UK24PowerAnimInstance::_k24Power' has a wrong offset!");

// Class TheK24.k24PowerCooldownInteraction
// 0x0040 (0x0660 - 0x0620)
class Uk24PowerCooldownInteraction final : public UInteractionDefinition
{
public:
	struct FDBDTunableRowHandle                   _k24PowerCooldownTime;                             // 0x0618(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _cooldownSpeedCurve;                               // 0x0640(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _cooldownLvl3SpeedCurve;                           // 0x0648(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _playedCooldownSpeedCurve;                         // 0x0650(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_658[0x8];                                      // 0x0658(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetK24Power(class AK24Power* k24Power);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"k24PowerCooldownInteraction">();
	}
	static class Uk24PowerCooldownInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<Uk24PowerCooldownInteraction>();
	}
};
static_assert(alignof(Uk24PowerCooldownInteraction) == 0x000010, "Wrong alignment on Uk24PowerCooldownInteraction");
static_assert(sizeof(Uk24PowerCooldownInteraction) == 0x000660, "Wrong size on Uk24PowerCooldownInteraction");
static_assert(offsetof(Uk24PowerCooldownInteraction, _k24PowerCooldownTime) == 0x000618, "Member 'Uk24PowerCooldownInteraction::_k24PowerCooldownTime' has a wrong offset!");
static_assert(offsetof(Uk24PowerCooldownInteraction, _cooldownSpeedCurve) == 0x000640, "Member 'Uk24PowerCooldownInteraction::_cooldownSpeedCurve' has a wrong offset!");
static_assert(offsetof(Uk24PowerCooldownInteraction, _cooldownLvl3SpeedCurve) == 0x000648, "Member 'Uk24PowerCooldownInteraction::_cooldownLvl3SpeedCurve' has a wrong offset!");
static_assert(offsetof(Uk24PowerCooldownInteraction, _playedCooldownSpeedCurve) == 0x000650, "Member 'Uk24PowerCooldownInteraction::_playedCooldownSpeedCurve' has a wrong offset!");

// Class TheK24.K24PowerPresentationItemProgressComponent
// 0x0008 (0x00C0 - 0x00B8)
class UK24PowerPresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	class AK24Power*                              _k24Power;                                         // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetK24Power(class AK24Power* k24Power);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24PowerPresentationItemProgressComponent">();
	}
	static class UK24PowerPresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24PowerPresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK24PowerPresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK24PowerPresentationItemProgressComponent");
static_assert(sizeof(UK24PowerPresentationItemProgressComponent) == 0x0000C0, "Wrong size on UK24PowerPresentationItemProgressComponent");
static_assert(offsetof(UK24PowerPresentationItemProgressComponent, _k24Power) == 0x0000B8, "Member 'UK24PowerPresentationItemProgressComponent::_k24Power' has a wrong offset!");

// Class TheK24.K24SlashAttack
// 0x0000 (0x0380 - 0x0380)
class UK24SlashAttack final : public UK24PounceAttack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24SlashAttack">();
	}
	static class UK24SlashAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24SlashAttack>();
	}
};
static_assert(alignof(UK24SlashAttack) == 0x000010, "Wrong alignment on UK24SlashAttack");
static_assert(sizeof(UK24SlashAttack) == 0x000380, "Wrong size on UK24SlashAttack");

// Class TheK24.K24WhipAttack
// 0x0070 (0x03F0 - 0x0380)
class UK24WhipAttack final : public UPounceAttack
{
public:
	struct FDBDTunableRowHandle                   _attackSphereTraceRadius;                          // 0x0380(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _attackMinDistanceToObstruction;                   // 0x03A8(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _whipMovementFromOffset;                           // 0x03D0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _whipMovementToOffset;                             // 0x03DC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x8];                                      // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_ContaminationResult(class ADBDPlayer* target, bool isValid);
	void Server_ContaminatePlayer(class ACamperPlayer* target, const float targetLocationTimestamp);
	void Server_HitBreakableOrZombie();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24WhipAttack">();
	}
	static class UK24WhipAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24WhipAttack>();
	}
};
static_assert(alignof(UK24WhipAttack) == 0x000010, "Wrong alignment on UK24WhipAttack");
static_assert(sizeof(UK24WhipAttack) == 0x0003F0, "Wrong size on UK24WhipAttack");
static_assert(offsetof(UK24WhipAttack, _attackSphereTraceRadius) == 0x000380, "Member 'UK24WhipAttack::_attackSphereTraceRadius' has a wrong offset!");
static_assert(offsetof(UK24WhipAttack, _attackMinDistanceToObstruction) == 0x0003A8, "Member 'UK24WhipAttack::_attackMinDistanceToObstruction' has a wrong offset!");
static_assert(offsetof(UK24WhipAttack, _whipMovementFromOffset) == 0x0003D0, "Member 'UK24WhipAttack::_whipMovementFromOffset' has a wrong offset!");
static_assert(offsetof(UK24WhipAttack, _whipMovementToOffset) == 0x0003DC, "Member 'UK24WhipAttack::_whipMovementToOffset' has a wrong offset!");

// Class TheK24.K24WhipAttackOpenSubstate
// 0x0008 (0x0138 - 0x0130)
class UK24WhipAttackOpenSubstate final : public UPounceAttackOpenSubstate
{
public:
	class UCurveFloat*                            _lvl3SpeedCurve;                                   // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24WhipAttackOpenSubstate">();
	}
	static class UK24WhipAttackOpenSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24WhipAttackOpenSubstate>();
	}
};
static_assert(alignof(UK24WhipAttackOpenSubstate) == 0x000008, "Wrong alignment on UK24WhipAttackOpenSubstate");
static_assert(sizeof(UK24WhipAttackOpenSubstate) == 0x000138, "Wrong size on UK24WhipAttackOpenSubstate");
static_assert(offsetof(UK24WhipAttackOpenSubstate, _lvl3SpeedCurve) == 0x000130, "Member 'UK24WhipAttackOpenSubstate::_lvl3SpeedCurve' has a wrong offset!");

// Class TheK24.K24WhipAttackHittingSubstate
// 0x00C0 (0x0260 - 0x01A0)
class UK24WhipAttackHittingSubstate final : public UPounceAttackHittingSubstate
{
public:
	struct FDBDTunableRowHandle                   _attackSphereTraceRadius;                          // 0x01A0(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerAttackBreakObjectLevel;                      // 0x01C8(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _powerCanBreakObjectAfterAPlayerDamage;            // 0x01F0(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _whipMovementFromOffset;                           // 0x0218(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _whipMovementToOffset;                             // 0x0224(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _whipMovementCurve;                                // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _lvl3SpeedCurve;                                   // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _whipGroundDetectionOffset;                        // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_244[0x1C];                                     // 0x0244(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24WhipAttackHittingSubstate">();
	}
	static class UK24WhipAttackHittingSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24WhipAttackHittingSubstate>();
	}
};
static_assert(alignof(UK24WhipAttackHittingSubstate) == 0x000008, "Wrong alignment on UK24WhipAttackHittingSubstate");
static_assert(sizeof(UK24WhipAttackHittingSubstate) == 0x000260, "Wrong size on UK24WhipAttackHittingSubstate");
static_assert(offsetof(UK24WhipAttackHittingSubstate, _attackSphereTraceRadius) == 0x0001A0, "Member 'UK24WhipAttackHittingSubstate::_attackSphereTraceRadius' has a wrong offset!");
static_assert(offsetof(UK24WhipAttackHittingSubstate, _powerAttackBreakObjectLevel) == 0x0001C8, "Member 'UK24WhipAttackHittingSubstate::_powerAttackBreakObjectLevel' has a wrong offset!");
static_assert(offsetof(UK24WhipAttackHittingSubstate, _powerCanBreakObjectAfterAPlayerDamage) == 0x0001F0, "Member 'UK24WhipAttackHittingSubstate::_powerCanBreakObjectAfterAPlayerDamage' has a wrong offset!");
static_assert(offsetof(UK24WhipAttackHittingSubstate, _whipMovementFromOffset) == 0x000218, "Member 'UK24WhipAttackHittingSubstate::_whipMovementFromOffset' has a wrong offset!");
static_assert(offsetof(UK24WhipAttackHittingSubstate, _whipMovementToOffset) == 0x000224, "Member 'UK24WhipAttackHittingSubstate::_whipMovementToOffset' has a wrong offset!");
static_assert(offsetof(UK24WhipAttackHittingSubstate, _whipMovementCurve) == 0x000230, "Member 'UK24WhipAttackHittingSubstate::_whipMovementCurve' has a wrong offset!");
static_assert(offsetof(UK24WhipAttackHittingSubstate, _lvl3SpeedCurve) == 0x000238, "Member 'UK24WhipAttackHittingSubstate::_lvl3SpeedCurve' has a wrong offset!");
static_assert(offsetof(UK24WhipAttackHittingSubstate, _whipGroundDetectionOffset) == 0x000240, "Member 'UK24WhipAttackHittingSubstate::_whipGroundDetectionOffset' has a wrong offset!");

// Class TheK24.K24WhipAttackSuccessSubstate
// 0x0000 (0x0118 - 0x0118)
class UK24WhipAttackSuccessSubstate final : public UPounceAttackSuccessSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24WhipAttackSuccessSubstate">();
	}
	static class UK24WhipAttackSuccessSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24WhipAttackSuccessSubstate>();
	}
};
static_assert(alignof(UK24WhipAttackSuccessSubstate) == 0x000008, "Wrong alignment on UK24WhipAttackSuccessSubstate");
static_assert(sizeof(UK24WhipAttackSuccessSubstate) == 0x000118, "Wrong size on UK24WhipAttackSuccessSubstate");

// Class TheK24.K24WhipAttackMissSubstate
// 0x0000 (0x0120 - 0x0120)
class UK24WhipAttackMissSubstate final : public UPounceAttackMissSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24WhipAttackMissSubstate">();
	}
	static class UK24WhipAttackMissSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24WhipAttackMissSubstate>();
	}
};
static_assert(alignof(UK24WhipAttackMissSubstate) == 0x000008, "Wrong alignment on UK24WhipAttackMissSubstate");
static_assert(sizeof(UK24WhipAttackMissSubstate) == 0x000120, "Wrong size on UK24WhipAttackMissSubstate");

// Class TheK24.K24WhipAttackObstructSubstate
// 0x0000 (0x0128 - 0x0128)
class UK24WhipAttackObstructSubstate final : public UPounceAttackObstructSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K24WhipAttackObstructSubstate">();
	}
	static class UK24WhipAttackObstructSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK24WhipAttackObstructSubstate>();
	}
};
static_assert(alignof(UK24WhipAttackObstructSubstate) == 0x000008, "Wrong alignment on UK24WhipAttackObstructSubstate");
static_assert(sizeof(UK24WhipAttackObstructSubstate) == 0x000128, "Wrong size on UK24WhipAttackObstructSubstate");

// Class TheK24.LethalPursuer
// 0x0018 (0x03E0 - 0x03C8)
class ULethalPursuer final : public UPerk
{
public:
	float                                         _survivorRevealDuration[0x3];                      // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _timedRevealEffect;                                // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Local_OnIntroCompleted();
	void Server_ActivatePerk();

	float GetSurvivorRevealDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LethalPursuer">();
	}
	static class ULethalPursuer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULethalPursuer>();
	}
};
static_assert(alignof(ULethalPursuer) == 0x000008, "Wrong alignment on ULethalPursuer");
static_assert(sizeof(ULethalPursuer) == 0x0003E0, "Wrong size on ULethalPursuer");
static_assert(offsetof(ULethalPursuer, _survivorRevealDuration) == 0x0003C8, "Member 'ULethalPursuer::_survivorRevealDuration' has a wrong offset!");
static_assert(offsetof(ULethalPursuer, _timedRevealEffect) == 0x0003D8, "Member 'ULethalPursuer::_timedRevealEffect' has a wrong offset!");

// Class TheK24.Resurgence
// 0x0010 (0x03D8 - 0x03C8)
class UResurgence final : public UPerk
{
public:
	float                                         _healRegainPercentage[0x3];                        // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Resurgence">();
	}
	static class UResurgence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResurgence>();
	}
};
static_assert(alignof(UResurgence) == 0x000008, "Wrong alignment on UResurgence");
static_assert(sizeof(UResurgence) == 0x0003D8, "Wrong size on UResurgence");
static_assert(offsetof(UResurgence, _healRegainPercentage) == 0x0003C8, "Member 'UResurgence::_healRegainPercentage' has a wrong offset!");

// Class TheK24.RookieSpirit
// 0x0010 (0x03D8 - 0x03C8)
class URookieSpirit final : public UPerk
{
public:
	int32                                         _numberOfGreatSkillChecksOnGeneratorRepair;        // 0x03C8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _numberOfGeneratorRepairGreatSkillChecksRequired[0x3]; // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleGeneratorIsDamagedChanged(class AGenerator* generator, class ADBDPlayer* player);
	void OnRep_NumberOfGreatSkillChecksOnGeneratorRepair();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RookieSpirit">();
	}
	static class URookieSpirit* GetDefaultObj()
	{
		return GetDefaultObjImpl<URookieSpirit>();
	}
};
static_assert(alignof(URookieSpirit) == 0x000008, "Wrong alignment on URookieSpirit");
static_assert(sizeof(URookieSpirit) == 0x0003D8, "Wrong size on URookieSpirit");
static_assert(offsetof(URookieSpirit, _numberOfGreatSkillChecksOnGeneratorRepair) == 0x0003C8, "Member 'URookieSpirit::_numberOfGreatSkillChecksOnGeneratorRepair' has a wrong offset!");
static_assert(offsetof(URookieSpirit, _numberOfGeneratorRepairGreatSkillChecksRequired) == 0x0003CC, "Member 'URookieSpirit::_numberOfGeneratorRepairGreatSkillChecksRequired' has a wrong offset!");

// Class TheK24.SerumOutlineUpdateStrategy
// 0x0000 (0x00E0 - 0x00E0)
class USerumOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SerumOutlineUpdateStrategy">();
	}
	static class USerumOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USerumOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USerumOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USerumOutlineUpdateStrategy");
static_assert(sizeof(USerumOutlineUpdateStrategy) == 0x0000E0, "Wrong size on USerumOutlineUpdateStrategy");

// Class TheK24.SupplyCrateOutlineUpdateStrategy
// 0x0000 (0x00E0 - 0x00E0)
class USupplyCrateOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyCrateOutlineUpdateStrategy">();
	}
	static class USupplyCrateOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyCrateOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USupplyCrateOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USupplyCrateOutlineUpdateStrategy");
static_assert(sizeof(USupplyCrateOutlineUpdateStrategy) == 0x0000E0, "Wrong size on USupplyCrateOutlineUpdateStrategy");

// Class TheK24.SurvivorContaminationComponent
// 0x0150 (0x0208 - 0x00B8)
class USurvivorContaminationComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isContaminated;                                   // 0x00D0(0x0030)(Net, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _injectSerumChargeable;                            // 0x0100(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _injectSerumSecondsToCharge;                       // 0x0108(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _hinderedEffect;                                   // 0x0130(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _contaminationHinderedSeconds;                     // 0x0138(0x0080)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _contaminationHinderedValue;                       // 0x01B8(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E0[0x8];                                      // 0x01E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UInteractionDefinition>> _injectSerumInteractionsClasses;               // 0x01E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UInteractionDefinition*>         _injectSerumInteractions;                          // 0x01F8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Multicast_OnContaminated_Cosmetic(EContaminator contaminator);
	void OnContaminated_Cosmetic(EContaminator contaminator);
	void OnContaminated_SFX_Stinger_Cosmetic();
	void OnContaminationCured_Cosmetic();
	void OnRep_InjectSerumInteractions();
	void OnRep_IsContaminated();

	bool IsContaminated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorContaminationComponent">();
	}
	static class USurvivorContaminationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorContaminationComponent>();
	}
};
static_assert(alignof(USurvivorContaminationComponent) == 0x000008, "Wrong alignment on USurvivorContaminationComponent");
static_assert(sizeof(USurvivorContaminationComponent) == 0x000208, "Wrong size on USurvivorContaminationComponent");
static_assert(offsetof(USurvivorContaminationComponent, _isContaminated) == 0x0000D0, "Member 'USurvivorContaminationComponent::_isContaminated' has a wrong offset!");
static_assert(offsetof(USurvivorContaminationComponent, _injectSerumChargeable) == 0x000100, "Member 'USurvivorContaminationComponent::_injectSerumChargeable' has a wrong offset!");
static_assert(offsetof(USurvivorContaminationComponent, _injectSerumSecondsToCharge) == 0x000108, "Member 'USurvivorContaminationComponent::_injectSerumSecondsToCharge' has a wrong offset!");
static_assert(offsetof(USurvivorContaminationComponent, _hinderedEffect) == 0x000130, "Member 'USurvivorContaminationComponent::_hinderedEffect' has a wrong offset!");
static_assert(offsetof(USurvivorContaminationComponent, _contaminationHinderedSeconds) == 0x000138, "Member 'USurvivorContaminationComponent::_contaminationHinderedSeconds' has a wrong offset!");
static_assert(offsetof(USurvivorContaminationComponent, _contaminationHinderedValue) == 0x0001B8, "Member 'USurvivorContaminationComponent::_contaminationHinderedValue' has a wrong offset!");
static_assert(offsetof(USurvivorContaminationComponent, _injectSerumInteractionsClasses) == 0x0001E8, "Member 'USurvivorContaminationComponent::_injectSerumInteractionsClasses' has a wrong offset!");
static_assert(offsetof(USurvivorContaminationComponent, _injectSerumInteractions) == 0x0001F8, "Member 'USurvivorContaminationComponent::_injectSerumInteractions' has a wrong offset!");

// Class TheK24.TheK24Utilities
// 0x0000 (0x0030 - 0x0030)
class UTheK24Utilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TheK24Utilities">();
	}
	static class UTheK24Utilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTheK24Utilities>();
	}
};
static_assert(alignof(UTheK24Utilities) == 0x000008, "Wrong alignment on UTheK24Utilities");
static_assert(sizeof(UTheK24Utilities) == 0x000030, "Wrong size on UTheK24Utilities");

// Class TheK24.ZombieAcquirePatrolAreaBTService
// 0x0000 (0x00A0 - 0x00A0)
class UZombieAcquirePatrolAreaBTService final : public UBTService_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieAcquirePatrolAreaBTService">();
	}
	static class UZombieAcquirePatrolAreaBTService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieAcquirePatrolAreaBTService>();
	}
};
static_assert(alignof(UZombieAcquirePatrolAreaBTService) == 0x000008, "Wrong alignment on UZombieAcquirePatrolAreaBTService");
static_assert(sizeof(UZombieAcquirePatrolAreaBTService) == 0x0000A0, "Wrong size on UZombieAcquirePatrolAreaBTService");

// Class TheK24.ZombieAcquireTargetBTService
// 0x0000 (0x00A0 - 0x00A0)
class UZombieAcquireTargetBTService final : public UBTService_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieAcquireTargetBTService">();
	}
	static class UZombieAcquireTargetBTService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieAcquireTargetBTService>();
	}
};
static_assert(alignof(UZombieAcquireTargetBTService) == 0x000008, "Wrong alignment on UZombieAcquireTargetBTService");
static_assert(sizeof(UZombieAcquireTargetBTService) == 0x0000A0, "Wrong size on UZombieAcquireTargetBTService");

// Class TheK24.ZombieBlindableComponent
// 0x0008 (0x0248 - 0x0240)
class UZombieBlindableComponent final : public UBlindableBaseComponent
{
public:
	class UGameplayTagContainerComponent*         _ownerObjectState;                                 // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieBlindableComponent">();
	}
	static class UZombieBlindableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieBlindableComponent>();
	}
};
static_assert(alignof(UZombieBlindableComponent) == 0x000008, "Wrong alignment on UZombieBlindableComponent");
static_assert(sizeof(UZombieBlindableComponent) == 0x000248, "Wrong size on UZombieBlindableComponent");
static_assert(offsetof(UZombieBlindableComponent, _ownerObjectState) == 0x000240, "Member 'UZombieBlindableComponent::_ownerObjectState' has a wrong offset!");

// Class TheK24.ZombieBlindingFXComponent
// 0x0000 (0x0150 - 0x0150)
class UZombieBlindingFXComponent final : public UKillerBlindingFXComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieBlindingFXComponent">();
	}
	static class UZombieBlindingFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieBlindingFXComponent>();
	}
};
static_assert(alignof(UZombieBlindingFXComponent) == 0x000008, "Wrong alignment on UZombieBlindingFXComponent");
static_assert(sizeof(UZombieBlindingFXComponent) == 0x000150, "Wrong size on UZombieBlindingFXComponent");

// Class TheK24.ZombieCharacter
// 0x0340 (0x0810 - 0x04D0)
class AZombieCharacter final : public ACharacter
{
public:
	uint8                                         Pad_4D0[0x38];                                     // 0x04D0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _zombieWalkSpeed;                                  // 0x0508(0x0080)(Edit, BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_588[0x8];                                      // 0x0588(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAuthoritativePoolableActorComponent*   _poolableComponent;                                // 0x0590(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _zombieAttackDetector;                             // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   _attackDamageZone;                                 // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EZombieState                                  _zombieState;                                      // 0x05A8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A9[0x3F];                                     // 0x05A9(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _zombieRespawnTimeKilledBySlasher;                 // 0x05E8(0x0080)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _zombieRespawnTimeKilledBySurvivor;                // 0x0668(0x0080)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6E8[0x8];                                      // 0x06E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             _respawnPositionBehindGate;                        // 0x06F0(0x0030)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	EZombieGender                                 _zombieGender;                                     // 0x0720(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_721[0x7];                                      // 0x0721(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          _femaleSkeletalMesh;                               // 0x0728(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _audioSwitchState;                                 // 0x0730(0x0010)(Edit, Net, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZombieBlindableComponent*              _blindableComponent;                               // 0x0740(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _blindingChargeableComponent;                      // 0x0748(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFirecrackerEffectHandlerComponent*     _firecrackerEffectHandlerComponent;                // 0x0750(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFlashlightableComponent*               _flashLightableComponent;                          // 0x0758(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_760[0x38];                                     // 0x0760(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _zombieStunBaseTime;                               // 0x0798(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayTagContainerComponent*         _objectState;                                      // 0x07C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C8[0x8];                                      // 0x07C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterPositionRecorderComponent*    _positionRecorder;                                 // 0x07D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAuthoritativeMovementComponent*        _authoritativeMovementComponent;                   // 0x07D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOtherCharactersVerticalCollisionsHandler* _otherCharactersVerticalCollisionsHandler;      // 0x07E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _ignoreActors;                                     // 0x07E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7F8[0x4];                                      // 0x07F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _zombieStunnedCapsuleRadius;                       // 0x07FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minFallHeight;                                    // 0x0800(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_804[0x8];                                      // 0x0804(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _afterInAirAttackCooldown;                         // 0x080C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_DeactivateZombieAndStartRespawnTimer();
	void Authority_OnFirecrackerInRangeBegin(const struct FFirecrackerEffectData& effectData);
	void Authority_OnFlashlightAdded(const class UFlashlightComponent* flashlight);
	void Authority_OnFlashlightRemoved(const class UFlashlightComponent* flashlight);
	void Authority_OnZombieStateChanged(EZombieState zombieState);
	void Multicast_ZombieKilledByKillerCosmetic(EAttackType attackType);
	void OnBeginOverlapZombieAttackDetector(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult);
	void OnEndOverlapZombieAttackDetector(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex);
	void OnFemaleGenderSet_Cosmetic();
	void OnRep_ZombieGender();
	void OnRep_ZombieState(EZombieState previousState);
	void OnSlasherSet(class ASlasherPlayer* slasher);
	void OnZombieStateChanged_Cosmetic(EZombieState zombieState);
	void SetCharacterActive_Cosmetic(const bool value);
	void ZombieKilledByKiller_Cosmetic(EAttackType attackType);

	class FString GetAudioSwitchState() const;
	class UAuthoritativeMovementComponent* GetAuthoritativeMovementComponent() const;
	class UOtherCharactersVerticalCollisionsHandler* GetOtherCharactersVerticalCollisionsHandler() const;
	EZombieGender GetZombieGender() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieCharacter">();
	}
	static class AZombieCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZombieCharacter>();
	}
};
static_assert(alignof(AZombieCharacter) == 0x000010, "Wrong alignment on AZombieCharacter");
static_assert(sizeof(AZombieCharacter) == 0x000810, "Wrong size on AZombieCharacter");
static_assert(offsetof(AZombieCharacter, _zombieWalkSpeed) == 0x000508, "Member 'AZombieCharacter::_zombieWalkSpeed' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _poolableComponent) == 0x000590, "Member 'AZombieCharacter::_poolableComponent' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _zombieAttackDetector) == 0x000598, "Member 'AZombieCharacter::_zombieAttackDetector' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _attackDamageZone) == 0x0005A0, "Member 'AZombieCharacter::_attackDamageZone' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _zombieState) == 0x0005A8, "Member 'AZombieCharacter::_zombieState' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _zombieRespawnTimeKilledBySlasher) == 0x0005E8, "Member 'AZombieCharacter::_zombieRespawnTimeKilledBySlasher' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _zombieRespawnTimeKilledBySurvivor) == 0x000668, "Member 'AZombieCharacter::_zombieRespawnTimeKilledBySurvivor' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _respawnPositionBehindGate) == 0x0006F0, "Member 'AZombieCharacter::_respawnPositionBehindGate' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _zombieGender) == 0x000720, "Member 'AZombieCharacter::_zombieGender' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _femaleSkeletalMesh) == 0x000728, "Member 'AZombieCharacter::_femaleSkeletalMesh' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _audioSwitchState) == 0x000730, "Member 'AZombieCharacter::_audioSwitchState' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _blindableComponent) == 0x000740, "Member 'AZombieCharacter::_blindableComponent' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _blindingChargeableComponent) == 0x000748, "Member 'AZombieCharacter::_blindingChargeableComponent' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _firecrackerEffectHandlerComponent) == 0x000750, "Member 'AZombieCharacter::_firecrackerEffectHandlerComponent' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _flashLightableComponent) == 0x000758, "Member 'AZombieCharacter::_flashLightableComponent' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _zombieStunBaseTime) == 0x000798, "Member 'AZombieCharacter::_zombieStunBaseTime' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _objectState) == 0x0007C0, "Member 'AZombieCharacter::_objectState' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _positionRecorder) == 0x0007D0, "Member 'AZombieCharacter::_positionRecorder' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _authoritativeMovementComponent) == 0x0007D8, "Member 'AZombieCharacter::_authoritativeMovementComponent' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _otherCharactersVerticalCollisionsHandler) == 0x0007E0, "Member 'AZombieCharacter::_otherCharactersVerticalCollisionsHandler' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _ignoreActors) == 0x0007E8, "Member 'AZombieCharacter::_ignoreActors' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _zombieStunnedCapsuleRadius) == 0x0007FC, "Member 'AZombieCharacter::_zombieStunnedCapsuleRadius' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _minFallHeight) == 0x000800, "Member 'AZombieCharacter::_minFallHeight' has a wrong offset!");
static_assert(offsetof(AZombieCharacter, _afterInAirAttackCooldown) == 0x00080C, "Member 'AZombieCharacter::_afterInAirAttackCooldown' has a wrong offset!");

// Class TheK24.ZombieChaseStateBTService
// 0x0000 (0x00A0 - 0x00A0)
class UZombieChaseStateBTService final : public UBTService_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieChaseStateBTService">();
	}
	static class UZombieChaseStateBTService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieChaseStateBTService>();
	}
};
static_assert(alignof(UZombieChaseStateBTService) == 0x000008, "Wrong alignment on UZombieChaseStateBTService");
static_assert(sizeof(UZombieChaseStateBTService) == 0x0000A0, "Wrong size on UZombieChaseStateBTService");

// Class TheK24.ZombieChaseSurvivorTargetBTTask
// 0x0000 (0x00B0 - 0x00B0)
class UZombieChaseSurvivorTargetBTTask final : public UBTTask_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieChaseSurvivorTargetBTTask">();
	}
	static class UZombieChaseSurvivorTargetBTTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieChaseSurvivorTargetBTTask>();
	}
};
static_assert(alignof(UZombieChaseSurvivorTargetBTTask) == 0x000008, "Wrong alignment on UZombieChaseSurvivorTargetBTTask");
static_assert(sizeof(UZombieChaseSurvivorTargetBTTask) == 0x0000B0, "Wrong size on UZombieChaseSurvivorTargetBTTask");

// Class TheK24.ZombieCustomizationComponent
// 0x0008 (0x0438 - 0x0430)
class UZombieCustomizationComponent final : public UCustomizedSkeletalMesh
{
public:
	TWeakObjectPtr<class ACamperPlayer>           _survivorSource;                                   // 0x0430(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Multicast_SetZombieCustomization(class ACamperPlayer* survivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieCustomizationComponent">();
	}
	static class UZombieCustomizationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieCustomizationComponent>();
	}
};
static_assert(alignof(UZombieCustomizationComponent) == 0x000008, "Wrong alignment on UZombieCustomizationComponent");
static_assert(sizeof(UZombieCustomizationComponent) == 0x000438, "Wrong size on UZombieCustomizationComponent");
static_assert(offsetof(UZombieCustomizationComponent, _survivorSource) == 0x000430, "Member 'UZombieCustomizationComponent::_survivorSource' has a wrong offset!");

// Class TheK24.ZombieEscapeDoorPointsActor
// 0x0010 (0x0240 - 0x0230)
class AZombieEscapeDoorPointsActor final : public AActor
{
public:
	TArray<class UArrowComponent*>                _availablePoints;                                  // 0x0230(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieEscapeDoorPointsActor">();
	}
	static class AZombieEscapeDoorPointsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZombieEscapeDoorPointsActor>();
	}
};
static_assert(alignof(AZombieEscapeDoorPointsActor) == 0x000008, "Wrong alignment on AZombieEscapeDoorPointsActor");
static_assert(sizeof(AZombieEscapeDoorPointsActor) == 0x000240, "Wrong size on AZombieEscapeDoorPointsActor");
static_assert(offsetof(AZombieEscapeDoorPointsActor, _availablePoints) == 0x000230, "Member 'AZombieEscapeDoorPointsActor::_availablePoints' has a wrong offset!");

// Class TheK24.ZombieEvaluateEnterChaseBTService
// 0x0000 (0x00A0 - 0x00A0)
class UZombieEvaluateEnterChaseBTService final : public UBTService_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieEvaluateEnterChaseBTService">();
	}
	static class UZombieEvaluateEnterChaseBTService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieEvaluateEnterChaseBTService>();
	}
};
static_assert(alignof(UZombieEvaluateEnterChaseBTService) == 0x000008, "Wrong alignment on UZombieEvaluateEnterChaseBTService");
static_assert(sizeof(UZombieEvaluateEnterChaseBTService) == 0x0000A0, "Wrong size on UZombieEvaluateEnterChaseBTService");

// Class TheK24.ZombieEvaluteEnterAttackBTService
// 0x0000 (0x00A0 - 0x00A0)
class UZombieEvaluteEnterAttackBTService final : public UBTService_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieEvaluteEnterAttackBTService">();
	}
	static class UZombieEvaluteEnterAttackBTService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieEvaluteEnterAttackBTService>();
	}
};
static_assert(alignof(UZombieEvaluteEnterAttackBTService) == 0x000008, "Wrong alignment on UZombieEvaluteEnterAttackBTService");
static_assert(sizeof(UZombieEvaluteEnterAttackBTService) == 0x0000A0, "Wrong size on UZombieEvaluteEnterAttackBTService");

// Class TheK24.ZombieFallDetectorComponent
// 0x0038 (0x00F0 - 0x00B8)
class UZombieFallDetectorComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _zombieDistanceConsideredSmashFall;                // 0x00B8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnMovementModeChange(class ACharacter* character, EMovementMode prevMovementMode, uint8 previousCustomMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieFallDetectorComponent">();
	}
	static class UZombieFallDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieFallDetectorComponent>();
	}
};
static_assert(alignof(UZombieFallDetectorComponent) == 0x000008, "Wrong alignment on UZombieFallDetectorComponent");
static_assert(sizeof(UZombieFallDetectorComponent) == 0x0000F0, "Wrong size on UZombieFallDetectorComponent");
static_assert(offsetof(UZombieFallDetectorComponent, _zombieDistanceConsideredSmashFall) == 0x0000B8, "Member 'UZombieFallDetectorComponent::_zombieDistanceConsideredSmashFall' has a wrong offset!");

// Class TheK24.ZombieOutlineUpdateStrategy
// 0x0008 (0x0140 - 0x0138)
class UZombieOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	class AZombieCharacter*                       _zombieCharacter;                                  // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieOutlineUpdateStrategy">();
	}
	static class UZombieOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UZombieOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UZombieOutlineUpdateStrategy");
static_assert(sizeof(UZombieOutlineUpdateStrategy) == 0x000140, "Wrong size on UZombieOutlineUpdateStrategy");
static_assert(offsetof(UZombieOutlineUpdateStrategy, _zombieCharacter) == 0x000138, "Member 'UZombieOutlineUpdateStrategy::_zombieCharacter' has a wrong offset!");

// Class TheK24.ZombieResurrector
// 0x0068 (0x0120 - 0x00B8)
class UZombieResurrector final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _powerLevelToSpawnZombie;                          // 0x00D0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AZombieCharacter*>               _delayedSpawnZombies;                              // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnKillerPowerLevelChanged(int32 powerLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieResurrector">();
	}
	static class UZombieResurrector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieResurrector>();
	}
};
static_assert(alignof(UZombieResurrector) == 0x000008, "Wrong alignment on UZombieResurrector");
static_assert(sizeof(UZombieResurrector) == 0x000120, "Wrong size on UZombieResurrector");
static_assert(offsetof(UZombieResurrector, _powerLevelToSpawnZombie) == 0x0000D0, "Member 'UZombieResurrector::_powerLevelToSpawnZombie' has a wrong offset!");
static_assert(offsetof(UZombieResurrector, _delayedSpawnZombies) == 0x000108, "Member 'UZombieResurrector::_delayedSpawnZombies' has a wrong offset!");

// Class TheK24.ZombieRotateTowardsTargetBTTask
// 0x0000 (0x00B0 - 0x00B0)
class UZombieRotateTowardsTargetBTTask final : public UBTTask_BlueprintBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieRotateTowardsTargetBTTask">();
	}
	static class UZombieRotateTowardsTargetBTTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieRotateTowardsTargetBTTask>();
	}
};
static_assert(alignof(UZombieRotateTowardsTargetBTTask) == 0x000008, "Wrong alignment on UZombieRotateTowardsTargetBTTask");
static_assert(sizeof(UZombieRotateTowardsTargetBTTask) == 0x0000B0, "Wrong size on UZombieRotateTowardsTargetBTTask");

// Class TheK24.ZombiesInterestEventManager
// 0x0030 (0x00E8 - 0x00B8)
class UZombiesInterestEventManager final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _zombieInterestEvents;                             // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnLoudNoiseTriggered(class AActor* originator, class AActor* instigatingActor, const struct FVector& location, bool shouldTrack, float* audibleRange, bool isQuickAction, bool isDeceivingNoise);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombiesInterestEventManager">();
	}
	static class UZombiesInterestEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombiesInterestEventManager>();
	}
};
static_assert(alignof(UZombiesInterestEventManager) == 0x000008, "Wrong alignment on UZombiesInterestEventManager");
static_assert(sizeof(UZombiesInterestEventManager) == 0x0000E8, "Wrong size on UZombiesInterestEventManager");
static_assert(offsetof(UZombiesInterestEventManager, _zombieInterestEvents) == 0x0000D0, "Member 'UZombiesInterestEventManager::_zombieInterestEvents' has a wrong offset!");

// Class TheK24.ZombiesManagement
// 0x00B8 (0x02E8 - 0x0230)
class AZombiesManagement final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAuthoritativeActorPoolComponent*       _zombiePool;                                       // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZombiesPatrolAreaManager*              _zombiesPatrolAreaManager;                         // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AZombieCharacter*>               _spawnedZombiesArray;                              // 0x0248(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_258[0x30];                                     // 0x0258(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _firstZombieSpawnTime;                             // 0x0288(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _numberOfZombieToSpawnAtStart;                     // 0x02B0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AZombieEscapeDoorPointsActor*>   _zombieEscapeDoorPoints;                           // 0x02D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Authority_OnIntroComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombiesManagement">();
	}
	static class AZombiesManagement* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZombiesManagement>();
	}
};
static_assert(alignof(AZombiesManagement) == 0x000008, "Wrong alignment on AZombiesManagement");
static_assert(sizeof(AZombiesManagement) == 0x0002E8, "Wrong size on AZombiesManagement");
static_assert(offsetof(AZombiesManagement, _zombiePool) == 0x000238, "Member 'AZombiesManagement::_zombiePool' has a wrong offset!");
static_assert(offsetof(AZombiesManagement, _zombiesPatrolAreaManager) == 0x000240, "Member 'AZombiesManagement::_zombiesPatrolAreaManager' has a wrong offset!");
static_assert(offsetof(AZombiesManagement, _spawnedZombiesArray) == 0x000248, "Member 'AZombiesManagement::_spawnedZombiesArray' has a wrong offset!");
static_assert(offsetof(AZombiesManagement, _firstZombieSpawnTime) == 0x000288, "Member 'AZombiesManagement::_firstZombieSpawnTime' has a wrong offset!");
static_assert(offsetof(AZombiesManagement, _numberOfZombieToSpawnAtStart) == 0x0002B0, "Member 'AZombiesManagement::_numberOfZombieToSpawnAtStart' has a wrong offset!");
static_assert(offsetof(AZombiesManagement, _zombieEscapeDoorPoints) == 0x0002D8, "Member 'AZombiesManagement::_zombieEscapeDoorPoints' has a wrong offset!");

// Class TheK24.ZombiesPatrolAreaManager
// 0x0028 (0x00E0 - 0x00B8)
class UZombiesPatrolAreaManager final : public UActorComponent
{
public:
	TArray<class AMeatHook*>                      _availablePatrolAreas;                             // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AMeatHook*>                      _usedPatrolAreas;                                  // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         _maxDistanceBetweenMeatHookAndPlayers;             // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombiesPatrolAreaManager">();
	}
	static class UZombiesPatrolAreaManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombiesPatrolAreaManager>();
	}
};
static_assert(alignof(UZombiesPatrolAreaManager) == 0x000008, "Wrong alignment on UZombiesPatrolAreaManager");
static_assert(sizeof(UZombiesPatrolAreaManager) == 0x0000E0, "Wrong size on UZombiesPatrolAreaManager");
static_assert(offsetof(UZombiesPatrolAreaManager, _availablePatrolAreas) == 0x0000B8, "Member 'UZombiesPatrolAreaManager::_availablePatrolAreas' has a wrong offset!");
static_assert(offsetof(UZombiesPatrolAreaManager, _usedPatrolAreas) == 0x0000C8, "Member 'UZombiesPatrolAreaManager::_usedPatrolAreas' has a wrong offset!");
static_assert(offsetof(UZombiesPatrolAreaManager, _maxDistanceBetweenMeatHookAndPlayers) == 0x0000D8, "Member 'UZombiesPatrolAreaManager::_maxDistanceBetweenMeatHookAndPlayers' has a wrong offset!");

// Class TheK24.ZombieStunnableComponent
// 0x0008 (0x00C0 - 0x00B8)
class UZombieStunnableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZombieStunnableComponent">();
	}
	static class UZombieStunnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZombieStunnableComponent>();
	}
};
static_assert(alignof(UZombieStunnableComponent) == 0x000008, "Wrong alignment on UZombieStunnableComponent");
static_assert(sizeof(UZombieStunnableComponent) == 0x0000C0, "Wrong size on UZombieStunnableComponent");

}

