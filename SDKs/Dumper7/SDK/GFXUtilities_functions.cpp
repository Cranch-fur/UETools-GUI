#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GFXUtilities

#include "Basic.hpp"

#include "GFXUtilities_classes.hpp"
#include "GFXUtilities_parameters.hpp"


namespace SDK
{

// Function GFXUtilities.BatchMeshCommands.BatchSetComponentTickEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::BatchSetComponentTickEnabled(bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "BatchSetComponentTickEnabled");

	Params::BatchMeshCommands_BatchSetComponentTickEnabled Parms{};

	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.BatchSetSkipComponentAndChildrenTransformUpdate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    skip                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::BatchSetSkipComponentAndChildrenTransformUpdate(bool skip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "BatchSetSkipComponentAndChildrenTransformUpdate");

	Params::BatchMeshCommands_BatchSetSkipComponentAndChildrenTransformUpdate Parms{};

	Parms.skip = skip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.BatchSetVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewVisibility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPropagateToChildren                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::BatchSetVisibility(bool bNewVisibility, bool bPropagateToChildren)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "BatchSetVisibility");

	Params::BatchMeshCommands_BatchSetVisibility Parms{};

	Parms.bNewVisibility = bNewVisibility;
	Parms.bPropagateToChildren = bPropagateToChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.CopyFirstScalarParameter
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName                       parameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  outValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBatchMeshCommands::CopyFirstScalarParameter(const class FName parameterName, float* outValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "CopyFirstScalarParameter");

	Params::BatchMeshCommands_CopyFirstScalarParameter Parms{};

	Parms.parameterName = parameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outValue != nullptr)
		*outValue = Parms.outValue;

	return Parms.ReturnValue;
}


// Function GFXUtilities.BatchMeshCommands.ResetMaterials
// (Final, Native, Public, BlueprintCallable)

void UBatchMeshCommands::ResetMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "ResetMaterials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetAllToSameMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               materialInterface                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetAllToSameMaterial(class UMaterialInterface* materialInterface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetAllToSameMaterial");

	Params::BatchMeshCommands_SetAllToSameMaterial Parms{};

	Parms.materialInterface = materialInterface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetCastCinematicShadows
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    castCinematicShadows                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetCastCinematicShadows(bool castCinematicShadows)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetCastCinematicShadows");

	Params::BatchMeshCommands_SetCastCinematicShadows Parms{};

	Parms.castCinematicShadows = castCinematicShadows;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetColourParameter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class FName                       parameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              newValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetColourParameter(const class FName parameterName, const struct FLinearColor& newValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetColourParameter");

	Params::BatchMeshCommands_SetColourParameter Parms{};

	Parms.parameterName = parameterName;
	Parms.newValue = std::move(newValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetCustomDepthStencilValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   stencilValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetCustomDepthStencilValue(int32 stencilValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetCustomDepthStencilValue");

	Params::BatchMeshCommands_SetCustomDepthStencilValue Parms{};

	Parms.stencilValue = stencilValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetLightingChannelForAllMeshes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FLightingChannels&         lightingChannels                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetLightingChannelForAllMeshes(const struct FLightingChannels& lightingChannels)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetLightingChannelForAllMeshes");

	Params::BatchMeshCommands_SetLightingChannelForAllMeshes Parms{};

	Parms.lightingChannels = std::move(lightingChannels);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    groupName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetMaterial(const class FString& groupName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetMaterial");

	Params::BatchMeshCommands_SetMaterial Parms{};

	Parms.groupName = std::move(groupName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetReceivesDecals
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    receivesDecals                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetReceivesDecals(bool receivesDecals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetReceivesDecals");

	Params::BatchMeshCommands_SetReceivesDecals Parms{};

	Parms.receivesDecals = receivesDecals;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetRenderInCustomColourNoDepth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    renderInCustomColour                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetRenderInCustomColourNoDepth(bool renderInCustomColour)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetRenderInCustomColourNoDepth");

	Params::BatchMeshCommands_SetRenderInCustomColourNoDepth Parms{};

	Parms.renderInCustomColour = renderInCustomColour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetRenderInCustomDepth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    renderInCustomDepth                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetRenderInCustomDepth(bool renderInCustomDepth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetRenderInCustomDepth");

	Params::BatchMeshCommands_SetRenderInCustomDepth Parms{};

	Parms.renderInCustomDepth = renderInCustomDepth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetRenderInMainPass
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    inRenderInMainPass                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetRenderInMainPass(bool inRenderInMainPass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetRenderInMainPass");

	Params::BatchMeshCommands_SetRenderInMainPass Parms{};

	Parms.inRenderInMainPass = inRenderInMainPass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetScalarParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       parameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             newValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetScalarParameter(const class FName parameterName, const float newValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetScalarParameter");

	Params::BatchMeshCommands_SetScalarParameter Parms{};

	Parms.parameterName = parameterName;
	Parms.newValue = newValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetStencilIntegerScalarParameter
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName                       parameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32&                            newValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetStencilIntegerScalarParameter(const class FName parameterName, const int32& newValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetStencilIntegerScalarParameter");

	Params::BatchMeshCommands_SetStencilIntegerScalarParameter Parms{};

	Parms.parameterName = parameterName;
	Parms.newValue = newValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetTextureParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       parameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         newTexture                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetTextureParameter(const class FName parameterName, class UTexture* newTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetTextureParameter");

	Params::BatchMeshCommands_SetTextureParameter Parms{};

	Parms.parameterName = parameterName;
	Parms.newTexture = newTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.SetVectorParameter
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class FName                       parameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   newValue                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBatchMeshCommands::SetVectorParameter(const class FName parameterName, const struct FVector& newValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "SetVectorParameter");

	Params::BatchMeshCommands_SetVectorParameter Parms{};

	Parms.parameterName = parameterName;
	Parms.newValue = std::move(newValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.BatchMeshCommands.UpdateMaterials
// (Final, Native, Public, BlueprintCallable)

void UBatchMeshCommands::UpdateMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BatchMeshCommands", "UpdateMaterials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.ClippableProviderComponent.AddIgnoredPrimitives
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class UPrimitiveComponent*>&ignoredPrimitives                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UClippableProviderComponent::AddIgnoredPrimitives(const TArray<class UPrimitiveComponent*>& ignoredPrimitives)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClippableProviderComponent", "AddIgnoredPrimitives");

	Params::ClippableProviderComponent_AddIgnoredPrimitives Parms{};

	Parms.ignoredPrimitives = std::move(ignoredPrimitives);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.ClippableProviderComponent.SetIgnoredPrimitives
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class UPrimitiveComponent*>&ignoredPrimitives                                      (ConstParm, Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UClippableProviderComponent::SetIgnoredPrimitives(const TArray<class UPrimitiveComponent*>& ignoredPrimitives)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClippableProviderComponent", "SetIgnoredPrimitives");

	Params::ClippableProviderComponent_SetIgnoredPrimitives Parms{};

	Parms.ignoredPrimitives = std::move(ignoredPrimitives);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.DBDReflectionCaptureSpawnerComponent.SetBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   brightness                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDReflectionCaptureSpawnerComponent::SetBrightness(float brightness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDReflectionCaptureSpawnerComponent", "SetBrightness");

	Params::DBDReflectionCaptureSpawnerComponent_SetBrightness Parms{};

	Parms.brightness = brightness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.DBDReflectionCaptureSpawnerComponent.SetContributionFactor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   contributionFactor                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDReflectionCaptureSpawnerComponent::SetContributionFactor(float contributionFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDReflectionCaptureSpawnerComponent", "SetContributionFactor");

	Params::DBDReflectionCaptureSpawnerComponent_SetContributionFactor Parms{};

	Parms.contributionFactor = contributionFactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.DBDReflectionCaptureSpawnerComponent.SetIBLMultiplicator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   IBLMultiplicator_0                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDReflectionCaptureSpawnerComponent::SetIBLMultiplicator(float IBLMultiplicator_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDReflectionCaptureSpawnerComponent", "SetIBLMultiplicator");

	Params::DBDReflectionCaptureSpawnerComponent_SetIBLMultiplicator Parms{};

	Parms.IBLMultiplicator_0 = IBLMultiplicator_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.GFXUtilities.ActivateVFX
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           skeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGFXUtilities::ActivateVFX(class USkeletalMeshComponent* skeletalMeshComponent, bool active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GFXUtilities", "ActivateVFX");

	Params::GFXUtilities_ActivateVFX Parms{};

	Parms.skeletalMeshComponent = skeletalMeshComponent;
	Parms.active = active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.AddLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULightComponent*                  light                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   multiplier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::AddLight(class ULightComponent* light, float multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "AddLight");

	Params::LightIntensityTimelineComponent_AddLight Parms{};

	Parms.light = light;
	Parms.multiplier = multiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.AddMaterialHelper
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialHelper*                  matHelper                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             propName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   multiplier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::AddMaterialHelper(class UMaterialHelper* matHelper, class FName propName, float multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "AddMaterialHelper");

	Params::LightIntensityTimelineComponent_AddMaterialHelper Parms{};

	Parms.matHelper = matHelper;
	Parms.propName = propName;
	Parms.multiplier = multiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.DeactivateTick
// (Final, Native, Public, BlueprintCallable)

void ULightIntensityTimelineComponent::DeactivateTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "DeactivateTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.RegisterForTick
// (Final, Native, Public, BlueprintCallable)

void ULightIntensityTimelineComponent::RegisterForTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "RegisterForTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.Reset
// (Final, Native, Public, BlueprintCallable)

void ULightIntensityTimelineComponent::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.SetLightCurve
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCurveFloat*                      lightcurve                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::SetLightCurve(class UCurveFloat* lightcurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "SetLightCurve");

	Params::LightIntensityTimelineComponent_SetLightCurve Parms{};

	Parms.lightcurve = lightcurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.SetLightToMaxValue
// (Final, Native, Public, BlueprintCallable)

void ULightIntensityTimelineComponent::SetLightToMaxValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "SetLightToMaxValue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.SetMaxLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   newMaxValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::SetMaxLength(float newMaxValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "SetMaxLength");

	Params::LightIntensityTimelineComponent_SetMaxLength Parms{};

	Parms.newMaxValue = newMaxValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.SetMinLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   newMinValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::SetMinLength(float newMinValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "SetMinLength");

	Params::LightIntensityTimelineComponent_SetMinLength Parms{};

	Parms.newMinValue = newMinValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.LightIntensityTimelineComponent.SetRandomizeLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    isRandom                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULightIntensityTimelineComponent::SetRandomizeLength(bool isRandom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LightIntensityTimelineComponent", "SetRandomizeLength");

	Params::LightIntensityTimelineComponent_SetRandomizeLength Parms{};

	Parms.isRandom = isRandom;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.MaterialHelper.RefreshMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   mc                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialHelper::RefreshMesh(class UMeshComponent* mc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialHelper", "RefreshMesh");

	Params::MaterialHelper_RefreshMesh Parms{};

	Parms.mc = mc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.MaterialHelper.RefreshMeshes
// (Final, Native, Public, BlueprintCallable)

void UMaterialHelper::RefreshMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialHelper", "RefreshMeshes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.OuterlineComponent.SetIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   intensity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOuterlineComponent::SetIntensity(float intensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OuterlineComponent", "SetIntensity");

	Params::OuterlineComponent_SetIntensity Parms{};

	Parms.intensity = intensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GFXUtilities.StencilOutlineRenderStrategy.EnableCopyStencilToCustomStencil
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStencilOutlineRenderStrategy::EnableCopyStencilToCustomStencil(bool enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("StencilOutlineRenderStrategy", "EnableCopyStencilToCustomStencil");

	Params::StencilOutlineRenderStrategy_EnableCopyStencilToCustomStencil Parms{};

	Parms.enabled = enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

