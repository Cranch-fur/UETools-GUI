#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDGameplay

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "DBDSharedTypes_structs.hpp"


namespace SDK::Params
{

// Function DBDGameplay.BaseHusk.Cosmetic_InitializeSkeletalMesh
// 0x0008 (0x0008 - 0x0000)
struct BaseHusk_Cosmetic_InitializeSkeletalMesh final
{
public:
	class USkeletalMeshComponent*                 mesh;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseHusk_Cosmetic_InitializeSkeletalMesh) == 0x000008, "Wrong alignment on BaseHusk_Cosmetic_InitializeSkeletalMesh");
static_assert(sizeof(BaseHusk_Cosmetic_InitializeSkeletalMesh) == 0x000008, "Wrong size on BaseHusk_Cosmetic_InitializeSkeletalMesh");
static_assert(offsetof(BaseHusk_Cosmetic_InitializeSkeletalMesh, mesh) == 0x000000, "Member 'BaseHusk_Cosmetic_InitializeSkeletalMesh::mesh' has a wrong offset!");

// Function DBDGameplay.BaseHusk.InitializeHusk
// 0x0008 (0x0008 - 0x0000)
struct BaseHusk_InitializeHusk final
{
public:
	class UCustomizedSkeletalMesh*                customizedSkeletalMeshToCopy;                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseHusk_InitializeHusk) == 0x000008, "Wrong alignment on BaseHusk_InitializeHusk");
static_assert(sizeof(BaseHusk_InitializeHusk) == 0x000008, "Wrong size on BaseHusk_InitializeHusk");
static_assert(offsetof(BaseHusk_InitializeHusk, customizedSkeletalMeshToCopy) == 0x000000, "Member 'BaseHusk_InitializeHusk::customizedSkeletalMeshToCopy' has a wrong offset!");

// Function DBDGameplay.BaseHusk.SetHuskVisibility
// 0x0001 (0x0001 - 0x0000)
struct BaseHusk_SetHuskVisibility final
{
public:
	bool                                          visible;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseHusk_SetHuskVisibility) == 0x000001, "Wrong alignment on BaseHusk_SetHuskVisibility");
static_assert(sizeof(BaseHusk_SetHuskVisibility) == 0x000001, "Wrong size on BaseHusk_SetHuskVisibility");
static_assert(offsetof(BaseHusk_SetHuskVisibility, visible) == 0x000000, "Member 'BaseHusk_SetHuskVisibility::visible' has a wrong offset!");

// Function DBDGameplay.BaseHusk.SetScalarParameterOnAllChildrenMeshes
// 0x0018 (0x0018 - 0x0000)
struct BaseHusk_SetScalarParameterOnAllChildrenMeshes final
{
public:
	class FName                                   parameterName;                                     // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         value;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 mesh;                                              // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseHusk_SetScalarParameterOnAllChildrenMeshes) == 0x000008, "Wrong alignment on BaseHusk_SetScalarParameterOnAllChildrenMeshes");
static_assert(sizeof(BaseHusk_SetScalarParameterOnAllChildrenMeshes) == 0x000018, "Wrong size on BaseHusk_SetScalarParameterOnAllChildrenMeshes");
static_assert(offsetof(BaseHusk_SetScalarParameterOnAllChildrenMeshes, parameterName) == 0x000000, "Member 'BaseHusk_SetScalarParameterOnAllChildrenMeshes::parameterName' has a wrong offset!");
static_assert(offsetof(BaseHusk_SetScalarParameterOnAllChildrenMeshes, value) == 0x00000C, "Member 'BaseHusk_SetScalarParameterOnAllChildrenMeshes::value' has a wrong offset!");
static_assert(offsetof(BaseHusk_SetScalarParameterOnAllChildrenMeshes, mesh) == 0x000010, "Member 'BaseHusk_SetScalarParameterOnAllChildrenMeshes::mesh' has a wrong offset!");

// Function DBDGameplay.PoseableHusk.OnActiveStateChanged
// 0x0001 (0x0001 - 0x0000)
struct PoseableHusk_OnActiveStateChanged final
{
public:
	bool                                          isActive;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableHusk_OnActiveStateChanged) == 0x000001, "Wrong alignment on PoseableHusk_OnActiveStateChanged");
static_assert(sizeof(PoseableHusk_OnActiveStateChanged) == 0x000001, "Wrong size on PoseableHusk_OnActiveStateChanged");
static_assert(offsetof(PoseableHusk_OnActiveStateChanged, isActive) == 0x000000, "Member 'PoseableHusk_OnActiveStateChanged::isActive' has a wrong offset!");

// Function DBDGameplay.PoseableHusk.SetIsActive
// 0x0001 (0x0001 - 0x0000)
struct PoseableHusk_SetIsActive final
{
public:
	bool                                          isActive;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableHusk_SetIsActive) == 0x000001, "Wrong alignment on PoseableHusk_SetIsActive");
static_assert(sizeof(PoseableHusk_SetIsActive) == 0x000001, "Wrong size on PoseableHusk_SetIsActive");
static_assert(offsetof(PoseableHusk_SetIsActive, isActive) == 0x000000, "Member 'PoseableHusk_SetIsActive::isActive' has a wrong offset!");

// Function DBDGameplay.PoseableHusk.GetIsActive
// 0x0001 (0x0001 - 0x0000)
struct PoseableHusk_GetIsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableHusk_GetIsActive) == 0x000001, "Wrong alignment on PoseableHusk_GetIsActive");
static_assert(sizeof(PoseableHusk_GetIsActive) == 0x000001, "Wrong size on PoseableHusk_GetIsActive");
static_assert(offsetof(PoseableHusk_GetIsActive, ReturnValue) == 0x000000, "Member 'PoseableHusk_GetIsActive::ReturnValue' has a wrong offset!");

// Function DBDGameplay.AimableComponent.SetMaxAimDistance
// 0x0004 (0x0004 - 0x0000)
struct AimableComponent_SetMaxAimDistance final
{
public:
	float                                         maxAimDistance;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimableComponent_SetMaxAimDistance) == 0x000004, "Wrong alignment on AimableComponent_SetMaxAimDistance");
static_assert(sizeof(AimableComponent_SetMaxAimDistance) == 0x000004, "Wrong size on AimableComponent_SetMaxAimDistance");
static_assert(offsetof(AimableComponent_SetMaxAimDistance, maxAimDistance) == 0x000000, "Member 'AimableComponent_SetMaxAimDistance::maxAimDistance' has a wrong offset!");

// Function DBDGameplay.AimableComponent.SetOcclusionIgnoredActors
// 0x0010 (0x0010 - 0x0000)
struct AimableComponent_SetOcclusionIgnoredActors final
{
public:
	TArray<class AActor*>                         ignoredActors;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimableComponent_SetOcclusionIgnoredActors) == 0x000008, "Wrong alignment on AimableComponent_SetOcclusionIgnoredActors");
static_assert(sizeof(AimableComponent_SetOcclusionIgnoredActors) == 0x000010, "Wrong size on AimableComponent_SetOcclusionIgnoredActors");
static_assert(offsetof(AimableComponent_SetOcclusionIgnoredActors, ignoredActors) == 0x000000, "Member 'AimableComponent_SetOcclusionIgnoredActors::ignoredActors' has a wrong offset!");

// Function DBDGameplay.AimableComponent.SetProcessors
// 0x0010 (0x0010 - 0x0000)
struct AimableComponent_SetProcessors final
{
public:
	TArray<class UAimPointProcessor*>             processors;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimableComponent_SetProcessors) == 0x000008, "Wrong alignment on AimableComponent_SetProcessors");
static_assert(sizeof(AimableComponent_SetProcessors) == 0x000010, "Wrong size on AimableComponent_SetProcessors");
static_assert(offsetof(AimableComponent_SetProcessors, processors) == 0x000000, "Member 'AimableComponent_SetProcessors::processors' has a wrong offset!");

// Function DBDGameplay.AISense_Terror.ReportTerrorEvent
// 0x0028 (0x0028 - 0x0000)
struct AISense_Terror_ReportTerrorEvent final
{
public:
	class UObject*                                worldContextObj;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                location;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 instigator;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTerrorRadiusEmitterComponent*          terrorEmitter;                                     // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AISense_Terror_ReportTerrorEvent) == 0x000008, "Wrong alignment on AISense_Terror_ReportTerrorEvent");
static_assert(sizeof(AISense_Terror_ReportTerrorEvent) == 0x000028, "Wrong size on AISense_Terror_ReportTerrorEvent");
static_assert(offsetof(AISense_Terror_ReportTerrorEvent, worldContextObj) == 0x000000, "Member 'AISense_Terror_ReportTerrorEvent::worldContextObj' has a wrong offset!");
static_assert(offsetof(AISense_Terror_ReportTerrorEvent, location) == 0x000008, "Member 'AISense_Terror_ReportTerrorEvent::location' has a wrong offset!");
static_assert(offsetof(AISense_Terror_ReportTerrorEvent, instigator) == 0x000018, "Member 'AISense_Terror_ReportTerrorEvent::instigator' has a wrong offset!");
static_assert(offsetof(AISense_Terror_ReportTerrorEvent, terrorEmitter) == 0x000020, "Member 'AISense_Terror_ReportTerrorEvent::terrorEmitter' has a wrong offset!");

// Function DBDGameplay.PowerChargeComponent.OnCurrentChargeChanged
// 0x0004 (0x0004 - 0x0000)
struct PowerChargeComponent_OnCurrentChargeChanged final
{
public:
	float                                         value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PowerChargeComponent_OnCurrentChargeChanged) == 0x000004, "Wrong alignment on PowerChargeComponent_OnCurrentChargeChanged");
static_assert(sizeof(PowerChargeComponent_OnCurrentChargeChanged) == 0x000004, "Wrong size on PowerChargeComponent_OnCurrentChargeChanged");
static_assert(offsetof(PowerChargeComponent_OnCurrentChargeChanged, value) == 0x000000, "Member 'PowerChargeComponent_OnCurrentChargeChanged::value' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseAmplitude
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude final
{
public:
	float                                         amplitude;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude");
static_assert(sizeof(AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude) == 0x000004, "Wrong size on AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude");
static_assert(offsetof(AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude, amplitude) == 0x000000, "Member 'AimPointPerlinNoise_SetBaseInaccuracyNoiseAmplitude::amplitude' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseFrequency
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency final
{
public:
	float                                         frequency;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency");
static_assert(sizeof(AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency) == 0x000004, "Wrong size on AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency");
static_assert(offsetof(AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency, frequency) == 0x000000, "Member 'AimPointPerlinNoise_SetBaseInaccuracyNoiseFrequency::frequency' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoiseOctaveCount
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount final
{
public:
	int32                                         octaveCount;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount");
static_assert(sizeof(AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount) == 0x000004, "Wrong size on AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount");
static_assert(offsetof(AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount, octaveCount) == 0x000000, "Member 'AimPointPerlinNoise_SetBaseInaccuracyNoiseOctaveCount::octaveCount' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetBaseInaccuracyNoisePersistence
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence final
{
public:
	float                                         noisePersistence;                                  // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence");
static_assert(sizeof(AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence) == 0x000004, "Wrong size on AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence");
static_assert(offsetof(AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence, noisePersistence) == 0x000000, "Member 'AimPointPerlinNoise_SetBaseInaccuracyNoisePersistence::noisePersistence' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetNoiseAmplitudeMultiplier
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetNoiseAmplitudeMultiplier final
{
public:
	float                                         multiplier;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetNoiseAmplitudeMultiplier) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetNoiseAmplitudeMultiplier");
static_assert(sizeof(AimPointPerlinNoise_SetNoiseAmplitudeMultiplier) == 0x000004, "Wrong size on AimPointPerlinNoise_SetNoiseAmplitudeMultiplier");
static_assert(offsetof(AimPointPerlinNoise_SetNoiseAmplitudeMultiplier, multiplier) == 0x000000, "Member 'AimPointPerlinNoise_SetNoiseAmplitudeMultiplier::multiplier' has a wrong offset!");

// Function DBDGameplay.AimPointPerlinNoise.SetNoiseFrequencyMultiplier
// 0x0004 (0x0004 - 0x0000)
struct AimPointPerlinNoise_SetNoiseFrequencyMultiplier final
{
public:
	float                                         multiplier;                                        // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AimPointPerlinNoise_SetNoiseFrequencyMultiplier) == 0x000004, "Wrong alignment on AimPointPerlinNoise_SetNoiseFrequencyMultiplier");
static_assert(sizeof(AimPointPerlinNoise_SetNoiseFrequencyMultiplier) == 0x000004, "Wrong size on AimPointPerlinNoise_SetNoiseFrequencyMultiplier");
static_assert(offsetof(AimPointPerlinNoise_SetNoiseFrequencyMultiplier, multiplier) == 0x000000, "Member 'AimPointPerlinNoise_SetNoiseFrequencyMultiplier::multiplier' has a wrong offset!");

// Function DBDGameplay.AuraOverriderComponent.ForceShowAura
// 0x0020 (0x0020 - 0x0000)
struct AuraOverriderComponent_ForceShowAura final
{
public:
	const class AActor*                           actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           color;                                             // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isAlwaysVisible;                                   // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         minimumOutlineDistance;                            // 0x001C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AuraOverriderComponent_ForceShowAura) == 0x000008, "Wrong alignment on AuraOverriderComponent_ForceShowAura");
static_assert(sizeof(AuraOverriderComponent_ForceShowAura) == 0x000020, "Wrong size on AuraOverriderComponent_ForceShowAura");
static_assert(offsetof(AuraOverriderComponent_ForceShowAura, actor) == 0x000000, "Member 'AuraOverriderComponent_ForceShowAura::actor' has a wrong offset!");
static_assert(offsetof(AuraOverriderComponent_ForceShowAura, color) == 0x000008, "Member 'AuraOverriderComponent_ForceShowAura::color' has a wrong offset!");
static_assert(offsetof(AuraOverriderComponent_ForceShowAura, isAlwaysVisible) == 0x000018, "Member 'AuraOverriderComponent_ForceShowAura::isAlwaysVisible' has a wrong offset!");
static_assert(offsetof(AuraOverriderComponent_ForceShowAura, minimumOutlineDistance) == 0x00001C, "Member 'AuraOverriderComponent_ForceShowAura::minimumOutlineDistance' has a wrong offset!");

// Function DBDGameplay.AuraOverriderComponent.ResetAura
// 0x0008 (0x0008 - 0x0000)
struct AuraOverriderComponent_ResetAura final
{
public:
	const class AActor*                           actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AuraOverriderComponent_ResetAura) == 0x000008, "Wrong alignment on AuraOverriderComponent_ResetAura");
static_assert(sizeof(AuraOverriderComponent_ResetAura) == 0x000008, "Wrong size on AuraOverriderComponent_ResetAura");
static_assert(offsetof(AuraOverriderComponent_ResetAura, actor) == 0x000000, "Member 'AuraOverriderComponent_ResetAura::actor' has a wrong offset!");

// Function DBDGameplay.BaseActorAttackableComponent.HitWithProjectile
// 0x0008 (0x0008 - 0x0000)
struct BaseActorAttackableComponent_HitWithProjectile final
{
public:
	class ABaseProjectile*                        projectile;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BaseActorAttackableComponent_HitWithProjectile) == 0x000008, "Wrong alignment on BaseActorAttackableComponent_HitWithProjectile");
static_assert(sizeof(BaseActorAttackableComponent_HitWithProjectile) == 0x000008, "Wrong size on BaseActorAttackableComponent_HitWithProjectile");
static_assert(offsetof(BaseActorAttackableComponent_HitWithProjectile, projectile) == 0x000000, "Member 'BaseActorAttackableComponent_HitWithProjectile::projectile' has a wrong offset!");

// Function DBDGameplay.FlashlightTargetFXComponent.OnIsLitChanged
// 0x0001 (0x0001 - 0x0000)
struct FlashlightTargetFXComponent_OnIsLitChanged final
{
public:
	bool                                          isLit;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightTargetFXComponent_OnIsLitChanged) == 0x000001, "Wrong alignment on FlashlightTargetFXComponent_OnIsLitChanged");
static_assert(sizeof(FlashlightTargetFXComponent_OnIsLitChanged) == 0x000001, "Wrong size on FlashlightTargetFXComponent_OnIsLitChanged");
static_assert(offsetof(FlashlightTargetFXComponent_OnIsLitChanged, isLit) == 0x000000, "Member 'FlashlightTargetFXComponent_OnIsLitChanged::isLit' has a wrong offset!");

// Function DBDGameplay.CamperFootstepCreatorComponent.OnLoudNoiseTriggered
// 0x0028 (0x0028 - 0x0000)
struct CamperFootstepCreatorComponent_OnLoudNoiseTriggered final
{
public:
	class AActor*                                 originator;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 instigatingActor;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                location;                                          // 0x0010(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          shouldTrack;                                       // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         audibleRange;                                      // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isQuickAction;                                     // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isDeceivingNoise;                                  // 0x0025(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered) == 0x000008, "Wrong alignment on CamperFootstepCreatorComponent_OnLoudNoiseTriggered");
static_assert(sizeof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered) == 0x000028, "Wrong size on CamperFootstepCreatorComponent_OnLoudNoiseTriggered");
static_assert(offsetof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered, originator) == 0x000000, "Member 'CamperFootstepCreatorComponent_OnLoudNoiseTriggered::originator' has a wrong offset!");
static_assert(offsetof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered, instigatingActor) == 0x000008, "Member 'CamperFootstepCreatorComponent_OnLoudNoiseTriggered::instigatingActor' has a wrong offset!");
static_assert(offsetof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered, location) == 0x000010, "Member 'CamperFootstepCreatorComponent_OnLoudNoiseTriggered::location' has a wrong offset!");
static_assert(offsetof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered, shouldTrack) == 0x00001C, "Member 'CamperFootstepCreatorComponent_OnLoudNoiseTriggered::shouldTrack' has a wrong offset!");
static_assert(offsetof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered, audibleRange) == 0x000020, "Member 'CamperFootstepCreatorComponent_OnLoudNoiseTriggered::audibleRange' has a wrong offset!");
static_assert(offsetof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered, isQuickAction) == 0x000024, "Member 'CamperFootstepCreatorComponent_OnLoudNoiseTriggered::isQuickAction' has a wrong offset!");
static_assert(offsetof(CamperFootstepCreatorComponent_OnLoudNoiseTriggered, isDeceivingNoise) == 0x000025, "Member 'CamperFootstepCreatorComponent_OnLoudNoiseTriggered::isDeceivingNoise' has a wrong offset!");

// Function DBDGameplay.CollectableComponentUtilities.GetCollector
// 0x0010 (0x0010 - 0x0000)
struct CollectableComponentUtilities_GetCollector final
{
public:
	const class UActorComponent*                  component;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDPlayer*                             ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CollectableComponentUtilities_GetCollector) == 0x000008, "Wrong alignment on CollectableComponentUtilities_GetCollector");
static_assert(sizeof(CollectableComponentUtilities_GetCollector) == 0x000010, "Wrong size on CollectableComponentUtilities_GetCollector");
static_assert(offsetof(CollectableComponentUtilities_GetCollector, component) == 0x000000, "Member 'CollectableComponentUtilities_GetCollector::component' has a wrong offset!");
static_assert(offsetof(CollectableComponentUtilities_GetCollector, ReturnValue) == 0x000008, "Member 'CollectableComponentUtilities_GetCollector::ReturnValue' has a wrong offset!");

// Function DBDGameplay.DebugIndicator.SetColor
// 0x0010 (0x0010 - 0x0000)
struct DebugIndicator_SetColor final
{
public:
	struct FLinearColor                           color;                                             // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DebugIndicator_SetColor) == 0x000004, "Wrong alignment on DebugIndicator_SetColor");
static_assert(sizeof(DebugIndicator_SetColor) == 0x000010, "Wrong size on DebugIndicator_SetColor");
static_assert(offsetof(DebugIndicator_SetColor, color) == 0x000000, "Member 'DebugIndicator_SetColor::color' has a wrong offset!");

// Function DBDGameplay.DebugIndicator.SetVisible
// 0x0001 (0x0001 - 0x0000)
struct DebugIndicator_SetVisible final
{
public:
	bool                                          visible;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DebugIndicator_SetVisible) == 0x000001, "Wrong alignment on DebugIndicator_SetVisible");
static_assert(sizeof(DebugIndicator_SetVisible) == 0x000001, "Wrong size on DebugIndicator_SetVisible");
static_assert(offsetof(DebugIndicator_SetVisible, visible) == 0x000000, "Member 'DebugIndicator_SetVisible::visible' has a wrong offset!");

// Function DBDGameplay.DecoySlasherComponent.DoPostVFXUpdates
// 0x0018 (0x0018 - 0x0000)
struct DecoySlasherComponent_DoPostVFXUpdates final
{
public:
	struct FVector                                location;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               rotation;                                          // 0x000C(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecoySlasherComponent_DoPostVFXUpdates) == 0x000004, "Wrong alignment on DecoySlasherComponent_DoPostVFXUpdates");
static_assert(sizeof(DecoySlasherComponent_DoPostVFXUpdates) == 0x000018, "Wrong size on DecoySlasherComponent_DoPostVFXUpdates");
static_assert(offsetof(DecoySlasherComponent_DoPostVFXUpdates, location) == 0x000000, "Member 'DecoySlasherComponent_DoPostVFXUpdates::location' has a wrong offset!");
static_assert(offsetof(DecoySlasherComponent_DoPostVFXUpdates, rotation) == 0x00000C, "Member 'DecoySlasherComponent_DoPostVFXUpdates::rotation' has a wrong offset!");

// Function DBDGameplay.DecoySlasherComponent.OnRealSlasherTerrorRadiusChanged
// 0x0004 (0x0004 - 0x0000)
struct DecoySlasherComponent_OnRealSlasherTerrorRadiusChanged final
{
public:
	float                                         newValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecoySlasherComponent_OnRealSlasherTerrorRadiusChanged) == 0x000004, "Wrong alignment on DecoySlasherComponent_OnRealSlasherTerrorRadiusChanged");
static_assert(sizeof(DecoySlasherComponent_OnRealSlasherTerrorRadiusChanged) == 0x000004, "Wrong size on DecoySlasherComponent_OnRealSlasherTerrorRadiusChanged");
static_assert(offsetof(DecoySlasherComponent_OnRealSlasherTerrorRadiusChanged, newValue) == 0x000000, "Member 'DecoySlasherComponent_OnRealSlasherTerrorRadiusChanged::newValue' has a wrong offset!");

// Function DBDGameplay.DecoySlasherComponent.SetDecoyIsActive
// 0x0020 (0x0020 - 0x0000)
struct DecoySlasherComponent_SetDecoyIsActive final
{
public:
	bool                                          isActive;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                location;                                          // 0x0004(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               rotation;                                          // 0x0010(0x000C)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          visibleRedGlow;                                    // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DecoySlasherComponent_SetDecoyIsActive) == 0x000004, "Wrong alignment on DecoySlasherComponent_SetDecoyIsActive");
static_assert(sizeof(DecoySlasherComponent_SetDecoyIsActive) == 0x000020, "Wrong size on DecoySlasherComponent_SetDecoyIsActive");
static_assert(offsetof(DecoySlasherComponent_SetDecoyIsActive, isActive) == 0x000000, "Member 'DecoySlasherComponent_SetDecoyIsActive::isActive' has a wrong offset!");
static_assert(offsetof(DecoySlasherComponent_SetDecoyIsActive, location) == 0x000004, "Member 'DecoySlasherComponent_SetDecoyIsActive::location' has a wrong offset!");
static_assert(offsetof(DecoySlasherComponent_SetDecoyIsActive, rotation) == 0x000010, "Member 'DecoySlasherComponent_SetDecoyIsActive::rotation' has a wrong offset!");
static_assert(offsetof(DecoySlasherComponent_SetDecoyIsActive, visibleRedGlow) == 0x00001C, "Member 'DecoySlasherComponent_SetDecoyIsActive::visibleRedGlow' has a wrong offset!");

// Function DBDGameplay.DecoySlasherComponent.GetRealSlasher
// 0x0008 (0x0008 - 0x0000)
struct DecoySlasherComponent_GetRealSlasher final
{
public:
	class ASlasherPlayer*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecoySlasherComponent_GetRealSlasher) == 0x000008, "Wrong alignment on DecoySlasherComponent_GetRealSlasher");
static_assert(sizeof(DecoySlasherComponent_GetRealSlasher) == 0x000008, "Wrong size on DecoySlasherComponent_GetRealSlasher");
static_assert(offsetof(DecoySlasherComponent_GetRealSlasher, ReturnValue) == 0x000000, "Member 'DecoySlasherComponent_GetRealSlasher::ReturnValue' has a wrong offset!");

// Function DBDGameplay.DecoySlasherComponent.IsDecoyActive
// 0x0001 (0x0001 - 0x0000)
struct DecoySlasherComponent_IsDecoyActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecoySlasherComponent_IsDecoyActive) == 0x000001, "Wrong alignment on DecoySlasherComponent_IsDecoyActive");
static_assert(sizeof(DecoySlasherComponent_IsDecoyActive) == 0x000001, "Wrong size on DecoySlasherComponent_IsDecoyActive");
static_assert(offsetof(DecoySlasherComponent_IsDecoyActive, ReturnValue) == 0x000000, "Member 'DecoySlasherComponent_IsDecoyActive::ReturnValue' has a wrong offset!");

// Function DBDGameplay.EtherealComponent.Server_SetIsEthereal
// 0x0008 (0x0008 - 0x0000)
struct EtherealComponent_Server_SetIsEthereal final
{
public:
	float                                         timestamp;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ethereal;                                          // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(EtherealComponent_Server_SetIsEthereal) == 0x000004, "Wrong alignment on EtherealComponent_Server_SetIsEthereal");
static_assert(sizeof(EtherealComponent_Server_SetIsEthereal) == 0x000008, "Wrong size on EtherealComponent_Server_SetIsEthereal");
static_assert(offsetof(EtherealComponent_Server_SetIsEthereal, timestamp) == 0x000000, "Member 'EtherealComponent_Server_SetIsEthereal::timestamp' has a wrong offset!");
static_assert(offsetof(EtherealComponent_Server_SetIsEthereal, ethereal) == 0x000004, "Member 'EtherealComponent_Server_SetIsEthereal::ethereal' has a wrong offset!");

// Function DBDGameplay.RangeToActorsTrackerStrategy.OnInRangeToTrackedActorsChanged
// 0x0001 (0x0001 - 0x0000)
struct RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged final
{
public:
	bool                                          inRange;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged) == 0x000001, "Wrong alignment on RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged");
static_assert(sizeof(RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged) == 0x000001, "Wrong size on RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged");
static_assert(offsetof(RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged, inRange) == 0x000000, "Member 'RangeToActorsTrackerStrategy_OnInRangeToTrackedActorsChanged::inRange' has a wrong offset!");

// Function DBDGameplay.FadeComponent.GetFadePercent
// 0x0004 (0x0004 - 0x0000)
struct FadeComponent_GetFadePercent final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FadeComponent_GetFadePercent) == 0x000004, "Wrong alignment on FadeComponent_GetFadePercent");
static_assert(sizeof(FadeComponent_GetFadePercent) == 0x000004, "Wrong size on FadeComponent_GetFadePercent");
static_assert(offsetof(FadeComponent_GetFadePercent, ReturnValue) == 0x000000, "Member 'FadeComponent_GetFadePercent::ReturnValue' has a wrong offset!");

// Function DBDGameplay.Flashlight.GetSpotlightComponent
// 0x0008 (0x0008 - 0x0000)
struct Flashlight_GetSpotlightComponent final
{
public:
	class USpotLightComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Flashlight_GetSpotlightComponent) == 0x000008, "Wrong alignment on Flashlight_GetSpotlightComponent");
static_assert(sizeof(Flashlight_GetSpotlightComponent) == 0x000008, "Wrong size on Flashlight_GetSpotlightComponent");
static_assert(offsetof(Flashlight_GetSpotlightComponent, ReturnValue) == 0x000000, "Member 'Flashlight_GetSpotlightComponent::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightableComponent.IsLit
// 0x0001 (0x0001 - 0x0000)
struct FlashlightableComponent_IsLit final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightableComponent_IsLit) == 0x000001, "Wrong alignment on FlashlightableComponent_IsLit");
static_assert(sizeof(FlashlightableComponent_IsLit) == 0x000001, "Wrong size on FlashlightableComponent_IsLit");
static_assert(offsetof(FlashlightableComponent_IsLit, ReturnValue) == 0x000000, "Member 'FlashlightableComponent_IsLit::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightComponent.Server_SetAndUpdateAutonomousLitFlashlightables
// 0x0010 (0x0010 - 0x0000)
struct FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables final
{
public:
	TArray<class UFlashlightableComponent*>       newLitFlashlightables;                             // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables) == 0x000008, "Wrong alignment on FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables");
static_assert(sizeof(FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables) == 0x000010, "Wrong size on FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables");
static_assert(offsetof(FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables, newLitFlashlightables) == 0x000000, "Member 'FlashlightComponent_Server_SetAndUpdateAutonomousLitFlashlightables::newLitFlashlightables' has a wrong offset!");

// Function DBDGameplay.FlashlightComponent.GetEffectiveBlindnessDuration
// 0x0004 (0x0004 - 0x0000)
struct FlashlightComponent_GetEffectiveBlindnessDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightComponent_GetEffectiveBlindnessDuration) == 0x000004, "Wrong alignment on FlashlightComponent_GetEffectiveBlindnessDuration");
static_assert(sizeof(FlashlightComponent_GetEffectiveBlindnessDuration) == 0x000004, "Wrong size on FlashlightComponent_GetEffectiveBlindnessDuration");
static_assert(offsetof(FlashlightComponent_GetEffectiveBlindnessDuration, ReturnValue) == 0x000000, "Member 'FlashlightComponent_GetEffectiveBlindnessDuration::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightComponent.GetEffectiveTimeToBlindModifier
// 0x0004 (0x0004 - 0x0000)
struct FlashlightComponent_GetEffectiveTimeToBlindModifier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightComponent_GetEffectiveTimeToBlindModifier) == 0x000004, "Wrong alignment on FlashlightComponent_GetEffectiveTimeToBlindModifier");
static_assert(sizeof(FlashlightComponent_GetEffectiveTimeToBlindModifier) == 0x000004, "Wrong size on FlashlightComponent_GetEffectiveTimeToBlindModifier");
static_assert(offsetof(FlashlightComponent_GetEffectiveTimeToBlindModifier, ReturnValue) == 0x000000, "Member 'FlashlightComponent_GetEffectiveTimeToBlindModifier::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightComponent.IsOn
// 0x0001 (0x0001 - 0x0000)
struct FlashlightComponent_IsOn final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightComponent_IsOn) == 0x000001, "Wrong alignment on FlashlightComponent_IsOn");
static_assert(sizeof(FlashlightComponent_IsOn) == 0x000001, "Wrong size on FlashlightComponent_IsOn");
static_assert(offsetof(FlashlightComponent_IsOn, ReturnValue) == 0x000000, "Member 'FlashlightComponent_IsOn::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightConeComponent.GetEffectiveConeHalfAngle
// 0x0004 (0x0004 - 0x0000)
struct FlashlightConeComponent_GetEffectiveConeHalfAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightConeComponent_GetEffectiveConeHalfAngle) == 0x000004, "Wrong alignment on FlashlightConeComponent_GetEffectiveConeHalfAngle");
static_assert(sizeof(FlashlightConeComponent_GetEffectiveConeHalfAngle) == 0x000004, "Wrong size on FlashlightConeComponent_GetEffectiveConeHalfAngle");
static_assert(offsetof(FlashlightConeComponent_GetEffectiveConeHalfAngle, ReturnValue) == 0x000000, "Member 'FlashlightConeComponent_GetEffectiveConeHalfAngle::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightConeComponent.GetEffectiveConeLength
// 0x0004 (0x0004 - 0x0000)
struct FlashlightConeComponent_GetEffectiveConeLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightConeComponent_GetEffectiveConeLength) == 0x000004, "Wrong alignment on FlashlightConeComponent_GetEffectiveConeLength");
static_assert(sizeof(FlashlightConeComponent_GetEffectiveConeLength) == 0x000004, "Wrong size on FlashlightConeComponent_GetEffectiveConeLength");
static_assert(offsetof(FlashlightConeComponent_GetEffectiveConeLength, ReturnValue) == 0x000000, "Member 'FlashlightConeComponent_GetEffectiveConeLength::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightConeComponent.GetOcclusionDistance
// 0x0004 (0x0004 - 0x0000)
struct FlashlightConeComponent_GetOcclusionDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightConeComponent_GetOcclusionDistance) == 0x000004, "Wrong alignment on FlashlightConeComponent_GetOcclusionDistance");
static_assert(sizeof(FlashlightConeComponent_GetOcclusionDistance) == 0x000004, "Wrong size on FlashlightConeComponent_GetOcclusionDistance");
static_assert(offsetof(FlashlightConeComponent_GetOcclusionDistance, ReturnValue) == 0x000000, "Member 'FlashlightConeComponent_GetOcclusionDistance::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FlashlightFXComponent.OnCollectedEvent
// 0x0008 (0x0008 - 0x0000)
struct FlashlightFXComponent_OnCollectedEvent final
{
public:
	class ADBDPlayer*                             collector;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightFXComponent_OnCollectedEvent) == 0x000008, "Wrong alignment on FlashlightFXComponent_OnCollectedEvent");
static_assert(sizeof(FlashlightFXComponent_OnCollectedEvent) == 0x000008, "Wrong size on FlashlightFXComponent_OnCollectedEvent");
static_assert(offsetof(FlashlightFXComponent_OnCollectedEvent, collector) == 0x000000, "Member 'FlashlightFXComponent_OnCollectedEvent::collector' has a wrong offset!");

// Function DBDGameplay.FlashlightFXComponent.OnCollectorLocallyObservedChangedEvent
// 0x0001 (0x0001 - 0x0000)
struct FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent final
{
public:
	bool                                          isLocallyObserved;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent) == 0x000001, "Wrong alignment on FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent");
static_assert(sizeof(FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent) == 0x000001, "Wrong size on FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent");
static_assert(offsetof(FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent, isLocallyObserved) == 0x000000, "Member 'FlashlightFXComponent_OnCollectorLocallyObservedChangedEvent::isLocallyObserved' has a wrong offset!");

// Function DBDGameplay.FlashlightFXComponent.UpdateConeEvent
// 0x0008 (0x0008 - 0x0000)
struct FlashlightFXComponent_UpdateConeEvent final
{
public:
	float                                         length;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         halfAngle;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightFXComponent_UpdateConeEvent) == 0x000004, "Wrong alignment on FlashlightFXComponent_UpdateConeEvent");
static_assert(sizeof(FlashlightFXComponent_UpdateConeEvent) == 0x000008, "Wrong size on FlashlightFXComponent_UpdateConeEvent");
static_assert(offsetof(FlashlightFXComponent_UpdateConeEvent, length) == 0x000000, "Member 'FlashlightFXComponent_UpdateConeEvent::length' has a wrong offset!");
static_assert(offsetof(FlashlightFXComponent_UpdateConeEvent, halfAngle) == 0x000004, "Member 'FlashlightFXComponent_UpdateConeEvent::halfAngle' has a wrong offset!");

// Function DBDGameplay.FlashlightFXComponent.GetBlindingSuccessRatio
// 0x0004 (0x0004 - 0x0000)
struct FlashlightFXComponent_GetBlindingSuccessRatio final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FlashlightFXComponent_GetBlindingSuccessRatio) == 0x000004, "Wrong alignment on FlashlightFXComponent_GetBlindingSuccessRatio");
static_assert(sizeof(FlashlightFXComponent_GetBlindingSuccessRatio) == 0x000004, "Wrong size on FlashlightFXComponent_GetBlindingSuccessRatio");
static_assert(offsetof(FlashlightFXComponent_GetBlindingSuccessRatio, ReturnValue) == 0x000000, "Member 'FlashlightFXComponent_GetBlindingSuccessRatio::ReturnValue' has a wrong offset!");

// Function DBDGameplay.FootstepManagerComponent.OnUpdateCreatorFootsteps
// 0x0008 (0x0008 - 0x0000)
struct FootstepManagerComponent_OnUpdateCreatorFootsteps final
{
public:
	class UFootstepCreatorComponent*              creator;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FootstepManagerComponent_OnUpdateCreatorFootsteps) == 0x000008, "Wrong alignment on FootstepManagerComponent_OnUpdateCreatorFootsteps");
static_assert(sizeof(FootstepManagerComponent_OnUpdateCreatorFootsteps) == 0x000008, "Wrong size on FootstepManagerComponent_OnUpdateCreatorFootsteps");
static_assert(offsetof(FootstepManagerComponent_OnUpdateCreatorFootsteps, creator) == 0x000000, "Member 'FootstepManagerComponent_OnUpdateCreatorFootsteps::creator' has a wrong offset!");

// Function DBDGameplay.FootstepManagerComponent.TriggerSpawnFootstep
// 0x0018 (0x0018 - 0x0000)
struct FootstepManagerComponent_TriggerSpawnFootstep final
{
public:
	class UFootstepCreatorComponent*              originatorComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                location;                                          // 0x0008(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FootstepManagerComponent_TriggerSpawnFootstep) == 0x000008, "Wrong alignment on FootstepManagerComponent_TriggerSpawnFootstep");
static_assert(sizeof(FootstepManagerComponent_TriggerSpawnFootstep) == 0x000018, "Wrong size on FootstepManagerComponent_TriggerSpawnFootstep");
static_assert(offsetof(FootstepManagerComponent_TriggerSpawnFootstep, originatorComponent) == 0x000000, "Member 'FootstepManagerComponent_TriggerSpawnFootstep::originatorComponent' has a wrong offset!");
static_assert(offsetof(FootstepManagerComponent_TriggerSpawnFootstep, location) == 0x000008, "Member 'FootstepManagerComponent_TriggerSpawnFootstep::location' has a wrong offset!");

// Function DBDGameplay.KillerInstinctComponent.GetParticleSystem
// 0x0008 (0x0008 - 0x0000)
struct KillerInstinctComponent_GetParticleSystem final
{
public:
	class UNiagaraComponent*                      ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerInstinctComponent_GetParticleSystem) == 0x000008, "Wrong alignment on KillerInstinctComponent_GetParticleSystem");
static_assert(sizeof(KillerInstinctComponent_GetParticleSystem) == 0x000008, "Wrong size on KillerInstinctComponent_GetParticleSystem");
static_assert(offsetof(KillerInstinctComponent_GetParticleSystem, ReturnValue) == 0x000000, "Member 'KillerInstinctComponent_GetParticleSystem::ReturnValue' has a wrong offset!");

// Function DBDGameplay.KillerInstinctComponent.OnKillerLocallyObservedChanged
// 0x0001 (0x0001 - 0x0000)
struct KillerInstinctComponent_OnKillerLocallyObservedChanged final
{
public:
	bool                                          locallyObserved;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerInstinctComponent_OnKillerLocallyObservedChanged) == 0x000001, "Wrong alignment on KillerInstinctComponent_OnKillerLocallyObservedChanged");
static_assert(sizeof(KillerInstinctComponent_OnKillerLocallyObservedChanged) == 0x000001, "Wrong size on KillerInstinctComponent_OnKillerLocallyObservedChanged");
static_assert(offsetof(KillerInstinctComponent_OnKillerLocallyObservedChanged, locallyObserved) == 0x000000, "Member 'KillerInstinctComponent_OnKillerLocallyObservedChanged::locallyObserved' has a wrong offset!");

// Function DBDGameplay.KillerInstinctComponent.SetParticleSystem
// 0x0008 (0x0008 - 0x0000)
struct KillerInstinctComponent_SetParticleSystem final
{
public:
	class UNiagaraComponent*                      particleSystemComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerInstinctComponent_SetParticleSystem) == 0x000008, "Wrong alignment on KillerInstinctComponent_SetParticleSystem");
static_assert(sizeof(KillerInstinctComponent_SetParticleSystem) == 0x000008, "Wrong size on KillerInstinctComponent_SetParticleSystem");
static_assert(offsetof(KillerInstinctComponent_SetParticleSystem, particleSystemComponent) == 0x000000, "Member 'KillerInstinctComponent_SetParticleSystem::particleSystemComponent' has a wrong offset!");

// Function DBDGameplay.KillerInstinctComponent.IsOwnerInKillerInstinctRadius
// 0x0001 (0x0001 - 0x0000)
struct KillerInstinctComponent_IsOwnerInKillerInstinctRadius final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KillerInstinctComponent_IsOwnerInKillerInstinctRadius) == 0x000001, "Wrong alignment on KillerInstinctComponent_IsOwnerInKillerInstinctRadius");
static_assert(sizeof(KillerInstinctComponent_IsOwnerInKillerInstinctRadius) == 0x000001, "Wrong size on KillerInstinctComponent_IsOwnerInKillerInstinctRadius");
static_assert(offsetof(KillerInstinctComponent_IsOwnerInKillerInstinctRadius, ReturnValue) == 0x000000, "Member 'KillerInstinctComponent_IsOwnerInKillerInstinctRadius::ReturnValue' has a wrong offset!");

// Function DBDGameplay.LullabyFeedbackComponent.OnSlasherSet
// 0x0008 (0x0008 - 0x0000)
struct LullabyFeedbackComponent_OnSlasherSet final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LullabyFeedbackComponent_OnSlasherSet) == 0x000008, "Wrong alignment on LullabyFeedbackComponent_OnSlasherSet");
static_assert(sizeof(LullabyFeedbackComponent_OnSlasherSet) == 0x000008, "Wrong size on LullabyFeedbackComponent_OnSlasherSet");
static_assert(offsetof(LullabyFeedbackComponent_OnSlasherSet, killer) == 0x000000, "Member 'LullabyFeedbackComponent_OnSlasherSet::killer' has a wrong offset!");

// Function DBDGameplay.MapCollectable.GetActorKnowledgeCollection
// 0x0008 (0x0008 - 0x0000)
struct MapCollectable_GetActorKnowledgeCollection final
{
public:
	class UActorKnowledgeCollection*              ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapCollectable_GetActorKnowledgeCollection) == 0x000008, "Wrong alignment on MapCollectable_GetActorKnowledgeCollection");
static_assert(sizeof(MapCollectable_GetActorKnowledgeCollection) == 0x000008, "Wrong size on MapCollectable_GetActorKnowledgeCollection");
static_assert(offsetof(MapCollectable_GetActorKnowledgeCollection, ReturnValue) == 0x000000, "Member 'MapCollectable_GetActorKnowledgeCollection::ReturnValue' has a wrong offset!");

// Function DBDGameplay.MapCollectable.GetChargeableComponent
// 0x0008 (0x0008 - 0x0000)
struct MapCollectable_GetChargeableComponent final
{
public:
	class UChargeableComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapCollectable_GetChargeableComponent) == 0x000008, "Wrong alignment on MapCollectable_GetChargeableComponent");
static_assert(sizeof(MapCollectable_GetChargeableComponent) == 0x000008, "Wrong size on MapCollectable_GetChargeableComponent");
static_assert(offsetof(MapCollectable_GetChargeableComponent, ReturnValue) == 0x000000, "Member 'MapCollectable_GetChargeableComponent::ReturnValue' has a wrong offset!");

// Function DBDGameplay.MapCollectable.GetChargerComponent
// 0x0008 (0x0008 - 0x0000)
struct MapCollectable_GetChargerComponent final
{
public:
	class UChargerComponent*                      ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MapCollectable_GetChargerComponent) == 0x000008, "Wrong alignment on MapCollectable_GetChargerComponent");
static_assert(sizeof(MapCollectable_GetChargerComponent) == 0x000008, "Wrong size on MapCollectable_GetChargerComponent");
static_assert(offsetof(MapCollectable_GetChargerComponent, ReturnValue) == 0x000000, "Member 'MapCollectable_GetChargerComponent::ReturnValue' has a wrong offset!");

// Function DBDGameplay.Medkit.Authority_OnAnyOngoingInteractionChanged
// 0x0001 (0x0001 - 0x0000)
struct Medkit_Authority_OnAnyOngoingInteractionChanged final
{
public:
	bool                                          isInteracting;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_Authority_OnAnyOngoingInteractionChanged) == 0x000001, "Wrong alignment on Medkit_Authority_OnAnyOngoingInteractionChanged");
static_assert(sizeof(Medkit_Authority_OnAnyOngoingInteractionChanged) == 0x000001, "Wrong size on Medkit_Authority_OnAnyOngoingInteractionChanged");
static_assert(offsetof(Medkit_Authority_OnAnyOngoingInteractionChanged, isInteracting) == 0x000000, "Member 'Medkit_Authority_OnAnyOngoingInteractionChanged::isInteracting' has a wrong offset!");

// Function DBDGameplay.Medkit.Authority_OnChargeStateChange
// 0x0001 (0x0001 - 0x0000)
struct Medkit_Authority_OnChargeStateChange final
{
public:
	bool                                          empty;                                             // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_Authority_OnChargeStateChange) == 0x000001, "Wrong alignment on Medkit_Authority_OnChargeStateChange");
static_assert(sizeof(Medkit_Authority_OnChargeStateChange) == 0x000001, "Wrong size on Medkit_Authority_OnChargeStateChange");
static_assert(offsetof(Medkit_Authority_OnChargeStateChange, empty) == 0x000000, "Member 'Medkit_Authority_OnChargeStateChange::empty' has a wrong offset!");

// Function DBDGameplay.Medkit.OnMedkitHealedCamper
// 0x0008 (0x0008 - 0x0000)
struct Medkit_OnMedkitHealedCamper final
{
public:
	class ADBDPlayer*                             healedPlayer;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_OnMedkitHealedCamper) == 0x000008, "Wrong alignment on Medkit_OnMedkitHealedCamper");
static_assert(sizeof(Medkit_OnMedkitHealedCamper) == 0x000008, "Wrong size on Medkit_OnMedkitHealedCamper");
static_assert(offsetof(Medkit_OnMedkitHealedCamper, healedPlayer) == 0x000000, "Member 'Medkit_OnMedkitHealedCamper::healedPlayer' has a wrong offset!");

// Function DBDGameplay.Medkit.UseCharge
// 0x0004 (0x0004 - 0x0000)
struct Medkit_UseCharge final
{
public:
	float                                         seconds;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_UseCharge) == 0x000004, "Wrong alignment on Medkit_UseCharge");
static_assert(sizeof(Medkit_UseCharge) == 0x000004, "Wrong size on Medkit_UseCharge");
static_assert(offsetof(Medkit_UseCharge, seconds) == 0x000000, "Member 'Medkit_UseCharge::seconds' has a wrong offset!");

// Function DBDGameplay.Medkit.GetCharge
// 0x0004 (0x0004 - 0x0000)
struct Medkit_GetCharge final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_GetCharge) == 0x000004, "Wrong alignment on Medkit_GetCharge");
static_assert(sizeof(Medkit_GetCharge) == 0x000004, "Wrong size on Medkit_GetCharge");
static_assert(offsetof(Medkit_GetCharge, ReturnValue) == 0x000000, "Member 'Medkit_GetCharge::ReturnValue' has a wrong offset!");

// Function DBDGameplay.Medkit.GetChargeMultiplier
// 0x0004 (0x0004 - 0x0000)
struct Medkit_GetChargeMultiplier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_GetChargeMultiplier) == 0x000004, "Wrong alignment on Medkit_GetChargeMultiplier");
static_assert(sizeof(Medkit_GetChargeMultiplier) == 0x000004, "Wrong size on Medkit_GetChargeMultiplier");
static_assert(offsetof(Medkit_GetChargeMultiplier, ReturnValue) == 0x000000, "Member 'Medkit_GetChargeMultiplier::ReturnValue' has a wrong offset!");

// Function DBDGameplay.Medkit.HasCharge
// 0x0001 (0x0001 - 0x0000)
struct Medkit_HasCharge final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Medkit_HasCharge) == 0x000001, "Wrong alignment on Medkit_HasCharge");
static_assert(sizeof(Medkit_HasCharge) == 0x000001, "Wrong size on Medkit_HasCharge");
static_assert(offsetof(Medkit_HasCharge, ReturnValue) == 0x000000, "Member 'Medkit_HasCharge::ReturnValue' has a wrong offset!");

// Function DBDGameplay.NearestOutsideMapBoundsLocator.OnGameEnd
// 0x0001 (0x0001 - 0x0000)
struct NearestOutsideMapBoundsLocator_OnGameEnd final
{
public:
	EEndGameReason                                endGameReason;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NearestOutsideMapBoundsLocator_OnGameEnd) == 0x000001, "Wrong alignment on NearestOutsideMapBoundsLocator_OnGameEnd");
static_assert(sizeof(NearestOutsideMapBoundsLocator_OnGameEnd) == 0x000001, "Wrong size on NearestOutsideMapBoundsLocator_OnGameEnd");
static_assert(offsetof(NearestOutsideMapBoundsLocator_OnGameEnd, endGameReason) == 0x000000, "Member 'NearestOutsideMapBoundsLocator_OnGameEnd::endGameReason' has a wrong offset!");

// Function DBDGameplay.PlayerInteractionListenerComponent.ListenToInteractionEnd
// 0x0028 (0x0028 - 0x0000)
struct PlayerInteractionListenerComponent_ListenToInteractionEnd final
{
public:
	class ADBDPlayer*                             player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           interactionSemantic;                               // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)> interactionDelegate; // 0x0014(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInteractionListenerComponent_ListenToInteractionEnd) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_ListenToInteractionEnd");
static_assert(sizeof(PlayerInteractionListenerComponent_ListenToInteractionEnd) == 0x000028, "Wrong size on PlayerInteractionListenerComponent_ListenToInteractionEnd");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionEnd, player) == 0x000000, "Member 'PlayerInteractionListenerComponent_ListenToInteractionEnd::player' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionEnd, interactionSemantic) == 0x000008, "Member 'PlayerInteractionListenerComponent_ListenToInteractionEnd::interactionSemantic' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionEnd, interactionDelegate) == 0x000014, "Member 'PlayerInteractionListenerComponent_ListenToInteractionEnd::interactionDelegate' has a wrong offset!");

// Function DBDGameplay.PlayerInteractionListenerComponent.ListenToInteractionStart
// 0x0028 (0x0028 - 0x0000)
struct PlayerInteractionListenerComponent_ListenToInteractionStart final
{
public:
	class ADBDPlayer*                             player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           interactionSemantic;                               // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class ADBDPlayer* Player, const struct FGameplayTag& interactionSemantic)> interactionDelegate; // 0x0014(0x0014)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInteractionListenerComponent_ListenToInteractionStart) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_ListenToInteractionStart");
static_assert(sizeof(PlayerInteractionListenerComponent_ListenToInteractionStart) == 0x000028, "Wrong size on PlayerInteractionListenerComponent_ListenToInteractionStart");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionStart, player) == 0x000000, "Member 'PlayerInteractionListenerComponent_ListenToInteractionStart::player' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionStart, interactionSemantic) == 0x000008, "Member 'PlayerInteractionListenerComponent_ListenToInteractionStart::interactionSemantic' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_ListenToInteractionStart, interactionDelegate) == 0x000014, "Member 'PlayerInteractionListenerComponent_ListenToInteractionStart::interactionDelegate' has a wrong offset!");

// Function DBDGameplay.PlayerInteractionListenerComponent.OnActorDestroyed
// 0x0008 (0x0008 - 0x0000)
struct PlayerInteractionListenerComponent_OnActorDestroyed final
{
public:
	class AActor*                                 destroyedActor;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInteractionListenerComponent_OnActorDestroyed) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_OnActorDestroyed");
static_assert(sizeof(PlayerInteractionListenerComponent_OnActorDestroyed) == 0x000008, "Wrong size on PlayerInteractionListenerComponent_OnActorDestroyed");
static_assert(offsetof(PlayerInteractionListenerComponent_OnActorDestroyed, destroyedActor) == 0x000000, "Member 'PlayerInteractionListenerComponent_OnActorDestroyed::destroyedActor' has a wrong offset!");

// Function DBDGameplay.PlayerInteractionListenerComponent.UnlistenToInteractionEnd
// 0x0018 (0x0018 - 0x0000)
struct PlayerInteractionListenerComponent_UnlistenToInteractionEnd final
{
public:
	class ADBDPlayer*                             player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           interactionSemantic;                               // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerInteractionListenerComponent_UnlistenToInteractionEnd) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_UnlistenToInteractionEnd");
static_assert(sizeof(PlayerInteractionListenerComponent_UnlistenToInteractionEnd) == 0x000018, "Wrong size on PlayerInteractionListenerComponent_UnlistenToInteractionEnd");
static_assert(offsetof(PlayerInteractionListenerComponent_UnlistenToInteractionEnd, player) == 0x000000, "Member 'PlayerInteractionListenerComponent_UnlistenToInteractionEnd::player' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_UnlistenToInteractionEnd, interactionSemantic) == 0x000008, "Member 'PlayerInteractionListenerComponent_UnlistenToInteractionEnd::interactionSemantic' has a wrong offset!");

// Function DBDGameplay.PlayerInteractionListenerComponent.UnlistenToInteractionStart
// 0x0018 (0x0018 - 0x0000)
struct PlayerInteractionListenerComponent_UnlistenToInteractionStart final
{
public:
	class ADBDPlayer*                             player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           interactionSemantic;                               // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerInteractionListenerComponent_UnlistenToInteractionStart) == 0x000008, "Wrong alignment on PlayerInteractionListenerComponent_UnlistenToInteractionStart");
static_assert(sizeof(PlayerInteractionListenerComponent_UnlistenToInteractionStart) == 0x000018, "Wrong size on PlayerInteractionListenerComponent_UnlistenToInteractionStart");
static_assert(offsetof(PlayerInteractionListenerComponent_UnlistenToInteractionStart, player) == 0x000000, "Member 'PlayerInteractionListenerComponent_UnlistenToInteractionStart::player' has a wrong offset!");
static_assert(offsetof(PlayerInteractionListenerComponent_UnlistenToInteractionStart, interactionSemantic) == 0x000008, "Member 'PlayerInteractionListenerComponent_UnlistenToInteractionStart::interactionSemantic' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyGamepadPitchScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier final
{
public:
	class ADBDPlayer*                             player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         adjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier, player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier::player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier, multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier::multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier, adjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyGamepadPitchScaleMultiplier::adjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyGamepadYawScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier final
{
public:
	class ADBDPlayer*                             player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         adjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier, player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier::player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier, multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier::multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier, adjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyGamepadYawScaleMultiplier::adjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyMousePitchScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier final
{
public:
	class ADBDPlayer*                             player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         adjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier, player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier::player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier, multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier::multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier, adjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyMousePitchScaleMultiplier::adjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyMouseYawScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier final
{
public:
	class ADBDPlayer*                             player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         adjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier, player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier::player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier, multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier::multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier, adjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyMouseYawScaleMultiplier::adjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyPitchScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier final
{
public:
	class ADBDPlayer*                             player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         adjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier, player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier::player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier, multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier::multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier, adjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyPitchScaleMultiplier::adjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyRotationScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier final
{
public:
	class ADBDPlayer*                             player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         adjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier, player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier::player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier, multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier::multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier, adjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyRotationScaleMultiplier::adjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ApplyYawScaleMultiplier
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ApplyYawScaleMultiplier final
{
public:
	class ADBDPlayer*                             player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         multiplier;                                        // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         adjustmentTime;                                    // 0x000C(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ApplyYawScaleMultiplier) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ApplyYawScaleMultiplier");
static_assert(sizeof(PlayerMovementUtilities_Local_ApplyYawScaleMultiplier) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ApplyYawScaleMultiplier");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyYawScaleMultiplier, player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ApplyYawScaleMultiplier::player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyYawScaleMultiplier, multiplier) == 0x000008, "Member 'PlayerMovementUtilities_Local_ApplyYawScaleMultiplier::multiplier' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ApplyYawScaleMultiplier, adjustmentTime) == 0x00000C, "Member 'PlayerMovementUtilities_Local_ApplyYawScaleMultiplier::adjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ResetGamepadLookCurves
// 0x0008 (0x0008 - 0x0000)
struct PlayerMovementUtilities_Local_ResetGamepadLookCurves final
{
public:
	class ADBDPlayer*                             player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_ResetGamepadLookCurves) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ResetGamepadLookCurves");
static_assert(sizeof(PlayerMovementUtilities_Local_ResetGamepadLookCurves) == 0x000008, "Wrong size on PlayerMovementUtilities_Local_ResetGamepadLookCurves");
static_assert(offsetof(PlayerMovementUtilities_Local_ResetGamepadLookCurves, player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ResetGamepadLookCurves::player' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_ResetRotationScale
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_ResetRotationScale final
{
public:
	class ADBDPlayer*                             player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         adjustmentTime;                                    // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerMovementUtilities_Local_ResetRotationScale) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_ResetRotationScale");
static_assert(sizeof(PlayerMovementUtilities_Local_ResetRotationScale) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_ResetRotationScale");
static_assert(offsetof(PlayerMovementUtilities_Local_ResetRotationScale, player) == 0x000000, "Member 'PlayerMovementUtilities_Local_ResetRotationScale::player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_ResetRotationScale, adjustmentTime) == 0x000008, "Member 'PlayerMovementUtilities_Local_ResetRotationScale::adjustmentTime' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_SetGamepadPitchCurve
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_SetGamepadPitchCurve final
{
public:
	class ADBDPlayer*                             player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            curve;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_SetGamepadPitchCurve) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_SetGamepadPitchCurve");
static_assert(sizeof(PlayerMovementUtilities_Local_SetGamepadPitchCurve) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_SetGamepadPitchCurve");
static_assert(offsetof(PlayerMovementUtilities_Local_SetGamepadPitchCurve, player) == 0x000000, "Member 'PlayerMovementUtilities_Local_SetGamepadPitchCurve::player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_SetGamepadPitchCurve, curve) == 0x000008, "Member 'PlayerMovementUtilities_Local_SetGamepadPitchCurve::curve' has a wrong offset!");

// Function DBDGameplay.PlayerMovementUtilities.Local_SetGamepadYawCurve
// 0x0010 (0x0010 - 0x0000)
struct PlayerMovementUtilities_Local_SetGamepadYawCurve final
{
public:
	class ADBDPlayer*                             player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            curve;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerMovementUtilities_Local_SetGamepadYawCurve) == 0x000008, "Wrong alignment on PlayerMovementUtilities_Local_SetGamepadYawCurve");
static_assert(sizeof(PlayerMovementUtilities_Local_SetGamepadYawCurve) == 0x000010, "Wrong size on PlayerMovementUtilities_Local_SetGamepadYawCurve");
static_assert(offsetof(PlayerMovementUtilities_Local_SetGamepadYawCurve, player) == 0x000000, "Member 'PlayerMovementUtilities_Local_SetGamepadYawCurve::player' has a wrong offset!");
static_assert(offsetof(PlayerMovementUtilities_Local_SetGamepadYawCurve, curve) == 0x000008, "Member 'PlayerMovementUtilities_Local_SetGamepadYawCurve::curve' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.SetEmitterActive
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusEmitterComponent_SetEmitterActive final
{
public:
	bool                                          active;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_SetEmitterActive) == 0x000001, "Wrong alignment on TerrorRadiusEmitterComponent_SetEmitterActive");
static_assert(sizeof(TerrorRadiusEmitterComponent_SetEmitterActive) == 0x000001, "Wrong size on TerrorRadiusEmitterComponent_SetEmitterActive");
static_assert(offsetof(TerrorRadiusEmitterComponent_SetEmitterActive, active) == 0x000000, "Member 'TerrorRadiusEmitterComponent_SetEmitterActive::active' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.SetImitatesAudioOnly
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusEmitterComponent_SetImitatesAudioOnly final
{
public:
	bool                                          imitatesAudioOnly;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_SetImitatesAudioOnly) == 0x000001, "Wrong alignment on TerrorRadiusEmitterComponent_SetImitatesAudioOnly");
static_assert(sizeof(TerrorRadiusEmitterComponent_SetImitatesAudioOnly) == 0x000001, "Wrong size on TerrorRadiusEmitterComponent_SetImitatesAudioOnly");
static_assert(offsetof(TerrorRadiusEmitterComponent_SetImitatesAudioOnly, imitatesAudioOnly) == 0x000000, "Member 'TerrorRadiusEmitterComponent_SetImitatesAudioOnly::imitatesAudioOnly' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.SetIsFakeTerrorRadius
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius final
{
public:
	bool                                          value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius) == 0x000001, "Wrong alignment on TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius");
static_assert(sizeof(TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius) == 0x000001, "Wrong size on TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius");
static_assert(offsetof(TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius, value) == 0x000000, "Member 'TerrorRadiusEmitterComponent_SetIsFakeTerrorRadius::value' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.SetSimulatedFixedDistance
// 0x0004 (0x0004 - 0x0000)
struct TerrorRadiusEmitterComponent_SetSimulatedFixedDistance final
{
public:
	float                                         distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_SetSimulatedFixedDistance) == 0x000004, "Wrong alignment on TerrorRadiusEmitterComponent_SetSimulatedFixedDistance");
static_assert(sizeof(TerrorRadiusEmitterComponent_SetSimulatedFixedDistance) == 0x000004, "Wrong size on TerrorRadiusEmitterComponent_SetSimulatedFixedDistance");
static_assert(offsetof(TerrorRadiusEmitterComponent_SetSimulatedFixedDistance, distance) == 0x000000, "Member 'TerrorRadiusEmitterComponent_SetSimulatedFixedDistance::distance' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.SetTerrorRadius
// 0x0004 (0x0004 - 0x0000)
struct TerrorRadiusEmitterComponent_SetTerrorRadius final
{
public:
	float                                         radius;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_SetTerrorRadius) == 0x000004, "Wrong alignment on TerrorRadiusEmitterComponent_SetTerrorRadius");
static_assert(sizeof(TerrorRadiusEmitterComponent_SetTerrorRadius) == 0x000004, "Wrong size on TerrorRadiusEmitterComponent_SetTerrorRadius");
static_assert(offsetof(TerrorRadiusEmitterComponent_SetTerrorRadius, radius) == 0x000000, "Member 'TerrorRadiusEmitterComponent_SetTerrorRadius::radius' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.GetImitatesAudioOnly
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusEmitterComponent_GetImitatesAudioOnly final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_GetImitatesAudioOnly) == 0x000001, "Wrong alignment on TerrorRadiusEmitterComponent_GetImitatesAudioOnly");
static_assert(sizeof(TerrorRadiusEmitterComponent_GetImitatesAudioOnly) == 0x000001, "Wrong size on TerrorRadiusEmitterComponent_GetImitatesAudioOnly");
static_assert(offsetof(TerrorRadiusEmitterComponent_GetImitatesAudioOnly, ReturnValue) == 0x000000, "Member 'TerrorRadiusEmitterComponent_GetImitatesAudioOnly::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.GetIsActive
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusEmitterComponent_GetIsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_GetIsActive) == 0x000001, "Wrong alignment on TerrorRadiusEmitterComponent_GetIsActive");
static_assert(sizeof(TerrorRadiusEmitterComponent_GetIsActive) == 0x000001, "Wrong size on TerrorRadiusEmitterComponent_GetIsActive");
static_assert(offsetof(TerrorRadiusEmitterComponent_GetIsActive, ReturnValue) == 0x000000, "Member 'TerrorRadiusEmitterComponent_GetIsActive::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.GetRadius
// 0x0004 (0x0004 - 0x0000)
struct TerrorRadiusEmitterComponent_GetRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_GetRadius) == 0x000004, "Wrong alignment on TerrorRadiusEmitterComponent_GetRadius");
static_assert(sizeof(TerrorRadiusEmitterComponent_GetRadius) == 0x000004, "Wrong size on TerrorRadiusEmitterComponent_GetRadius");
static_assert(offsetof(TerrorRadiusEmitterComponent_GetRadius, ReturnValue) == 0x000000, "Member 'TerrorRadiusEmitterComponent_GetRadius::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.GetSimulatedFixedDistance
// 0x0004 (0x0004 - 0x0000)
struct TerrorRadiusEmitterComponent_GetSimulatedFixedDistance final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusEmitterComponent_GetSimulatedFixedDistance) == 0x000004, "Wrong alignment on TerrorRadiusEmitterComponent_GetSimulatedFixedDistance");
static_assert(sizeof(TerrorRadiusEmitterComponent_GetSimulatedFixedDistance) == 0x000004, "Wrong size on TerrorRadiusEmitterComponent_GetSimulatedFixedDistance");
static_assert(offsetof(TerrorRadiusEmitterComponent_GetSimulatedFixedDistance, ReturnValue) == 0x000000, "Member 'TerrorRadiusEmitterComponent_GetSimulatedFixedDistance::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterComponent.IsInTerrorRadius
// 0x0010 (0x0010 - 0x0000)
struct TerrorRadiusEmitterComponent_IsInTerrorRadius final
{
public:
	class UTerrorRadiusReceiverComponent*         receiver;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TerrorRadiusEmitterComponent_IsInTerrorRadius) == 0x000008, "Wrong alignment on TerrorRadiusEmitterComponent_IsInTerrorRadius");
static_assert(sizeof(TerrorRadiusEmitterComponent_IsInTerrorRadius) == 0x000010, "Wrong size on TerrorRadiusEmitterComponent_IsInTerrorRadius");
static_assert(offsetof(TerrorRadiusEmitterComponent_IsInTerrorRadius, receiver) == 0x000000, "Member 'TerrorRadiusEmitterComponent_IsInTerrorRadius::receiver' has a wrong offset!");
static_assert(offsetof(TerrorRadiusEmitterComponent_IsInTerrorRadius, ReturnValue) == 0x000008, "Member 'TerrorRadiusEmitterComponent_IsInTerrorRadius::ReturnValue' has a wrong offset!");

// Function DBDGameplay.SlasherTerrorRadiusEmitterComponent.SetBaseTerrorRadius
// 0x0008 (0x0008 - 0x0000)
struct SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius final
{
public:
	float                                         baseTerrorRadius;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          progressive;                                       // 0x0004(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius) == 0x000004, "Wrong alignment on SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius");
static_assert(sizeof(SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius) == 0x000008, "Wrong size on SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius");
static_assert(offsetof(SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius, baseTerrorRadius) == 0x000000, "Member 'SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius::baseTerrorRadius' has a wrong offset!");
static_assert(offsetof(SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius, progressive) == 0x000004, "Member 'SlasherTerrorRadiusEmitterComponent_SetBaseTerrorRadius::progressive' has a wrong offset!");

// Function DBDGameplay.StruggleComponent.OnSkillCheckEnd
// 0x0010 (0x0010 - 0x0000)
struct StruggleComponent_OnSkillCheckEnd final
{
public:
	bool                                          hadInput;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          success;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bonus;                                             // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         type;                                              // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StruggleComponent_OnSkillCheckEnd) == 0x000008, "Wrong alignment on StruggleComponent_OnSkillCheckEnd");
static_assert(sizeof(StruggleComponent_OnSkillCheckEnd) == 0x000010, "Wrong size on StruggleComponent_OnSkillCheckEnd");
static_assert(offsetof(StruggleComponent_OnSkillCheckEnd, hadInput) == 0x000000, "Member 'StruggleComponent_OnSkillCheckEnd::hadInput' has a wrong offset!");
static_assert(offsetof(StruggleComponent_OnSkillCheckEnd, success) == 0x000001, "Member 'StruggleComponent_OnSkillCheckEnd::success' has a wrong offset!");
static_assert(offsetof(StruggleComponent_OnSkillCheckEnd, bonus) == 0x000002, "Member 'StruggleComponent_OnSkillCheckEnd::bonus' has a wrong offset!");
static_assert(offsetof(StruggleComponent_OnSkillCheckEnd, type) == 0x000003, "Member 'StruggleComponent_OnSkillCheckEnd::type' has a wrong offset!");
static_assert(offsetof(StruggleComponent_OnSkillCheckEnd, player) == 0x000008, "Member 'StruggleComponent_OnSkillCheckEnd::player' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusEmitterFunctionLibrary.GetActiveFakeTerrorRadiusEmittersCount
// 0x0010 (0x0010 - 0x0000)
struct TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount final
{
public:
	const class UObject*                          worldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount) == 0x000008, "Wrong alignment on TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount");
static_assert(sizeof(TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount) == 0x000010, "Wrong size on TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount");
static_assert(offsetof(TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount, worldContextObject) == 0x000000, "Member 'TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount::worldContextObject' has a wrong offset!");
static_assert(offsetof(TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount, ReturnValue) == 0x000008, "Member 'TerrorRadiusEmitterFunctionLibrary_GetActiveFakeTerrorRadiusEmittersCount::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusReceiverComponent.IsInTerrorRadius
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusReceiverComponent_IsInTerrorRadius final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusReceiverComponent_IsInTerrorRadius) == 0x000001, "Wrong alignment on TerrorRadiusReceiverComponent_IsInTerrorRadius");
static_assert(sizeof(TerrorRadiusReceiverComponent_IsInTerrorRadius) == 0x000001, "Wrong size on TerrorRadiusReceiverComponent_IsInTerrorRadius");
static_assert(offsetof(TerrorRadiusReceiverComponent_IsInTerrorRadius, ReturnValue) == 0x000000, "Member 'TerrorRadiusReceiverComponent_IsInTerrorRadius::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusReceiverComponent.IsInTerrorRadiusRange
// 0x0001 (0x0001 - 0x0000)
struct TerrorRadiusReceiverComponent_IsInTerrorRadiusRange final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusReceiverComponent_IsInTerrorRadiusRange) == 0x000001, "Wrong alignment on TerrorRadiusReceiverComponent_IsInTerrorRadiusRange");
static_assert(sizeof(TerrorRadiusReceiverComponent_IsInTerrorRadiusRange) == 0x000001, "Wrong size on TerrorRadiusReceiverComponent_IsInTerrorRadiusRange");
static_assert(offsetof(TerrorRadiusReceiverComponent_IsInTerrorRadiusRange, ReturnValue) == 0x000000, "Member 'TerrorRadiusReceiverComponent_IsInTerrorRadiusRange::ReturnValue' has a wrong offset!");

// Function DBDGameplay.TerrorRadiusScreenIndicatorComponent.OnHeartStateChanged
// 0x000C (0x000C - 0x0000)
struct TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged final
{
public:
	struct FGameplayTag                           heartState;                                        // 0x0000(0x000C)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged) == 0x000004, "Wrong alignment on TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged");
static_assert(sizeof(TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged) == 0x00000C, "Wrong size on TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged");
static_assert(offsetof(TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged, heartState) == 0x000000, "Member 'TerrorRadiusScreenIndicatorComponent_OnHeartStateChanged::heartState' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.Authority_AddWiggleCharge
// 0x0004 (0x0004 - 0x0000)
struct WiggleComponent_Authority_AddWiggleCharge final
{
public:
	float                                         chargeAmount;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_Authority_AddWiggleCharge) == 0x000004, "Wrong alignment on WiggleComponent_Authority_AddWiggleCharge");
static_assert(sizeof(WiggleComponent_Authority_AddWiggleCharge) == 0x000004, "Wrong size on WiggleComponent_Authority_AddWiggleCharge");
static_assert(offsetof(WiggleComponent_Authority_AddWiggleCharge, chargeAmount) == 0x000000, "Member 'WiggleComponent_Authority_AddWiggleCharge::chargeAmount' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.OnHideWiggleSkillCheck
// 0x0001 (0x0001 - 0x0000)
struct WiggleComponent_OnHideWiggleSkillCheck final
{
public:
	ESkillCheckCustomType                         type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_OnHideWiggleSkillCheck) == 0x000001, "Wrong alignment on WiggleComponent_OnHideWiggleSkillCheck");
static_assert(sizeof(WiggleComponent_OnHideWiggleSkillCheck) == 0x000001, "Wrong size on WiggleComponent_OnHideWiggleSkillCheck");
static_assert(offsetof(WiggleComponent_OnHideWiggleSkillCheck, type) == 0x000000, "Member 'WiggleComponent_OnHideWiggleSkillCheck::type' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.OnPickedUpSkillCheckEnd
// 0x0010 (0x0010 - 0x0000)
struct WiggleComponent_OnPickedUpSkillCheckEnd final
{
public:
	bool                                          hadInput;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          success;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bonus;                                             // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         type;                                              // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_OnPickedUpSkillCheckEnd) == 0x000008, "Wrong alignment on WiggleComponent_OnPickedUpSkillCheckEnd");
static_assert(sizeof(WiggleComponent_OnPickedUpSkillCheckEnd) == 0x000010, "Wrong size on WiggleComponent_OnPickedUpSkillCheckEnd");
static_assert(offsetof(WiggleComponent_OnPickedUpSkillCheckEnd, hadInput) == 0x000000, "Member 'WiggleComponent_OnPickedUpSkillCheckEnd::hadInput' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnPickedUpSkillCheckEnd, success) == 0x000001, "Member 'WiggleComponent_OnPickedUpSkillCheckEnd::success' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnPickedUpSkillCheckEnd, bonus) == 0x000002, "Member 'WiggleComponent_OnPickedUpSkillCheckEnd::bonus' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnPickedUpSkillCheckEnd, type) == 0x000003, "Member 'WiggleComponent_OnPickedUpSkillCheckEnd::type' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnPickedUpSkillCheckEnd, player) == 0x000008, "Member 'WiggleComponent_OnPickedUpSkillCheckEnd::player' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.OnPlayerPickedUpEnd
// 0x0008 (0x0008 - 0x0000)
struct WiggleComponent_OnPlayerPickedUpEnd final
{
public:
	class ADBDPlayer*                             picker;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_OnPlayerPickedUpEnd) == 0x000008, "Wrong alignment on WiggleComponent_OnPlayerPickedUpEnd");
static_assert(sizeof(WiggleComponent_OnPlayerPickedUpEnd) == 0x000008, "Wrong size on WiggleComponent_OnPlayerPickedUpEnd");
static_assert(offsetof(WiggleComponent_OnPlayerPickedUpEnd, picker) == 0x000000, "Member 'WiggleComponent_OnPlayerPickedUpEnd::picker' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.OnPlayerPickedUpStart
// 0x0008 (0x0008 - 0x0000)
struct WiggleComponent_OnPlayerPickedUpStart final
{
public:
	class ADBDPlayer*                             picker;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_OnPlayerPickedUpStart) == 0x000008, "Wrong alignment on WiggleComponent_OnPlayerPickedUpStart");
static_assert(sizeof(WiggleComponent_OnPlayerPickedUpStart) == 0x000008, "Wrong size on WiggleComponent_OnPlayerPickedUpStart");
static_assert(offsetof(WiggleComponent_OnPlayerPickedUpStart, picker) == 0x000000, "Member 'WiggleComponent_OnPlayerPickedUpStart::picker' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.OnWiggleSkillCheckEnd
// 0x0010 (0x0010 - 0x0000)
struct WiggleComponent_OnWiggleSkillCheckEnd final
{
public:
	bool                                          hadInput;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          success;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bonus;                                             // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         type;                                              // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_OnWiggleSkillCheckEnd) == 0x000008, "Wrong alignment on WiggleComponent_OnWiggleSkillCheckEnd");
static_assert(sizeof(WiggleComponent_OnWiggleSkillCheckEnd) == 0x000010, "Wrong size on WiggleComponent_OnWiggleSkillCheckEnd");
static_assert(offsetof(WiggleComponent_OnWiggleSkillCheckEnd, hadInput) == 0x000000, "Member 'WiggleComponent_OnWiggleSkillCheckEnd::hadInput' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnWiggleSkillCheckEnd, success) == 0x000001, "Member 'WiggleComponent_OnWiggleSkillCheckEnd::success' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnWiggleSkillCheckEnd, bonus) == 0x000002, "Member 'WiggleComponent_OnWiggleSkillCheckEnd::bonus' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnWiggleSkillCheckEnd, type) == 0x000003, "Member 'WiggleComponent_OnWiggleSkillCheckEnd::type' has a wrong offset!");
static_assert(offsetof(WiggleComponent_OnWiggleSkillCheckEnd, player) == 0x000008, "Member 'WiggleComponent_OnWiggleSkillCheckEnd::player' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.DBD_SetWiggleProgress
// 0x0004 (0x0004 - 0x0000)
struct WiggleComponent_DBD_SetWiggleProgress final
{
public:
	float                                         progressPercent;                                   // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_DBD_SetWiggleProgress) == 0x000004, "Wrong alignment on WiggleComponent_DBD_SetWiggleProgress");
static_assert(sizeof(WiggleComponent_DBD_SetWiggleProgress) == 0x000004, "Wrong size on WiggleComponent_DBD_SetWiggleProgress");
static_assert(offsetof(WiggleComponent_DBD_SetWiggleProgress, progressPercent) == 0x000000, "Member 'WiggleComponent_DBD_SetWiggleProgress::progressPercent' has a wrong offset!");

// Function DBDGameplay.WiggleComponent.GetWiggleChargeable
// 0x0008 (0x0008 - 0x0000)
struct WiggleComponent_GetWiggleChargeable final
{
public:
	class UChargeableComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleComponent_GetWiggleChargeable) == 0x000008, "Wrong alignment on WiggleComponent_GetWiggleChargeable");
static_assert(sizeof(WiggleComponent_GetWiggleChargeable) == 0x000008, "Wrong size on WiggleComponent_GetWiggleChargeable");
static_assert(offsetof(WiggleComponent_GetWiggleChargeable, ReturnValue) == 0x000000, "Member 'WiggleComponent_GetWiggleChargeable::ReturnValue' has a wrong offset!");

// Function DBDGameplay.WiggleFreeComponent.Authority_OnChargeableCompleteEvent
// 0x0018 (0x0018 - 0x0000)
struct WiggleFreeComponent_Authority_OnChargeableCompleteEvent final
{
public:
	bool                                          completed;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         instigatorsForCompletion;                          // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleFreeComponent_Authority_OnChargeableCompleteEvent) == 0x000008, "Wrong alignment on WiggleFreeComponent_Authority_OnChargeableCompleteEvent");
static_assert(sizeof(WiggleFreeComponent_Authority_OnChargeableCompleteEvent) == 0x000018, "Wrong size on WiggleFreeComponent_Authority_OnChargeableCompleteEvent");
static_assert(offsetof(WiggleFreeComponent_Authority_OnChargeableCompleteEvent, completed) == 0x000000, "Member 'WiggleFreeComponent_Authority_OnChargeableCompleteEvent::completed' has a wrong offset!");
static_assert(offsetof(WiggleFreeComponent_Authority_OnChargeableCompleteEvent, instigatorsForCompletion) == 0x000008, "Member 'WiggleFreeComponent_Authority_OnChargeableCompleteEvent::instigatorsForCompletion' has a wrong offset!");

// Function DBDGameplay.WiggleFreeComponent.Authority_OnPlayerPickedUpEnd
// 0x0008 (0x0008 - 0x0000)
struct WiggleFreeComponent_Authority_OnPlayerPickedUpEnd final
{
public:
	class ADBDPlayer*                             picker;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleFreeComponent_Authority_OnPlayerPickedUpEnd) == 0x000008, "Wrong alignment on WiggleFreeComponent_Authority_OnPlayerPickedUpEnd");
static_assert(sizeof(WiggleFreeComponent_Authority_OnPlayerPickedUpEnd) == 0x000008, "Wrong size on WiggleFreeComponent_Authority_OnPlayerPickedUpEnd");
static_assert(offsetof(WiggleFreeComponent_Authority_OnPlayerPickedUpEnd, picker) == 0x000000, "Member 'WiggleFreeComponent_Authority_OnPlayerPickedUpEnd::picker' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.OnHideWiggleSkillCheck
// 0x0001 (0x0001 - 0x0000)
struct WiggleMotionComponent_OnHideWiggleSkillCheck final
{
public:
	ESkillCheckCustomType                         type;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_OnHideWiggleSkillCheck) == 0x000001, "Wrong alignment on WiggleMotionComponent_OnHideWiggleSkillCheck");
static_assert(sizeof(WiggleMotionComponent_OnHideWiggleSkillCheck) == 0x000001, "Wrong size on WiggleMotionComponent_OnHideWiggleSkillCheck");
static_assert(offsetof(WiggleMotionComponent_OnHideWiggleSkillCheck, type) == 0x000000, "Member 'WiggleMotionComponent_OnHideWiggleSkillCheck::type' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.OnSurvivorPickedUp
// 0x0008 (0x0008 - 0x0000)
struct WiggleMotionComponent_OnSurvivorPickedUp final
{
public:
	class ADBDPlayer*                             target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_OnSurvivorPickedUp) == 0x000008, "Wrong alignment on WiggleMotionComponent_OnSurvivorPickedUp");
static_assert(sizeof(WiggleMotionComponent_OnSurvivorPickedUp) == 0x000008, "Wrong size on WiggleMotionComponent_OnSurvivorPickedUp");
static_assert(offsetof(WiggleMotionComponent_OnSurvivorPickedUp, target) == 0x000000, "Member 'WiggleMotionComponent_OnSurvivorPickedUp::target' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.OnSurvivorRemoved
// 0x0008 (0x0008 - 0x0000)
struct WiggleMotionComponent_OnSurvivorRemoved final
{
public:
	class ADBDPlayer*                             target;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_OnSurvivorRemoved) == 0x000008, "Wrong alignment on WiggleMotionComponent_OnSurvivorRemoved");
static_assert(sizeof(WiggleMotionComponent_OnSurvivorRemoved) == 0x000008, "Wrong size on WiggleMotionComponent_OnSurvivorRemoved");
static_assert(offsetof(WiggleMotionComponent_OnSurvivorRemoved, target) == 0x000000, "Member 'WiggleMotionComponent_OnSurvivorRemoved::target' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.OnWiggleSkillCheckEnd
// 0x0010 (0x0010 - 0x0000)
struct WiggleMotionComponent_OnWiggleSkillCheckEnd final
{
public:
	bool                                          hadInput;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          success;                                           // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bonus;                                             // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCheckCustomType                         type;                                              // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_OnWiggleSkillCheckEnd) == 0x000008, "Wrong alignment on WiggleMotionComponent_OnWiggleSkillCheckEnd");
static_assert(sizeof(WiggleMotionComponent_OnWiggleSkillCheckEnd) == 0x000010, "Wrong size on WiggleMotionComponent_OnWiggleSkillCheckEnd");
static_assert(offsetof(WiggleMotionComponent_OnWiggleSkillCheckEnd, hadInput) == 0x000000, "Member 'WiggleMotionComponent_OnWiggleSkillCheckEnd::hadInput' has a wrong offset!");
static_assert(offsetof(WiggleMotionComponent_OnWiggleSkillCheckEnd, success) == 0x000001, "Member 'WiggleMotionComponent_OnWiggleSkillCheckEnd::success' has a wrong offset!");
static_assert(offsetof(WiggleMotionComponent_OnWiggleSkillCheckEnd, bonus) == 0x000002, "Member 'WiggleMotionComponent_OnWiggleSkillCheckEnd::bonus' has a wrong offset!");
static_assert(offsetof(WiggleMotionComponent_OnWiggleSkillCheckEnd, type) == 0x000003, "Member 'WiggleMotionComponent_OnWiggleSkillCheckEnd::type' has a wrong offset!");
static_assert(offsetof(WiggleMotionComponent_OnWiggleSkillCheckEnd, player) == 0x000008, "Member 'WiggleMotionComponent_OnWiggleSkillCheckEnd::player' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.Server_SetIsBeingWiggled
// 0x0001 (0x0001 - 0x0000)
struct WiggleMotionComponent_Server_SetIsBeingWiggled final
{
public:
	bool                                          isBeingWiggled;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_Server_SetIsBeingWiggled) == 0x000001, "Wrong alignment on WiggleMotionComponent_Server_SetIsBeingWiggled");
static_assert(sizeof(WiggleMotionComponent_Server_SetIsBeingWiggled) == 0x000001, "Wrong size on WiggleMotionComponent_Server_SetIsBeingWiggled");
static_assert(offsetof(WiggleMotionComponent_Server_SetIsBeingWiggled, isBeingWiggled) == 0x000000, "Member 'WiggleMotionComponent_Server_SetIsBeingWiggled::isBeingWiggled' has a wrong offset!");

// Function DBDGameplay.WiggleMotionComponent.SetIsBeingWiggled
// 0x0001 (0x0001 - 0x0000)
struct WiggleMotionComponent_SetIsBeingWiggled final
{
public:
	bool                                          isBeingWiggled;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WiggleMotionComponent_SetIsBeingWiggled) == 0x000001, "Wrong alignment on WiggleMotionComponent_SetIsBeingWiggled");
static_assert(sizeof(WiggleMotionComponent_SetIsBeingWiggled) == 0x000001, "Wrong size on WiggleMotionComponent_SetIsBeingWiggled");
static_assert(offsetof(WiggleMotionComponent_SetIsBeingWiggled, isBeingWiggled) == 0x000000, "Member 'WiggleMotionComponent_SetIsBeingWiggled::isBeingWiggled' has a wrong offset!");

}

