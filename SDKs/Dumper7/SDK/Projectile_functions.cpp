#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Projectile

#include "Basic.hpp"

#include "Projectile_classes.hpp"
#include "Projectile_parameters.hpp"


namespace SDK
{

// Function Projectile.DBDProjectileMovementComponent.AddComponentToSweep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDBDProjectileMovementComponent::AddComponentToSweep(class UPrimitiveComponent* component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDProjectileMovementComponent", "AddComponentToSweep");

	Params::DBDProjectileMovementComponent_AddComponentToSweep Parms{};

	Parms.component = component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.DBDProjectileMovementComponent.GetPreviousLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector UDBDProjectileMovementComponent::GetPreviousLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DBDProjectileMovementComponent", "GetPreviousLocation");

	Params::DBDProjectileMovementComponent_GetPreviousLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.Authority_TryDetectCollision
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const struct FImpactInfo&               impactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::Authority_TryDetectCollision(const struct FImpactInfo& impactInfo, bool force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "Authority_TryDetectCollision");

	Params::BaseProjectile_Authority_TryDetectCollision Parms{};

	Parms.impactInfo = std::move(impactInfo);
	Parms.force = force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.IsValidImpactDetection
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// const struct FImpactInfo&               impactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::IsValidImpactDetection(const struct FImpactInfo& impactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "IsValidImpactDetection");

	Params::BaseProjectile_IsValidImpactDetection Parms{};

	Parms.impactInfo = std::move(impactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.IsValidPlayerDetection
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// const struct FImpactInfo&               impactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::IsValidPlayerDetection(const struct FImpactInfo& impactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "IsValidPlayerDetection");

	Params::BaseProjectile_IsValidPlayerDetection Parms{};

	Parms.impactInfo = std::move(impactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.Local_OnPlayerDetected
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FImpactInfo&               impactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FVector&                   projectileLocation                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::Local_OnPlayerDetected(const struct FImpactInfo& impactInfo, const struct FVector& projectileLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "Local_OnPlayerDetected");

	Params::BaseProjectile_Local_OnPlayerDetected Parms{};

	Parms.impactInfo = std::move(impactInfo);
	Parms.projectileLocation = std::move(projectileLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.Local_SweepImpactCollision
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   start                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   end                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  colliderRotation                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult*                      outHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::Local_SweepImpactCollision(const struct FVector& start, const struct FVector& end, const struct FRotator& colliderRotation, struct FHitResult* outHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "Local_SweepImpactCollision");

	Params::BaseProjectile_Local_SweepImpactCollision Parms{};

	Parms.start = std::move(start);
	Parms.end = std::move(end);
	Parms.colliderRotation = std::move(colliderRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outHit != nullptr)
		*outHit = std::move(Parms.outHit);

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.Local_TryDetectCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FImpactInfo&               impactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::Local_TryDetectCollision(const struct FImpactInfo& impactInfo, bool force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "Local_TryDetectCollision");

	Params::BaseProjectile_Local_TryDetectCollision Parms{};

	Parms.impactInfo = std::move(impactInfo);
	Parms.force = force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.OnDetectCollision
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FImpactInfo&               impactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABaseProjectile::OnDetectCollision(const struct FImpactInfo& impactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "OnDetectCollision");

	Params::BaseProjectile_OnDetectCollision Parms{};

	Parms.impactInfo = std::move(impactInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectile.OnDetectPlayer
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FImpactInfo&               impactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABaseProjectile::OnDetectPlayer(const struct FImpactInfo& impactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "OnDetectPlayer");

	Params::BaseProjectile_OnDetectPlayer Parms{};

	Parms.impactInfo = std::move(impactInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectile.OnLaunch
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FLaunchInfo&               launchInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    hasImpactOnLaunch                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseProjectile::OnLaunch(const struct FLaunchInfo& launchInfo, bool hasImpactOnLaunch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "OnLaunch");

	Params::BaseProjectile_OnLaunch Parms{};

	Parms.launchInfo = std::move(launchInfo);
	Parms.hasImpactOnLaunch = hasImpactOnLaunch;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectile.OnSetActive
// (Event, Protected, BlueprintEvent)
// Parameters:
// const bool                              active                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseProjectile::OnSetActive(const bool active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "OnSetActive");

	Params::BaseProjectile_OnSetActive Parms{};

	Parms.active = active;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectile.GetAddLauncherVeloctyFactor
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABaseProjectile::GetAddLauncherVeloctyFactor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "GetAddLauncherVeloctyFactor");

	Params::BaseProjectile_GetAddLauncherVeloctyFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.GetImpactPrimitiveComponent
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* ABaseProjectile::GetImpactPrimitiveComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "GetImpactPrimitiveComponent");

	Params::BaseProjectile_GetImpactPrimitiveComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.GetLauncher
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBaseProjectileLauncher*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseProjectileLauncher* ABaseProjectile::GetLauncher() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "GetLauncher");

	Params::BaseProjectile_GetLauncher Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.IsOwningPawnLocallyControlled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::IsOwningPawnLocallyControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "IsOwningPawnLocallyControlled");

	Params::BaseProjectile_IsOwningPawnLocallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectile.SphereTraceSingle
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   end                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USphereComponent*                 sphere                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      outHitResult                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABaseProjectile::SphereTraceSingle(const struct FVector& start, const struct FVector& end, class USphereComponent* sphere, struct FHitResult* outHitResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectile", "SphereTraceSingle");

	Params::BaseProjectile_SphereTraceSingle Parms{};

	Parms.start = std::move(start);
	Parms.end = std::move(end);
	Parms.sphere = sphere;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outHitResult != nullptr)
		*outHitResult = std::move(Parms.outHitResult);

	return Parms.ReturnValue;
}


// Function Projectile.SingleProjectileProviderComponent.OnRep_Projectile
// (Final, Native, Private)

void USingleProjectileProviderComponent::OnRep_Projectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SingleProjectileProviderComponent", "OnRep_Projectile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Client_LaunchRefusedByServer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class ABaseProjectile*                  projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Client_LaunchRefusedByServer(class ABaseProjectile* projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Client_LaunchRefusedByServer");

	Params::BaseProjectileReplicationComponent_Client_LaunchRefusedByServer Parms{};

	Parms.projectile = projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Client_ReceiveDetectPlayerValidation
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class ABaseProjectile*                  projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Client_ReceiveDetectPlayerValidation(class ABaseProjectile* projectile, bool success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Client_ReceiveDetectPlayerValidation");

	Params::BaseProjectileReplicationComponent_Client_ReceiveDetectPlayerValidation Parms{};

	Parms.projectile = projectile;
	Parms.success = success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Multicast_DetectImpact
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseProjectile*                  projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FImpactInfo&               impactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Multicast_DetectImpact(class ABaseProjectile* projectile, const struct FImpactInfo& impactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Multicast_DetectImpact");

	Params::BaseProjectileReplicationComponent_Multicast_DetectImpact Parms{};

	Parms.projectile = projectile;
	Parms.impactInfo = std::move(impactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Multicast_DetectPlayer
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseProjectile*                  projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FImpactInfo&               impactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Multicast_DetectPlayer(class ABaseProjectile* projectile, const struct FImpactInfo& impactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Multicast_DetectPlayer");

	Params::BaseProjectileReplicationComponent_Multicast_DetectPlayer Parms{};

	Parms.projectile = projectile;
	Parms.impactInfo = std::move(impactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Multicast_OnLaunch
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseProjectile*                  projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLaunchInfo&               launchInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Multicast_OnLaunch(class ABaseProjectile* projectile, const struct FLaunchInfo& launchInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Multicast_OnLaunch");

	Params::BaseProjectileReplicationComponent_Multicast_OnLaunch Parms{};

	Parms.projectile = projectile;
	Parms.launchInfo = std::move(launchInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Multicast_OnLaunchWithImpact
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseProjectile*                  projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLaunchInfo&               launchInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FImpactInfo&               impactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Multicast_OnLaunchWithImpact(class ABaseProjectile* projectile, const struct FLaunchInfo& launchInfo, const struct FImpactInfo& impactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Multicast_OnLaunchWithImpact");

	Params::BaseProjectileReplicationComponent_Multicast_OnLaunchWithImpact Parms{};

	Parms.projectile = projectile;
	Parms.launchInfo = std::move(launchInfo);
	Parms.impactInfo = std::move(impactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Multicast_SendAuthorityDetectPlayer
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ABaseProjectile*                  projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FImpactInfo&               impactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Multicast_SendAuthorityDetectPlayer(class ABaseProjectile* projectile, const struct FImpactInfo& impactInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Multicast_SendAuthorityDetectPlayer");

	Params::BaseProjectileReplicationComponent_Multicast_SendAuthorityDetectPlayer Parms{};

	Parms.projectile = projectile;
	Parms.impactInfo = std::move(impactInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileReplicationComponent.Server_TryDetectPlayer
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class ABaseProjectile*                  projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FImpactInfo&               impactInfo                                             (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FVector_NetQuantize100&    projectileLocation                                     (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector_NetQuantize10&     projectileRotation                                     (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             targetLocationTimestamp                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileReplicationComponent::Server_TryDetectPlayer(class ABaseProjectile* projectile, const struct FImpactInfo& impactInfo, const struct FVector_NetQuantize100& projectileLocation, const struct FVector_NetQuantize10& projectileRotation, const float targetLocationTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileReplicationComponent", "Server_TryDetectPlayer");

	Params::BaseProjectileReplicationComponent_Server_TryDetectPlayer Parms{};

	Parms.projectile = projectile;
	Parms.impactInfo = std::move(impactInfo);
	Parms.projectileLocation = std::move(projectileLocation);
	Parms.projectileRotation = std::move(projectileRotation);
	Parms.targetLocationTimestamp = targetLocationTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Authority_AddMaxAmmo
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ammoToAdd                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::Authority_AddMaxAmmo(int32 ammoToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Authority_AddMaxAmmo");

	Params::BaseProjectileLauncher_Authority_AddMaxAmmo Parms{};

	Parms.ammoToAdd = ammoToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Authority_Launch
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UBaseProjectileLauncher::Authority_Launch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Authority_Launch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Authority_Reload
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UBaseProjectileLauncher::Authority_Reload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Authority_Reload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Authority_ReturnAmmoUnits
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   amountOfAmmoUnitsReturned                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::Authority_ReturnAmmoUnits(int32 amountOfAmmoUnitsReturned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Authority_ReturnAmmoUnits");

	Params::BaseProjectileLauncher_Authority_ReturnAmmoUnits Parms{};

	Parms.amountOfAmmoUnitsReturned = amountOfAmmoUnitsReturned;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Authority_SetMaxAmmo
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   newMaxAmmo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isMaxAmmoImmutable                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::Authority_SetMaxAmmo(int32 newMaxAmmo, bool isMaxAmmoImmutable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Authority_SetMaxAmmo");

	Params::BaseProjectileLauncher_Authority_SetMaxAmmo Parms{};

	Parms.newMaxAmmo = newMaxAmmo;
	Parms.isMaxAmmoImmutable = isMaxAmmoImmutable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Cosmetic_OnOutOfAmmo
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void UBaseProjectileLauncher::Cosmetic_OnOutOfAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Cosmetic_OnOutOfAmmo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Projectile.BaseProjectileLauncher.Local_Launch
// (Final, Native, Public, BlueprintCallable)

void UBaseProjectileLauncher::Local_Launch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Local_Launch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.OnLaunch
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FLaunchInfo&               launchInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class ABaseProjectile*                  projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::OnLaunch(const struct FLaunchInfo& launchInfo, class ABaseProjectile* projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "OnLaunch");

	Params::BaseProjectileLauncher_OnLaunch Parms{};

	Parms.launchInfo = std::move(launchInfo);
	Parms.projectile = projectile;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectileLauncher.OnRep_Ammo
// (Native, Protected)
// Parameters:
// int32                                   oldAmmo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::OnRep_Ammo(int32 oldAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "OnRep_Ammo");

	Params::BaseProjectileLauncher_OnRep_Ammo Parms{};

	Parms.oldAmmo = oldAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.OnRep_MaxAmmo
// (Native, Protected)
// Parameters:
// int32                                   oldMaxAmmo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::OnRep_MaxAmmo(int32 oldMaxAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "OnRep_MaxAmmo");

	Params::BaseProjectileLauncher_OnRep_MaxAmmo Parms{};

	Parms.oldMaxAmmo = oldMaxAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Server_Launch
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const struct FLaunchInfo&               launchInfo                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ABaseProjectile*                  projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::Server_Launch(const struct FLaunchInfo& launchInfo, class ABaseProjectile* projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Server_Launch");

	Params::BaseProjectileLauncher_Server_Launch Parms{};

	Parms.launchInfo = std::move(launchInfo);
	Parms.projectile = projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.Server_LaunchWithImpact
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const struct FLaunchInfo&               launchInfo                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FImpactInfo&               impactInfo                                             (ConstParm, Parm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class ABaseProjectile*                  projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::Server_LaunchWithImpact(const struct FLaunchInfo& launchInfo, const struct FImpactInfo& impactInfo, class ABaseProjectile* projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "Server_LaunchWithImpact");

	Params::BaseProjectileLauncher_Server_LaunchWithImpact Parms{};

	Parms.launchInfo = std::move(launchInfo);
	Parms.impactInfo = std::move(impactInfo);
	Parms.projectile = projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.SetProjectileProvider
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IProjectileProvider>projectileProvider                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::SetProjectileProvider(TScriptInterface<class IProjectileProvider> projectileProvider)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "SetProjectileProvider");

	Params::BaseProjectileLauncher_SetProjectileProvider Parms{};

	Parms.projectileProvider = projectileProvider;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Projectile.BaseProjectileLauncher.SetProjectileVar
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             varName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseProjectileLauncher::SetProjectileVar(class FName varName, float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "SetProjectileVar");

	Params::BaseProjectileLauncher_SetProjectileVar Parms{};

	Parms.varName = varName;
	Parms.value = value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Projectile.BaseProjectileLauncher.GetAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBaseProjectileLauncher::GetAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetAmmo");

	Params::BaseProjectileLauncher_GetAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetLaunchDirection
// (Native, Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBaseProjectileLauncher::GetLaunchDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetLaunchDirection");

	Params::BaseProjectileLauncher_GetLaunchDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetLaunchDirectionAtViewAndThrowPowerRatio
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const struct FRotator&                  viewRotation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   throwPowerRatio                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBaseProjectileLauncher::GetLaunchDirectionAtViewAndThrowPowerRatio(const struct FRotator& viewRotation, float throwPowerRatio) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetLaunchDirectionAtViewAndThrowPowerRatio");

	Params::BaseProjectileLauncher_GetLaunchDirectionAtViewAndThrowPowerRatio Parms{};

	Parms.viewRotation = std::move(viewRotation);
	Parms.throwPowerRatio = throwPowerRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetLaunchPosition
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UBaseProjectileLauncher::GetLaunchPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetLaunchPosition");

	Params::BaseProjectileLauncher_GetLaunchPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetLaunchSpeed
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBaseProjectileLauncher::GetLaunchSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetLaunchSpeed");

	Params::BaseProjectileLauncher_GetLaunchSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetLaunchSpeedAtThrowPowerRatio
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   throwPowerRatio                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBaseProjectileLauncher::GetLaunchSpeedAtThrowPowerRatio(float throwPowerRatio) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetLaunchSpeedAtThrowPowerRatio");

	Params::BaseProjectileLauncher_GetLaunchSpeedAtThrowPowerRatio Parms{};

	Parms.throwPowerRatio = throwPowerRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetOwningPawn
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UBaseProjectileLauncher::GetOwningPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetOwningPawn");

	Params::BaseProjectileLauncher_GetOwningPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.GetProjectileToLaunch
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class ABaseProjectile*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABaseProjectile* UBaseProjectileLauncher::GetProjectileToLaunch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "GetProjectileToLaunch");

	Params::BaseProjectileLauncher_GetProjectileToLaunch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.HasAuthority
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseProjectileLauncher::HasAuthority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "HasAuthority");

	Params::BaseProjectileLauncher_HasAuthority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.HasProjectile
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseProjectileLauncher::HasProjectile() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "HasProjectile");

	Params::BaseProjectileLauncher_HasProjectile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.IsAmmoFull
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseProjectileLauncher::IsAmmoFull() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "IsAmmoFull");

	Params::BaseProjectileLauncher_IsAmmoFull Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.BaseProjectileLauncher.IsLocallyControlled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseProjectileLauncher::IsLocallyControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseProjectileLauncher", "IsLocallyControlled");

	Params::BaseProjectileLauncher_IsLocallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Projectile.AuthoritativePoolProjectileProviderAdapter.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAuthoritativeActorPoolComponent* pool                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuthoritativePoolProjectileProviderAdapter::Init(class UAuthoritativeActorPoolComponent* pool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthoritativePoolProjectileProviderAdapter", "Init");

	Params::AuthoritativePoolProjectileProviderAdapter_Init Parms{};

	Parms.pool = pool;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

