#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK23

#include "Basic.hpp"

#include "TheK23_classes.hpp"
#include "TheK23_parameters.hpp"


namespace SDK
{

// Function TheK23.FastTrack.Cosmetic_OnTokenCountDecreased
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void UFastTrack::Cosmetic_OnTokenCountDecreased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FastTrack", "Cosmetic_OnTokenCountDecreased");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheK23.FlurryComboScoreComponent.OnRep_ComboScore
// (Final, Native, Private, Const)

void UFlurryComboScoreComponent::OnRep_ComboScore() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlurryComboScoreComponent", "OnRep_ComboScore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.FlurryOfKnives.Multicast_StartThrowing
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void UFlurryOfKnives::Multicast_StartThrowing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlurryOfKnives", "Multicast_StartThrowing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.FlurryOfKnives.OnRep_NumOfStacksReduction
// (Final, Native, Private)

void UFlurryOfKnives::OnRep_NumOfStacksReduction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlurryOfKnives", "OnRep_NumOfStacksReduction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.FlurryOfKnives.Server_DecreaseConsecutiveKnivesStacks
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void UFlurryOfKnives::Server_DecreaseConsecutiveKnivesStacks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlurryOfKnives", "Server_DecreaseConsecutiveKnivesStacks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.FlurryOfKnives.Server_StartThrowing
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void UFlurryOfKnives::Server_StartThrowing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlurryOfKnives", "Server_StartThrowing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.KnifeProjectile.BP_CosmeticOnAddonExplosion
// (BlueprintCosmetic, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKnifeProjectile::BP_CosmeticOnAddonExplosion(const struct FVector& location, const struct FVector& normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnifeProjectile", "BP_CosmeticOnAddonExplosion");

	Params::KnifeProjectile_BP_CosmeticOnAddonExplosion Parms{};

	Parms.location = std::move(location);
	Parms.normal = std::move(normal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheK23.KnifeProjectile.BP_OnLaunchCosmetic
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// const struct FLaunchInfo&               launchInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    hasImpactOnLaunch                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKnifeProjectile::BP_OnLaunchCosmetic(const struct FLaunchInfo& launchInfo, bool hasImpactOnLaunch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnifeProjectile", "BP_OnLaunchCosmetic");

	Params::KnifeProjectile_BP_OnLaunchCosmetic Parms{};

	Parms.launchInfo = std::move(launchInfo);
	Parms.hasImpactOnLaunch = hasImpactOnLaunch;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheK23.KnifeProjectile.BP_SetKnifeActive
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKnifeProjectile::BP_SetKnifeActive(bool active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnifeProjectile", "BP_SetKnifeActive");

	Params::KnifeProjectile_BP_SetKnifeActive Parms{};

	Parms.active = active;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheK23.KnifeProjectile.OnProjectileBounce
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// const struct FHitResult&                impactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FVector&                   impactVelocity                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKnifeProjectile::OnProjectileBounce(const struct FHitResult& impactResult, const struct FVector& impactVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnifeProjectile", "OnProjectileBounce");

	Params::KnifeProjectile_OnProjectileBounce Parms{};

	Parms.impactResult = std::move(impactResult);
	Parms.impactVelocity = std::move(impactVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.KnifeProjectile.OnWorldColliderHit
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              hitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           otherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              otherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   normalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AKnifeProjectile::OnWorldColliderHit(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, const struct FVector& normalImpulse, const struct FHitResult& hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnifeProjectile", "OnWorldColliderHit");

	Params::KnifeProjectile_OnWorldColliderHit Parms{};

	Parms.hitComponent = hitComponent;
	Parms.otherActor = otherActor;
	Parms.otherComp = otherComp;
	Parms.normalImpulse = std::move(normalImpulse);
	Parms.hit = std::move(hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.KnifeProjectile.SetKnifeAcquired
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    acquired                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKnifeProjectile::SetKnifeAcquired(bool acquired)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnifeProjectile", "SetKnifeAcquired");

	Params::KnifeProjectile_SetKnifeAcquired Parms{};

	Parms.acquired = acquired;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.KnifeProjectile.GetAddonExplosionRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AKnifeProjectile::GetAddonExplosionRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnifeProjectile", "GetAddonExplosionRadius");

	Params::KnifeProjectile_GetAddonExplosionRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheK23.KnifeProjectile.KnifeCanPierceCampers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKnifeProjectile::KnifeCanPierceCampers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnifeProjectile", "KnifeCanPierceCampers");

	Params::KnifeProjectile_KnifeCanPierceCampers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheK23.KnifeProjectile.ShouldPlayRicochetSound
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKnifeProjectile::ShouldPlayRicochetSound() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnifeProjectile", "ShouldPlayRicochetSound");

	Params::KnifeProjectile_ShouldPlayRicochetSound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheK23.KnifeProjectile.WasLaunchedDuringSuperMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AKnifeProjectile::WasLaunchedDuringSuperMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnifeProjectile", "WasLaunchedDuringSuperMode");

	Params::KnifeProjectile_WasLaunchedDuringSuperMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheK23.KnifeRack.OnReloadEnded
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKnifeRack::OnReloadEnded(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnifeRack", "OnReloadEnded");

	Params::KnifeRack_OnReloadEnded Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheK23.KnifeRack.OnReloadMontageStarted
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   actionSpeedMultiplier                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AKnifeRack::OnReloadMontageStarted(float actionSpeedMultiplier, class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnifeRack", "OnReloadMontageStarted");

	Params::KnifeRack_OnReloadMontageStarted Parms{};

	Parms.actionSpeedMultiplier = actionSpeedMultiplier;
	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheK23.KnivesLauncher.GetLocallyPredictedAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKnivesLauncher::GetLocallyPredictedAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnivesLauncher", "GetLocallyPredictedAmmo");

	Params::KnivesLauncher_GetLocallyPredictedAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheK23.KnivesLauncher.GetPower
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AThrowingKnives*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AThrowingKnives* UKnivesLauncher::GetPower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KnivesLauncher", "GetPower");

	Params::KnivesLauncher_GetPower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheK23.LacerationComponent.Cosmetic_OnKnifeHit
// (BlueprintCosmetic, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// float                                   lacerationPercent                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isDangerous                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    causedDamage                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    causedKo                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   impactNormal                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULacerationComponent::Cosmetic_OnKnifeHit(float lacerationPercent, bool isDangerous, bool causedDamage, bool causedKo, const struct FVector& impactNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LacerationComponent", "Cosmetic_OnKnifeHit");

	Params::LacerationComponent_Cosmetic_OnKnifeHit Parms{};

	Parms.lacerationPercent = lacerationPercent;
	Parms.isDangerous = isDangerous;
	Parms.causedDamage = causedDamage;
	Parms.causedKo = causedKo;
	Parms.impactNormal = std::move(impactNormal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheK23.LacerationComponent.Cosmetic_OnLacerationChanged
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// float                                   lacerationPercent                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isDangerous                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULacerationComponent::Cosmetic_OnLacerationChanged(float lacerationPercent, bool isDangerous)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LacerationComponent", "Cosmetic_OnLacerationChanged");

	Params::LacerationComponent_Cosmetic_OnLacerationChanged Parms{};

	Parms.lacerationPercent = lacerationPercent;
	Parms.isDangerous = isDangerous;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheK23.LacerationComponent.Cosmetic_OnLocallyObservedChanged
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isLocallyObserved                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   lacerationPercent                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    isDangerous                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULacerationComponent::Cosmetic_OnLocallyObservedChanged(bool isLocallyObserved, float lacerationPercent, bool isDangerous)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LacerationComponent", "Cosmetic_OnLocallyObservedChanged");

	Params::LacerationComponent_Cosmetic_OnLocallyObservedChanged Parms{};

	Parms.isLocallyObserved = isLocallyObserved;
	Parms.lacerationPercent = lacerationPercent;
	Parms.isDangerous = isDangerous;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheK23.LacerationComponent.Multicast_KnifeHit
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// float                                   newLaceration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    causedDamage                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    causedKo                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   impactLocation                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   impactNormal                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULacerationComponent::Multicast_KnifeHit(float newLaceration, bool causedDamage, bool causedKo, const struct FVector& impactLocation, const struct FVector& impactNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LacerationComponent", "Multicast_KnifeHit");

	Params::LacerationComponent_Multicast_KnifeHit Parms{};

	Parms.newLaceration = newLaceration;
	Parms.causedDamage = causedDamage;
	Parms.causedKo = causedKo;
	Parms.impactLocation = std::move(impactLocation);
	Parms.impactNormal = std::move(impactNormal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.LacerationComponent.OnRepLaceration
// (Final, Native, Private)
// Parameters:
// float                                   oldLaceration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULacerationComponent::OnRepLaceration(float oldLaceration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LacerationComponent", "OnRepLaceration");

	Params::LacerationComponent_OnRepLaceration Parms{};

	Parms.oldLaceration = oldLaceration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.NoWayOut.Multicast_TriggerLoudNoise
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class ADBDPlayer*                       instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEscapeDoor*                      escapeDoor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNoWayOut::Multicast_TriggerLoudNoise(class ADBDPlayer* instigator, class AEscapeDoor* escapeDoor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoWayOut", "Multicast_TriggerLoudNoise");

	Params::NoWayOut_Multicast_TriggerLoudNoise Parms{};

	Parms.instigator = instigator;
	Parms.escapeDoor = escapeDoor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.NoWayOut.GetExitGatePanelBlockBaseDurationAtLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoWayOut::GetExitGatePanelBlockBaseDurationAtLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoWayOut", "GetExitGatePanelBlockBaseDurationAtLevel");

	Params::NoWayOut_GetExitGatePanelBlockBaseDurationAtLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheK23.NoWayOut.GetExitGatePanelBlockDurationPerTokenAtLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNoWayOut::GetExitGatePanelBlockDurationPerTokenAtLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoWayOut", "GetExitGatePanelBlockDurationPerTokenAtLevel");

	Params::NoWayOut_GetExitGatePanelBlockDurationPerTokenAtLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheK23.ThrowingKnives.Authority_SpawnReloadInteractionOnLockers
// (Final, Native, Public)

void AThrowingKnives::Authority_SpawnReloadInteractionOnLockers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowingKnives", "Authority_SpawnReloadInteractionOnLockers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.ThrowingKnives.Cosmetic_OnComboFinished
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    isSRankCombo                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThrowingKnives::Cosmetic_OnComboFinished(bool isSRankCombo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowingKnives", "Cosmetic_OnComboFinished");

	Params::ThrowingKnives_Cosmetic_OnComboFinished Parms{};

	Parms.isSRankCombo = isSRankCombo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheK23.ThrowingKnives.Cosmetic_OnComboScoreChanged
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// float                                   scoreNormalizedForAudio                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThrowingKnives::Cosmetic_OnComboScoreChanged(float scoreNormalizedForAudio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowingKnives", "Cosmetic_OnComboScoreChanged");

	Params::ThrowingKnives_Cosmetic_OnComboScoreChanged Parms{};

	Parms.scoreNormalizedForAudio = scoreNormalizedForAudio;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheK23.ThrowingKnives.Cosmetic_OnLaunch
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void AThrowingKnives::Cosmetic_OnLaunch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowingKnives", "Cosmetic_OnLaunch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheK23.ThrowingKnives.Cosmetic_OnUsePowerWhenInCooldown
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void AThrowingKnives::Cosmetic_OnUsePowerWhenInCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowingKnives", "Cosmetic_OnUsePowerWhenInCooldown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheK23.ThrowingKnives.Cosmetic_OnUsePowerWhenOutOfAmmo
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void AThrowingKnives::Cosmetic_OnUsePowerWhenOutOfAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowingKnives", "Cosmetic_OnUsePowerWhenOutOfAmmo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheK23.ThrowingKnives.Multicast_OnUsePowerWhenInCooldown
// (Net, Native, Event, NetMulticast, Public)

void AThrowingKnives::Multicast_OnUsePowerWhenInCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowingKnives", "Multicast_OnUsePowerWhenInCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.ThrowingKnives.Multicast_OnUsePowerWhenOutOfAmmo
// (Net, Native, Event, NetMulticast, Public)

void AThrowingKnives::Multicast_OnUsePowerWhenOutOfAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowingKnives", "Multicast_OnUsePowerWhenOutOfAmmo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.ThrowingKnives.OnItemUsedStateChanged
// (Final, Native, Private)
// Parameters:
// bool                                    pressed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AThrowingKnives::OnItemUsedStateChanged(bool pressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowingKnives", "OnItemUsedStateChanged");

	Params::ThrowingKnives_OnItemUsedStateChanged Parms{};

	Parms.pressed = pressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.ThrowingKnives.GetLauncher
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UKnivesLauncher*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UKnivesLauncher* AThrowingKnives::GetLauncher() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowingKnives", "GetLauncher");

	Params::ThrowingKnives_GetLauncher Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheK23.ThrowingKnives.GetSlasher
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASlasherPlayer*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASlasherPlayer* AThrowingKnives::GetSlasher() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowingKnives", "GetSlasher");

	Params::ThrowingKnives_GetSlasher Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheK23.TricksterCharacterVFXInterface.HideWeapon
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)

void ITricksterCharacterVFXInterface::HideWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("TricksterCharacterVFXInterface", "HideWeapon");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function TheK23.TricksterCharacterVFXInterface.SetIsInCooldown
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    isInCooldown                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ITricksterCharacterVFXInterface::SetIsInCooldown(bool isInCooldown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("TricksterCharacterVFXInterface", "SetIsInCooldown");

	Params::TricksterCharacterVFXInterface_SetIsInCooldown Parms{};

	Parms.isInCooldown = isInCooldown;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function TheK23.TricksterCharacterVFXInterface.SetIsSuperModeReady
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    isSuperModeReady                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ITricksterCharacterVFXInterface::SetIsSuperModeReady(bool isSuperModeReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("TricksterCharacterVFXInterface", "SetIsSuperModeReady");

	Params::TricksterCharacterVFXInterface_SetIsSuperModeReady Parms{};

	Parms.isSuperModeReady = isSuperModeReady;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function TheK23.TricksterCharacterVFXInterface.SetKnivesVisibility
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    leftKnife                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    rightKnife                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ITricksterCharacterVFXInterface::SetKnivesVisibility(bool leftKnife, bool rightKnife)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("TricksterCharacterVFXInterface", "SetKnivesVisibility");

	Params::TricksterCharacterVFXInterface_SetKnivesVisibility Parms{};

	Parms.leftKnife = leftKnife;
	Parms.rightKnife = rightKnife;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function TheK23.TricksterCharacterVFXInterface.SetSuperModeActive
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ITricksterCharacterVFXInterface::SetSuperModeActive(bool active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("TricksterCharacterVFXInterface", "SetSuperModeActive");

	Params::TricksterCharacterVFXInterface_SetSuperModeActive Parms{};

	Parms.active = active;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function TheK23.TricksterCharacterVFXInterface.ShowWeapon
// (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)

void ITricksterCharacterVFXInterface::ShowWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("TricksterCharacterVFXInterface", "ShowWeapon");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function TheK23.TricksterSuperModeComponent.OnRepIsInCooldown
// (Final, Native, Private)

void UTricksterSuperModeComponent::OnRepIsInCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TricksterSuperModeComponent", "OnRepIsInCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.TricksterSuperModeComponent.OnRepIsInSuperMode
// (Final, Native, Private)

void UTricksterSuperModeComponent::OnRepIsInSuperMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TricksterSuperModeComponent", "OnRepIsInSuperMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheK23.TricksterSuperModeComponent.OnRepIsSuperModeReady
// (Final, Native, Private)

void UTricksterSuperModeComponent::OnRepIsSuperModeReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TricksterSuperModeComponent", "OnRepIsSuperModeReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

