#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DeadByDaylight

#include "Basic.hpp"

#include "DeadByDaylight_structs.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "Customization_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "AnimationUtilities_structs.hpp"
#include "AnimationUtilities_classes.hpp"
#include "Niagara_structs.hpp"
#include "StatSystem_structs.hpp"
#include "Activation_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DBDUIViewsMobile_structs.hpp"
#include "DBDUIViewsMobile_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "Competence_structs.hpp"
#include "Competence_classes.hpp"
#include "SlateCore_structs.hpp"
#include "AkAudio_structs.hpp"
#include "AkAudio_classes.hpp"
#include "GameplayTagUtilities_structs.hpp"
#include "Projectile_classes.hpp"
#include "SystemUtilities_structs.hpp"
#include "SystemUtilities_classes.hpp"
#include "PhysicsCore_structs.hpp"
#include "NetworkUtilities_structs.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "NavigationSystem_classes.hpp"
#include "OnlineSubsystemUtils_classes.hpp"
#include "GFXUtilities_classes.hpp"
#include "SocialParty_classes.hpp"
#include "PlatformsProviders_structs.hpp"
#include "OnlinePresence_structs.hpp"
#include "SignificanceUtilities_classes.hpp"
#include "Slate_structs.hpp"
#include "DBDAnimationBudgetAllocator_classes.hpp"
#include "DBDUIViewInterfaces_structs.hpp"
#include "VFXUtilities_classes.hpp"
#include "ReversibleActionSystem_classes.hpp"
#include "DBDAudio_classes.hpp"
#include "GameplayUtilities_classes.hpp"


namespace SDK
{

// Class DeadByDaylight.ActorVariationSpawner
// 0x0050 (0x0270 - 0x0220)
class UActorVariationSpawner final : public USceneComponent
{
public:
	TSoftClassPtr<class UClass>                   Visualization;                                     // 0x0218(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActorVariationElements>        Variations;                                        // 0x0248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_258[0x8];                                      // 0x0258(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 _toSpawn;                                          // 0x0260(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorVariationSpawner">();
	}
	static class UActorVariationSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorVariationSpawner>();
	}
};
static_assert(alignof(UActorVariationSpawner) == 0x000010, "Wrong alignment on UActorVariationSpawner");
static_assert(sizeof(UActorVariationSpawner) == 0x000270, "Wrong size on UActorVariationSpawner");
static_assert(offsetof(UActorVariationSpawner, Visualization) == 0x000218, "Member 'UActorVariationSpawner::Visualization' has a wrong offset!");
static_assert(offsetof(UActorVariationSpawner, Variations) == 0x000248, "Member 'UActorVariationSpawner::Variations' has a wrong offset!");
static_assert(offsetof(UActorVariationSpawner, _toSpawn) == 0x000260, "Member 'UActorVariationSpawner::_toSpawn' has a wrong offset!");

// Class DeadByDaylight.InGameAssetPreloaderGatherer
// 0x0000 (0x0030 - 0x0030)
class UInGameAssetPreloaderGatherer : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameAssetPreloaderGatherer">();
	}
	static class UInGameAssetPreloaderGatherer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameAssetPreloaderGatherer>();
	}
};
static_assert(alignof(UInGameAssetPreloaderGatherer) == 0x000008, "Wrong alignment on UInGameAssetPreloaderGatherer");
static_assert(sizeof(UInGameAssetPreloaderGatherer) == 0x000030, "Wrong size on UInGameAssetPreloaderGatherer");

// Class DeadByDaylight.OutlineUpdateStrategy
// 0x0008 (0x00C0 - 0x00B8)
class UOutlineUpdateStrategy : public UActorComponent
{
public:
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x00B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutlineUpdateStrategy">();
	}
	static class UOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UOutlineUpdateStrategy");
static_assert(sizeof(UOutlineUpdateStrategy) == 0x0000C0, "Wrong size on UOutlineUpdateStrategy");
static_assert(offsetof(UOutlineUpdateStrategy, _outlineComponent) == 0x0000B8, "Member 'UOutlineUpdateStrategy::_outlineComponent' has a wrong offset!");

// Class DeadByDaylight.UMGCloseTooltipWidget
// 0x0018 (0x0350 - 0x0338)
class UUMGCloseTooltipWidget final : public UMobileBaseUserWidget
{
public:
	class UButton*                                FullScreenButton;                                  // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCloseTooltipButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCloseTooltipWidget">();
	}
	static class UUMGCloseTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCloseTooltipWidget>();
	}
};
static_assert(alignof(UUMGCloseTooltipWidget) == 0x000008, "Wrong alignment on UUMGCloseTooltipWidget");
static_assert(sizeof(UUMGCloseTooltipWidget) == 0x000350, "Wrong size on UUMGCloseTooltipWidget");
static_assert(offsetof(UUMGCloseTooltipWidget, FullScreenButton) == 0x000338, "Member 'UUMGCloseTooltipWidget::FullScreenButton' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerControllerBase
// 0x00D8 (0x0670 - 0x0598)
class ADBDPlayerControllerBase : public APlayerController
{
public:
	uint8                                         Pad_598[0x58];                                     // 0x0598(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class APlayerState* playerState)> OnPlayerStateChanged;      // 0x05F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_600[0x58];                                     // 0x0600(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _mainCharacter;                                    // 0x0658(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_660[0x10];                                     // 0x0660(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallConsoleCmdOnServer_Server(const class FString& commandLine);
	void Client_EACMessageFromServer(const TArray<uint8>& message);
	void Client_FinishedPlaying();
	void Client_GameEnded();
	void Client_RequestPlayerProfile();
	void Client_SendLogs(const TArray<class FString>& ensures);
	void Client_SendServerAuthentication(const class FString& authServerTicket, uint64 steamID, uint32 ticketLength);
	void Client_SendWarning(bool penaltyStarts, float seconds);
	void Client_ValidateServer();
	void DBD_BuildFromMap(const class FString& map);
	void DBD_BuildFromPlayerCount(int32 count);
	void DBD_BuildFromPremadeMap(const class FString& map);
	void DBD_BuildFromSeed(int32 seed);
	void DBD_BuildFromTile(int32 matrixX, int32 matrixY, int32 rotation, const class FString& name);
	void DBD_DebugSendChatMessage(const class FString& msg);
	void DBD_FillAllScoreCategories();
	void DBD_FillScoreCategory(int32 category);
	void DBD_FireTestScore(int32 category, float value);
	void DBD_SetCurrentCharacterPrestigeDatesFuture();
	void DBD_SetCurrentCharacterPrestigeDatesNow();
	void DBD_SetCurrentCharacterPrestigeDatesPast();
	void DBD_UpdateLocalStats();
	void Server(const class FString& commandLine);
	void Server_EACMessageFromClient(const TArray<uint8>& message);
	void Server_ReceivePlayerProfile(const struct FPlayerSavedProfileDataShared& savedProfileData, const struct FPlayerLoadoutData& playerLoadout);
	void Server_SendClientAuthentication(const class FString& authClientTicket, uint64 steamID, uint32 ticketLength);
	void Server_SendMessage(const class FString& message);
	void Server_SetConsecutiveMatchStreak(int32 consecutiveMatch);
	void Server_UpdateReplicatedPips(int32 pipsToAdd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerControllerBase">();
	}
	static class ADBDPlayerControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerControllerBase>();
	}
};
static_assert(alignof(ADBDPlayerControllerBase) == 0x000008, "Wrong alignment on ADBDPlayerControllerBase");
static_assert(sizeof(ADBDPlayerControllerBase) == 0x000670, "Wrong size on ADBDPlayerControllerBase");
static_assert(offsetof(ADBDPlayerControllerBase, OnPlayerStateChanged) == 0x0005F0, "Member 'ADBDPlayerControllerBase::OnPlayerStateChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayerControllerBase, _mainCharacter) == 0x000658, "Member 'ADBDPlayerControllerBase::_mainCharacter' has a wrong offset!");

// Class DeadByDaylight.AssetUtilities
// 0x0000 (0x0030 - 0x0030)
class UAssetUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetUtilities">();
	}
	static class UAssetUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetUtilities>();
	}
};
static_assert(alignof(UAssetUtilities) == 0x000008, "Wrong alignment on UAssetUtilities");
static_assert(sizeof(UAssetUtilities) == 0x000030, "Wrong size on UAssetUtilities");

// Class DeadByDaylight.AICharacterBehaviour
// 0x0028 (0x0058 - 0x0030)
class UAICharacterBehaviour : public UObject
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Pause();
	void Resume();
	void SetEnable(bool enable);
	void Start();
	void Stop();
	void Update(float deltaTime);

	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviour">();
	}
	static class UAICharacterBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviour>();
	}
};
static_assert(alignof(UAICharacterBehaviour) == 0x000008, "Wrong alignment on UAICharacterBehaviour");
static_assert(sizeof(UAICharacterBehaviour) == 0x000058, "Wrong size on UAICharacterBehaviour");

// Class DeadByDaylight.DBDLocatorComponent
// 0x0000 (0x0220 - 0x0220)
#pragma pack(push, 0x1)
class alignas(0x10) UDBDLocatorComponent : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDLocatorComponent">();
	}
	static class UDBDLocatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDLocatorComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UDBDLocatorComponent) == 0x000010, "Wrong alignment on UDBDLocatorComponent");
static_assert(sizeof(UDBDLocatorComponent) == 0x000220, "Wrong size on UDBDLocatorComponent");

// Class DeadByDaylight.DBDAggregateParticleLocatorComponent
// 0x0010 (0x0230 - 0x0220)
class UDBDAggregateParticleLocatorComponent final : public UDBDLocatorComponent
{
public:
	class UParticleSystem*                        Template;                                          // 0x0218(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               _particleComponent;                                // 0x0220(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAggregateParticleLocatorComponent">();
	}
	static class UDBDAggregateParticleLocatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAggregateParticleLocatorComponent>();
	}
};
static_assert(alignof(UDBDAggregateParticleLocatorComponent) == 0x000010, "Wrong alignment on UDBDAggregateParticleLocatorComponent");
static_assert(sizeof(UDBDAggregateParticleLocatorComponent) == 0x000230, "Wrong size on UDBDAggregateParticleLocatorComponent");
static_assert(offsetof(UDBDAggregateParticleLocatorComponent, Template) == 0x000218, "Member 'UDBDAggregateParticleLocatorComponent::Template' has a wrong offset!");
static_assert(offsetof(UDBDAggregateParticleLocatorComponent, _particleComponent) == 0x000220, "Member 'UDBDAggregateParticleLocatorComponent::_particleComponent' has a wrong offset!");

// Class DeadByDaylight.GameplayModifierContainer
// 0x0120 (0x0218 - 0x00F8)
class UGameplayModifierContainer : public UBaseModifierContainer
{
public:
	uint8                                         Pad_F8[0x90];                                      // 0x00F8(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	struct FModifierTickableConditionReplicatedData _tickableConditionsData;                         // 0x0188(0x0018)(Net, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           _tags;                                             // 0x01A0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          UseApplyFunction;                                  // 0x01B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastStatusView;                               // 0x01B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B2[0x2];                                      // 0x01B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StatusViewID;                                      // 0x01B4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _autoInitializeOnBeginPlay;                        // 0x01C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _canOptimizeTickActivation;                        // 0x01C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C2[0x46];                                     // 0x01C2(0x0046)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimerObject*                           _activationTimer;                                  // 0x0208(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0x8];                                      // 0x0210(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBaseModifierCondition* AddCondition(TSubclassOf<class UBaseModifierCondition> conditionType);
	void Apply(float DeltaTime);
	void Authority_ClearActivationTimer();
	void Authority_InstantiateGameplayModifierConditions();
	void Authority_SetActivationTimerPaused(const bool paused);
	void Authority_TriggerActivationTimer(float activationTime);
	void ListenToDispatcherGameEvent(const struct FGameplayTag& eventType);
	void OnApplyBegin();
	void OnApplyEnd();
	void OnGameEventDispatched(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void OnInitialized();
	void OnInitialized_Internal();
	void OnLevelReadyToPlay();
	void OnRep_ActivationTimer();
	void OnRep_ModifierData();
	void OnRep_TickableConditionsData();
	void RemoveAllFlags();
	void RemoveAllModifiers();
	void RemoveModifier(const struct FGameplayTag& type);
	void SetFlag(const struct FGameplayTag& flag, bool flagValue);
	void SetModifierValue(const struct FGameplayTag& type, float GameplayModifierValue);
	void SetUseApplyFunction(bool use);
	void UnlistenToAllDispatcherGameEvents();
	void UnlistenToDispatcherGameEvent(const struct FGameplayTag& eventType);
	void UpdateIsApplicable();

	void FireActiveStatusViewEvent(class FName statusViewID, class FName uniqueSourceID, const struct FStatusViewSource& statusViewSource) const;
	float GetActivationTimerDuration() const;
	float GetActivationTimerElapsedTime() const;
	float GetActivationTimerElapsedTimePercent() const;
	float GetActivationTimerPercentRemaining() const;
	float GetActivationTimerRemainingTime() const;
	int32 GetIconFilePathIndex() const;
	EInventoryItemType GetInventoryItemType() const;
	int32 GetLevelToDisplay() const;
	float GetModifierValue(const struct FGameplayTag& type) const;
	class UGameplayModifierContainer* GetOriginatingEffect() const;
	class ADBDPlayer* GetOwningPlayer() const;
	float GetPercentageFill() const;
	float GetRemainingLifetime() const;
	bool HasFlag(const struct FGameplayTag& flag) const;
	bool HasModifierOfType(const struct FGameplayTag& type) const;
	bool IsActivationTimerActive() const;
	bool IsActivationTimerDone() const;
	bool IsStatusViewActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayModifierContainer">();
	}
	static class UGameplayModifierContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModifierContainer>();
	}
};
static_assert(alignof(UGameplayModifierContainer) == 0x000008, "Wrong alignment on UGameplayModifierContainer");
static_assert(sizeof(UGameplayModifierContainer) == 0x000218, "Wrong size on UGameplayModifierContainer");
static_assert(offsetof(UGameplayModifierContainer, _tickableConditionsData) == 0x000188, "Member 'UGameplayModifierContainer::_tickableConditionsData' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _tags) == 0x0001A0, "Member 'UGameplayModifierContainer::_tags' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, UseApplyFunction) == 0x0001B0, "Member 'UGameplayModifierContainer::UseApplyFunction' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, BroadcastStatusView) == 0x0001B1, "Member 'UGameplayModifierContainer::BroadcastStatusView' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, StatusViewID) == 0x0001B4, "Member 'UGameplayModifierContainer::StatusViewID' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _autoInitializeOnBeginPlay) == 0x0001C0, "Member 'UGameplayModifierContainer::_autoInitializeOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _canOptimizeTickActivation) == 0x0001C1, "Member 'UGameplayModifierContainer::_canOptimizeTickActivation' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainer, _activationTimer) == 0x000208, "Member 'UGameplayModifierContainer::_activationTimer' has a wrong offset!");

// Class DeadByDaylight.Perk
// 0x01B0 (0x03C8 - 0x0218)
class UPerk : public UGameplayModifierContainer
{
public:
	uint8                                         Pad_218[0x60];                                     // 0x0218(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayModifierData                  PerkLevelData[0x3];                                // 0x0278(0x0030)(Edit, Net, EditFixedSize, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x30];                                     // 0x0308(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBasePerkIconStrategy>      PerkIconStrategyClass;                             // 0x0338(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(int32 tokenCount)> OnTokenCountChangedBP;                          // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x30];                                     // 0x0350(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isUsable;                                         // 0x0380(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _keepImposedStatusEffectsOnEndPlay;                // 0x0381(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BroadcastWhenApplicable;                           // 0x0382(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BroadcastOnTimer;                                  // 0x0383(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BroadcastCooldownTimer;                            // 0x0384(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BroadcastInactiveCooldownTimer;                    // 0x0385(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BroadcastAlways;                                   // 0x0386(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SetInactiveDuringCooldown;                         // 0x0387(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBasePerkIconStrategy*                  _perkIconStrategy;                                 // 0x0388(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPerkInitializationData                _perkInitializationData;                           // 0x0390(0x0008)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0x4];                                      // 0x0398(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _tokenCount;                                       // 0x039C(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxTokenCount;                                    // 0x03A0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EPerkTokenSoundStrategy                       _tokenSoundStrategy;                               // 0x03A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A5[0x3];                                      // 0x03A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimerObject*                           _cooldownTimer;                                    // 0x03A8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimerObject*                           _hudIconTimer;                                     // 0x03B8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDefinition*                 _activatableInteraction;                           // 0x03C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_DecrementToken();
	void Authority_IncrementToken();
	void Authority_SetIsUsable(bool value);
	void Authority_SetMaxTokenCount(int32 value);
	void Authority_SetTokenCount(int32 value);
	void Authority_TriggerCooldownTimer(const float coolddownTime);
	void Authority_TriggerHudIconTimer(float duration);
	void FireActivePerkEvent(const float percentage, const int32 chargeCount);
	struct FGameplayModifierData GetGameplayModifierData();
	void OnRep_PerkInitializationData();
	void OnRep_TokenCount(int32 oldCount);
	void SetIsUsable(bool value);

	class UTimerObject* GetCooldownTimer() const;
	float GetHudIconTimerElapsedTimePercent() const;
	bool GetIsUsable() const;
	int32 GetMaxTokenCount() const;
	class UBasePerkIconStrategy* GetPerkIconStrategy() const;
	int32 GetPerkLevel() const;
	int32 GetTokenCount() const;
	bool IsCooldownTimerDone() const;
	bool IsHudIconTimerDone() const;
	void OnRep_CooldownTimer() const;
	void OnRep_IsUsable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Perk">();
	}
	static class UPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerk>();
	}
};
static_assert(alignof(UPerk) == 0x000008, "Wrong alignment on UPerk");
static_assert(sizeof(UPerk) == 0x0003C8, "Wrong size on UPerk");
static_assert(offsetof(UPerk, PerkLevelData) == 0x000278, "Member 'UPerk::PerkLevelData' has a wrong offset!");
static_assert(offsetof(UPerk, PerkIconStrategyClass) == 0x000338, "Member 'UPerk::PerkIconStrategyClass' has a wrong offset!");
static_assert(offsetof(UPerk, OnTokenCountChangedBP) == 0x000340, "Member 'UPerk::OnTokenCountChangedBP' has a wrong offset!");
static_assert(offsetof(UPerk, _isUsable) == 0x000380, "Member 'UPerk::_isUsable' has a wrong offset!");
static_assert(offsetof(UPerk, _keepImposedStatusEffectsOnEndPlay) == 0x000381, "Member 'UPerk::_keepImposedStatusEffectsOnEndPlay' has a wrong offset!");
static_assert(offsetof(UPerk, BroadcastWhenApplicable) == 0x000382, "Member 'UPerk::BroadcastWhenApplicable' has a wrong offset!");
static_assert(offsetof(UPerk, BroadcastOnTimer) == 0x000383, "Member 'UPerk::BroadcastOnTimer' has a wrong offset!");
static_assert(offsetof(UPerk, BroadcastCooldownTimer) == 0x000384, "Member 'UPerk::BroadcastCooldownTimer' has a wrong offset!");
static_assert(offsetof(UPerk, BroadcastInactiveCooldownTimer) == 0x000385, "Member 'UPerk::BroadcastInactiveCooldownTimer' has a wrong offset!");
static_assert(offsetof(UPerk, BroadcastAlways) == 0x000386, "Member 'UPerk::BroadcastAlways' has a wrong offset!");
static_assert(offsetof(UPerk, SetInactiveDuringCooldown) == 0x000387, "Member 'UPerk::SetInactiveDuringCooldown' has a wrong offset!");
static_assert(offsetof(UPerk, _perkIconStrategy) == 0x000388, "Member 'UPerk::_perkIconStrategy' has a wrong offset!");
static_assert(offsetof(UPerk, _perkInitializationData) == 0x000390, "Member 'UPerk::_perkInitializationData' has a wrong offset!");
static_assert(offsetof(UPerk, _tokenCount) == 0x00039C, "Member 'UPerk::_tokenCount' has a wrong offset!");
static_assert(offsetof(UPerk, _maxTokenCount) == 0x0003A0, "Member 'UPerk::_maxTokenCount' has a wrong offset!");
static_assert(offsetof(UPerk, _tokenSoundStrategy) == 0x0003A4, "Member 'UPerk::_tokenSoundStrategy' has a wrong offset!");
static_assert(offsetof(UPerk, _cooldownTimer) == 0x0003A8, "Member 'UPerk::_cooldownTimer' has a wrong offset!");
static_assert(offsetof(UPerk, _hudIconTimer) == 0x0003B8, "Member 'UPerk::_hudIconTimer' has a wrong offset!");
static_assert(offsetof(UPerk, _activatableInteraction) == 0x0003C0, "Member 'UPerk::_activatableInteraction' has a wrong offset!");

// Class DeadByDaylight.TotemBoundPerk
// 0x0058 (0x0420 - 0x03C8)
class UTotemBoundPerk : public UPerk
{
public:
	uint8                                         Pad_3C8[0x18];                                     // 0x03C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	ETotemState                                   TotemBoundState;                                   // 0x03E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _doNotBindToTotemOnInit;                           // 0x03E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E2[0x6];                                      // 0x03E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATotem*>                         _boundTotems;                                      // 0x03E8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<class ATotem*>                         _local_boundTotems;                                // 0x03F8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ATotem*>                         _authorityPrevTotemActors;                         // 0x0408(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         _numTotemsToBind;                                  // 0x0418(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Authority_BindToDullTotems(bool allowAdditionalBoundTotems);
	void Authority_UnbindFromTotem(class ATotem* aTotemActor);
	void OnRep_BoundTotems();

	TArray<class ATotem*> GetBoundTotems() const;
	float GetSquaredDistanceToOwner(const class AActor* survivor) const;
	const TArray<class ATotem*> GetTotems() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TotemBoundPerk">();
	}
	static class UTotemBoundPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTotemBoundPerk>();
	}
};
static_assert(alignof(UTotemBoundPerk) == 0x000008, "Wrong alignment on UTotemBoundPerk");
static_assert(sizeof(UTotemBoundPerk) == 0x000420, "Wrong size on UTotemBoundPerk");
static_assert(offsetof(UTotemBoundPerk, TotemBoundState) == 0x0003E0, "Member 'UTotemBoundPerk::TotemBoundState' has a wrong offset!");
static_assert(offsetof(UTotemBoundPerk, _doNotBindToTotemOnInit) == 0x0003E1, "Member 'UTotemBoundPerk::_doNotBindToTotemOnInit' has a wrong offset!");
static_assert(offsetof(UTotemBoundPerk, _boundTotems) == 0x0003E8, "Member 'UTotemBoundPerk::_boundTotems' has a wrong offset!");
static_assert(offsetof(UTotemBoundPerk, _local_boundTotems) == 0x0003F8, "Member 'UTotemBoundPerk::_local_boundTotems' has a wrong offset!");
static_assert(offsetof(UTotemBoundPerk, _authorityPrevTotemActors) == 0x000408, "Member 'UTotemBoundPerk::_authorityPrevTotemActors' has a wrong offset!");
static_assert(offsetof(UTotemBoundPerk, _numTotemsToBind) == 0x000418, "Member 'UTotemBoundPerk::_numTotemsToBind' has a wrong offset!");

// Class DeadByDaylight.InteractionDefinition
// 0x0400 (0x0620 - 0x0220)
#pragma pack(push, 0x1)
class alignas(0x10) UInteractionDefinition : public USceneComponent
{
public:
	uint8                                         Pad_218[0x40];                                     // 0x0218(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 InteractionID;                                     // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapTime;                                          // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ResetCameraDuringSnap;                             // 0x026C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInteractionCancelled;                            // 0x026D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowStartInteractionFromHeldInput;                // 0x026E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnMontageComplete;                  // 0x026F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnMontageBlendingOut;               // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnTimerExpire;                      // 0x0271(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnHeightDelta;                      // 0x0272(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopEnterMontageOnExit;                            // 0x0273(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopUpdateMontageOnExit;                           // 0x0274(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreStrafeAnimFix;                               // 0x0275(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionAnimation                         InteractionAnimation;                              // 0x0276(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CamperCanInteract;                                 // 0x0277(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SlasherCanInteract;                                // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowInputPersistence;                             // 0x0279(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SnapPosition;                                      // 0x027A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SnapRotation;                                      // 0x027B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapStopDistance;                                  // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TestClearPathDuringSnap;                           // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CheckInteractableIsInPlayerView;                   // 0x0281(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_282[0x2];                                      // 0x0282(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CheckInteractableInViewSphereSweepRadius;          // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CheckInteractableInViewOffset;                     // 0x0288(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckInteractableInViewOffsetDistanceToHitPoint;   // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInterruptibleIfTestClearPathDuringSnapFails;     // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TestPlayerOrientationOnSnap;                       // 0x0299(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScaleEnterAnimationToTime;                         // 0x029A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScaleMainAnimationToTime;                          // 0x029B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ScaleExitAnimationToTime;                          // 0x029C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnapBackType                                 SnapBackType;                                      // 0x029D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESnapBackPositionType                         SnapBackPositionType;                              // 0x029E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29F[0x1];                                      // 0x029F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SnapBackPositionOffset;                            // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SnapToInitialRotationDuringSnapBack;               // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseStartSnapTimeForSnapExitTime;                   // 0x02A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileIncapacitated;                     // 0x02AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileCloaked;                           // 0x02AB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileAttacking;                         // 0x02AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileChainLinked;                       // 0x02AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileShocked;                           // 0x02AE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileUnhookingSelf;                     // 0x02AF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteractWhileCarrying;                          // 0x02B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowNavigation;                                   // 0x02B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowNavigationInput;                              // 0x02B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowRotation;                                     // 0x02B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCameraMontageMode;                              // 0x02B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OwnerBlocksAttack;                                 // 0x02B5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHighPriority;                                    // 0x02B6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowOverridingWhenNotForced;                      // 0x02B7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreOverlapOnInteractable;                       // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAuthoritativeMovement;                          // 0x02B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeAuthoritativePushedDuringEnter;               // 0x02BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeAuthoritativePushedDuringUpdate;              // 0x02BB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeAuthoritativePushedDuringExit;                // 0x02BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanAuthoritativePush;                              // 0x02BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CancelOnHit;                                       // 0x02BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CancelOnAttack;                                    // 0x02BF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HideItem;                                          // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoBindToParentInteractor;                        // 0x02C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoBindToParentZone;                              // 0x02C2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3[0x1];                                      // 0x02C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CancelOnMoveInitialDelay;                          // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CancelOnMoveInput;                                 // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CancelOnMoveInputOnlyWhenRunning;                  // 0x02CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ProgressBasedSkillChecks;                          // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          CanCrouch;                                         // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AffectsStillness;                                  // 0x02E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ConsideredIdle;                                    // 0x02E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BlockSelfInteract;                                 // 0x02E3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionTime;                                   // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputInteractionType                         InteractionInputType;                              // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnInputRelease;                     // 0x02E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowHitMontageWhenInteracting;                    // 0x02EA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowBasicInteractionIcon;                          // 0x02EB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInterruptionDefinition*>        _interruptionDefinitions;                          // 0x02F0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* player)> OnInteractionEnteredDelegate;           // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0x30];                                     // 0x0310(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnInteractionFinishedDelegate;                     // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInteractionInterruptedStartDelegate;             // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInteractionInterruptedStartedDelegate;           // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInteractionInterruptedEndDelegate;               // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName NotifyId)> OnInteractionAnimNotify;                    // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          DebugUnavailability;                               // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputInteractionType                         SecondaryActionInputType;                          // 0x0391(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_392[0x1E];                                     // 0x0392(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            NavigationSpeedCurveEnter;                         // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            NavigationSpeedCurve;                              // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            NavigationSpeedCurveExit;                          // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _shouldCheckInteractedUpon;                        // 0x03C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionOwnership                         OwnershipUsability;                                // 0x03C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CA[0x2];                                      // 0x03CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExitInteractionTime;                               // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ApplyModifiersToExitTime;                          // 0x03D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InteractionDescriptionText;                        // 0x03D8(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          InteractionCanBeToggled;                           // 0x03F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IgnoreSprintToCancelSetting;                       // 0x03F1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ForceWithSprintToCancelSetting;                    // 0x03F2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F3[0x1];                                      // 0x03F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InteractionHeightDeltaMax;                         // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumVelocity;                                   // 0x03F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            EnterMontage;                                      // 0x0400(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimationMontageDescriptor            UpdateMontage;                                     // 0x0420(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FAnimationMontageDescriptor            ExitMontage;                                       // 0x0440(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           EnterMontageVariantCycle;                          // 0x0460(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           UpdateMontageVariantCycle;                         // 0x0470(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           ExitMontageVariantCycle;                           // 0x0480(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   SnapSocketName;                                    // 0x0490(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _canBeAttachedToAnyZone;                           // 0x049C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInterruptibleBySacrifice;                       // 0x049D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IgnoreStun;                                        // 0x049E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49F[0x1];                                      // 0x049F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _tags;                                             // 0x04A0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           _objectStateTag;                                   // 0x04C0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4CC[0x4];                                      // 0x04CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FSecondaryInteractionProperties> _secondaryInteractions;                // 0x04D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          _useHoldPrompt;                                    // 0x0520(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _allowInteractionInNarrowSpaces;                   // 0x0521(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _allowIKSensorDuringInteraction;                   // 0x0522(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _overrideSlashableRelativeLocation;                // 0x0523(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _slashableRelativeLocation;                        // 0x0524(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _startUpdateMontageDuringEnter;                    // 0x0530(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_531[0x7];                                      // 0x0531(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractor*                            _interactor;                                       // 0x0538(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInteractionDefinition*>         _mutuallyExclusiveInteractionsClient;              // 0x0540(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FActivationDefinition                  _activationDefinition;                             // 0x0550(0x0028)(Edit, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    _zone;                                             // 0x0578(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInputInteractionType                         _cancelInputType;                                  // 0x0580(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_581[0x7];                                      // 0x0581(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _preventingTags;                                   // 0x0588(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  _disablingTags;                                    // 0x05A8(0x0020)(Edit, NativeAccessSpecifierPrivate)
	TArray<class UPlayerInteractionHandler*>      _evaluatingInteractionHandlers;                    // 0x05C8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FSecondaryInteractionProperties        DEPRECATED_SecondaryInteractionProperties;         // 0x05D8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	uint8                                         Pad_610[0x8];                                      // 0x0610(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDisablingTags(const struct FGameplayTag& tagToAdd);
	void AddMutuallyExclusiveInteraction(class UInteractionDefinition* interaction);
	void AttachToInteractor(class UInteractor* interactor);
	void AttachToZone(class UPrimitiveComponent* zone);
	void Authority_OnInteractionAuthorized(class ADBDPlayer* player);
	void CompleteCharge(class ADBDPlayer* character);
	class ADBDPlayer* GetPlayerDependency(const class ADBDPlayer* interactingPlayer);
	void OnInteractionAnimNotifyEvent(class FName notifyID, class ADBDPlayer* player);
	void OnInteractionCancelled(class ADBDPlayer* player);
	void OnInteractionEnterEnd(class ADBDPlayer* player);
	void OnInteractionEnterStart(class ADBDPlayer* player, float actualSnapTime);
	void OnInteractionEnterTick(class ADBDPlayer* player, float deltaTime);
	void OnInteractionExitEnd(class ADBDPlayer* player);
	void OnInteractionExitStart(class ADBDPlayer* player);
	void OnInteractionExitTick(class ADBDPlayer* player, float deltaTime);
	void OnInteractionFinished(class ADBDPlayer* player, bool hasInteractionStarted);
	void OnInteractionInit(class ADBDPlayer* player);
	void OnInteractionInterruptEnd(class ADBDPlayer* player, class UInterruptionDefinition* currentInterruption, class ADBDPlayer* interruptingPlayer);
	void OnInteractionInterruptStart(class ADBDPlayer* player, class UInterruptionDefinition* currentInterruption, class ADBDPlayer* interruptingPlayer);
	void OnInteractionInterruptStarted(class ADBDPlayer* player, class UInterruptionDefinition* currentInterruption, class ADBDPlayer* interruptingPlayer);
	void OnInteractionUpdateEnd(class ADBDPlayer* player);
	void OnInteractionUpdateMontageReachedMiddle(class ADBDPlayer* player);
	void OnInteractionUpdateStart(class ADBDPlayer* player);
	void OnInteractionUpdateTick(class ADBDPlayer* player, float deltaTime);
	void OnInterruptorUpdateStart(class UInterruptionDefinition* currentInterruption, class ADBDPlayer* interruptor, class ADBDPlayer* interruptee);
	void OnUpdateMontageStart(class ADBDPlayer* player);
	void RemoveDisablingTags(const struct FGameplayTag& tagToRemove);
	void ResetSlashableLocation(class ADBDPlayer* player);
	void SetSecondaryActionInputType(EInputInteractionType inputType);
	void UpdateSlashableLocation(class ADBDPlayer* player);

	float CalculateSnapTimeForConstantMaxNormalMovementSpeed(const class ADBDPlayer* player, float speedBoost) const;
	float CalculateSnapTimeForConstantSpeed(const class ADBDPlayer* player, const float speed) const;
	bool CanOverrideInteraction(const class UInteractionDefinition* interaction) const;
	EInteractionComparisonPriority ComparePriorityToInteraction(const class UInteractionDefinition* interaction) const;
	bool DoesPlayerHaveClearPath(const class ADBDPlayer* player) const;
	float GetActionSpeedMultiplier(const class ADBDPlayer* character) const;
	float GetActorHeightDelta(const class ADBDPlayer* player) const;
	TArray<class AActor*> GetActorsToIgnoreOverlap() const;
	struct FVector GetActualSnapPointPosition(const class ADBDPlayer* player) const;
	struct FVector GetActualSnapPointPositionAtStart(const class ADBDPlayer* player) const;
	bool GetAllowNavigation(const class ADBDPlayer* player) const;
	float GetChargePercent() const;
	struct FMontagePlaybackDefinition GetEnterAnimationPlayBackDefinition(const class ADBDPlayer* player, bool follower) const;
	struct FAnimationMontageDescriptor GetEnterMontage(const class ADBDPlayer* player) const;
	struct FMontagePlaybackDefinition GetExitAnimationPlayBackDefinition(const class ADBDPlayer* player, bool follower) const;
	float GetExitAnimationPlayRate(const class ADBDPlayer* player) const;
	struct FAnimationMontageDescriptor GetExitMontage(const class ADBDPlayer* player) const;
	struct FVector GetFocalPointPosition(const class ADBDPlayer* player) const;
	class AInteractable* GetInteractable() const;
	const class FText GetInteractionDescriptionText() const;
	float GetInteractionExitTime(const class ADBDPlayer* character) const;
	class FString GetInteractionText(const class ADBDPlayer* player) const;
	float GetInteractionTime(const class ADBDPlayer* character) const;
	float GetInteractionTimeMultiplier(const class ADBDPlayer* character) const;
	class UInteractor* GetInteractor() const;
	const TArray<class UInterruptionDefinition*> GetInterruptionDefinitions() const;
	struct FRotator GetRotationToSnapPoint(const class ADBDPlayer* player) const;
	struct FRotator GetRotationToSnapPointAtStart(const class ADBDPlayer* player) const;
	EInputInteractionType GetSecondaryActionInputType(const class UObject* worldContextObject) const;
	struct FVector GetSlashableRelativeLocation() const;
	float GetSnapDistance(const class ADBDPlayer* player) const;
	float GetSnapDistanceAtStart(const class ADBDPlayer* player) const;
	struct FVector GetSnapPointPosition(const class ADBDPlayer* player) const;
	struct FVector GetSnapPointPositionAtStart(const class ADBDPlayer* player) const;
	class FName GetSnapSocketName(const class ADBDPlayer* player) const;
	float GetSnapTime(const class ADBDPlayer* player) const;
	float GetSnapTimeAtStart(const class ADBDPlayer* player) const;
	struct FMontagePlaybackDefinition GetUpdateAnimationPlayBackDefinition(const class ADBDPlayer* player, bool follower) const;
	float GetUpdateAnimationPlayRate(const class ADBDPlayer* player) const;
	struct FAnimationMontageDescriptor GetUpdateMontage(const class ADBDPlayer* player) const;
	bool IsCancelable(const class ADBDPlayer* player) const;
	bool IsCharacterFacingInteractorDirection(const class ADBDPlayer* player) const;
	bool IsInputPressed(const class ADBDPlayer* player) const;
	bool IsInteractableInPlayerView(const class ADBDPlayer* player) const;
	bool IsInteractionDone(const class ADBDPlayer* player, EInputInteractionType interactionType) const;
	bool IsInteractionPossible(const class ADBDPlayer* player, EInputInteractionType interactionType, bool performClientCheck, bool performHeightCheck) const;
	bool IsInteractionPossibleBP(const class ADBDPlayer* player, EInputInteractionType interactionType) const;
	bool IsInteractionPossibleClient(const class ADBDPlayer* player, EInputInteractionType interactionType) const;
	bool IsInteractionUsingOffering(const class ADBDPlayer* player) const;
	bool IsInterruptionPossible(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee, const class UInterruptionDefinition* interruption) const;
	bool IsSupportedCharacterType(const class ADBDPlayer* player) const;
	bool ShouldStartUpdateMontageDuringEnter(const class ADBDPlayer* character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionDefinition">();
	}
	static class UInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionDefinition>();
	}
};
#pragma pack(pop)
static_assert(alignof(UInteractionDefinition) == 0x000010, "Wrong alignment on UInteractionDefinition");
static_assert(sizeof(UInteractionDefinition) == 0x000620, "Wrong size on UInteractionDefinition");
static_assert(offsetof(UInteractionDefinition, InteractionID) == 0x000258, "Member 'UInteractionDefinition::InteractionID' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapTime) == 0x000268, "Member 'UInteractionDefinition::SnapTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ResetCameraDuringSnap) == 0x00026C, "Member 'UInteractionDefinition::ResetCameraDuringSnap' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IsInteractionCancelled) == 0x00026D, "Member 'UInteractionDefinition::IsInteractionCancelled' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowStartInteractionFromHeldInput) == 0x00026E, "Member 'UInteractionDefinition::AllowStartInteractionFromHeldInput' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopInteractionOnMontageComplete) == 0x00026F, "Member 'UInteractionDefinition::StopInteractionOnMontageComplete' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopInteractionOnMontageBlendingOut) == 0x000270, "Member 'UInteractionDefinition::StopInteractionOnMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopInteractionOnTimerExpire) == 0x000271, "Member 'UInteractionDefinition::StopInteractionOnTimerExpire' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopInteractionOnHeightDelta) == 0x000272, "Member 'UInteractionDefinition::StopInteractionOnHeightDelta' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopEnterMontageOnExit) == 0x000273, "Member 'UInteractionDefinition::StopEnterMontageOnExit' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopUpdateMontageOnExit) == 0x000274, "Member 'UInteractionDefinition::StopUpdateMontageOnExit' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IgnoreStrafeAnimFix) == 0x000275, "Member 'UInteractionDefinition::IgnoreStrafeAnimFix' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionAnimation) == 0x000276, "Member 'UInteractionDefinition::InteractionAnimation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CamperCanInteract) == 0x000277, "Member 'UInteractionDefinition::CamperCanInteract' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SlasherCanInteract) == 0x000278, "Member 'UInteractionDefinition::SlasherCanInteract' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowInputPersistence) == 0x000279, "Member 'UInteractionDefinition::AllowInputPersistence' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapPosition) == 0x00027A, "Member 'UInteractionDefinition::SnapPosition' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapRotation) == 0x00027B, "Member 'UInteractionDefinition::SnapRotation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapStopDistance) == 0x00027C, "Member 'UInteractionDefinition::SnapStopDistance' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, TestClearPathDuringSnap) == 0x000280, "Member 'UInteractionDefinition::TestClearPathDuringSnap' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CheckInteractableIsInPlayerView) == 0x000281, "Member 'UInteractionDefinition::CheckInteractableIsInPlayerView' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CheckInteractableInViewSphereSweepRadius) == 0x000284, "Member 'UInteractionDefinition::CheckInteractableInViewSphereSweepRadius' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CheckInteractableInViewOffset) == 0x000288, "Member 'UInteractionDefinition::CheckInteractableInViewOffset' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CheckInteractableInViewOffsetDistanceToHitPoint) == 0x000294, "Member 'UInteractionDefinition::CheckInteractableInViewOffsetDistanceToHitPoint' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IsInterruptibleIfTestClearPathDuringSnapFails) == 0x000298, "Member 'UInteractionDefinition::IsInterruptibleIfTestClearPathDuringSnapFails' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, TestPlayerOrientationOnSnap) == 0x000299, "Member 'UInteractionDefinition::TestPlayerOrientationOnSnap' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ScaleEnterAnimationToTime) == 0x00029A, "Member 'UInteractionDefinition::ScaleEnterAnimationToTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ScaleMainAnimationToTime) == 0x00029B, "Member 'UInteractionDefinition::ScaleMainAnimationToTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ScaleExitAnimationToTime) == 0x00029C, "Member 'UInteractionDefinition::ScaleExitAnimationToTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapBackType) == 0x00029D, "Member 'UInteractionDefinition::SnapBackType' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapBackPositionType) == 0x00029E, "Member 'UInteractionDefinition::SnapBackPositionType' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapBackPositionOffset) == 0x0002A0, "Member 'UInteractionDefinition::SnapBackPositionOffset' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapToInitialRotationDuringSnapBack) == 0x0002A8, "Member 'UInteractionDefinition::SnapToInitialRotationDuringSnapBack' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, UseStartSnapTimeForSnapExitTime) == 0x0002A9, "Member 'UInteractionDefinition::UseStartSnapTimeForSnapExitTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileIncapacitated) == 0x0002AA, "Member 'UInteractionDefinition::CanInteractWhileIncapacitated' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileCloaked) == 0x0002AB, "Member 'UInteractionDefinition::CanInteractWhileCloaked' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileAttacking) == 0x0002AC, "Member 'UInteractionDefinition::CanInteractWhileAttacking' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileChainLinked) == 0x0002AD, "Member 'UInteractionDefinition::CanInteractWhileChainLinked' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileShocked) == 0x0002AE, "Member 'UInteractionDefinition::CanInteractWhileShocked' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileUnhookingSelf) == 0x0002AF, "Member 'UInteractionDefinition::CanInteractWhileUnhookingSelf' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanInteractWhileCarrying) == 0x0002B0, "Member 'UInteractionDefinition::CanInteractWhileCarrying' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowNavigation) == 0x0002B1, "Member 'UInteractionDefinition::AllowNavigation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowNavigationInput) == 0x0002B2, "Member 'UInteractionDefinition::AllowNavigationInput' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowRotation) == 0x0002B3, "Member 'UInteractionDefinition::AllowRotation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, UseCameraMontageMode) == 0x0002B4, "Member 'UInteractionDefinition::UseCameraMontageMode' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OwnerBlocksAttack) == 0x0002B5, "Member 'UInteractionDefinition::OwnerBlocksAttack' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IsHighPriority) == 0x0002B6, "Member 'UInteractionDefinition::IsHighPriority' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowOverridingWhenNotForced) == 0x0002B7, "Member 'UInteractionDefinition::AllowOverridingWhenNotForced' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IgnoreOverlapOnInteractable) == 0x0002B8, "Member 'UInteractionDefinition::IgnoreOverlapOnInteractable' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, UseAuthoritativeMovement) == 0x0002B9, "Member 'UInteractionDefinition::UseAuthoritativeMovement' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanBeAuthoritativePushedDuringEnter) == 0x0002BA, "Member 'UInteractionDefinition::CanBeAuthoritativePushedDuringEnter' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanBeAuthoritativePushedDuringUpdate) == 0x0002BB, "Member 'UInteractionDefinition::CanBeAuthoritativePushedDuringUpdate' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanBeAuthoritativePushedDuringExit) == 0x0002BC, "Member 'UInteractionDefinition::CanBeAuthoritativePushedDuringExit' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanAuthoritativePush) == 0x0002BD, "Member 'UInteractionDefinition::CanAuthoritativePush' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CancelOnHit) == 0x0002BE, "Member 'UInteractionDefinition::CancelOnHit' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CancelOnAttack) == 0x0002BF, "Member 'UInteractionDefinition::CancelOnAttack' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, HideItem) == 0x0002C0, "Member 'UInteractionDefinition::HideItem' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AutoBindToParentInteractor) == 0x0002C1, "Member 'UInteractionDefinition::AutoBindToParentInteractor' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AutoBindToParentZone) == 0x0002C2, "Member 'UInteractionDefinition::AutoBindToParentZone' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CancelOnMoveInitialDelay) == 0x0002C4, "Member 'UInteractionDefinition::CancelOnMoveInitialDelay' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CancelOnMoveInput) == 0x0002C8, "Member 'UInteractionDefinition::CancelOnMoveInput' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CancelOnMoveInputOnlyWhenRunning) == 0x0002CC, "Member 'UInteractionDefinition::CancelOnMoveInputOnlyWhenRunning' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ProgressBasedSkillChecks) == 0x0002D0, "Member 'UInteractionDefinition::ProgressBasedSkillChecks' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, CanCrouch) == 0x0002E0, "Member 'UInteractionDefinition::CanCrouch' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AffectsStillness) == 0x0002E1, "Member 'UInteractionDefinition::AffectsStillness' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ConsideredIdle) == 0x0002E2, "Member 'UInteractionDefinition::ConsideredIdle' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, BlockSelfInteract) == 0x0002E3, "Member 'UInteractionDefinition::BlockSelfInteract' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionTime) == 0x0002E4, "Member 'UInteractionDefinition::InteractionTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionInputType) == 0x0002E8, "Member 'UInteractionDefinition::InteractionInputType' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, StopInteractionOnInputRelease) == 0x0002E9, "Member 'UInteractionDefinition::StopInteractionOnInputRelease' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, AllowHitMontageWhenInteracting) == 0x0002EA, "Member 'UInteractionDefinition::AllowHitMontageWhenInteracting' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ShowBasicInteractionIcon) == 0x0002EB, "Member 'UInteractionDefinition::ShowBasicInteractionIcon' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _interruptionDefinitions) == 0x0002F0, "Member 'UInteractionDefinition::_interruptionDefinitions' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OnInteractionEnteredDelegate) == 0x000300, "Member 'UInteractionDefinition::OnInteractionEnteredDelegate' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OnInteractionFinishedDelegate) == 0x000340, "Member 'UInteractionDefinition::OnInteractionFinishedDelegate' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OnInteractionInterruptedStartDelegate) == 0x000350, "Member 'UInteractionDefinition::OnInteractionInterruptedStartDelegate' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OnInteractionInterruptedStartedDelegate) == 0x000360, "Member 'UInteractionDefinition::OnInteractionInterruptedStartedDelegate' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OnInteractionInterruptedEndDelegate) == 0x000370, "Member 'UInteractionDefinition::OnInteractionInterruptedEndDelegate' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OnInteractionAnimNotify) == 0x000380, "Member 'UInteractionDefinition::OnInteractionAnimNotify' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, DebugUnavailability) == 0x000390, "Member 'UInteractionDefinition::DebugUnavailability' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SecondaryActionInputType) == 0x000391, "Member 'UInteractionDefinition::SecondaryActionInputType' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, NavigationSpeedCurveEnter) == 0x0003B0, "Member 'UInteractionDefinition::NavigationSpeedCurveEnter' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, NavigationSpeedCurve) == 0x0003B8, "Member 'UInteractionDefinition::NavigationSpeedCurve' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, NavigationSpeedCurveExit) == 0x0003C0, "Member 'UInteractionDefinition::NavigationSpeedCurveExit' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _shouldCheckInteractedUpon) == 0x0003C8, "Member 'UInteractionDefinition::_shouldCheckInteractedUpon' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, OwnershipUsability) == 0x0003C9, "Member 'UInteractionDefinition::OwnershipUsability' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ExitInteractionTime) == 0x0003CC, "Member 'UInteractionDefinition::ExitInteractionTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ApplyModifiersToExitTime) == 0x0003D0, "Member 'UInteractionDefinition::ApplyModifiersToExitTime' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionDescriptionText) == 0x0003D8, "Member 'UInteractionDefinition::InteractionDescriptionText' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionCanBeToggled) == 0x0003F0, "Member 'UInteractionDefinition::InteractionCanBeToggled' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IgnoreSprintToCancelSetting) == 0x0003F1, "Member 'UInteractionDefinition::IgnoreSprintToCancelSetting' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ForceWithSprintToCancelSetting) == 0x0003F2, "Member 'UInteractionDefinition::ForceWithSprintToCancelSetting' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, InteractionHeightDeltaMax) == 0x0003F4, "Member 'UInteractionDefinition::InteractionHeightDeltaMax' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, MaximumVelocity) == 0x0003F8, "Member 'UInteractionDefinition::MaximumVelocity' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, EnterMontage) == 0x000400, "Member 'UInteractionDefinition::EnterMontage' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, UpdateMontage) == 0x000420, "Member 'UInteractionDefinition::UpdateMontage' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ExitMontage) == 0x000440, "Member 'UInteractionDefinition::ExitMontage' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, EnterMontageVariantCycle) == 0x000460, "Member 'UInteractionDefinition::EnterMontageVariantCycle' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, UpdateMontageVariantCycle) == 0x000470, "Member 'UInteractionDefinition::UpdateMontageVariantCycle' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, ExitMontageVariantCycle) == 0x000480, "Member 'UInteractionDefinition::ExitMontageVariantCycle' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, SnapSocketName) == 0x000490, "Member 'UInteractionDefinition::SnapSocketName' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _canBeAttachedToAnyZone) == 0x00049C, "Member 'UInteractionDefinition::_canBeAttachedToAnyZone' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _isInterruptibleBySacrifice) == 0x00049D, "Member 'UInteractionDefinition::_isInterruptibleBySacrifice' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, IgnoreStun) == 0x00049E, "Member 'UInteractionDefinition::IgnoreStun' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _tags) == 0x0004A0, "Member 'UInteractionDefinition::_tags' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _objectStateTag) == 0x0004C0, "Member 'UInteractionDefinition::_objectStateTag' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _secondaryInteractions) == 0x0004D0, "Member 'UInteractionDefinition::_secondaryInteractions' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _useHoldPrompt) == 0x000520, "Member 'UInteractionDefinition::_useHoldPrompt' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _allowInteractionInNarrowSpaces) == 0x000521, "Member 'UInteractionDefinition::_allowInteractionInNarrowSpaces' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _allowIKSensorDuringInteraction) == 0x000522, "Member 'UInteractionDefinition::_allowIKSensorDuringInteraction' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _overrideSlashableRelativeLocation) == 0x000523, "Member 'UInteractionDefinition::_overrideSlashableRelativeLocation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _slashableRelativeLocation) == 0x000524, "Member 'UInteractionDefinition::_slashableRelativeLocation' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _startUpdateMontageDuringEnter) == 0x000530, "Member 'UInteractionDefinition::_startUpdateMontageDuringEnter' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _interactor) == 0x000538, "Member 'UInteractionDefinition::_interactor' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _mutuallyExclusiveInteractionsClient) == 0x000540, "Member 'UInteractionDefinition::_mutuallyExclusiveInteractionsClient' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _activationDefinition) == 0x000550, "Member 'UInteractionDefinition::_activationDefinition' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _zone) == 0x000578, "Member 'UInteractionDefinition::_zone' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _cancelInputType) == 0x000580, "Member 'UInteractionDefinition::_cancelInputType' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _preventingTags) == 0x000588, "Member 'UInteractionDefinition::_preventingTags' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _disablingTags) == 0x0005A8, "Member 'UInteractionDefinition::_disablingTags' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, _evaluatingInteractionHandlers) == 0x0005C8, "Member 'UInteractionDefinition::_evaluatingInteractionHandlers' has a wrong offset!");
static_assert(offsetof(UInteractionDefinition, DEPRECATED_SecondaryInteractionProperties) == 0x0005D8, "Member 'UInteractionDefinition::DEPRECATED_SecondaryInteractionProperties' has a wrong offset!");

// Class DeadByDaylight.UMGPromoPackSelectedItemWidget
// 0x0038 (0x0370 - 0x0338)
class UUMGPromoPackSelectedItemWidget final : public UMobileBaseUserWidget
{
public:
	class UUMGHtmlRichText*                       ItemDescription;                                   // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemTypeIcon;                                      // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemName;                                          // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemSubtitle;                                      // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNamedSlot*                             SelectedItemSlot;                                  // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGPromoPackItemWidget*                SelectedItem;                                      // 0x0360(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBox;                                         // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPromoPackSelectedItemWidget">();
	}
	static class UUMGPromoPackSelectedItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPromoPackSelectedItemWidget>();
	}
};
static_assert(alignof(UUMGPromoPackSelectedItemWidget) == 0x000008, "Wrong alignment on UUMGPromoPackSelectedItemWidget");
static_assert(sizeof(UUMGPromoPackSelectedItemWidget) == 0x000370, "Wrong size on UUMGPromoPackSelectedItemWidget");
static_assert(offsetof(UUMGPromoPackSelectedItemWidget, ItemDescription) == 0x000338, "Member 'UUMGPromoPackSelectedItemWidget::ItemDescription' has a wrong offset!");
static_assert(offsetof(UUMGPromoPackSelectedItemWidget, ItemTypeIcon) == 0x000340, "Member 'UUMGPromoPackSelectedItemWidget::ItemTypeIcon' has a wrong offset!");
static_assert(offsetof(UUMGPromoPackSelectedItemWidget, ItemName) == 0x000348, "Member 'UUMGPromoPackSelectedItemWidget::ItemName' has a wrong offset!");
static_assert(offsetof(UUMGPromoPackSelectedItemWidget, ItemSubtitle) == 0x000350, "Member 'UUMGPromoPackSelectedItemWidget::ItemSubtitle' has a wrong offset!");
static_assert(offsetof(UUMGPromoPackSelectedItemWidget, SelectedItemSlot) == 0x000358, "Member 'UUMGPromoPackSelectedItemWidget::SelectedItemSlot' has a wrong offset!");
static_assert(offsetof(UUMGPromoPackSelectedItemWidget, SelectedItem) == 0x000360, "Member 'UUMGPromoPackSelectedItemWidget::SelectedItem' has a wrong offset!");
static_assert(offsetof(UUMGPromoPackSelectedItemWidget, ScrollBox) == 0x000368, "Member 'UUMGPromoPackSelectedItemWidget::ScrollBox' has a wrong offset!");

// Class DeadByDaylight.DynamicGrass
// 0x0018 (0x0248 - 0x0230)
class ADynamicGrass final : public AActor
{
public:
	class UMaterialParameterCollection*           _worldSettings;                                    // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x10];                                     // 0x0238(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicGrass">();
	}
	static class ADynamicGrass* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicGrass>();
	}
};
static_assert(alignof(ADynamicGrass) == 0x000008, "Wrong alignment on ADynamicGrass");
static_assert(sizeof(ADynamicGrass) == 0x000248, "Wrong size on ADynamicGrass");
static_assert(offsetof(ADynamicGrass, _worldSettings) == 0x000230, "Member 'ADynamicGrass::_worldSettings' has a wrong offset!");

// Class DeadByDaylight.ScreenBase
// 0x00F0 (0x0120 - 0x0030)
class UScreenBase : public UObject
{
public:
	bool                                          IsAnimationDone;                                   // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UGFxObject*                             ScreenObject;                                      // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScreenController*                      _screenController;                                 // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0xD8];                                      // 0x0048(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastOnHighlightedElementClickedEvent(const class FName onBoardingID);
	void OnAnimationUpdate(int32 isAnimationDone);
	void OnAnyKey(float code);
	void OnBack();
	void OnEscape();
	void OnHideVirtualKeyboardRequested();
	void OnNavKey(const class FString& navKey);
	void OnStart();
	void OnTextInputMouseClicked(bool isPassword);

	void SetFadesOut(bool fadesOut) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenBase">();
	}
	static class UScreenBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenBase>();
	}
};
static_assert(alignof(UScreenBase) == 0x000008, "Wrong alignment on UScreenBase");
static_assert(sizeof(UScreenBase) == 0x000120, "Wrong size on UScreenBase");
static_assert(offsetof(UScreenBase, IsAnimationDone) == 0x000030, "Member 'UScreenBase::IsAnimationDone' has a wrong offset!");
static_assert(offsetof(UScreenBase, ScreenObject) == 0x000038, "Member 'UScreenBase::ScreenObject' has a wrong offset!");
static_assert(offsetof(UScreenBase, _screenController) == 0x000040, "Member 'UScreenBase::_screenController' has a wrong offset!");

// Class DeadByDaylight.AtlantaFriendsListScreenUMG
// 0x0080 (0x01A0 - 0x0120)
class UAtlantaFriendsListScreenUMG final : public UScreenBase
{
public:
	uint8                                         Pad_120[0x78];                                     // 0x0120(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGAtlantaFriendListScreen*            _atlantaFriendListScreen;                          // 0x0198(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleClosedButtonClicked();
	void HandleResearchButtonClicked(const class FText& searchInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaFriendsListScreenUMG">();
	}
	static class UAtlantaFriendsListScreenUMG* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaFriendsListScreenUMG>();
	}
};
static_assert(alignof(UAtlantaFriendsListScreenUMG) == 0x000008, "Wrong alignment on UAtlantaFriendsListScreenUMG");
static_assert(sizeof(UAtlantaFriendsListScreenUMG) == 0x0001A0, "Wrong size on UAtlantaFriendsListScreenUMG");
static_assert(offsetof(UAtlantaFriendsListScreenUMG, _atlantaFriendListScreen) == 0x000198, "Member 'UAtlantaFriendsListScreenUMG::_atlantaFriendListScreen' has a wrong offset!");

// Class DeadByDaylight.AttackTypeEventComponent
// 0x0018 (0x00D0 - 0x00B8)
class UAttackTypeEventComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackTypeEventComponent">();
	}
	static class UAttackTypeEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackTypeEventComponent>();
	}
};
static_assert(alignof(UAttackTypeEventComponent) == 0x000008, "Wrong alignment on UAttackTypeEventComponent");
static_assert(sizeof(UAttackTypeEventComponent) == 0x0000D0, "Wrong size on UAttackTypeEventComponent");

// Class DeadByDaylight.SurveillancePerk
// 0x0008 (0x03D0 - 0x03C8)
class USurveillancePerk final : public UPerk
{
public:
	float                                         generatorRegressionStopRevealTime;                 // 0x03C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleGeneratorIsDamagedChanged(class AGenerator* generator, class ADBDPlayer* player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurveillancePerk">();
	}
	static class USurveillancePerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurveillancePerk>();
	}
};
static_assert(alignof(USurveillancePerk) == 0x000008, "Wrong alignment on USurveillancePerk");
static_assert(sizeof(USurveillancePerk) == 0x0003D0, "Wrong size on USurveillancePerk");
static_assert(offsetof(USurveillancePerk, generatorRegressionStopRevealTime) == 0x0003C8, "Member 'USurveillancePerk::generatorRegressionStopRevealTime' has a wrong offset!");

// Class DeadByDaylight.BasePerkIconStrategy
// 0x0008 (0x0038 - 0x0030)
class UBasePerkIconStrategy : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetDisplayPercent(const class UPerk* perk) const;
	bool GetIsRechargeable(const class UPerk* perk) const;
	bool GetIsRechargeableActive(const class UPerk* perk) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePerkIconStrategy">();
	}
	static class UBasePerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePerkIconStrategy>();
	}
};
static_assert(alignof(UBasePerkIconStrategy) == 0x000008, "Wrong alignment on UBasePerkIconStrategy");
static_assert(sizeof(UBasePerkIconStrategy) == 0x000038, "Wrong size on UBasePerkIconStrategy");

// Class DeadByDaylight.ActivationTimerIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerIconStrategy">();
	}
	static class UActivationTimerIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerIconStrategy");
static_assert(sizeof(UActivationTimerIconStrategy) == 0x000038, "Wrong size on UActivationTimerIconStrategy");

// Class DeadByDaylight.SourceBasedOutlineUpdateStrategy
// 0x0078 (0x0138 - 0x00C0)
class USourceBasedOutlineUpdateStrategy : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _defaultColorForSurvivor;                          // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _defaultColorForSlasher;                           // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x58];                                      // 0x00E0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddRangedReveal(const class UObject* source, const class AActor* sourceActor, const struct FLinearColor& highlightColor, int32 priority, const TArray<class ADBDPlayer*>& affectedCharacters, float range);
	void AddReveal(const class UObject* source, const struct FLinearColor& highlightColor, int32 priority, const TArray<class ADBDPlayer*>& affectedCharacters);
	void AddRevealWithOptions(const class UObject* source, const struct FLinearColor& highlightColor, int32 priority, const TArray<class ADBDPlayer*>& affectedCharacters, const struct FRevealOptions& options);
	void AddTimedAndRangedReveal(const class UObject* source, const class AActor* sourceActor, const struct FLinearColor& highlightColor, int32 priority, const TArray<class ADBDPlayer*>& affectedCharacters, float duration, float range);
	void AddTimedReveal(const class UObject* source, const struct FLinearColor& highlightColor, int32 priority, const TArray<class ADBDPlayer*>& affectedCharacters, float duration);
	void ChangeDefaultColorForSlasher(const struct FLinearColor& newColor);
	void ChangeDefaultColorForSurvivor(const struct FLinearColor& newColor);
	void RemoveRevealSource(const class UObject* source);
	void ResetReveal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SourceBasedOutlineUpdateStrategy">();
	}
	static class USourceBasedOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USourceBasedOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USourceBasedOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USourceBasedOutlineUpdateStrategy");
static_assert(sizeof(USourceBasedOutlineUpdateStrategy) == 0x000138, "Wrong size on USourceBasedOutlineUpdateStrategy");
static_assert(offsetof(USourceBasedOutlineUpdateStrategy, _defaultColorForSurvivor) == 0x0000C0, "Member 'USourceBasedOutlineUpdateStrategy::_defaultColorForSurvivor' has a wrong offset!");
static_assert(offsetof(USourceBasedOutlineUpdateStrategy, _defaultColorForSlasher) == 0x0000D0, "Member 'USourceBasedOutlineUpdateStrategy::_defaultColorForSlasher' has a wrong offset!");

// Class DeadByDaylight.UMGTallyListElementWidget
// 0x0010 (0x0348 - 0x0338)
class UUMGTallyListElementWidget : public UMobileBaseUserWidget
{
public:
	int32                                         ElementIndex;                                      // 0x0338(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              WidgetSize;                                        // 0x033C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInAnimationFinished();
	void OnPageVisibilityChanged(bool isVisible, bool wasInAnimationPlayed);
	void OnPlayInAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyListElementWidget">();
	}
	static class UUMGTallyListElementWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyListElementWidget>();
	}
};
static_assert(alignof(UUMGTallyListElementWidget) == 0x000008, "Wrong alignment on UUMGTallyListElementWidget");
static_assert(sizeof(UUMGTallyListElementWidget) == 0x000348, "Wrong size on UUMGTallyListElementWidget");
static_assert(offsetof(UUMGTallyListElementWidget, ElementIndex) == 0x000338, "Member 'UUMGTallyListElementWidget::ElementIndex' has a wrong offset!");
static_assert(offsetof(UUMGTallyListElementWidget, WidgetSize) == 0x00033C, "Member 'UUMGTallyListElementWidget::WidgetSize' has a wrong offset!");

// Class DeadByDaylight.UMGTallyPlayerLevelWidget
// 0x0048 (0x0390 - 0x0348)
class UUMGTallyPlayerLevelWidget final : public UUMGTallyListElementWidget
{
public:
	uint8                                         Pad_348[0x48];                                     // 0x0348(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSetFinalPlayerXp(int32 finalXp, const TArray<struct FPlayerLevelData>& reachedLevels, const TArray<struct FXpBonusData>& xpBonuses, const TArray<struct FRewardItemData>& rewardsEarned);
	void OnSetInitialPlayerXp(int32 initialXp, const struct FPlayerLevelData& initialLevelData);

	const int32 GetFinalXp() const;
	const int32 GetInitialXp() const;
	const TArray<struct FPlayerLevelData> GetReachedLevels() const;
	const TArray<struct FRewardItemData> GetRewardsEarned() const;
	const TArray<struct FXpBonusData> GetXpBonuses() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyPlayerLevelWidget">();
	}
	static class UUMGTallyPlayerLevelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyPlayerLevelWidget>();
	}
};
static_assert(alignof(UUMGTallyPlayerLevelWidget) == 0x000008, "Wrong alignment on UUMGTallyPlayerLevelWidget");
static_assert(sizeof(UUMGTallyPlayerLevelWidget) == 0x000390, "Wrong size on UUMGTallyPlayerLevelWidget");

// Class DeadByDaylight.DBDHookUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDHookUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float ComputeHookStrugglePercent(const class ACamperPlayer* hookedCamper, float hookStruggleThreshold);
	static bool IsFreddyHook(class AMeatHook* targetHook);
	static bool IsHagHook(class AMeatHook* targetHook);
	static bool IsHookOf(class AMeatHook* targetHook, const struct FGameplayTag& hookTag);
	static bool IsHuntressHook(class AMeatHook* targetHook);
	static bool IsLegionHook(class AMeatHook* targetHook);
	static bool IsNurseHook(class AMeatHook* targetHook);
	static bool IsPigHook(class AMeatHook* targetHook);
	static bool IsWraithHook(class AMeatHook* targetHook);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHookUtilities">();
	}
	static class UDBDHookUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHookUtilities>();
	}
};
static_assert(alignof(UDBDHookUtilities) == 0x000008, "Wrong alignment on UDBDHookUtilities");
static_assert(sizeof(UDBDHookUtilities) == 0x000030, "Wrong size on UDBDHookUtilities");

// Class DeadByDaylight.ConsentManager
// 0x0070 (0x00A0 - 0x0030)
class UConsentManager final : public UObject
{
public:
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsentManager">();
	}
	static class UConsentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsentManager>();
	}
};
static_assert(alignof(UConsentManager) == 0x000008, "Wrong alignment on UConsentManager");
static_assert(sizeof(UConsentManager) == 0x0000A0, "Wrong size on UConsentManager");

// Class DeadByDaylight.ItemModifier
// 0x0060 (0x0278 - 0x0218)
class UItemModifier : public UGameplayModifierContainer
{
public:
	struct FGameplayModifierData                  ModifierData;                                      // 0x0218(0x0030)(Edit, Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x30];                                     // 0x0248(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AuthoritySetItemCount(int32 itemCount);
	void AuthoritySetItemEnergy(float energy);
	void AuthoritySetItemMaxEnergy(float energy);
	void HandleIncreaseCharge();
	void HandleIncreaseItemCount();
	void HandleIncreaseMaxCharge();

	class ACollectable* GetBaseItem() const;
	int32 GetItemCount() const;
	float GetItemEnergy() const;
	float GetItemMaxEnergy() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemModifier">();
	}
	static class UItemModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemModifier>();
	}
};
static_assert(alignof(UItemModifier) == 0x000008, "Wrong alignment on UItemModifier");
static_assert(sizeof(UItemModifier) == 0x000278, "Wrong size on UItemModifier");
static_assert(offsetof(UItemModifier, ModifierData) == 0x000218, "Member 'UItemModifier::ModifierData' has a wrong offset!");

// Class DeadByDaylight.ItemAddon
// 0x0040 (0x02B8 - 0x0278)
class UItemAddon : public UItemModifier
{
public:
	TSubclassOf<class ACollectable>               BaseItemType;                                      // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _needsSetup;                                       // 0x0280(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x1F];                                     // 0x0281(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _tokenCount;                                       // 0x02A0(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxTokenCount;                                    // 0x02A4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FItemAddonInitializationData           _addonInitializationData;                          // 0x02A8(0x0002)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AA[0xE];                                      // 0x02AA(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_ApplyMetaModifiers();
	void Authority_DecrementToken();
	void Authority_IncrementToken();
	void Authority_OnCollectableDropped(class ADBDPlayer* player);
	void Authority_OnCollectablePickedUp(class ADBDPlayer* player);
	void Authority_SetMaxTokenCount(int32 value);
	void Authority_SetTokenCount(int32 value);
	void DebugPrintStats();
	void Multicast_AddAddonToItem(class ACollectable* item);
	void Multicast_SetBaseItem(class ACollectable* baseItem);
	void OnPostItemAddonsCreation(class ADBDPlayer* player, class ACollectable* item);
	void OnRep_AddonInitializationData();
	void OnRep_TokenCount(int32 oldCount);
	void SetUpAddon();

	int32 GetMaxTokenCount() const;
	int32 GetTokenCount() const;
	bool IsReadyForSetUp() const;
	bool IsSecondaryAction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAddon">();
	}
	static class UItemAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAddon>();
	}
};
static_assert(alignof(UItemAddon) == 0x000008, "Wrong alignment on UItemAddon");
static_assert(sizeof(UItemAddon) == 0x0002B8, "Wrong size on UItemAddon");
static_assert(offsetof(UItemAddon, BaseItemType) == 0x000278, "Member 'UItemAddon::BaseItemType' has a wrong offset!");
static_assert(offsetof(UItemAddon, _needsSetup) == 0x000280, "Member 'UItemAddon::_needsSetup' has a wrong offset!");
static_assert(offsetof(UItemAddon, _tokenCount) == 0x0002A0, "Member 'UItemAddon::_tokenCount' has a wrong offset!");
static_assert(offsetof(UItemAddon, _maxTokenCount) == 0x0002A4, "Member 'UItemAddon::_maxTokenCount' has a wrong offset!");
static_assert(offsetof(UItemAddon, _addonInitializationData) == 0x0002A8, "Member 'UItemAddon::_addonInitializationData' has a wrong offset!");

// Class DeadByDaylight.AISenseEvent_Trail
// 0x0030 (0x0060 - 0x0030)
class UAISenseEvent_Trail final : public UAISenseEvent
{
public:
	struct FAITrailEvent                          Event;                                             // 0x0030(0x0030)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseEvent_Trail">();
	}
	static class UAISenseEvent_Trail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseEvent_Trail>();
	}
};
static_assert(alignof(UAISenseEvent_Trail) == 0x000008, "Wrong alignment on UAISenseEvent_Trail");
static_assert(sizeof(UAISenseEvent_Trail) == 0x000060, "Wrong size on UAISenseEvent_Trail");
static_assert(offsetof(UAISenseEvent_Trail, Event) == 0x000030, "Member 'UAISenseEvent_Trail::Event' has a wrong offset!");

// Class DeadByDaylight.StreamVideoPlayer
// 0x0098 (0x02C8 - 0x0230)
class AStreamVideoPlayer final : public AActor
{
public:
	uint8                                         Pad_230[0x38];                                     // 0x0230(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UMediaPlayer*                           MediaPlayer;                                       // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMediaSoundComponent*                   SoundComponent;                                    // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGStreamVideoWidget*                  StreamVideoWidget;                                 // 0x0278(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStreamMediaSource*                     StreamMediaSource;                                 // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        _audioComponent;                                   // 0x0288(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x38];                                     // 0x0290(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEndReached();
	void OnMediaClosed();
	void OnMediaOpened(const class FString& openedUrl);
	void OnSkipButtonTriggered();
	void OnVideoAssetLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamVideoPlayer">();
	}
	static class AStreamVideoPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStreamVideoPlayer>();
	}
};
static_assert(alignof(AStreamVideoPlayer) == 0x000008, "Wrong alignment on AStreamVideoPlayer");
static_assert(sizeof(AStreamVideoPlayer) == 0x0002C8, "Wrong size on AStreamVideoPlayer");
static_assert(offsetof(AStreamVideoPlayer, MediaPlayer) == 0x000268, "Member 'AStreamVideoPlayer::MediaPlayer' has a wrong offset!");
static_assert(offsetof(AStreamVideoPlayer, SoundComponent) == 0x000270, "Member 'AStreamVideoPlayer::SoundComponent' has a wrong offset!");
static_assert(offsetof(AStreamVideoPlayer, StreamVideoWidget) == 0x000278, "Member 'AStreamVideoPlayer::StreamVideoWidget' has a wrong offset!");
static_assert(offsetof(AStreamVideoPlayer, StreamMediaSource) == 0x000280, "Member 'AStreamVideoPlayer::StreamMediaSource' has a wrong offset!");
static_assert(offsetof(AStreamVideoPlayer, _audioComponent) == 0x000288, "Member 'AStreamVideoPlayer::_audioComponent' has a wrong offset!");

// Class DeadByDaylight.ChargeableInteractionDefinition
// 0x0120 (0x0740 - 0x0620)
class UChargeableInteractionDefinition : public UInteractionDefinition
{
public:
	uint8                                         Pad_618[0x18];                                     // 0x0618(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, ESkillCheckCustomType type)> SkillCheckResponseAestheticDelegate; // 0x0630(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, ESkillCheckCustomType type)> SkillCheckResponseAuthorityDelegate; // 0x0640(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          StopInteractionOnChargeComplete;                   // 0x0650(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasProgressivelyHarderSkillChecks;                 // 0x0651(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_652[0x2];                                      // 0x0652(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProgressiveDifficultyModifier;                     // 0x0654(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EChargeableInteractionBarType                 ProgressBarType;                                   // 0x0658(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_659[0x7];                                      // 0x0659(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ProgressPips;                                      // 0x0660(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          HideProgressBar;                                   // 0x0670(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowItemIcon;                                      // 0x0671(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_672[0x6];                                      // 0x0672(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _chargeableComponent;                              // 0x0678(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _tutorialChargeableMultiplier;                     // 0x0680(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_684[0x54];                                     // 0x0684(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowSpeedProficiencyForMultipleInteractors;        // 0x06D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6D9[0x7];                                      // 0x06D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _interactionSpecificActionSpeedTags;               // 0x06E0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  _interactionSpecificActionSpeedMultiplicativeTags; // 0x0700(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  _interactionSpecificActionDurationAdditiveTags;    // 0x0720(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Authority_AddCharge(float deltaSeconds, class ADBDPlayer* character, bool isChargeFromItem);
	void Authority_ChargeWithItem(float deltaSeconds, class ACollectable* item, class ADBDPlayer* character);
	void OnInteractionCompletionStateChanged(class ADBDPlayer* player, bool complete);
	void OnSkillCheckResponseAesthetic(bool success, bool bonus, class ADBDPlayer* player, bool triggerLoudNoise, bool hadInput, ESkillCheckCustomType type);
	void OnSkillCheckResponseAestheticBP(class ADBDPlayer* player, bool success, bool bonus, bool hadInput, ESkillCheckCustomType type);
	void OnSkillCheckResponseAuthority(bool success, bool bonus, class ADBDPlayer* player, bool triggerLoudNoise, bool hadInput, ESkillCheckCustomType type);
	void OnSkillCheckResponseAuthorityBP(class ADBDPlayer* player, bool success, bool bonus, bool hadInput, ESkillCheckCustomType type);
	void SetChargeableComponent(class UChargeableComponent* chargeableComponent, bool isNullAllowed);
	void SetSpeedBase(float speedBase);
	void SetTutorialChargeableMultiplier(float multiplierValue);

	float GetAdditiveChargeTimeReductionAsMultiplier(const class ADBDPlayer* character) const;
	float GetAdditiveLuckBonus(const class ADBDPlayer* character) const;
	float GetBonusSkillCheckSuccessPercentReward(const class ADBDPlayer* player) const;
	float GetBonusSkillCheckZoneSizeModifier(const class ADBDPlayer* character) const;
	class UChargeableComponent* GetChargeableComponent() const;
	float GetChargeAmountForTime(float deltaSeconds, class ADBDPlayer* character) const;
	float GetChargeSpeedModifier(const class ADBDPlayer* character) const;
	float GetGoodSkillCheckSuccessPercentReward(const class ADBDPlayer* player) const;
	float GetInteractionChargeSpeedMultiplier(const class ADBDPlayer* character) const;
	float GetItemEfficiencyModifier(const class ADBDPlayer* character) const;
	float GetMaxCharge() const;
	float GetMultiplicativeLuckBonus(const class ADBDPlayer* character) const;
	float GetPerkMultiplier(const class ADBDPlayer* character) const;
	int32 GetPipsPassed() const;
	float GetSkillCheckCharge(class ADBDPlayer* player, bool success, bool bonus, ESkillCheckCustomType type) const;
	float GetSkillCheckDifficulityModifier(const class ADBDPlayer* character) const;
	float GetSkillCheckFailurePercentPenalty(const class ADBDPlayer* player) const;
	float GetSkillCheckFailureTimePenalty() const;
	float GetSkillCheckProbability(const class ADBDPlayer* interactingPlayer) const;
	float GetSuccessProbability() const;
	float GetTunableValue(class FName TunableValueID, float defaultValue) const;
	bool HasSkillCheckHappened(const class ADBDPlayer* character) const;
	bool IsChargeComplete(const class ADBDPlayer* currentlyInteractingPlayer) const;
	bool ShouldShowSpeedProficiencyForMultipleInteractors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeableInteractionDefinition">();
	}
	static class UChargeableInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeableInteractionDefinition>();
	}
};
static_assert(alignof(UChargeableInteractionDefinition) == 0x000010, "Wrong alignment on UChargeableInteractionDefinition");
static_assert(sizeof(UChargeableInteractionDefinition) == 0x000740, "Wrong size on UChargeableInteractionDefinition");
static_assert(offsetof(UChargeableInteractionDefinition, SkillCheckResponseAestheticDelegate) == 0x000630, "Member 'UChargeableInteractionDefinition::SkillCheckResponseAestheticDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, SkillCheckResponseAuthorityDelegate) == 0x000640, "Member 'UChargeableInteractionDefinition::SkillCheckResponseAuthorityDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, StopInteractionOnChargeComplete) == 0x000650, "Member 'UChargeableInteractionDefinition::StopInteractionOnChargeComplete' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, HasProgressivelyHarderSkillChecks) == 0x000651, "Member 'UChargeableInteractionDefinition::HasProgressivelyHarderSkillChecks' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ProgressiveDifficultyModifier) == 0x000654, "Member 'UChargeableInteractionDefinition::ProgressiveDifficultyModifier' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ProgressBarType) == 0x000658, "Member 'UChargeableInteractionDefinition::ProgressBarType' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ProgressPips) == 0x000660, "Member 'UChargeableInteractionDefinition::ProgressPips' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, HideProgressBar) == 0x000670, "Member 'UChargeableInteractionDefinition::HideProgressBar' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ShowItemIcon) == 0x000671, "Member 'UChargeableInteractionDefinition::ShowItemIcon' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, _chargeableComponent) == 0x000678, "Member 'UChargeableInteractionDefinition::_chargeableComponent' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, _tutorialChargeableMultiplier) == 0x000680, "Member 'UChargeableInteractionDefinition::_tutorialChargeableMultiplier' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, ShowSpeedProficiencyForMultipleInteractors) == 0x0006D8, "Member 'UChargeableInteractionDefinition::ShowSpeedProficiencyForMultipleInteractors' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, _interactionSpecificActionSpeedTags) == 0x0006E0, "Member 'UChargeableInteractionDefinition::_interactionSpecificActionSpeedTags' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, _interactionSpecificActionSpeedMultiplicativeTags) == 0x000700, "Member 'UChargeableInteractionDefinition::_interactionSpecificActionSpeedMultiplicativeTags' has a wrong offset!");
static_assert(offsetof(UChargeableInteractionDefinition, _interactionSpecificActionDurationAdditiveTags) == 0x000720, "Member 'UChargeableInteractionDefinition::_interactionSpecificActionDurationAdditiveTags' has a wrong offset!");

// Class DeadByDaylight.PopupFactory
// 0x0008 (0x0038 - 0x0030)
class UPopupFactory final : public UObject
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupFactory">();
	}
	static class UPopupFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupFactory>();
	}
};
static_assert(alignof(UPopupFactory) == 0x000008, "Wrong alignment on UPopupFactory");
static_assert(sizeof(UPopupFactory) == 0x000038, "Wrong size on UPopupFactory");
static_assert(offsetof(UPopupFactory, _gameInstance) == 0x000030, "Member 'UPopupFactory::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.CrossPromotionManager
// 0x0028 (0x0060 - 0x0038)
class UCrossPromotionManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrossPromotionManager">();
	}
	static class UCrossPromotionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrossPromotionManager>();
	}
};
static_assert(alignof(UCrossPromotionManager) == 0x000008, "Wrong alignment on UCrossPromotionManager");
static_assert(sizeof(UCrossPromotionManager) == 0x000060, "Wrong size on UCrossPromotionManager");

// Class DeadByDaylight.Interactable
// 0x00F8 (0x0328 - 0x0230)
class AInteractable : public AActor
{
public:
	uint8                                         Pad_230[0x60];                                     // 0x0230(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    _singleZone;                                       // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useSingleZone;                                    // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractor*>                    _interactors;                                      // 0x02A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UInteractableTransformOptimizer*        _transformOptimizer;                               // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x20];                                     // 0x02B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UPrimitiveComponent*, struct FInteractionArray> _zoneToInteractions;                  // 0x02D8(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AttachEveryInteractionToZone(class UPrimitiveComponent* zone);
	void AuthorityRequestCancelOngoingInteractions(bool onlyOnHitCancelableInteractions);
	void OnInteractorLockChanged(bool locked, class ADBDPlayer* interactingPlayer);
	void OnLevelReadyToPlay();
	void OnLevelReadyToPlay_Native();
	void PreInterruptionEvent(class ADBDPlayer* interruptor, class ADBDPlayer* interruptee, class UInterruptionDefinition* interruption);
	void SetInteractorsUsable(bool usable, class UInteractor* exception);
	void SetSingleZone(class UPrimitiveComponent* zone);

	TArray<class ADBDPlayer*> Authority_GetInteractingPlayers() const;
	struct FVector GetFocalPointPosition(const class ADBDPlayer* player, const class UInteractionDefinition* definition) const;
	TArray<class ADBDPlayer*> GetInteractingPlayersRaw() const;
	TArray<class UInteractor*> GetInteractors() const;
	class ADBDPlayer* GetPlayerOwner() const;
	bool HasAnOngoingInteraction() const;
	bool IsInteractingWith(const class ADBDPlayer* player) const;
	bool IsInteractionDone(class ADBDPlayer* player, const class UInteractor* interactor, const class UInteractionDefinition* definition, EInputInteractionType interactionType) const;
	bool IsInterruptionPossible(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee, const class UInteractor* interactor, const class UInteractionDefinition* definition, const class UInterruptionDefinition* interruption) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interactable">();
	}
	static class AInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInteractable>();
	}
};
static_assert(alignof(AInteractable) == 0x000008, "Wrong alignment on AInteractable");
static_assert(sizeof(AInteractable) == 0x000328, "Wrong size on AInteractable");
static_assert(offsetof(AInteractable, _singleZone) == 0x000290, "Member 'AInteractable::_singleZone' has a wrong offset!");
static_assert(offsetof(AInteractable, _useSingleZone) == 0x000298, "Member 'AInteractable::_useSingleZone' has a wrong offset!");
static_assert(offsetof(AInteractable, _interactors) == 0x0002A0, "Member 'AInteractable::_interactors' has a wrong offset!");
static_assert(offsetof(AInteractable, _transformOptimizer) == 0x0002B0, "Member 'AInteractable::_transformOptimizer' has a wrong offset!");
static_assert(offsetof(AInteractable, _zoneToInteractions) == 0x0002D8, "Member 'AInteractable::_zoneToInteractions' has a wrong offset!");

// Class DeadByDaylight.SpecialBehaviourInteractable
// 0x0040 (0x0368 - 0x0328)
class ASpecialBehaviourInteractable : public AInteractable
{
public:
	uint8                                         Pad_328[0x30];                                     // 0x0328(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ADBDPlayerState>         _specialBehaviourOwner;                            // 0x0358(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SpecialBehaviourOwner();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialBehaviourInteractable">();
	}
	static class ASpecialBehaviourInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpecialBehaviourInteractable>();
	}
};
static_assert(alignof(ASpecialBehaviourInteractable) == 0x000008, "Wrong alignment on ASpecialBehaviourInteractable");
static_assert(sizeof(ASpecialBehaviourInteractable) == 0x000368, "Wrong size on ASpecialBehaviourInteractable");
static_assert(offsetof(ASpecialBehaviourInteractable, _specialBehaviourOwner) == 0x000358, "Member 'ASpecialBehaviourInteractable::_specialBehaviourOwner' has a wrong offset!");

// Class DeadByDaylight.StandDisplayable
// 0x0000 (0x0000 - 0x0000)
class IStandDisplayable final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StandDisplayable">();
	}
	static class IStandDisplayable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStandDisplayable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStandDisplayable) == 0x000001, "Wrong alignment on IStandDisplayable");
static_assert(sizeof(IStandDisplayable) == 0x000001, "Wrong size on IStandDisplayable");

// Class DeadByDaylight.Charm
// 0x0048 (0x0278 - 0x0230)
class ACharm final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 _skeletalMeshComponent;                            // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x18];                                     // 0x0240(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AItemVfx*                               _actorVfx;                                         // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginDestroySequence_Internal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Charm">();
	}
	static class ACharm* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharm>();
	}
};
static_assert(alignof(ACharm) == 0x000008, "Wrong alignment on ACharm");
static_assert(sizeof(ACharm) == 0x000278, "Wrong size on ACharm");
static_assert(offsetof(ACharm, _skeletalMeshComponent) == 0x000238, "Member 'ACharm::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ACharm, _actorVfx) == 0x000258, "Member 'ACharm::_actorVfx' has a wrong offset!");

// Class DeadByDaylight.EvaluatorCondition
// 0x0018 (0x0048 - 0x0030)
class UEvaluatorCondition : public UObject
{
public:
	EConditionSubject                             _conditionSubject;                                 // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x17];                                      // 0x0031(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvaluatorCondition">();
	}
	static class UEvaluatorCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvaluatorCondition>();
	}
};
static_assert(alignof(UEvaluatorCondition) == 0x000008, "Wrong alignment on UEvaluatorCondition");
static_assert(sizeof(UEvaluatorCondition) == 0x000048, "Wrong size on UEvaluatorCondition");
static_assert(offsetof(UEvaluatorCondition, _conditionSubject) == 0x000030, "Member 'UEvaluatorCondition::_conditionSubject' has a wrong offset!");

// Class DeadByDaylight.BaseIndicatorWidget
// 0x0048 (0x0380 - 0x0338)
class UBaseIndicatorWidget : public UMobileBaseUserWidget
{
public:
	class UCanvasPanel*                           _safeZonePanel;                                    // 0x0338(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanelSlot*                       _canvasPanelSlot;                                  // 0x0340(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RadiusMultiplier;                                  // 0x0348(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           IndicatorPanel;                                    // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Indicator;                                         // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ArrowImage;                                        // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x18];                                     // 0x0368(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOutAnimationFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseIndicatorWidget">();
	}
	static class UBaseIndicatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseIndicatorWidget>();
	}
};
static_assert(alignof(UBaseIndicatorWidget) == 0x000008, "Wrong alignment on UBaseIndicatorWidget");
static_assert(sizeof(UBaseIndicatorWidget) == 0x000380, "Wrong size on UBaseIndicatorWidget");
static_assert(offsetof(UBaseIndicatorWidget, _safeZonePanel) == 0x000338, "Member 'UBaseIndicatorWidget::_safeZonePanel' has a wrong offset!");
static_assert(offsetof(UBaseIndicatorWidget, _canvasPanelSlot) == 0x000340, "Member 'UBaseIndicatorWidget::_canvasPanelSlot' has a wrong offset!");
static_assert(offsetof(UBaseIndicatorWidget, RadiusMultiplier) == 0x000348, "Member 'UBaseIndicatorWidget::RadiusMultiplier' has a wrong offset!");
static_assert(offsetof(UBaseIndicatorWidget, IndicatorPanel) == 0x000350, "Member 'UBaseIndicatorWidget::IndicatorPanel' has a wrong offset!");
static_assert(offsetof(UBaseIndicatorWidget, Indicator) == 0x000358, "Member 'UBaseIndicatorWidget::Indicator' has a wrong offset!");
static_assert(offsetof(UBaseIndicatorWidget, ArrowImage) == 0x000360, "Member 'UBaseIndicatorWidget::ArrowImage' has a wrong offset!");

// Class DeadByDaylight.GeneratorIndicatorWidget
// 0x0000 (0x0380 - 0x0380)
class UGeneratorIndicatorWidget final : public UBaseIndicatorWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorIndicatorWidget">();
	}
	static class UGeneratorIndicatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorIndicatorWidget>();
	}
};
static_assert(alignof(UGeneratorIndicatorWidget) == 0x000008, "Wrong alignment on UGeneratorIndicatorWidget");
static_assert(sizeof(UGeneratorIndicatorWidget) == 0x000380, "Wrong size on UGeneratorIndicatorWidget");

// Class DeadByDaylight.ActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy">();
	}
	static class UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy>();
	}
};
static_assert(alignof(UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy) == 0x000008, "Wrong alignment on UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy");
static_assert(sizeof(UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy) == 0x000038, "Wrong size on UActiveWhenApplicableAndActivationAndCooldownPerkIconStrategy");

// Class DeadByDaylight.PromoPackUtilities
// 0x0000 (0x0030 - 0x0030)
class UPromoPackUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PromoPackUtilities">();
	}
	static class UPromoPackUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPromoPackUtilities>();
	}
};
static_assert(alignof(UPromoPackUtilities) == 0x000008, "Wrong alignment on UPromoPackUtilities");
static_assert(sizeof(UPromoPackUtilities) == 0x000030, "Wrong size on UPromoPackUtilities");

// Class DeadByDaylight.AssetLibrary
// 0x0080 (0x00B0 - 0x0030)
class UAssetLibrary : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectLibrary*                         _objectLibrary;                                    // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x64];                                      // 0x0040(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondsDelayBetweenBatch;                          // 0x00A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetLibrary">();
	}
	static class UAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetLibrary>();
	}
};
static_assert(alignof(UAssetLibrary) == 0x000008, "Wrong alignment on UAssetLibrary");
static_assert(sizeof(UAssetLibrary) == 0x0000B0, "Wrong size on UAssetLibrary");
static_assert(offsetof(UAssetLibrary, _objectLibrary) == 0x000038, "Member 'UAssetLibrary::_objectLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibrary, SecondsDelayBetweenBatch) == 0x0000A4, "Member 'UAssetLibrary::SecondsDelayBetweenBatch' has a wrong offset!");

// Class DeadByDaylight.ItemsAssetLibrary
// 0x0070 (0x0120 - 0x00B0)
class UItemsAssetLibrary : public UAssetLibrary
{
public:
	uint8                                         Pad_B0[0x70];                                      // 0x00B0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemsAssetLibrary">();
	}
	static class UItemsAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemsAssetLibrary>();
	}
};
static_assert(alignof(UItemsAssetLibrary) == 0x000008, "Wrong alignment on UItemsAssetLibrary");
static_assert(sizeof(UItemsAssetLibrary) == 0x000120, "Wrong size on UItemsAssetLibrary");

// Class DeadByDaylight.CharacterInfoScreen
// 0x0018 (0x0138 - 0x0120)
class UCharacterInfoScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBackButtonClick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterInfoScreen">();
	}
	static class UCharacterInfoScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterInfoScreen>();
	}
};
static_assert(alignof(UCharacterInfoScreen) == 0x000008, "Wrong alignment on UCharacterInfoScreen");
static_assert(sizeof(UCharacterInfoScreen) == 0x000138, "Wrong size on UCharacterInfoScreen");

// Class DeadByDaylight.UMGTooltipContentPlayerLevelWidget
// 0x0030 (0x0368 - 0x0338)
class UUMGTooltipContentPlayerLevelWidget final : public UMobileBaseUserWidget
{
public:
	class FText                                   PlayerLevelText;                                   // 0x0338(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UUMGLevelBannerWidget*                  LevelBanner;                                       // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         LevelExperienceRichText;                           // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ExperienceToNextLevelText;                         // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetInfo(const int32 playerLevel, const int32 playerPrestige, const int32 currentExperience, const int32 nextLevelExperience);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTooltipContentPlayerLevelWidget">();
	}
	static class UUMGTooltipContentPlayerLevelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTooltipContentPlayerLevelWidget>();
	}
};
static_assert(alignof(UUMGTooltipContentPlayerLevelWidget) == 0x000008, "Wrong alignment on UUMGTooltipContentPlayerLevelWidget");
static_assert(sizeof(UUMGTooltipContentPlayerLevelWidget) == 0x000368, "Wrong size on UUMGTooltipContentPlayerLevelWidget");
static_assert(offsetof(UUMGTooltipContentPlayerLevelWidget, PlayerLevelText) == 0x000338, "Member 'UUMGTooltipContentPlayerLevelWidget::PlayerLevelText' has a wrong offset!");
static_assert(offsetof(UUMGTooltipContentPlayerLevelWidget, LevelBanner) == 0x000350, "Member 'UUMGTooltipContentPlayerLevelWidget::LevelBanner' has a wrong offset!");
static_assert(offsetof(UUMGTooltipContentPlayerLevelWidget, LevelExperienceRichText) == 0x000358, "Member 'UUMGTooltipContentPlayerLevelWidget::LevelExperienceRichText' has a wrong offset!");
static_assert(offsetof(UUMGTooltipContentPlayerLevelWidget, ExperienceToNextLevelText) == 0x000360, "Member 'UUMGTooltipContentPlayerLevelWidget::ExperienceToNextLevelText' has a wrong offset!");

// Class DeadByDaylight.RecentGameEventTracker
// 0x00A0 (0x00D8 - 0x0038)
class URecentGameEventTracker final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xA0];                                      // 0x0038(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecentGameEventTracker">();
	}
	static class URecentGameEventTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecentGameEventTracker>();
	}
};
static_assert(alignof(URecentGameEventTracker) == 0x000008, "Wrong alignment on URecentGameEventTracker");
static_assert(sizeof(URecentGameEventTracker) == 0x0000D8, "Wrong size on URecentGameEventTracker");

// Class DeadByDaylight.QuestEventEvaluatorBase
// 0x0088 (0x00B8 - 0x0030)
class UQuestEventEvaluatorBase : public UObject
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _dbdPlayer;                                        // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0xA];                                       // 0x0058(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	EConditionNeedsType                           _conditionNeedsType;                               // 0x0062(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_63[0x5];                                       // 0x0063(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UEvaluatorCondition>> _evaluatorConditionsClass;                        // 0x0068(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UEvaluatorCondition*>            _evaluatorConditions;                              // 0x0078(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x30];                                      // 0x0088(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestEventEvaluatorBase">();
	}
	static class UQuestEventEvaluatorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestEventEvaluatorBase>();
	}
};
static_assert(alignof(UQuestEventEvaluatorBase) == 0x000008, "Wrong alignment on UQuestEventEvaluatorBase");
static_assert(sizeof(UQuestEventEvaluatorBase) == 0x0000B8, "Wrong size on UQuestEventEvaluatorBase");
static_assert(offsetof(UQuestEventEvaluatorBase, _dbdPlayer) == 0x000050, "Member 'UQuestEventEvaluatorBase::_dbdPlayer' has a wrong offset!");
static_assert(offsetof(UQuestEventEvaluatorBase, _conditionNeedsType) == 0x000062, "Member 'UQuestEventEvaluatorBase::_conditionNeedsType' has a wrong offset!");
static_assert(offsetof(UQuestEventEvaluatorBase, _evaluatorConditionsClass) == 0x000068, "Member 'UQuestEventEvaluatorBase::_evaluatorConditionsClass' has a wrong offset!");
static_assert(offsetof(UQuestEventEvaluatorBase, _evaluatorConditions) == 0x000078, "Member 'UQuestEventEvaluatorBase::_evaluatorConditions' has a wrong offset!");

// Class DeadByDaylight.ArmIKSensorComponent
// 0x0080 (0x0138 - 0x00B8)
class UArmIKSensorComponent : public UActorComponent
{
public:
	class USkeletalMeshComponent*                 _mesh;                                             // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EArm, struct FArmIKSensorDatum>          _arms;                                             // 0x00C0(0x0050)(Edit, EditFixedSize, Protected, NativeAccessSpecifierProtected)
	float                                         _capsuleRadius;                                    // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _capsuleHalfHeight;                                // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _traceLength;                                      // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       _owningCamera;                                     // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmIKSensorComponent">();
	}
	static class UArmIKSensorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmIKSensorComponent>();
	}
};
static_assert(alignof(UArmIKSensorComponent) == 0x000008, "Wrong alignment on UArmIKSensorComponent");
static_assert(sizeof(UArmIKSensorComponent) == 0x000138, "Wrong size on UArmIKSensorComponent");
static_assert(offsetof(UArmIKSensorComponent, _mesh) == 0x0000B8, "Member 'UArmIKSensorComponent::_mesh' has a wrong offset!");
static_assert(offsetof(UArmIKSensorComponent, _arms) == 0x0000C0, "Member 'UArmIKSensorComponent::_arms' has a wrong offset!");
static_assert(offsetof(UArmIKSensorComponent, _capsuleRadius) == 0x000110, "Member 'UArmIKSensorComponent::_capsuleRadius' has a wrong offset!");
static_assert(offsetof(UArmIKSensorComponent, _capsuleHalfHeight) == 0x000114, "Member 'UArmIKSensorComponent::_capsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UArmIKSensorComponent, _traceLength) == 0x000118, "Member 'UArmIKSensorComponent::_traceLength' has a wrong offset!");
static_assert(offsetof(UArmIKSensorComponent, _owningCamera) == 0x000120, "Member 'UArmIKSensorComponent::_owningCamera' has a wrong offset!");

// Class DeadByDaylight.CustomizedAudioComponent
// 0x0160 (0x0218 - 0x00B8)
class UCustomizedAudioComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(EAudioCustomizationCategory category, const class FString& switchState)> OnCustomizedAudioSwitchStateChanged; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FName& outfitAudioStateCollection)> OnOutfitCustomizedAudioStateCollectionChanged; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0xB0];                                      // 0x00D8(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AudioCharacterNameDefaultSwitchState;              // 0x0188(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterSubNameDefaultSwitchState;           // 0x0198(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterHeadDefaultSwitchState;              // 0x01A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterClothesDefaultSwitchState;           // 0x01B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterShoesDefaultSwitchState;             // 0x01C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterWeaponDefaultSwitchState;            // 0x01D8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterAmbianceDefaultSwitchState;          // 0x01E8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioCharacterStateDefaultSwitchState;             // 0x01F8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AudioCharacterDefaultOutfitCollectionState;        // 0x0208(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetAudioSwitchState(EAudioCustomizationCategory audioCustomizationCategory) const;
	class FName GetOutfitCustomizedAudioCollectionState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizedAudioComponent">();
	}
	static class UCustomizedAudioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizedAudioComponent>();
	}
};
static_assert(alignof(UCustomizedAudioComponent) == 0x000008, "Wrong alignment on UCustomizedAudioComponent");
static_assert(sizeof(UCustomizedAudioComponent) == 0x000218, "Wrong size on UCustomizedAudioComponent");
static_assert(offsetof(UCustomizedAudioComponent, OnCustomizedAudioSwitchStateChanged) == 0x0000B8, "Member 'UCustomizedAudioComponent::OnCustomizedAudioSwitchStateChanged' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, OnOutfitCustomizedAudioStateCollectionChanged) == 0x0000C8, "Member 'UCustomizedAudioComponent::OnOutfitCustomizedAudioStateCollectionChanged' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterNameDefaultSwitchState) == 0x000188, "Member 'UCustomizedAudioComponent::AudioCharacterNameDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterSubNameDefaultSwitchState) == 0x000198, "Member 'UCustomizedAudioComponent::AudioCharacterSubNameDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterHeadDefaultSwitchState) == 0x0001A8, "Member 'UCustomizedAudioComponent::AudioCharacterHeadDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterClothesDefaultSwitchState) == 0x0001B8, "Member 'UCustomizedAudioComponent::AudioCharacterClothesDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterShoesDefaultSwitchState) == 0x0001C8, "Member 'UCustomizedAudioComponent::AudioCharacterShoesDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterWeaponDefaultSwitchState) == 0x0001D8, "Member 'UCustomizedAudioComponent::AudioCharacterWeaponDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterAmbianceDefaultSwitchState) == 0x0001E8, "Member 'UCustomizedAudioComponent::AudioCharacterAmbianceDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterStateDefaultSwitchState) == 0x0001F8, "Member 'UCustomizedAudioComponent::AudioCharacterStateDefaultSwitchState' has a wrong offset!");
static_assert(offsetof(UCustomizedAudioComponent, AudioCharacterDefaultOutfitCollectionState) == 0x000208, "Member 'UCustomizedAudioComponent::AudioCharacterDefaultOutfitCollectionState' has a wrong offset!");

// Class DeadByDaylight.BaseTooltipWidget
// 0x0038 (0x0370 - 0x0338)
class UBaseTooltipWidget : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             TitleLabel;                                        // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           TooltipContainer;                                  // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGHtmlRichText*                       DescriptionLabel;                                  // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                CloseButton;                                       // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x10];                                     // 0x0358(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          TooltipOpeningSound;                               // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnQuitButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseTooltipWidget">();
	}
	static class UBaseTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseTooltipWidget>();
	}
};
static_assert(alignof(UBaseTooltipWidget) == 0x000008, "Wrong alignment on UBaseTooltipWidget");
static_assert(sizeof(UBaseTooltipWidget) == 0x000370, "Wrong size on UBaseTooltipWidget");
static_assert(offsetof(UBaseTooltipWidget, TitleLabel) == 0x000338, "Member 'UBaseTooltipWidget::TitleLabel' has a wrong offset!");
static_assert(offsetof(UBaseTooltipWidget, TooltipContainer) == 0x000340, "Member 'UBaseTooltipWidget::TooltipContainer' has a wrong offset!");
static_assert(offsetof(UBaseTooltipWidget, DescriptionLabel) == 0x000348, "Member 'UBaseTooltipWidget::DescriptionLabel' has a wrong offset!");
static_assert(offsetof(UBaseTooltipWidget, CloseButton) == 0x000350, "Member 'UBaseTooltipWidget::CloseButton' has a wrong offset!");
static_assert(offsetof(UBaseTooltipWidget, TooltipOpeningSound) == 0x000368, "Member 'UBaseTooltipWidget::TooltipOpeningSound' has a wrong offset!");

// Class DeadByDaylight.TeachableTooltipWidget
// 0x0020 (0x0390 - 0x0370)
class UTeachableTooltipWidget final : public UBaseTooltipWidget
{
public:
	class UTextBlock*                             SubTitleLabel;                                     // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HeaderSmoke;                                       // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGHtmlRichText*                       EffectText;                                        // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGHtmlRichText*                       AvailabilityText;                                  // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeachableTooltipWidget">();
	}
	static class UTeachableTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeachableTooltipWidget>();
	}
};
static_assert(alignof(UTeachableTooltipWidget) == 0x000008, "Wrong alignment on UTeachableTooltipWidget");
static_assert(sizeof(UTeachableTooltipWidget) == 0x000390, "Wrong size on UTeachableTooltipWidget");
static_assert(offsetof(UTeachableTooltipWidget, SubTitleLabel) == 0x000370, "Member 'UTeachableTooltipWidget::SubTitleLabel' has a wrong offset!");
static_assert(offsetof(UTeachableTooltipWidget, HeaderSmoke) == 0x000378, "Member 'UTeachableTooltipWidget::HeaderSmoke' has a wrong offset!");
static_assert(offsetof(UTeachableTooltipWidget, EffectText) == 0x000380, "Member 'UTeachableTooltipWidget::EffectText' has a wrong offset!");
static_assert(offsetof(UTeachableTooltipWidget, AvailabilityText) == 0x000388, "Member 'UTeachableTooltipWidget::AvailabilityText' has a wrong offset!");

// Class DeadByDaylight.SpecialBehaviourIterativeWeightAdjustmentStrategy
// 0x0000 (0x0030 - 0x0030)
class USpecialBehaviourIterativeWeightAdjustmentStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialBehaviourIterativeWeightAdjustmentStrategy">();
	}
	static class USpecialBehaviourIterativeWeightAdjustmentStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialBehaviourIterativeWeightAdjustmentStrategy>();
	}
};
static_assert(alignof(USpecialBehaviourIterativeWeightAdjustmentStrategy) == 0x000008, "Wrong alignment on USpecialBehaviourIterativeWeightAdjustmentStrategy");
static_assert(sizeof(USpecialBehaviourIterativeWeightAdjustmentStrategy) == 0x000030, "Wrong size on USpecialBehaviourIterativeWeightAdjustmentStrategy");

// Class DeadByDaylight.BaseSky
// 0x0168 (0x0398 - 0x0230)
class ABaseSky final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          AdjustCullDistance;                                // 0x0238(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IBLContributionMultiplier;                         // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ProbesTintColor;                                   // 0x0240(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProbesSaturationValue;                             // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBHVRPerDetailModeFloat                ASMDepthBias;                                      // 0x0258(0x00A0)(Edit, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	struct FBHVRPerDetailModeFloat                ASMDepthAttenuation;                               // 0x02F8(0x00A0)(Edit, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)

public:
	void CopyComponentsSettingsFromSource(class UStaticMeshComponent* moonMesh, class UDirectionalLightComponent* shadowLight, class UDirectionalLightComponent* godRayLight, class USkyLightComponent* skylight, class UExponentialHeightFogComponent* heightFog, class UPostProcessComponent* postProcess, class UClass* sourceBaseSkyClass);
	class UPostProcessComponent* GetPostprocessComponent();
	void OnAlphaChanged(float newAlpha, class AActor* other);
	void OnFadeBegin(class AActor* other);
	void OnFadeEnd(class AActor* other);
	void SetCullDistance(float newCullDistance);
	void SetProbesTint(const struct FLinearColor& inColor, float inSaturation);
	void ToggleDreamworldLighting(bool toggleOn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseSky">();
	}
	static class ABaseSky* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseSky>();
	}
};
static_assert(alignof(ABaseSky) == 0x000008, "Wrong alignment on ABaseSky");
static_assert(sizeof(ABaseSky) == 0x000398, "Wrong size on ABaseSky");
static_assert(offsetof(ABaseSky, AdjustCullDistance) == 0x000238, "Member 'ABaseSky::AdjustCullDistance' has a wrong offset!");
static_assert(offsetof(ABaseSky, IBLContributionMultiplier) == 0x00023C, "Member 'ABaseSky::IBLContributionMultiplier' has a wrong offset!");
static_assert(offsetof(ABaseSky, ProbesTintColor) == 0x000240, "Member 'ABaseSky::ProbesTintColor' has a wrong offset!");
static_assert(offsetof(ABaseSky, ProbesSaturationValue) == 0x000250, "Member 'ABaseSky::ProbesSaturationValue' has a wrong offset!");
static_assert(offsetof(ABaseSky, ASMDepthBias) == 0x000258, "Member 'ABaseSky::ASMDepthBias' has a wrong offset!");
static_assert(offsetof(ABaseSky, ASMDepthAttenuation) == 0x0002F8, "Member 'ABaseSky::ASMDepthAttenuation' has a wrong offset!");

// Class DeadByDaylight.AbstractGameFlowHandler
// 0x0000 (0x0038 - 0x0038)
class UAbstractGameFlowHandler : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbstractGameFlowHandler">();
	}
	static class UAbstractGameFlowHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbstractGameFlowHandler>();
	}
};
static_assert(alignof(UAbstractGameFlowHandler) == 0x000008, "Wrong alignment on UAbstractGameFlowHandler");
static_assert(sizeof(UAbstractGameFlowHandler) == 0x000038, "Wrong size on UAbstractGameFlowHandler");

// Class DeadByDaylight.DefaultOutlineUpdateStrategy
// 0x0020 (0x00E0 - 0x00C0)
class UDefaultOutlineUpdateStrategy : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _revealedColorToSurvivor;                          // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _revealedColorToKiller;                            // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultOutlineUpdateStrategy">();
	}
	static class UDefaultOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UDefaultOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UDefaultOutlineUpdateStrategy");
static_assert(sizeof(UDefaultOutlineUpdateStrategy) == 0x0000E0, "Wrong size on UDefaultOutlineUpdateStrategy");
static_assert(offsetof(UDefaultOutlineUpdateStrategy, _revealedColorToSurvivor) == 0x0000C0, "Member 'UDefaultOutlineUpdateStrategy::_revealedColorToSurvivor' has a wrong offset!");
static_assert(offsetof(UDefaultOutlineUpdateStrategy, _revealedColorToKiller) == 0x0000D0, "Member 'UDefaultOutlineUpdateStrategy::_revealedColorToKiller' has a wrong offset!");

// Class DeadByDaylight.CharacterCollisionsUtilities
// 0x0000 (0x0030 - 0x0030)
class UCharacterCollisionsUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCollisionsUtilities">();
	}
	static class UCharacterCollisionsUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCollisionsUtilities>();
	}
};
static_assert(alignof(UCharacterCollisionsUtilities) == 0x000008, "Wrong alignment on UCharacterCollisionsUtilities");
static_assert(sizeof(UCharacterCollisionsUtilities) == 0x000030, "Wrong size on UCharacterCollisionsUtilities");

// Class DeadByDaylight.GeneratorDrivenActor
// 0x0028 (0x0258 - 0x0230)
class AGeneratorDrivenActor : public AActor
{
public:
	float                                         LightPriority;                                     // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EComponentMobility                            TargetMobileLightMobility;                         // 0x0234(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_235[0x3];                                      // 0x0235(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  _activated;                                        // 0x0238(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AGenerator*>                     _generators;                                       // 0x0248(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Authority_CheckActivation(bool isAutoCompleted, int32 generatorId);
	void Authority_CheckGeneratorRepairedBySurvivor(class ADBDPlayer* repairingSurvivor, int32 generatorId);
	struct FRandomStream GetSharedTileRandomizer();
	void Multicast_ActivationChecked(bool activated, bool isAutoCompleted, int32 generatorId);
	void Multicast_GeneratorRepairedBySurvivor(class ADBDPlayer* repairingSurvivor, int32 generatorId);
	void OnActivateGeneratorDrivenActor(bool isAutoCompleted, int32 generatorId);
	void OnGeneratorRepairedBySurvivor(class ADBDPlayer* repairingSurvivor, int32 generatorId);
	void OnGeneratorRepairedBySurvivorEvent0(class ADBDPlayer* repairingSurvivor);
	void OnGeneratorRepairedBySurvivorEvent1(class ADBDPlayer* repairingSurvivor);
	void OnGeneratorRepairedBySurvivorEvent2(class ADBDPlayer* repairingSurvivor);
	void OnGeneratorRepairedBySurvivorEvent3(class ADBDPlayer* repairingSurvivor);
	void OnGeneratorRepairedBySurvivorEvent4(class ADBDPlayer* repairingSurvivor);
	void OnGeneratorRepairedBySurvivorEvent5(class ADBDPlayer* repairingSurvivor);
	void OnGeneratorRepairedBySurvivorEvent6(class ADBDPlayer* repairingSurvivor);
	void OnGeneratorRepairedEvent0(bool isAutoCompleted);
	void OnGeneratorRepairedEvent1(bool isAutoCompleted);
	void OnGeneratorRepairedEvent2(bool isAutoCompleted);
	void OnGeneratorRepairedEvent3(bool isAutoCompleted);
	void OnGeneratorRepairedEvent4(bool isAutoCompleted);
	void OnGeneratorRepairedEvent5(bool isAutoCompleted);
	void OnGeneratorRepairedEvent6(bool isAutoCompleted);
	void OnInitGeneratorDrivenActor(class AGenerator* generator, int32 generatorId);
	void SetSpawnedObject(class AGenerator* generator, int32 generatorId);

	bool IsActivated(int32 generatorId) const;
	bool IsValidGeneratorId(int32 generatorId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorDrivenActor">();
	}
	static class AGeneratorDrivenActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGeneratorDrivenActor>();
	}
};
static_assert(alignof(AGeneratorDrivenActor) == 0x000008, "Wrong alignment on AGeneratorDrivenActor");
static_assert(sizeof(AGeneratorDrivenActor) == 0x000258, "Wrong size on AGeneratorDrivenActor");
static_assert(offsetof(AGeneratorDrivenActor, LightPriority) == 0x000230, "Member 'AGeneratorDrivenActor::LightPriority' has a wrong offset!");
static_assert(offsetof(AGeneratorDrivenActor, TargetMobileLightMobility) == 0x000234, "Member 'AGeneratorDrivenActor::TargetMobileLightMobility' has a wrong offset!");
static_assert(offsetof(AGeneratorDrivenActor, _activated) == 0x000238, "Member 'AGeneratorDrivenActor::_activated' has a wrong offset!");
static_assert(offsetof(AGeneratorDrivenActor, _generators) == 0x000248, "Member 'AGeneratorDrivenActor::_generators' has a wrong offset!");

// Class DeadByDaylight.CrowBomb
// 0x0098 (0x02F0 - 0x0258)
class ACrowBomb final : public AGeneratorDrivenActor
{
public:
	float                                         _innerRadius;                                      // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _outerRadius;                                      // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxTakeoffDelay;                                  // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _numCrows;                                         // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _crowCenterDistance;                               // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _eliminationSamples;                               // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _eliminationStddev;                                // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _meshComponentClass;                               // 0x0278(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UWorldRunawayMeshComponent*>     _crows;                                            // 0x02A8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0x18];                                     // 0x02B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _root;                                             // 0x02D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _traceStart;                                       // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _traceEnd;                                         // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _landed;                                           // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TriggerLand();
	void TriggerTakeOff(const struct FVector& triggerLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrowBomb">();
	}
	static class ACrowBomb* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACrowBomb>();
	}
};
static_assert(alignof(ACrowBomb) == 0x000008, "Wrong alignment on ACrowBomb");
static_assert(sizeof(ACrowBomb) == 0x0002F0, "Wrong size on ACrowBomb");
static_assert(offsetof(ACrowBomb, _innerRadius) == 0x000258, "Member 'ACrowBomb::_innerRadius' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _outerRadius) == 0x00025C, "Member 'ACrowBomb::_outerRadius' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _maxTakeoffDelay) == 0x000260, "Member 'ACrowBomb::_maxTakeoffDelay' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _numCrows) == 0x000264, "Member 'ACrowBomb::_numCrows' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _crowCenterDistance) == 0x000268, "Member 'ACrowBomb::_crowCenterDistance' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _eliminationSamples) == 0x00026C, "Member 'ACrowBomb::_eliminationSamples' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _eliminationStddev) == 0x000270, "Member 'ACrowBomb::_eliminationStddev' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _meshComponentClass) == 0x000278, "Member 'ACrowBomb::_meshComponentClass' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _crows) == 0x0002A8, "Member 'ACrowBomb::_crows' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _root) == 0x0002D0, "Member 'ACrowBomb::_root' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _traceStart) == 0x0002D8, "Member 'ACrowBomb::_traceStart' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _traceEnd) == 0x0002E0, "Member 'ACrowBomb::_traceEnd' has a wrong offset!");
static_assert(offsetof(ACrowBomb, _landed) == 0x0002E8, "Member 'ACrowBomb::_landed' has a wrong offset!");

// Class DeadByDaylight.Collectable
// 0x0188 (0x04B0 - 0x0328)
class ACollectable : public AInteractable
{
public:
	uint8                                         Pad_328[0x30];                                     // 0x0328(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DisplayUsePercent;                                 // 0x0358(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAtlantaItemProgressionBarEnum                ProgressBar;                                       // 0x0359(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OverrideItemIndex;                                 // 0x035A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35B[0x1];                                      // 0x035B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OverridenItemIndex;                                // 0x035C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StrafeOnUse;                                       // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleWhenEquipped;                               // 0x0361(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopRunningOnUse;                                  // 0x0362(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemHandPosition                             HandPosition;                                      // 0x0363(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableArmOverrideDuringInteractions;              // 0x0364(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasUseInteraction;                                 // 0x0365(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollectableCategory                          Category;                                          // 0x0366(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_367[0x1];                                      // 0x0367(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemID;                                            // 0x0368(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FromPlayerSpawn;                                   // 0x0374(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_375[0x3];                                      // 0x0375(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemModifier*                          BaseItemModifier;                                  // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemModifier*                          ItemModifier1;                                     // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemModifier*                          ItemModifier2;                                     // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldRegisterToOnSurvivorAdded;                   // 0x0390(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x67];                                     // 0x0391(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          BeingCollected;                                    // 0x03F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BeingDropped;                                      // 0x03F9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _beingConsumedByEntity;                            // 0x03FA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3FB[0x5];                                      // 0x03FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractor*                            _itemInteractor;                                   // 0x0400(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDSkeletalMeshComponentBudgeted*      _mesh;                                             // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInputInteractionType                         _displayedInputType;                               // 0x0410(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isKeyPromptForceDisabled;                         // 0x0411(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_412[0x6];                                      // 0x0412(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTagContainerComponent*         _objectState;                                      // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBoundToFirstCollector;                          // 0x0420(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_421[0x1F];                                     // 0x0421(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _placementOrigin;                                  // 0x0440(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_448[0x10];                                     // 0x0448(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _collector;                                        // 0x0458(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _firstCollector;                                   // 0x0460(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollectableState                             _state;                                            // 0x0468(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_469[0x7];                                      // 0x0469(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UItemAddon*>                     _itemAddons;                                       // 0x0470(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UItemModifier*>                  _itemModifiers;                                    // 0x0480(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         _itemCount;                                        // 0x0490(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAttachToSocketNameEnum                       _attachToSocketName;                               // 0x0494(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EInventoryType                                _collectInInventoryType;                           // 0x0495(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_496[0x2];                                      // 0x0496(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _stateTagForCollector;                             // 0x0498(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELoadoutItemType                              _itemType;                                         // 0x04A4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _discardWhenConsumed;                              // 0x04A5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _disableAttachmentReplication;                     // 0x04A6(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A7[0x1];                                      // 0x04A7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isInUse;                                          // 0x04A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _aimOnUse;                                         // 0x04A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4AA[0x6];                                      // 0x04AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Authority_AddItemAddon(class UItemAddon* addon);
	void Authority_Discard();
	void Authority_OnConsumed(bool forceDiscard);
	void Authority_RemoveItemAddon(class UItemAddon* addon);
	void Authority_Use();
	void Authority_UseReleased();
	void BP_OnSurvivorAdded(class ACamperPlayer* survivor);
	void CallOnCollectorSetBP(TDelegate<void(class ADBDPlayer* player)> callback);
	void DebugPrintStats();
	TArray<class UItemAddon*> GetItemAddons();
	void Local_Dropped_Location(class ADBDPlayer* droppedBy, const struct FVector& location, const struct FRotator& rotation);
	void Multicast_Collected(class ADBDPlayer* collector);
	void Multicast_Dropped(class ADBDPlayer* droppedBy, const struct FVector& location, const struct FRotator& rotation);
	void Multicast_RemoveAllAddons();
	void Multicast_RemoveItemAddon(class UItemAddon* addon);
	void Multicast_Use();
	void Multicast_UseReleased(class ADBDPlayer* collector);
	void OnActivateDissolveItem();
	void OnAddonsAdded(const TArray<class UItemAddon*>& addons);
	void OnAddonsRemoved(const TArray<class UItemAddon*>& addons);
	void OnCollectorEndPlay(class AActor* actor, EEndPlayReason endPlayReason);
	void OnCollectorSet(class ADBDPlayer* collector);
	void OnCustomizationChanged();
	void OnDropped(class ADBDPlayer* droppingPlayer);
	void OnPostItemAddonsCreation(class ADBDPlayer* player);
	void OnRep_Collector(class ADBDPlayer* oldCollector);
	void OnRep_State();
	void OnUse();
	void OnUseReleased(class ADBDPlayer* collector);
	void Server_Discard();
	void SetCount(int32 count);
	void SetDisplayedInputType(const EInputInteractionType displayedInputType);
	void SetIsKeyPromptForceDisabled(const bool isKeyPromptForceDisabled);
	void SetItemInteractor(class UInteractor* interactor);
	void SetVisibilityEvent(bool visibility);

	bool CanBeCollected(const class ADBDPlayer* collector) const;
	bool CanBeDropped(const class ADBDPlayer* dropper) const;
	bool CanUse(const class ADBDPlayer* player) const;
	class ADBDPlayer* GetCollector() const;
	int32 GetCount() const;
	EInputInteractionType GetDisplayedInputType() const;
	class FString GetIconFilePath() const;
	uint8 GetItemIconIndex() const;
	class UInteractor* GetItemInteractor() const;
	float GetModifierMax(const struct FGameplayTag& modifierType, float defaultValue) const;
	float GetModifierSum(const struct FGameplayTag& modifierType, float defaultValue) const;
	float GetUsePercentLeft() const;
	bool HasGameplayModifierFlag(const struct FGameplayTag& modifierFlag) const;
	bool IsCollected() const;
	bool IsCountDisplayForced() const;
	bool IsEquipped() const;
	bool IsInSearchable() const;
	bool IsKeyPromptForceDisabled() const;
	bool IsLocallyControlled() const;
	bool IsOnGround() const;
	bool IsPickable() const;
	bool IsRechargeable() const;
	bool IsStored() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Collectable">();
	}
	static class ACollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollectable>();
	}
};
static_assert(alignof(ACollectable) == 0x000008, "Wrong alignment on ACollectable");
static_assert(sizeof(ACollectable) == 0x0004B0, "Wrong size on ACollectable");
static_assert(offsetof(ACollectable, DisplayUsePercent) == 0x000358, "Member 'ACollectable::DisplayUsePercent' has a wrong offset!");
static_assert(offsetof(ACollectable, ProgressBar) == 0x000359, "Member 'ACollectable::ProgressBar' has a wrong offset!");
static_assert(offsetof(ACollectable, OverrideItemIndex) == 0x00035A, "Member 'ACollectable::OverrideItemIndex' has a wrong offset!");
static_assert(offsetof(ACollectable, OverridenItemIndex) == 0x00035C, "Member 'ACollectable::OverridenItemIndex' has a wrong offset!");
static_assert(offsetof(ACollectable, StrafeOnUse) == 0x000360, "Member 'ACollectable::StrafeOnUse' has a wrong offset!");
static_assert(offsetof(ACollectable, VisibleWhenEquipped) == 0x000361, "Member 'ACollectable::VisibleWhenEquipped' has a wrong offset!");
static_assert(offsetof(ACollectable, StopRunningOnUse) == 0x000362, "Member 'ACollectable::StopRunningOnUse' has a wrong offset!");
static_assert(offsetof(ACollectable, HandPosition) == 0x000363, "Member 'ACollectable::HandPosition' has a wrong offset!");
static_assert(offsetof(ACollectable, DisableArmOverrideDuringInteractions) == 0x000364, "Member 'ACollectable::DisableArmOverrideDuringInteractions' has a wrong offset!");
static_assert(offsetof(ACollectable, HasUseInteraction) == 0x000365, "Member 'ACollectable::HasUseInteraction' has a wrong offset!");
static_assert(offsetof(ACollectable, Category) == 0x000366, "Member 'ACollectable::Category' has a wrong offset!");
static_assert(offsetof(ACollectable, ItemID) == 0x000368, "Member 'ACollectable::ItemID' has a wrong offset!");
static_assert(offsetof(ACollectable, FromPlayerSpawn) == 0x000374, "Member 'ACollectable::FromPlayerSpawn' has a wrong offset!");
static_assert(offsetof(ACollectable, BaseItemModifier) == 0x000378, "Member 'ACollectable::BaseItemModifier' has a wrong offset!");
static_assert(offsetof(ACollectable, ItemModifier1) == 0x000380, "Member 'ACollectable::ItemModifier1' has a wrong offset!");
static_assert(offsetof(ACollectable, ItemModifier2) == 0x000388, "Member 'ACollectable::ItemModifier2' has a wrong offset!");
static_assert(offsetof(ACollectable, ShouldRegisterToOnSurvivorAdded) == 0x000390, "Member 'ACollectable::ShouldRegisterToOnSurvivorAdded' has a wrong offset!");
static_assert(offsetof(ACollectable, BeingCollected) == 0x0003F8, "Member 'ACollectable::BeingCollected' has a wrong offset!");
static_assert(offsetof(ACollectable, BeingDropped) == 0x0003F9, "Member 'ACollectable::BeingDropped' has a wrong offset!");
static_assert(offsetof(ACollectable, _beingConsumedByEntity) == 0x0003FA, "Member 'ACollectable::_beingConsumedByEntity' has a wrong offset!");
static_assert(offsetof(ACollectable, _itemInteractor) == 0x000400, "Member 'ACollectable::_itemInteractor' has a wrong offset!");
static_assert(offsetof(ACollectable, _mesh) == 0x000408, "Member 'ACollectable::_mesh' has a wrong offset!");
static_assert(offsetof(ACollectable, _displayedInputType) == 0x000410, "Member 'ACollectable::_displayedInputType' has a wrong offset!");
static_assert(offsetof(ACollectable, _isKeyPromptForceDisabled) == 0x000411, "Member 'ACollectable::_isKeyPromptForceDisabled' has a wrong offset!");
static_assert(offsetof(ACollectable, _objectState) == 0x000418, "Member 'ACollectable::_objectState' has a wrong offset!");
static_assert(offsetof(ACollectable, _isBoundToFirstCollector) == 0x000420, "Member 'ACollectable::_isBoundToFirstCollector' has a wrong offset!");
static_assert(offsetof(ACollectable, _placementOrigin) == 0x000440, "Member 'ACollectable::_placementOrigin' has a wrong offset!");
static_assert(offsetof(ACollectable, _collector) == 0x000458, "Member 'ACollectable::_collector' has a wrong offset!");
static_assert(offsetof(ACollectable, _firstCollector) == 0x000460, "Member 'ACollectable::_firstCollector' has a wrong offset!");
static_assert(offsetof(ACollectable, _state) == 0x000468, "Member 'ACollectable::_state' has a wrong offset!");
static_assert(offsetof(ACollectable, _itemAddons) == 0x000470, "Member 'ACollectable::_itemAddons' has a wrong offset!");
static_assert(offsetof(ACollectable, _itemModifiers) == 0x000480, "Member 'ACollectable::_itemModifiers' has a wrong offset!");
static_assert(offsetof(ACollectable, _itemCount) == 0x000490, "Member 'ACollectable::_itemCount' has a wrong offset!");
static_assert(offsetof(ACollectable, _attachToSocketName) == 0x000494, "Member 'ACollectable::_attachToSocketName' has a wrong offset!");
static_assert(offsetof(ACollectable, _collectInInventoryType) == 0x000495, "Member 'ACollectable::_collectInInventoryType' has a wrong offset!");
static_assert(offsetof(ACollectable, _stateTagForCollector) == 0x000498, "Member 'ACollectable::_stateTagForCollector' has a wrong offset!");
static_assert(offsetof(ACollectable, _itemType) == 0x0004A4, "Member 'ACollectable::_itemType' has a wrong offset!");
static_assert(offsetof(ACollectable, _discardWhenConsumed) == 0x0004A5, "Member 'ACollectable::_discardWhenConsumed' has a wrong offset!");
static_assert(offsetof(ACollectable, _disableAttachmentReplication) == 0x0004A6, "Member 'ACollectable::_disableAttachmentReplication' has a wrong offset!");
static_assert(offsetof(ACollectable, _isInUse) == 0x0004A8, "Member 'ACollectable::_isInUse' has a wrong offset!");
static_assert(offsetof(ACollectable, _aimOnUse) == 0x0004A9, "Member 'ACollectable::_aimOnUse' has a wrong offset!");

// Class DeadByDaylight.AbstractAnalyticsManager
// 0x0000 (0x0038 - 0x0038)
class UAbstractAnalyticsManager : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbstractAnalyticsManager">();
	}
	static class UAbstractAnalyticsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbstractAnalyticsManager>();
	}
};
static_assert(alignof(UAbstractAnalyticsManager) == 0x000008, "Wrong alignment on UAbstractAnalyticsManager");
static_assert(sizeof(UAbstractAnalyticsManager) == 0x000038, "Wrong size on UAbstractAnalyticsManager");

// Class DeadByDaylight.UMGAtlantaNavigationScreen
// 0x0060 (0x0398 - 0x0338)
class UUMGAtlantaNavigationScreen final : public UMobileBaseUserWidget
{
public:
	class UUMGBankAndPlayerInfoWidget*            BankAndPlayerInfoWidget;                           // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TextButtonStart;                                   // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              PlayModeSelectionVisibility;                       // 0x0348(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              CharacterInfoVisibility;                           // 0x0349(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              BackButtonVisibility;                              // 0x034A(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              MenuButtonsVisibility;                             // 0x034B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              ButtonRoleVisibility;                              // 0x034C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34D[0x3];                                      // 0x034D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UButton*                                ButtonRole;                                        // 0x0350(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        BottomRightWidgetSwitcher;                         // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGPartySlotsWidget*                   PartyPlayerSlots;                                  // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBaseCountdownWidget*                PartyCountdownLarge;                               // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPartyMemberUIData>             _partyMembers;                                     // 0x0370(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x18];                                     // 0x0380(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ButtonClickEvent(ENavigationScreenButton buttonid);

	const TArray<struct FPartyMemberUIData> GetPartyMembersData(int32 index) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaNavigationScreen">();
	}
	static class UUMGAtlantaNavigationScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaNavigationScreen>();
	}
};
static_assert(alignof(UUMGAtlantaNavigationScreen) == 0x000008, "Wrong alignment on UUMGAtlantaNavigationScreen");
static_assert(sizeof(UUMGAtlantaNavigationScreen) == 0x000398, "Wrong size on UUMGAtlantaNavigationScreen");
static_assert(offsetof(UUMGAtlantaNavigationScreen, BankAndPlayerInfoWidget) == 0x000338, "Member 'UUMGAtlantaNavigationScreen::BankAndPlayerInfoWidget' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaNavigationScreen, TextButtonStart) == 0x000340, "Member 'UUMGAtlantaNavigationScreen::TextButtonStart' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaNavigationScreen, PlayModeSelectionVisibility) == 0x000348, "Member 'UUMGAtlantaNavigationScreen::PlayModeSelectionVisibility' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaNavigationScreen, CharacterInfoVisibility) == 0x000349, "Member 'UUMGAtlantaNavigationScreen::CharacterInfoVisibility' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaNavigationScreen, BackButtonVisibility) == 0x00034A, "Member 'UUMGAtlantaNavigationScreen::BackButtonVisibility' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaNavigationScreen, MenuButtonsVisibility) == 0x00034B, "Member 'UUMGAtlantaNavigationScreen::MenuButtonsVisibility' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaNavigationScreen, ButtonRoleVisibility) == 0x00034C, "Member 'UUMGAtlantaNavigationScreen::ButtonRoleVisibility' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaNavigationScreen, ButtonRole) == 0x000350, "Member 'UUMGAtlantaNavigationScreen::ButtonRole' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaNavigationScreen, BottomRightWidgetSwitcher) == 0x000358, "Member 'UUMGAtlantaNavigationScreen::BottomRightWidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaNavigationScreen, PartyPlayerSlots) == 0x000360, "Member 'UUMGAtlantaNavigationScreen::PartyPlayerSlots' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaNavigationScreen, PartyCountdownLarge) == 0x000368, "Member 'UUMGAtlantaNavigationScreen::PartyCountdownLarge' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaNavigationScreen, _partyMembers) == 0x000370, "Member 'UUMGAtlantaNavigationScreen::_partyMembers' has a wrong offset!");

// Class DeadByDaylight.AtlantaNavigationScreen
// 0x0008 (0x0128 - 0x0120)
class UAtlantaNavigationScreen final : public UScreenBase
{
public:
	class UUMGAtlantaNavigationScreen*            _umgScreen;                                        // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaNavigationScreen">();
	}
	static class UAtlantaNavigationScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaNavigationScreen>();
	}
};
static_assert(alignof(UAtlantaNavigationScreen) == 0x000008, "Wrong alignment on UAtlantaNavigationScreen");
static_assert(sizeof(UAtlantaNavigationScreen) == 0x000128, "Wrong size on UAtlantaNavigationScreen");
static_assert(offsetof(UAtlantaNavigationScreen, _umgScreen) == 0x000120, "Member 'UAtlantaNavigationScreen::_umgScreen' has a wrong offset!");

// Class DeadByDaylight.ActorComponentExt
// 0x0000 (0x0030 - 0x0030)
class UActorComponentExt final : public UBlueprintFunctionLibrary
{
public:
	static class ACharacter* GetOwningCharacter(const class UActorComponent* actorComponent, bool recursiveSearch);
	static class ACharacter* GetOwningCharacterChecked(const class UActorComponent* actorComponent, bool recursiveSearch);
	static class ASlasherPlayer* GetOwningKiller(const class UActorComponent* actorComponent, bool recursiveSearch);
	static class APawn* GetOwningPawn(const class UActorComponent* actorComponent, bool recursiveSearch);
	static class APawn* GetOwningPawnChecked(const class UActorComponent* actorComponent, bool recursiveSearch);
	static class ADBDPlayer* GetOwningPlayer(const class UActorComponent* actorComponent, bool recursiveSearch);
	static class ADBDPlayer* GetOwningPlayerChecked(const class UActorComponent* actorComponent, bool recursiveSearch);
	static class ADBDPlayer* GetOwningPlayerInHierarchy(const class UActorComponent* actorComponent);
	static class ACamperPlayer* GetOwningSurvivor(const class UActorComponent* actorComponent, bool recursiveSearch);
	static class ACamperPlayer* GetOwningSurvivorChecked(const class UActorComponent* actorComponent, bool recursiveSearch);
	static class AActor* GetValidatedOwner(const class UActorComponent* actorComponent);
	static bool HasAuthority(const class UActorComponent* actorComponent);
	static bool IsLocallyControlled(const class UActorComponent* actorComponent, bool recursiveSearch);
	static bool IsLocallyObserved(const class UActorComponent* actorComponent, bool recursiveSearch);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorComponentExt">();
	}
	static class UActorComponentExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorComponentExt>();
	}
};
static_assert(alignof(UActorComponentExt) == 0x000008, "Wrong alignment on UActorComponentExt");
static_assert(sizeof(UActorComponentExt) == 0x000030, "Wrong size on UActorComponentExt");

// Class DeadByDaylight.DBDEasyAntiCheat
// 0x0028 (0x0058 - 0x0030)
class UDBDEasyAntiCheat : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x2];                                       // 0x0050(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _connectedToServer;                                // 0x0052(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_53[0x5];                                       // 0x0053(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEasyAntiCheat">();
	}
	static class UDBDEasyAntiCheat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEasyAntiCheat>();
	}
};
static_assert(alignof(UDBDEasyAntiCheat) == 0x000008, "Wrong alignment on UDBDEasyAntiCheat");
static_assert(sizeof(UDBDEasyAntiCheat) == 0x000058, "Wrong size on UDBDEasyAntiCheat");
static_assert(offsetof(UDBDEasyAntiCheat, _gameInstance) == 0x000048, "Member 'UDBDEasyAntiCheat::_gameInstance' has a wrong offset!");
static_assert(offsetof(UDBDEasyAntiCheat, _connectedToServer) == 0x000052, "Member 'UDBDEasyAntiCheat::_connectedToServer' has a wrong offset!");

// Class DeadByDaylight.DBDEasyAntiCheatEnable
// 0x0090 (0x00E8 - 0x0058)
class UDBDEasyAntiCheatEnable : public UDBDEasyAntiCheat
{
public:
	uint8                                         Pad_58[0x90];                                      // 0x0058(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEasyAntiCheatEnable">();
	}
	static class UDBDEasyAntiCheatEnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEasyAntiCheatEnable>();
	}
};
static_assert(alignof(UDBDEasyAntiCheatEnable) == 0x000008, "Wrong alignment on UDBDEasyAntiCheatEnable");
static_assert(sizeof(UDBDEasyAntiCheatEnable) == 0x0000E8, "Wrong size on UDBDEasyAntiCheatEnable");

// Class DeadByDaylight.DBDEasyAntiCheatWindows
// 0x0000 (0x00E8 - 0x00E8)
class UDBDEasyAntiCheatWindows final : public UDBDEasyAntiCheatEnable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEasyAntiCheatWindows">();
	}
	static class UDBDEasyAntiCheatWindows* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEasyAntiCheatWindows>();
	}
};
static_assert(alignof(UDBDEasyAntiCheatWindows) == 0x000008, "Wrong alignment on UDBDEasyAntiCheatWindows");
static_assert(sizeof(UDBDEasyAntiCheatWindows) == 0x0000E8, "Wrong size on UDBDEasyAntiCheatWindows");

// Class DeadByDaylight.DBDAttack
// 0x02C8 (0x0380 - 0x00B8)
class alignas(0x10) UDBDAttack : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EAttackType                                   _attackType;                                       // 0x00D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _useMontage;                                       // 0x00D1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDetectionZone                                _damageZone;                                       // 0x00D2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDetectionZone                                _lockZone;                                         // 0x00D3(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDetectionZone                                _obstructionZone;                                  // 0x00D4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatProperty                          _maxAccelerationMultiplier;                        // 0x00D8(0x0088)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _onlyApplyAccelerationMultiplierWhenWalking;       // 0x0160(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_161[0x7];                                      // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDAttackTargetTracker                _targetTracker;                                    // 0x0168(0x00B8)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<EAttackSubstate, TSubclassOf<class UDBDAttackSubstate>> _stateClasses;                      // 0x0220(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class ACharacter*>                     _localAlreadyHitTargets;                           // 0x0270(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class ADBDPlayer*>                     _hitTargets;                                       // 0x0280(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSet<class ADBDPlayer*>                       _targetsAwaitingServerValidation;                  // 0x0290(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x28];                                     // 0x02E0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EAttackSubstate, class UDBDAttackSubstate*> _states;                                        // 0x0308(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x1F];                                     // 0x0358(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	EHitValidatorConfigName                       _hitValidationConfigName;                          // 0x0377(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_ReceiveAttackSubstateRequestResult(const struct FAttackSubstateRequestResult& result);
	void Client_ReceiveHitResult(class ADBDPlayer* target, bool isValid, const struct FActionPredictionKey& predictionKey);
	void Local_OnMovementChanged(class ACharacter* character, EMovementMode prevMovementMode, uint8 previousCustomMode);
	void Multicast_ClearTargets();
	void Multicast_HitAttackableComponent(class UAttackableComponent* attackableComponent);
	void Multicast_HitTarget(class ADBDPlayer* target, bool hitCosmeticOnly);
	void Multicast_RequestStateChange(const EAttackSubstate state);
	void Multicast_SendPostHitTargetData(class ADBDPlayer* owningKiller, class ADBDPlayer* target, const struct FPostAttackData& attackData);
	void Server_ClearTargets();
	void Server_HitAttackableComponent(class UAttackableComponent* attackableComponent);
	void Server_HitTarget(class ADBDPlayer* target, const float targetLocationTimestamp, const struct FActionPredictionKey& predictionKey);
	void Server_RequestStateChange(const EAttackSubstate state);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttack">();
	}
	static class UDBDAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttack>();
	}
};
static_assert(alignof(UDBDAttack) == 0x000010, "Wrong alignment on UDBDAttack");
static_assert(sizeof(UDBDAttack) == 0x000380, "Wrong size on UDBDAttack");
static_assert(offsetof(UDBDAttack, _attackType) == 0x0000D0, "Member 'UDBDAttack::_attackType' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _useMontage) == 0x0000D1, "Member 'UDBDAttack::_useMontage' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _damageZone) == 0x0000D2, "Member 'UDBDAttack::_damageZone' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _lockZone) == 0x0000D3, "Member 'UDBDAttack::_lockZone' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _obstructionZone) == 0x0000D4, "Member 'UDBDAttack::_obstructionZone' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _maxAccelerationMultiplier) == 0x0000D8, "Member 'UDBDAttack::_maxAccelerationMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _onlyApplyAccelerationMultiplierWhenWalking) == 0x000160, "Member 'UDBDAttack::_onlyApplyAccelerationMultiplierWhenWalking' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _targetTracker) == 0x000168, "Member 'UDBDAttack::_targetTracker' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _stateClasses) == 0x000220, "Member 'UDBDAttack::_stateClasses' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _localAlreadyHitTargets) == 0x000270, "Member 'UDBDAttack::_localAlreadyHitTargets' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _hitTargets) == 0x000280, "Member 'UDBDAttack::_hitTargets' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _targetsAwaitingServerValidation) == 0x000290, "Member 'UDBDAttack::_targetsAwaitingServerValidation' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _states) == 0x000308, "Member 'UDBDAttack::_states' has a wrong offset!");
static_assert(offsetof(UDBDAttack, _hitValidationConfigName) == 0x000377, "Member 'UDBDAttack::_hitValidationConfigName' has a wrong offset!");

// Class DeadByDaylight.ChargeableComponent
// 0x0268 (0x0320 - 0x00B8)
class UChargeableComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnInteractionEmptiedEvent;                         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool completed, const TArray<class AActor*>& instigatorsForCompletion)> OnInteractionCompletionStateChanged; // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool hadInput, ESkillCheckCustomType type, float ChargeChange)> SkillCheckResponseAestheticDelegate; // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Success, bool Bonus, class ADBDPlayer* Player, bool TriggerLoudNoise, bool hadInput, ESkillCheckCustomType type, float ChargeChange)> SkillCheckResponseAuthorityDelegate; // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float IndividualChargeAmount, float TotalChargeAmount, class AActor* ChargeInstigator, bool WasCoop, float DeltaTime)> ChargeAppliedAuthorityDelegate; // 0x0128(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UChargeableComponent* ChargeableComponent, float PercentCompletionChange, float TotalPercentComplete)> ChargeableCompletionPercentChangeAuthorityDelegate; // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UChargeableComponent* ChargeableComponent, float TotalPercentComplete)> ChargeableCompletionPercentChangeCosmeticDelegate; // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UChargeableComponent* ChargeableComponent)> DechargeBeginDelegate; // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UChargeableComponent* ChargeableComponent)> DechargeEndDelegate; // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          AllowSkillChecksAtFullCharge;                      // 0x0178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChargeableComponentID;                             // 0x0180(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DechargeDelay;                                     // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartingChargePercent;                             // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSpeedBasedNetSyncedValue              _currentCharge;                                    // 0x0198(0x0038)(Net, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D0[0x8];                                      // 0x01D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTimer                              _skillCheckFailurePenaltyTimer;                    // 0x01D8(0x0028)(Transient, NativeAccessSpecifierPrivate)
	struct FDBDTimer                              _dechargeTimer;                                    // 0x0200(0x0028)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FChargeData>                    _chargesThisFrame;                                 // 0x0228(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FChargeData>                    _redirectedChargesThisFrame;                       // 0x0238(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<uint32, class UChargeStrategy*>          _activeChargeStrategies;                           // 0x0248(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _instigatorsSinceEmpty;                            // 0x0298(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class FName, float>                      _tunableValueMap;                                  // 0x02A8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	bool                                          _isCharging;                                       // 0x02F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 _playersWhoDidSkillCheck;                          // 0x0300(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	float                                         _dechargeRate;                                     // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _enableAddCharge;                                  // 0x0314(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _enableSkillCheckFailurePenalty;                   // 0x0315(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isDecharging;                                     // 0x0316(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _stopDechargingWhenComplete;                       // 0x0317(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AddCharge(float chargeAmount, class AActor* instigator, bool bypassSkillCheckFail, bool isOneTimeIncrease, bool isChargeWithItem);
	void Authority_AddChargePercent(float chargePercent, class AActor* instigator, bool bypassSkillCheckFail, bool isOneTimeIncrease, bool isChargeWithItem);
	void Authority_ApplyStartingCharge();
	void Authority_Reset();
	void Authority_SetEnableAddCharge(const bool enable);
	void Authority_SetEnableSkillCheckFailurePenalty(const bool enable);
	void IncreaseMaxCharge(float percent);
	void IncreaseMaxChargeAdditive(float secondsToAdd);
	void OnCurrentChargeChanged(float value);
	void OnRep_CurrentCharge();
	void SetDechargeRate(float dechargeRate);
	void SetSecondsToCharge(float secondsToCharge);

	float GetChargeRemaining() const;
	float GetChargingSpeed() const;
	float GetCurrentCharge() const;
	float GetMaxCharge() const;
	float GetPercentComplete() const;
	float GetPlayerCountPenaltyModifier(int32 playerCount) const;
	float GetTunableValue(class FName TunableValueID) const;
	bool HasPlayerDoneSkillCheck(int32 playerID) const;
	bool IsChargeComplete() const;
	bool IsSkillCheckTimePenaltyActive() const;
	void Multicast_OnCompleteChanged(bool completed) const;
	void Multicast_OnEmptied() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeableComponent">();
	}
	static class UChargeableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeableComponent>();
	}
};
static_assert(alignof(UChargeableComponent) == 0x000008, "Wrong alignment on UChargeableComponent");
static_assert(sizeof(UChargeableComponent) == 0x000320, "Wrong size on UChargeableComponent");
static_assert(offsetof(UChargeableComponent, OnInteractionEmptiedEvent) == 0x0000B8, "Member 'UChargeableComponent::OnInteractionEmptiedEvent' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, OnInteractionCompletionStateChanged) == 0x0000E0, "Member 'UChargeableComponent::OnInteractionCompletionStateChanged' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, SkillCheckResponseAestheticDelegate) == 0x000108, "Member 'UChargeableComponent::SkillCheckResponseAestheticDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, SkillCheckResponseAuthorityDelegate) == 0x000118, "Member 'UChargeableComponent::SkillCheckResponseAuthorityDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, ChargeAppliedAuthorityDelegate) == 0x000128, "Member 'UChargeableComponent::ChargeAppliedAuthorityDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, ChargeableCompletionPercentChangeAuthorityDelegate) == 0x000138, "Member 'UChargeableComponent::ChargeableCompletionPercentChangeAuthorityDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, ChargeableCompletionPercentChangeCosmeticDelegate) == 0x000148, "Member 'UChargeableComponent::ChargeableCompletionPercentChangeCosmeticDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, DechargeBeginDelegate) == 0x000158, "Member 'UChargeableComponent::DechargeBeginDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, DechargeEndDelegate) == 0x000168, "Member 'UChargeableComponent::DechargeEndDelegate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, AllowSkillChecksAtFullCharge) == 0x000178, "Member 'UChargeableComponent::AllowSkillChecksAtFullCharge' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, ChargeableComponentID) == 0x000180, "Member 'UChargeableComponent::ChargeableComponentID' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, DechargeDelay) == 0x000190, "Member 'UChargeableComponent::DechargeDelay' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, StartingChargePercent) == 0x000194, "Member 'UChargeableComponent::StartingChargePercent' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _currentCharge) == 0x000198, "Member 'UChargeableComponent::_currentCharge' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _skillCheckFailurePenaltyTimer) == 0x0001D8, "Member 'UChargeableComponent::_skillCheckFailurePenaltyTimer' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _dechargeTimer) == 0x000200, "Member 'UChargeableComponent::_dechargeTimer' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _chargesThisFrame) == 0x000228, "Member 'UChargeableComponent::_chargesThisFrame' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _redirectedChargesThisFrame) == 0x000238, "Member 'UChargeableComponent::_redirectedChargesThisFrame' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _activeChargeStrategies) == 0x000248, "Member 'UChargeableComponent::_activeChargeStrategies' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _instigatorsSinceEmpty) == 0x000298, "Member 'UChargeableComponent::_instigatorsSinceEmpty' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _tunableValueMap) == 0x0002A8, "Member 'UChargeableComponent::_tunableValueMap' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _isCharging) == 0x0002F8, "Member 'UChargeableComponent::_isCharging' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _playersWhoDidSkillCheck) == 0x000300, "Member 'UChargeableComponent::_playersWhoDidSkillCheck' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _dechargeRate) == 0x000310, "Member 'UChargeableComponent::_dechargeRate' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _enableAddCharge) == 0x000314, "Member 'UChargeableComponent::_enableAddCharge' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _enableSkillCheckFailurePenalty) == 0x000315, "Member 'UChargeableComponent::_enableSkillCheckFailurePenalty' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _isDecharging) == 0x000316, "Member 'UChargeableComponent::_isDecharging' has a wrong offset!");
static_assert(offsetof(UChargeableComponent, _stopDechargingWhenComplete) == 0x000317, "Member 'UChargeableComponent::_stopDechargingWhenComplete' has a wrong offset!");

// Class DeadByDaylight.DBDCurrencyConversionTunables
// 0x0050 (0x0088 - 0x0038)
class UDBDCurrencyConversionTunables final : public UDataAsset
{
public:
	TMap<ECurrencyType, struct FCurrencyConversion> Currencies;                                      // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCurrencyConversionTunables">();
	}
	static class UDBDCurrencyConversionTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCurrencyConversionTunables>();
	}
};
static_assert(alignof(UDBDCurrencyConversionTunables) == 0x000008, "Wrong alignment on UDBDCurrencyConversionTunables");
static_assert(sizeof(UDBDCurrencyConversionTunables) == 0x000088, "Wrong size on UDBDCurrencyConversionTunables");
static_assert(offsetof(UDBDCurrencyConversionTunables, Currencies) == 0x000038, "Member 'UDBDCurrencyConversionTunables::Currencies' has a wrong offset!");

// Class DeadByDaylight.DBDAIUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDAIUtilities : public UBlueprintFunctionLibrary
{
public:
	static bool DrawDebugAINavigation();
	static bool DrawDebugAINavigationFilter();
	static bool DrawDebugAIPerception();
	static class UNavigationPath* FindPathWithAgentRadiusToActorSynchronously(class UObject* worldContextObject, const struct FVector& pathStart, class AActor* goalActor, float agentRadius, float tetherDistance, class AActor* pathfindingContext, TSubclassOf<class UNavigationQueryFilter> filterClass);
	static void SetCanEverAffectNavigation(class UActorComponent* component, bool affectNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIUtilities">();
	}
	static class UDBDAIUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAIUtilities>();
	}
};
static_assert(alignof(UDBDAIUtilities) == 0x000008, "Wrong alignment on UDBDAIUtilities");
static_assert(sizeof(UDBDAIUtilities) == 0x000030, "Wrong size on UDBDAIUtilities");

// Class DeadByDaylight.UMGAtlantaDailyRewardsGrid
// 0x0198 (0x04D0 - 0x0338)
class UUMGAtlantaDailyRewardsGrid final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   BigDailyRewardWidgetTemplate_type_7;               // 0x0348(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   BigDailyRewardWidgetTemplate_type_9;               // 0x0378(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   BigDailyRewardWidgetTemplate_type_13;              // 0x03A8(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SmallDailyRewardWidgetTemplate_type_7;             // 0x03D8(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SmallDailyRewardWidgetTemplate_type_9;             // 0x0408(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SmallDailyRewardWidgetTemplate_type_13;            // 0x0438(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      DailyRewardWidgetsGridPanel;                       // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           LastDailyRewardWidgetPanel;                        // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumberOfItems;                                     // 0x0478(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47C[0x2C];                                     // 0x047C(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 _bigWidgetTemplate;                                // 0x04A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _smallWidgetTemplate;                              // 0x04B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUMGDailyRewardWidget*>          _rewardWidgets;                                    // 0x04B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UUMGDailyRewardWidget*                  _widgetToAttach;                                   // 0x04C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeLayouts_BP();
	void PlayNextRewardIntroAnimation();
	void StartIntroSequence();
	void StartRewardsIntroRewardSequence();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaDailyRewardsGrid">();
	}
	static class UUMGAtlantaDailyRewardsGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaDailyRewardsGrid>();
	}
};
static_assert(alignof(UUMGAtlantaDailyRewardsGrid) == 0x000008, "Wrong alignment on UUMGAtlantaDailyRewardsGrid");
static_assert(sizeof(UUMGAtlantaDailyRewardsGrid) == 0x0004D0, "Wrong size on UUMGAtlantaDailyRewardsGrid");
static_assert(offsetof(UUMGAtlantaDailyRewardsGrid, BigDailyRewardWidgetTemplate_type_7) == 0x000348, "Member 'UUMGAtlantaDailyRewardsGrid::BigDailyRewardWidgetTemplate_type_7' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsGrid, BigDailyRewardWidgetTemplate_type_9) == 0x000378, "Member 'UUMGAtlantaDailyRewardsGrid::BigDailyRewardWidgetTemplate_type_9' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsGrid, BigDailyRewardWidgetTemplate_type_13) == 0x0003A8, "Member 'UUMGAtlantaDailyRewardsGrid::BigDailyRewardWidgetTemplate_type_13' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsGrid, SmallDailyRewardWidgetTemplate_type_7) == 0x0003D8, "Member 'UUMGAtlantaDailyRewardsGrid::SmallDailyRewardWidgetTemplate_type_7' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsGrid, SmallDailyRewardWidgetTemplate_type_9) == 0x000408, "Member 'UUMGAtlantaDailyRewardsGrid::SmallDailyRewardWidgetTemplate_type_9' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsGrid, SmallDailyRewardWidgetTemplate_type_13) == 0x000438, "Member 'UUMGAtlantaDailyRewardsGrid::SmallDailyRewardWidgetTemplate_type_13' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsGrid, DailyRewardWidgetsGridPanel) == 0x000468, "Member 'UUMGAtlantaDailyRewardsGrid::DailyRewardWidgetsGridPanel' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsGrid, LastDailyRewardWidgetPanel) == 0x000470, "Member 'UUMGAtlantaDailyRewardsGrid::LastDailyRewardWidgetPanel' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsGrid, NumberOfItems) == 0x000478, "Member 'UUMGAtlantaDailyRewardsGrid::NumberOfItems' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsGrid, _bigWidgetTemplate) == 0x0004A8, "Member 'UUMGAtlantaDailyRewardsGrid::_bigWidgetTemplate' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsGrid, _smallWidgetTemplate) == 0x0004B0, "Member 'UUMGAtlantaDailyRewardsGrid::_smallWidgetTemplate' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsGrid, _rewardWidgets) == 0x0004B8, "Member 'UUMGAtlantaDailyRewardsGrid::_rewardWidgets' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsGrid, _widgetToAttach) == 0x0004C8, "Member 'UUMGAtlantaDailyRewardsGrid::_widgetToAttach' has a wrong offset!");

// Class DeadByDaylight.DBDNetworkUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDNetworkUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool IsOnDedicatedServerNetwork(const class UObject* worldContextObject);
	static bool IsRunningDedicatedServerFlow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDNetworkUtilities">();
	}
	static class UDBDNetworkUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDNetworkUtilities>();
	}
};
static_assert(alignof(UDBDNetworkUtilities) == 0x000008, "Wrong alignment on UDBDNetworkUtilities");
static_assert(sizeof(UDBDNetworkUtilities) == 0x000030, "Wrong size on UDBDNetworkUtilities");

// Class DeadByDaylight.LevelParadise
// 0x00F8 (0x0328 - 0x0230)
class ALevelParadise final : public AActor
{
public:
	float                                         LoopStartDistance;                                 // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopDistance;                                      // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        MainPlayerSpawnPoint;                              // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                OtherSurvivorSpawnPoints;                          // 0x0240(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USceneComponent*>                ParadiseTiles;                                     // 0x0250(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AActor*                                 ParadiseViewTarget;                                // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_268[0xA8];                                     // 0x0268(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _spawnedMainPawn;                                  // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _runnerComponent;                                  // 0x0318(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fadeOutDuration;                                  // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fadeInDuration;                                   // 0x0324(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnInterpolationDone();
	void ParadiseEntered(const struct FParadiseData& playerData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelParadise">();
	}
	static class ALevelParadise* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelParadise>();
	}
};
static_assert(alignof(ALevelParadise) == 0x000008, "Wrong alignment on ALevelParadise");
static_assert(sizeof(ALevelParadise) == 0x000328, "Wrong size on ALevelParadise");
static_assert(offsetof(ALevelParadise, LoopStartDistance) == 0x000230, "Member 'ALevelParadise::LoopStartDistance' has a wrong offset!");
static_assert(offsetof(ALevelParadise, LoopDistance) == 0x000234, "Member 'ALevelParadise::LoopDistance' has a wrong offset!");
static_assert(offsetof(ALevelParadise, MainPlayerSpawnPoint) == 0x000238, "Member 'ALevelParadise::MainPlayerSpawnPoint' has a wrong offset!");
static_assert(offsetof(ALevelParadise, OtherSurvivorSpawnPoints) == 0x000240, "Member 'ALevelParadise::OtherSurvivorSpawnPoints' has a wrong offset!");
static_assert(offsetof(ALevelParadise, ParadiseTiles) == 0x000250, "Member 'ALevelParadise::ParadiseTiles' has a wrong offset!");
static_assert(offsetof(ALevelParadise, ParadiseViewTarget) == 0x000260, "Member 'ALevelParadise::ParadiseViewTarget' has a wrong offset!");
static_assert(offsetof(ALevelParadise, _spawnedMainPawn) == 0x000310, "Member 'ALevelParadise::_spawnedMainPawn' has a wrong offset!");
static_assert(offsetof(ALevelParadise, _runnerComponent) == 0x000318, "Member 'ALevelParadise::_runnerComponent' has a wrong offset!");
static_assert(offsetof(ALevelParadise, _fadeOutDuration) == 0x000320, "Member 'ALevelParadise::_fadeOutDuration' has a wrong offset!");
static_assert(offsetof(ALevelParadise, _fadeInDuration) == 0x000324, "Member 'ALevelParadise::_fadeInDuration' has a wrong offset!");

// Class DeadByDaylight.DBDAttackSubstate
// 0x00E8 (0x0118 - 0x0030)
class UDBDAttackSubstate : public UObject
{
public:
	struct FStatProperty                          _duration;                                         // 0x0030(0x0088)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _speedCurve;                                       // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _montage;                                          // 0x00C0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _currentCurve;                                     // 0x00D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x40];                                      // 0x00D8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackSubstate">();
	}
	static class UDBDAttackSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackSubstate>();
	}
};
static_assert(alignof(UDBDAttackSubstate) == 0x000008, "Wrong alignment on UDBDAttackSubstate");
static_assert(sizeof(UDBDAttackSubstate) == 0x000118, "Wrong size on UDBDAttackSubstate");
static_assert(offsetof(UDBDAttackSubstate, _duration) == 0x000030, "Member 'UDBDAttackSubstate::_duration' has a wrong offset!");
static_assert(offsetof(UDBDAttackSubstate, _speedCurve) == 0x0000B8, "Member 'UDBDAttackSubstate::_speedCurve' has a wrong offset!");
static_assert(offsetof(UDBDAttackSubstate, _montage) == 0x0000C0, "Member 'UDBDAttackSubstate::_montage' has a wrong offset!");
static_assert(offsetof(UDBDAttackSubstate, _currentCurve) == 0x0000D0, "Member 'UDBDAttackSubstate::_currentCurve' has a wrong offset!");

// Class DeadByDaylight.AICharacterBehaviourData
// 0x0000 (0x0030 - 0x0030)
class UAICharacterBehaviourData : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviourData">();
	}
	static class UAICharacterBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviourData>();
	}
};
static_assert(alignof(UAICharacterBehaviourData) == 0x000008, "Wrong alignment on UAICharacterBehaviourData");
static_assert(sizeof(UAICharacterBehaviourData) == 0x000030, "Wrong size on UAICharacterBehaviourData");

// Class DeadByDaylight.AICharacterBehaviourInteractWithActorData
// 0x0020 (0x0050 - 0x0030)
class UAICharacterBehaviourInteractWithActorData final : public UAICharacterBehaviourData
{
public:
	class AActor*                                 TargetActor;                                       // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ECharacterMovementTypes                       CharacterMovementType;                             // 0x0048(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UsePathfinding;                                    // 0x0049(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AActor* actor, ECharacterMovementTypes characterMovementType, bool usePathfinding);
	void WatchGameEventType(const struct FGameplayTag& gameEventType);
	void WatchGameEventTypes(const TArray<struct FGameplayTag>& gameEventTypes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviourInteractWithActorData">();
	}
	static class UAICharacterBehaviourInteractWithActorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviourInteractWithActorData>();
	}
};
static_assert(alignof(UAICharacterBehaviourInteractWithActorData) == 0x000008, "Wrong alignment on UAICharacterBehaviourInteractWithActorData");
static_assert(sizeof(UAICharacterBehaviourInteractWithActorData) == 0x000050, "Wrong size on UAICharacterBehaviourInteractWithActorData");
static_assert(offsetof(UAICharacterBehaviourInteractWithActorData, TargetActor) == 0x000030, "Member 'UAICharacterBehaviourInteractWithActorData::TargetActor' has a wrong offset!");
static_assert(offsetof(UAICharacterBehaviourInteractWithActorData, CharacterMovementType) == 0x000048, "Member 'UAICharacterBehaviourInteractWithActorData::CharacterMovementType' has a wrong offset!");
static_assert(offsetof(UAICharacterBehaviourInteractWithActorData, UsePathfinding) == 0x000049, "Member 'UAICharacterBehaviourInteractWithActorData::UsePathfinding' has a wrong offset!");

// Class DeadByDaylight.AtlantaHudPowerAttackJoystick
// 0x0050 (0x0388 - 0x0338)
class UAtlantaHudPowerAttackJoystick final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           AnimationContainer;                                // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _availableAnimationName;                           // 0x0348(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _fadeOutAnimationName;                             // 0x0354(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _tutoStartAnimationName;                           // 0x0360(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _tutoLoopAnimationName;                            // 0x036C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Icon;                                              // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_380[0x8];                                      // 0x0380(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedAvailableAnimation();
	void OnFinishedTutorialAnimationIn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaHudPowerAttackJoystick">();
	}
	static class UAtlantaHudPowerAttackJoystick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaHudPowerAttackJoystick>();
	}
};
static_assert(alignof(UAtlantaHudPowerAttackJoystick) == 0x000008, "Wrong alignment on UAtlantaHudPowerAttackJoystick");
static_assert(sizeof(UAtlantaHudPowerAttackJoystick) == 0x000388, "Wrong size on UAtlantaHudPowerAttackJoystick");
static_assert(offsetof(UAtlantaHudPowerAttackJoystick, AnimationContainer) == 0x000340, "Member 'UAtlantaHudPowerAttackJoystick::AnimationContainer' has a wrong offset!");
static_assert(offsetof(UAtlantaHudPowerAttackJoystick, _availableAnimationName) == 0x000348, "Member 'UAtlantaHudPowerAttackJoystick::_availableAnimationName' has a wrong offset!");
static_assert(offsetof(UAtlantaHudPowerAttackJoystick, _fadeOutAnimationName) == 0x000354, "Member 'UAtlantaHudPowerAttackJoystick::_fadeOutAnimationName' has a wrong offset!");
static_assert(offsetof(UAtlantaHudPowerAttackJoystick, _tutoStartAnimationName) == 0x000360, "Member 'UAtlantaHudPowerAttackJoystick::_tutoStartAnimationName' has a wrong offset!");
static_assert(offsetof(UAtlantaHudPowerAttackJoystick, _tutoLoopAnimationName) == 0x00036C, "Member 'UAtlantaHudPowerAttackJoystick::_tutoLoopAnimationName' has a wrong offset!");
static_assert(offsetof(UAtlantaHudPowerAttackJoystick, Icon) == 0x000378, "Member 'UAtlantaHudPowerAttackJoystick::Icon' has a wrong offset!");

// Class DeadByDaylight.ActiveWhenApplicableAndNotCampingPerkIconStrategy
// 0x0008 (0x0040 - 0x0038)
class UActiveWhenApplicableAndNotCampingPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveWhenApplicableAndNotCampingPerkIconStrategy">();
	}
	static class UActiveWhenApplicableAndNotCampingPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveWhenApplicableAndNotCampingPerkIconStrategy>();
	}
};
static_assert(alignof(UActiveWhenApplicableAndNotCampingPerkIconStrategy) == 0x000008, "Wrong alignment on UActiveWhenApplicableAndNotCampingPerkIconStrategy");
static_assert(sizeof(UActiveWhenApplicableAndNotCampingPerkIconStrategy) == 0x000040, "Wrong size on UActiveWhenApplicableAndNotCampingPerkIconStrategy");

// Class DeadByDaylight.GlyphNavMovementComponent
// 0x0028 (0x0168 - 0x0140)
class UGlyphNavMovementComponent final : public UNavMovementComponent
{
public:
	class AActor*                                 _glyphOwner;                                       // 0x0140(0x0008)(ZeroConstructor, Transient, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPathFollowingComponent*                _pathFollowingComponent;                           // 0x0148(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bPositionCorrected : 1;                            // 0x0150(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxSpeed;                                         // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _acceleration;                                     // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _deceleration;                                     // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _brakingDeceleration;                              // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_164[0x4];                                      // 0x0164(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAcceleration(float acceleration);
	void SetDeceleration(float deceleration);
	void SetMaxSpeed(float maxSpeed);

	class AActor* GetGlyphOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlyphNavMovementComponent">();
	}
	static class UGlyphNavMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlyphNavMovementComponent>();
	}
};
static_assert(alignof(UGlyphNavMovementComponent) == 0x000008, "Wrong alignment on UGlyphNavMovementComponent");
static_assert(sizeof(UGlyphNavMovementComponent) == 0x000168, "Wrong size on UGlyphNavMovementComponent");
static_assert(offsetof(UGlyphNavMovementComponent, _glyphOwner) == 0x000140, "Member 'UGlyphNavMovementComponent::_glyphOwner' has a wrong offset!");
static_assert(offsetof(UGlyphNavMovementComponent, _pathFollowingComponent) == 0x000148, "Member 'UGlyphNavMovementComponent::_pathFollowingComponent' has a wrong offset!");
static_assert(offsetof(UGlyphNavMovementComponent, _maxSpeed) == 0x000154, "Member 'UGlyphNavMovementComponent::_maxSpeed' has a wrong offset!");
static_assert(offsetof(UGlyphNavMovementComponent, _acceleration) == 0x000158, "Member 'UGlyphNavMovementComponent::_acceleration' has a wrong offset!");
static_assert(offsetof(UGlyphNavMovementComponent, _deceleration) == 0x00015C, "Member 'UGlyphNavMovementComponent::_deceleration' has a wrong offset!");
static_assert(offsetof(UGlyphNavMovementComponent, _brakingDeceleration) == 0x000160, "Member 'UGlyphNavMovementComponent::_brakingDeceleration' has a wrong offset!");

// Class DeadByDaylight.DoctorPowerAnimStateComponent
// 0x0008 (0x00C0 - 0x00B8)
class UDoctorPowerAnimStateComponent final : public UActorComponent
{
public:
	EDoctorAbilityType                            _abilityType;                                      // 0x00B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoctorAbilityPhase                           _abilityPhase;                                     // 0x00B9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurrentAbilityPhase(EDoctorAbilityPhase abilityPhase);
	void SetCurrentAbilityType(EDoctorAbilityType abilityType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoctorPowerAnimStateComponent">();
	}
	static class UDoctorPowerAnimStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoctorPowerAnimStateComponent>();
	}
};
static_assert(alignof(UDoctorPowerAnimStateComponent) == 0x000008, "Wrong alignment on UDoctorPowerAnimStateComponent");
static_assert(sizeof(UDoctorPowerAnimStateComponent) == 0x0000C0, "Wrong size on UDoctorPowerAnimStateComponent");
static_assert(offsetof(UDoctorPowerAnimStateComponent, _abilityType) == 0x0000B8, "Member 'UDoctorPowerAnimStateComponent::_abilityType' has a wrong offset!");
static_assert(offsetof(UDoctorPowerAnimStateComponent, _abilityPhase) == 0x0000B9, "Member 'UDoctorPowerAnimStateComponent::_abilityPhase' has a wrong offset!");

// Class DeadByDaylight.DBDAttackOpenSubstate
// 0x0000 (0x0118 - 0x0118)
class UDBDAttackOpenSubstate : public UDBDAttackSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackOpenSubstate">();
	}
	static class UDBDAttackOpenSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackOpenSubstate>();
	}
};
static_assert(alignof(UDBDAttackOpenSubstate) == 0x000008, "Wrong alignment on UDBDAttackOpenSubstate");
static_assert(sizeof(UDBDAttackOpenSubstate) == 0x000118, "Wrong size on UDBDAttackOpenSubstate");

// Class DeadByDaylight.StatusEffect
// 0x0138 (0x0350 - 0x0218)
class UStatusEffect : public UGameplayModifierContainer
{
public:
	uint8                                         Pad_218[0x48];                                     // 0x0218(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayModifierData                  ModifierData;                                      // 0x0260(0x0030)(Edit, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          ShouldDisplay;                                     // 0x0290(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomParam;                                       // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _removeOnRemainingLifetimeEnded;                   // 0x0298(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectWhenApplicable;             // 0x0299(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectByActivationTimer;          // 0x029A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectWhenLifeRemains;            // 0x029B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectByFunction;                 // 0x029C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastAsStatusEffectAlways;                     // 0x029D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BroadcastOriginatorGameEventNotificationWhenFirstApplicable; // 0x029E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldHideStatusEffectIconForOriginatingPlayer;    // 0x029F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _forceActivationTimerDisplay;                      // 0x02A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStatusEffectInitializationData        _statusInitializationData;                         // 0x02A8(0x0028)(Net, Transient, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x38];                                     // 0x02D0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           _nonStackingEffects;                               // 0x0308(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x38];                                     // 0x0318(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_EndSelf();
	void Authority_OnOriginatingPlayerEndPlay(class AActor* actor, EEndPlayReason endPlayReason);
	void Authority_RemoveSelf();
	void Authority_SetRemainingLifetime(float lifetime);
	void BroadcastGameEventNotification(const struct FGameplayNotificationData& notificationData, bool addToHistory);
	void BroadcastOriginatorGameEventNotification();
	void InitializeLifetime(float lifetime);
	void Multicast_SetRemainingLifetime(float lifetime);
	void Multicast_SetRemainingLifetimeInitialized(bool remainingLifetimeInitialized);
	void OnRep_ShouldDisplay();
	void OnRep_ShouldOriginatingPlayerChange();
	void OnRep_StatusInitializationData();
	void OnShouldDisplayChanged(bool currentValue);
	void OnShouldOriginatingPlayerChange();
	void SetShouldDisplay(bool on);
	void SetStatusEffectIconPercentage(float value);

	void FireActiveStatusEffectEvent(float percentage, int32 levelToDisplay) const;
	float GetCustomParam() const;
	float GetLifetimeDuration() const;
	class ADBDPlayer* GetOriginatingPlayer() const;
	bool GetShouldDisplay() const;
	float GetStatusEffectCooldownRate() const;
	EStatusEffectType GetStatusEffectType() const;
	bool IsInOriginatorRange() const;
	bool IsKillerInOriginatorRange(float AdditiveRangeModifier) const;
	bool IsOriginatorAlive() const;
	bool IsOriginatorHooked() const;
	bool ShouldDisplayStatusEffectIcon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffect">();
	}
	static class UStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffect>();
	}
};
static_assert(alignof(UStatusEffect) == 0x000008, "Wrong alignment on UStatusEffect");
static_assert(sizeof(UStatusEffect) == 0x000350, "Wrong size on UStatusEffect");
static_assert(offsetof(UStatusEffect, ModifierData) == 0x000260, "Member 'UStatusEffect::ModifierData' has a wrong offset!");
static_assert(offsetof(UStatusEffect, ShouldDisplay) == 0x000290, "Member 'UStatusEffect::ShouldDisplay' has a wrong offset!");
static_assert(offsetof(UStatusEffect, CustomParam) == 0x000294, "Member 'UStatusEffect::CustomParam' has a wrong offset!");
static_assert(offsetof(UStatusEffect, _removeOnRemainingLifetimeEnded) == 0x000298, "Member 'UStatusEffect::_removeOnRemainingLifetimeEnded' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectWhenApplicable) == 0x000299, "Member 'UStatusEffect::BroadcastAsStatusEffectWhenApplicable' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectByActivationTimer) == 0x00029A, "Member 'UStatusEffect::BroadcastAsStatusEffectByActivationTimer' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectWhenLifeRemains) == 0x00029B, "Member 'UStatusEffect::BroadcastAsStatusEffectWhenLifeRemains' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectByFunction) == 0x00029C, "Member 'UStatusEffect::BroadcastAsStatusEffectByFunction' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastAsStatusEffectAlways) == 0x00029D, "Member 'UStatusEffect::BroadcastAsStatusEffectAlways' has a wrong offset!");
static_assert(offsetof(UStatusEffect, BroadcastOriginatorGameEventNotificationWhenFirstApplicable) == 0x00029E, "Member 'UStatusEffect::BroadcastOriginatorGameEventNotificationWhenFirstApplicable' has a wrong offset!");
static_assert(offsetof(UStatusEffect, ShouldHideStatusEffectIconForOriginatingPlayer) == 0x00029F, "Member 'UStatusEffect::ShouldHideStatusEffectIconForOriginatingPlayer' has a wrong offset!");
static_assert(offsetof(UStatusEffect, _forceActivationTimerDisplay) == 0x0002A0, "Member 'UStatusEffect::_forceActivationTimerDisplay' has a wrong offset!");
static_assert(offsetof(UStatusEffect, _statusInitializationData) == 0x0002A8, "Member 'UStatusEffect::_statusInitializationData' has a wrong offset!");
static_assert(offsetof(UStatusEffect, _nonStackingEffects) == 0x000308, "Member 'UStatusEffect::_nonStackingEffects' has a wrong offset!");

// Class DeadByDaylight.SpecialEventLoadingScreen
// 0x0018 (0x0138 - 0x0120)
class USpecialEventLoadingScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoadingTextTimerComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventLoadingScreen">();
	}
	static class USpecialEventLoadingScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialEventLoadingScreen>();
	}
};
static_assert(alignof(USpecialEventLoadingScreen) == 0x000008, "Wrong alignment on USpecialEventLoadingScreen");
static_assert(sizeof(USpecialEventLoadingScreen) == 0x000138, "Wrong size on USpecialEventLoadingScreen");

// Class DeadByDaylight.CheatUtilities
// 0x0000 (0x0030 - 0x0030)
class UCheatUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheatUtilities">();
	}
	static class UCheatUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheatUtilities>();
	}
};
static_assert(alignof(UCheatUtilities) == 0x000008, "Wrong alignment on UCheatUtilities");
static_assert(sizeof(UCheatUtilities) == 0x000030, "Wrong size on UCheatUtilities");

// Class DeadByDaylight.HitValidatorComponent
// 0x0030 (0x00E8 - 0x00B8)
class UHitValidatorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UHitValidationConfigsComponent> _hitValidationConfigComponent;              // 0x00E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Multicast_DrawDebugHit(const struct FHitValidationReport& report);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitValidatorComponent">();
	}
	static class UHitValidatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitValidatorComponent>();
	}
};
static_assert(alignof(UHitValidatorComponent) == 0x000008, "Wrong alignment on UHitValidatorComponent");
static_assert(sizeof(UHitValidatorComponent) == 0x0000E8, "Wrong size on UHitValidatorComponent");
static_assert(offsetof(UHitValidatorComponent, _hitValidationConfigComponent) == 0x0000E0, "Member 'UHitValidatorComponent::_hitValidationConfigComponent' has a wrong offset!");

// Class DeadByDaylight.DBDAttackHittingSubstate
// 0x0088 (0x01A0 - 0x0118)
class UDBDAttackHittingSubstate : public UDBDAttackSubstate
{
public:
	struct FStatProperty                          _hittingPercentDamageBegin;                        // 0x0118(0x0088)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackHittingSubstate">();
	}
	static class UDBDAttackHittingSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackHittingSubstate>();
	}
};
static_assert(alignof(UDBDAttackHittingSubstate) == 0x000008, "Wrong alignment on UDBDAttackHittingSubstate");
static_assert(sizeof(UDBDAttackHittingSubstate) == 0x0001A0, "Wrong size on UDBDAttackHittingSubstate");
static_assert(offsetof(UDBDAttackHittingSubstate, _hittingPercentDamageBegin) == 0x000118, "Member 'UDBDAttackHittingSubstate::_hittingPercentDamageBegin' has a wrong offset!");

// Class DeadByDaylight.AtlantaEventsTemplateDataAsset
// 0x0050 (0x0088 - 0x0038)
class UAtlantaEventsTemplateDataAsset final : public UPrimaryDataAsset
{
public:
	TMap<EEventsType, TSubclassOf<class UUMGAtlantaBaseEventsTemplate>> Data;                        // 0x0038(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaEventsTemplateDataAsset">();
	}
	static class UAtlantaEventsTemplateDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaEventsTemplateDataAsset>();
	}
};
static_assert(alignof(UAtlantaEventsTemplateDataAsset) == 0x000008, "Wrong alignment on UAtlantaEventsTemplateDataAsset");
static_assert(sizeof(UAtlantaEventsTemplateDataAsset) == 0x000088, "Wrong size on UAtlantaEventsTemplateDataAsset");
static_assert(offsetof(UAtlantaEventsTemplateDataAsset, Data) == 0x000038, "Member 'UAtlantaEventsTemplateDataAsset::Data' has a wrong offset!");

// Class DeadByDaylight.ActivationTimerRemainingPercentIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerRemainingPercentIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerRemainingPercentIconStrategy">();
	}
	static class UActivationTimerRemainingPercentIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerRemainingPercentIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerRemainingPercentIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerRemainingPercentIconStrategy");
static_assert(sizeof(UActivationTimerRemainingPercentIconStrategy) == 0x000038, "Wrong size on UActivationTimerRemainingPercentIconStrategy");

// Class DeadByDaylight.DBDAttackSuccessSubstate
// 0x0000 (0x0118 - 0x0118)
class UDBDAttackSuccessSubstate : public UDBDAttackSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackSuccessSubstate">();
	}
	static class UDBDAttackSuccessSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackSuccessSubstate>();
	}
};
static_assert(alignof(UDBDAttackSuccessSubstate) == 0x000008, "Wrong alignment on UDBDAttackSuccessSubstate");
static_assert(sizeof(UDBDAttackSuccessSubstate) == 0x000118, "Wrong size on UDBDAttackSuccessSubstate");

// Class DeadByDaylight.BlockElement
// 0x0068 (0x0098 - 0x0030)
class UBlockElement final : public UObject
{
public:
	TWeakObjectPtr<class UObject>                 _source;                                           // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<TWeakObjectPtr<class ADBDPlayer>>        _affectedPlayers;                                  // 0x0038(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockElement">();
	}
	static class UBlockElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockElement>();
	}
};
static_assert(alignof(UBlockElement) == 0x000008, "Wrong alignment on UBlockElement");
static_assert(sizeof(UBlockElement) == 0x000098, "Wrong size on UBlockElement");
static_assert(offsetof(UBlockElement, _source) == 0x000030, "Member 'UBlockElement::_source' has a wrong offset!");
static_assert(offsetof(UBlockElement, _affectedPlayers) == 0x000038, "Member 'UBlockElement::_affectedPlayers' has a wrong offset!");

// Class DeadByDaylight.AICharacterBehaviourInteractWithActor
// 0x0038 (0x0090 - 0x0058)
class UAICharacterBehaviourInteractWithActor : public UAICharacterBehaviour
{
public:
	class ADBDPlayer*                             _aiPlayer;                                         // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDAIPlayerController*                 _aiPlayerController;                               // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAICharacterBehaviourInteractWithActorData* _behaviourData;                                // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x20];                                      // 0x0070(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMovementFinished(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviourInteractWithActor">();
	}
	static class UAICharacterBehaviourInteractWithActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviourInteractWithActor>();
	}
};
static_assert(alignof(UAICharacterBehaviourInteractWithActor) == 0x000008, "Wrong alignment on UAICharacterBehaviourInteractWithActor");
static_assert(sizeof(UAICharacterBehaviourInteractWithActor) == 0x000090, "Wrong size on UAICharacterBehaviourInteractWithActor");
static_assert(offsetof(UAICharacterBehaviourInteractWithActor, _aiPlayer) == 0x000058, "Member 'UAICharacterBehaviourInteractWithActor::_aiPlayer' has a wrong offset!");
static_assert(offsetof(UAICharacterBehaviourInteractWithActor, _aiPlayerController) == 0x000060, "Member 'UAICharacterBehaviourInteractWithActor::_aiPlayerController' has a wrong offset!");
static_assert(offsetof(UAICharacterBehaviourInteractWithActor, _behaviourData) == 0x000068, "Member 'UAICharacterBehaviourInteractWithActor::_behaviourData' has a wrong offset!");

// Class DeadByDaylight.TokenCounter
// 0x0028 (0x0058 - 0x0030)
class UTokenCounter final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _tokenCount;                                       // 0x0048(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maxTokenCount;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_DecrementToken();
	void Authority_IncrementToken();
	void Authority_SetMaxTokenCount(int32 value);
	void Authority_SetTokenCount(int32 value);
	void OnRep_TokenCount(int32 oldCount);

	int32 GetMaxTokenCount() const;
	int32 GetTokenCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TokenCounter">();
	}
	static class UTokenCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTokenCounter>();
	}
};
static_assert(alignof(UTokenCounter) == 0x000008, "Wrong alignment on UTokenCounter");
static_assert(sizeof(UTokenCounter) == 0x000058, "Wrong size on UTokenCounter");
static_assert(offsetof(UTokenCounter, _tokenCount) == 0x000048, "Member 'UTokenCounter::_tokenCount' has a wrong offset!");
static_assert(offsetof(UTokenCounter, _maxTokenCount) == 0x00004C, "Member 'UTokenCounter::_maxTokenCount' has a wrong offset!");

// Class DeadByDaylight.DreamSnareOutlineUpdateStrategy
// 0x0010 (0x00F0 - 0x00E0)
class UDreamSnareOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamSnareOutlineUpdateStrategy">();
	}
	static class UDreamSnareOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamSnareOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UDreamSnareOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UDreamSnareOutlineUpdateStrategy");
static_assert(sizeof(UDreamSnareOutlineUpdateStrategy) == 0x0000F0, "Wrong size on UDreamSnareOutlineUpdateStrategy");

// Class DeadByDaylight.LandingPageTabsDataAsset
// 0x00F0 (0x0128 - 0x0038)
class ULandingPageTabsDataAsset final : public UPrimaryDataAsset
{
public:
	TMap<EStorefrontState, struct FLandingPageTabData> BigButtonsData;                               // 0x0038(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EStorefrontState, struct FLandingPageTabData> MediumButtonsData;                            // 0x0088(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<EStorefrontState, struct FLandingPageTabData> SmallButtonsData;                             // 0x00D8(0x0050)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LandingPageTabsDataAsset">();
	}
	static class ULandingPageTabsDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULandingPageTabsDataAsset>();
	}
};
static_assert(alignof(ULandingPageTabsDataAsset) == 0x000008, "Wrong alignment on ULandingPageTabsDataAsset");
static_assert(sizeof(ULandingPageTabsDataAsset) == 0x000128, "Wrong size on ULandingPageTabsDataAsset");
static_assert(offsetof(ULandingPageTabsDataAsset, BigButtonsData) == 0x000038, "Member 'ULandingPageTabsDataAsset::BigButtonsData' has a wrong offset!");
static_assert(offsetof(ULandingPageTabsDataAsset, MediumButtonsData) == 0x000088, "Member 'ULandingPageTabsDataAsset::MediumButtonsData' has a wrong offset!");
static_assert(offsetof(ULandingPageTabsDataAsset, SmallButtonsData) == 0x0000D8, "Member 'ULandingPageTabsDataAsset::SmallButtonsData' has a wrong offset!");

// Class DeadByDaylight.DBDAttackMissSubstate
// 0x0000 (0x0118 - 0x0118)
class UDBDAttackMissSubstate : public UDBDAttackSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackMissSubstate">();
	}
	static class UDBDAttackMissSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackMissSubstate>();
	}
};
static_assert(alignof(UDBDAttackMissSubstate) == 0x000008, "Wrong alignment on UDBDAttackMissSubstate");
static_assert(sizeof(UDBDAttackMissSubstate) == 0x000118, "Wrong size on UDBDAttackMissSubstate");

// Class DeadByDaylight.BlindableBaseComponent
// 0x0188 (0x0240 - 0x00B8)
class UBlindableBaseComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x90];                                      // 0x00B8(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isBlinded;                                        // 0x0148(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isBeingBlinded;                                   // 0x0150(0x0030)(Net, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _chargeableComponent;                              // 0x0180(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AActor*, TScriptInterface<class IBlindingEffectorInterface>> _blindingEffectors;      // 0x0188(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x68];                                     // 0x01D8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AddBlindingEffector(TScriptInterface<class IBlindingEffectorInterface> effector);
	void Authority_Blinded(EBlindType blindType, float blindnessDuration, class AActor* effectorActor);
	void Authority_RemoveBlindingEffector(TScriptInterface<class IBlindingEffectorInterface> effector);
	void OnChargeableCompletionPercentChanged(class UChargeableComponent* chargeableComponent, float totalPercentComplete);
	void OnRep_IsBlinded();
	void SetChargeable(class UChargeableComponent* value);

	bool IsBlinded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindableBaseComponent">();
	}
	static class UBlindableBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindableBaseComponent>();
	}
};
static_assert(alignof(UBlindableBaseComponent) == 0x000008, "Wrong alignment on UBlindableBaseComponent");
static_assert(sizeof(UBlindableBaseComponent) == 0x000240, "Wrong size on UBlindableBaseComponent");
static_assert(offsetof(UBlindableBaseComponent, _isBlinded) == 0x000148, "Member 'UBlindableBaseComponent::_isBlinded' has a wrong offset!");
static_assert(offsetof(UBlindableBaseComponent, _isBeingBlinded) == 0x000150, "Member 'UBlindableBaseComponent::_isBeingBlinded' has a wrong offset!");
static_assert(offsetof(UBlindableBaseComponent, _chargeableComponent) == 0x000180, "Member 'UBlindableBaseComponent::_chargeableComponent' has a wrong offset!");
static_assert(offsetof(UBlindableBaseComponent, _blindingEffectors) == 0x000188, "Member 'UBlindableBaseComponent::_blindingEffectors' has a wrong offset!");

// Class DeadByDaylight.ActivationTimerElapsedCooldownElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerElapsedCooldownElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerElapsedCooldownElapsedIconStrategy">();
	}
	static class UActivationTimerElapsedCooldownElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerElapsedCooldownElapsedIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerElapsedCooldownElapsedIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerElapsedCooldownElapsedIconStrategy");
static_assert(sizeof(UActivationTimerElapsedCooldownElapsedIconStrategy) == 0x000038, "Wrong size on UActivationTimerElapsedCooldownElapsedIconStrategy");

// Class DeadByDaylight.DirectionalMinigameSurvivorComponent
// 0x0050 (0x0108 - 0x00B8)
class UDirectionalMinigameSurvivorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_StopInteraction(class UDirectionalMinigameComponent* directionalMinigame, EDirectionalMinigameResult result);
	void Server_CancelMinigame(class UDirectionalMinigameComponent* directionalMinigame);
	void Server_EnterKey(class UDirectionalMinigameComponent* directionalMinigame, EDirectionalInputKey key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DirectionalMinigameSurvivorComponent">();
	}
	static class UDirectionalMinigameSurvivorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDirectionalMinigameSurvivorComponent>();
	}
};
static_assert(alignof(UDirectionalMinigameSurvivorComponent) == 0x000008, "Wrong alignment on UDirectionalMinigameSurvivorComponent");
static_assert(sizeof(UDirectionalMinigameSurvivorComponent) == 0x000108, "Wrong size on UDirectionalMinigameSurvivorComponent");

// Class DeadByDaylight.DBDAttackObstructSubstate
// 0x0000 (0x0118 - 0x0118)
class UDBDAttackObstructSubstate : public UDBDAttackSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackObstructSubstate">();
	}
	static class UDBDAttackObstructSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackObstructSubstate>();
	}
};
static_assert(alignof(UDBDAttackObstructSubstate) == 0x000008, "Wrong alignment on UDBDAttackObstructSubstate");
static_assert(sizeof(UDBDAttackObstructSubstate) == 0x000118, "Wrong size on UDBDAttackObstructSubstate");

// Class DeadByDaylight.DBDAIController
// 0x02A8 (0x05E8 - 0x0340)
class ADBDAIController : public AAIController
{
public:
	float                                         DefaultSightRange;                                 // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloakedTargetSightRange;                           // 0x0344(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EAIDifficultyLevel, int32>               AIDifficultyMaxPlayerRanks;                        // 0x0348(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_398[0x10];                                     // 0x0398(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotateCameraOnStationaryWaitTime;                  // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateCameraOnStationaryDegreePerSecond;           // 0x03AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B0[0x20];                                     // 0x03B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  _aiPawn;                                           // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APawn*                                  _lastAiPawn;                                       // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class UObject*, float>                   _contextualPathSpeedFactors;                       // 0x03E0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UObject*                                _objOverridingDefaultNavigationFilter;             // 0x0430(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UNavigationQueryFilter>     _originalDefaultNavigationFilter;                  // 0x0438(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_440[0x18];                                     // 0x0440(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPawnInputPressTypes, class UObject*>    _inputLocks;                                       // 0x0458(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UObject*                                _movementLock;                                     // 0x04A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x138];                                    // 0x04B0(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionRequest(const class UObject* requester);
	void AttackRequest(const class UObject* requester);
	void CancelMinigameRequest(const class UObject* requester);
	void DropItemRequest(const class UObject* requester);
	void EndActionRequest(const class UObject* requester);
	void EndDropItemRequest(const class UObject* requester);
	void EndFastInteractRequest(const class UObject* requester);
	void EndInteractRequest(const class UObject* requester);
	void EndRunRequest(const class UObject* requester);
	void EndSecondAttackRequest(const class UObject* requester);
	void EndUseItemRequest(const class UObject* requester);
	void FastInteractRequest(const class UObject* requester);
	void Gesture01Request(const class UObject* requester);
	void Gesture02Request(const class UObject* requester);
	void Gesture03Request(const class UObject* requester);
	void Gesture04Request(const class UObject* requester);
	void InteractRequest(const class UObject* requester);
	void InteractRequestRelease(const class UObject* requester);
	void RunRequest(const class UObject* requester);
	void SecondaryActionRequest(const class UObject* requester);
	void SecondAttackRequest(const class UObject* requester);
	void Server_SetAIPlayerRank(int32 playerRank);
	bool SetCharacterMovement(ECharacterMovementTypes movementTypes, const class UObject* requester);
	void StruggleRequest(const class UObject* requester, float input);
	void UseItemRequest(const class UObject* requester);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIController">();
	}
	static class ADBDAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDAIController>();
	}
};
static_assert(alignof(ADBDAIController) == 0x000008, "Wrong alignment on ADBDAIController");
static_assert(sizeof(ADBDAIController) == 0x0005E8, "Wrong size on ADBDAIController");
static_assert(offsetof(ADBDAIController, DefaultSightRange) == 0x000340, "Member 'ADBDAIController::DefaultSightRange' has a wrong offset!");
static_assert(offsetof(ADBDAIController, CloakedTargetSightRange) == 0x000344, "Member 'ADBDAIController::CloakedTargetSightRange' has a wrong offset!");
static_assert(offsetof(ADBDAIController, AIDifficultyMaxPlayerRanks) == 0x000348, "Member 'ADBDAIController::AIDifficultyMaxPlayerRanks' has a wrong offset!");
static_assert(offsetof(ADBDAIController, RotateCameraOnStationaryWaitTime) == 0x0003A8, "Member 'ADBDAIController::RotateCameraOnStationaryWaitTime' has a wrong offset!");
static_assert(offsetof(ADBDAIController, RotateCameraOnStationaryDegreePerSecond) == 0x0003AC, "Member 'ADBDAIController::RotateCameraOnStationaryDegreePerSecond' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _aiPawn) == 0x0003D0, "Member 'ADBDAIController::_aiPawn' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _lastAiPawn) == 0x0003D8, "Member 'ADBDAIController::_lastAiPawn' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _contextualPathSpeedFactors) == 0x0003E0, "Member 'ADBDAIController::_contextualPathSpeedFactors' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _objOverridingDefaultNavigationFilter) == 0x000430, "Member 'ADBDAIController::_objOverridingDefaultNavigationFilter' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _originalDefaultNavigationFilter) == 0x000438, "Member 'ADBDAIController::_originalDefaultNavigationFilter' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _inputLocks) == 0x000458, "Member 'ADBDAIController::_inputLocks' has a wrong offset!");
static_assert(offsetof(ADBDAIController, _movementLock) == 0x0004A8, "Member 'ADBDAIController::_movementLock' has a wrong offset!");

// Class DeadByDaylight.DBDMistManager
// 0x0008 (0x0238 - 0x0230)
class ADBDMistManager final : public AActor
{
public:
	class UDBDAggregateParticleSystemComponent*   _particleSystemComp;                               // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMistManager">();
	}
	static class ADBDMistManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDMistManager>();
	}
};
static_assert(alignof(ADBDMistManager) == 0x000008, "Wrong alignment on ADBDMistManager");
static_assert(sizeof(ADBDMistManager) == 0x000238, "Wrong size on ADBDMistManager");
static_assert(offsetof(ADBDMistManager, _particleSystemComp) == 0x000230, "Member 'ADBDMistManager::_particleSystemComp' has a wrong offset!");

// Class DeadByDaylight.EndGameEntityAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class UEndGameEntityAnimInstance final : public UAnimInstance
{
public:
	bool                                          _isFront;                                          // 0x02C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBack;                                           // 0x02C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C2[0xE];                                      // 0x02C2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameEntityAnimInstance">();
	}
	static class UEndGameEntityAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndGameEntityAnimInstance>();
	}
};
static_assert(alignof(UEndGameEntityAnimInstance) == 0x000010, "Wrong alignment on UEndGameEntityAnimInstance");
static_assert(sizeof(UEndGameEntityAnimInstance) == 0x0002D0, "Wrong size on UEndGameEntityAnimInstance");
static_assert(offsetof(UEndGameEntityAnimInstance, _isFront) == 0x0002C0, "Member 'UEndGameEntityAnimInstance::_isFront' has a wrong offset!");
static_assert(offsetof(UEndGameEntityAnimInstance, _isBack) == 0x0002C1, "Member 'UEndGameEntityAnimInstance::_isBack' has a wrong offset!");

// Class DeadByDaylight.GameplayModifierCondition
// 0x0000 (0x00D0 - 0x00D0)
class UGameplayModifierCondition : public UBaseModifierCondition
{
public:
	void OnOwningGameplayModifierSet();
	void SetOwningGameplayModifier(class UGameplayModifierContainer* OwningGameplayModifier);

	class UGameplayModifierContainer* GetOwningGameplayModifier() const;
	class ADBDPlayer* GetOwningPlayer() const;
	bool IsApplicable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayModifierCondition">();
	}
	static class UGameplayModifierCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModifierCondition>();
	}
};
static_assert(alignof(UGameplayModifierCondition) == 0x000008, "Wrong alignment on UGameplayModifierCondition");
static_assert(sizeof(UGameplayModifierCondition) == 0x0000D0, "Wrong size on UGameplayModifierCondition");

// Class DeadByDaylight.StadiaVirtualKeyboardManager
// 0x0038 (0x0070 - 0x0038)
class UStadiaVirtualKeyboardManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StadiaVirtualKeyboardManager">();
	}
	static class UStadiaVirtualKeyboardManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStadiaVirtualKeyboardManager>();
	}
};
static_assert(alignof(UStadiaVirtualKeyboardManager) == 0x000008, "Wrong alignment on UStadiaVirtualKeyboardManager");
static_assert(sizeof(UStadiaVirtualKeyboardManager) == 0x000070, "Wrong size on UStadiaVirtualKeyboardManager");

// Class DeadByDaylight.GameplayNotificationManager
// 0x0028 (0x00E0 - 0x00B8)
class UGameplayNotificationManager final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FireGameplayNotification(const struct FGameplayNotificationData& notificationData, bool addToHistory);
	void Multicast_FireGameplayNotification(const class UGameplayModifierContainer* modifierContainer, bool addToHistory);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayNotificationManager">();
	}
	static class UGameplayNotificationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayNotificationManager>();
	}
};
static_assert(alignof(UGameplayNotificationManager) == 0x000008, "Wrong alignment on UGameplayNotificationManager");
static_assert(sizeof(UGameplayNotificationManager) == 0x0000E0, "Wrong size on UGameplayNotificationManager");

// Class DeadByDaylight.ActivationAndTimerIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationAndTimerIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationAndTimerIconStrategy">();
	}
	static class UActivationAndTimerIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationAndTimerIconStrategy>();
	}
};
static_assert(alignof(UActivationAndTimerIconStrategy) == 0x000008, "Wrong alignment on UActivationAndTimerIconStrategy");
static_assert(sizeof(UActivationAndTimerIconStrategy) == 0x000038, "Wrong size on UActivationAndTimerIconStrategy");

// Class DeadByDaylight.DBDPersistentData
// 0x1018 (0x1048 - 0x0030)
class UDBDPersistentData final : public UObject
{
public:
	struct FGamePersistentData                    _gamePersistentData;                               // 0x0030(0x0108)(Transient, NativeAccessSpecifierPrivate)
	TArray<class FString>                         _keepDataIDs;                                      // 0x0138(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FPlayerPersistentData> _playerIdToPersistentDataMap;                  // 0x0148(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FPlayerPersistentData                  _localPlayerPersistentData;                        // 0x0198(0x0828)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C0[0x50];                                     // 0x09C0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCloudInventoryItem>            _cloudInventory;                                   // 0x0A10(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A20[0x628];                                    // 0x0A20(0x0628)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPersistentData">();
	}
	static class UDBDPersistentData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPersistentData>();
	}
};
static_assert(alignof(UDBDPersistentData) == 0x000008, "Wrong alignment on UDBDPersistentData");
static_assert(sizeof(UDBDPersistentData) == 0x001048, "Wrong size on UDBDPersistentData");
static_assert(offsetof(UDBDPersistentData, _gamePersistentData) == 0x000030, "Member 'UDBDPersistentData::_gamePersistentData' has a wrong offset!");
static_assert(offsetof(UDBDPersistentData, _keepDataIDs) == 0x000138, "Member 'UDBDPersistentData::_keepDataIDs' has a wrong offset!");
static_assert(offsetof(UDBDPersistentData, _playerIdToPersistentDataMap) == 0x000148, "Member 'UDBDPersistentData::_playerIdToPersistentDataMap' has a wrong offset!");
static_assert(offsetof(UDBDPersistentData, _localPlayerPersistentData) == 0x000198, "Member 'UDBDPersistentData::_localPlayerPersistentData' has a wrong offset!");
static_assert(offsetof(UDBDPersistentData, _cloudInventory) == 0x000A10, "Member 'UDBDPersistentData::_cloudInventory' has a wrong offset!");

// Class DeadByDaylight.CustomizationDescription
// 0x0010 (0x0048 - 0x0038)
class UCustomizationDescription final : public UDataAsset
{
public:
	TArray<struct FCustomizedMeshPart>            Parts;                                             // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationDescription">();
	}
	static class UCustomizationDescription* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationDescription>();
	}
};
static_assert(alignof(UCustomizationDescription) == 0x000008, "Wrong alignment on UCustomizationDescription");
static_assert(sizeof(UCustomizationDescription) == 0x000048, "Wrong size on UCustomizationDescription");
static_assert(offsetof(UCustomizationDescription, Parts) == 0x000038, "Member 'UCustomizationDescription::Parts' has a wrong offset!");

// Class DeadByDaylight.DBDGameState
// 0x05C0 (0x0868 - 0x02A8)
class ADBDGameState : public AGameState
{
public:
	uint8                                         Pad_2A8[0x30];                                     // 0x02A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnEscapeDoorActivated;                             // 0x02D8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x90];                                     // 0x02E8(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	EIntroState                                   IntroState;                                        // 0x0378(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(float killerIntroCompletePercentChanged)> OnKillerIntroCompletePercentChanged; // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLightingGenerated;                               // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0x30];                                     // 0x03A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USpecialEventGameplaySpawnerComponent*  _specialEventGameplaySpawnerComponent;             // 0x03D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              AuthorityOnAllPlayerLoaded;                        // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E8[0x18];                                     // 0x03E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int32 _activatedGeneratorCount)> OnActivatedGeneratorCountChangedDynamic; // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSlasherSet;                                      // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0x18];                                     // 0x0420(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ACamperPlayer* newObsession, class ACamperPlayer* previousObsession)> OnObsessionChanged; // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         CamperDeadCount;                                   // 0x0448(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CamperInMeatLockerCount;                           // 0x044C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CamperEscaped;                                     // 0x0450(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WaitingForEscape;                                  // 0x0454(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CamperCount;                                       // 0x0458(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondsLeftInLobby;                                // 0x045C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_460[0x30];                                     // 0x0460(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class ASlasherPlayer*                         Slasher;                                           // 0x0490(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URenderingFeaturesSequencer*            _renderingSequencer;                               // 0x0498(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0x30];                                     // 0x04A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _camperHookedInBasementCount;                      // 0x04D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D4[0x8];                                      // 0x04D4(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EServerUseNetAsyncLoading                     _useNetAsyncLoading;                               // 0x04DC(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _gameLevelLoadingStarted;                          // 0x04DD(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4DE[0x2];                                      // 0x04DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBuiltLevelData                        _builtLevelData;                                   // 0x04E0(0x00B0)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	struct FOfferingData                          _levelOfferings;                                   // 0x0590(0x0018)(Net, Transient, NativeAccessSpecifierPrivate)
	class AClipManager*                           _clipManager;                                      // 0x05A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  _sessionId;                                        // 0x05B0(0x0010)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  _lobbyId;                                          // 0x05C0(0x0010)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _activatedGeneratorCount;                          // 0x05D0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _requiredActivatedGeneratorCount;                  // 0x05D4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _escapeDoorActivated;                              // 0x05D8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _escapeDoorOpened;                                 // 0x05D9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isHatchOpen;                                      // 0x05DA(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _levelReadyToPlay;                                 // 0x05DB(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _playerDistributionReady;                          // 0x05DC(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _usingWeakenedMechanic;                            // 0x05DD(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5DE[0x2];                                      // 0x05DE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _survivorLeft;                                     // 0x05E0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E4[0x4];                                      // 0x05E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AMeatHook*>                      _meatHooks;                                        // 0x05E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ASearchable*>                    _searchables;                                      // 0x05F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AGenerator*>                     _generators;                                       // 0x0608(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AEscapeDoor*>                    _escapeDoors;                                      // 0x0618(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AHatch*>                         _hatches;                                          // 0x0628(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AReverseBearTrapRemover*>        _reverseBearTrapRemovers;                          // 0x0638(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ABaseTrap*>                      _baseTraps;                                        // 0x0648(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class APallet*>                        _pallets;                                          // 0x0658(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AWindow*>                        _windows;                                          // 0x0668(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ALocker*>                        _lockers;                                          // 0x0678(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ABreakableBase*>                 _breakableWalls;                                   // 0x0688(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ATotem*>                         _totems;                                           // 0x0698(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FBoxSphereBounds                       _mapBoxSphereBounds;                               // 0x06A8(0x001C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C4[0x18];                                     // 0x06C4(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _camperEscapedThroughHatch;                        // 0x06DC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACamperPlayer*                          _obsessionTarget;                                  // 0x06E0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _cachedObsessionEscaped;                           // 0x06E8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6E9[0x7];                                      // 0x06E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int8                                          _numberOfSurvivorsKilled;                          // 0x06F0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6F1[0x7];                                      // 0x06F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AInteractable*>                  _traps;                                            // 0x06F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UDBDDangerPredictionComponent*>  _dangerPredictionObjects;                          // 0x0708(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_718[0x8];                                      // 0x0718(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGamePresetData                        _gamePresetData;                                   // 0x0720(0x0090)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          _gameLevelLoaded;                                  // 0x07B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _gameLevelCreated;                                 // 0x07B1(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _gameLevelEnded;                                   // 0x07B2(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _gameTimedOut;                                     // 0x07B3(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEndGameReason                                _gameEndedReason;                                  // 0x07B4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isLoadoutFrozen;                                  // 0x07B5(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7B6[0x2];                                      // 0x07B6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UEndGameStateComponent*                 _endGameState;                                     // 0x07B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScourgeHookManagerComponent*           _scourgeHookManager;                               // 0x07C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActorPairQueryEvaluatorComponent*      _actorPairQueryEvaluatorComponent;                 // 0x07C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D0[0x8];                                      // 0x07D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterCollection*                   _characterCollection;                              // 0x07D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCollectableCollection*                 _collectableCollection;                            // 0x07E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UServerTimeProviderComponent*           _serverTimeProvider;                               // 0x07E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInGameAssetPreloaderComponent*         _inGameAssetPreloaderComponent;                    // 0x07F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOnScreenDebugComponent*                _onScreenDebugComponent;                           // 0x07F8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_800[0x28];                                     // 0x0800(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              _matchStartTime;                                   // 0x0828(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isServerDedicated;                                // 0x0830(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_831[0x3];                                      // 0x0831(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _maxSurvivorCount;                                 // 0x0834(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _serverBuildVersion;                               // 0x0838(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _serverContentVersion;                             // 0x0848(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _introDuration;                                    // 0x0858(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _leaveSpectateRequested;                           // 0x085C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_85D[0xB];                                      // 0x085D(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDangerPredictionObject(class UDBDDangerPredictionComponent* toAdd);
	void AddTrap(class AInteractable* toAdd);
	void Authority_DeactivateAI();
	void Authority_EnableObsession();
	void Authority_EscapeThroughHatch();
	void Authority_EvaluateObsessionTarget(class ADBDPlayer* potentialTarget);
	void Authority_SetAllPlayerLoaded();
	void Authority_SetEscapeDoorOpened(bool opened);
	void Authority_SetGameLevelCreated();
	void Authority_SetGameLevelEnded(EEndGameReason endGameReason);
	void Authority_SetGameLevelLoaded();
	void Authority_SetGameSelectedOffering(const TArray<struct FSelectedOffering>& offerings);
	void Authority_SetGameStarted();
	void Authority_SetHatchOpen(bool opened);
	void Authority_SetLevelReadyToPlay();
	void Authority_SetObsessionTarget(class ACamperPlayer* obsessionTarget);
	void Authority_SetSurvivorLeft(int32 survivorRemaining);
	void Authority_SignalEscapeDoorActivated(bool newEscapeDoorActivated);
	void BroadcastOnSetBuildLevelData();
	void CallOnIntroComplete(TDelegate<void()> callback);
	void CallOnLevelReadyToPlay(TDelegate<void()> callback);
	void CallOnSlasherSet(TDelegate<void(class ASlasherPlayer* slasher)> callback);
	const TArray<class UDBDDangerPredictionComponent*> GetDangerPredictionObjects(const bool isObjectDynamic);
	void IntroCompleted();
	bool IsObsessionTargetAlive();
	bool IsObsessionTargetAliveInLevel();
	void Multicast_BroadcastOnLevelLoadingTimeOutClientEvent();
	void Multicast_OnGameStarted();
	void Multicast_SendEnsureToClients(const class FString& ensure);
	void Multicast_SendHVSPlusState(bool enabled);
	void Multicast_SetBuiltLevelData(const struct FBuiltLevelData& builtLevelData);
	void Multicast_SetGameEnded(bool hasServerLeftGame);
	void Multicast_SetGameLevelEnded(EEndGameReason endGameReason);
	void Multicast_SetGameLevelLoaded(bool gameLevelLoaded);
	void Multicast_SetLostServerConnection(bool hasLostServerConnection);
	void Multicast_SetServerLeftGame(bool hasServerLeftGame);
	void Multicast_UpdateCharacterFromGamePreset(class ADBDPlayerState_Menu* playerState_Menu, const struct FGamePresetData& gamePresetData);
	void OnPlayerGameStateChangedAddIfKilled(class ADBDPlayerState* playerState, EGameState gameState);
	void OnRep_ActivatedGeneratorCount(int32 oldValue);
	void OnRep_BuildLevelData();
	void OnRep_EscapeDoorActivated(bool oldValue);
	void OnRep_GameLevelLoadingStarted(bool oldValue);
	void OnRep_GamePresetData();
	void OnRep_HatchOpened(bool oldValue);
	void OnRep_LobbyId();
	void OnRep_ObsessionTarget(class ACamperPlayer* previousObsessionTarget);
	void OnRep_OnGameLevelCreated();
	void OnRep_OnLevelReadyToPlay(bool oldValue);
	void OnRep_RequiredActivatedGeneratorCount(int32 oldRequiredActivatedGeneratorCount);
	void OnRep_SecondsLeftInLobby(const int32 oldValue);
	void OnRep_SessionId();
	void OnRep_SurvivorLeft(int32 oldValue);
	void OnRep_UseNetAsyncLoading();
	void RemoveDangerPredictionObject(class UDBDDangerPredictionComponent* toRemove);
	void RemoveTrap(class AInteractable* toRemove);
	void ResetGameLevelStatus();
	void Server_UpdateGameRole();
	void SetBuiltLevelData(const struct FBuiltLevelData& builtLevelData);
	void SetDisplayMapName(bool display);
	void SetGameLevelEnded(EEndGameReason endGameReason);
	void SetKillerIntroCompletedNormalized(float completedAmount);
	void SetPlayersReadyToStart(bool playersReadyToStart);
	void SortOfferings();
	void UnregisterFromIntroCompleteAndLevelReadyToPlay(const class UObject* inObject);

	const TArray<class UDBDDangerPredictionComponent*> GetAllDangerPredictionObjects() const;
	class UCharacterCollection* GetCharacterCollection() const;
	class UCollectableCollection* GetCollectableCollection() const;
	class UEndGameStateComponent* GetEndGameStateComponent() const;
	bool GetGameLevelLoaded() const;
	bool GetGameLevelLoadingStarted() const;
	const TArray<class ABaseTrap*> GetInGameBaseTraps() const;
	const TArray<class AEscapeDoor*> GetInGameEscapeDoors() const;
	const TArray<class AGenerator*> GetInGameGenerators() const;
	const TArray<class AHatch*> GetInGameHatches() const;
	const TArray<class AMeatHook*> GetInGameMeatHooks() const;
	const TArray<class APallet*> GetInGamePallets() const;
	const TArray<class AReverseBearTrapRemover*> GetInGameReverseBearTrapRemovers() const;
	const TArray<class ASearchable*> GetInGameSearchables() const;
	const TArray<class AWindow*> GetInGameWindows() const;
	bool GetIsGameEnded() const;
	class ASlasherPlayer* GetKiller() const;
	float GetKillerIntroCompletedNormalized() const;
	const struct FBuiltLevelData GetLevelData() const;
	TSoftObjectPtr<class UAkAudioBank> GetLevelThemeAudioSoundBankAssetPtr() const;
	class APawn* GetLocalPlayerBasePawn() const;
	class ADBDPlayer* GetLocalPlayerPawn() const;
	class FName GetMapThemeName() const;
	int32 GetNumberOfActiveSurvivors() const;
	int32 GetNumberOfOtherActiveSurvivors(class ADBDPlayer* exception) const;
	class ACamperPlayer* GetObsessionTarget() const;
	void GetPlayerRoleCounts(int32* survivorCount, int32* killerCount, int32* spectatorCount) const;
	bool GetPlayersReadyToStart() const;
	class ADBDPlayerState* GetPlayerStateByIDString(const class FString& id) const;
	class ADBDPlayerState* GetPlayerStateByMirrorsID(const class FString& id) const;
	int32 GetRemainingGeneratorsNeeded() const;
	int32 GetRequiredActivatedGeneratorCount() const;
	bool GetSelectedOffering(int32 index, struct FSelectedOffering* selectedOffering) const;
	const TArray<struct FSelectedOffering> GetSelectedOfferings() const;
	class USpecialEventGameplaySpawnerComponent* GetSpecialEventGameplaySpawnerComponent() const;
	int32 GetSurvivorLeft() const;
	const TArray<class ATotem*> GetTotems() const;
	const TArray<class AInteractable*> GetTraps() const;
	bool IsEscapeDoorActivated() const;
	bool IsEscapeDoorOpen() const;
	bool IsEscapeRequirementCompleted() const;
	bool IsHatchVisible() const;
	bool IsIntroCompleted() const;
	bool IsLevelReadyToPlay() const;
	bool IsLevelSetupDone() const;
	bool IsLightingGenerated() const;
	bool IsOfferingReceived() const;
	bool IsOnePlayerLeft() const;
	bool IsPlayerDistributionReady() const;
	void UpdateInGamePallets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameState">();
	}
	static class ADBDGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGameState>();
	}
};
static_assert(alignof(ADBDGameState) == 0x000008, "Wrong alignment on ADBDGameState");
static_assert(sizeof(ADBDGameState) == 0x000868, "Wrong size on ADBDGameState");
static_assert(offsetof(ADBDGameState, OnEscapeDoorActivated) == 0x0002D8, "Member 'ADBDGameState::OnEscapeDoorActivated' has a wrong offset!");
static_assert(offsetof(ADBDGameState, IntroState) == 0x000378, "Member 'ADBDGameState::IntroState' has a wrong offset!");
static_assert(offsetof(ADBDGameState, OnKillerIntroCompletePercentChanged) == 0x000380, "Member 'ADBDGameState::OnKillerIntroCompletePercentChanged' has a wrong offset!");
static_assert(offsetof(ADBDGameState, OnLightingGenerated) == 0x000390, "Member 'ADBDGameState::OnLightingGenerated' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _specialEventGameplaySpawnerComponent) == 0x0003D0, "Member 'ADBDGameState::_specialEventGameplaySpawnerComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, AuthorityOnAllPlayerLoaded) == 0x0003D8, "Member 'ADBDGameState::AuthorityOnAllPlayerLoaded' has a wrong offset!");
static_assert(offsetof(ADBDGameState, OnActivatedGeneratorCountChangedDynamic) == 0x000400, "Member 'ADBDGameState::OnActivatedGeneratorCountChangedDynamic' has a wrong offset!");
static_assert(offsetof(ADBDGameState, OnSlasherSet) == 0x000410, "Member 'ADBDGameState::OnSlasherSet' has a wrong offset!");
static_assert(offsetof(ADBDGameState, OnObsessionChanged) == 0x000438, "Member 'ADBDGameState::OnObsessionChanged' has a wrong offset!");
static_assert(offsetof(ADBDGameState, CamperDeadCount) == 0x000448, "Member 'ADBDGameState::CamperDeadCount' has a wrong offset!");
static_assert(offsetof(ADBDGameState, CamperInMeatLockerCount) == 0x00044C, "Member 'ADBDGameState::CamperInMeatLockerCount' has a wrong offset!");
static_assert(offsetof(ADBDGameState, CamperEscaped) == 0x000450, "Member 'ADBDGameState::CamperEscaped' has a wrong offset!");
static_assert(offsetof(ADBDGameState, WaitingForEscape) == 0x000454, "Member 'ADBDGameState::WaitingForEscape' has a wrong offset!");
static_assert(offsetof(ADBDGameState, CamperCount) == 0x000458, "Member 'ADBDGameState::CamperCount' has a wrong offset!");
static_assert(offsetof(ADBDGameState, SecondsLeftInLobby) == 0x00045C, "Member 'ADBDGameState::SecondsLeftInLobby' has a wrong offset!");
static_assert(offsetof(ADBDGameState, Slasher) == 0x000490, "Member 'ADBDGameState::Slasher' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _renderingSequencer) == 0x000498, "Member 'ADBDGameState::_renderingSequencer' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _camperHookedInBasementCount) == 0x0004D0, "Member 'ADBDGameState::_camperHookedInBasementCount' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _useNetAsyncLoading) == 0x0004DC, "Member 'ADBDGameState::_useNetAsyncLoading' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameLevelLoadingStarted) == 0x0004DD, "Member 'ADBDGameState::_gameLevelLoadingStarted' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _builtLevelData) == 0x0004E0, "Member 'ADBDGameState::_builtLevelData' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _levelOfferings) == 0x000590, "Member 'ADBDGameState::_levelOfferings' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _clipManager) == 0x0005A8, "Member 'ADBDGameState::_clipManager' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _sessionId) == 0x0005B0, "Member 'ADBDGameState::_sessionId' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _lobbyId) == 0x0005C0, "Member 'ADBDGameState::_lobbyId' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _activatedGeneratorCount) == 0x0005D0, "Member 'ADBDGameState::_activatedGeneratorCount' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _requiredActivatedGeneratorCount) == 0x0005D4, "Member 'ADBDGameState::_requiredActivatedGeneratorCount' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _escapeDoorActivated) == 0x0005D8, "Member 'ADBDGameState::_escapeDoorActivated' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _escapeDoorOpened) == 0x0005D9, "Member 'ADBDGameState::_escapeDoorOpened' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _isHatchOpen) == 0x0005DA, "Member 'ADBDGameState::_isHatchOpen' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _levelReadyToPlay) == 0x0005DB, "Member 'ADBDGameState::_levelReadyToPlay' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _playerDistributionReady) == 0x0005DC, "Member 'ADBDGameState::_playerDistributionReady' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _usingWeakenedMechanic) == 0x0005DD, "Member 'ADBDGameState::_usingWeakenedMechanic' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _survivorLeft) == 0x0005E0, "Member 'ADBDGameState::_survivorLeft' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _meatHooks) == 0x0005E8, "Member 'ADBDGameState::_meatHooks' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _searchables) == 0x0005F8, "Member 'ADBDGameState::_searchables' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _generators) == 0x000608, "Member 'ADBDGameState::_generators' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _escapeDoors) == 0x000618, "Member 'ADBDGameState::_escapeDoors' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _hatches) == 0x000628, "Member 'ADBDGameState::_hatches' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _reverseBearTrapRemovers) == 0x000638, "Member 'ADBDGameState::_reverseBearTrapRemovers' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _baseTraps) == 0x000648, "Member 'ADBDGameState::_baseTraps' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _pallets) == 0x000658, "Member 'ADBDGameState::_pallets' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _windows) == 0x000668, "Member 'ADBDGameState::_windows' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _lockers) == 0x000678, "Member 'ADBDGameState::_lockers' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _breakableWalls) == 0x000688, "Member 'ADBDGameState::_breakableWalls' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _totems) == 0x000698, "Member 'ADBDGameState::_totems' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _mapBoxSphereBounds) == 0x0006A8, "Member 'ADBDGameState::_mapBoxSphereBounds' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _camperEscapedThroughHatch) == 0x0006DC, "Member 'ADBDGameState::_camperEscapedThroughHatch' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _obsessionTarget) == 0x0006E0, "Member 'ADBDGameState::_obsessionTarget' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _cachedObsessionEscaped) == 0x0006E8, "Member 'ADBDGameState::_cachedObsessionEscaped' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _numberOfSurvivorsKilled) == 0x0006F0, "Member 'ADBDGameState::_numberOfSurvivorsKilled' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _traps) == 0x0006F8, "Member 'ADBDGameState::_traps' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _dangerPredictionObjects) == 0x000708, "Member 'ADBDGameState::_dangerPredictionObjects' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gamePresetData) == 0x000720, "Member 'ADBDGameState::_gamePresetData' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameLevelLoaded) == 0x0007B0, "Member 'ADBDGameState::_gameLevelLoaded' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameLevelCreated) == 0x0007B1, "Member 'ADBDGameState::_gameLevelCreated' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameLevelEnded) == 0x0007B2, "Member 'ADBDGameState::_gameLevelEnded' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameTimedOut) == 0x0007B3, "Member 'ADBDGameState::_gameTimedOut' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _gameEndedReason) == 0x0007B4, "Member 'ADBDGameState::_gameEndedReason' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _isLoadoutFrozen) == 0x0007B5, "Member 'ADBDGameState::_isLoadoutFrozen' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _endGameState) == 0x0007B8, "Member 'ADBDGameState::_endGameState' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _scourgeHookManager) == 0x0007C0, "Member 'ADBDGameState::_scourgeHookManager' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _actorPairQueryEvaluatorComponent) == 0x0007C8, "Member 'ADBDGameState::_actorPairQueryEvaluatorComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _characterCollection) == 0x0007D8, "Member 'ADBDGameState::_characterCollection' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _collectableCollection) == 0x0007E0, "Member 'ADBDGameState::_collectableCollection' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _serverTimeProvider) == 0x0007E8, "Member 'ADBDGameState::_serverTimeProvider' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _inGameAssetPreloaderComponent) == 0x0007F0, "Member 'ADBDGameState::_inGameAssetPreloaderComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _onScreenDebugComponent) == 0x0007F8, "Member 'ADBDGameState::_onScreenDebugComponent' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _matchStartTime) == 0x000828, "Member 'ADBDGameState::_matchStartTime' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _isServerDedicated) == 0x000830, "Member 'ADBDGameState::_isServerDedicated' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _maxSurvivorCount) == 0x000834, "Member 'ADBDGameState::_maxSurvivorCount' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _serverBuildVersion) == 0x000838, "Member 'ADBDGameState::_serverBuildVersion' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _serverContentVersion) == 0x000848, "Member 'ADBDGameState::_serverContentVersion' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _introDuration) == 0x000858, "Member 'ADBDGameState::_introDuration' has a wrong offset!");
static_assert(offsetof(ADBDGameState, _leaveSpectateRequested) == 0x00085C, "Member 'ADBDGameState::_leaveSpectateRequested' has a wrong offset!");

// Class DeadByDaylight.BonusPointEventsManager
// 0x00B8 (0x00E8 - 0x0030)
class UBonusPointEventsManager final : public UObject
{
public:
	uint8                                         Pad_30[0xB8];                                      // 0x0030(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BonusPointEventsManager">();
	}
	static class UBonusPointEventsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBonusPointEventsManager>();
	}
};
static_assert(alignof(UBonusPointEventsManager) == 0x000008, "Wrong alignment on UBonusPointEventsManager");
static_assert(sizeof(UBonusPointEventsManager) == 0x0000E8, "Wrong size on UBonusPointEventsManager");

// Class DeadByDaylight.AttackableComponent
// 0x0000 (0x00B8 - 0x00B8)
class UAttackableComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttackableComponent">();
	}
	static class UAttackableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttackableComponent>();
	}
};
static_assert(alignof(UAttackableComponent) == 0x000008, "Wrong alignment on UAttackableComponent");
static_assert(sizeof(UAttackableComponent) == 0x0000B8, "Wrong size on UAttackableComponent");

// Class DeadByDaylight.BackendLoadoutManager
// 0x00A0 (0x00D8 - 0x0038)
class UBackendLoadoutManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xA0];                                      // 0x0038(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackendLoadoutManager">();
	}
	static class UBackendLoadoutManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackendLoadoutManager>();
	}
};
static_assert(alignof(UBackendLoadoutManager) == 0x000008, "Wrong alignment on UBackendLoadoutManager");
static_assert(sizeof(UBackendLoadoutManager) == 0x0000D8, "Wrong size on UBackendLoadoutManager");

// Class DeadByDaylight.PresentationItemProgressComponent
// 0x0000 (0x00B8 - 0x00B8)
class UPresentationItemProgressComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresentationItemProgressComponent">();
	}
	static class UPresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresentationItemProgressComponent>();
	}
};
static_assert(alignof(UPresentationItemProgressComponent) == 0x000008, "Wrong alignment on UPresentationItemProgressComponent");
static_assert(sizeof(UPresentationItemProgressComponent) == 0x0000B8, "Wrong size on UPresentationItemProgressComponent");

// Class DeadByDaylight.GameEventListenerCollectionComponent
// 0x0018 (0x00D0 - 0x00B8)
class UGameEventListenerCollectionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachGameEventDispatcher(class UGameEventDispatcher* gameEventDispatcher);
	void ListenToGameEvent(const struct FGameplayTag& eventType, TDelegate<void(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)> delegateToBind);
	void UnlistenToAllGameEvents();
	void UnlistenToGameEvent(const struct FGameplayTag& eventType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEventListenerCollectionComponent">();
	}
	static class UGameEventListenerCollectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEventListenerCollectionComponent>();
	}
};
static_assert(alignof(UGameEventListenerCollectionComponent) == 0x000008, "Wrong alignment on UGameEventListenerCollectionComponent");
static_assert(sizeof(UGameEventListenerCollectionComponent) == 0x0000D0, "Wrong size on UGameEventListenerCollectionComponent");

// Class DeadByDaylight.ActivationTimerElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerElapsedIconStrategy">();
	}
	static class UActivationTimerElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerElapsedIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerElapsedIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerElapsedIconStrategy");
static_assert(sizeof(UActivationTimerElapsedIconStrategy) == 0x000038, "Wrong size on UActivationTimerElapsedIconStrategy");

// Class DeadByDaylight.ClientStartupInitializerInterface
// 0x0000 (0x0000 - 0x0000)
class IClientStartupInitializerInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientStartupInitializerInterface">();
	}
	static class IClientStartupInitializerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IClientStartupInitializerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IClientStartupInitializerInterface) == 0x000001, "Wrong alignment on IClientStartupInitializerInterface");
static_assert(sizeof(IClientStartupInitializerInterface) == 0x000001, "Wrong size on IClientStartupInitializerInterface");

// Class DeadByDaylight.ScreenIndicatorWorldMarkerComponent
// 0x0010 (0x0230 - 0x0220)
class UScreenIndicatorWorldMarkerComponent : public USceneComponent
{
public:
	EHudScreenIndicatorType                       HudScreenIndicatorType;                            // 0x0218(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x3];                                      // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            VisibleDistanceRange;                              // 0x021C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenIndicatorWorldMarkerComponent">();
	}
	static class UScreenIndicatorWorldMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenIndicatorWorldMarkerComponent>();
	}
};
static_assert(alignof(UScreenIndicatorWorldMarkerComponent) == 0x000010, "Wrong alignment on UScreenIndicatorWorldMarkerComponent");
static_assert(sizeof(UScreenIndicatorWorldMarkerComponent) == 0x000230, "Wrong size on UScreenIndicatorWorldMarkerComponent");
static_assert(offsetof(UScreenIndicatorWorldMarkerComponent, HudScreenIndicatorType) == 0x000218, "Member 'UScreenIndicatorWorldMarkerComponent::HudScreenIndicatorType' has a wrong offset!");
static_assert(offsetof(UScreenIndicatorWorldMarkerComponent, VisibleDistanceRange) == 0x00021C, "Member 'UScreenIndicatorWorldMarkerComponent::VisibleDistanceRange' has a wrong offset!");

// Class DeadByDaylight.StateMachine
// 0x0078 (0x0130 - 0x00B8)
class alignas(0x10) UStateMachine : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x9];                                       // 0x00B8(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _enableJoinInProgress;                             // 0x00C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C2[0x56];                                      // 0x00C2(0x0056)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint16>                                _netStateIDStackInitial;                           // 0x0118(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_SetStateStack(const TArray<uint16>& netStateIDStack);
	void NetIDStackChanged();
	void Server_SetStateStack(const TArray<uint16>& netStateIDStack);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateMachine">();
	}
	static class UStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateMachine>();
	}
};
static_assert(alignof(UStateMachine) == 0x000010, "Wrong alignment on UStateMachine");
static_assert(sizeof(UStateMachine) == 0x000130, "Wrong size on UStateMachine");
static_assert(offsetof(UStateMachine, _enableJoinInProgress) == 0x0000C1, "Member 'UStateMachine::_enableJoinInProgress' has a wrong offset!");
static_assert(offsetof(UStateMachine, _netStateIDStackInitial) == 0x000118, "Member 'UStateMachine::_netStateIDStackInitial' has a wrong offset!");

// Class DeadByDaylight.WalesCypherHandler
// 0x0010 (0x0048 - 0x0038)
class UWalesCypherHandler final : public ULocalPlayerSubsystem
{
public:
	class UWalesCypherParameters*                 _walesCypherParams;                                // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WalesCypherHandler">();
	}
	static class UWalesCypherHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWalesCypherHandler>();
	}
};
static_assert(alignof(UWalesCypherHandler) == 0x000008, "Wrong alignment on UWalesCypherHandler");
static_assert(sizeof(UWalesCypherHandler) == 0x000048, "Wrong size on UWalesCypherHandler");
static_assert(offsetof(UWalesCypherHandler, _walesCypherParams) == 0x000038, "Member 'UWalesCypherHandler::_walesCypherParams' has a wrong offset!");

// Class DeadByDaylight.DBDEmblem
// 0x0050 (0x0108 - 0x00B8)
class UDBDEmblem : public UActorComponent
{
public:
	float                                         _points;                                           // 0x00B8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FProgressionPoints>             _progressionPoints;                                // 0x00C0(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    _definition;                                       // 0x00D0(0x0018)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x20];                                      // 0x00E8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_FinalizeReplication(const float points, const TArray<struct FProgressionPoints>& progressionPoints);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEmblem">();
	}
	static class UDBDEmblem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEmblem>();
	}
};
static_assert(alignof(UDBDEmblem) == 0x000008, "Wrong alignment on UDBDEmblem");
static_assert(sizeof(UDBDEmblem) == 0x000108, "Wrong size on UDBDEmblem");
static_assert(offsetof(UDBDEmblem, _points) == 0x0000B8, "Member 'UDBDEmblem::_points' has a wrong offset!");
static_assert(offsetof(UDBDEmblem, _progressionPoints) == 0x0000C0, "Member 'UDBDEmblem::_progressionPoints' has a wrong offset!");
static_assert(offsetof(UDBDEmblem, _definition) == 0x0000D0, "Member 'UDBDEmblem::_definition' has a wrong offset!");

// Class DeadByDaylight.ActionButton
// 0x0270 (0x05A8 - 0x0338)
class UActionButton final : public UMobileBaseUserWidget
{
public:
	struct FSlateBrush                            DefaultImage;                                      // 0x0338(0x0090)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	class UImage*                                 IconImage;                                         // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ToggleSmokeImage;                                  // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                Button;                                            // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultOpacity;                                    // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToggledOpacity;                                    // 0x03E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisabledOpacity;                                   // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            Normal;                                            // 0x03F0(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            Toggled;                                           // 0x0480(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            Disabled;                                          // 0x0510(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EActionButtonState                            _currentState;                                     // 0x05A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EActionButtonState                            _previousState;                                    // 0x05A1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A2[0x6];                                      // 0x05A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayBecameAvailableAnimation();
	void SetIcon(const struct FSlateBrush& slateBrush);
	void SetPreviousState();
	void SetSlateBrush(const struct FSlateBrush& InBrush);
	void SetState(EActionButtonState state);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionButton">();
	}
	static class UActionButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionButton>();
	}
};
static_assert(alignof(UActionButton) == 0x000008, "Wrong alignment on UActionButton");
static_assert(sizeof(UActionButton) == 0x0005A8, "Wrong size on UActionButton");
static_assert(offsetof(UActionButton, DefaultImage) == 0x000338, "Member 'UActionButton::DefaultImage' has a wrong offset!");
static_assert(offsetof(UActionButton, IconImage) == 0x0003C8, "Member 'UActionButton::IconImage' has a wrong offset!");
static_assert(offsetof(UActionButton, ToggleSmokeImage) == 0x0003D0, "Member 'UActionButton::ToggleSmokeImage' has a wrong offset!");
static_assert(offsetof(UActionButton, Button) == 0x0003D8, "Member 'UActionButton::Button' has a wrong offset!");
static_assert(offsetof(UActionButton, DefaultOpacity) == 0x0003E0, "Member 'UActionButton::DefaultOpacity' has a wrong offset!");
static_assert(offsetof(UActionButton, ToggledOpacity) == 0x0003E4, "Member 'UActionButton::ToggledOpacity' has a wrong offset!");
static_assert(offsetof(UActionButton, DisabledOpacity) == 0x0003E8, "Member 'UActionButton::DisabledOpacity' has a wrong offset!");
static_assert(offsetof(UActionButton, Normal) == 0x0003F0, "Member 'UActionButton::Normal' has a wrong offset!");
static_assert(offsetof(UActionButton, Toggled) == 0x000480, "Member 'UActionButton::Toggled' has a wrong offset!");
static_assert(offsetof(UActionButton, Disabled) == 0x000510, "Member 'UActionButton::Disabled' has a wrong offset!");
static_assert(offsetof(UActionButton, _currentState) == 0x0005A0, "Member 'UActionButton::_currentState' has a wrong offset!");
static_assert(offsetof(UActionButton, _previousState) == 0x0005A1, "Member 'UActionButton::_previousState' has a wrong offset!");

// Class DeadByDaylight.WorldRunawayMeshComponent
// 0x0020 (0x1020 - 0x1000)
class UWorldRunawayMeshComponent : public UDBDSkeletalMeshComponentBudgeted
{
public:
	float                                         ResetCooldown;                                     // 0x0FF8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _runAwayMustTickDuration;                          // 0x0FFC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _returnMustTickDuration;                           // 0x1000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1004[0x1C];                                    // 0x1004(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetShouldRunAway(bool should);
	void SetShouldRunAwayWithDelay(bool should, float delay);
	void SetShouldRunAwayWithRandomDelay(bool should, float delayRange);

	bool GetShouldRunAway() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldRunawayMeshComponent">();
	}
	static class UWorldRunawayMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldRunawayMeshComponent>();
	}
};
static_assert(alignof(UWorldRunawayMeshComponent) == 0x000010, "Wrong alignment on UWorldRunawayMeshComponent");
static_assert(sizeof(UWorldRunawayMeshComponent) == 0x001020, "Wrong size on UWorldRunawayMeshComponent");
static_assert(offsetof(UWorldRunawayMeshComponent, ResetCooldown) == 0x000FF8, "Member 'UWorldRunawayMeshComponent::ResetCooldown' has a wrong offset!");
static_assert(offsetof(UWorldRunawayMeshComponent, _runAwayMustTickDuration) == 0x000FFC, "Member 'UWorldRunawayMeshComponent::_runAwayMustTickDuration' has a wrong offset!");
static_assert(offsetof(UWorldRunawayMeshComponent, _returnMustTickDuration) == 0x001000, "Member 'UWorldRunawayMeshComponent::_returnMustTickDuration' has a wrong offset!");

// Class DeadByDaylight.UIController
// 0x0030 (0x0060 - 0x0030)
class UUIController final : public UObject
{
public:
	class UGFxObject*                             m_UIControllerObj;                                 // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMobileBaseUserWidget*                  _atlantaLoadingWidget;                             // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIController">();
	}
	static class UUIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIController>();
	}
};
static_assert(alignof(UUIController) == 0x000008, "Wrong alignment on UUIController");
static_assert(sizeof(UUIController) == 0x000060, "Wrong size on UUIController");
static_assert(offsetof(UUIController, m_UIControllerObj) == 0x000030, "Member 'UUIController::m_UIControllerObj' has a wrong offset!");
static_assert(offsetof(UUIController, _atlantaLoadingWidget) == 0x000038, "Member 'UUIController::_atlantaLoadingWidget' has a wrong offset!");

// Class DeadByDaylight.BaseCameraTargetingStrategy
// 0x0020 (0x0050 - 0x0030)
class UBaseCameraTargetingStrategy : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxFreeAngle;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxInputRotation;                                 // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _interpolationSpeed;                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _interpolationSpeedOutsideFreeMoveZone;            // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _target;                                           // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCameraTargetingStrategy">();
	}
	static class UBaseCameraTargetingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCameraTargetingStrategy>();
	}
};
static_assert(alignof(UBaseCameraTargetingStrategy) == 0x000008, "Wrong alignment on UBaseCameraTargetingStrategy");
static_assert(sizeof(UBaseCameraTargetingStrategy) == 0x000050, "Wrong size on UBaseCameraTargetingStrategy");
static_assert(offsetof(UBaseCameraTargetingStrategy, _maxFreeAngle) == 0x000038, "Member 'UBaseCameraTargetingStrategy::_maxFreeAngle' has a wrong offset!");
static_assert(offsetof(UBaseCameraTargetingStrategy, _maxInputRotation) == 0x00003C, "Member 'UBaseCameraTargetingStrategy::_maxInputRotation' has a wrong offset!");
static_assert(offsetof(UBaseCameraTargetingStrategy, _interpolationSpeed) == 0x000040, "Member 'UBaseCameraTargetingStrategy::_interpolationSpeed' has a wrong offset!");
static_assert(offsetof(UBaseCameraTargetingStrategy, _interpolationSpeedOutsideFreeMoveZone) == 0x000044, "Member 'UBaseCameraTargetingStrategy::_interpolationSpeedOutsideFreeMoveZone' has a wrong offset!");
static_assert(offsetof(UBaseCameraTargetingStrategy, _target) == 0x000048, "Member 'UBaseCameraTargetingStrategy::_target' has a wrong offset!");

// Class DeadByDaylight.UMGShadersPrecompilingProgressionWidget
// 0x0010 (0x0348 - 0x0338)
class UUMGShadersPrecompilingProgressionWidget final : public UMobileBaseUserWidget
{
public:
	class UProgressBar*                           _progressBar;                                      // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             _progressionText;                                  // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGShadersPrecompilingProgressionWidget">();
	}
	static class UUMGShadersPrecompilingProgressionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGShadersPrecompilingProgressionWidget>();
	}
};
static_assert(alignof(UUMGShadersPrecompilingProgressionWidget) == 0x000008, "Wrong alignment on UUMGShadersPrecompilingProgressionWidget");
static_assert(sizeof(UUMGShadersPrecompilingProgressionWidget) == 0x000348, "Wrong size on UUMGShadersPrecompilingProgressionWidget");
static_assert(offsetof(UUMGShadersPrecompilingProgressionWidget, _progressBar) == 0x000338, "Member 'UUMGShadersPrecompilingProgressionWidget::_progressBar' has a wrong offset!");
static_assert(offsetof(UUMGShadersPrecompilingProgressionWidget, _progressionText) == 0x000340, "Member 'UUMGShadersPrecompilingProgressionWidget::_progressionText' has a wrong offset!");

// Class DeadByDaylight.ActivationTimerRemainingCooldownElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActivationTimerRemainingCooldownElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivationTimerRemainingCooldownElapsedIconStrategy">();
	}
	static class UActivationTimerRemainingCooldownElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivationTimerRemainingCooldownElapsedIconStrategy>();
	}
};
static_assert(alignof(UActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000008, "Wrong alignment on UActivationTimerRemainingCooldownElapsedIconStrategy");
static_assert(sizeof(UActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000038, "Wrong size on UActivationTimerRemainingCooldownElapsedIconStrategy");

// Class DeadByDaylight.LegalMenuScreen
// 0x0048 (0x0168 - 0x0120)
class ULegalMenuScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0x48];                                     // 0x0120(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAcceptClick();
	void OnDeclineClick();
	void OnOkClick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LegalMenuScreen">();
	}
	static class ULegalMenuScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULegalMenuScreen>();
	}
};
static_assert(alignof(ULegalMenuScreen) == 0x000008, "Wrong alignment on ULegalMenuScreen");
static_assert(sizeof(ULegalMenuScreen) == 0x000168, "Wrong size on ULegalMenuScreen");

// Class DeadByDaylight.ActiveOnTimerOrApplicablePerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActiveOnTimerOrApplicablePerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveOnTimerOrApplicablePerkIconStrategy">();
	}
	static class UActiveOnTimerOrApplicablePerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveOnTimerOrApplicablePerkIconStrategy>();
	}
};
static_assert(alignof(UActiveOnTimerOrApplicablePerkIconStrategy) == 0x000008, "Wrong alignment on UActiveOnTimerOrApplicablePerkIconStrategy");
static_assert(sizeof(UActiveOnTimerOrApplicablePerkIconStrategy) == 0x000038, "Wrong size on UActiveOnTimerOrApplicablePerkIconStrategy");

// Class DeadByDaylight.MovementSettings
// 0x0000 (0x0000 - 0x0000)
class IMovementSettings final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementSettings">();
	}
	static class IMovementSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMovementSettings>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IMovementSettings) == 0x000001, "Wrong alignment on IMovementSettings");
static_assert(sizeof(IMovementSettings) == 0x000001, "Wrong size on IMovementSettings");

// Class DeadByDaylight.UMGAtlantaCreditsPopup
// 0x0020 (0x0358 - 0x0338)
class UUMGAtlantaCreditsPopup final : public UMobileBaseUserWidget
{
public:
	class UUMGHtmlRichText*                       RichTitleText;                                     // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGHtmlRichText*                       RichContentText;                                   // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _titleDefaultStyle;                                // 0x0348(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetCreditContent(const class FString& content);
	void SetCreditTitle(const class FString& title);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaCreditsPopup">();
	}
	static class UUMGAtlantaCreditsPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaCreditsPopup>();
	}
};
static_assert(alignof(UUMGAtlantaCreditsPopup) == 0x000008, "Wrong alignment on UUMGAtlantaCreditsPopup");
static_assert(sizeof(UUMGAtlantaCreditsPopup) == 0x000358, "Wrong size on UUMGAtlantaCreditsPopup");
static_assert(offsetof(UUMGAtlantaCreditsPopup, RichTitleText) == 0x000338, "Member 'UUMGAtlantaCreditsPopup::RichTitleText' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaCreditsPopup, RichContentText) == 0x000340, "Member 'UUMGAtlantaCreditsPopup::RichContentText' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaCreditsPopup, _titleDefaultStyle) == 0x000348, "Member 'UUMGAtlantaCreditsPopup::_titleDefaultStyle' has a wrong offset!");

// Class DeadByDaylight.KillerProjectile
// 0x0080 (0x0338 - 0x02B8)
class AKillerProjectile : public APhysicsBasedProjectile
{
public:
	uint8                                         Pad_2B8[0x48];                                     // 0x02B8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _killerProjectileAttemptGameEventTag;              // 0x0300(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UHitValidatorConfigurator*              _hitValidatorConfigurator;                         // 0x0310(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitValidatorComponent*                 _hitValidatorComponent;                            // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHitValidatorConfigName                       _hitValidationConfigName;                          // 0x0320(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_321[0x17];                                     // 0x0321(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetActiveSlashable(bool active);

	class ASlasherPlayer* GetLaunchingKiller() const;
	class UPrimitiveComponent* GetPlayerPrimitiveComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectile">();
	}
	static class AKillerProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKillerProjectile>();
	}
};
static_assert(alignof(AKillerProjectile) == 0x000008, "Wrong alignment on AKillerProjectile");
static_assert(sizeof(AKillerProjectile) == 0x000338, "Wrong size on AKillerProjectile");
static_assert(offsetof(AKillerProjectile, _killerProjectileAttemptGameEventTag) == 0x000300, "Member 'AKillerProjectile::_killerProjectileAttemptGameEventTag' has a wrong offset!");
static_assert(offsetof(AKillerProjectile, _hitValidatorConfigurator) == 0x000310, "Member 'AKillerProjectile::_hitValidatorConfigurator' has a wrong offset!");
static_assert(offsetof(AKillerProjectile, _hitValidatorComponent) == 0x000318, "Member 'AKillerProjectile::_hitValidatorComponent' has a wrong offset!");
static_assert(offsetof(AKillerProjectile, _hitValidationConfigName) == 0x000320, "Member 'AKillerProjectile::_hitValidationConfigName' has a wrong offset!");

// Class DeadByDaylight.BaseLinkedVomitProjectile
// 0x0070 (0x03A8 - 0x0338)
class ABaseLinkedVomitProjectile final : public AKillerProjectile
{
public:
	bool                                          _useSplashDamage;                                  // 0x0338(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _passThroughSurvivors;                             // 0x0339(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33A[0x6];                                      // 0x033A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UPoolableProjectileComponent*           _poolableProjectile;                               // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void()>              OnDeactivateOrLaunch;                              // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               _vomitTrail;                                       // 0x0358(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USplineMeshComponent*                   _splineMesh;                                       // 0x0360(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _splashDamageSphere;                               // 0x0368(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           _akAudioVomitProjectile;                           // 0x0370(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _vomitSplashCamper;                                // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystem*                        _vomitSplash;                                      // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          _akAudioEventAudioEventVomitSplash;                // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              _minDecalSize;                                     // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              _maxDecalSize;                                     // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isSuperVomit;                                     // 0x03A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A1[0x7];                                      // 0x03A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NativeExplode(const struct FImpactInfo& impactInfo);
	void OnAffectInteractable(class AInteractable* interactable, class USceneComponent* hitComponent);
	void OnAffectSurvivor(class ACamperPlayer* camperPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseLinkedVomitProjectile">();
	}
	static class ABaseLinkedVomitProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseLinkedVomitProjectile>();
	}
};
static_assert(alignof(ABaseLinkedVomitProjectile) == 0x000008, "Wrong alignment on ABaseLinkedVomitProjectile");
static_assert(sizeof(ABaseLinkedVomitProjectile) == 0x0003A8, "Wrong size on ABaseLinkedVomitProjectile");
static_assert(offsetof(ABaseLinkedVomitProjectile, _useSplashDamage) == 0x000338, "Member 'ABaseLinkedVomitProjectile::_useSplashDamage' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _passThroughSurvivors) == 0x000339, "Member 'ABaseLinkedVomitProjectile::_passThroughSurvivors' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _poolableProjectile) == 0x000340, "Member 'ABaseLinkedVomitProjectile::_poolableProjectile' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, OnDeactivateOrLaunch) == 0x000348, "Member 'ABaseLinkedVomitProjectile::OnDeactivateOrLaunch' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _vomitTrail) == 0x000358, "Member 'ABaseLinkedVomitProjectile::_vomitTrail' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _splineMesh) == 0x000360, "Member 'ABaseLinkedVomitProjectile::_splineMesh' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _splashDamageSphere) == 0x000368, "Member 'ABaseLinkedVomitProjectile::_splashDamageSphere' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _akAudioVomitProjectile) == 0x000370, "Member 'ABaseLinkedVomitProjectile::_akAudioVomitProjectile' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _vomitSplashCamper) == 0x000378, "Member 'ABaseLinkedVomitProjectile::_vomitSplashCamper' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _vomitSplash) == 0x000380, "Member 'ABaseLinkedVomitProjectile::_vomitSplash' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _akAudioEventAudioEventVomitSplash) == 0x000388, "Member 'ABaseLinkedVomitProjectile::_akAudioEventAudioEventVomitSplash' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _minDecalSize) == 0x000390, "Member 'ABaseLinkedVomitProjectile::_minDecalSize' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _maxDecalSize) == 0x000398, "Member 'ABaseLinkedVomitProjectile::_maxDecalSize' has a wrong offset!");
static_assert(offsetof(ABaseLinkedVomitProjectile, _isSuperVomit) == 0x0003A0, "Member 'ABaseLinkedVomitProjectile::_isSuperVomit' has a wrong offset!");

// Class DeadByDaylight.UMGLobbyOfferingWidget
// 0x0060 (0x0398 - 0x0338)
class UUMGLobbyOfferingWidget final : public UMobileBaseUserWidget
{
public:
	class UCanvasPanel*                           CanvasOffering;                                    // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   LobbyOfferingItemClass;                            // 0x0340(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x28];                                     // 0x0370(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLobbyOfferingWidget">();
	}
	static class UUMGLobbyOfferingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLobbyOfferingWidget>();
	}
};
static_assert(alignof(UUMGLobbyOfferingWidget) == 0x000008, "Wrong alignment on UUMGLobbyOfferingWidget");
static_assert(sizeof(UUMGLobbyOfferingWidget) == 0x000398, "Wrong size on UUMGLobbyOfferingWidget");
static_assert(offsetof(UUMGLobbyOfferingWidget, CanvasOffering) == 0x000338, "Member 'UUMGLobbyOfferingWidget::CanvasOffering' has a wrong offset!");
static_assert(offsetof(UUMGLobbyOfferingWidget, LobbyOfferingItemClass) == 0x000340, "Member 'UUMGLobbyOfferingWidget::LobbyOfferingItemClass' has a wrong offset!");

// Class DeadByDaylight.ActiveOnTimerPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActiveOnTimerPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveOnTimerPerkIconStrategy">();
	}
	static class UActiveOnTimerPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveOnTimerPerkIconStrategy>();
	}
};
static_assert(alignof(UActiveOnTimerPerkIconStrategy) == 0x000008, "Wrong alignment on UActiveOnTimerPerkIconStrategy");
static_assert(sizeof(UActiveOnTimerPerkIconStrategy) == 0x000038, "Wrong size on UActiveOnTimerPerkIconStrategy");

// Class DeadByDaylight.GateFactory
// 0x0000 (0x0230 - 0x0230)
class AGateFactory final : public AActor
{
public:
	class AGate* GetGate(EGateType gateType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GateFactory">();
	}
	static class AGateFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGateFactory>();
	}
};
static_assert(alignof(AGateFactory) == 0x000008, "Wrong alignment on AGateFactory");
static_assert(sizeof(AGateFactory) == 0x000230, "Wrong size on AGateFactory");

// Class DeadByDaylight.ActiveWhenApplicablePerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActiveWhenApplicablePerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveWhenApplicablePerkIconStrategy">();
	}
	static class UActiveWhenApplicablePerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveWhenApplicablePerkIconStrategy>();
	}
};
static_assert(alignof(UActiveWhenApplicablePerkIconStrategy) == 0x000008, "Wrong alignment on UActiveWhenApplicablePerkIconStrategy");
static_assert(sizeof(UActiveWhenApplicablePerkIconStrategy) == 0x000038, "Wrong size on UActiveWhenApplicablePerkIconStrategy");

// Class DeadByDaylight.BaseBloodwebContentAdapter
// 0x0030 (0x0060 - 0x0030)
class UBaseBloodwebContentAdapter : public UObject
{
public:
	class UBloodwebTunables*                      _bloodwebTunables;                                 // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBloodwebEntity*                        _entity;                                           // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TScriptInterface<class IDBDBloodwebDefinitionBase> _bloodwebDefinition;                          // 0x0040(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseBloodwebContentAdapter">();
	}
	static class UBaseBloodwebContentAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseBloodwebContentAdapter>();
	}
};
static_assert(alignof(UBaseBloodwebContentAdapter) == 0x000008, "Wrong alignment on UBaseBloodwebContentAdapter");
static_assert(sizeof(UBaseBloodwebContentAdapter) == 0x000060, "Wrong size on UBaseBloodwebContentAdapter");
static_assert(offsetof(UBaseBloodwebContentAdapter, _bloodwebTunables) == 0x000030, "Member 'UBaseBloodwebContentAdapter::_bloodwebTunables' has a wrong offset!");
static_assert(offsetof(UBaseBloodwebContentAdapter, _entity) == 0x000038, "Member 'UBaseBloodwebContentAdapter::_entity' has a wrong offset!");
static_assert(offsetof(UBaseBloodwebContentAdapter, _bloodwebDefinition) == 0x000040, "Member 'UBaseBloodwebContentAdapter::_bloodwebDefinition' has a wrong offset!");

// Class DeadByDaylight.BackendBloodwebContentAdapter
// 0x00A8 (0x0108 - 0x0060)
class UBackendBloodwebContentAdapter final : public UBaseBloodwebContentAdapter
{
public:
	uint8                                         Pad_60[0xA0];                                      // 0x0060(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodwebGenerator*                     _bloodwebBuilder;                                  // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackendBloodwebContentAdapter">();
	}
	static class UBackendBloodwebContentAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackendBloodwebContentAdapter>();
	}
};
static_assert(alignof(UBackendBloodwebContentAdapter) == 0x000008, "Wrong alignment on UBackendBloodwebContentAdapter");
static_assert(sizeof(UBackendBloodwebContentAdapter) == 0x000108, "Wrong size on UBackendBloodwebContentAdapter");
static_assert(offsetof(UBackendBloodwebContentAdapter, _bloodwebBuilder) == 0x000100, "Member 'UBackendBloodwebContentAdapter::_bloodwebBuilder' has a wrong offset!");

// Class DeadByDaylight.SurvivorCameraLagStrategy
// 0x0060 (0x0118 - 0x00B8)
class USurvivorCameraLagStrategy final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x60];                                      // 0x00B8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorCameraLagStrategy">();
	}
	static class USurvivorCameraLagStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorCameraLagStrategy>();
	}
};
static_assert(alignof(USurvivorCameraLagStrategy) == 0x000008, "Wrong alignment on USurvivorCameraLagStrategy");
static_assert(sizeof(USurvivorCameraLagStrategy) == 0x000118, "Wrong size on USurvivorCameraLagStrategy");

// Class DeadByDaylight.ActiveWhenKOdAndCooldownTimerPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UActiveWhenKOdAndCooldownTimerPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActiveWhenKOdAndCooldownTimerPerkIconStrategy">();
	}
	static class UActiveWhenKOdAndCooldownTimerPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActiveWhenKOdAndCooldownTimerPerkIconStrategy>();
	}
};
static_assert(alignof(UActiveWhenKOdAndCooldownTimerPerkIconStrategy) == 0x000008, "Wrong alignment on UActiveWhenKOdAndCooldownTimerPerkIconStrategy");
static_assert(sizeof(UActiveWhenKOdAndCooldownTimerPerkIconStrategy) == 0x000038, "Wrong size on UActiveWhenKOdAndCooldownTimerPerkIconStrategy");

// Class DeadByDaylight.ActorClipperComponent
// 0x0080 (0x0138 - 0x00B8)
class UActorClipperComponent final : public UActorComponent
{
public:
	class USphereComponent*                       Shape;                                             // 0x00B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FClippedActor>     _clippedActors;                                    // 0x00C0(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UPrimitiveCollection>    _clippables;                                       // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x20];                                     // 0x0118(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCameraChanged(EDBDCameraSocketID socketId);
	void OnOwnerLocallyObservedChanged(bool locallyObserved);
	void SetPrimitiveCollection(const class UPrimitiveCollection* clippables);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorClipperComponent">();
	}
	static class UActorClipperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorClipperComponent>();
	}
};
static_assert(alignof(UActorClipperComponent) == 0x000008, "Wrong alignment on UActorClipperComponent");
static_assert(sizeof(UActorClipperComponent) == 0x000138, "Wrong size on UActorClipperComponent");
static_assert(offsetof(UActorClipperComponent, Shape) == 0x0000B8, "Member 'UActorClipperComponent::Shape' has a wrong offset!");
static_assert(offsetof(UActorClipperComponent, _clippedActors) == 0x0000C0, "Member 'UActorClipperComponent::_clippedActors' has a wrong offset!");
static_assert(offsetof(UActorClipperComponent, _clippables) == 0x000110, "Member 'UActorClipperComponent::_clippables' has a wrong offset!");

// Class DeadByDaylight.Highlightable
// 0x0000 (0x0000 - 0x0000)
class IHighlightable final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Highlightable">();
	}
	static class IHighlightable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHighlightable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IHighlightable) == 0x000001, "Wrong alignment on IHighlightable");
static_assert(sizeof(IHighlightable) == 0x000001, "Wrong size on IHighlightable");

// Class DeadByDaylight.ActorDependency
// 0x0010 (0x00C8 - 0x00B8)
class UActorDependency final : public UActorComponent
{
public:
	TArray<struct FDependency>                    Dependencies;                                      // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorDependency">();
	}
	static class UActorDependency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorDependency>();
	}
};
static_assert(alignof(UActorDependency) == 0x000008, "Wrong alignment on UActorDependency");
static_assert(sizeof(UActorDependency) == 0x0000C8, "Wrong size on UActorDependency");
static_assert(offsetof(UActorDependency, Dependencies) == 0x0000B8, "Member 'UActorDependency::Dependencies' has a wrong offset!");

// Class DeadByDaylight.IniAssetLibrary
// 0x0010 (0x00C0 - 0x00B0)
class UIniAssetLibrary final : public UAssetLibrary
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IniAssetLibrary">();
	}
	static class UIniAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIniAssetLibrary>();
	}
};
static_assert(alignof(UIniAssetLibrary) == 0x000008, "Wrong alignment on UIniAssetLibrary");
static_assert(sizeof(UIniAssetLibrary) == 0x0000C0, "Wrong size on UIniAssetLibrary");

// Class DeadByDaylight.UMGGenericPopup
// 0x00E8 (0x0420 - 0x0338)
class UUMGGenericPopup : public UMobileBaseUserWidget
{
public:
	class URichTextBlock*                         Title;                                             // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGHtmlRichText*                       Message;                                           // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 TitleBackground;                                   // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 TitleSmoke;                                        // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGPopupButton*                        RegressionPopupButton;                             // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGPopupButton*                        AlternativePopupButton;                            // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGPopupButton*                        ProgressionPopupButton;                            // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            ErrorTitleSmokeColor;                              // 0x0370(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            ErrorTitleBackgroundColor;                         // 0x0398(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            DefaultTitleSmokeColor;                            // 0x03C0(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSlateColor                            DefaultTitleBackgroundColor;                       // 0x03E8(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_410[0x10];                                     // 0x0410(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPopupAppearance();
	void OnPopupDisappearance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGGenericPopup">();
	}
	static class UUMGGenericPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGGenericPopup>();
	}
};
static_assert(alignof(UUMGGenericPopup) == 0x000008, "Wrong alignment on UUMGGenericPopup");
static_assert(sizeof(UUMGGenericPopup) == 0x000420, "Wrong size on UUMGGenericPopup");
static_assert(offsetof(UUMGGenericPopup, Title) == 0x000338, "Member 'UUMGGenericPopup::Title' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, Message) == 0x000340, "Member 'UUMGGenericPopup::Message' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, TitleBackground) == 0x000348, "Member 'UUMGGenericPopup::TitleBackground' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, TitleSmoke) == 0x000350, "Member 'UUMGGenericPopup::TitleSmoke' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, RegressionPopupButton) == 0x000358, "Member 'UUMGGenericPopup::RegressionPopupButton' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, AlternativePopupButton) == 0x000360, "Member 'UUMGGenericPopup::AlternativePopupButton' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, ProgressionPopupButton) == 0x000368, "Member 'UUMGGenericPopup::ProgressionPopupButton' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, ErrorTitleSmokeColor) == 0x000370, "Member 'UUMGGenericPopup::ErrorTitleSmokeColor' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, ErrorTitleBackgroundColor) == 0x000398, "Member 'UUMGGenericPopup::ErrorTitleBackgroundColor' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, DefaultTitleSmokeColor) == 0x0003C0, "Member 'UUMGGenericPopup::DefaultTitleSmokeColor' has a wrong offset!");
static_assert(offsetof(UUMGGenericPopup, DefaultTitleBackgroundColor) == 0x0003E8, "Member 'UUMGGenericPopup::DefaultTitleBackgroundColor' has a wrong offset!");

// Class DeadByDaylight.BlindingEffectorInterface
// 0x0000 (0x0000 - 0x0000)
class IBlindingEffectorInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindingEffectorInterface">();
	}
	static class IBlindingEffectorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBlindingEffectorInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IBlindingEffectorInterface) == 0x000001, "Wrong alignment on IBlindingEffectorInterface");
static_assert(sizeof(IBlindingEffectorInterface) == 0x000001, "Wrong size on IBlindingEffectorInterface");

// Class DeadByDaylight.UMGBaseSideMainMenuButton
// 0x0018 (0x0480 - 0x0468)
class UUMGBaseSideMainMenuButton : public UUMGBaseButtonWidget
{
public:
	class UImage*                                 NotificationBadge;                                 // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _baseTextOpacity;                                  // 0x0470(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _highlightTextOpacity;                             // 0x0474(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _baseIconOpacity;                                  // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _highlightIconOpacity;                             // 0x047C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBaseSideMainMenuButton">();
	}
	static class UUMGBaseSideMainMenuButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBaseSideMainMenuButton>();
	}
};
static_assert(alignof(UUMGBaseSideMainMenuButton) == 0x000008, "Wrong alignment on UUMGBaseSideMainMenuButton");
static_assert(sizeof(UUMGBaseSideMainMenuButton) == 0x000480, "Wrong size on UUMGBaseSideMainMenuButton");
static_assert(offsetof(UUMGBaseSideMainMenuButton, NotificationBadge) == 0x000468, "Member 'UUMGBaseSideMainMenuButton::NotificationBadge' has a wrong offset!");
static_assert(offsetof(UUMGBaseSideMainMenuButton, _baseTextOpacity) == 0x000470, "Member 'UUMGBaseSideMainMenuButton::_baseTextOpacity' has a wrong offset!");
static_assert(offsetof(UUMGBaseSideMainMenuButton, _highlightTextOpacity) == 0x000474, "Member 'UUMGBaseSideMainMenuButton::_highlightTextOpacity' has a wrong offset!");
static_assert(offsetof(UUMGBaseSideMainMenuButton, _baseIconOpacity) == 0x000478, "Member 'UUMGBaseSideMainMenuButton::_baseIconOpacity' has a wrong offset!");
static_assert(offsetof(UUMGBaseSideMainMenuButton, _highlightIconOpacity) == 0x00047C, "Member 'UUMGBaseSideMainMenuButton::_highlightIconOpacity' has a wrong offset!");

// Class DeadByDaylight.UMGMenuBaseBanner
// 0x0028 (0x04A8 - 0x0480)
class UUMGMenuBaseBanner : public UUMGBaseSideMainMenuButton
{
public:
	class UImage*                                 BannerImage;                                       // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Title;                                             // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TScriptInterface<class ISlateTextureAtlasInterface> DefaultBanner;                               // 0x0490(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0x8];                                      // 0x04A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGMenuBaseBanner">();
	}
	static class UUMGMenuBaseBanner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGMenuBaseBanner>();
	}
};
static_assert(alignof(UUMGMenuBaseBanner) == 0x000008, "Wrong alignment on UUMGMenuBaseBanner");
static_assert(sizeof(UUMGMenuBaseBanner) == 0x0004A8, "Wrong size on UUMGMenuBaseBanner");
static_assert(offsetof(UUMGMenuBaseBanner, BannerImage) == 0x000480, "Member 'UUMGMenuBaseBanner::BannerImage' has a wrong offset!");
static_assert(offsetof(UUMGMenuBaseBanner, Title) == 0x000488, "Member 'UUMGMenuBaseBanner::Title' has a wrong offset!");
static_assert(offsetof(UUMGMenuBaseBanner, DefaultBanner) == 0x000490, "Member 'UUMGMenuBaseBanner::DefaultBanner' has a wrong offset!");

// Class DeadByDaylight.UMGMenuMarketingBanner
// 0x0008 (0x04B0 - 0x04A8)
class UUMGMenuMarketingBanner final : public UUMGMenuBaseBanner
{
public:
	class UTextBlock*                             SubTitle;                                          // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGMenuMarketingBanner">();
	}
	static class UUMGMenuMarketingBanner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGMenuMarketingBanner>();
	}
};
static_assert(alignof(UUMGMenuMarketingBanner) == 0x000008, "Wrong alignment on UUMGMenuMarketingBanner");
static_assert(sizeof(UUMGMenuMarketingBanner) == 0x0004B0, "Wrong size on UUMGMenuMarketingBanner");
static_assert(offsetof(UUMGMenuMarketingBanner, SubTitle) == 0x0004A8, "Member 'UUMGMenuMarketingBanner::SubTitle' has a wrong offset!");

// Class DeadByDaylight.ActorDetectorComponent
// 0x0028 (0x00E0 - 0x00B8)
class UActorDetectorComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class AActor* actor)> OnActorDetected;                             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         CollectedTypes;                                    // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _primitive;                                        // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void SetDetectionPrimitive(class UPrimitiveComponent* primitive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorDetectorComponent">();
	}
	static class UActorDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorDetectorComponent>();
	}
};
static_assert(alignof(UActorDetectorComponent) == 0x000008, "Wrong alignment on UActorDetectorComponent");
static_assert(sizeof(UActorDetectorComponent) == 0x0000E0, "Wrong size on UActorDetectorComponent");
static_assert(offsetof(UActorDetectorComponent, OnActorDetected) == 0x0000B8, "Member 'UActorDetectorComponent::OnActorDetected' has a wrong offset!");
static_assert(offsetof(UActorDetectorComponent, CollectedTypes) == 0x0000C8, "Member 'UActorDetectorComponent::CollectedTypes' has a wrong offset!");
static_assert(offsetof(UActorDetectorComponent, _primitive) == 0x0000D8, "Member 'UActorDetectorComponent::_primitive' has a wrong offset!");

// Class DeadByDaylight.ItemTooltipWidget
// 0x0020 (0x0390 - 0x0370)
class UItemTooltipWidget final : public UBaseTooltipWidget
{
public:
	class UTextBlock*                             RarityLabel;                                       // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGHtmlRichText*                       WarningText;                                       // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HeaderSmoke;                                       // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HeaderBackground;                                  // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemTooltipWidget">();
	}
	static class UItemTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemTooltipWidget>();
	}
};
static_assert(alignof(UItemTooltipWidget) == 0x000008, "Wrong alignment on UItemTooltipWidget");
static_assert(sizeof(UItemTooltipWidget) == 0x000390, "Wrong size on UItemTooltipWidget");
static_assert(offsetof(UItemTooltipWidget, RarityLabel) == 0x000370, "Member 'UItemTooltipWidget::RarityLabel' has a wrong offset!");
static_assert(offsetof(UItemTooltipWidget, WarningText) == 0x000378, "Member 'UItemTooltipWidget::WarningText' has a wrong offset!");
static_assert(offsetof(UItemTooltipWidget, HeaderSmoke) == 0x000380, "Member 'UItemTooltipWidget::HeaderSmoke' has a wrong offset!");
static_assert(offsetof(UItemTooltipWidget, HeaderBackground) == 0x000388, "Member 'UItemTooltipWidget::HeaderBackground' has a wrong offset!");

// Class DeadByDaylight.ActorKnowledgeCollection
// 0x0050 (0x0108 - 0x00B8)
class UActorKnowledgeCollection final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _actors;                                           // 0x00D0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _previousActors;                                   // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          _available;                                        // 0x00F0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             _possessor;                                        // 0x00F8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EKnowledgeSharingType                         _sharing;                                          // 0x0100(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Authority_Add(class AActor* actor);
	void Authority_Append(const TArray<class AActor*>& actors);
	void Authority_Empty();
	void Authority_Remove(class AActor* actor);
	void Authority_SetAvailable(bool value);
	void Authority_SetPossessor(class ACharacter* possessor);
	void Authority_SetSharingType(EKnowledgeSharingType value);
	void Local_SetAvailable(bool value);
	void OnRep_Actors();

	bool Contains(class AActor* actor) const;
	bool IsAvailable(const class ACharacter* character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorKnowledgeCollection">();
	}
	static class UActorKnowledgeCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorKnowledgeCollection>();
	}
};
static_assert(alignof(UActorKnowledgeCollection) == 0x000008, "Wrong alignment on UActorKnowledgeCollection");
static_assert(sizeof(UActorKnowledgeCollection) == 0x000108, "Wrong size on UActorKnowledgeCollection");
static_assert(offsetof(UActorKnowledgeCollection, _actors) == 0x0000D0, "Member 'UActorKnowledgeCollection::_actors' has a wrong offset!");
static_assert(offsetof(UActorKnowledgeCollection, _previousActors) == 0x0000E0, "Member 'UActorKnowledgeCollection::_previousActors' has a wrong offset!");
static_assert(offsetof(UActorKnowledgeCollection, _available) == 0x0000F0, "Member 'UActorKnowledgeCollection::_available' has a wrong offset!");
static_assert(offsetof(UActorKnowledgeCollection, _possessor) == 0x0000F8, "Member 'UActorKnowledgeCollection::_possessor' has a wrong offset!");
static_assert(offsetof(UActorKnowledgeCollection, _sharing) == 0x000100, "Member 'UActorKnowledgeCollection::_sharing' has a wrong offset!");

// Class DeadByDaylight.AtlantaPartyFlowHandler
// 0x0248 (0x0278 - 0x0030)
class UAtlantaPartyFlowHandler final : public UObject
{
public:
	uint8                                         Pad_30[0x248];                                     // 0x0030(0x0248)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisplayPartyFlowHandlerInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaPartyFlowHandler">();
	}
	static class UAtlantaPartyFlowHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaPartyFlowHandler>();
	}
};
static_assert(alignof(UAtlantaPartyFlowHandler) == 0x000008, "Wrong alignment on UAtlantaPartyFlowHandler");
static_assert(sizeof(UAtlantaPartyFlowHandler) == 0x000278, "Wrong size on UAtlantaPartyFlowHandler");

// Class DeadByDaylight.ActorSpawner
// 0x00B0 (0x02D0 - 0x0220)
class UActorSpawner : public USceneComponent
{
public:
	uint8                                         Pad_218[0x10];                                     // 0x0218(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EGameplayElementType                          Type;                                              // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x7];                                      // 0x0229(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   Visualization;                                     // 0x0230(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActivatedByDefault;                                // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActorSpawnerProperties>        ActivatedSceneElement;                             // 0x0268(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FActorSpawnerProperties>        DeactivatedSceneElement;                           // 0x0278(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnCountMax;                                     // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnPriorityTier;                                 // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AActor* actorSpawned)> OnAsyncActorSpawned;                  // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          WeightInfluenceable;                               // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          WeightInfluencer;                                  // 0x02B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B2[0x2];                                      // 0x02B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Cost;                                              // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _toSpawn;                                          // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  _spawnedActorOnAuthority;                          // 0x02C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_SpawnActorAsyncEvent();
	void AuthoritySelect(bool selected);
	void EditorForceSpawnVisualization();

	class AActor* AuthorityGetSpawnedActor() const;
	bool IsEnabled() const;
	bool UseActivatedElement() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorSpawner">();
	}
	static class UActorSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorSpawner>();
	}
};
static_assert(alignof(UActorSpawner) == 0x000010, "Wrong alignment on UActorSpawner");
static_assert(sizeof(UActorSpawner) == 0x0002D0, "Wrong size on UActorSpawner");
static_assert(offsetof(UActorSpawner, Type) == 0x000228, "Member 'UActorSpawner::Type' has a wrong offset!");
static_assert(offsetof(UActorSpawner, Visualization) == 0x000230, "Member 'UActorSpawner::Visualization' has a wrong offset!");
static_assert(offsetof(UActorSpawner, ActivatedByDefault) == 0x000260, "Member 'UActorSpawner::ActivatedByDefault' has a wrong offset!");
static_assert(offsetof(UActorSpawner, ActivatedSceneElement) == 0x000268, "Member 'UActorSpawner::ActivatedSceneElement' has a wrong offset!");
static_assert(offsetof(UActorSpawner, DeactivatedSceneElement) == 0x000278, "Member 'UActorSpawner::DeactivatedSceneElement' has a wrong offset!");
static_assert(offsetof(UActorSpawner, Weight) == 0x000288, "Member 'UActorSpawner::Weight' has a wrong offset!");
static_assert(offsetof(UActorSpawner, SpawnCountMax) == 0x00028C, "Member 'UActorSpawner::SpawnCountMax' has a wrong offset!");
static_assert(offsetof(UActorSpawner, SpawnPriorityTier) == 0x000290, "Member 'UActorSpawner::SpawnPriorityTier' has a wrong offset!");
static_assert(offsetof(UActorSpawner, OnAsyncActorSpawned) == 0x000298, "Member 'UActorSpawner::OnAsyncActorSpawned' has a wrong offset!");
static_assert(offsetof(UActorSpawner, WeightInfluenceable) == 0x0002B0, "Member 'UActorSpawner::WeightInfluenceable' has a wrong offset!");
static_assert(offsetof(UActorSpawner, WeightInfluencer) == 0x0002B1, "Member 'UActorSpawner::WeightInfluencer' has a wrong offset!");
static_assert(offsetof(UActorSpawner, Cost) == 0x0002B4, "Member 'UActorSpawner::Cost' has a wrong offset!");
static_assert(offsetof(UActorSpawner, _toSpawn) == 0x0002B8, "Member 'UActorSpawner::_toSpawn' has a wrong offset!");
static_assert(offsetof(UActorSpawner, _spawnedActorOnAuthority) == 0x0002C8, "Member 'UActorSpawner::_spawnedActorOnAuthority' has a wrong offset!");

// Class DeadByDaylight.GeneratorRepairWithGenericPerksEscapeAchievement
// 0x0028 (0x00E0 - 0x00B8)
class UGeneratorRepairWithGenericPerksEscapeAchievement final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorRepairWithGenericPerksEscapeAchievement">();
	}
	static class UGeneratorRepairWithGenericPerksEscapeAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorRepairWithGenericPerksEscapeAchievement>();
	}
};
static_assert(alignof(UGeneratorRepairWithGenericPerksEscapeAchievement) == 0x000008, "Wrong alignment on UGeneratorRepairWithGenericPerksEscapeAchievement");
static_assert(sizeof(UGeneratorRepairWithGenericPerksEscapeAchievement) == 0x0000E0, "Wrong size on UGeneratorRepairWithGenericPerksEscapeAchievement");

// Class DeadByDaylight.ObjectRandomizer
// 0x0010 (0x0230 - 0x0220)
class UObjectRandomizer : public USceneComponent
{
public:
	TArray<class UActorSpawner*>                  Spawners;                                          // 0x0218(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         MinPopulation;                                     // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPopulation;                                     // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectRandomizer">();
	}
	static class UObjectRandomizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectRandomizer>();
	}
};
static_assert(alignof(UObjectRandomizer) == 0x000010, "Wrong alignment on UObjectRandomizer");
static_assert(sizeof(UObjectRandomizer) == 0x000230, "Wrong size on UObjectRandomizer");
static_assert(offsetof(UObjectRandomizer, Spawners) == 0x000218, "Member 'UObjectRandomizer::Spawners' has a wrong offset!");
static_assert(offsetof(UObjectRandomizer, MinPopulation) == 0x000228, "Member 'UObjectRandomizer::MinPopulation' has a wrong offset!");
static_assert(offsetof(UObjectRandomizer, MaxPopulation) == 0x00022C, "Member 'UObjectRandomizer::MaxPopulation' has a wrong offset!");

// Class DeadByDaylight.ActorSpawnerRandomizer
// 0x0020 (0x0250 - 0x0230)
class UActorSpawnerRandomizer final : public UObjectRandomizer
{
public:
	TArray<struct FSpawnerElement>                ActivatedSpawnerContentLists;                      // 0x0230(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSpawnerElement>                DeactivatedSpawnerContentLists;                    // 0x0240(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorSpawnerRandomizer">();
	}
	static class UActorSpawnerRandomizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorSpawnerRandomizer>();
	}
};
static_assert(alignof(UActorSpawnerRandomizer) == 0x000010, "Wrong alignment on UActorSpawnerRandomizer");
static_assert(sizeof(UActorSpawnerRandomizer) == 0x000250, "Wrong size on UActorSpawnerRandomizer");
static_assert(offsetof(UActorSpawnerRandomizer, ActivatedSpawnerContentLists) == 0x000230, "Member 'UActorSpawnerRandomizer::ActivatedSpawnerContentLists' has a wrong offset!");
static_assert(offsetof(UActorSpawnerRandomizer, DeactivatedSpawnerContentLists) == 0x000240, "Member 'UActorSpawnerRandomizer::DeactivatedSpawnerContentLists' has a wrong offset!");

// Class DeadByDaylight.UMGCustomizationItemPriceWidget
// 0x0100 (0x0438 - 0x0338)
class UUMGCustomizationItemPriceWidget : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             CurrencyValue;                                     // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DiscountPercentageContainer;                       // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DiscountPercentage;                                // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CurrencyIcon;                                      // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ECurrencyType, TSoftObjectPtr<class UTexture2D>> CurrencyTextures;                          // 0x0358(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FSlateColor                            AffordableCurrencyTextColor;                       // 0x03A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            AffordableSpecialCurrencyTextColor;                // 0x03D0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            NonAffordableCurrencyTextColor;                    // 0x03F8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FString                                 _itemId;                                           // 0x0420(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECurrencyType                                 _currencyType;                                     // 0x0430(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasDiscountPercentage;                            // 0x0431(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_432[0x6];                                      // 0x0432(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCustomizationItemPriceWidget">();
	}
	static class UUMGCustomizationItemPriceWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCustomizationItemPriceWidget>();
	}
};
static_assert(alignof(UUMGCustomizationItemPriceWidget) == 0x000008, "Wrong alignment on UUMGCustomizationItemPriceWidget");
static_assert(sizeof(UUMGCustomizationItemPriceWidget) == 0x000438, "Wrong size on UUMGCustomizationItemPriceWidget");
static_assert(offsetof(UUMGCustomizationItemPriceWidget, CurrencyValue) == 0x000338, "Member 'UUMGCustomizationItemPriceWidget::CurrencyValue' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemPriceWidget, DiscountPercentageContainer) == 0x000340, "Member 'UUMGCustomizationItemPriceWidget::DiscountPercentageContainer' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemPriceWidget, DiscountPercentage) == 0x000348, "Member 'UUMGCustomizationItemPriceWidget::DiscountPercentage' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemPriceWidget, CurrencyIcon) == 0x000350, "Member 'UUMGCustomizationItemPriceWidget::CurrencyIcon' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemPriceWidget, CurrencyTextures) == 0x000358, "Member 'UUMGCustomizationItemPriceWidget::CurrencyTextures' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemPriceWidget, AffordableCurrencyTextColor) == 0x0003A8, "Member 'UUMGCustomizationItemPriceWidget::AffordableCurrencyTextColor' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemPriceWidget, AffordableSpecialCurrencyTextColor) == 0x0003D0, "Member 'UUMGCustomizationItemPriceWidget::AffordableSpecialCurrencyTextColor' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemPriceWidget, NonAffordableCurrencyTextColor) == 0x0003F8, "Member 'UUMGCustomizationItemPriceWidget::NonAffordableCurrencyTextColor' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemPriceWidget, _itemId) == 0x000420, "Member 'UUMGCustomizationItemPriceWidget::_itemId' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemPriceWidget, _currencyType) == 0x000430, "Member 'UUMGCustomizationItemPriceWidget::_currencyType' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemPriceWidget, _hasDiscountPercentage) == 0x000431, "Member 'UUMGCustomizationItemPriceWidget::_hasDiscountPercentage' has a wrong offset!");

// Class DeadByDaylight.DBDRankDesignTunables
// 0x0030 (0x0060 - 0x0030)
class UDBDRankDesignTunables final : public UObject
{
public:
	class UCurveFloat*                            UnbrokenTimeAlivePointsCurve;                      // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EvaderStealthPointsByDistanceWhileKillerNotChasingCurve; // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EvaderStealthPointsByDistanceWhileKillerIsChasingCurve; // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EvaderChasePointsByDurationCurve;                  // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EvaderZAxisDistanceScalingCurve;                   // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ChaserChasePointsByDurationCurve;                  // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDRankDesignTunables">();
	}
	static class UDBDRankDesignTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDRankDesignTunables>();
	}
};
static_assert(alignof(UDBDRankDesignTunables) == 0x000008, "Wrong alignment on UDBDRankDesignTunables");
static_assert(sizeof(UDBDRankDesignTunables) == 0x000060, "Wrong size on UDBDRankDesignTunables");
static_assert(offsetof(UDBDRankDesignTunables, UnbrokenTimeAlivePointsCurve) == 0x000030, "Member 'UDBDRankDesignTunables::UnbrokenTimeAlivePointsCurve' has a wrong offset!");
static_assert(offsetof(UDBDRankDesignTunables, EvaderStealthPointsByDistanceWhileKillerNotChasingCurve) == 0x000038, "Member 'UDBDRankDesignTunables::EvaderStealthPointsByDistanceWhileKillerNotChasingCurve' has a wrong offset!");
static_assert(offsetof(UDBDRankDesignTunables, EvaderStealthPointsByDistanceWhileKillerIsChasingCurve) == 0x000040, "Member 'UDBDRankDesignTunables::EvaderStealthPointsByDistanceWhileKillerIsChasingCurve' has a wrong offset!");
static_assert(offsetof(UDBDRankDesignTunables, EvaderChasePointsByDurationCurve) == 0x000048, "Member 'UDBDRankDesignTunables::EvaderChasePointsByDurationCurve' has a wrong offset!");
static_assert(offsetof(UDBDRankDesignTunables, EvaderZAxisDistanceScalingCurve) == 0x000050, "Member 'UDBDRankDesignTunables::EvaderZAxisDistanceScalingCurve' has a wrong offset!");
static_assert(offsetof(UDBDRankDesignTunables, ChaserChasePointsByDurationCurve) == 0x000058, "Member 'UDBDRankDesignTunables::ChaserChasePointsByDurationCurve' has a wrong offset!");

// Class DeadByDaylight.AIBotsManager
// 0x0040 (0x0078 - 0x0038)
class UAIBotsManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x40];                                      // 0x0038(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIBotsManager">();
	}
	static class UAIBotsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIBotsManager>();
	}
};
static_assert(alignof(UAIBotsManager) == 0x000008, "Wrong alignment on UAIBotsManager");
static_assert(sizeof(UAIBotsManager) == 0x000078, "Wrong size on UAIBotsManager");

// Class DeadByDaylight.DBDPlayerController_Menu
// 0x0000 (0x0670 - 0x0670)
class ADBDPlayerController_Menu final : public ADBDPlayerControllerBase
{
public:
	void Authority_SetPlayerReady(bool isReady);
	void Authority_TogglePlayerReadyState();
	void Server_GamePresetDataFromClient(const struct FGamePresetData& gameState);
	void Server_SetCharacterData(int32 characterIndex, const struct FPlayerDataSync& playerDataSync);
	void Server_SetCharacterLevel(int32 characterLevel, int32 prestigeLevel, bool callOnRep);
	void Server_SetCustomizationCharm(class FName charmId, int8 slotIndex);
	void Server_SetCustomizationMeshes(const struct FCharacterCustomization& customization);
	void Server_SetEquipedPerks(const TArray<class FName>& perkIds, const TArray<int32>& perkLevels, bool callOnRep);
	void Server_SetPlayerLoadout(const struct FPlayerLoadoutData& desiredLoadout);
	void Server_SetPlayerReady(bool isReady);
	void Server_SetReadyToTravel();
	void SetPlayerReady(bool isReady);
	void TogglePlayerReadyState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerController_Menu">();
	}
	static class ADBDPlayerController_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerController_Menu>();
	}
};
static_assert(alignof(ADBDPlayerController_Menu) == 0x000008, "Wrong alignment on ADBDPlayerController_Menu");
static_assert(sizeof(ADBDPlayerController_Menu) == 0x000670, "Wrong size on ADBDPlayerController_Menu");

// Class DeadByDaylight.AICharacterBehaviourDropPallet
// 0x0008 (0x0098 - 0x0090)
class UAICharacterBehaviourDropPallet final : public UAICharacterBehaviourInteractWithActor
{
public:
	class APallet*                                _targetPallet;                                     // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviourDropPallet">();
	}
	static class UAICharacterBehaviourDropPallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviourDropPallet>();
	}
};
static_assert(alignof(UAICharacterBehaviourDropPallet) == 0x000008, "Wrong alignment on UAICharacterBehaviourDropPallet");
static_assert(sizeof(UAICharacterBehaviourDropPallet) == 0x000098, "Wrong size on UAICharacterBehaviourDropPallet");
static_assert(offsetof(UAICharacterBehaviourDropPallet, _targetPallet) == 0x000090, "Member 'UAICharacterBehaviourDropPallet::_targetPallet' has a wrong offset!");

// Class DeadByDaylight.DBDPrimaryDataAsset
// 0x0010 (0x0048 - 0x0038)
class UDBDPrimaryDataAsset : public UPrimaryDataAsset
{
public:
	struct FPrimaryAssetType                      AssetType;                                         // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPrimaryDataAsset">();
	}
	static class UDBDPrimaryDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPrimaryDataAsset>();
	}
};
static_assert(alignof(UDBDPrimaryDataAsset) == 0x000008, "Wrong alignment on UDBDPrimaryDataAsset");
static_assert(sizeof(UDBDPrimaryDataAsset) == 0x000048, "Wrong size on UDBDPrimaryDataAsset");
static_assert(offsetof(UDBDPrimaryDataAsset, AssetType) == 0x000038, "Member 'UDBDPrimaryDataAsset::AssetType' has a wrong offset!");

// Class DeadByDaylight.AICharacterBehaviourInteractWithHook
// 0x0008 (0x0098 - 0x0090)
class UAICharacterBehaviourInteractWithHook final : public UAICharacterBehaviourInteractWithActor
{
public:
	class AMeatHook*                              _targetHook;                                       // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterBehaviourInteractWithHook">();
	}
	static class UAICharacterBehaviourInteractWithHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterBehaviourInteractWithHook>();
	}
};
static_assert(alignof(UAICharacterBehaviourInteractWithHook) == 0x000008, "Wrong alignment on UAICharacterBehaviourInteractWithHook");
static_assert(sizeof(UAICharacterBehaviourInteractWithHook) == 0x000098, "Wrong size on UAICharacterBehaviourInteractWithHook");
static_assert(offsetof(UAICharacterBehaviourInteractWithHook, _targetHook) == 0x000090, "Member 'UAICharacterBehaviourInteractWithHook::_targetHook' has a wrong offset!");

// Class DeadByDaylight.SurvivorHitSprintEffect
// 0x0000 (0x0350 - 0x0350)
class USurvivorHitSprintEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorHitSprintEffect">();
	}
	static class USurvivorHitSprintEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorHitSprintEffect>();
	}
};
static_assert(alignof(USurvivorHitSprintEffect) == 0x000008, "Wrong alignment on USurvivorHitSprintEffect");
static_assert(sizeof(USurvivorHitSprintEffect) == 0x000350, "Wrong size on USurvivorHitSprintEffect");

// Class DeadByDaylight.AICharacterEscapeCarriedData
// 0x0008 (0x0038 - 0x0030)
class UAICharacterEscapeCarriedData final : public UAICharacterBehaviourData
{
public:
	bool                                          _preventWiggleSuccess;                             // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(bool preventWiggleSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterEscapeCarriedData">();
	}
	static class UAICharacterEscapeCarriedData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterEscapeCarriedData>();
	}
};
static_assert(alignof(UAICharacterEscapeCarriedData) == 0x000008, "Wrong alignment on UAICharacterEscapeCarriedData");
static_assert(sizeof(UAICharacterEscapeCarriedData) == 0x000038, "Wrong size on UAICharacterEscapeCarriedData");
static_assert(offsetof(UAICharacterEscapeCarriedData, _preventWiggleSuccess) == 0x000030, "Member 'UAICharacterEscapeCarriedData::_preventWiggleSuccess' has a wrong offset!");

// Class DeadByDaylight.AICharacterEscapeCarried
// 0x0010 (0x0068 - 0x0058)
class UAICharacterEscapeCarried final : public UAICharacterBehaviour
{
public:
	class ACamperPlayer*                          _camperPlayer;                                     // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAICharacterEscapeCarriedData*          _behaviourData;                                    // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterEscapeCarried">();
	}
	static class UAICharacterEscapeCarried* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterEscapeCarried>();
	}
};
static_assert(alignof(UAICharacterEscapeCarried) == 0x000008, "Wrong alignment on UAICharacterEscapeCarried");
static_assert(sizeof(UAICharacterEscapeCarried) == 0x000068, "Wrong size on UAICharacterEscapeCarried");
static_assert(offsetof(UAICharacterEscapeCarried, _camperPlayer) == 0x000058, "Member 'UAICharacterEscapeCarried::_camperPlayer' has a wrong offset!");
static_assert(offsetof(UAICharacterEscapeCarried, _behaviourData) == 0x000060, "Member 'UAICharacterEscapeCarried::_behaviourData' has a wrong offset!");

// Class DeadByDaylight.CharacterEvasionBehaviourData
// 0x0020 (0x0050 - 0x0030)
class UCharacterEvasionBehaviourData final : public UAICharacterBehaviourData
{
public:
	class AActor*                                 _hunter;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _escapePoints;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         _minEscapeDist;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AActor* hunter, const TArray<class AActor*>& escapePoints, float minEscapeDist);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterEvasionBehaviourData">();
	}
	static class UCharacterEvasionBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterEvasionBehaviourData>();
	}
};
static_assert(alignof(UCharacterEvasionBehaviourData) == 0x000008, "Wrong alignment on UCharacterEvasionBehaviourData");
static_assert(sizeof(UCharacterEvasionBehaviourData) == 0x000050, "Wrong size on UCharacterEvasionBehaviourData");
static_assert(offsetof(UCharacterEvasionBehaviourData, _hunter) == 0x000030, "Member 'UCharacterEvasionBehaviourData::_hunter' has a wrong offset!");
static_assert(offsetof(UCharacterEvasionBehaviourData, _escapePoints) == 0x000038, "Member 'UCharacterEvasionBehaviourData::_escapePoints' has a wrong offset!");
static_assert(offsetof(UCharacterEvasionBehaviourData, _minEscapeDist) == 0x000048, "Member 'UCharacterEvasionBehaviourData::_minEscapeDist' has a wrong offset!");

// Class DeadByDaylight.UMGReceivedFriendRequestListElement
// 0x0008 (0x0400 - 0x03F8)
class UUMGReceivedFriendRequestListElement final : public UUMGBaseFriendListElement
{
public:
	class URichTextBlock*                         FriendRequestStatusRichText;                       // 0x03F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGReceivedFriendRequestListElement">();
	}
	static class UUMGReceivedFriendRequestListElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGReceivedFriendRequestListElement>();
	}
};
static_assert(alignof(UUMGReceivedFriendRequestListElement) == 0x000008, "Wrong alignment on UUMGReceivedFriendRequestListElement");
static_assert(sizeof(UUMGReceivedFriendRequestListElement) == 0x000400, "Wrong size on UUMGReceivedFriendRequestListElement");
static_assert(offsetof(UUMGReceivedFriendRequestListElement, FriendRequestStatusRichText) == 0x0003F8, "Member 'UUMGReceivedFriendRequestListElement::FriendRequestStatusRichText' has a wrong offset!");

// Class DeadByDaylight.DBDRichPresenceSubsystem
// 0x0018 (0x0050 - 0x0038)
class UDBDRichPresenceSubsystem final : public UGameInstanceSubsystem
{
public:
	ERichPresenceUserType                         _userType;                                         // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERichPresenceStatus                           _richPresenceStatus;                               // 0x0039(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timerRate;                                        // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timerDelay;                                       // 0x0040(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isValidSetup;                                     // 0x0044(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45[0xB];                                       // 0x0045(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDRichPresenceSubsystem">();
	}
	static class UDBDRichPresenceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDRichPresenceSubsystem>();
	}
};
static_assert(alignof(UDBDRichPresenceSubsystem) == 0x000008, "Wrong alignment on UDBDRichPresenceSubsystem");
static_assert(sizeof(UDBDRichPresenceSubsystem) == 0x000050, "Wrong size on UDBDRichPresenceSubsystem");
static_assert(offsetof(UDBDRichPresenceSubsystem, _userType) == 0x000038, "Member 'UDBDRichPresenceSubsystem::_userType' has a wrong offset!");
static_assert(offsetof(UDBDRichPresenceSubsystem, _richPresenceStatus) == 0x000039, "Member 'UDBDRichPresenceSubsystem::_richPresenceStatus' has a wrong offset!");
static_assert(offsetof(UDBDRichPresenceSubsystem, _timerRate) == 0x00003C, "Member 'UDBDRichPresenceSubsystem::_timerRate' has a wrong offset!");
static_assert(offsetof(UDBDRichPresenceSubsystem, _timerDelay) == 0x000040, "Member 'UDBDRichPresenceSubsystem::_timerDelay' has a wrong offset!");
static_assert(offsetof(UDBDRichPresenceSubsystem, _isValidSetup) == 0x000044, "Member 'UDBDRichPresenceSubsystem::_isValidSetup' has a wrong offset!");

// Class DeadByDaylight.AICharacterEvasionBehaviour
// 0x0028 (0x0080 - 0x0058)
class UAICharacterEvasionBehaviour final : public UAICharacterBehaviour
{
public:
	class ADBDPlayer*                             _prey;                                             // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _preyAIController;                                 // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _currentEscapePoint;                               // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterEvasionBehaviourData*         _characterEvasionData;                             // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EscapeDestinationReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterEvasionBehaviour">();
	}
	static class UAICharacterEvasionBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterEvasionBehaviour>();
	}
};
static_assert(alignof(UAICharacterEvasionBehaviour) == 0x000008, "Wrong alignment on UAICharacterEvasionBehaviour");
static_assert(sizeof(UAICharacterEvasionBehaviour) == 0x000080, "Wrong size on UAICharacterEvasionBehaviour");
static_assert(offsetof(UAICharacterEvasionBehaviour, _prey) == 0x000058, "Member 'UAICharacterEvasionBehaviour::_prey' has a wrong offset!");
static_assert(offsetof(UAICharacterEvasionBehaviour, _preyAIController) == 0x000060, "Member 'UAICharacterEvasionBehaviour::_preyAIController' has a wrong offset!");
static_assert(offsetof(UAICharacterEvasionBehaviour, _currentEscapePoint) == 0x000068, "Member 'UAICharacterEvasionBehaviour::_currentEscapePoint' has a wrong offset!");
static_assert(offsetof(UAICharacterEvasionBehaviour, _characterEvasionData) == 0x000070, "Member 'UAICharacterEvasionBehaviour::_characterEvasionData' has a wrong offset!");

// Class DeadByDaylight.AICharacterHideInLockerBehaviourData
// 0x0010 (0x0040 - 0x0030)
class UAICharacterHideInLockerBehaviourData final : public UAICharacterBehaviourData
{
public:
	class ALocker*                                TargetLocker;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterMovementTypes                       CharacterMovementType;                             // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class ALocker* locker, ECharacterMovementTypes characterMovementType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterHideInLockerBehaviourData">();
	}
	static class UAICharacterHideInLockerBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterHideInLockerBehaviourData>();
	}
};
static_assert(alignof(UAICharacterHideInLockerBehaviourData) == 0x000008, "Wrong alignment on UAICharacterHideInLockerBehaviourData");
static_assert(sizeof(UAICharacterHideInLockerBehaviourData) == 0x000040, "Wrong size on UAICharacterHideInLockerBehaviourData");
static_assert(offsetof(UAICharacterHideInLockerBehaviourData, TargetLocker) == 0x000030, "Member 'UAICharacterHideInLockerBehaviourData::TargetLocker' has a wrong offset!");
static_assert(offsetof(UAICharacterHideInLockerBehaviourData, CharacterMovementType) == 0x000038, "Member 'UAICharacterHideInLockerBehaviourData::CharacterMovementType' has a wrong offset!");

// Class DeadByDaylight.TriggerableWorldObjectComponent
// 0x0098 (0x0150 - 0x00B8)
class UTriggerableWorldObjectComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class AActor* Instigator, const struct FVector& Location)> OnTriggered; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTriggerReset;                                    // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         _triggerResetTime;                                 // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _randomChance;                                     // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _rollFrequency;                                    // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0xC];                                       // 0x00E4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPrimitiveComponent>     _conditionalTriggerVolume;                         // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class ADBDPlayer*>                       _conditionalVolumeOverlappingPlayers;              // 0x00F8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UPrimitiveComponent>     _guaranteedTriggerVolume;                          // 0x0148(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_ConditionalVolumeBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& HitResult);
	void Authority_ConditionalVolumeEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void Authority_GuaranteedVolumeOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& HitResult);
	void Authority_ResetTrigger();
	void Authority_Trigger(class AActor* instigator, const struct FVector& triggerLocation);
	bool CanPlayerTriggerConditional(class ADBDPlayer* player);
	bool CanPlayerTriggerGuaranteed(class ADBDPlayer* player);
	void GetConditionalModifiers(class ADBDPlayer* player, float* outAdditive, float* outMultiplicative);
	void Multicast_OnTriggered(class AActor* instigator, const struct FVector& triggerLocation);
	void Multicast_OnTriggerReset();
	void SetConditionalTriggerVolume(class UPrimitiveComponent* volume);
	void SetGuaranteedTriggerVolume(class UPrimitiveComponent* volume);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerableWorldObjectComponent">();
	}
	static class UTriggerableWorldObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriggerableWorldObjectComponent>();
	}
};
static_assert(alignof(UTriggerableWorldObjectComponent) == 0x000008, "Wrong alignment on UTriggerableWorldObjectComponent");
static_assert(sizeof(UTriggerableWorldObjectComponent) == 0x000150, "Wrong size on UTriggerableWorldObjectComponent");
static_assert(offsetof(UTriggerableWorldObjectComponent, OnTriggered) == 0x0000B8, "Member 'UTriggerableWorldObjectComponent::OnTriggered' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, OnTriggerReset) == 0x0000C8, "Member 'UTriggerableWorldObjectComponent::OnTriggerReset' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _triggerResetTime) == 0x0000D8, "Member 'UTriggerableWorldObjectComponent::_triggerResetTime' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _randomChance) == 0x0000DC, "Member 'UTriggerableWorldObjectComponent::_randomChance' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _rollFrequency) == 0x0000E0, "Member 'UTriggerableWorldObjectComponent::_rollFrequency' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _conditionalTriggerVolume) == 0x0000F0, "Member 'UTriggerableWorldObjectComponent::_conditionalTriggerVolume' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _conditionalVolumeOverlappingPlayers) == 0x0000F8, "Member 'UTriggerableWorldObjectComponent::_conditionalVolumeOverlappingPlayers' has a wrong offset!");
static_assert(offsetof(UTriggerableWorldObjectComponent, _guaranteedTriggerVolume) == 0x000148, "Member 'UTriggerableWorldObjectComponent::_guaranteedTriggerVolume' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerState
// 0x03F0 (0x0728 - 0x0338)
class ADBDPlayerState : public APlayerState
{
public:
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnAIFinishedPlayingEvent;                          // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 MirrorsId;                                         // 0x0350(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ContentVersion;                                    // 0x0360(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIDifficultyLevel                            _difficultyLevel;                                  // 0x0370(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlayerReady;                                     // 0x0371(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerRole                                   GameRole;                                          // 0x0372(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_373[0x5];                                      // 0x0373(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UDedicatedServerHandlerComponent*       DedicatedServerHandler;                            // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCharacterStateData                    CamperData;                                        // 0x0380(0x0020)(Net, Transient, RepNotify, NativeAccessSpecifierPublic)
	struct FCharacterStateData                    SlasherData;                                       // 0x03A0(0x0020)(Net, RepNotify, NativeAccessSpecifierPublic)
	struct FPlayerStateData                       PlayerData;                                        // 0x03C0(0x0038)(Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EDBDScoreTypes playerGameplayEventType, float amount, class AActor* effector, class AActor* target)> OnPlayerGameplayEvent; // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayerState* playerState, const EGameState gameState)> OnPlayerGameStateChanged; // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, struct FAwardedScores>      _awardedScoresByType;                              // 0x0420(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FUserGameStats                         _cachedUserGameStats;                              // 0x0470(0x00B0)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FOngoingScoreData>              _ongoingScoreEvents;                               // 0x0520(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_530[0x9];                                      // 0x0530(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _inParadise;                                       // 0x0539(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _endOfMatchRpcReceived;                            // 0x053A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_53B[0x5];                                      // 0x053B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEquippedPlayerCustomization           _playerCustomization;                              // 0x0540(0x0038)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         _selectedCamperIndex;                              // 0x0578(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _selectedSlasherIndex;                             // 0x057C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGameplayNotificationManager*           _gameplayNotificationManager;                      // 0x0580(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterStatsHandlerComponent*        _characterStatsHandler;                            // 0x0588(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerScoreComponent*                  _playerScoreComponent;                             // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_598[0x20];                                     // 0x0598(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _platformAccountId;                                // 0x05B8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C8[0x104];                                    // 0x05C8(0x0104)(Fixing Size After Last Property [ Dumper-7 ])
	EPlatformFlag                                 _platform;                                         // 0x06CC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EProviderFlag                                 _provider;                                         // 0x06D0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _crossplayAllowed;                                 // 0x06D4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _offNetworkFlag;                                   // 0x06D5(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6D6[0x2];                                      // 0x06D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStreamerModePlayerData                _streamerModePlayerData;                           // 0x06D8(0x0008)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          _gameLevelLoaded;                                  // 0x06E0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6E1[0x37];                                     // 0x06E1(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _showPortraitBorder;                               // 0x0718(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_719[0x2];                                      // 0x0719(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasActiveSubscription;                            // 0x071B(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        _matchmakingIncentive;                             // 0x071C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _pktLossPercentage;                                // 0x0720(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_724[0x4];                                      // 0x0724(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_CancelOngoingScoreEvent(const struct FGameplayTag& scoreTypeTag);
	void Authority_EndOngoingScoreEvent(const struct FGameplayTag& scoreTypeTag);
	void Authority_HandleScoreEvent(const struct FGameplayTag& scoreTypeTag, const struct FScoreEventData& scoreEventData);
	void Authority_SetPlayerGameState(EGameState newGameState, bool isEscapeHatch);
	void ChangeStartingGameRole(EPlayerRole gameRole);
	void Client_AtlantaUpdateInventoryItem(const class FName& itemid, int32 newCount);
	void Client_FetchCoreRituals(bool hasClaimableRitual);
	void Client_HandleEndOfMatch(bool success, const struct FEndOfMatchRPCData& response);
	void Client_HandleEscapeScoreEvent();
	void Client_InvalidateIncentives();
	void Client_RemotelyDispatchGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Client_RemotelyDispatchGameEventWithScore(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData, const struct FAwardedScore& awardedScore);
	void Client_RemoveItemFromInventory(class FName toRemove, bool updateLoadout);
	void Client_SetGameRole(EPlayerRole newRole);
	void Client_SetInParadise();
	void Client_UpdateWallet(const class FString& currencyId, int32 amount);
	void FireActiveStatusEffectEvent(class FName statusEffectID, float percentage, int32 iconFilePathIndex, int32 levelToDisplay);
	void FireActiveStatusViewEvent(class FName statusViewID, class FName uniqueSourceID, const struct FStatusViewSource& statusViewSource);
	void FireScoreEvent(EDBDScoreTypes scoreType, float percentToAward);
	void Multicast_FireGameplayEvent(EDBDScoreTypes playerGameplayEventType, float amount, class AActor* effector, class AActor* target);
	void Multicast_FireGameplayEventWithScore(EDBDScoreTypes playerGameplayEventType, float amount, class AActor* effector, class AActor* target, const struct FAwardedScore& awardedScore);
	void Multicast_SetAsDisconnected();
	void Multicast_SetAsLeftMatch();
	void Multicast_SetInParadise();
	void Multicast_SetPlayerGameState(EGameState newGameState, bool isEscapeHatch);
	void OnRep_BotDifficultyLevel();
	void OnRep_CustomizationData();
	void OnRep_DisplayData();
	void Server_CheatSelectKiller(int32 slasherIndex);
	void Server_CheatSelectSurvivor(int32 camperIndex);
	void UpdateOngoingScores();

	class UGameplayNotificationManager* GetGameplayNotificationManager() const;
	EPlayerRole GetGameRole() const;
	EGameState GetPlayerGameState() const;
	bool HasEscaped() const;
	bool IsInFinishedPlayingState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerState">();
	}
	static class ADBDPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerState>();
	}
};
static_assert(alignof(ADBDPlayerState) == 0x000008, "Wrong alignment on ADBDPlayerState");
static_assert(sizeof(ADBDPlayerState) == 0x000728, "Wrong size on ADBDPlayerState");
static_assert(offsetof(ADBDPlayerState, OnAIFinishedPlayingEvent) == 0x000340, "Member 'ADBDPlayerState::OnAIFinishedPlayingEvent' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, MirrorsId) == 0x000350, "Member 'ADBDPlayerState::MirrorsId' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, ContentVersion) == 0x000360, "Member 'ADBDPlayerState::ContentVersion' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _difficultyLevel) == 0x000370, "Member 'ADBDPlayerState::_difficultyLevel' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, IsPlayerReady) == 0x000371, "Member 'ADBDPlayerState::IsPlayerReady' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, GameRole) == 0x000372, "Member 'ADBDPlayerState::GameRole' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, DedicatedServerHandler) == 0x000378, "Member 'ADBDPlayerState::DedicatedServerHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, CamperData) == 0x000380, "Member 'ADBDPlayerState::CamperData' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, SlasherData) == 0x0003A0, "Member 'ADBDPlayerState::SlasherData' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, PlayerData) == 0x0003C0, "Member 'ADBDPlayerState::PlayerData' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, OnPlayerGameplayEvent) == 0x000400, "Member 'ADBDPlayerState::OnPlayerGameplayEvent' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, OnPlayerGameStateChanged) == 0x000410, "Member 'ADBDPlayerState::OnPlayerGameStateChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _awardedScoresByType) == 0x000420, "Member 'ADBDPlayerState::_awardedScoresByType' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _cachedUserGameStats) == 0x000470, "Member 'ADBDPlayerState::_cachedUserGameStats' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _ongoingScoreEvents) == 0x000520, "Member 'ADBDPlayerState::_ongoingScoreEvents' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _inParadise) == 0x000539, "Member 'ADBDPlayerState::_inParadise' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _endOfMatchRpcReceived) == 0x00053A, "Member 'ADBDPlayerState::_endOfMatchRpcReceived' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _playerCustomization) == 0x000540, "Member 'ADBDPlayerState::_playerCustomization' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _selectedCamperIndex) == 0x000578, "Member 'ADBDPlayerState::_selectedCamperIndex' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _selectedSlasherIndex) == 0x00057C, "Member 'ADBDPlayerState::_selectedSlasherIndex' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _gameplayNotificationManager) == 0x000580, "Member 'ADBDPlayerState::_gameplayNotificationManager' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _characterStatsHandler) == 0x000588, "Member 'ADBDPlayerState::_characterStatsHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _playerScoreComponent) == 0x000590, "Member 'ADBDPlayerState::_playerScoreComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _platformAccountId) == 0x0005B8, "Member 'ADBDPlayerState::_platformAccountId' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _platform) == 0x0006CC, "Member 'ADBDPlayerState::_platform' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _provider) == 0x0006D0, "Member 'ADBDPlayerState::_provider' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _crossplayAllowed) == 0x0006D4, "Member 'ADBDPlayerState::_crossplayAllowed' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _offNetworkFlag) == 0x0006D5, "Member 'ADBDPlayerState::_offNetworkFlag' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _streamerModePlayerData) == 0x0006D8, "Member 'ADBDPlayerState::_streamerModePlayerData' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _gameLevelLoaded) == 0x0006E0, "Member 'ADBDPlayerState::_gameLevelLoaded' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _showPortraitBorder) == 0x000718, "Member 'ADBDPlayerState::_showPortraitBorder' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _hasActiveSubscription) == 0x00071B, "Member 'ADBDPlayerState::_hasActiveSubscription' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _matchmakingIncentive) == 0x00071C, "Member 'ADBDPlayerState::_matchmakingIncentive' has a wrong offset!");
static_assert(offsetof(ADBDPlayerState, _pktLossPercentage) == 0x000720, "Member 'ADBDPlayerState::_pktLossPercentage' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerState_Menu
// 0x0000 (0x0728 - 0x0728)
class ADBDPlayerState_Menu : public ADBDPlayerState
{
public:
	void Multicast_SetSelectedCharacterCustomization(EPlayerRole forRole, int32 id, const struct FEquippedPlayerCustomization& customization);
	void Multicast_SetSelectedCharacterId(EPlayerRole forRole, int32 id, bool updateDisplayData);
	void Server_NotifyOnRep();
	void Server_SetEquipment(ELoadoutSlot slot, class FName itemId, bool callOnRep);
	void Server_SetEquipmentAddons(const TArray<class FName>& addonItemIds, bool callOnRep);
	void Server_SetSelectedCharacterCustomization(EPlayerRole forRole, int32 id, const struct FEquippedPlayerCustomization& customization);
	void Server_SetSelectedCharacterId(int32 id, bool updateDisplayData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerState_Menu">();
	}
	static class ADBDPlayerState_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerState_Menu>();
	}
};
static_assert(alignof(ADBDPlayerState_Menu) == 0x000008, "Wrong alignment on ADBDPlayerState_Menu");
static_assert(sizeof(ADBDPlayerState_Menu) == 0x000728, "Wrong size on ADBDPlayerState_Menu");

// Class DeadByDaylight.AICharacterHideInLockerBehaviour
// 0x0038 (0x0090 - 0x0058)
class UAICharacterHideInLockerBehaviour final : public UAICharacterBehaviour
{
public:
	class ADBDPlayer*                             _aiPlayer;                                         // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _aiPlayerController;                               // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAICharacterHideInLockerBehaviourData*  _characterHideInLockerData;                        // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMovementFinished(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterHideInLockerBehaviour">();
	}
	static class UAICharacterHideInLockerBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterHideInLockerBehaviour>();
	}
};
static_assert(alignof(UAICharacterHideInLockerBehaviour) == 0x000008, "Wrong alignment on UAICharacterHideInLockerBehaviour");
static_assert(sizeof(UAICharacterHideInLockerBehaviour) == 0x000090, "Wrong size on UAICharacterHideInLockerBehaviour");
static_assert(offsetof(UAICharacterHideInLockerBehaviour, _aiPlayer) == 0x000058, "Member 'UAICharacterHideInLockerBehaviour::_aiPlayer' has a wrong offset!");
static_assert(offsetof(UAICharacterHideInLockerBehaviour, _aiPlayerController) == 0x000060, "Member 'UAICharacterHideInLockerBehaviour::_aiPlayerController' has a wrong offset!");
static_assert(offsetof(UAICharacterHideInLockerBehaviour, _characterHideInLockerData) == 0x000080, "Member 'UAICharacterHideInLockerBehaviour::_characterHideInLockerData' has a wrong offset!");

// Class DeadByDaylight.AICharacterRepairGeneratorBehaviourData
// 0x0010 (0x0040 - 0x0030)
class UAICharacterRepairGeneratorBehaviourData final : public UAICharacterBehaviourData
{
public:
	class AGenerator*                             _generator;                                        // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECharacterMovementTypes                       _characterMovementType;                            // 0x0038(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AGenerator* generator, ECharacterMovementTypes characterMovementType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterRepairGeneratorBehaviourData">();
	}
	static class UAICharacterRepairGeneratorBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterRepairGeneratorBehaviourData>();
	}
};
static_assert(alignof(UAICharacterRepairGeneratorBehaviourData) == 0x000008, "Wrong alignment on UAICharacterRepairGeneratorBehaviourData");
static_assert(sizeof(UAICharacterRepairGeneratorBehaviourData) == 0x000040, "Wrong size on UAICharacterRepairGeneratorBehaviourData");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviourData, _generator) == 0x000030, "Member 'UAICharacterRepairGeneratorBehaviourData::_generator' has a wrong offset!");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviourData, _characterMovementType) == 0x000038, "Member 'UAICharacterRepairGeneratorBehaviourData::_characterMovementType' has a wrong offset!");

// Class DeadByDaylight.DBDHostSettingsParamsBase
// 0x0010 (0x0040 - 0x0030)
class UDBDHostSettingsParamsBase : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHostSettingsParamsBase">();
	}
	static class UDBDHostSettingsParamsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHostSettingsParamsBase>();
	}
};
static_assert(alignof(UDBDHostSettingsParamsBase) == 0x000008, "Wrong alignment on UDBDHostSettingsParamsBase");
static_assert(sizeof(UDBDHostSettingsParamsBase) == 0x000040, "Wrong size on UDBDHostSettingsParamsBase");

// Class DeadByDaylight.DBDHostSettingsParamsRanking
// 0x0008 (0x0048 - 0x0040)
class UDBDHostSettingsParamsRanking final : public UDBDHostSettingsParamsBase
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHostSettingsParamsRanking">();
	}
	static class UDBDHostSettingsParamsRanking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHostSettingsParamsRanking>();
	}
};
static_assert(alignof(UDBDHostSettingsParamsRanking) == 0x000008, "Wrong alignment on UDBDHostSettingsParamsRanking");
static_assert(sizeof(UDBDHostSettingsParamsRanking) == 0x000048, "Wrong size on UDBDHostSettingsParamsRanking");

// Class DeadByDaylight.AICharacterRepairGeneratorBehaviour
// 0x0040 (0x0098 - 0x0058)
class UAICharacterRepairGeneratorBehaviour final : public UAICharacterBehaviour
{
public:
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _aiPlayer;                                         // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _aiPlayerController;                               // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _targetInteractor;                                 // 0x0078(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAICharacterRepairGeneratorBehaviourData* _characterRepairGeneratorData;                   // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGeneratorRepairedEventHandler(bool isAutoCompleted);
	void OnMovementFinished(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharacterRepairGeneratorBehaviour">();
	}
	static class UAICharacterRepairGeneratorBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAICharacterRepairGeneratorBehaviour>();
	}
};
static_assert(alignof(UAICharacterRepairGeneratorBehaviour) == 0x000008, "Wrong alignment on UAICharacterRepairGeneratorBehaviour");
static_assert(sizeof(UAICharacterRepairGeneratorBehaviour) == 0x000098, "Wrong size on UAICharacterRepairGeneratorBehaviour");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviour, _aiPlayer) == 0x000068, "Member 'UAICharacterRepairGeneratorBehaviour::_aiPlayer' has a wrong offset!");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviour, _aiPlayerController) == 0x000070, "Member 'UAICharacterRepairGeneratorBehaviour::_aiPlayerController' has a wrong offset!");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviour, _targetInteractor) == 0x000078, "Member 'UAICharacterRepairGeneratorBehaviour::_targetInteractor' has a wrong offset!");
static_assert(offsetof(UAICharacterRepairGeneratorBehaviour, _characterRepairGeneratorData) == 0x000080, "Member 'UAICharacterRepairGeneratorBehaviour::_characterRepairGeneratorData' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaStoreScreen
// 0x0038 (0x0370 - 0x0338)
class UUMGAtlantaStoreScreen final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x20];                                     // 0x0338(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UScaleBox*                              AuricCellsWidget;                                  // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      AuricCellsGridPanel;                               // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnClickedBuyAuricCell(int32 cellIndex);
	void HandleOnStoreLeft();
	void SetBank(ECurrencyType currencyType, int32 bank);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaStoreScreen">();
	}
	static class UUMGAtlantaStoreScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaStoreScreen>();
	}
};
static_assert(alignof(UUMGAtlantaStoreScreen) == 0x000008, "Wrong alignment on UUMGAtlantaStoreScreen");
static_assert(sizeof(UUMGAtlantaStoreScreen) == 0x000370, "Wrong size on UUMGAtlantaStoreScreen");
static_assert(offsetof(UUMGAtlantaStoreScreen, AuricCellsWidget) == 0x000358, "Member 'UUMGAtlantaStoreScreen::AuricCellsWidget' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaStoreScreen, AuricCellsGridPanel) == 0x000360, "Member 'UUMGAtlantaStoreScreen::AuricCellsGridPanel' has a wrong offset!");

// Class DeadByDaylight.AIHealAllyBehaviourData
// 0x0008 (0x0038 - 0x0030)
class UAIHealAllyBehaviourData final : public UAICharacterBehaviourData
{
public:
	class ACamperPlayer*                          _targetAlly;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Init(class ACamperPlayer* allyToHealTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHealAllyBehaviourData">();
	}
	static class UAIHealAllyBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHealAllyBehaviourData>();
	}
};
static_assert(alignof(UAIHealAllyBehaviourData) == 0x000008, "Wrong alignment on UAIHealAllyBehaviourData");
static_assert(sizeof(UAIHealAllyBehaviourData) == 0x000038, "Wrong size on UAIHealAllyBehaviourData");
static_assert(offsetof(UAIHealAllyBehaviourData, _targetAlly) == 0x000030, "Member 'UAIHealAllyBehaviourData::_targetAlly' has a wrong offset!");

// Class DeadByDaylight.UMGRitualClaimRewardButton
// 0x0018 (0x0480 - 0x0468)
class UUMGRitualClaimRewardButton final : public UUMGBaseButtonWidget
{
public:
	TMulticastInlineDelegate<void()>              OnPressedAnimationCompleted;                       // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           ClaimFxPanel;                                      // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BroadcastOnPressedAnimationCompleted();
	void SetClaimedButtonStatus(bool isClaimed, float percent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGRitualClaimRewardButton">();
	}
	static class UUMGRitualClaimRewardButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGRitualClaimRewardButton>();
	}
};
static_assert(alignof(UUMGRitualClaimRewardButton) == 0x000008, "Wrong alignment on UUMGRitualClaimRewardButton");
static_assert(sizeof(UUMGRitualClaimRewardButton) == 0x000480, "Wrong size on UUMGRitualClaimRewardButton");
static_assert(offsetof(UUMGRitualClaimRewardButton, OnPressedAnimationCompleted) == 0x000468, "Member 'UUMGRitualClaimRewardButton::OnPressedAnimationCompleted' has a wrong offset!");
static_assert(offsetof(UUMGRitualClaimRewardButton, ClaimFxPanel) == 0x000478, "Member 'UUMGRitualClaimRewardButton::ClaimFxPanel' has a wrong offset!");

// Class DeadByDaylight.DBDSpectator
// 0x0020 (0x02E0 - 0x02C0)
class ADBDSpectator final : public ASpectatorPawn
{
public:
	uint8                                         Pad_2C0[0x20];                                     // 0x02C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSpectator">();
	}
	static class ADBDSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDSpectator>();
	}
};
static_assert(alignof(ADBDSpectator) == 0x000008, "Wrong alignment on ADBDSpectator");
static_assert(sizeof(ADBDSpectator) == 0x0002E0, "Wrong size on ADBDSpectator");

// Class DeadByDaylight.AIHealAllyBehaviour
// 0x0028 (0x0080 - 0x0058)
class UAIHealAllyBehaviour final : public UAICharacterBehaviour
{
public:
	class UAIHealAllyBehaviourData*               _behaviourData;                                    // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _aiController;                                     // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _aiPlayer;                                         // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class ADBDPlayer* character, class UAICharacterBehaviourData* behaviourData);
	void TargetPositionReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIHealAllyBehaviour">();
	}
	static class UAIHealAllyBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIHealAllyBehaviour>();
	}
};
static_assert(alignof(UAIHealAllyBehaviour) == 0x000008, "Wrong alignment on UAIHealAllyBehaviour");
static_assert(sizeof(UAIHealAllyBehaviour) == 0x000080, "Wrong size on UAIHealAllyBehaviour");
static_assert(offsetof(UAIHealAllyBehaviour, _behaviourData) == 0x000058, "Member 'UAIHealAllyBehaviour::_behaviourData' has a wrong offset!");
static_assert(offsetof(UAIHealAllyBehaviour, _aiController) == 0x000060, "Member 'UAIHealAllyBehaviour::_aiController' has a wrong offset!");
static_assert(offsetof(UAIHealAllyBehaviour, _aiPlayer) == 0x000068, "Member 'UAIHealAllyBehaviour::_aiPlayer' has a wrong offset!");

// Class DeadByDaylight.AimableInterface
// 0x0000 (0x0000 - 0x0000)
class IAimableInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimableInterface">();
	}
	static class IAimableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAimableInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAimableInterface) == 0x000001, "Wrong alignment on IAimableInterface");
static_assert(sizeof(IAimableInterface) == 0x000001, "Wrong size on IAimableInterface");

// Class DeadByDaylight.UMGRoleSelectionScreen
// 0x0020 (0x0358 - 0x0338)
class UUMGRoleSelectionScreen final : public UMobileBaseUserWidget
{
public:
	int32                                         _newInboxMessageCount;                             // 0x0338(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x1C];                                     // 0x033C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ButtonClickEvent(ERoleSelectionScreenButton buttonId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGRoleSelectionScreen">();
	}
	static class UUMGRoleSelectionScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGRoleSelectionScreen>();
	}
};
static_assert(alignof(UUMGRoleSelectionScreen) == 0x000008, "Wrong alignment on UUMGRoleSelectionScreen");
static_assert(sizeof(UUMGRoleSelectionScreen) == 0x000358, "Wrong size on UUMGRoleSelectionScreen");
static_assert(offsetof(UUMGRoleSelectionScreen, _newInboxMessageCount) == 0x000338, "Member 'UUMGRoleSelectionScreen::_newInboxMessageCount' has a wrong offset!");

// Class DeadByDaylight.DBDSignificanceStrategy
// 0x01E0 (0x0210 - 0x0030)
class UDBDSignificanceStrategy final : public USignificanceStrategy
{
public:
	struct FBHVRPerDetailModeFloat                _farDistance;                                      // 0x0030(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _auraRevealedMultiplier;                           // 0x00D0(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _auraRevealedMinimumSignificance;                  // 0x0170(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSignificanceStrategy">();
	}
	static class UDBDSignificanceStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSignificanceStrategy>();
	}
};
static_assert(alignof(UDBDSignificanceStrategy) == 0x000008, "Wrong alignment on UDBDSignificanceStrategy");
static_assert(sizeof(UDBDSignificanceStrategy) == 0x000210, "Wrong size on UDBDSignificanceStrategy");
static_assert(offsetof(UDBDSignificanceStrategy, _farDistance) == 0x000030, "Member 'UDBDSignificanceStrategy::_farDistance' has a wrong offset!");
static_assert(offsetof(UDBDSignificanceStrategy, _auraRevealedMultiplier) == 0x0000D0, "Member 'UDBDSignificanceStrategy::_auraRevealedMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDSignificanceStrategy, _auraRevealedMinimumSignificance) == 0x000170, "Member 'UDBDSignificanceStrategy::_auraRevealedMinimumSignificance' has a wrong offset!");

// Class DeadByDaylight.AimAssistComponent
// 0x0030 (0x00E8 - 0x00B8)
class UAimAssistComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimAssistComponent">();
	}
	static class UAimAssistComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimAssistComponent>();
	}
};
static_assert(alignof(UAimAssistComponent) == 0x000008, "Wrong alignment on UAimAssistComponent");
static_assert(sizeof(UAimAssistComponent) == 0x0000E8, "Wrong size on UAimAssistComponent");

// Class DeadByDaylight.AIMoveToInteractData
// 0x0018 (0x0048 - 0x0030)
class UAIMoveToInteractData final : public UAICharacterBehaviourData
{
public:
	class AActor*                                 _interactActor;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _targetPositionActor;                              // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterMovementTypes                       _characterMovementTypes;                           // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AActor* interactActor, ECharacterMovementTypes characterMovementTypes, class AActor* targetPositionActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMoveToInteractData">();
	}
	static class UAIMoveToInteractData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMoveToInteractData>();
	}
};
static_assert(alignof(UAIMoveToInteractData) == 0x000008, "Wrong alignment on UAIMoveToInteractData");
static_assert(sizeof(UAIMoveToInteractData) == 0x000048, "Wrong size on UAIMoveToInteractData");
static_assert(offsetof(UAIMoveToInteractData, _interactActor) == 0x000030, "Member 'UAIMoveToInteractData::_interactActor' has a wrong offset!");
static_assert(offsetof(UAIMoveToInteractData, _targetPositionActor) == 0x000038, "Member 'UAIMoveToInteractData::_targetPositionActor' has a wrong offset!");
static_assert(offsetof(UAIMoveToInteractData, _characterMovementTypes) == 0x000040, "Member 'UAIMoveToInteractData::_characterMovementTypes' has a wrong offset!");

// Class DeadByDaylight.StatusView
// 0x0070 (0x02A0 - 0x0230)
class AStatusView final : public AActor
{
public:
	bool                                          _isActive;                                         // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _level;                                            // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _percentageFill;                                   // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isClockwiseTimer;                                 // 0x023C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23D[0x5B];                                     // 0x023D(0x005B)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _localDBDPlayer;                                   // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void FireNotification(const struct FStatusViewSource& statusViewSource);
	void ResetView(const class ADBDPlayer* dbdPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusView">();
	}
	static class AStatusView* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStatusView>();
	}
};
static_assert(alignof(AStatusView) == 0x000008, "Wrong alignment on AStatusView");
static_assert(sizeof(AStatusView) == 0x0002A0, "Wrong size on AStatusView");
static_assert(offsetof(AStatusView, _isActive) == 0x000230, "Member 'AStatusView::_isActive' has a wrong offset!");
static_assert(offsetof(AStatusView, _level) == 0x000234, "Member 'AStatusView::_level' has a wrong offset!");
static_assert(offsetof(AStatusView, _percentageFill) == 0x000238, "Member 'AStatusView::_percentageFill' has a wrong offset!");
static_assert(offsetof(AStatusView, _isClockwiseTimer) == 0x00023C, "Member 'AStatusView::_isClockwiseTimer' has a wrong offset!");
static_assert(offsetof(AStatusView, _localDBDPlayer) == 0x000298, "Member 'AStatusView::_localDBDPlayer' has a wrong offset!");

// Class DeadByDaylight.DBDHostSettingsParamsSessionInvalid
// 0x0000 (0x0040 - 0x0040)
class UDBDHostSettingsParamsSessionInvalid final : public UDBDHostSettingsParamsBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHostSettingsParamsSessionInvalid">();
	}
	static class UDBDHostSettingsParamsSessionInvalid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHostSettingsParamsSessionInvalid>();
	}
};
static_assert(alignof(UDBDHostSettingsParamsSessionInvalid) == 0x000008, "Wrong alignment on UDBDHostSettingsParamsSessionInvalid");
static_assert(sizeof(UDBDHostSettingsParamsSessionInvalid) == 0x000040, "Wrong size on UDBDHostSettingsParamsSessionInvalid");

// Class DeadByDaylight.AIMoveToInteract
// 0x0018 (0x0070 - 0x0058)
class UAIMoveToInteract final : public UAICharacterBehaviour
{
public:
	class UAIMoveToInteractData*                  _aiMoveToInteractData;                             // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _aiController;                                     // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class ADBDPlayer* character, class UAICharacterBehaviourData* behaviourData);
	void InteractionPointReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMoveToInteract">();
	}
	static class UAIMoveToInteract* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMoveToInteract>();
	}
};
static_assert(alignof(UAIMoveToInteract) == 0x000008, "Wrong alignment on UAIMoveToInteract");
static_assert(sizeof(UAIMoveToInteract) == 0x000070, "Wrong size on UAIMoveToInteract");
static_assert(offsetof(UAIMoveToInteract, _aiMoveToInteractData) == 0x000058, "Member 'UAIMoveToInteract::_aiMoveToInteractData' has a wrong offset!");
static_assert(offsetof(UAIMoveToInteract, _aiController) == 0x000060, "Member 'UAIMoveToInteract::_aiController' has a wrong offset!");

// Class DeadByDaylight.AIMoveToPositionData
// 0x0010 (0x0040 - 0x0030)
class UAIMoveToPositionData final : public UAICharacterBehaviourData
{
public:
	class AActor*                                 _positionActor;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharacterMovementTypes                       _movementType;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _usePathfinding;                                   // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class AActor* positionActor, ECharacterMovementTypes movementType, bool usePathfinding);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMoveToPositionData">();
	}
	static class UAIMoveToPositionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMoveToPositionData>();
	}
};
static_assert(alignof(UAIMoveToPositionData) == 0x000008, "Wrong alignment on UAIMoveToPositionData");
static_assert(sizeof(UAIMoveToPositionData) == 0x000040, "Wrong size on UAIMoveToPositionData");
static_assert(offsetof(UAIMoveToPositionData, _positionActor) == 0x000030, "Member 'UAIMoveToPositionData::_positionActor' has a wrong offset!");
static_assert(offsetof(UAIMoveToPositionData, _movementType) == 0x000038, "Member 'UAIMoveToPositionData::_movementType' has a wrong offset!");
static_assert(offsetof(UAIMoveToPositionData, _usePathfinding) == 0x000039, "Member 'UAIMoveToPositionData::_usePathfinding' has a wrong offset!");

// Class DeadByDaylight.AIMoveToPosition
// 0x0018 (0x0070 - 0x0058)
class UAIMoveToPosition final : public UAICharacterBehaviour
{
public:
	class UAIMoveToPositionData*                  _aiBehaviourData;                                  // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _aiController;                                     // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class ADBDPlayer* character, class UAICharacterBehaviourData* behaviourData);
	void TargetPositionReached(const struct FAIRequestID& RequestID, EPathFollowingResult Result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIMoveToPosition">();
	}
	static class UAIMoveToPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIMoveToPosition>();
	}
};
static_assert(alignof(UAIMoveToPosition) == 0x000008, "Wrong alignment on UAIMoveToPosition");
static_assert(sizeof(UAIMoveToPosition) == 0x000070, "Wrong size on UAIMoveToPosition");
static_assert(offsetof(UAIMoveToPosition, _aiBehaviourData) == 0x000058, "Member 'UAIMoveToPosition::_aiBehaviourData' has a wrong offset!");
static_assert(offsetof(UAIMoveToPosition, _aiController) == 0x000060, "Member 'UAIMoveToPosition::_aiController' has a wrong offset!");

// Class DeadByDaylight.UMGBaseStorefrontWidget
// 0x0000 (0x0338 - 0x0338)
class UUMGBaseStorefrontWidget : public UMobileBaseUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBaseStorefrontWidget">();
	}
	static class UUMGBaseStorefrontWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBaseStorefrontWidget>();
	}
};
static_assert(alignof(UUMGBaseStorefrontWidget) == 0x000008, "Wrong alignment on UUMGBaseStorefrontWidget");
static_assert(sizeof(UUMGBaseStorefrontWidget) == 0x000338, "Wrong size on UUMGBaseStorefrontWidget");

// Class DeadByDaylight.UMGBaseLandingPageStorefrontWidget
// 0x00F0 (0x0428 - 0x0338)
class UUMGBaseLandingPageStorefrontWidget : public UUMGBaseStorefrontWidget
{
public:
	class UHorizontalBox*                         BigButtonsSlot;                                    // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           SmallButtonsSlot1;                                 // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           SmallButtonsSlot2;                                 // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SmallButtonClass;                                  // 0x0350(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   MediumButtonClass;                                 // 0x0380(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   BigButtonClass;                                    // 0x03B0(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           DisabledButtonColor;                               // 0x03E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DisabledButtonText;                                // 0x03F0(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x10];                                     // 0x0408(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUMGLandingPageButtonWidget*>    _landingPageTabs;                                  // 0x0418(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void HandleTabSelected(const EStorefrontState& tabId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBaseLandingPageStorefrontWidget">();
	}
	static class UUMGBaseLandingPageStorefrontWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBaseLandingPageStorefrontWidget>();
	}
};
static_assert(alignof(UUMGBaseLandingPageStorefrontWidget) == 0x000008, "Wrong alignment on UUMGBaseLandingPageStorefrontWidget");
static_assert(sizeof(UUMGBaseLandingPageStorefrontWidget) == 0x000428, "Wrong size on UUMGBaseLandingPageStorefrontWidget");
static_assert(offsetof(UUMGBaseLandingPageStorefrontWidget, BigButtonsSlot) == 0x000338, "Member 'UUMGBaseLandingPageStorefrontWidget::BigButtonsSlot' has a wrong offset!");
static_assert(offsetof(UUMGBaseLandingPageStorefrontWidget, SmallButtonsSlot1) == 0x000340, "Member 'UUMGBaseLandingPageStorefrontWidget::SmallButtonsSlot1' has a wrong offset!");
static_assert(offsetof(UUMGBaseLandingPageStorefrontWidget, SmallButtonsSlot2) == 0x000348, "Member 'UUMGBaseLandingPageStorefrontWidget::SmallButtonsSlot2' has a wrong offset!");
static_assert(offsetof(UUMGBaseLandingPageStorefrontWidget, SmallButtonClass) == 0x000350, "Member 'UUMGBaseLandingPageStorefrontWidget::SmallButtonClass' has a wrong offset!");
static_assert(offsetof(UUMGBaseLandingPageStorefrontWidget, MediumButtonClass) == 0x000380, "Member 'UUMGBaseLandingPageStorefrontWidget::MediumButtonClass' has a wrong offset!");
static_assert(offsetof(UUMGBaseLandingPageStorefrontWidget, BigButtonClass) == 0x0003B0, "Member 'UUMGBaseLandingPageStorefrontWidget::BigButtonClass' has a wrong offset!");
static_assert(offsetof(UUMGBaseLandingPageStorefrontWidget, DisabledButtonColor) == 0x0003E0, "Member 'UUMGBaseLandingPageStorefrontWidget::DisabledButtonColor' has a wrong offset!");
static_assert(offsetof(UUMGBaseLandingPageStorefrontWidget, DisabledButtonText) == 0x0003F0, "Member 'UUMGBaseLandingPageStorefrontWidget::DisabledButtonText' has a wrong offset!");
static_assert(offsetof(UUMGBaseLandingPageStorefrontWidget, _landingPageTabs) == 0x000418, "Member 'UUMGBaseLandingPageStorefrontWidget::_landingPageTabs' has a wrong offset!");

// Class DeadByDaylight.UMGAtlLandingPageStorefrontWidget
// 0x0018 (0x0440 - 0x0428)
class UUMGAtlLandingPageStorefrontWidget final : public UUMGBaseLandingPageStorefrontWidget
{
public:
	uint8                                         Pad_428[0x10];                                     // 0x0428(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGBaseButtonWidget*                   AtlantaRedeemCodeBtn;                              // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPromoCodeButtonPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlLandingPageStorefrontWidget">();
	}
	static class UUMGAtlLandingPageStorefrontWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlLandingPageStorefrontWidget>();
	}
};
static_assert(alignof(UUMGAtlLandingPageStorefrontWidget) == 0x000008, "Wrong alignment on UUMGAtlLandingPageStorefrontWidget");
static_assert(sizeof(UUMGAtlLandingPageStorefrontWidget) == 0x000440, "Wrong size on UUMGAtlLandingPageStorefrontWidget");
static_assert(offsetof(UUMGAtlLandingPageStorefrontWidget, AtlantaRedeemCodeBtn) == 0x000438, "Member 'UUMGAtlLandingPageStorefrontWidget::AtlantaRedeemCodeBtn' has a wrong offset!");

// Class DeadByDaylight.AIPointOfInterestTargetInterface
// 0x0000 (0x0000 - 0x0000)
class IAIPointOfInterestTargetInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIPointOfInterestTargetInterface">();
	}
	static class IAIPointOfInterestTargetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAIPointOfInterestTargetInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAIPointOfInterestTargetInterface) == 0x000001, "Wrong alignment on IAIPointOfInterestTargetInterface");
static_assert(sizeof(IAIPointOfInterestTargetInterface) == 0x000001, "Wrong size on IAIPointOfInterestTargetInterface");

// Class DeadByDaylight.UMGSettingContextButton
// 0x0018 (0x0350 - 0x0338)
class UUMGSettingContextButton final : public UMobileBaseUserWidget
{
public:
	TMulticastInlineDelegate<void(int32 tabIndex)> OnSettingContextButtonClickEvent;                 // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetContextButtonData();
	void HandleSettingContextButtonClick();
	void SetButtonText(const class FString& buttonText);
	void SetContextButtonData(int32 buttonID);
	void SetIsSelected(bool isSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSettingContextButton">();
	}
	static class UUMGSettingContextButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSettingContextButton>();
	}
};
static_assert(alignof(UUMGSettingContextButton) == 0x000008, "Wrong alignment on UUMGSettingContextButton");
static_assert(sizeof(UUMGSettingContextButton) == 0x000350, "Wrong size on UUMGSettingContextButton");
static_assert(offsetof(UUMGSettingContextButton, OnSettingContextButtonClickEvent) == 0x000338, "Member 'UUMGSettingContextButton::OnSettingContextButtonClickEvent' has a wrong offset!");

// Class DeadByDaylight.EventObjectComponent
// 0x0010 (0x00C8 - 0x00B8)
class UEventObjectComponent : public UActorComponent
{
public:
	class FName                                   _eventId;                                          // 0x00B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventObjectComponent">();
	}
	static class UEventObjectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventObjectComponent>();
	}
};
static_assert(alignof(UEventObjectComponent) == 0x000008, "Wrong alignment on UEventObjectComponent");
static_assert(sizeof(UEventObjectComponent) == 0x0000C8, "Wrong size on UEventObjectComponent");
static_assert(offsetof(UEventObjectComponent, _eventId) == 0x0000B8, "Member 'UEventObjectComponent::_eventId' has a wrong offset!");

// Class DeadByDaylight.EventHookComponent
// 0x0018 (0x00E0 - 0x00C8)
class UEventHookComponent final : public UEventObjectComponent
{
public:
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _updateOutlineForSurvivor;                         // 0x00D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _updateOutlineForSlasher;                          // 0x00D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOutlineCarryingColorToDefault();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventHookComponent">();
	}
	static class UEventHookComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventHookComponent>();
	}
};
static_assert(alignof(UEventHookComponent) == 0x000008, "Wrong alignment on UEventHookComponent");
static_assert(sizeof(UEventHookComponent) == 0x0000E0, "Wrong size on UEventHookComponent");
static_assert(offsetof(UEventHookComponent, _updateOutlineForSurvivor) == 0x0000D8, "Member 'UEventHookComponent::_updateOutlineForSurvivor' has a wrong offset!");
static_assert(offsetof(UEventHookComponent, _updateOutlineForSlasher) == 0x0000D9, "Member 'UEventHookComponent::_updateOutlineForSlasher' has a wrong offset!");

// Class DeadByDaylight.AISenseConfig_PointOfInterest
// 0x0010 (0x0060 - 0x0050)
class UAISenseConfig_PointOfInterest final : public UAISenseConfig
{
public:
	TSubclassOf<class UAISense_PointOfInterest>   Implementation;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinGeneratorRepairSoundRange;                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGeneratorRepairSoundRange;                      // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_PointOfInterest">();
	}
	static class UAISenseConfig_PointOfInterest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_PointOfInterest>();
	}
};
static_assert(alignof(UAISenseConfig_PointOfInterest) == 0x000008, "Wrong alignment on UAISenseConfig_PointOfInterest");
static_assert(sizeof(UAISenseConfig_PointOfInterest) == 0x000060, "Wrong size on UAISenseConfig_PointOfInterest");
static_assert(offsetof(UAISenseConfig_PointOfInterest, Implementation) == 0x000050, "Member 'UAISenseConfig_PointOfInterest::Implementation' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_PointOfInterest, MinGeneratorRepairSoundRange) == 0x000058, "Member 'UAISenseConfig_PointOfInterest::MinGeneratorRepairSoundRange' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_PointOfInterest, MaxGeneratorRepairSoundRange) == 0x00005C, "Member 'UAISenseConfig_PointOfInterest::MaxGeneratorRepairSoundRange' has a wrong offset!");

// Class DeadByDaylight.AISense_PointOfInterest
// 0x0010 (0x00A0 - 0x0090)
class UAISense_PointOfInterest final : public UAISense
{
public:
	TArray<class AActor*>                         _sources;                                          // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_PointOfInterest">();
	}
	static class UAISense_PointOfInterest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_PointOfInterest>();
	}
};
static_assert(alignof(UAISense_PointOfInterest) == 0x000008, "Wrong alignment on UAISense_PointOfInterest");
static_assert(sizeof(UAISense_PointOfInterest) == 0x0000A0, "Wrong size on UAISense_PointOfInterest");
static_assert(offsetof(UAISense_PointOfInterest, _sources) == 0x000090, "Member 'UAISense_PointOfInterest::_sources' has a wrong offset!");

// Class DeadByDaylight.UMGSettingContextWidget
// 0x0018 (0x0350 - 0x0338)
class UUMGSettingContextWidget : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x18];                                     // 0x0338(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleContextButtonClickEvent(int32 buttonData);
	void SetContextTitle(const class FText& contextTitle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSettingContextWidget">();
	}
	static class UUMGSettingContextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSettingContextWidget>();
	}
};
static_assert(alignof(UUMGSettingContextWidget) == 0x000008, "Wrong alignment on UUMGSettingContextWidget");
static_assert(sizeof(UUMGSettingContextWidget) == 0x000350, "Wrong size on UUMGSettingContextWidget");

// Class DeadByDaylight.UMGSettingLanguageContextWidget
// 0x0048 (0x0398 - 0x0350)
class UUMGSettingLanguageContextWidget final : public UUMGSettingContextWidget
{
public:
	class UScrollBox*                             LanguageScrollBox;                                 // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   _languageButtonClass;                              // 0x0358(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _languageListRowGap;                               // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGSettingContextButton*               _selectedLanguageButton;                           // 0x0390(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSettingLanguageContextWidget">();
	}
	static class UUMGSettingLanguageContextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSettingLanguageContextWidget>();
	}
};
static_assert(alignof(UUMGSettingLanguageContextWidget) == 0x000008, "Wrong alignment on UUMGSettingLanguageContextWidget");
static_assert(sizeof(UUMGSettingLanguageContextWidget) == 0x000398, "Wrong size on UUMGSettingLanguageContextWidget");
static_assert(offsetof(UUMGSettingLanguageContextWidget, LanguageScrollBox) == 0x000350, "Member 'UUMGSettingLanguageContextWidget::LanguageScrollBox' has a wrong offset!");
static_assert(offsetof(UUMGSettingLanguageContextWidget, _languageButtonClass) == 0x000358, "Member 'UUMGSettingLanguageContextWidget::_languageButtonClass' has a wrong offset!");
static_assert(offsetof(UUMGSettingLanguageContextWidget, _languageListRowGap) == 0x000388, "Member 'UUMGSettingLanguageContextWidget::_languageListRowGap' has a wrong offset!");
static_assert(offsetof(UUMGSettingLanguageContextWidget, _selectedLanguageButton) == 0x000390, "Member 'UUMGSettingLanguageContextWidget::_selectedLanguageButton' has a wrong offset!");

// Class DeadByDaylight.EscapeRequirementTracker
// 0x0038 (0x0068 - 0x0030)
class UEscapeRequirementTracker final : public UObject
{
public:
	TArray<class AGenerator*>                     _escapeGenerators;                                 // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class ADBDGameState*                          _dbdGameState;                                     // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameEventDispatched(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeRequirementTracker">();
	}
	static class UEscapeRequirementTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEscapeRequirementTracker>();
	}
};
static_assert(alignof(UEscapeRequirementTracker) == 0x000008, "Wrong alignment on UEscapeRequirementTracker");
static_assert(sizeof(UEscapeRequirementTracker) == 0x000068, "Wrong size on UEscapeRequirementTracker");
static_assert(offsetof(UEscapeRequirementTracker, _escapeGenerators) == 0x000030, "Member 'UEscapeRequirementTracker::_escapeGenerators' has a wrong offset!");
static_assert(offsetof(UEscapeRequirementTracker, _dbdGameState) == 0x000040, "Member 'UEscapeRequirementTracker::_dbdGameState' has a wrong offset!");

// Class DeadByDaylight.AISenseConfig_Trail
// 0x0018 (0x0068 - 0x0050)
class UAISenseConfig_Trail final : public UAISenseConfig
{
public:
	TSubclassOf<class UAISense_Trail>             Implementation;                                    // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PeripheralVisionAngleDegrees;                      // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAISenseAffiliationFilter              DetectionByAffiliation;                            // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_Trail">();
	}
	static class UAISenseConfig_Trail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_Trail>();
	}
};
static_assert(alignof(UAISenseConfig_Trail) == 0x000008, "Wrong alignment on UAISenseConfig_Trail");
static_assert(sizeof(UAISenseConfig_Trail) == 0x000068, "Wrong size on UAISenseConfig_Trail");
static_assert(offsetof(UAISenseConfig_Trail, Implementation) == 0x000050, "Member 'UAISenseConfig_Trail::Implementation' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Trail, MaxRange) == 0x000058, "Member 'UAISenseConfig_Trail::MaxRange' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Trail, PeripheralVisionAngleDegrees) == 0x00005C, "Member 'UAISenseConfig_Trail::PeripheralVisionAngleDegrees' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_Trail, DetectionByAffiliation) == 0x000060, "Member 'UAISenseConfig_Trail::DetectionByAffiliation' has a wrong offset!");

// Class DeadByDaylight.DBDSocialNotificationFactory
// 0x0040 (0x0070 - 0x0030)
class UDBDSocialNotificationFactory final : public UObject
{
public:
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UToastManager*                          _toastMgr;                                         // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDPartyFacade*                        _partyFacade;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFriendManager*                         _friendManager;                                    // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             _toastTable;                                       // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSocialNotificationFactory">();
	}
	static class UDBDSocialNotificationFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSocialNotificationFactory>();
	}
};
static_assert(alignof(UDBDSocialNotificationFactory) == 0x000008, "Wrong alignment on UDBDSocialNotificationFactory");
static_assert(sizeof(UDBDSocialNotificationFactory) == 0x000070, "Wrong size on UDBDSocialNotificationFactory");
static_assert(offsetof(UDBDSocialNotificationFactory, _gameInstance) == 0x000030, "Member 'UDBDSocialNotificationFactory::_gameInstance' has a wrong offset!");
static_assert(offsetof(UDBDSocialNotificationFactory, _toastMgr) == 0x000038, "Member 'UDBDSocialNotificationFactory::_toastMgr' has a wrong offset!");
static_assert(offsetof(UDBDSocialNotificationFactory, _partyFacade) == 0x000040, "Member 'UDBDSocialNotificationFactory::_partyFacade' has a wrong offset!");
static_assert(offsetof(UDBDSocialNotificationFactory, _friendManager) == 0x000048, "Member 'UDBDSocialNotificationFactory::_friendManager' has a wrong offset!");
static_assert(offsetof(UDBDSocialNotificationFactory, _toastTable) == 0x000050, "Member 'UDBDSocialNotificationFactory::_toastTable' has a wrong offset!");

// Class DeadByDaylight.AISense_Trail
// 0x0060 (0x00F0 - 0x0090)
class UAISense_Trail final : public UAISense
{
public:
	TArray<struct FAITrailEvent>                  Events;                                            // 0x0090(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x50];                                      // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ReportTrailEvent(class UObject* worldContextObj, const struct FVector& location, class AActor* instigator, const struct FGameplayTag& ignoreOnPerkTag, float lifeTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_Trail">();
	}
	static class UAISense_Trail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_Trail>();
	}
};
static_assert(alignof(UAISense_Trail) == 0x000008, "Wrong alignment on UAISense_Trail");
static_assert(sizeof(UAISense_Trail) == 0x0000F0, "Wrong size on UAISense_Trail");
static_assert(offsetof(UAISense_Trail, Events) == 0x000090, "Member 'UAISense_Trail::Events' has a wrong offset!");

// Class DeadByDaylight.AISlasherChaseAndAttackBehaviourData
// 0x0010 (0x0040 - 0x0030)
class UAISlasherChaseAndAttackBehaviourData final : public UAICharacterBehaviourData
{
public:
	class ACamperPlayer*                          _targetSurvivor;                                   // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sqrtAttackRangeDistance;                          // 0x0038(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sqrtMaxTargetPositionDiff;                        // 0x003C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Init(class ACamperPlayer* targetSurvivor, float attackRangeDistance, float locationDistance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISlasherChaseAndAttackBehaviourData">();
	}
	static class UAISlasherChaseAndAttackBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISlasherChaseAndAttackBehaviourData>();
	}
};
static_assert(alignof(UAISlasherChaseAndAttackBehaviourData) == 0x000008, "Wrong alignment on UAISlasherChaseAndAttackBehaviourData");
static_assert(sizeof(UAISlasherChaseAndAttackBehaviourData) == 0x000040, "Wrong size on UAISlasherChaseAndAttackBehaviourData");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviourData, _targetSurvivor) == 0x000030, "Member 'UAISlasherChaseAndAttackBehaviourData::_targetSurvivor' has a wrong offset!");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviourData, _sqrtAttackRangeDistance) == 0x000038, "Member 'UAISlasherChaseAndAttackBehaviourData::_sqrtAttackRangeDistance' has a wrong offset!");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviourData, _sqrtMaxTargetPositionDiff) == 0x00003C, "Member 'UAISlasherChaseAndAttackBehaviourData::_sqrtMaxTargetPositionDiff' has a wrong offset!");

// Class DeadByDaylight.AISlasherChaseAndAttackBehaviour
// 0x0028 (0x0080 - 0x0058)
class UAISlasherChaseAndAttackBehaviour final : public UAICharacterBehaviour
{
public:
	class UAISlasherChaseAndAttackBehaviourData*  _behaviourData;                                    // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASlasherPlayer*                         _slasherPlayer;                                    // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _slasherAIPlayerController;                        // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISlasherChaseAndAttackBehaviour">();
	}
	static class UAISlasherChaseAndAttackBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISlasherChaseAndAttackBehaviour>();
	}
};
static_assert(alignof(UAISlasherChaseAndAttackBehaviour) == 0x000008, "Wrong alignment on UAISlasherChaseAndAttackBehaviour");
static_assert(sizeof(UAISlasherChaseAndAttackBehaviour) == 0x000080, "Wrong size on UAISlasherChaseAndAttackBehaviour");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviour, _behaviourData) == 0x000058, "Member 'UAISlasherChaseAndAttackBehaviour::_behaviourData' has a wrong offset!");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviour, _slasherPlayer) == 0x000060, "Member 'UAISlasherChaseAndAttackBehaviour::_slasherPlayer' has a wrong offset!");
static_assert(offsetof(UAISlasherChaseAndAttackBehaviour, _slasherAIPlayerController) == 0x000068, "Member 'UAISlasherChaseAndAttackBehaviour::_slasherAIPlayerController' has a wrong offset!");

// Class DeadByDaylight.UMGAuthentificationProviderListWidget
// 0x0008 (0x0340 - 0x0338)
class UUMGAuthentificationProviderListWidget final : public UMobileBaseUserWidget
{
public:
	class UHorizontalBox*                         GuestButtonContainer;                              // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HideGuestButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAuthentificationProviderListWidget">();
	}
	static class UUMGAuthentificationProviderListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAuthentificationProviderListWidget>();
	}
};
static_assert(alignof(UUMGAuthentificationProviderListWidget) == 0x000008, "Wrong alignment on UUMGAuthentificationProviderListWidget");
static_assert(sizeof(UUMGAuthentificationProviderListWidget) == 0x000340, "Wrong size on UUMGAuthentificationProviderListWidget");
static_assert(offsetof(UUMGAuthentificationProviderListWidget, GuestButtonContainer) == 0x000338, "Member 'UUMGAuthentificationProviderListWidget::GuestButtonContainer' has a wrong offset!");

// Class DeadByDaylight.AISlasherMoveToGrabSurvivorBehaviourData
// 0x0008 (0x0038 - 0x0030)
class UAISlasherMoveToGrabSurvivorBehaviourData final : public UAICharacterBehaviourData
{
public:
	class ACamperPlayer*                          _targetSurvivor;                                   // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Init(class ACamperPlayer* targetSurvivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISlasherMoveToGrabSurvivorBehaviourData">();
	}
	static class UAISlasherMoveToGrabSurvivorBehaviourData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISlasherMoveToGrabSurvivorBehaviourData>();
	}
};
static_assert(alignof(UAISlasherMoveToGrabSurvivorBehaviourData) == 0x000008, "Wrong alignment on UAISlasherMoveToGrabSurvivorBehaviourData");
static_assert(sizeof(UAISlasherMoveToGrabSurvivorBehaviourData) == 0x000038, "Wrong size on UAISlasherMoveToGrabSurvivorBehaviourData");
static_assert(offsetof(UAISlasherMoveToGrabSurvivorBehaviourData, _targetSurvivor) == 0x000030, "Member 'UAISlasherMoveToGrabSurvivorBehaviourData::_targetSurvivor' has a wrong offset!");

// Class DeadByDaylight.UMGLoadoutBaseWidget
// 0x0058 (0x0390 - 0x0338)
class UUMGLoadoutBaseWidget : public UMobileBaseUserWidget
{
public:
	class UUMGLoadoutItemButton*                  ItemOrPowerButton;                                 // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGLoadoutItemButton*                  AddonFirstButton;                                  // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGLoadoutItemButton*                  AddonSecondButton;                                 // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGLoadoutItemButton*                  OfferingButton;                                    // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGLoadoutItemButton*                  PerkFirstButton;                                   // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGLoadoutItemButton*                  PerkSecondButton;                                  // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGLoadoutItemButton*                  PerkThirdButton;                                   // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGLoadoutItemButton*                  PerkFourthButton;                                  // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUMGLoadoutItemButton*>          LoadoutItemButtons;                                // 0x0378(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          UsingMatchRules;                                   // 0x0388(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          PerkSlotsLockedByAdmin;                            // 0x0389(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSlasher;                                         // 0x038A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38B[0x5];                                      // 0x038B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDividerImageColor(const struct FLinearColor& color);
	void SetIsSelectedLoadoutItemButton(ELoadoutSlot loadoutSlot);
	void SetLoadoutData(const TArray<struct FInventorySlotData>& loadoutData, bool usingMatchRules, bool perkSlotsLockedByAdmin, ELoadoutSlot loadoutSlot, bool isSlasher, bool isClickable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLoadoutBaseWidget">();
	}
	static class UUMGLoadoutBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLoadoutBaseWidget>();
	}
};
static_assert(alignof(UUMGLoadoutBaseWidget) == 0x000008, "Wrong alignment on UUMGLoadoutBaseWidget");
static_assert(sizeof(UUMGLoadoutBaseWidget) == 0x000390, "Wrong size on UUMGLoadoutBaseWidget");
static_assert(offsetof(UUMGLoadoutBaseWidget, ItemOrPowerButton) == 0x000338, "Member 'UUMGLoadoutBaseWidget::ItemOrPowerButton' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutBaseWidget, AddonFirstButton) == 0x000340, "Member 'UUMGLoadoutBaseWidget::AddonFirstButton' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutBaseWidget, AddonSecondButton) == 0x000348, "Member 'UUMGLoadoutBaseWidget::AddonSecondButton' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutBaseWidget, OfferingButton) == 0x000350, "Member 'UUMGLoadoutBaseWidget::OfferingButton' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutBaseWidget, PerkFirstButton) == 0x000358, "Member 'UUMGLoadoutBaseWidget::PerkFirstButton' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutBaseWidget, PerkSecondButton) == 0x000360, "Member 'UUMGLoadoutBaseWidget::PerkSecondButton' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutBaseWidget, PerkThirdButton) == 0x000368, "Member 'UUMGLoadoutBaseWidget::PerkThirdButton' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutBaseWidget, PerkFourthButton) == 0x000370, "Member 'UUMGLoadoutBaseWidget::PerkFourthButton' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutBaseWidget, LoadoutItemButtons) == 0x000378, "Member 'UUMGLoadoutBaseWidget::LoadoutItemButtons' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutBaseWidget, UsingMatchRules) == 0x000388, "Member 'UUMGLoadoutBaseWidget::UsingMatchRules' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutBaseWidget, PerkSlotsLockedByAdmin) == 0x000389, "Member 'UUMGLoadoutBaseWidget::PerkSlotsLockedByAdmin' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutBaseWidget, IsSlasher) == 0x00038A, "Member 'UUMGLoadoutBaseWidget::IsSlasher' has a wrong offset!");

// Class DeadByDaylight.DedicatedServerStartupInitializerInterface
// 0x0000 (0x0000 - 0x0000)
class IDedicatedServerStartupInitializerInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerStartupInitializerInterface">();
	}
	static class IDedicatedServerStartupInitializerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDedicatedServerStartupInitializerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDedicatedServerStartupInitializerInterface) == 0x000001, "Wrong alignment on IDedicatedServerStartupInitializerInterface");
static_assert(sizeof(IDedicatedServerStartupInitializerInterface) == 0x000001, "Wrong size on IDedicatedServerStartupInitializerInterface");

// Class DeadByDaylight.AISlasherMoveToGrabSurvivorBehaviour
// 0x0028 (0x0080 - 0x0058)
class UAISlasherMoveToGrabSurvivorBehaviour final : public UAICharacterBehaviour
{
public:
	class UAISlasherMoveToGrabSurvivorBehaviourData* _behaviourData;                                 // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASlasherPlayer*                         _slasherPlayer;                                    // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDAIPlayerController*                 _slasherAIPlayerController;                        // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISlasherMoveToGrabSurvivorBehaviour">();
	}
	static class UAISlasherMoveToGrabSurvivorBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISlasherMoveToGrabSurvivorBehaviour>();
	}
};
static_assert(alignof(UAISlasherMoveToGrabSurvivorBehaviour) == 0x000008, "Wrong alignment on UAISlasherMoveToGrabSurvivorBehaviour");
static_assert(sizeof(UAISlasherMoveToGrabSurvivorBehaviour) == 0x000080, "Wrong size on UAISlasherMoveToGrabSurvivorBehaviour");
static_assert(offsetof(UAISlasherMoveToGrabSurvivorBehaviour, _behaviourData) == 0x000058, "Member 'UAISlasherMoveToGrabSurvivorBehaviour::_behaviourData' has a wrong offset!");
static_assert(offsetof(UAISlasherMoveToGrabSurvivorBehaviour, _slasherPlayer) == 0x000060, "Member 'UAISlasherMoveToGrabSurvivorBehaviour::_slasherPlayer' has a wrong offset!");
static_assert(offsetof(UAISlasherMoveToGrabSurvivorBehaviour, _slasherAIPlayerController) == 0x000068, "Member 'UAISlasherMoveToGrabSurvivorBehaviour::_slasherAIPlayerController' has a wrong offset!");

// Class DeadByDaylight.UMGLoadoutFilterWidget
// 0x0078 (0x03B0 - 0x0338)
class UUMGLoadoutFilterWidget final : public UMobileBaseUserWidget
{
public:
	TMulticastInlineDelegate<void(class FName filterName)> OnLoadoutFilterClicked;                   // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AtlantaLoadoutFilterButtonClass;                   // 0x0348(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         FilterContainerBox;                                // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           Filters;                                           // 0x0380(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UUMGLoadoutFilterButton*>        FilterButtons;                                     // 0x0390(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UUMGLoadoutFilterButton*                SelectedFilterButton;                              // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearSelectedFilter();
	void InitFilterWidget(const TMap<class FName, TSoftObjectPtr<class UTexture2D>>& filtersInfo);
	void OnFilterButtonClicked(class FName filterName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLoadoutFilterWidget">();
	}
	static class UUMGLoadoutFilterWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLoadoutFilterWidget>();
	}
};
static_assert(alignof(UUMGLoadoutFilterWidget) == 0x000008, "Wrong alignment on UUMGLoadoutFilterWidget");
static_assert(sizeof(UUMGLoadoutFilterWidget) == 0x0003B0, "Wrong size on UUMGLoadoutFilterWidget");
static_assert(offsetof(UUMGLoadoutFilterWidget, OnLoadoutFilterClicked) == 0x000338, "Member 'UUMGLoadoutFilterWidget::OnLoadoutFilterClicked' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutFilterWidget, AtlantaLoadoutFilterButtonClass) == 0x000348, "Member 'UUMGLoadoutFilterWidget::AtlantaLoadoutFilterButtonClass' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutFilterWidget, FilterContainerBox) == 0x000378, "Member 'UUMGLoadoutFilterWidget::FilterContainerBox' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutFilterWidget, Filters) == 0x000380, "Member 'UUMGLoadoutFilterWidget::Filters' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutFilterWidget, FilterButtons) == 0x000390, "Member 'UUMGLoadoutFilterWidget::FilterButtons' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutFilterWidget, SelectedFilterButton) == 0x0003A0, "Member 'UUMGLoadoutFilterWidget::SelectedFilterButton' has a wrong offset!");

// Class DeadByDaylight.DecalMaskedMaterialsList
// 0x0060 (0x0098 - 0x0038)
class UDecalMaskedMaterialsList final : public UDataAsset
{
public:
	class UStaticMesh*                            decalPlaneStaticMesh;                              // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         decalPlaneExtent;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UMaterialInterface*>  decalMaskedMaterials;                              // 0x0048(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecalMaskedMaterialsList">();
	}
	static class UDecalMaskedMaterialsList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecalMaskedMaterialsList>();
	}
};
static_assert(alignof(UDecalMaskedMaterialsList) == 0x000008, "Wrong alignment on UDecalMaskedMaterialsList");
static_assert(sizeof(UDecalMaskedMaterialsList) == 0x000098, "Wrong size on UDecalMaskedMaterialsList");
static_assert(offsetof(UDecalMaskedMaterialsList, decalPlaneStaticMesh) == 0x000038, "Member 'UDecalMaskedMaterialsList::decalPlaneStaticMesh' has a wrong offset!");
static_assert(offsetof(UDecalMaskedMaterialsList, decalPlaneExtent) == 0x000040, "Member 'UDecalMaskedMaterialsList::decalPlaneExtent' has a wrong offset!");
static_assert(offsetof(UDecalMaskedMaterialsList, decalMaskedMaterials) == 0x000048, "Member 'UDecalMaskedMaterialsList::decalMaskedMaterials' has a wrong offset!");

// Class DeadByDaylight.AlertsScreen
// 0x0018 (0x0138 - 0x0120)
class UAlertsScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RewardAlertSequenceCompleted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlertsScreen">();
	}
	static class UAlertsScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlertsScreen>();
	}
};
static_assert(alignof(UAlertsScreen) == 0x000008, "Wrong alignment on UAlertsScreen");
static_assert(sizeof(UAlertsScreen) == 0x000138, "Wrong size on UAlertsScreen");

// Class DeadByDaylight.AlwaysVisiblePerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UAlwaysVisiblePerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlwaysVisiblePerkIconStrategy">();
	}
	static class UAlwaysVisiblePerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlwaysVisiblePerkIconStrategy>();
	}
};
static_assert(alignof(UAlwaysVisiblePerkIconStrategy) == 0x000008, "Wrong alignment on UAlwaysVisiblePerkIconStrategy");
static_assert(sizeof(UAlwaysVisiblePerkIconStrategy) == 0x000038, "Wrong size on UAlwaysVisiblePerkIconStrategy");

// Class DeadByDaylight.ScreenshotVFXCharmHook
// 0x0018 (0x0048 - 0x0030)
class UScreenshotVFXCharmHook final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FScreenshotVFXCharmHookCharm>   Charms;                                            // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotVFXCharmHook">();
	}
	static class UScreenshotVFXCharmHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotVFXCharmHook>();
	}
};
static_assert(alignof(UScreenshotVFXCharmHook) == 0x000008, "Wrong alignment on UScreenshotVFXCharmHook");
static_assert(sizeof(UScreenshotVFXCharmHook) == 0x000048, "Wrong size on UScreenshotVFXCharmHook");
static_assert(offsetof(UScreenshotVFXCharmHook, Charms) == 0x000038, "Member 'UScreenshotVFXCharmHook::Charms' has a wrong offset!");

// Class DeadByDaylight.DBDTags
// 0x0000 (0x0030 - 0x0030)
class UDBDTags final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTags">();
	}
	static class UDBDTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTags>();
	}
};
static_assert(alignof(UDBDTags) == 0x000008, "Wrong alignment on UDBDTags");
static_assert(sizeof(UDBDTags) == 0x000030, "Wrong size on UDBDTags");

// Class DeadByDaylight.OfferingCardAnim
// 0x0020 (0x02E0 - 0x02C0)
class UOfferingCardAnim final : public UAnimInstance
{
public:
	TMulticastInlineDelegate<void()>              _onCardDissolved;                                  // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPrivate)
	EOfferingAnimState                            _activeState;                                      // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isRevealed;                                       // 0x02D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D2[0xE];                                      // 0x02D2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingCardAnim">();
	}
	static class UOfferingCardAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOfferingCardAnim>();
	}
};
static_assert(alignof(UOfferingCardAnim) == 0x000010, "Wrong alignment on UOfferingCardAnim");
static_assert(sizeof(UOfferingCardAnim) == 0x0002E0, "Wrong size on UOfferingCardAnim");
static_assert(offsetof(UOfferingCardAnim, _onCardDissolved) == 0x0002C0, "Member 'UOfferingCardAnim::_onCardDissolved' has a wrong offset!");
static_assert(offsetof(UOfferingCardAnim, _activeState) == 0x0002D0, "Member 'UOfferingCardAnim::_activeState' has a wrong offset!");
static_assert(offsetof(UOfferingCardAnim, _isRevealed) == 0x0002D1, "Member 'UOfferingCardAnim::_isRevealed' has a wrong offset!");

// Class DeadByDaylight.Gate
// 0x0018 (0x0248 - 0x0230)
class AGate : public AActor
{
public:
	TArray<float>                                 InteractionInputs;                                 // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         InteractionOutput;                                 // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gate">();
	}
	static class AGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGate>();
	}
};
static_assert(alignof(AGate) == 0x000008, "Wrong alignment on AGate");
static_assert(sizeof(AGate) == 0x000248, "Wrong size on AGate");
static_assert(offsetof(AGate, InteractionInputs) == 0x000230, "Member 'AGate::InteractionInputs' has a wrong offset!");
static_assert(offsetof(AGate, InteractionOutput) == 0x000240, "Member 'AGate::InteractionOutput' has a wrong offset!");

// Class DeadByDaylight.AndGate
// 0x0000 (0x0248 - 0x0248)
class AAndGate final : public AGate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AndGate">();
	}
	static class AAndGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAndGate>();
	}
};
static_assert(alignof(AAndGate) == 0x000008, "Wrong alignment on AAndGate");
static_assert(sizeof(AAndGate) == 0x000248, "Wrong size on AAndGate");

// Class DeadByDaylight.NewsContentManager
// 0x00D0 (0x0100 - 0x0030)
class UNewsContentManager final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0xB0];                                      // 0x0050(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NewsContentManager">();
	}
	static class UNewsContentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNewsContentManager>();
	}
};
static_assert(alignof(UNewsContentManager) == 0x000008, "Wrong alignment on UNewsContentManager");
static_assert(sizeof(UNewsContentManager) == 0x000100, "Wrong size on UNewsContentManager");
static_assert(offsetof(UNewsContentManager, _gameInstance) == 0x000048, "Member 'UNewsContentManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.DedicatedServerHandlerComponent
// 0x0058 (0x0110 - 0x00B8)
class UDedicatedServerHandlerComponent final : public UActorComponent
{
public:
	struct FAtlantaRitualSet                      _atlantaRituals;                                   // 0x00B8(0x0038)(NativeAccessSpecifierPrivate)
	TArray<struct FDailyRitualInstance>           _coreRituals;                                      // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void ReceiveGameEvent(EDBDScoreTypes scoreType, float amount, class AActor* instigator, class AActor* target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerHandlerComponent">();
	}
	static class UDedicatedServerHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDedicatedServerHandlerComponent>();
	}
};
static_assert(alignof(UDedicatedServerHandlerComponent) == 0x000008, "Wrong alignment on UDedicatedServerHandlerComponent");
static_assert(sizeof(UDedicatedServerHandlerComponent) == 0x000110, "Wrong size on UDedicatedServerHandlerComponent");
static_assert(offsetof(UDedicatedServerHandlerComponent, _atlantaRituals) == 0x0000B8, "Member 'UDedicatedServerHandlerComponent::_atlantaRituals' has a wrong offset!");
static_assert(offsetof(UDedicatedServerHandlerComponent, _coreRituals) == 0x0000F0, "Member 'UDedicatedServerHandlerComponent::_coreRituals' has a wrong offset!");

// Class DeadByDaylight.AnimationFollowerActor
// 0x0068 (0x0298 - 0x0230)
class AAnimationFollowerActor final : public AActor
{
public:
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent;                            // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationMontageSlave*                 _montageFollower;                                  // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x50];                                     // 0x0248(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnMontageStarted();
	void Cosmetic_OnMontageStopped();
	void NativeOnMontageEnded(const struct FAnimationMontageDescriptor& montage, bool interrupted);
	void NativeOnMontageStarted(const struct FAnimationMontageDescriptor& id, const float rate);
	void NativeOnMontageStopped(const struct FAnimationMontageDescriptor& id);
	void OnMontageEnd(const struct FAnimationMontageDescriptor& montage, bool interrupted);
	void OnMontageStarted(const struct FAnimationMontageDescriptor& id, const float rate);
	void OnMontageStopped(const struct FAnimationMontageDescriptor& id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationFollowerActor">();
	}
	static class AAnimationFollowerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAnimationFollowerActor>();
	}
};
static_assert(alignof(AAnimationFollowerActor) == 0x000008, "Wrong alignment on AAnimationFollowerActor");
static_assert(sizeof(AAnimationFollowerActor) == 0x000298, "Wrong size on AAnimationFollowerActor");
static_assert(offsetof(AAnimationFollowerActor, _skeletalMeshComponent) == 0x000230, "Member 'AAnimationFollowerActor::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AAnimationFollowerActor, _montageFollower) == 0x000238, "Member 'AAnimationFollowerActor::_montageFollower' has a wrong offset!");
static_assert(offsetof(AAnimationFollowerActor, _montagePlayer) == 0x000240, "Member 'AAnimationFollowerActor::_montagePlayer' has a wrong offset!");

// Class DeadByDaylight.NavArea_Danger
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Danger final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Danger">();
	}
	static class UNavArea_Danger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Danger>();
	}
};
static_assert(alignof(UNavArea_Danger) == 0x000008, "Wrong alignment on UNavArea_Danger");
static_assert(sizeof(UNavArea_Danger) == 0x000050, "Wrong size on UNavArea_Danger");

// Class DeadByDaylight.TutorialFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UTutorialFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class ATutorialGameMode* GetTutorialGameMode(class UObject* WorldContextObject);
	static class ATutorialGameState* GetTutorialGameState(class UObject* WorldContextObject);
	static class UTutorialHighlightController* GetTutorialHighlightController(class UObject* WorldContextObject);
	static class UTutorialNotificationController* GetTutorialNotificationController(class UObject* WorldContextObject);
	static class UTutorialObjectiveController* GetTutorialObjectiveController(class UObject* WorldContextObject);
	static bool IsInTutorial(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialFunctionLibrary">();
	}
	static class UTutorialFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialFunctionLibrary>();
	}
};
static_assert(alignof(UTutorialFunctionLibrary) == 0x000008, "Wrong alignment on UTutorialFunctionLibrary");
static_assert(sizeof(UTutorialFunctionLibrary) == 0x000030, "Wrong size on UTutorialFunctionLibrary");

// Class DeadByDaylight.AnimationMontageSlave
// 0x0008 (0x00C0 - 0x00B8)
class UAnimationMontageSlave final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMontageStarted(const struct FAnimationMontageDescriptor& id, const float rate);
	void OnMontageStopped(const struct FAnimationMontageDescriptor& id);
	void SetLeader(class UMontagePlayer* leader);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationMontageSlave">();
	}
	static class UAnimationMontageSlave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationMontageSlave>();
	}
};
static_assert(alignof(UAnimationMontageSlave) == 0x000008, "Wrong alignment on UAnimationMontageSlave");
static_assert(sizeof(UAnimationMontageSlave) == 0x0000C0, "Wrong size on UAnimationMontageSlave");

// Class DeadByDaylight.UMGBloodStoreWidget
// 0x00C0 (0x03F8 - 0x0338)
class UUMGBloodStoreWidget final : public UMobileBaseUserWidget
{
public:
	TMulticastInlineDelegate<void(int32 characterId, int32 nodeId, int32 nodeDepth)> OnBloodNodeSelected; // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 characterId)> OnBloodNodePurchase;                           // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 characterId)> OnBloodStoreRegenerate;                        // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCharacterRoleButtonClicked;                      // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UUMGBloodStoreArrayWidget*              BloodStoreArrayWidget;                             // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBloodStoreItemPreviewWidget*        ItemPreviewWidget;                                 // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBloodStoreSubMenu*                  BloodStoreSubMenuWidget;                           // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _bloodStoreTitle;                                  // 0x0390(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _killersTitle;                                     // 0x03A8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _survivorsTitle;                                   // 0x03C0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x20];                                     // 0x03D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PurchaseSelectedNode();
	void RegenerateBloodStore();
	void SetFaction(bool isKiller);
	void SetSelectedNode(const class FString& selectedId);
	void SwitchRole();
	void UnselectNode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBloodStoreWidget">();
	}
	static class UUMGBloodStoreWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBloodStoreWidget>();
	}
};
static_assert(alignof(UUMGBloodStoreWidget) == 0x000008, "Wrong alignment on UUMGBloodStoreWidget");
static_assert(sizeof(UUMGBloodStoreWidget) == 0x0003F8, "Wrong size on UUMGBloodStoreWidget");
static_assert(offsetof(UUMGBloodStoreWidget, OnBloodNodeSelected) == 0x000338, "Member 'UUMGBloodStoreWidget::OnBloodNodeSelected' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreWidget, OnBloodNodePurchase) == 0x000348, "Member 'UUMGBloodStoreWidget::OnBloodNodePurchase' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreWidget, OnBloodStoreRegenerate) == 0x000358, "Member 'UUMGBloodStoreWidget::OnBloodStoreRegenerate' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreWidget, OnCharacterRoleButtonClicked) == 0x000368, "Member 'UUMGBloodStoreWidget::OnCharacterRoleButtonClicked' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreWidget, BloodStoreArrayWidget) == 0x000378, "Member 'UUMGBloodStoreWidget::BloodStoreArrayWidget' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreWidget, ItemPreviewWidget) == 0x000380, "Member 'UUMGBloodStoreWidget::ItemPreviewWidget' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreWidget, BloodStoreSubMenuWidget) == 0x000388, "Member 'UUMGBloodStoreWidget::BloodStoreSubMenuWidget' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreWidget, _bloodStoreTitle) == 0x000390, "Member 'UUMGBloodStoreWidget::_bloodStoreTitle' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreWidget, _killersTitle) == 0x0003A8, "Member 'UUMGBloodStoreWidget::_killersTitle' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreWidget, _survivorsTitle) == 0x0003C0, "Member 'UUMGBloodStoreWidget::_survivorsTitle' has a wrong offset!");

// Class DeadByDaylight.DiscordancePerk
// 0x0060 (0x0428 - 0x03C8)
class UDiscordancePerk final : public UPerk
{
public:
	TArray<struct FGeneratorQueryHandlePair>      _generatorQueryHandlePairs;                        // 0x03C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x30];                                     // 0x03D8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _effectRange[0x3];                                 // 0x0408(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _auraLingerDuration;                               // 0x0414(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _numSurvivorsRepairingToReveal;                    // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41C[0x1];                                      // 0x041C(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isPerkConsideredActive;                           // 0x041D(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41E[0xA];                                      // 0x041E(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_AddGeneratorAura(class AGenerator* generator);
	void Multicast_AddLingeringGeneratorAura(class AGenerator* generator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DiscordancePerk">();
	}
	static class UDiscordancePerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDiscordancePerk>();
	}
};
static_assert(alignof(UDiscordancePerk) == 0x000008, "Wrong alignment on UDiscordancePerk");
static_assert(sizeof(UDiscordancePerk) == 0x000428, "Wrong size on UDiscordancePerk");
static_assert(offsetof(UDiscordancePerk, _generatorQueryHandlePairs) == 0x0003C8, "Member 'UDiscordancePerk::_generatorQueryHandlePairs' has a wrong offset!");
static_assert(offsetof(UDiscordancePerk, _effectRange) == 0x000408, "Member 'UDiscordancePerk::_effectRange' has a wrong offset!");
static_assert(offsetof(UDiscordancePerk, _auraLingerDuration) == 0x000414, "Member 'UDiscordancePerk::_auraLingerDuration' has a wrong offset!");
static_assert(offsetof(UDiscordancePerk, _numSurvivorsRepairingToReveal) == 0x000418, "Member 'UDiscordancePerk::_numSurvivorsRepairingToReveal' has a wrong offset!");
static_assert(offsetof(UDiscordancePerk, _isPerkConsideredActive) == 0x00041D, "Member 'UDiscordancePerk::_isPerkConsideredActive' has a wrong offset!");

// Class DeadByDaylight.AnimNotifyState_HideCustomizationAttachments
// 0x0008 (0x0040 - 0x0038)
class UAnimNotifyState_HideCustomizationAttachments final : public UAnimNotifyState
{
public:
	ECustomizationCategory                        Category;                                          // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_HideCustomizationAttachments">();
	}
	static class UAnimNotifyState_HideCustomizationAttachments* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_HideCustomizationAttachments>();
	}
};
static_assert(alignof(UAnimNotifyState_HideCustomizationAttachments) == 0x000008, "Wrong alignment on UAnimNotifyState_HideCustomizationAttachments");
static_assert(sizeof(UAnimNotifyState_HideCustomizationAttachments) == 0x000040, "Wrong size on UAnimNotifyState_HideCustomizationAttachments");
static_assert(offsetof(UAnimNotifyState_HideCustomizationAttachments, Category) == 0x000038, "Member 'UAnimNotifyState_HideCustomizationAttachments::Category' has a wrong offset!");

// Class DeadByDaylight.AnimTagProvider
// 0x0000 (0x0000 - 0x0000)
class IAnimTagProvider final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimTagProvider">();
	}
	static class IAnimTagProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimTagProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAnimTagProvider) == 0x000001, "Wrong alignment on IAnimTagProvider");
static_assert(sizeof(IAnimTagProvider) == 0x000001, "Wrong size on IAnimTagProvider");

// Class DeadByDaylight.UMGCharacterFreeTicketButton
// 0x0050 (0x0388 - 0x0338)
class UUMGCharacterFreeTicketButton final : public UMobileBaseUserWidget
{
public:
	class UWidgetSwitcher*                        ButtonSwitcher;                                    // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             FreeTicketLeftSecondsText;                         // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FreeTicketLeftSecondsBG;                           // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x38];                                     // 0x0350(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCharacterFreeTicketButton">();
	}
	static class UUMGCharacterFreeTicketButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCharacterFreeTicketButton>();
	}
};
static_assert(alignof(UUMGCharacterFreeTicketButton) == 0x000008, "Wrong alignment on UUMGCharacterFreeTicketButton");
static_assert(sizeof(UUMGCharacterFreeTicketButton) == 0x000388, "Wrong size on UUMGCharacterFreeTicketButton");
static_assert(offsetof(UUMGCharacterFreeTicketButton, ButtonSwitcher) == 0x000338, "Member 'UUMGCharacterFreeTicketButton::ButtonSwitcher' has a wrong offset!");
static_assert(offsetof(UUMGCharacterFreeTicketButton, FreeTicketLeftSecondsText) == 0x000340, "Member 'UUMGCharacterFreeTicketButton::FreeTicketLeftSecondsText' has a wrong offset!");
static_assert(offsetof(UUMGCharacterFreeTicketButton, FreeTicketLeftSecondsBG) == 0x000348, "Member 'UUMGCharacterFreeTicketButton::FreeTicketLeftSecondsBG' has a wrong offset!");

// Class DeadByDaylight.DestroyBreakableDefinition
// 0x0060 (0x0680 - 0x0620)
class UDestroyBreakableDefinition final : public UInteractionDefinition
{
public:
	float                                         _interactionTimePercentForDestroyEvent;            // 0x0618(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61C[0x2C];                                     // 0x061C(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	class ABreakableBase*                         _breakable;                                        // 0x0648(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _fastInteractionAnimThreshold;                     // 0x0650(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_678[0x8];                                      // 0x0678(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ABreakableBase* GetBreakable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DestroyBreakableDefinition">();
	}
	static class UDestroyBreakableDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDestroyBreakableDefinition>();
	}
};
static_assert(alignof(UDestroyBreakableDefinition) == 0x000010, "Wrong alignment on UDestroyBreakableDefinition");
static_assert(sizeof(UDestroyBreakableDefinition) == 0x000680, "Wrong size on UDestroyBreakableDefinition");
static_assert(offsetof(UDestroyBreakableDefinition, _interactionTimePercentForDestroyEvent) == 0x000618, "Member 'UDestroyBreakableDefinition::_interactionTimePercentForDestroyEvent' has a wrong offset!");
static_assert(offsetof(UDestroyBreakableDefinition, _breakable) == 0x000648, "Member 'UDestroyBreakableDefinition::_breakable' has a wrong offset!");
static_assert(offsetof(UDestroyBreakableDefinition, _fastInteractionAnimThreshold) == 0x000650, "Member 'UDestroyBreakableDefinition::_fastInteractionAnimThreshold' has a wrong offset!");

// Class DeadByDaylight.ApplicableActivationTimerElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UApplicableActivationTimerElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplicableActivationTimerElapsedIconStrategy">();
	}
	static class UApplicableActivationTimerElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplicableActivationTimerElapsedIconStrategy>();
	}
};
static_assert(alignof(UApplicableActivationTimerElapsedIconStrategy) == 0x000008, "Wrong alignment on UApplicableActivationTimerElapsedIconStrategy");
static_assert(sizeof(UApplicableActivationTimerElapsedIconStrategy) == 0x000038, "Wrong size on UApplicableActivationTimerElapsedIconStrategy");

// Class DeadByDaylight.ApplicableActivationTimerRemainingCooldownElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UApplicableActivationTimerRemainingCooldownElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplicableActivationTimerRemainingCooldownElapsedIconStrategy">();
	}
	static class UApplicableActivationTimerRemainingCooldownElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplicableActivationTimerRemainingCooldownElapsedIconStrategy>();
	}
};
static_assert(alignof(UApplicableActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000008, "Wrong alignment on UApplicableActivationTimerRemainingCooldownElapsedIconStrategy");
static_assert(sizeof(UApplicableActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000038, "Wrong size on UApplicableActivationTimerRemainingCooldownElapsedIconStrategy");

// Class DeadByDaylight.SectionnedChargeableComponent
// 0x0008 (0x0328 - 0x0320)
class USectionnedChargeableComponent final : public UChargeableComponent
{
public:
	uint8                                         _sections;                                         // 0x0320(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetSectionChargeRemaining() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SectionnedChargeableComponent">();
	}
	static class USectionnedChargeableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USectionnedChargeableComponent>();
	}
};
static_assert(alignof(USectionnedChargeableComponent) == 0x000008, "Wrong alignment on USectionnedChargeableComponent");
static_assert(sizeof(USectionnedChargeableComponent) == 0x000328, "Wrong size on USectionnedChargeableComponent");
static_assert(offsetof(USectionnedChargeableComponent, _sections) == 0x000320, "Member 'USectionnedChargeableComponent::_sections' has a wrong offset!");

// Class DeadByDaylight.DecalSpawner
// 0x0018 (0x0048 - 0x0030)
class UDecalSpawner final : public UObject
{
public:
	class UDecalCollection*                       _decalCollection;                                  // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpawnerStrategy*                       _spawnerStrategy;                                  // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USpawnerStrategy* GetSpawnerStrategy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecalSpawner">();
	}
	static class UDecalSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecalSpawner>();
	}
};
static_assert(alignof(UDecalSpawner) == 0x000008, "Wrong alignment on UDecalSpawner");
static_assert(sizeof(UDecalSpawner) == 0x000048, "Wrong size on UDecalSpawner");
static_assert(offsetof(UDecalSpawner, _decalCollection) == 0x000030, "Member 'UDecalSpawner::_decalCollection' has a wrong offset!");
static_assert(offsetof(UDecalSpawner, _spawnerStrategy) == 0x000038, "Member 'UDecalSpawner::_spawnerStrategy' has a wrong offset!");

// Class DeadByDaylight.OnboardingUtilities
// 0x0000 (0x0030 - 0x0030)
class UOnboardingUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnboardingUtilities">();
	}
	static class UOnboardingUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnboardingUtilities>();
	}
};
static_assert(alignof(UOnboardingUtilities) == 0x000008, "Wrong alignment on UOnboardingUtilities");
static_assert(sizeof(UOnboardingUtilities) == 0x000030, "Wrong size on UOnboardingUtilities");

// Class DeadByDaylight.ApplicableActivationTimerRemainingIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UApplicableActivationTimerRemainingIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplicableActivationTimerRemainingIconStrategy">();
	}
	static class UApplicableActivationTimerRemainingIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplicableActivationTimerRemainingIconStrategy>();
	}
};
static_assert(alignof(UApplicableActivationTimerRemainingIconStrategy) == 0x000008, "Wrong alignment on UApplicableActivationTimerRemainingIconStrategy");
static_assert(sizeof(UApplicableActivationTimerRemainingIconStrategy) == 0x000038, "Wrong size on UApplicableActivationTimerRemainingIconStrategy");

// Class DeadByDaylight.BasePopupScreen
// 0x0000 (0x0120 - 0x0120)
class UBasePopupScreen : public UScreenBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePopupScreen">();
	}
	static class UBasePopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePopupScreen>();
	}
};
static_assert(alignof(UBasePopupScreen) == 0x000008, "Wrong alignment on UBasePopupScreen");
static_assert(sizeof(UBasePopupScreen) == 0x000120, "Wrong size on UBasePopupScreen");

// Class DeadByDaylight.ObjectPlacementValidationStrategy
// 0x0000 (0x00B8 - 0x00B8)
class UObjectPlacementValidationStrategy : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPlacementValidationStrategy">();
	}
	static class UObjectPlacementValidationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectPlacementValidationStrategy>();
	}
};
static_assert(alignof(UObjectPlacementValidationStrategy) == 0x000008, "Wrong alignment on UObjectPlacementValidationStrategy");
static_assert(sizeof(UObjectPlacementValidationStrategy) == 0x0000B8, "Wrong size on UObjectPlacementValidationStrategy");

// Class DeadByDaylight.DefaultObjectPlacementValidationStrategy
// 0x0028 (0x00E0 - 0x00B8)
class UDefaultObjectPlacementValidationStrategy : public UObjectPlacementValidationStrategy
{
public:
	struct FVector                                _objectPlacementRaycastStart;                      // 0x00B8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _objectPlacementRaycastEnd;                        // 0x00C4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRange                            _objectHeightRangeAroundBaseLocation;              // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DefaultObjectPlacementValidationStrategy">();
	}
	static class UDefaultObjectPlacementValidationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDefaultObjectPlacementValidationStrategy>();
	}
};
static_assert(alignof(UDefaultObjectPlacementValidationStrategy) == 0x000008, "Wrong alignment on UDefaultObjectPlacementValidationStrategy");
static_assert(sizeof(UDefaultObjectPlacementValidationStrategy) == 0x0000E0, "Wrong size on UDefaultObjectPlacementValidationStrategy");
static_assert(offsetof(UDefaultObjectPlacementValidationStrategy, _objectPlacementRaycastStart) == 0x0000B8, "Member 'UDefaultObjectPlacementValidationStrategy::_objectPlacementRaycastStart' has a wrong offset!");
static_assert(offsetof(UDefaultObjectPlacementValidationStrategy, _objectPlacementRaycastEnd) == 0x0000C4, "Member 'UDefaultObjectPlacementValidationStrategy::_objectPlacementRaycastEnd' has a wrong offset!");
static_assert(offsetof(UDefaultObjectPlacementValidationStrategy, _objectHeightRangeAroundBaseLocation) == 0x0000D0, "Member 'UDefaultObjectPlacementValidationStrategy::_objectHeightRangeAroundBaseLocation' has a wrong offset!");

// Class DeadByDaylight.NavMeshObjectPlacementValidationStrategy
// 0x0008 (0x00E8 - 0x00E0)
class UNavMeshObjectPlacementValidationStrategy final : public UDefaultObjectPlacementValidationStrategy
{
public:
	float                                         _navPathMaxLength;                                 // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavMeshObjectPlacementValidationStrategy">();
	}
	static class UNavMeshObjectPlacementValidationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavMeshObjectPlacementValidationStrategy>();
	}
};
static_assert(alignof(UNavMeshObjectPlacementValidationStrategy) == 0x000008, "Wrong alignment on UNavMeshObjectPlacementValidationStrategy");
static_assert(sizeof(UNavMeshObjectPlacementValidationStrategy) == 0x0000E8, "Wrong size on UNavMeshObjectPlacementValidationStrategy");
static_assert(offsetof(UNavMeshObjectPlacementValidationStrategy, _navPathMaxLength) == 0x0000E0, "Member 'UNavMeshObjectPlacementValidationStrategy::_navPathMaxLength' has a wrong offset!");

// Class DeadByDaylight.DirectionalMinigameComponent
// 0x0050 (0x0108 - 0x00B8)
class UDirectionalMinigameComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          _currentlyEngagedSurvivor;                         // 0x00E0(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EDirectionalInputKey>                  _currentSequence;                                  // 0x00E8(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          _isInProgress;                                     // 0x00F8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _currentKeyIndex;                                  // 0x00FC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_StartMinigameForSurvivor(class ACamperPlayer* survivor);
	void OnRep_IsInProgress();
	void Server_CancelMinigame();
	void Server_EnterKey(EDirectionalInputKey enteredKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DirectionalMinigameComponent">();
	}
	static class UDirectionalMinigameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDirectionalMinigameComponent>();
	}
};
static_assert(alignof(UDirectionalMinigameComponent) == 0x000008, "Wrong alignment on UDirectionalMinigameComponent");
static_assert(sizeof(UDirectionalMinigameComponent) == 0x000108, "Wrong size on UDirectionalMinigameComponent");
static_assert(offsetof(UDirectionalMinigameComponent, _currentlyEngagedSurvivor) == 0x0000E0, "Member 'UDirectionalMinigameComponent::_currentlyEngagedSurvivor' has a wrong offset!");
static_assert(offsetof(UDirectionalMinigameComponent, _currentSequence) == 0x0000E8, "Member 'UDirectionalMinigameComponent::_currentSequence' has a wrong offset!");
static_assert(offsetof(UDirectionalMinigameComponent, _isInProgress) == 0x0000F8, "Member 'UDirectionalMinigameComponent::_isInProgress' has a wrong offset!");
static_assert(offsetof(UDirectionalMinigameComponent, _currentKeyIndex) == 0x0000FC, "Member 'UDirectionalMinigameComponent::_currentKeyIndex' has a wrong offset!");

// Class DeadByDaylight.GenericPopupScreen
// 0x0020 (0x0140 - 0x0120)
class UGenericPopupScreen : public UBasePopupScreen
{
public:
	class UUMGGenericPopup*                       _popup;                                            // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x18];                                     // 0x0128(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChoiceSelected(int32 selectedButtonType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericPopupScreen">();
	}
	static class UGenericPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericPopupScreen>();
	}
};
static_assert(alignof(UGenericPopupScreen) == 0x000008, "Wrong alignment on UGenericPopupScreen");
static_assert(sizeof(UGenericPopupScreen) == 0x000140, "Wrong size on UGenericPopupScreen");
static_assert(offsetof(UGenericPopupScreen, _popup) == 0x000120, "Member 'UGenericPopupScreen::_popup' has a wrong offset!");

// Class DeadByDaylight.SpawnerStrategy
// 0x0000 (0x0030 - 0x0030)
class USpawnerStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnerStrategy">();
	}
	static class USpawnerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnerStrategy>();
	}
};
static_assert(alignof(USpawnerStrategy) == 0x000008, "Wrong alignment on USpawnerStrategy");
static_assert(sizeof(USpawnerStrategy) == 0x000030, "Wrong size on USpawnerStrategy");

// Class DeadByDaylight.NoAccumulationSpawnerStrategy
// 0x0000 (0x0030 - 0x0030)
class UNoAccumulationSpawnerStrategy final : public USpawnerStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NoAccumulationSpawnerStrategy">();
	}
	static class UNoAccumulationSpawnerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNoAccumulationSpawnerStrategy>();
	}
};
static_assert(alignof(UNoAccumulationSpawnerStrategy) == 0x000008, "Wrong alignment on UNoAccumulationSpawnerStrategy");
static_assert(sizeof(UNoAccumulationSpawnerStrategy) == 0x000030, "Wrong size on UNoAccumulationSpawnerStrategy");

// Class DeadByDaylight.StorefrontConfiguration
// 0x0050 (0x0088 - 0x0038)
class UStorefrontConfiguration final : public UDataAsset
{
public:
	TMap<EStorefrontState, struct FStorefrontStateData> States;                                      // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StorefrontConfiguration">();
	}
	static class UStorefrontConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStorefrontConfiguration>();
	}
};
static_assert(alignof(UStorefrontConfiguration) == 0x000008, "Wrong alignment on UStorefrontConfiguration");
static_assert(sizeof(UStorefrontConfiguration) == 0x000088, "Wrong size on UStorefrontConfiguration");
static_assert(offsetof(UStorefrontConfiguration, States) == 0x000038, "Member 'UStorefrontConfiguration::States' has a wrong offset!");

// Class DeadByDaylight.ArchivePassPurchasePopupScreen
// 0x0000 (0x0140 - 0x0140)
class UArchivePassPurchasePopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivePassPurchasePopupScreen">();
	}
	static class UArchivePassPurchasePopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchivePassPurchasePopupScreen>();
	}
};
static_assert(alignof(UArchivePassPurchasePopupScreen) == 0x000008, "Wrong alignment on UArchivePassPurchasePopupScreen");
static_assert(sizeof(UArchivePassPurchasePopupScreen) == 0x000140, "Wrong size on UArchivePassPurchasePopupScreen");

// Class DeadByDaylight.ArchivesHelper
// 0x0000 (0x0030 - 0x0030)
class UArchivesHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivesHelper">();
	}
	static class UArchivesHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchivesHelper>();
	}
};
static_assert(alignof(UArchivesHelper) == 0x000008, "Wrong alignment on UArchivesHelper");
static_assert(sizeof(UArchivesHelper) == 0x000030, "Wrong size on UArchivesHelper");

// Class DeadByDaylight.ArchivesManager
// 0x0038 (0x0070 - 0x0038)
class UArchivesManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UArchiveStoriesContainer*               _storiesContainer;                                 // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArchiveVignettesContainer*             _vignettesContainer;                               // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URewardTrackContainer*                  _rewardTrackContainer;                             // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivesManager">();
	}
	static class UArchivesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchivesManager>();
	}
};
static_assert(alignof(UArchivesManager) == 0x000008, "Wrong alignment on UArchivesManager");
static_assert(sizeof(UArchivesManager) == 0x000070, "Wrong size on UArchivesManager");
static_assert(offsetof(UArchivesManager, _storiesContainer) == 0x000058, "Member 'UArchivesManager::_storiesContainer' has a wrong offset!");
static_assert(offsetof(UArchivesManager, _vignettesContainer) == 0x000060, "Member 'UArchivesManager::_vignettesContainer' has a wrong offset!");
static_assert(offsetof(UArchivesManager, _rewardTrackContainer) == 0x000068, "Member 'UArchivesManager::_rewardTrackContainer' has a wrong offset!");

// Class DeadByDaylight.UMGCharacterPrice
// 0x0010 (0x0348 - 0x0338)
class UUMGCharacterPrice final : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             PriceTextBlock;                                    // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 AffordableColor;                                   // 0x0340(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 UnaffordableColor;                                 // 0x0344(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetCurrencyData(const struct FPurchaseCurrencyData& currencyData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCharacterPrice">();
	}
	static class UUMGCharacterPrice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCharacterPrice>();
	}
};
static_assert(alignof(UUMGCharacterPrice) == 0x000008, "Wrong alignment on UUMGCharacterPrice");
static_assert(sizeof(UUMGCharacterPrice) == 0x000348, "Wrong size on UUMGCharacterPrice");
static_assert(offsetof(UUMGCharacterPrice, PriceTextBlock) == 0x000338, "Member 'UUMGCharacterPrice::PriceTextBlock' has a wrong offset!");
static_assert(offsetof(UUMGCharacterPrice, AffordableColor) == 0x000340, "Member 'UUMGCharacterPrice::AffordableColor' has a wrong offset!");
static_assert(offsetof(UUMGCharacterPrice, UnaffordableColor) == 0x000344, "Member 'UUMGCharacterPrice::UnaffordableColor' has a wrong offset!");

// Class DeadByDaylight.DisplayStandController
// 0x00F0 (0x0120 - 0x0030)
class UDisplayStandController : public UObject
{
public:
	uint8                                         Pad_30[0xF0];                                      // 0x0030(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandController">();
	}
	static class UDisplayStandController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayStandController>();
	}
};
static_assert(alignof(UDisplayStandController) == 0x000008, "Wrong alignment on UDisplayStandController");
static_assert(sizeof(UDisplayStandController) == 0x000120, "Wrong size on UDisplayStandController");

// Class DeadByDaylight.ArchivesSpecialBehavioursHelper
// 0x0000 (0x0030 - 0x0030)
class UArchivesSpecialBehavioursHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchivesSpecialBehavioursHelper">();
	}
	static class UArchivesSpecialBehavioursHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchivesSpecialBehavioursHelper>();
	}
};
static_assert(alignof(UArchivesSpecialBehavioursHelper) == 0x000008, "Wrong alignment on UArchivesSpecialBehavioursHelper");
static_assert(sizeof(UArchivesSpecialBehavioursHelper) == 0x000030, "Wrong size on UArchivesSpecialBehavioursHelper");

// Class DeadByDaylight.ArchiveStoriesContainer
// 0x0408 (0x0438 - 0x0030)
class UArchiveStoriesContainer final : public UObject
{
public:
	uint8                                         Pad_30[0x2B8];                                     // 0x0030(0x02B8)(Fixing Size After Last Property [ Dumper-7 ])
	class URewardTrackContainer*                  _rewardTrackcontainer;                             // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0xC8];                                     // 0x02F0(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UWalletHandler*                         _wallet;                                           // 0x03B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArchiveVignettesContainer*             _vignettesContainer;                               // 0x03C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x70];                                     // 0x03C8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveStoriesContainer">();
	}
	static class UArchiveStoriesContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchiveStoriesContainer>();
	}
};
static_assert(alignof(UArchiveStoriesContainer) == 0x000008, "Wrong alignment on UArchiveStoriesContainer");
static_assert(sizeof(UArchiveStoriesContainer) == 0x000438, "Wrong size on UArchiveStoriesContainer");
static_assert(offsetof(UArchiveStoriesContainer, _rewardTrackcontainer) == 0x0002E8, "Member 'UArchiveStoriesContainer::_rewardTrackcontainer' has a wrong offset!");
static_assert(offsetof(UArchiveStoriesContainer, _wallet) == 0x0003B8, "Member 'UArchiveStoriesContainer::_wallet' has a wrong offset!");
static_assert(offsetof(UArchiveStoriesContainer, _vignettesContainer) == 0x0003C0, "Member 'UArchiveStoriesContainer::_vignettesContainer' has a wrong offset!");

// Class DeadByDaylight.PlayerProfileDAL
// 0x0058 (0x0088 - 0x0030)
class UPlayerProfileDAL : public UObject
{
public:
	uint8                                         Pad_30[0x58];                                      // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerProfileDAL">();
	}
	static class UPlayerProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerProfileDAL>();
	}
};
static_assert(alignof(UPlayerProfileDAL) == 0x000008, "Wrong alignment on UPlayerProfileDAL");
static_assert(sizeof(UPlayerProfileDAL) == 0x000088, "Wrong size on UPlayerProfileDAL");

// Class DeadByDaylight.SwitchProfileDAL
// 0x0000 (0x0088 - 0x0088)
class USwitchProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SwitchProfileDAL">();
	}
	static class USwitchProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<USwitchProfileDAL>();
	}
};
static_assert(alignof(USwitchProfileDAL) == 0x000008, "Wrong alignment on USwitchProfileDAL");
static_assert(sizeof(USwitchProfileDAL) == 0x000088, "Wrong size on USwitchProfileDAL");

// Class DeadByDaylight.DialogHandlerComponent
// 0x00B0 (0x0168 - 0x00B8)
class UDialogHandlerComponent final : public UActorComponent
{
public:
	float                                         _minimumDelayBetweenDialog;                        // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxSubtitleDistance;                              // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDialogEventSettings>           _dialogEvents;                                     // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayTag>                   _stopAudioGameplayEvents;                          // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          _stopAudioClip;                                    // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x80];                                      // 0x00E8(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogHandlerComponent">();
	}
	static class UDialogHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogHandlerComponent>();
	}
};
static_assert(alignof(UDialogHandlerComponent) == 0x000008, "Wrong alignment on UDialogHandlerComponent");
static_assert(sizeof(UDialogHandlerComponent) == 0x000168, "Wrong size on UDialogHandlerComponent");
static_assert(offsetof(UDialogHandlerComponent, _minimumDelayBetweenDialog) == 0x0000B8, "Member 'UDialogHandlerComponent::_minimumDelayBetweenDialog' has a wrong offset!");
static_assert(offsetof(UDialogHandlerComponent, _maxSubtitleDistance) == 0x0000BC, "Member 'UDialogHandlerComponent::_maxSubtitleDistance' has a wrong offset!");
static_assert(offsetof(UDialogHandlerComponent, _dialogEvents) == 0x0000C0, "Member 'UDialogHandlerComponent::_dialogEvents' has a wrong offset!");
static_assert(offsetof(UDialogHandlerComponent, _stopAudioGameplayEvents) == 0x0000D0, "Member 'UDialogHandlerComponent::_stopAudioGameplayEvents' has a wrong offset!");
static_assert(offsetof(UDialogHandlerComponent, _stopAudioClip) == 0x0000E0, "Member 'UDialogHandlerComponent::_stopAudioClip' has a wrong offset!");

// Class DeadByDaylight.ArchiveTierPurchasePopupScreen
// 0x0018 (0x0158 - 0x0140)
class UArchiveTierPurchasePopupScreen final : public UGenericPopupScreen
{
public:
	uint8                                         Pad_140[0x18];                                     // 0x0140(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConfirmPurchase(int32 tiersToPurchaseNumber);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveTierPurchasePopupScreen">();
	}
	static class UArchiveTierPurchasePopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchiveTierPurchasePopupScreen>();
	}
};
static_assert(alignof(UArchiveTierPurchasePopupScreen) == 0x000008, "Wrong alignment on UArchiveTierPurchasePopupScreen");
static_assert(sizeof(UArchiveTierPurchasePopupScreen) == 0x000158, "Wrong size on UArchiveTierPurchasePopupScreen");

// Class DeadByDaylight.ArchiveVignettesContainer
// 0x00D8 (0x0108 - 0x0030)
class UArchiveVignettesContainer final : public UObject
{
public:
	uint8                                         Pad_30[0xD8];                                      // 0x0030(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveVignettesContainer">();
	}
	static class UArchiveVignettesContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchiveVignettesContainer>();
	}
};
static_assert(alignof(UArchiveVignettesContainer) == 0x000008, "Wrong alignment on UArchiveVignettesContainer");
static_assert(sizeof(UArchiveVignettesContainer) == 0x000108, "Wrong size on UArchiveVignettesContainer");

// Class DeadByDaylight.OfferingSequenceManager
// 0x00C0 (0x02F0 - 0x0230)
class AOfferingSequenceManager : public AActor
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerController*                      _localPlayerController;                            // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOfferingHandler*                       _offeringHandler;                                  // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOfferingSequenceAssets*                _sequenceAssets;                                   // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDLobbyHud*                           _hud;                                              // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACameraActor*                           _offeringCamera;                                   // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<uint8, class AOfferingCard*>             _spawnedCards;                                     // 0x0260(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x10];                                     // 0x02B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AOfferingCard>              _defaultCardsClass;                                // 0x02C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AOfferingCard>              _eventCardsClass;                                  // 0x02C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x20];                                     // 0x02D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeInScreen();
	void HandleSequenceEnded();
	void HandleSequenceStarted();
	void HandleSequenceStateChanged(EOfferingSequenceState state);

	bool ContainsDefaultCard() const;
	bool ContainsEventCard() const;
	EOfferingSequenceState GetCurrentState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingSequenceManager">();
	}
	static class AOfferingSequenceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOfferingSequenceManager>();
	}
};
static_assert(alignof(AOfferingSequenceManager) == 0x000008, "Wrong alignment on AOfferingSequenceManager");
static_assert(sizeof(AOfferingSequenceManager) == 0x0002F0, "Wrong size on AOfferingSequenceManager");
static_assert(offsetof(AOfferingSequenceManager, _gameInstance) == 0x000230, "Member 'AOfferingSequenceManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _localPlayerController) == 0x000238, "Member 'AOfferingSequenceManager::_localPlayerController' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _offeringHandler) == 0x000240, "Member 'AOfferingSequenceManager::_offeringHandler' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _sequenceAssets) == 0x000248, "Member 'AOfferingSequenceManager::_sequenceAssets' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _hud) == 0x000250, "Member 'AOfferingSequenceManager::_hud' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _offeringCamera) == 0x000258, "Member 'AOfferingSequenceManager::_offeringCamera' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _spawnedCards) == 0x000260, "Member 'AOfferingSequenceManager::_spawnedCards' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _defaultCardsClass) == 0x0002C0, "Member 'AOfferingSequenceManager::_defaultCardsClass' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceManager, _eventCardsClass) == 0x0002C8, "Member 'AOfferingSequenceManager::_eventCardsClass' has a wrong offset!");

// Class DeadByDaylight.DlcHelper
// 0x0000 (0x0030 - 0x0030)
class UDlcHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DlcHelper">();
	}
	static class UDlcHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDlcHelper>();
	}
};
static_assert(alignof(UDlcHelper) == 0x000008, "Wrong alignment on UDlcHelper");
static_assert(sizeof(UDlcHelper) == 0x000030, "Wrong size on UDlcHelper");

// Class DeadByDaylight.ArchiveWidgetScreen
// 0x0030 (0x0150 - 0x0120)
class UArchiveWidgetScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0x30];                                     // 0x0120(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnQuestsButtonClick();
	void OnRewardsButtonClick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveWidgetScreen">();
	}
	static class UArchiveWidgetScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchiveWidgetScreen>();
	}
};
static_assert(alignof(UArchiveWidgetScreen) == 0x000008, "Wrong alignment on UArchiveWidgetScreen");
static_assert(sizeof(UArchiveWidgetScreen) == 0x000150, "Wrong size on UArchiveWidgetScreen");

// Class DeadByDaylight.ObjectPlacementValidationWithRestrictionStrategy
// 0x0010 (0x00F0 - 0x00E0)
class UObjectPlacementValidationWithRestrictionStrategy : public UDefaultObjectPlacementValidationStrategy
{
public:
	TArray<class URestrictedPlacementAreaStrategy*> _restrictedAreas;                                // 0x00E0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, NoClear, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPlacementValidationWithRestrictionStrategy">();
	}
	static class UObjectPlacementValidationWithRestrictionStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectPlacementValidationWithRestrictionStrategy>();
	}
};
static_assert(alignof(UObjectPlacementValidationWithRestrictionStrategy) == 0x000008, "Wrong alignment on UObjectPlacementValidationWithRestrictionStrategy");
static_assert(sizeof(UObjectPlacementValidationWithRestrictionStrategy) == 0x0000F0, "Wrong size on UObjectPlacementValidationWithRestrictionStrategy");
static_assert(offsetof(UObjectPlacementValidationWithRestrictionStrategy, _restrictedAreas) == 0x0000E0, "Member 'UObjectPlacementValidationWithRestrictionStrategy::_restrictedAreas' has a wrong offset!");

// Class DeadByDaylight.SubscriptionRewardDataAsset
// 0x0050 (0x0088 - 0x0038)
class USubscriptionRewardDataAsset final : public UPrimaryDataAsset
{
public:
	TMap<ESubscriptionRewardType, struct FSubscriptionRewardTypeData> Data;                          // 0x0038(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubscriptionRewardDataAsset">();
	}
	static class USubscriptionRewardDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubscriptionRewardDataAsset>();
	}
};
static_assert(alignof(USubscriptionRewardDataAsset) == 0x000008, "Wrong alignment on USubscriptionRewardDataAsset");
static_assert(sizeof(USubscriptionRewardDataAsset) == 0x000088, "Wrong size on USubscriptionRewardDataAsset");
static_assert(offsetof(USubscriptionRewardDataAsset, Data) == 0x000038, "Member 'USubscriptionRewardDataAsset::Data' has a wrong offset!");

// Class DeadByDaylight.AspectRatioComponentUtilities
// 0x0000 (0x0030 - 0x0030)
class UAspectRatioComponentUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AspectRatioComponentUtilities">();
	}
	static class UAspectRatioComponentUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAspectRatioComponentUtilities>();
	}
};
static_assert(alignof(UAspectRatioComponentUtilities) == 0x000008, "Wrong alignment on UAspectRatioComponentUtilities");
static_assert(sizeof(UAspectRatioComponentUtilities) == 0x000030, "Wrong size on UAspectRatioComponentUtilities");

// Class DeadByDaylight.AssetLibraryManager
// 0x00D0 (0x0100 - 0x0030)
class UAssetLibraryManager final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                _worldContextObject;                               // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class UCharacterItemsAssetLibrary*> _characterItemsAssetLibrary;                     // 0x0048(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UIniAssetLibrary*                       _globalAssetLibrary;                               // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMenuAssetLibrary*                      _menuAssetLibrary;                                 // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameAssetLibrary*                      _gameAssetLibrary;                                 // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTutorialAssetLibrary*                  _tutorialAssetLibrary;                             // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UShopManager*                           _shopManager;                                      // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAssetLibraryLoader>            _loadingList;                                      // 0x00D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         CharacterItemsAssetLoadCountPerChunk;              // 0x00E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BlindPackAssetLoadCountPerChunk;                   // 0x00EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MenuAssetLoadCountPerChunk;                        // 0x00F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GlobalAssetLoadCountPerChunk;                      // 0x00F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         GameAssetLoadCountPerChunk;                        // 0x00F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetLibraryManager">();
	}
	static class UAssetLibraryManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetLibraryManager>();
	}
};
static_assert(alignof(UAssetLibraryManager) == 0x000008, "Wrong alignment on UAssetLibraryManager");
static_assert(sizeof(UAssetLibraryManager) == 0x000100, "Wrong size on UAssetLibraryManager");
static_assert(offsetof(UAssetLibraryManager, _worldContextObject) == 0x000040, "Member 'UAssetLibraryManager::_worldContextObject' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _characterItemsAssetLibrary) == 0x000048, "Member 'UAssetLibraryManager::_characterItemsAssetLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _globalAssetLibrary) == 0x000098, "Member 'UAssetLibraryManager::_globalAssetLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _menuAssetLibrary) == 0x0000A0, "Member 'UAssetLibraryManager::_menuAssetLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _gameAssetLibrary) == 0x0000A8, "Member 'UAssetLibraryManager::_gameAssetLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _tutorialAssetLibrary) == 0x0000B0, "Member 'UAssetLibraryManager::_tutorialAssetLibrary' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _shopManager) == 0x0000C0, "Member 'UAssetLibraryManager::_shopManager' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, _loadingList) == 0x0000D8, "Member 'UAssetLibraryManager::_loadingList' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, CharacterItemsAssetLoadCountPerChunk) == 0x0000E8, "Member 'UAssetLibraryManager::CharacterItemsAssetLoadCountPerChunk' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, BlindPackAssetLoadCountPerChunk) == 0x0000EC, "Member 'UAssetLibraryManager::BlindPackAssetLoadCountPerChunk' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, MenuAssetLoadCountPerChunk) == 0x0000F0, "Member 'UAssetLibraryManager::MenuAssetLoadCountPerChunk' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, GlobalAssetLoadCountPerChunk) == 0x0000F4, "Member 'UAssetLibraryManager::GlobalAssetLoadCountPerChunk' has a wrong offset!");
static_assert(offsetof(UAssetLibraryManager, GameAssetLoadCountPerChunk) == 0x0000F8, "Member 'UAssetLibraryManager::GameAssetLoadCountPerChunk' has a wrong offset!");

// Class DeadByDaylight.AtlantaCustomGameUtilities
// 0x0000 (0x0030 - 0x0030)
class UAtlantaCustomGameUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool IsCustomGameEnabled();
	static bool IsInCustomGameLobby(const class UDBDGameInstance* gameInstance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaCustomGameUtilities">();
	}
	static class UAtlantaCustomGameUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaCustomGameUtilities>();
	}
};
static_assert(alignof(UAtlantaCustomGameUtilities) == 0x000008, "Wrong alignment on UAtlantaCustomGameUtilities");
static_assert(sizeof(UAtlantaCustomGameUtilities) == 0x000030, "Wrong size on UAtlantaCustomGameUtilities");

// Class DeadByDaylight.TileEventComponent
// 0x0010 (0x00C8 - 0x00B8)
class UTileEventComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileEventComponent">();
	}
	static class UTileEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileEventComponent>();
	}
};
static_assert(alignof(UTileEventComponent) == 0x000008, "Wrong alignment on UTileEventComponent");
static_assert(sizeof(UTileEventComponent) == 0x0000C8, "Wrong size on UTileEventComponent");

// Class DeadByDaylight.DisplayStandItemRequesterComponent
// 0x0058 (0x0110 - 0x00B8)
class UDisplayStandItemRequesterComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x58];                                      // 0x00B8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LoadItemsOnCharacter(class AActor* actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandItemRequesterComponent">();
	}
	static class UDisplayStandItemRequesterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayStandItemRequesterComponent>();
	}
};
static_assert(alignof(UDisplayStandItemRequesterComponent) == 0x000008, "Wrong alignment on UDisplayStandItemRequesterComponent");
static_assert(sizeof(UDisplayStandItemRequesterComponent) == 0x000110, "Wrong size on UDisplayStandItemRequesterComponent");

// Class DeadByDaylight.AtlantaCustomizationTooltipWidget
// 0x0018 (0x0388 - 0x0370)
class UAtlantaCustomizationTooltipWidget final : public UBaseTooltipWidget
{
public:
	class UImage*                                 SmokeImage;                                        // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGCustomizationTooltipHeaderWidget*   Header;                                            // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGCustomizationTooltipContentWidget*  Content;                                           // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaCustomizationTooltipWidget">();
	}
	static class UAtlantaCustomizationTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaCustomizationTooltipWidget>();
	}
};
static_assert(alignof(UAtlantaCustomizationTooltipWidget) == 0x000008, "Wrong alignment on UAtlantaCustomizationTooltipWidget");
static_assert(sizeof(UAtlantaCustomizationTooltipWidget) == 0x000388, "Wrong size on UAtlantaCustomizationTooltipWidget");
static_assert(offsetof(UAtlantaCustomizationTooltipWidget, SmokeImage) == 0x000370, "Member 'UAtlantaCustomizationTooltipWidget::SmokeImage' has a wrong offset!");
static_assert(offsetof(UAtlantaCustomizationTooltipWidget, Header) == 0x000378, "Member 'UAtlantaCustomizationTooltipWidget::Header' has a wrong offset!");
static_assert(offsetof(UAtlantaCustomizationTooltipWidget, Content) == 0x000380, "Member 'UAtlantaCustomizationTooltipWidget::Content' has a wrong offset!");

// Class DeadByDaylight.OnlineSystemHandler
// 0x04C0 (0x04F0 - 0x0030)
class UOnlineSystemHandler final : public UObject
{
public:
	uint8                                         Pad_30[0x1B8];                                     // 0x0030(0x01B8)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalPlayer*                           _cachedLocalPlayer;                                // 0x01E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDGameInstance*                       _gameInstance;                                     // 0x01F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameSessionDS*                         _gameSessionDS;                                    // 0x01F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0x270];                                    // 0x0200(0x0270)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDServerInstance*                     _serverInstance;                                   // 0x0470(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x30];                                     // 0x0478(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UCrossPlatformManager*                  _crossPlatformManager;                             // 0x04A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x40];                                     // 0x04B0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineSystemHandler">();
	}
	static class UOnlineSystemHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineSystemHandler>();
	}
};
static_assert(alignof(UOnlineSystemHandler) == 0x000008, "Wrong alignment on UOnlineSystemHandler");
static_assert(sizeof(UOnlineSystemHandler) == 0x0004F0, "Wrong size on UOnlineSystemHandler");
static_assert(offsetof(UOnlineSystemHandler, _cachedLocalPlayer) == 0x0001E8, "Member 'UOnlineSystemHandler::_cachedLocalPlayer' has a wrong offset!");
static_assert(offsetof(UOnlineSystemHandler, _gameInstance) == 0x0001F0, "Member 'UOnlineSystemHandler::_gameInstance' has a wrong offset!");
static_assert(offsetof(UOnlineSystemHandler, _gameSessionDS) == 0x0001F8, "Member 'UOnlineSystemHandler::_gameSessionDS' has a wrong offset!");
static_assert(offsetof(UOnlineSystemHandler, _serverInstance) == 0x000470, "Member 'UOnlineSystemHandler::_serverInstance' has a wrong offset!");
static_assert(offsetof(UOnlineSystemHandler, _crossPlatformManager) == 0x0004A8, "Member 'UOnlineSystemHandler::_crossPlatformManager' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerPositionOffsetComponent
// 0x0008 (0x00C0 - 0x00B8)
class UDBDPlayerPositionOffsetComponent final : public UActorComponent
{
public:
	struct FPerPlatformFloat                      _menuZHeadOffset;                                  // 0x00B8(0x0004)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerPositionOffsetComponent">();
	}
	static class UDBDPlayerPositionOffsetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPlayerPositionOffsetComponent>();
	}
};
static_assert(alignof(UDBDPlayerPositionOffsetComponent) == 0x000008, "Wrong alignment on UDBDPlayerPositionOffsetComponent");
static_assert(sizeof(UDBDPlayerPositionOffsetComponent) == 0x0000C0, "Wrong size on UDBDPlayerPositionOffsetComponent");
static_assert(offsetof(UDBDPlayerPositionOffsetComponent, _menuZHeadOffset) == 0x0000B8, "Member 'UDBDPlayerPositionOffsetComponent::_menuZHeadOffset' has a wrong offset!");

// Class DeadByDaylight.AtlantaDeepLinkSubsystem
// 0x0028 (0x0060 - 0x0038)
class UAtlantaDeepLinkSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaDeepLinkSubsystem">();
	}
	static class UAtlantaDeepLinkSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaDeepLinkSubsystem>();
	}
};
static_assert(alignof(UAtlantaDeepLinkSubsystem) == 0x000008, "Wrong alignment on UAtlantaDeepLinkSubsystem");
static_assert(sizeof(UAtlantaDeepLinkSubsystem) == 0x000060, "Wrong size on UAtlantaDeepLinkSubsystem");

// Class DeadByDaylight.OfferingUtilities
// 0x0000 (0x0030 - 0x0030)
class UOfferingUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool HasItemLossProtection(const class ADBDPlayer* player);
	static bool HasOfferingOfType(const class UObject* worldContextObject, EOfferingEffectType offeringEffectType, int32 playerId);
	static bool IsPlayerEquippedWithOfferingWithTag(const class ADBDPlayer* player, const class FName offeringTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingUtilities">();
	}
	static class UOfferingUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOfferingUtilities>();
	}
};
static_assert(alignof(UOfferingUtilities) == 0x000008, "Wrong alignment on UOfferingUtilities");
static_assert(sizeof(UOfferingUtilities) == 0x000030, "Wrong size on UOfferingUtilities");

// Class DeadByDaylight.TutorialLevel
// 0x0040 (0x0278 - 0x0238)
class ATutorialLevel : public ALevelScriptActor
{
public:
	bool                                          _tutorialStarted;                                  // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_239[0x3F];                                     // 0x0239(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddObjective(class FName objectiveId);
	void CompleteObjective(class FName objectiveId);
	void DisplayBlockingNotification(class FName notificationId);
	void DisplayNotification(class FName notificationId, float time);
	void HandleNotificationDismissed(class FName notificationId);
	void HandleTutorialStepReached();
	void OnNotificationDismissed(class FName notificationId);
	void OnTutorialStepUpdated(ETutorialStep tutorialStep);
	void RemoveObjective(class FName objectiveId);
	void SetHandledTutorialStep(ETutorialStep tutorialStep);
	void StartTutorial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialLevel">();
	}
	static class ATutorialLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialLevel>();
	}
};
static_assert(alignof(ATutorialLevel) == 0x000008, "Wrong alignment on ATutorialLevel");
static_assert(sizeof(ATutorialLevel) == 0x000278, "Wrong size on ATutorialLevel");
static_assert(offsetof(ATutorialLevel, _tutorialStarted) == 0x000238, "Member 'ATutorialLevel::_tutorialStarted' has a wrong offset!");

// Class DeadByDaylight.AtlantaTutorialLevel
// 0x00B0 (0x0328 - 0x0278)
class AAtlantaTutorialLevel : public ATutorialLevel
{
public:
	uint8                                         Pad_278[0xB0];                                     // 0x0278(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCanStartTutorialChanged(bool canStartTutorial);
	bool IsActorInLineOfSight(class ADBDAIPlayerController* aiPlayerController, class APlayerController* playerController);
	void OnTriggerBeginOverlapActor(const class FString& triggerID, class AActor* overlappingActor);
	void OnTutorialStarted();
	void SetAIEscapePoints(const TArray<class AActor*>& escapePoints);
	void SetLocallyControlledPlayer(class ADBDPlayer* locallyControllerPlayer);
	void SetTutorialElement(const class FString& elementKey, class AActor* elementToSet);
	void SetTutorialElements();
	void StartCameraFadeIn();

	class AActor* GetTutorialElement(const class FString& elementKey) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaTutorialLevel">();
	}
	static class AAtlantaTutorialLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlantaTutorialLevel>();
	}
};
static_assert(alignof(AAtlantaTutorialLevel) == 0x000008, "Wrong alignment on AAtlantaTutorialLevel");
static_assert(sizeof(AAtlantaTutorialLevel) == 0x000328, "Wrong size on AAtlantaTutorialLevel");

// Class DeadByDaylight.SurvivorAtlantaTutorialLevel
// 0x0010 (0x0338 - 0x0328)
class ASurvivorAtlantaTutorialLevel final : public AAtlantaTutorialLevel
{
public:
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSlasherPlayer(class ASlasherPlayer* slasherPlayer);

	class ACamperPlayer* GetCamperPlayer() const;
	class ADBDAIPlayerController* GetSlasherAIPlayerController() const;
	class ASlasherPlayer* GetSlasherPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAtlantaTutorialLevel">();
	}
	static class ASurvivorAtlantaTutorialLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASurvivorAtlantaTutorialLevel>();
	}
};
static_assert(alignof(ASurvivorAtlantaTutorialLevel) == 0x000008, "Wrong alignment on ASurvivorAtlantaTutorialLevel");
static_assert(sizeof(ASurvivorAtlantaTutorialLevel) == 0x000338, "Wrong size on ASurvivorAtlantaTutorialLevel");

// Class DeadByDaylight.DisplayStand
// 0x0180 (0x03B0 - 0x0230)
#pragma pack(push, 0x1)
class alignas(0x10) ADisplayStand : public AActor
{
public:
	uint8                                         Pad_230[0x18];                                     // 0x0230(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _currentActorDisplayed;                            // 0x0248(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 _currentActorDisplayedClass;                       // 0x0258(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _nextActorToDisplayClass;                          // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x28];                                     // 0x0268(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UClass*, struct FTransform>        _offsetByClass;                                    // 0x0290(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TMap<class UClass*, bool>                     _enableRotationByClass;                            // 0x02E0(0x0050)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _defaultCharmClassDisplayable;                     // 0x0330(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x39];                                     // 0x0360(0x0039)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _useOffsetMenuAnimations;                          // 0x0399(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _displayDummyCharacter;                            // 0x039A(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39B[0x1];                                      // 0x039B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterDropdown                     _characterDropdown;                                // 0x039C(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlockRotation(bool shouldBlockRotation);
	void OnCurrentActorDestroyed(class AActor* destroyedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStand">();
	}
	static class ADisplayStand* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADisplayStand>();
	}
};
#pragma pack(pop)
static_assert(alignof(ADisplayStand) == 0x000010, "Wrong alignment on ADisplayStand");
static_assert(sizeof(ADisplayStand) == 0x0003B0, "Wrong size on ADisplayStand");
static_assert(offsetof(ADisplayStand, _currentActorDisplayed) == 0x000248, "Member 'ADisplayStand::_currentActorDisplayed' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _currentActorDisplayedClass) == 0x000258, "Member 'ADisplayStand::_currentActorDisplayedClass' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _nextActorToDisplayClass) == 0x000260, "Member 'ADisplayStand::_nextActorToDisplayClass' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _offsetByClass) == 0x000290, "Member 'ADisplayStand::_offsetByClass' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _enableRotationByClass) == 0x0002E0, "Member 'ADisplayStand::_enableRotationByClass' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _defaultCharmClassDisplayable) == 0x000330, "Member 'ADisplayStand::_defaultCharmClassDisplayable' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _useOffsetMenuAnimations) == 0x000399, "Member 'ADisplayStand::_useOffsetMenuAnimations' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _displayDummyCharacter) == 0x00039A, "Member 'ADisplayStand::_displayDummyCharacter' has a wrong offset!");
static_assert(offsetof(ADisplayStand, _characterDropdown) == 0x00039C, "Member 'ADisplayStand::_characterDropdown' has a wrong offset!");

// Class DeadByDaylight.UMGPromoPackItemWidget
// 0x0038 (0x04A0 - 0x0468)
class UUMGPromoPackItemWidget : public UUMGBaseButtonWidget
{
public:
	class UCanvasPanel*                           SelectedPanel;                                     // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           BackgroundPanel;                                   // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           AmountPanel;                                       // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_480[0x20];                                     // 0x0480(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPromoPackItemWidget">();
	}
	static class UUMGPromoPackItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPromoPackItemWidget>();
	}
};
static_assert(alignof(UUMGPromoPackItemWidget) == 0x000008, "Wrong alignment on UUMGPromoPackItemWidget");
static_assert(sizeof(UUMGPromoPackItemWidget) == 0x0004A0, "Wrong size on UUMGPromoPackItemWidget");
static_assert(offsetof(UUMGPromoPackItemWidget, SelectedPanel) == 0x000468, "Member 'UUMGPromoPackItemWidget::SelectedPanel' has a wrong offset!");
static_assert(offsetof(UUMGPromoPackItemWidget, BackgroundPanel) == 0x000470, "Member 'UUMGPromoPackItemWidget::BackgroundPanel' has a wrong offset!");
static_assert(offsetof(UUMGPromoPackItemWidget, AmountPanel) == 0x000478, "Member 'UUMGPromoPackItemWidget::AmountPanel' has a wrong offset!");

// Class DeadByDaylight.UMGPromoPackCurrencyWidget
// 0x0000 (0x04A0 - 0x04A0)
class UUMGPromoPackCurrencyWidget final : public UUMGPromoPackItemWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPromoPackCurrencyWidget">();
	}
	static class UUMGPromoPackCurrencyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPromoPackCurrencyWidget>();
	}
};
static_assert(alignof(UUMGPromoPackCurrencyWidget) == 0x000008, "Wrong alignment on UUMGPromoPackCurrencyWidget");
static_assert(sizeof(UUMGPromoPackCurrencyWidget) == 0x0004A0, "Wrong size on UUMGPromoPackCurrencyWidget");

// Class DeadByDaylight.EmblemRankContainer
// 0x0210 (0x0248 - 0x0038)
class UEmblemRankContainer final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x210];                                     // 0x0038(0x0210)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmblemRankContainer">();
	}
	static class UEmblemRankContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmblemRankContainer>();
	}
};
static_assert(alignof(UEmblemRankContainer) == 0x000008, "Wrong alignment on UEmblemRankContainer");
static_assert(sizeof(UEmblemRankContainer) == 0x000248, "Wrong size on UEmblemRankContainer");

// Class DeadByDaylight.PushableInterface
// 0x0000 (0x0000 - 0x0000)
class IPushableInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PushableInterface">();
	}
	static class IPushableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPushableInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPushableInterface) == 0x000001, "Wrong alignment on IPushableInterface");
static_assert(sizeof(IPushableInterface) == 0x000001, "Wrong size on IPushableInterface");

// Class DeadByDaylight.AtlantaDisplayStand
// 0x0010 (0x03C0 - 0x03B0)
class AAtlantaDisplayStand final : public ADisplayStand
{
public:
	EAtlantaDisplayStandPosition                  StandPosition;                                     // 0x03A8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SurvivorPositionMarker;                            // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        KillerPositionMarker;                              // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaDisplayStand">();
	}
	static class AAtlantaDisplayStand* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlantaDisplayStand>();
	}
};
static_assert(alignof(AAtlantaDisplayStand) == 0x000010, "Wrong alignment on AAtlantaDisplayStand");
static_assert(sizeof(AAtlantaDisplayStand) == 0x0003C0, "Wrong size on AAtlantaDisplayStand");
static_assert(offsetof(AAtlantaDisplayStand, StandPosition) == 0x0003A8, "Member 'AAtlantaDisplayStand::StandPosition' has a wrong offset!");
static_assert(offsetof(AAtlantaDisplayStand, SurvivorPositionMarker) == 0x0003B0, "Member 'AAtlantaDisplayStand::SurvivorPositionMarker' has a wrong offset!");
static_assert(offsetof(AAtlantaDisplayStand, KillerPositionMarker) == 0x0003B8, "Member 'AAtlantaDisplayStand::KillerPositionMarker' has a wrong offset!");

// Class DeadByDaylight.AtlantaHudDirectionalStick
// 0x0048 (0x0380 - 0x0338)
class UAtlantaHudDirectionalStick final : public UMobileBaseUserWidget
{
public:
	class UCanvasPanel*                           JoystickAnimationPanel;                            // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ContainerToRotate;                                 // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ArrowsContainer;                                   // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 JoystickLockImage;                                 // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 JoystickOn;                                        // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           AutoRunContainer;                                  // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMovementLockAnimationActive;                    // 0x0368(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_369[0x17];                                     // 0x0369(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMovementLockAnimationStatus(bool value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaHudDirectionalStick">();
	}
	static class UAtlantaHudDirectionalStick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaHudDirectionalStick>();
	}
};
static_assert(alignof(UAtlantaHudDirectionalStick) == 0x000008, "Wrong alignment on UAtlantaHudDirectionalStick");
static_assert(sizeof(UAtlantaHudDirectionalStick) == 0x000380, "Wrong size on UAtlantaHudDirectionalStick");
static_assert(offsetof(UAtlantaHudDirectionalStick, JoystickAnimationPanel) == 0x000338, "Member 'UAtlantaHudDirectionalStick::JoystickAnimationPanel' has a wrong offset!");
static_assert(offsetof(UAtlantaHudDirectionalStick, ContainerToRotate) == 0x000340, "Member 'UAtlantaHudDirectionalStick::ContainerToRotate' has a wrong offset!");
static_assert(offsetof(UAtlantaHudDirectionalStick, ArrowsContainer) == 0x000348, "Member 'UAtlantaHudDirectionalStick::ArrowsContainer' has a wrong offset!");
static_assert(offsetof(UAtlantaHudDirectionalStick, JoystickLockImage) == 0x000350, "Member 'UAtlantaHudDirectionalStick::JoystickLockImage' has a wrong offset!");
static_assert(offsetof(UAtlantaHudDirectionalStick, JoystickOn) == 0x000358, "Member 'UAtlantaHudDirectionalStick::JoystickOn' has a wrong offset!");
static_assert(offsetof(UAtlantaHudDirectionalStick, AutoRunContainer) == 0x000360, "Member 'UAtlantaHudDirectionalStick::AutoRunContainer' has a wrong offset!");
static_assert(offsetof(UAtlantaHudDirectionalStick, _isMovementLockAnimationActive) == 0x000368, "Member 'UAtlantaHudDirectionalStick::_isMovementLockAnimationActive' has a wrong offset!");

// Class DeadByDaylight.UMGBaseRootStorefrontWidget
// 0x00F0 (0x0428 - 0x0338)
class UUMGBaseRootStorefrontWidget : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x48];                                     // 0x0338(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UNamedSlot*                             StorePageSlot;                                     // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBaseButtonWidget*                   BackButton;                                        // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           CurrencyButtonsPanel;                              // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             StorefrontTitle;                                   // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x88];                                     // 0x03A0(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBackButtonPressed();
	void OnCurrencyButtonLongPressed(const struct FTooltipPressedData& tooltipPressedData, const ECurrencyType currencyType);
	void OnPurchaseAuricCellButtonPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBaseRootStorefrontWidget">();
	}
	static class UUMGBaseRootStorefrontWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBaseRootStorefrontWidget>();
	}
};
static_assert(alignof(UUMGBaseRootStorefrontWidget) == 0x000008, "Wrong alignment on UUMGBaseRootStorefrontWidget");
static_assert(sizeof(UUMGBaseRootStorefrontWidget) == 0x000428, "Wrong size on UUMGBaseRootStorefrontWidget");
static_assert(offsetof(UUMGBaseRootStorefrontWidget, StorePageSlot) == 0x000380, "Member 'UUMGBaseRootStorefrontWidget::StorePageSlot' has a wrong offset!");
static_assert(offsetof(UUMGBaseRootStorefrontWidget, BackButton) == 0x000388, "Member 'UUMGBaseRootStorefrontWidget::BackButton' has a wrong offset!");
static_assert(offsetof(UUMGBaseRootStorefrontWidget, CurrencyButtonsPanel) == 0x000390, "Member 'UUMGBaseRootStorefrontWidget::CurrencyButtonsPanel' has a wrong offset!");
static_assert(offsetof(UUMGBaseRootStorefrontWidget, StorefrontTitle) == 0x000398, "Member 'UUMGBaseRootStorefrontWidget::StorefrontTitle' has a wrong offset!");

// Class DeadByDaylight.UMGAtlRootStorefrontWidget
// 0x0010 (0x0438 - 0x0428)
class UUMGAtlRootStorefrontWidget final : public UUMGBaseRootStorefrontWidget
{
public:
	class UUMGCurrencyWidget*                     ShardWalletWidget;                                 // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGAuricCellsButton*                   AuricWalletWidget;                                 // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlRootStorefrontWidget">();
	}
	static class UUMGAtlRootStorefrontWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlRootStorefrontWidget>();
	}
};
static_assert(alignof(UUMGAtlRootStorefrontWidget) == 0x000008, "Wrong alignment on UUMGAtlRootStorefrontWidget");
static_assert(sizeof(UUMGAtlRootStorefrontWidget) == 0x000438, "Wrong size on UUMGAtlRootStorefrontWidget");
static_assert(offsetof(UUMGAtlRootStorefrontWidget, ShardWalletWidget) == 0x000428, "Member 'UUMGAtlRootStorefrontWidget::ShardWalletWidget' has a wrong offset!");
static_assert(offsetof(UUMGAtlRootStorefrontWidget, AuricWalletWidget) == 0x000430, "Member 'UUMGAtlRootStorefrontWidget::AuricWalletWidget' has a wrong offset!");

// Class DeadByDaylight.VaultableOutlineUpdateStrategy
// 0x0008 (0x0140 - 0x0138)
class UVaultableOutlineUpdateStrategy : public USourceBasedOutlineUpdateStrategy
{
public:
	bool                                          _canBeRevealedToLocalPlayer;                       // 0x0138(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCanBeRevealedToLocalPlayer(bool canBeRevealedToLocalPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultableOutlineUpdateStrategy">();
	}
	static class UVaultableOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultableOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UVaultableOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UVaultableOutlineUpdateStrategy");
static_assert(sizeof(UVaultableOutlineUpdateStrategy) == 0x000140, "Wrong size on UVaultableOutlineUpdateStrategy");
static_assert(offsetof(UVaultableOutlineUpdateStrategy, _canBeRevealedToLocalPlayer) == 0x000138, "Member 'UVaultableOutlineUpdateStrategy::_canBeRevealedToLocalPlayer' has a wrong offset!");

// Class DeadByDaylight.PalletOutlineUpdateStrategy
// 0x0010 (0x0150 - 0x0140)
class UPalletOutlineUpdateStrategy : public UVaultableOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _revealedByPowerColor;                             // 0x0140(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletOutlineUpdateStrategy">();
	}
	static class UPalletOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalletOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UPalletOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UPalletOutlineUpdateStrategy");
static_assert(sizeof(UPalletOutlineUpdateStrategy) == 0x000150, "Wrong size on UPalletOutlineUpdateStrategy");
static_assert(offsetof(UPalletOutlineUpdateStrategy, _revealedByPowerColor) == 0x000140, "Member 'UPalletOutlineUpdateStrategy::_revealedByPowerColor' has a wrong offset!");

// Class DeadByDaylight.DreamPalletOutlineUpdateStrategy
// 0x0028 (0x0178 - 0x0150)
class UDreamPalletOutlineUpdateStrategy final : public UPalletOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _revealedByMapColor;                               // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x18];                                     // 0x0160(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeTunableValues(class ASlasherPlayer* killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamPalletOutlineUpdateStrategy">();
	}
	static class UDreamPalletOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamPalletOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UDreamPalletOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UDreamPalletOutlineUpdateStrategy");
static_assert(sizeof(UDreamPalletOutlineUpdateStrategy) == 0x000178, "Wrong size on UDreamPalletOutlineUpdateStrategy");
static_assert(offsetof(UDreamPalletOutlineUpdateStrategy, _revealedByMapColor) == 0x000150, "Member 'UDreamPalletOutlineUpdateStrategy::_revealedByMapColor' has a wrong offset!");

// Class DeadByDaylight.AtlantaHudLookBackJoystick
// 0x0008 (0x0340 - 0x0338)
class UAtlantaHudLookBackJoystick final : public UMobileBaseUserWidget
{
public:
	class UGridPanel*                             TutorialAnimContainer;                             // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaHudLookBackJoystick">();
	}
	static class UAtlantaHudLookBackJoystick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaHudLookBackJoystick>();
	}
};
static_assert(alignof(UAtlantaHudLookBackJoystick) == 0x000008, "Wrong alignment on UAtlantaHudLookBackJoystick");
static_assert(sizeof(UAtlantaHudLookBackJoystick) == 0x000340, "Wrong size on UAtlantaHudLookBackJoystick");
static_assert(offsetof(UAtlantaHudLookBackJoystick, TutorialAnimContainer) == 0x000338, "Member 'UAtlantaHudLookBackJoystick::TutorialAnimContainer' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaPromoCodeRewardItemWidget
// 0x0138 (0x0470 - 0x0338)
class UUMGAtlantaPromoCodeRewardItemWidget final : public UMobileBaseUserWidget
{
public:
	class UPanelWidget*                           CurrencyItem;                                      // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CurrencyIcon;                                      // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrencyName;                                      // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrencyAmount;                                    // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemRarityTint;                                    // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       RevealAnimationSmall;                              // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           CustomizationItem;                                 // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CustomizationIcon;                                 // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CustomizationName;                                 // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CustomizationRarityTint;                           // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       RevealAnimationLarge;                              // 0x0388(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           CharacterPanel;                                    // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CharacterPortrait;                                 // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CharacterName;                                     // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           TicketPanel;                                       // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TicketRarityTint;                                  // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TicketIcon;                                        // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TicketName;                                        // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TicketAmount;                                      // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           OfferingPanel;                                     // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 OfferingRarityTint;                                // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 OfferingIcon;                                      // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             OfferingName;                                      // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             OfferingAmount;                                    // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F8[0x78];                                     // 0x03F8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaPromoCodeRewardItemWidget">();
	}
	static class UUMGAtlantaPromoCodeRewardItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaPromoCodeRewardItemWidget>();
	}
};
static_assert(alignof(UUMGAtlantaPromoCodeRewardItemWidget) == 0x000008, "Wrong alignment on UUMGAtlantaPromoCodeRewardItemWidget");
static_assert(sizeof(UUMGAtlantaPromoCodeRewardItemWidget) == 0x000470, "Wrong size on UUMGAtlantaPromoCodeRewardItemWidget");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, CurrencyItem) == 0x000338, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::CurrencyItem' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, CurrencyIcon) == 0x000340, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::CurrencyIcon' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, CurrencyName) == 0x000348, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::CurrencyName' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, CurrencyAmount) == 0x000350, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::CurrencyAmount' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, ItemRarityTint) == 0x000358, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::ItemRarityTint' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, RevealAnimationSmall) == 0x000360, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::RevealAnimationSmall' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, CustomizationItem) == 0x000368, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::CustomizationItem' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, CustomizationIcon) == 0x000370, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::CustomizationIcon' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, CustomizationName) == 0x000378, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::CustomizationName' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, CustomizationRarityTint) == 0x000380, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::CustomizationRarityTint' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, RevealAnimationLarge) == 0x000388, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::RevealAnimationLarge' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, CharacterPanel) == 0x000390, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::CharacterPanel' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, CharacterPortrait) == 0x000398, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::CharacterPortrait' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, CharacterName) == 0x0003A0, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::CharacterName' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, TicketPanel) == 0x0003A8, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::TicketPanel' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, TicketRarityTint) == 0x0003B0, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::TicketRarityTint' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, TicketIcon) == 0x0003B8, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::TicketIcon' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, TicketName) == 0x0003C0, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::TicketName' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, TicketAmount) == 0x0003C8, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::TicketAmount' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, OfferingPanel) == 0x0003D0, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::OfferingPanel' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, OfferingRarityTint) == 0x0003D8, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::OfferingRarityTint' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, OfferingIcon) == 0x0003E0, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::OfferingIcon' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, OfferingName) == 0x0003E8, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::OfferingName' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPromoCodeRewardItemWidget, OfferingAmount) == 0x0003F0, "Member 'UUMGAtlantaPromoCodeRewardItemWidget::OfferingAmount' has a wrong offset!");

// Class DeadByDaylight.LobbyLevel
// 0x0088 (0x02C0 - 0x0238)
class ALobbyLevel : public ALevelScriptActor
{
public:
	uint8                                         Pad_238[0x48];                                     // 0x0238(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADisplayStand*>                  _registeredDisplayStands;                          // 0x0280(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	EWorldFlowEvent                               LobbyLoadedEvent;                                  // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_291[0x2F];                                     // 0x0291(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAdditionalSubLevelsLoaded();
	void OnLobbySubLevelLoaded();
	void OnShopSubLevelLoaded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyLevel">();
	}
	static class ALobbyLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyLevel>();
	}
};
static_assert(alignof(ALobbyLevel) == 0x000008, "Wrong alignment on ALobbyLevel");
static_assert(sizeof(ALobbyLevel) == 0x0002C0, "Wrong size on ALobbyLevel");
static_assert(offsetof(ALobbyLevel, _registeredDisplayStands) == 0x000280, "Member 'ALobbyLevel::_registeredDisplayStands' has a wrong offset!");
static_assert(offsetof(ALobbyLevel, LobbyLoadedEvent) == 0x000290, "Member 'ALobbyLevel::LobbyLoadedEvent' has a wrong offset!");

// Class DeadByDaylight.VaultableComponent
// 0x0020 (0x00D8 - 0x00B8)
class UVaultableComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class ADBDPlayer* vaulter)> OnVault;                               // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChaseEnded(class ADBDPlayer* survivor, float chaseTimer);
	void SignalVault(class ADBDPlayer* survivor, float interactionTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultableComponent">();
	}
	static class UVaultableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultableComponent>();
	}
};
static_assert(alignof(UVaultableComponent) == 0x000008, "Wrong alignment on UVaultableComponent");
static_assert(sizeof(UVaultableComponent) == 0x0000D8, "Wrong size on UVaultableComponent");
static_assert(offsetof(UVaultableComponent, OnVault) == 0x0000B8, "Member 'UVaultableComponent::OnVault' has a wrong offset!");

// Class DeadByDaylight.EnergyPoweredInterface
// 0x0000 (0x0000 - 0x0000)
class IEnergyPoweredInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnergyPoweredInterface">();
	}
	static class IEnergyPoweredInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEnergyPoweredInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEnergyPoweredInterface) == 0x000001, "Wrong alignment on IEnergyPoweredInterface");
static_assert(sizeof(IEnergyPoweredInterface) == 0x000001, "Wrong size on IEnergyPoweredInterface");

// Class DeadByDaylight.AtlantaLobbyLevel
// 0x0040 (0x0300 - 0x02C0)
class AAtlantaLobbyLevel final : public ALobbyLevel
{
public:
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLightingChannels                      ForefrontLightingChannel;                          // 0x02D0(0x0001)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	struct FLightingChannels                      BackgroundLightingChannel;                         // 0x02D1(0x0001)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D2[0x6];                                      // 0x02D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AAtlantaOfflineLobbyCamera*             _offlineLobbyCamera;                               // 0x02D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _roleSelectionLobbyCameraPosition;                 // 0x02E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _characterSelectionLobbyCameraPosition;            // 0x02E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _loadoutSelectionLobbyCameraPosition;              // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBackPawnSpawned(class AActor* backgroundPawn);
	void OnFrontPawnSpawned(class AActor* forefrontPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaLobbyLevel">();
	}
	static class AAtlantaLobbyLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlantaLobbyLevel>();
	}
};
static_assert(alignof(AAtlantaLobbyLevel) == 0x000008, "Wrong alignment on AAtlantaLobbyLevel");
static_assert(sizeof(AAtlantaLobbyLevel) == 0x000300, "Wrong size on AAtlantaLobbyLevel");
static_assert(offsetof(AAtlantaLobbyLevel, ForefrontLightingChannel) == 0x0002D0, "Member 'AAtlantaLobbyLevel::ForefrontLightingChannel' has a wrong offset!");
static_assert(offsetof(AAtlantaLobbyLevel, BackgroundLightingChannel) == 0x0002D1, "Member 'AAtlantaLobbyLevel::BackgroundLightingChannel' has a wrong offset!");
static_assert(offsetof(AAtlantaLobbyLevel, _offlineLobbyCamera) == 0x0002D8, "Member 'AAtlantaLobbyLevel::_offlineLobbyCamera' has a wrong offset!");
static_assert(offsetof(AAtlantaLobbyLevel, _roleSelectionLobbyCameraPosition) == 0x0002E0, "Member 'AAtlantaLobbyLevel::_roleSelectionLobbyCameraPosition' has a wrong offset!");
static_assert(offsetof(AAtlantaLobbyLevel, _characterSelectionLobbyCameraPosition) == 0x0002E8, "Member 'AAtlantaLobbyLevel::_characterSelectionLobbyCameraPosition' has a wrong offset!");
static_assert(offsetof(AAtlantaLobbyLevel, _loadoutSelectionLobbyCameraPosition) == 0x0002F0, "Member 'AAtlantaLobbyLevel::_loadoutSelectionLobbyCameraPosition' has a wrong offset!");

// Class DeadByDaylight.VersioningUtilities
// 0x0000 (0x0030 - 0x0030)
class UVersioningUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VersioningUtilities">();
	}
	static class UVersioningUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVersioningUtilities>();
	}
};
static_assert(alignof(UVersioningUtilities) == 0x000008, "Wrong alignment on UVersioningUtilities");
static_assert(sizeof(UVersioningUtilities) == 0x000030, "Wrong size on UVersioningUtilities");

// Class DeadByDaylight.EmblemTooltipWidget
// 0x0058 (0x03C8 - 0x0370)
class UEmblemTooltipWidget final : public UBaseTooltipWidget
{
public:
	class UImage*                                 HeaderBackground;                                  // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SubTitleLabel;                                     // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HeaderSmoke;                                       // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           DataContainer;                                     // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGTallyEmblemProgressBar*             TallyEmblemProgressBar;                            // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ProgressionDataWidgetClass;                        // 0x0398(0x0030)(Edit, DisableEditOnInstance, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmblemTooltipWidget">();
	}
	static class UEmblemTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmblemTooltipWidget>();
	}
};
static_assert(alignof(UEmblemTooltipWidget) == 0x000008, "Wrong alignment on UEmblemTooltipWidget");
static_assert(sizeof(UEmblemTooltipWidget) == 0x0003C8, "Wrong size on UEmblemTooltipWidget");
static_assert(offsetof(UEmblemTooltipWidget, HeaderBackground) == 0x000370, "Member 'UEmblemTooltipWidget::HeaderBackground' has a wrong offset!");
static_assert(offsetof(UEmblemTooltipWidget, SubTitleLabel) == 0x000378, "Member 'UEmblemTooltipWidget::SubTitleLabel' has a wrong offset!");
static_assert(offsetof(UEmblemTooltipWidget, HeaderSmoke) == 0x000380, "Member 'UEmblemTooltipWidget::HeaderSmoke' has a wrong offset!");
static_assert(offsetof(UEmblemTooltipWidget, DataContainer) == 0x000388, "Member 'UEmblemTooltipWidget::DataContainer' has a wrong offset!");
static_assert(offsetof(UEmblemTooltipWidget, TallyEmblemProgressBar) == 0x000390, "Member 'UEmblemTooltipWidget::TallyEmblemProgressBar' has a wrong offset!");
static_assert(offsetof(UEmblemTooltipWidget, ProgressionDataWidgetClass) == 0x000398, "Member 'UEmblemTooltipWidget::ProgressionDataWidgetClass' has a wrong offset!");

// Class DeadByDaylight.AtlantaObjectiveWidget
// 0x0068 (0x03A0 - 0x0338)
class UAtlantaObjectiveWidget final : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             ObjectiveLabel;                                    // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_340[0x54];                                     // 0x0340(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _totalFadeOutTime;                                 // 0x0394(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _polynomialOrder;                                  // 0x0398(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaObjectiveWidget">();
	}
	static class UAtlantaObjectiveWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaObjectiveWidget>();
	}
};
static_assert(alignof(UAtlantaObjectiveWidget) == 0x000008, "Wrong alignment on UAtlantaObjectiveWidget");
static_assert(sizeof(UAtlantaObjectiveWidget) == 0x0003A0, "Wrong size on UAtlantaObjectiveWidget");
static_assert(offsetof(UAtlantaObjectiveWidget, ObjectiveLabel) == 0x000338, "Member 'UAtlantaObjectiveWidget::ObjectiveLabel' has a wrong offset!");
static_assert(offsetof(UAtlantaObjectiveWidget, _totalFadeOutTime) == 0x000394, "Member 'UAtlantaObjectiveWidget::_totalFadeOutTime' has a wrong offset!");
static_assert(offsetof(UAtlantaObjectiveWidget, _polynomialOrder) == 0x000398, "Member 'UAtlantaObjectiveWidget::_polynomialOrder' has a wrong offset!");

// Class DeadByDaylight.EdgeObjectHandlingStrategy
// 0x0128 (0x0158 - 0x0030)
class UEdgeObjectHandlingStrategy final : public UObject
{
public:
	TArray<class UActorSpawner*>                  _edgeObjectSpawners;                               // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UActorSpawner*>                  _edgeObjectBlockers;                               // 0x0040(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x108];                                     // 0x0050(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EdgeObjectHandlingStrategy">();
	}
	static class UEdgeObjectHandlingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEdgeObjectHandlingStrategy>();
	}
};
static_assert(alignof(UEdgeObjectHandlingStrategy) == 0x000008, "Wrong alignment on UEdgeObjectHandlingStrategy");
static_assert(sizeof(UEdgeObjectHandlingStrategy) == 0x000158, "Wrong size on UEdgeObjectHandlingStrategy");
static_assert(offsetof(UEdgeObjectHandlingStrategy, _edgeObjectSpawners) == 0x000030, "Member 'UEdgeObjectHandlingStrategy::_edgeObjectSpawners' has a wrong offset!");
static_assert(offsetof(UEdgeObjectHandlingStrategy, _edgeObjectBlockers) == 0x000040, "Member 'UEdgeObjectHandlingStrategy::_edgeObjectBlockers' has a wrong offset!");

// Class DeadByDaylight.AtlantaOfflineLobbyCamera
// 0x0010 (0x07D0 - 0x07C0)
class AAtlantaOfflineLobbyCamera final : public ACameraActor
{
public:
	float                                         ZCameraPositionOffsetMultiplier;                   // 0x07C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C4[0x4];                                      // 0x07C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _kDefaultAspectRatio;                              // 0x07C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7CC[0x4];                                      // 0x07CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCameraPosition(const struct FVector& positionVector);
	void SetCameraRotation(const struct FRotator& rotationVector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaOfflineLobbyCamera">();
	}
	static class AAtlantaOfflineLobbyCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAtlantaOfflineLobbyCamera>();
	}
};
static_assert(alignof(AAtlantaOfflineLobbyCamera) == 0x000010, "Wrong alignment on AAtlantaOfflineLobbyCamera");
static_assert(sizeof(AAtlantaOfflineLobbyCamera) == 0x0007D0, "Wrong size on AAtlantaOfflineLobbyCamera");
static_assert(offsetof(AAtlantaOfflineLobbyCamera, ZCameraPositionOffsetMultiplier) == 0x0007C0, "Member 'AAtlantaOfflineLobbyCamera::ZCameraPositionOffsetMultiplier' has a wrong offset!");
static_assert(offsetof(AAtlantaOfflineLobbyCamera, _kDefaultAspectRatio) == 0x0007C8, "Member 'AAtlantaOfflineLobbyCamera::_kDefaultAspectRatio' has a wrong offset!");

// Class DeadByDaylight.EndGameStateComponent
// 0x0068 (0x0120 - 0x00B8)
class UEndGameStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xC];                                       // 0x00B8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isEndGameOver;                                    // 0x00C4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _worldTimeAtLastModification;                      // 0x00C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC[0x44];                                      // 0x00CC(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeDilation;                                     // 0x0110(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isTimerPaused;                                    // 0x0114(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _normalTotalTimeElapsedAtLastTimeModification;     // 0x0118(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEndGameScenarioTrigger                       _endGameScenarioTrigger;                           // 0x011C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_SetIsInEndGameSimulation(bool endGameSimulation);
	void OnRep_IsEndGameOver();
	void OnRep_IsTimerPaused();
	void OnRep_TimeDilation();
	void OnRep_WorldTimeAtLastDilationModification();

	float GetElapsedTimePercent() const;
	bool HasEndGameBegun() const;
	bool IsEndGameOver() const;
	bool IsTimerSlowedDown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameStateComponent">();
	}
	static class UEndGameStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndGameStateComponent>();
	}
};
static_assert(alignof(UEndGameStateComponent) == 0x000008, "Wrong alignment on UEndGameStateComponent");
static_assert(sizeof(UEndGameStateComponent) == 0x000120, "Wrong size on UEndGameStateComponent");
static_assert(offsetof(UEndGameStateComponent, _isEndGameOver) == 0x0000C4, "Member 'UEndGameStateComponent::_isEndGameOver' has a wrong offset!");
static_assert(offsetof(UEndGameStateComponent, _worldTimeAtLastModification) == 0x0000C8, "Member 'UEndGameStateComponent::_worldTimeAtLastModification' has a wrong offset!");
static_assert(offsetof(UEndGameStateComponent, _timeDilation) == 0x000110, "Member 'UEndGameStateComponent::_timeDilation' has a wrong offset!");
static_assert(offsetof(UEndGameStateComponent, _isTimerPaused) == 0x000114, "Member 'UEndGameStateComponent::_isTimerPaused' has a wrong offset!");
static_assert(offsetof(UEndGameStateComponent, _normalTotalTimeElapsedAtLastTimeModification) == 0x000118, "Member 'UEndGameStateComponent::_normalTotalTimeElapsedAtLastTimeModification' has a wrong offset!");
static_assert(offsetof(UEndGameStateComponent, _endGameScenarioTrigger) == 0x00011C, "Member 'UEndGameStateComponent::_endGameScenarioTrigger' has a wrong offset!");

// Class DeadByDaylight.AtlantaPartyFlowUtilities
// 0x0000 (0x0030 - 0x0030)
class UAtlantaPartyFlowUtilities final : public UObject
{
public:
	static bool IsCurrentPlayerAloneInParty();
	static bool IsCurrentPlayerInParty();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaPartyFlowUtilities">();
	}
	static class UAtlantaPartyFlowUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaPartyFlowUtilities>();
	}
};
static_assert(alignof(UAtlantaPartyFlowUtilities) == 0x000008, "Wrong alignment on UAtlantaPartyFlowUtilities");
static_assert(sizeof(UAtlantaPartyFlowUtilities) == 0x000030, "Wrong size on UAtlantaPartyFlowUtilities");

// Class DeadByDaylight.AtlantaInstalledContent
// 0x0020 (0x0050 - 0x0030)
class UAtlantaInstalledContent : public UObject
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetFreeDiskSpace();
	float GetInstalledContentSize();
	bool Mount(int32 PakOrder, const class FString& MountPoint);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaInstalledContent">();
	}
	static class UAtlantaInstalledContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaInstalledContent>();
	}
};
static_assert(alignof(UAtlantaInstalledContent) == 0x000008, "Wrong alignment on UAtlantaInstalledContent");
static_assert(sizeof(UAtlantaInstalledContent) == 0x000050, "Wrong size on UAtlantaInstalledContent");

// Class DeadByDaylight.WalesCypherParameters
// 0x0018 (0x0050 - 0x0038)
class UWalesCypherParameters final : public UDataAsset
{
public:
	class FString                                 AUDIO_EVENT;                                       // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SLASHER_INDEX;                                     // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CAMPER_INDEX;                                      // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WalesCypherParameters">();
	}
	static class UWalesCypherParameters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWalesCypherParameters>();
	}
};
static_assert(alignof(UWalesCypherParameters) == 0x000008, "Wrong alignment on UWalesCypherParameters");
static_assert(sizeof(UWalesCypherParameters) == 0x000050, "Wrong size on UWalesCypherParameters");
static_assert(offsetof(UWalesCypherParameters, AUDIO_EVENT) == 0x000038, "Member 'UWalesCypherParameters::AUDIO_EVENT' has a wrong offset!");
static_assert(offsetof(UWalesCypherParameters, SLASHER_INDEX) == 0x000048, "Member 'UWalesCypherParameters::SLASHER_INDEX' has a wrong offset!");
static_assert(offsetof(UWalesCypherParameters, CAMPER_INDEX) == 0x00004C, "Member 'UWalesCypherParameters::CAMPER_INDEX' has a wrong offset!");

// Class DeadByDaylight.EscapeDoorAnimInstance
// 0x0000 (0x02D0 - 0x02D0)
class UEscapeDoorAnimInstance final : public USleepingAnimInstance
{
public:
	bool                                          _isOpen;                                           // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOpenByKiller;                                   // 0x02C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CA[0x6];                                      // 0x02CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlaySound(class UAkAudioEvent* akEvent);
	void SetIsOpen(bool isOpen);
	void SetIsOpenByKiller(const bool isOpenByKiller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeDoorAnimInstance">();
	}
	static class UEscapeDoorAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEscapeDoorAnimInstance>();
	}
};
static_assert(alignof(UEscapeDoorAnimInstance) == 0x000010, "Wrong alignment on UEscapeDoorAnimInstance");
static_assert(sizeof(UEscapeDoorAnimInstance) == 0x0002D0, "Wrong size on UEscapeDoorAnimInstance");
static_assert(offsetof(UEscapeDoorAnimInstance, _isOpen) == 0x0002C8, "Member 'UEscapeDoorAnimInstance::_isOpen' has a wrong offset!");
static_assert(offsetof(UEscapeDoorAnimInstance, _isOpenByKiller) == 0x0002C9, "Member 'UEscapeDoorAnimInstance::_isOpenByKiller' has a wrong offset!");

// Class DeadByDaylight.ReverseBearTrap
// 0x00C0 (0x03E8 - 0x0328)
class AReverseBearTrap final : public AInteractable
{
public:
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 _rbtMesh;                                          // 0x0330(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationMontageSlave*                 _animMontageSlave;                                 // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x4];                                      // 0x0340(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _keyID;                                            // 0x0344(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _attemptsNeededToDetach;                           // 0x0348(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34C[0x94];                                     // 0x034C(0x0094)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _exitGatesPoweredAfterAttachment;                  // 0x03E0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _generatorFixedAfterAttachment;                    // 0x03E1(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E2[0x6];                                      // 0x03E2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachSurvivor(class ACamperPlayer* survivor);
	void Authority_GenerateAttemptsNeeded(const int32 remainingAttemptsTotal, const int32 remainingRBTs, const int32 numRemovers);
	void Authority_SetKeyID(int32 keyID);
	void DetachSurvivor(class ACamperPlayer* survivor);
	void FastForwardExecutionTimer(float deltaTime);
	void IncrementAttemptsMade();
	void NotifyDetachStarted(class ACamperPlayer* survivor);
	void NotifyOnAttachSurvivorBegin(class ACamperPlayer* survivor);
	void OnAttachSurvivor(class ACamperPlayer* survivor);
	void OnAttachSurvivorBegin(class ACamperPlayer* survivor);
	void OnDetachSurvivor(class ACamperPlayer* survivor);
	void OnEnterWarningZone();
	void OnExitWarningZone();
	void OnGeneratorComplete(int32 activatedGeneratorCount);
	void OnWarningLevelChanged(int32 previousWarningLevel, int32 currentWarningLevel);
	void ResetExecutionTimer(float time);
	void SetGateClosedAtAttachment(bool closed);
	void SetVisible(bool visible);
	void StopExecutionTimer();
	void StopMontage();

	bool CanExecute() const;
	class ACamperPlayer* GetAttachedSurvivor() const;
	int32 GetAttemptsMade() const;
	int32 GetAttemptsNeeded() const;
	float GetExecutionTimerPercentTimeElapsed() const;
	float GetExecutionTimerTimeLeft() const;
	bool GetExitGatesPoweredAfterAttachment() const;
	bool GetGeneratorFixedAfterAttachment() const;
	int32 GetKeyID() const;
	int32 GetWarningLevel() const;
	bool GetWasGateClosedAtAttachment() const;
	bool HasDetachStarted() const;
	bool IsExecutionTimerActive() const;
	bool IsExecutionTimerDone() const;
	bool IsInWarningZone() const;
	bool IsRBTActivated() const;
	bool ShouldUpdateExecutionTimer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReverseBearTrap">();
	}
	static class AReverseBearTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReverseBearTrap>();
	}
};
static_assert(alignof(AReverseBearTrap) == 0x000008, "Wrong alignment on AReverseBearTrap");
static_assert(sizeof(AReverseBearTrap) == 0x0003E8, "Wrong size on AReverseBearTrap");
static_assert(offsetof(AReverseBearTrap, _rbtMesh) == 0x000330, "Member 'AReverseBearTrap::_rbtMesh' has a wrong offset!");
static_assert(offsetof(AReverseBearTrap, _animMontageSlave) == 0x000338, "Member 'AReverseBearTrap::_animMontageSlave' has a wrong offset!");
static_assert(offsetof(AReverseBearTrap, _keyID) == 0x000344, "Member 'AReverseBearTrap::_keyID' has a wrong offset!");
static_assert(offsetof(AReverseBearTrap, _attemptsNeededToDetach) == 0x000348, "Member 'AReverseBearTrap::_attemptsNeededToDetach' has a wrong offset!");
static_assert(offsetof(AReverseBearTrap, _exitGatesPoweredAfterAttachment) == 0x0003E0, "Member 'AReverseBearTrap::_exitGatesPoweredAfterAttachment' has a wrong offset!");
static_assert(offsetof(AReverseBearTrap, _generatorFixedAfterAttachment) == 0x0003E1, "Member 'AReverseBearTrap::_generatorFixedAfterAttachment' has a wrong offset!");

// Class DeadByDaylight.AtlantaPendingContent
// 0x0040 (0x0090 - 0x0050)
class UAtlantaPendingContent final : public UAtlantaInstalledContent
{
public:
	uint8                                         Pad_50[0x40];                                      // 0x0050(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetDownloadSize();
	float GetDownloadSpeed();
	class FText GetDownloadStatusText();
	float GetInstallProgress();
	bool GetIsDownloading();
	float GetRequiredDiskSpace();
	float GetTotalDownloadedSize();
	void StartInstall(TDelegate<void()> OnSucceeded, TDelegate<void(class FText ErrorText, int32 ErrorCode)> OnFailed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaPendingContent">();
	}
	static class UAtlantaPendingContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaPendingContent>();
	}
};
static_assert(alignof(UAtlantaPendingContent) == 0x000008, "Wrong alignment on UAtlantaPendingContent");
static_assert(sizeof(UAtlantaPendingContent) == 0x000090, "Wrong size on UAtlantaPendingContent");

// Class DeadByDaylight.AtlantaPatchingLibrary
// 0x0000 (0x0030 - 0x0030)
class UAtlantaPatchingLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetActiveDeviceProfileName();
	static class UAtlantaInstalledContent* GetInstalledContent(const class FString& InstallDirectory, const class FString& ManifestFilename);
	static TArray<class FString> GetSupportedPlatformNames();
	static bool HasActiveWiFiConnection();
	static void PrintPakLocations();
	static void RequestContent(const class FString& RemoteManifestURL, const class FString& CloudURL, const class FString& InstallDirectory, TDelegate<void(class UAtlantaPendingContent* MobilePendingContent)> OnSucceeded, TDelegate<void(class FText ErrorText, int32 ErrorCode)> OnFailed, class UAtlantaPendingContent* MobilePendingContent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaPatchingLibrary">();
	}
	static class UAtlantaPatchingLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaPatchingLibrary>();
	}
};
static_assert(alignof(UAtlantaPatchingLibrary) == 0x000008, "Wrong alignment on UAtlantaPatchingLibrary");
static_assert(sizeof(UAtlantaPatchingLibrary) == 0x000030, "Wrong size on UAtlantaPatchingLibrary");

// Class DeadByDaylight.WeightedElement
// 0x0000 (0x0000 - 0x0000)
class IWeightedElement final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeightedElement">();
	}
	static class IWeightedElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWeightedElement>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IWeightedElement) == 0x000001, "Wrong alignment on IWeightedElement");
static_assert(sizeof(IWeightedElement) == 0x000001, "Wrong size on IWeightedElement");

// Class DeadByDaylight.Entity
// 0x0020 (0x0250 - 0x0230)
class AEntity final : public AActor
{
public:
	class UCurveFloat*                            _dissolveCurve;                                    // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _revealsCurve;                                     // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialHelper*                        _materialHelper;                                   // 0x0240(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 _skeletalMesh;                                     // 0x0248(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ChangeToIdleState();
	void ChangeToSacrificeState();
	void ChangeToStruggleState();
	void CompleteSacrifice(bool isBasementHook);
	void HideEntity();
	void InitEntity(class AMeatHook* meatHook);
	void OnReactionStart();
	void SetAnimationIsStruggling(bool isStruggling);
	void SetAnimationStrugglePercent(float percent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Entity">();
	}
	static class AEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEntity>();
	}
};
static_assert(alignof(AEntity) == 0x000008, "Wrong alignment on AEntity");
static_assert(sizeof(AEntity) == 0x000250, "Wrong size on AEntity");
static_assert(offsetof(AEntity, _dissolveCurve) == 0x000230, "Member 'AEntity::_dissolveCurve' has a wrong offset!");
static_assert(offsetof(AEntity, _revealsCurve) == 0x000238, "Member 'AEntity::_revealsCurve' has a wrong offset!");
static_assert(offsetof(AEntity, _materialHelper) == 0x000240, "Member 'AEntity::_materialHelper' has a wrong offset!");
static_assert(offsetof(AEntity, _skeletalMesh) == 0x000248, "Member 'AEntity::_skeletalMesh' has a wrong offset!");

// Class DeadByDaylight.AtlantaPromptWidget
// 0x0068 (0x03A0 - 0x0338)
class UAtlantaPromptWidget final : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             PromptLabel;                                       // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPromptType, class FString>              AudioCues;                                         // 0x0350(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaPromptWidget">();
	}
	static class UAtlantaPromptWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaPromptWidget>();
	}
};
static_assert(alignof(UAtlantaPromptWidget) == 0x000008, "Wrong alignment on UAtlantaPromptWidget");
static_assert(sizeof(UAtlantaPromptWidget) == 0x0003A0, "Wrong size on UAtlantaPromptWidget");
static_assert(offsetof(UAtlantaPromptWidget, PromptLabel) == 0x000338, "Member 'UAtlantaPromptWidget::PromptLabel' has a wrong offset!");
static_assert(offsetof(UAtlantaPromptWidget, AudioCues) == 0x000350, "Member 'UAtlantaPromptWidget::AudioCues' has a wrong offset!");

// Class DeadByDaylight.ProgressionSystemInfoPopupScreen
// 0x0000 (0x0140 - 0x0140)
class UProgressionSystemInfoPopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressionSystemInfoPopupScreen">();
	}
	static class UProgressionSystemInfoPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProgressionSystemInfoPopupScreen>();
	}
};
static_assert(alignof(UProgressionSystemInfoPopupScreen) == 0x000008, "Wrong alignment on UProgressionSystemInfoPopupScreen");
static_assert(sizeof(UProgressionSystemInfoPopupScreen) == 0x000140, "Wrong size on UProgressionSystemInfoPopupScreen");

// Class DeadByDaylight.AtlantaRitualsManager
// 0x0098 (0x00C8 - 0x0030)
class UAtlantaRitualsManager final : public UObject
{
public:
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x90];                                      // 0x0038(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaRitualsManager">();
	}
	static class UAtlantaRitualsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaRitualsManager>();
	}
};
static_assert(alignof(UAtlantaRitualsManager) == 0x000008, "Wrong alignment on UAtlantaRitualsManager");
static_assert(sizeof(UAtlantaRitualsManager) == 0x0000C8, "Wrong size on UAtlantaRitualsManager");
static_assert(offsetof(UAtlantaRitualsManager, _gameInstance) == 0x000030, "Member 'UAtlantaRitualsManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.TutorialNotificationController
// 0x0080 (0x00B0 - 0x0030)
class UTutorialNotificationController final : public UObject
{
public:
	TMulticastInlineDelegate<void(class FName tutorialNotificationId)> OnBlockingNotificationDismissedEvent; // 0x0030(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x70];                                      // 0x0040(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideNotification(bool removeAllCachedNotifs);
	void OnBlockingNotificationDismissed();
	void ShowBlockingNotification(class FName tutorialNotificationId);
	void ShowNotification(class FName tutorialNotificationId, float duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialNotificationController">();
	}
	static class UTutorialNotificationController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialNotificationController>();
	}
};
static_assert(alignof(UTutorialNotificationController) == 0x000008, "Wrong alignment on UTutorialNotificationController");
static_assert(sizeof(UTutorialNotificationController) == 0x0000B0, "Wrong size on UTutorialNotificationController");
static_assert(offsetof(UTutorialNotificationController, OnBlockingNotificationDismissedEvent) == 0x000030, "Member 'UTutorialNotificationController::OnBlockingNotificationDismissedEvent' has a wrong offset!");

// Class DeadByDaylight.EndGameEntity
// 0x0008 (0x0238 - 0x0230)
class AEndGameEntity final : public AActor
{
public:
	class UDBDSkeletalMeshComponentBudgeted*      _skeletalMeshComponent;                            // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameEntity">();
	}
	static class AEndGameEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndGameEntity>();
	}
};
static_assert(alignof(AEndGameEntity) == 0x000008, "Wrong alignment on AEndGameEntity");
static_assert(sizeof(AEndGameEntity) == 0x000238, "Wrong size on AEndGameEntity");
static_assert(offsetof(AEndGameEntity, _skeletalMeshComponent) == 0x000230, "Member 'AEndGameEntity::_skeletalMeshComponent' has a wrong offset!");

// Class DeadByDaylight.AtlantaRitualsScreen
// 0x0068 (0x0188 - 0x0120)
class UAtlantaRitualsScreen final : public UScreenBase
{
public:
	class UUMGAtlantaRitualsScreen*               _umgScreen;                                        // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x60];                                     // 0x0128(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClaimRewards(int32 ritualId);
	void OnExitRequested();
	void OnRefreshRitual();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaRitualsScreen">();
	}
	static class UAtlantaRitualsScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaRitualsScreen>();
	}
};
static_assert(alignof(UAtlantaRitualsScreen) == 0x000008, "Wrong alignment on UAtlantaRitualsScreen");
static_assert(sizeof(UAtlantaRitualsScreen) == 0x000188, "Wrong size on UAtlantaRitualsScreen");
static_assert(offsetof(UAtlantaRitualsScreen, _umgScreen) == 0x000120, "Member 'UAtlantaRitualsScreen::_umgScreen' has a wrong offset!");

// Class DeadByDaylight.AtlantaRoleSelectionScreen
// 0x0008 (0x0128 - 0x0120)
class UAtlantaRoleSelectionScreen final : public UScreenBase
{
public:
	class UUMGRoleSelectionScreen*                _umgScreen;                                        // 0x0120(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaRoleSelectionScreen">();
	}
	static class UAtlantaRoleSelectionScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaRoleSelectionScreen>();
	}
};
static_assert(alignof(UAtlantaRoleSelectionScreen) == 0x000008, "Wrong alignment on UAtlantaRoleSelectionScreen");
static_assert(sizeof(UAtlantaRoleSelectionScreen) == 0x000128, "Wrong size on UAtlantaRoleSelectionScreen");
static_assert(offsetof(UAtlantaRoleSelectionScreen, _umgScreen) == 0x000120, "Member 'UAtlantaRoleSelectionScreen::_umgScreen' has a wrong offset!");

// Class DeadByDaylight.AtlantaSaveGame
// 0x0030 (0x0060 - 0x0030)
class UAtlantaSaveGame final : public USaveGame
{
public:
	class FString                                 SaveSlotName;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        UserIndex;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LastGenericLoadingImageId;                         // 0x0044(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LastSpecificLoadingImageId;                        // 0x0050(0x000C)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLastSpecificImage;                               // 0x005C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaSaveGame">();
	}
	static class UAtlantaSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaSaveGame>();
	}
};
static_assert(alignof(UAtlantaSaveGame) == 0x000008, "Wrong alignment on UAtlantaSaveGame");
static_assert(sizeof(UAtlantaSaveGame) == 0x000060, "Wrong size on UAtlantaSaveGame");
static_assert(offsetof(UAtlantaSaveGame, SaveSlotName) == 0x000030, "Member 'UAtlantaSaveGame::SaveSlotName' has a wrong offset!");
static_assert(offsetof(UAtlantaSaveGame, UserIndex) == 0x000040, "Member 'UAtlantaSaveGame::UserIndex' has a wrong offset!");
static_assert(offsetof(UAtlantaSaveGame, LastGenericLoadingImageId) == 0x000044, "Member 'UAtlantaSaveGame::LastGenericLoadingImageId' has a wrong offset!");
static_assert(offsetof(UAtlantaSaveGame, LastSpecificLoadingImageId) == 0x000050, "Member 'UAtlantaSaveGame::LastSpecificLoadingImageId' has a wrong offset!");
static_assert(offsetof(UAtlantaSaveGame, IsLastSpecificImage) == 0x00005C, "Member 'UAtlantaSaveGame::IsLastSpecificImage' has a wrong offset!");

// Class DeadByDaylight.AtlantaSkillCheckWidget
// 0x0090 (0x03C8 - 0x0338)
class UAtlantaSkillCheckWidget final : public UMobileBaseUserWidget
{
public:
	class UCanvasPanel*                           SkillCheckArea;                                    // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 HitArea;                                           // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Hit;                                               // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 OrangeSmoke;                                       // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 BonusArea;                                         // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 StartMarker;                                       // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 EndMarker;                                         // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           HitAreaContainer;                                  // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           BonusAreaContainer;                                // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           HitAreaStartMarkerContainer;                       // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           HitAreaEndMarkerContainer;                         // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           MarkerContainer;                                   // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HexColor;                                          // 0x0398(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultColor;                                      // 0x03A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _isPlayAnimation;                                  // 0x03B8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathCoveredAngle;                                  // 0x03BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0x8];                                      // 0x03C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnIsActiveChanged(bool isActive);
	void SetActive(bool active);
	void SetHexed(bool isHexed);

	const bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaSkillCheckWidget">();
	}
	static class UAtlantaSkillCheckWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaSkillCheckWidget>();
	}
};
static_assert(alignof(UAtlantaSkillCheckWidget) == 0x000008, "Wrong alignment on UAtlantaSkillCheckWidget");
static_assert(sizeof(UAtlantaSkillCheckWidget) == 0x0003C8, "Wrong size on UAtlantaSkillCheckWidget");
static_assert(offsetof(UAtlantaSkillCheckWidget, SkillCheckArea) == 0x000338, "Member 'UAtlantaSkillCheckWidget::SkillCheckArea' has a wrong offset!");
static_assert(offsetof(UAtlantaSkillCheckWidget, HitArea) == 0x000340, "Member 'UAtlantaSkillCheckWidget::HitArea' has a wrong offset!");
static_assert(offsetof(UAtlantaSkillCheckWidget, Hit) == 0x000348, "Member 'UAtlantaSkillCheckWidget::Hit' has a wrong offset!");
static_assert(offsetof(UAtlantaSkillCheckWidget, OrangeSmoke) == 0x000350, "Member 'UAtlantaSkillCheckWidget::OrangeSmoke' has a wrong offset!");
static_assert(offsetof(UAtlantaSkillCheckWidget, BonusArea) == 0x000358, "Member 'UAtlantaSkillCheckWidget::BonusArea' has a wrong offset!");
static_assert(offsetof(UAtlantaSkillCheckWidget, StartMarker) == 0x000360, "Member 'UAtlantaSkillCheckWidget::StartMarker' has a wrong offset!");
static_assert(offsetof(UAtlantaSkillCheckWidget, EndMarker) == 0x000368, "Member 'UAtlantaSkillCheckWidget::EndMarker' has a wrong offset!");
static_assert(offsetof(UAtlantaSkillCheckWidget, HitAreaContainer) == 0x000370, "Member 'UAtlantaSkillCheckWidget::HitAreaContainer' has a wrong offset!");
static_assert(offsetof(UAtlantaSkillCheckWidget, BonusAreaContainer) == 0x000378, "Member 'UAtlantaSkillCheckWidget::BonusAreaContainer' has a wrong offset!");
static_assert(offsetof(UAtlantaSkillCheckWidget, HitAreaStartMarkerContainer) == 0x000380, "Member 'UAtlantaSkillCheckWidget::HitAreaStartMarkerContainer' has a wrong offset!");
static_assert(offsetof(UAtlantaSkillCheckWidget, HitAreaEndMarkerContainer) == 0x000388, "Member 'UAtlantaSkillCheckWidget::HitAreaEndMarkerContainer' has a wrong offset!");
static_assert(offsetof(UAtlantaSkillCheckWidget, MarkerContainer) == 0x000390, "Member 'UAtlantaSkillCheckWidget::MarkerContainer' has a wrong offset!");
static_assert(offsetof(UAtlantaSkillCheckWidget, HexColor) == 0x000398, "Member 'UAtlantaSkillCheckWidget::HexColor' has a wrong offset!");
static_assert(offsetof(UAtlantaSkillCheckWidget, DefaultColor) == 0x0003A8, "Member 'UAtlantaSkillCheckWidget::DefaultColor' has a wrong offset!");
static_assert(offsetof(UAtlantaSkillCheckWidget, _isPlayAnimation) == 0x0003B8, "Member 'UAtlantaSkillCheckWidget::_isPlayAnimation' has a wrong offset!");
static_assert(offsetof(UAtlantaSkillCheckWidget, PathCoveredAngle) == 0x0003BC, "Member 'UAtlantaSkillCheckWidget::PathCoveredAngle' has a wrong offset!");

// Class DeadByDaylight.AtlantaTooltipManager
// 0x0038 (0x0068 - 0x0030)
class UAtlantaTooltipManager final : public UObject
{
public:
	class UBaseTooltipWidget*                     _activeTooltip;                                    // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGCloseTooltipWidget*                 _closeTooltipWidget;                               // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool TryCloseActiveTooltip();
	void TryCloseActiveTooltipWithWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaTooltipManager">();
	}
	static class UAtlantaTooltipManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaTooltipManager>();
	}
};
static_assert(alignof(UAtlantaTooltipManager) == 0x000008, "Wrong alignment on UAtlantaTooltipManager");
static_assert(sizeof(UAtlantaTooltipManager) == 0x000068, "Wrong size on UAtlantaTooltipManager");
static_assert(offsetof(UAtlantaTooltipManager, _activeTooltip) == 0x000030, "Member 'UAtlantaTooltipManager::_activeTooltip' has a wrong offset!");
static_assert(offsetof(UAtlantaTooltipManager, _closeTooltipWidget) == 0x000038, "Member 'UAtlantaTooltipManager::_closeTooltipWidget' has a wrong offset!");

// Class DeadByDaylight.AtlantaTooltipUtilities
// 0x0000 (0x0030 - 0x0030)
class UAtlantaTooltipUtilities final : public UObject
{
public:
	static bool TryCloseActiveTooltip();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaTooltipUtilities">();
	}
	static class UAtlantaTooltipUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaTooltipUtilities>();
	}
};
static_assert(alignof(UAtlantaTooltipUtilities) == 0x000008, "Wrong alignment on UAtlantaTooltipUtilities");
static_assert(sizeof(UAtlantaTooltipUtilities) == 0x000030, "Wrong size on UAtlantaTooltipUtilities");

// Class DeadByDaylight.PS5ProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UPS5ProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PS5ProfileDAL">();
	}
	static class UPS5ProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPS5ProfileDAL>();
	}
};
static_assert(alignof(UPS5ProfileDAL) == 0x000008, "Wrong alignment on UPS5ProfileDAL");
static_assert(sizeof(UPS5ProfileDAL) == 0x000088, "Wrong size on UPS5ProfileDAL");

// Class DeadByDaylight.UMGAlertsWidget
// 0x00C0 (0x03F8 - 0x0338)
class UUMGAlertsWidget final : public UMobileBaseUserWidget
{
public:
	TSoftClassPtr<class UClass>                   AtlantaScoreAlertComponentClass;                   // 0x0338(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   AtlantaStatusEffectAlertComponentClass;            // 0x0368(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPanelAlerts;                                 // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IdleTime;                                          // 0x03A0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A4[0x44];                                     // 0x03A4(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 _scoreAlertClass;                                  // 0x03E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _statusEffectAlertClass;                           // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAlertsWidget">();
	}
	static class UUMGAlertsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAlertsWidget>();
	}
};
static_assert(alignof(UUMGAlertsWidget) == 0x000008, "Wrong alignment on UUMGAlertsWidget");
static_assert(sizeof(UUMGAlertsWidget) == 0x0003F8, "Wrong size on UUMGAlertsWidget");
static_assert(offsetof(UUMGAlertsWidget, AtlantaScoreAlertComponentClass) == 0x000338, "Member 'UUMGAlertsWidget::AtlantaScoreAlertComponentClass' has a wrong offset!");
static_assert(offsetof(UUMGAlertsWidget, AtlantaStatusEffectAlertComponentClass) == 0x000368, "Member 'UUMGAlertsWidget::AtlantaStatusEffectAlertComponentClass' has a wrong offset!");
static_assert(offsetof(UUMGAlertsWidget, CanvasPanelAlerts) == 0x000398, "Member 'UUMGAlertsWidget::CanvasPanelAlerts' has a wrong offset!");
static_assert(offsetof(UUMGAlertsWidget, IdleTime) == 0x0003A0, "Member 'UUMGAlertsWidget::IdleTime' has a wrong offset!");
static_assert(offsetof(UUMGAlertsWidget, _scoreAlertClass) == 0x0003E8, "Member 'UUMGAlertsWidget::_scoreAlertClass' has a wrong offset!");
static_assert(offsetof(UUMGAlertsWidget, _statusEffectAlertClass) == 0x0003F0, "Member 'UUMGAlertsWidget::_statusEffectAlertClass' has a wrong offset!");

// Class DeadByDaylight.AtlantaTutorialObjectiveManager
// 0x0020 (0x0050 - 0x0030)
class UAtlantaTutorialObjectiveManager final : public UObject
{
public:
	TArray<class UAtlantaObjectiveWidget*>        _objectivesList;                                   // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UVerticalBox*                           _objectivesContainer;                              // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaTutorialObjectiveManager">();
	}
	static class UAtlantaTutorialObjectiveManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaTutorialObjectiveManager>();
	}
};
static_assert(alignof(UAtlantaTutorialObjectiveManager) == 0x000008, "Wrong alignment on UAtlantaTutorialObjectiveManager");
static_assert(sizeof(UAtlantaTutorialObjectiveManager) == 0x000050, "Wrong size on UAtlantaTutorialObjectiveManager");
static_assert(offsetof(UAtlantaTutorialObjectiveManager, _objectivesList) == 0x000030, "Member 'UAtlantaTutorialObjectiveManager::_objectivesList' has a wrong offset!");
static_assert(offsetof(UAtlantaTutorialObjectiveManager, _objectivesContainer) == 0x000040, "Member 'UAtlantaTutorialObjectiveManager::_objectivesContainer' has a wrong offset!");

// Class DeadByDaylight.AtlantaTutorialPlayerHudController
// 0x0048 (0x0078 - 0x0030)
class UAtlantaTutorialPlayerHudController final : public UObject
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideHudComponent(EHudComponent hudComponentToHide);
	void SetVirtualJoystickInputEnabled(bool enable);
	void ShowHudComponent(EHudComponent hudComponentToShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaTutorialPlayerHudController">();
	}
	static class UAtlantaTutorialPlayerHudController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaTutorialPlayerHudController>();
	}
};
static_assert(alignof(UAtlantaTutorialPlayerHudController) == 0x000008, "Wrong alignment on UAtlantaTutorialPlayerHudController");
static_assert(sizeof(UAtlantaTutorialPlayerHudController) == 0x000078, "Wrong size on UAtlantaTutorialPlayerHudController");

// Class DeadByDaylight.AtlantaTutorialStateMachine
// 0x0000 (0x0130 - 0x0130)
class UAtlantaTutorialStateMachine final : public UStateMachine
{
public:
	void OnBlockingNotificationDismissed(class FName blockingNotificationID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaTutorialStateMachine">();
	}
	static class UAtlantaTutorialStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaTutorialStateMachine>();
	}
};
static_assert(alignof(UAtlantaTutorialStateMachine) == 0x000010, "Wrong alignment on UAtlantaTutorialStateMachine");
static_assert(sizeof(UAtlantaTutorialStateMachine) == 0x000130, "Wrong size on UAtlantaTutorialStateMachine");

// Class DeadByDaylight.AtlantaUtilities
// 0x0000 (0x0030 - 0x0030)
class UAtlantaUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class FText GetAlantaInteractionDescriptionText(class UInteractionDefinition* interaction);
	static class UInteractionDefinition* GetAvailableInteractionOfType(class ADBDPlayer* player, EInputInteractionType interactionInputType);
	static struct FColor GetBackgroundColorByRarity(const EItemRarity rarity);
	static float GetControlsTunable(class FName tunableValueName);
	static float GetControlsTunableByRole(EPlayerRole playerRole, class FName tunableValueName);
	static struct FSlateColor GetCurrencyColor(ECurrencyType currencyType);
	static class FString GetCurrencyUITexturePath(ECurrencyType currencyType);
	static class UInteractionDefinition* GetCurrentInteraction(class ADBDPlayer* player);
	static class UInteractionDefinition* GetCurrentInteractionOfType(class ADBDPlayer* player, EInputInteractionType interactionInputType);
	static class UInteractionDefinition* GetCurrentOrAvailableInteractionOfType(class ADBDPlayer* player, EInputInteractionType interactionInputType);
	static class FText GetDifficultyLevelText(const EAIDifficultyLevel difficultyLevel);
	static struct FColor GetEmblemColorByQuality(const EEmblemQuality emblemQuality);
	static class FText GetEmblemQualityText(const EEmblemQuality emblemQuality);
	static class UTexture2D* GetIconImageByPath(const class FString& iconPath);
	static class FText GetItemAvailabilityText(const EItemAvailability availability);
	static class FText GetItemRarityText(const EItemRarity rarity);
	static class UPaperSprite* GetMapSpriteFromPath(const class FString& mapSpritePath);
	static class FText GetOfferingCategoryText(const EOfferingCategory offeringCategory);
	static struct FColor GetPaintColorByRarity(const EItemRarity rarity);
	static class FText GetPlayerRoleText(const EPlayerRole playerRole);
	static class FText GetPlayerRoleTextUppercase(const EPlayerRole playerRole);
	static class UPaperSprite* GetSpriteFromFullPath(const class FString& fullSpritePath);
	static class UPaperSprite* GetSpriteFromPath(const class FString& fullDbPathToImage, const class FString& constantDbPathToImageFolder, const class FString& constantPathToSpriteFolder);
	static class FString GetStoreVersion();
	static bool IsInAtlantaTutorialLevel();
	static bool IsPlayerInteractingWithActor(class ADBDPlayer* player, const class AActor* actor);
	static bool IsTutorialEditorDebuggingEnabled();
	static class UTexture2D* LoadTextureByAsset(const class FString& path);
	static struct FSlateBrush MakeBrushFromSprite(class UPaperSprite* sprite);
	static struct FSlateBrush MakeBrushFromTexture(class UTexture2D* texture);
	static class FString SecondsToStringWithoutDecimals(const int32 seconds);
	static void SetButtonStyle(class UButton* button, const struct FSlateBrush& brush);
	static void SetImageBrush(class UImage* image, class UTexture2D* asset, bool bMatchSize);
	static void SetImageBrushFromPath(class UImage* image, const class FString& path, bool bMatchSize);
	static void SetImageBrushFromSpritePath(class UImage* image, const class FString& path);
	static bool SetImageSlateBrush(class UImage* image, const struct FSlateBrush& brush, bool bMatchSize);
	static bool ShouldSupportMultipleActiveActivatablePerks();
	static bool ShouldUseAtlantaBackendBloodMarketData();
	static bool ShouldUseAtlantaBloodweb();
	static bool ShouldUseAtlantaBundleFilterRules();
	static bool ShouldUseAtlantaCatalog();
	static bool ShouldUseAtlantaCDNBucketChangelist();
	static bool ShouldUseAtlantaCDNPatching();
	static bool ShouldUseAtlantaCharacterProgression();
	static bool ShouldUseAtlantaContent();
	static bool ShouldUseAtlantaCurrencies();
	static bool ShouldUseAtlantaCustomizedHudSettings();
	static bool ShouldUseAtlantaDailyRewards();
	static bool ShouldUseAtlantaDreamworldFX();
	static bool ShouldUseAtlantaEntity();
	static bool ShouldUseAtlantaFearMarket();
	static bool ShouldUseAtlantaFixedMaps();
	static bool ShouldUseAtlantaFreeTickets();
	static bool ShouldUseAtlantaFriendList();
	static bool ShouldUseAtlantaGameplayValues();
	static bool ShouldUseAtlantaHudAttackJoystick();
	static bool ShouldUseAtlantaHudEditor();
	static bool ShouldUseAtlantaItemAvailability();
	static bool ShouldUseAtlantaKrakenContentVersion();
	static bool ShouldUseAtlantaLighting();
	static bool ShouldUseAtlantaMatchmaking();
	static bool ShouldUseAtlantaOutlines();
	static bool ShouldUseAtlantaPurchasableOperations();
	static bool ShouldUseAtlantaQualitySettings();
	static bool ShouldUseAtlantaRank();
	static bool ShouldUseAtlantaRituals();
	static bool ShouldUseAtlantaStreamVideo();
	static bool ShouldUseAtlantaUI();
	static bool ShouldUseOfflineMatchHistory();
	static bool ShouldUseQuickRoleSwitch();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaUtilities">();
	}
	static class UAtlantaUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaUtilities>();
	}
};
static_assert(alignof(UAtlantaUtilities) == 0x000008, "Wrong alignment on UAtlantaUtilities");
static_assert(sizeof(UAtlantaUtilities) == 0x000030, "Wrong size on UAtlantaUtilities");

// Class DeadByDaylight.UMGStalkingStatusEffectUI
// 0x0050 (0x0388 - 0x0338)
class UUMGStalkingStatusEffectUI final : public UMobileBaseUserWidget
{
public:
	class UCanvasPanel*                           StalkedCanvas;                                     // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 StalkingFillFull;                                  // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 StalkingFillLines;                                 // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 StalkingRedBackground;                             // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StalkingStartAnimationName;                        // 0x0358(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               _stalkingFillFullMI;                               // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _stalkingFillLinesMI;                              // 0x0370(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x10];                                     // 0x0378(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGStalkingStatusEffectUI">();
	}
	static class UUMGStalkingStatusEffectUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGStalkingStatusEffectUI>();
	}
};
static_assert(alignof(UUMGStalkingStatusEffectUI) == 0x000008, "Wrong alignment on UUMGStalkingStatusEffectUI");
static_assert(sizeof(UUMGStalkingStatusEffectUI) == 0x000388, "Wrong size on UUMGStalkingStatusEffectUI");
static_assert(offsetof(UUMGStalkingStatusEffectUI, StalkedCanvas) == 0x000338, "Member 'UUMGStalkingStatusEffectUI::StalkedCanvas' has a wrong offset!");
static_assert(offsetof(UUMGStalkingStatusEffectUI, StalkingFillFull) == 0x000340, "Member 'UUMGStalkingStatusEffectUI::StalkingFillFull' has a wrong offset!");
static_assert(offsetof(UUMGStalkingStatusEffectUI, StalkingFillLines) == 0x000348, "Member 'UUMGStalkingStatusEffectUI::StalkingFillLines' has a wrong offset!");
static_assert(offsetof(UUMGStalkingStatusEffectUI, StalkingRedBackground) == 0x000350, "Member 'UUMGStalkingStatusEffectUI::StalkingRedBackground' has a wrong offset!");
static_assert(offsetof(UUMGStalkingStatusEffectUI, StalkingStartAnimationName) == 0x000358, "Member 'UUMGStalkingStatusEffectUI::StalkingStartAnimationName' has a wrong offset!");
static_assert(offsetof(UUMGStalkingStatusEffectUI, _stalkingFillFullMI) == 0x000368, "Member 'UUMGStalkingStatusEffectUI::_stalkingFillFullMI' has a wrong offset!");
static_assert(offsetof(UUMGStalkingStatusEffectUI, _stalkingFillLinesMI) == 0x000370, "Member 'UUMGStalkingStatusEffectUI::_stalkingFillLinesMI' has a wrong offset!");

// Class DeadByDaylight.EvilWithinComponent
// 0x0080 (0x0138 - 0x00B8)
class UEvilWithinComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(int32 previousTier, int32 currentTier, bool isFirstTime)> OnTierChange; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         _currentTier;                                      // 0x00C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lastTierTimeStart;                                // 0x00CC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x58];                                      // 0x00D0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         _allowedSurvivorInteractionsForKill;               // 0x0128(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void Authority_NotifyKill(class ADBDPlayer* killedPlayer);
	void Authority_OnPlayerDisconnect(class ADBDPlayer* player);
	void Authority_OnStalkPointsAdded(float stalkPoints);
	void OnLevelReadyToPlay();
	void OnRep_CurrentTier(int32 previousTier);

	bool CanBeStandingKilled(const class ADBDPlayer* player) const;
	bool CanStandKill(const class ADBDPlayer* player) const;
	int32 GetCurrentTier() const;
	int32 GetMaxTier() const;
	float GetPercentStalkingPointsInCurrentTier() const;
	float GetRequirementForTier(int32 tier) const;
	bool IsAtLastTier() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EvilWithinComponent">();
	}
	static class UEvilWithinComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEvilWithinComponent>();
	}
};
static_assert(alignof(UEvilWithinComponent) == 0x000008, "Wrong alignment on UEvilWithinComponent");
static_assert(sizeof(UEvilWithinComponent) == 0x000138, "Wrong size on UEvilWithinComponent");
static_assert(offsetof(UEvilWithinComponent, OnTierChange) == 0x0000B8, "Member 'UEvilWithinComponent::OnTierChange' has a wrong offset!");
static_assert(offsetof(UEvilWithinComponent, _currentTier) == 0x0000C8, "Member 'UEvilWithinComponent::_currentTier' has a wrong offset!");
static_assert(offsetof(UEvilWithinComponent, _lastTierTimeStart) == 0x0000CC, "Member 'UEvilWithinComponent::_lastTierTimeStart' has a wrong offset!");
static_assert(offsetof(UEvilWithinComponent, _allowedSurvivorInteractionsForKill) == 0x000128, "Member 'UEvilWithinComponent::_allowedSurvivorInteractionsForKill' has a wrong offset!");

// Class DeadByDaylight.AtlCookedMaps
// 0x0010 (0x0048 - 0x0038)
class UAtlCookedMaps final : public UPrimaryDataAsset
{
public:
	TArray<struct FAtlCookedMapDescription>       Descriptions;                                      // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlCookedMaps">();
	}
	static class UAtlCookedMaps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlCookedMaps>();
	}
};
static_assert(alignof(UAtlCookedMaps) == 0x000008, "Wrong alignment on UAtlCookedMaps");
static_assert(sizeof(UAtlCookedMaps) == 0x000048, "Wrong size on UAtlCookedMaps");
static_assert(offsetof(UAtlCookedMaps, Descriptions) == 0x000038, "Member 'UAtlCookedMaps::Descriptions' has a wrong offset!");

// Class DeadByDaylight.Tile
// 0x0118 (0x0348 - 0x0230)
class ATile : public AActor
{
public:
	bool                                          RerunConstructionScript;                           // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumSpacing;                                    // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumSpacing;                                    // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DiagonalSpacing;                                   // 0x023C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TypeSpacing;                                       // 0x023D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23E[0x2];                                      // 0x023E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaximumCount;                                      // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Dimension;                                         // 0x0244(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EscapeStrategyType>                    AvailableEscapeTypes;                              // 0x0250(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ETileType                                     Type;                                              // 0x0260(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDensity                                      Density;                                           // 0x0261(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPathType                                     Path;                                              // 0x0262(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_263[0x1];                                      // 0x0263(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Number;                                            // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlaceHolder;                                       // 0x0268(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnPriorityTier;                                 // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Coord;                                             // 0x0274(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuadrantSpawnType                            QuadrantSpawnType;                                 // 0x027C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBasementType                                 BasementType;                                      // 0x027D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27E[0x2];                                      // 0x027E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTileSpawnPoint*>                SpawnPointsCache;                                  // 0x0280(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UObjectRandomizer*>              ObjectRandomizersCache;                            // 0x0290(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UActorSpawner*>                  ActorSpawnersCache;                                // 0x02A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UActorVariationSpawner*>         ActorVariationSpawnersCache;                       // 0x02B0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x7C];                                     // 0x02C0(0x007C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomStream                          SharedTileRandomizer;                              // 0x033C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          _initialized;                                      // 0x0344(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_345[0x3];                                      // 0x0345(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitOnSpawned();
	void OnAllTileSpawned();
	void OnRep_Initialized(bool oldValue);
	void OnSetSpawnObject(class UTileSpawnPoint* tileSpawnPoint, class AActor* spawnedObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tile">();
	}
	static class ATile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATile>();
	}
};
static_assert(alignof(ATile) == 0x000008, "Wrong alignment on ATile");
static_assert(sizeof(ATile) == 0x000348, "Wrong size on ATile");
static_assert(offsetof(ATile, RerunConstructionScript) == 0x000230, "Member 'ATile::RerunConstructionScript' has a wrong offset!");
static_assert(offsetof(ATile, MinimumSpacing) == 0x000234, "Member 'ATile::MinimumSpacing' has a wrong offset!");
static_assert(offsetof(ATile, MaximumSpacing) == 0x000238, "Member 'ATile::MaximumSpacing' has a wrong offset!");
static_assert(offsetof(ATile, DiagonalSpacing) == 0x00023C, "Member 'ATile::DiagonalSpacing' has a wrong offset!");
static_assert(offsetof(ATile, TypeSpacing) == 0x00023D, "Member 'ATile::TypeSpacing' has a wrong offset!");
static_assert(offsetof(ATile, MaximumCount) == 0x000240, "Member 'ATile::MaximumCount' has a wrong offset!");
static_assert(offsetof(ATile, Dimension) == 0x000244, "Member 'ATile::Dimension' has a wrong offset!");
static_assert(offsetof(ATile, AvailableEscapeTypes) == 0x000250, "Member 'ATile::AvailableEscapeTypes' has a wrong offset!");
static_assert(offsetof(ATile, Type) == 0x000260, "Member 'ATile::Type' has a wrong offset!");
static_assert(offsetof(ATile, Density) == 0x000261, "Member 'ATile::Density' has a wrong offset!");
static_assert(offsetof(ATile, Path) == 0x000262, "Member 'ATile::Path' has a wrong offset!");
static_assert(offsetof(ATile, Number) == 0x000264, "Member 'ATile::Number' has a wrong offset!");
static_assert(offsetof(ATile, PlaceHolder) == 0x000268, "Member 'ATile::PlaceHolder' has a wrong offset!");
static_assert(offsetof(ATile, SpawnPriorityTier) == 0x00026C, "Member 'ATile::SpawnPriorityTier' has a wrong offset!");
static_assert(offsetof(ATile, Weight) == 0x000270, "Member 'ATile::Weight' has a wrong offset!");
static_assert(offsetof(ATile, Coord) == 0x000274, "Member 'ATile::Coord' has a wrong offset!");
static_assert(offsetof(ATile, QuadrantSpawnType) == 0x00027C, "Member 'ATile::QuadrantSpawnType' has a wrong offset!");
static_assert(offsetof(ATile, BasementType) == 0x00027D, "Member 'ATile::BasementType' has a wrong offset!");
static_assert(offsetof(ATile, SpawnPointsCache) == 0x000280, "Member 'ATile::SpawnPointsCache' has a wrong offset!");
static_assert(offsetof(ATile, ObjectRandomizersCache) == 0x000290, "Member 'ATile::ObjectRandomizersCache' has a wrong offset!");
static_assert(offsetof(ATile, ActorSpawnersCache) == 0x0002A0, "Member 'ATile::ActorSpawnersCache' has a wrong offset!");
static_assert(offsetof(ATile, ActorVariationSpawnersCache) == 0x0002B0, "Member 'ATile::ActorVariationSpawnersCache' has a wrong offset!");
static_assert(offsetof(ATile, SharedTileRandomizer) == 0x00033C, "Member 'ATile::SharedTileRandomizer' has a wrong offset!");
static_assert(offsetof(ATile, _initialized) == 0x000344, "Member 'ATile::_initialized' has a wrong offset!");

// Class DeadByDaylight.EscapeTile
// 0x0008 (0x0350 - 0x0348)
class AEscapeTile final : public ATile
{
public:
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeTile">();
	}
	static class AEscapeTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEscapeTile>();
	}
};
static_assert(alignof(AEscapeTile) == 0x000008, "Wrong alignment on AEscapeTile");
static_assert(sizeof(AEscapeTile) == 0x000350, "Wrong size on AEscapeTile");

// Class DeadByDaylight.AudioFXComponent
// 0x0060 (0x0118 - 0x00B8)
class UAudioFXComponent final : public UActorComponent
{
public:
	class UPrimitiveComponent*                    _audioAmbientDetector;                             // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x58];                                      // 0x00C0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_Deafen(float duration);
	void Multicast_Deafen(float duration);
	void OnDeafenCompleted();
	void OnLocallyObservedChanged(bool locallyObserved);
	void SetAudioAmbientDetector(class UPrimitiveComponent* audioAmbientDetector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioFXComponent">();
	}
	static class UAudioFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioFXComponent>();
	}
};
static_assert(alignof(UAudioFXComponent) == 0x000008, "Wrong alignment on UAudioFXComponent");
static_assert(sizeof(UAudioFXComponent) == 0x000118, "Wrong size on UAudioFXComponent");
static_assert(offsetof(UAudioFXComponent, _audioAmbientDetector) == 0x0000B8, "Member 'UAudioFXComponent::_audioAmbientDetector' has a wrong offset!");

// Class DeadByDaylight.AudioMultipleEmitterActor
// 0x0018 (0x0248 - 0x0230)
class AAudioMultipleEmitterActor final : public AActor
{
public:
	class UAudioMultipleEmitterComponent*         AudioMultiEmitter;                                 // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         EmitterActors;                                     // 0x0238(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioMultipleEmitterActor">();
	}
	static class AAudioMultipleEmitterActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAudioMultipleEmitterActor>();
	}
};
static_assert(alignof(AAudioMultipleEmitterActor) == 0x000008, "Wrong alignment on AAudioMultipleEmitterActor");
static_assert(sizeof(AAudioMultipleEmitterActor) == 0x000248, "Wrong size on AAudioMultipleEmitterActor");
static_assert(offsetof(AAudioMultipleEmitterActor, AudioMultiEmitter) == 0x000230, "Member 'AAudioMultipleEmitterActor::AudioMultiEmitter' has a wrong offset!");
static_assert(offsetof(AAudioMultipleEmitterActor, EmitterActors) == 0x000238, "Member 'AAudioMultipleEmitterActor::EmitterActors' has a wrong offset!");

// Class DeadByDaylight.ExposerCirclingComponent
// 0x0050 (0x0270 - 0x0220)
class UExposerCirclingComponent final : public USceneComponent
{
public:
	bool                                          DirectionFollows;                                  // 0x0218(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x3];                                      // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinHeight;                                         // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxHeight;                                         // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRadius;                                         // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRadius;                                         // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CirclingSpeed;                                     // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceBetweenPoints;                             // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BezierModifier;                                    // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Samples;                                           // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x34];                                     // 0x023C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Reset();
	void SetIsCircling(bool circling);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExposerCirclingComponent">();
	}
	static class UExposerCirclingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExposerCirclingComponent>();
	}
};
static_assert(alignof(UExposerCirclingComponent) == 0x000010, "Wrong alignment on UExposerCirclingComponent");
static_assert(sizeof(UExposerCirclingComponent) == 0x000270, "Wrong size on UExposerCirclingComponent");
static_assert(offsetof(UExposerCirclingComponent, DirectionFollows) == 0x000218, "Member 'UExposerCirclingComponent::DirectionFollows' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, MinHeight) == 0x00021C, "Member 'UExposerCirclingComponent::MinHeight' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, MaxHeight) == 0x000220, "Member 'UExposerCirclingComponent::MaxHeight' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, MinRadius) == 0x000224, "Member 'UExposerCirclingComponent::MinRadius' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, MaxRadius) == 0x000228, "Member 'UExposerCirclingComponent::MaxRadius' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, CirclingSpeed) == 0x00022C, "Member 'UExposerCirclingComponent::CirclingSpeed' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, DistanceBetweenPoints) == 0x000230, "Member 'UExposerCirclingComponent::DistanceBetweenPoints' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, BezierModifier) == 0x000234, "Member 'UExposerCirclingComponent::BezierModifier' has a wrong offset!");
static_assert(offsetof(UExposerCirclingComponent, Samples) == 0x000238, "Member 'UExposerCirclingComponent::Samples' has a wrong offset!");

// Class DeadByDaylight.AudioMultipleEmitterComponent
// 0x0010 (0x0490 - 0x0480)
class UAudioMultipleEmitterComponent final : public UAkComponent
{
public:
	TArray<class UActorComponent*>                EmitterActorsComponents;                           // 0x0478(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AudioMultipleEmitterComponent">();
	}
	static class UAudioMultipleEmitterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAudioMultipleEmitterComponent>();
	}
};
static_assert(alignof(UAudioMultipleEmitterComponent) == 0x000010, "Wrong alignment on UAudioMultipleEmitterComponent");
static_assert(sizeof(UAudioMultipleEmitterComponent) == 0x000490, "Wrong size on UAudioMultipleEmitterComponent");
static_assert(offsetof(UAudioMultipleEmitterComponent, EmitterActorsComponents) == 0x000478, "Member 'UAudioMultipleEmitterComponent::EmitterActorsComponents' has a wrong offset!");

// Class DeadByDaylight.AuthoritativeMovementComponent
// 0x0060 (0x0118 - 0x00B8)
class UAuthoritativeMovementComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACharacter*>                     _charactersToPush;                                 // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ACharacter*>                     _stopIgnoreCharacterOnEndOverlap;                  // 0x00D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      _pawnDetector;                                     // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACharacter*>                     _authoritativeIgnoreOverlapCharacters;             // 0x00F8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class ACharacter*>                     _previousAuthoritativeIgnoreOverlapCharacters;     // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void OnPawnDetectorOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnPawnDetectorOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnRep_AuthoritativeIgnoreOverlapCharacters();
	void SetPawnDetector(class UCapsuleComponent* pawnDetector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthoritativeMovementComponent">();
	}
	static class UAuthoritativeMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthoritativeMovementComponent>();
	}
};
static_assert(alignof(UAuthoritativeMovementComponent) == 0x000008, "Wrong alignment on UAuthoritativeMovementComponent");
static_assert(sizeof(UAuthoritativeMovementComponent) == 0x000118, "Wrong size on UAuthoritativeMovementComponent");
static_assert(offsetof(UAuthoritativeMovementComponent, _charactersToPush) == 0x0000C8, "Member 'UAuthoritativeMovementComponent::_charactersToPush' has a wrong offset!");
static_assert(offsetof(UAuthoritativeMovementComponent, _stopIgnoreCharacterOnEndOverlap) == 0x0000D8, "Member 'UAuthoritativeMovementComponent::_stopIgnoreCharacterOnEndOverlap' has a wrong offset!");
static_assert(offsetof(UAuthoritativeMovementComponent, _pawnDetector) == 0x0000F0, "Member 'UAuthoritativeMovementComponent::_pawnDetector' has a wrong offset!");
static_assert(offsetof(UAuthoritativeMovementComponent, _authoritativeIgnoreOverlapCharacters) == 0x0000F8, "Member 'UAuthoritativeMovementComponent::_authoritativeIgnoreOverlapCharacters' has a wrong offset!");
static_assert(offsetof(UAuthoritativeMovementComponent, _previousAuthoritativeIgnoreOverlapCharacters) == 0x000108, "Member 'UAuthoritativeMovementComponent::_previousAuthoritativeIgnoreOverlapCharacters' has a wrong offset!");

// Class DeadByDaylight.AutomaticLeanComponent
// 0x02B8 (0x0370 - 0x00B8)
class UAutomaticLeanComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(ELeanState leanState)> OnLeanStateChanged;                         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(ELeanState leanState)> OnPotentialLeanStateChanged;                // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool canInitiate)> OnCanInitiateLeanChanged;                       // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FSocketOrBoneCache                     _cameraIdleLocation;                               // 0x00E8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FSocketOrBoneCache                     _cameraLeftLeanLocation;                           // 0x0148(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FSocketOrBoneCache                     _cameraRightLeanLocation;                          // 0x01A8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FSocketOrBoneCache                     _cameraCrouchLocation;                             // 0x0208(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FSocketOrBoneCache                     _cameraCrouchLeftLeanLocation;                     // 0x0268(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	struct FSocketOrBoneCache                     _cameraCrouchRightLeanLocation;                    // 0x02C8(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPrivate)
	float                                         _middleSphereTraceLength;                          // 0x0328(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sideSphereTraceLength;                            // 0x032C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sphereTraceRadius;                                // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _standingTraceHeightOffset;                        // 0x0334(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _crouchingTraceHeightOffset;                       // 0x0338(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sideTraceOffset;                                  // 0x033C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxCameraDistance;                                // 0x0340(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxCameraAngle;                                   // 0x0344(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _debugMode;                                        // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELeanState                                    _leanState;                                        // 0x0349(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34A[0x26];                                     // 0x034A(0x0026)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Local_Lean();
	void Local_Unlean();
	void OnRep_LeanState();
	void Server_SetLeanState(ELeanState leanState);

	bool CanInitiateLean() const;
	float GetAvailableDistanceInFrontOfCamera() const;
	ELeanState GetLeanState() const;
	ELeanState GetPotentialLeanState() const;
	bool IsLeaning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutomaticLeanComponent">();
	}
	static class UAutomaticLeanComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutomaticLeanComponent>();
	}
};
static_assert(alignof(UAutomaticLeanComponent) == 0x000008, "Wrong alignment on UAutomaticLeanComponent");
static_assert(sizeof(UAutomaticLeanComponent) == 0x000370, "Wrong size on UAutomaticLeanComponent");
static_assert(offsetof(UAutomaticLeanComponent, OnLeanStateChanged) == 0x0000B8, "Member 'UAutomaticLeanComponent::OnLeanStateChanged' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, OnPotentialLeanStateChanged) == 0x0000C8, "Member 'UAutomaticLeanComponent::OnPotentialLeanStateChanged' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, OnCanInitiateLeanChanged) == 0x0000D8, "Member 'UAutomaticLeanComponent::OnCanInitiateLeanChanged' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraIdleLocation) == 0x0000E8, "Member 'UAutomaticLeanComponent::_cameraIdleLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraLeftLeanLocation) == 0x000148, "Member 'UAutomaticLeanComponent::_cameraLeftLeanLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraRightLeanLocation) == 0x0001A8, "Member 'UAutomaticLeanComponent::_cameraRightLeanLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraCrouchLocation) == 0x000208, "Member 'UAutomaticLeanComponent::_cameraCrouchLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraCrouchLeftLeanLocation) == 0x000268, "Member 'UAutomaticLeanComponent::_cameraCrouchLeftLeanLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _cameraCrouchRightLeanLocation) == 0x0002C8, "Member 'UAutomaticLeanComponent::_cameraCrouchRightLeanLocation' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _middleSphereTraceLength) == 0x000328, "Member 'UAutomaticLeanComponent::_middleSphereTraceLength' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _sideSphereTraceLength) == 0x00032C, "Member 'UAutomaticLeanComponent::_sideSphereTraceLength' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _sphereTraceRadius) == 0x000330, "Member 'UAutomaticLeanComponent::_sphereTraceRadius' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _standingTraceHeightOffset) == 0x000334, "Member 'UAutomaticLeanComponent::_standingTraceHeightOffset' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _crouchingTraceHeightOffset) == 0x000338, "Member 'UAutomaticLeanComponent::_crouchingTraceHeightOffset' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _sideTraceOffset) == 0x00033C, "Member 'UAutomaticLeanComponent::_sideTraceOffset' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _maxCameraDistance) == 0x000340, "Member 'UAutomaticLeanComponent::_maxCameraDistance' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _maxCameraAngle) == 0x000344, "Member 'UAutomaticLeanComponent::_maxCameraAngle' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _debugMode) == 0x000348, "Member 'UAutomaticLeanComponent::_debugMode' has a wrong offset!");
static_assert(offsetof(UAutomaticLeanComponent, _leanState) == 0x000349, "Member 'UAutomaticLeanComponent::_leanState' has a wrong offset!");

// Class DeadByDaylight.AutoQualityAdjuster
// 0x0028 (0x0258 - 0x0230)
class AAutoQualityAdjuster final : public AActor
{
public:
	float                                         TargetResolutionScale;                             // 0x0230(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumMS;                                         // 0x0234(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaximumMS;                                         // 0x0238(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScaleIncreaseRate;                                 // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScaleDecreaseRate;                                 // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumAllowableScale;                             // 0x0244(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoQualityAdjuster">();
	}
	static class AAutoQualityAdjuster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAutoQualityAdjuster>();
	}
};
static_assert(alignof(AAutoQualityAdjuster) == 0x000008, "Wrong alignment on AAutoQualityAdjuster");
static_assert(sizeof(AAutoQualityAdjuster) == 0x000258, "Wrong size on AAutoQualityAdjuster");
static_assert(offsetof(AAutoQualityAdjuster, TargetResolutionScale) == 0x000230, "Member 'AAutoQualityAdjuster::TargetResolutionScale' has a wrong offset!");
static_assert(offsetof(AAutoQualityAdjuster, MinimumMS) == 0x000234, "Member 'AAutoQualityAdjuster::MinimumMS' has a wrong offset!");
static_assert(offsetof(AAutoQualityAdjuster, MaximumMS) == 0x000238, "Member 'AAutoQualityAdjuster::MaximumMS' has a wrong offset!");
static_assert(offsetof(AAutoQualityAdjuster, ScaleIncreaseRate) == 0x00023C, "Member 'AAutoQualityAdjuster::ScaleIncreaseRate' has a wrong offset!");
static_assert(offsetof(AAutoQualityAdjuster, ScaleDecreaseRate) == 0x000240, "Member 'AAutoQualityAdjuster::ScaleDecreaseRate' has a wrong offset!");
static_assert(offsetof(AAutoQualityAdjuster, MinimumAllowableScale) == 0x000244, "Member 'AAutoQualityAdjuster::MinimumAllowableScale' has a wrong offset!");

// Class DeadByDaylight.RestrictedPlacementAreaStrategy
// 0x0070 (0x00A0 - 0x0030)
class URestrictedPlacementAreaStrategy : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   RestrictedRadius;                                  // 0x0040(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x4];                                       // 0x0068(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _useTunableForHeight;                              // 0x006C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxHeightRestriction;                             // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxHeightRestrictionTunable;                      // 0x0078(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RestrictedPlacementAreaStrategy">();
	}
	static class URestrictedPlacementAreaStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URestrictedPlacementAreaStrategy>();
	}
};
static_assert(alignof(URestrictedPlacementAreaStrategy) == 0x000008, "Wrong alignment on URestrictedPlacementAreaStrategy");
static_assert(sizeof(URestrictedPlacementAreaStrategy) == 0x0000A0, "Wrong size on URestrictedPlacementAreaStrategy");
static_assert(offsetof(URestrictedPlacementAreaStrategy, RestrictedRadius) == 0x000040, "Member 'URestrictedPlacementAreaStrategy::RestrictedRadius' has a wrong offset!");
static_assert(offsetof(URestrictedPlacementAreaStrategy, _useTunableForHeight) == 0x00006C, "Member 'URestrictedPlacementAreaStrategy::_useTunableForHeight' has a wrong offset!");
static_assert(offsetof(URestrictedPlacementAreaStrategy, _maxHeightRestriction) == 0x000070, "Member 'URestrictedPlacementAreaStrategy::_maxHeightRestriction' has a wrong offset!");
static_assert(offsetof(URestrictedPlacementAreaStrategy, _maxHeightRestrictionTunable) == 0x000078, "Member 'URestrictedPlacementAreaStrategy::_maxHeightRestrictionTunable' has a wrong offset!");

// Class DeadByDaylight.ExitGateSwitchesRestrictedPlacementAreaStrategy
// 0x0000 (0x00A0 - 0x00A0)
class UExitGateSwitchesRestrictedPlacementAreaStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExitGateSwitchesRestrictedPlacementAreaStrategy">();
	}
	static class UExitGateSwitchesRestrictedPlacementAreaStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExitGateSwitchesRestrictedPlacementAreaStrategy>();
	}
};
static_assert(alignof(UExitGateSwitchesRestrictedPlacementAreaStrategy) == 0x000008, "Wrong alignment on UExitGateSwitchesRestrictedPlacementAreaStrategy");
static_assert(sizeof(UExitGateSwitchesRestrictedPlacementAreaStrategy) == 0x0000A0, "Wrong size on UExitGateSwitchesRestrictedPlacementAreaStrategy");

// Class DeadByDaylight.BackendCinematicContainer
// 0x00C0 (0x00F0 - 0x0030)
class UBackendCinematicContainer final : public UObject
{
public:
	uint8                                         Pad_30[0xC0];                                      // 0x0030(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BackendCinematicContainer">();
	}
	static class UBackendCinematicContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBackendCinematicContainer>();
	}
};
static_assert(alignof(UBackendCinematicContainer) == 0x000008, "Wrong alignment on UBackendCinematicContainer");
static_assert(sizeof(UBackendCinematicContainer) == 0x0000F0, "Wrong size on UBackendCinematicContainer");

// Class DeadByDaylight.BannerDataProcessor
// 0x0050 (0x0080 - 0x0030)
class UBannerDataProcessor final : public UObject
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BannerDataProcessor">();
	}
	static class UBannerDataProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBannerDataProcessor>();
	}
};
static_assert(alignof(UBannerDataProcessor) == 0x000008, "Wrong alignment on UBannerDataProcessor");
static_assert(sizeof(UBannerDataProcessor) == 0x000080, "Wrong size on UBannerDataProcessor");

// Class DeadByDaylight.BaseEscapeThroughHatch
// 0x0000 (0x0620 - 0x0620)
class UBaseEscapeThroughHatch : public UInteractionDefinition
{
public:
	class AHatch* GetHatch() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseEscapeThroughHatch">();
	}
	static class UBaseEscapeThroughHatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseEscapeThroughHatch>();
	}
};
static_assert(alignof(UBaseEscapeThroughHatch) == 0x000010, "Wrong alignment on UBaseEscapeThroughHatch");
static_assert(sizeof(UBaseEscapeThroughHatch) == 0x000620, "Wrong size on UBaseEscapeThroughHatch");

// Class DeadByDaylight.BaseHitValidationConfigurator
// 0x0008 (0x00C0 - 0x00B8)
class UBaseHitValidationConfigurator : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseHitValidationConfigurator">();
	}
	static class UBaseHitValidationConfigurator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseHitValidationConfigurator>();
	}
};
static_assert(alignof(UBaseHitValidationConfigurator) == 0x000008, "Wrong alignment on UBaseHitValidationConfigurator");
static_assert(sizeof(UBaseHitValidationConfigurator) == 0x0000C0, "Wrong size on UBaseHitValidationConfigurator");

// Class DeadByDaylight.UMGPartySlotsWidget
// 0x0100 (0x0438 - 0x0338)
class UUMGPartySlotsWidget final : public UMobileBaseUserWidget
{
public:
	class UPanelWidget*                           PartyPlayerSlotsContainer;                         // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUMGPartyPlayerSlotWidget*>      _partyPlayerSlots;                                 // 0x0340(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVerticalBox*                           PartyBotSlotsContainer;                            // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PartyBotSlotWidgetClass;                           // 0x0360(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxSlotCount;                                      // 0x0390(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            ConflictingCharacterColor;                         // 0x0398(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            NormalCharacterColor;                              // 0x03C0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x50];                                     // 0x03E8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleBotEditButtonClickEvent(const int32 index);
	void HandleInviteFriendButtonClickEvent();
	void HandleKickPlayerButtonClickEvent(const class FString& friendKrakenId);
	void RearrangePartySlots();
	void SetWidgetState(int32 index, EPartyPlayerSlotWidgetState state);
	void SwapWidgets(int32 first, int32 second);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPartySlotsWidget">();
	}
	static class UUMGPartySlotsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPartySlotsWidget>();
	}
};
static_assert(alignof(UUMGPartySlotsWidget) == 0x000008, "Wrong alignment on UUMGPartySlotsWidget");
static_assert(sizeof(UUMGPartySlotsWidget) == 0x000438, "Wrong size on UUMGPartySlotsWidget");
static_assert(offsetof(UUMGPartySlotsWidget, PartyPlayerSlotsContainer) == 0x000338, "Member 'UUMGPartySlotsWidget::PartyPlayerSlotsContainer' has a wrong offset!");
static_assert(offsetof(UUMGPartySlotsWidget, _partyPlayerSlots) == 0x000340, "Member 'UUMGPartySlotsWidget::_partyPlayerSlots' has a wrong offset!");
static_assert(offsetof(UUMGPartySlotsWidget, PartyBotSlotsContainer) == 0x000358, "Member 'UUMGPartySlotsWidget::PartyBotSlotsContainer' has a wrong offset!");
static_assert(offsetof(UUMGPartySlotsWidget, PartyBotSlotWidgetClass) == 0x000360, "Member 'UUMGPartySlotsWidget::PartyBotSlotWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGPartySlotsWidget, MaxSlotCount) == 0x000390, "Member 'UUMGPartySlotsWidget::MaxSlotCount' has a wrong offset!");
static_assert(offsetof(UUMGPartySlotsWidget, ConflictingCharacterColor) == 0x000398, "Member 'UUMGPartySlotsWidget::ConflictingCharacterColor' has a wrong offset!");
static_assert(offsetof(UUMGPartySlotsWidget, NormalCharacterColor) == 0x0003C0, "Member 'UUMGPartySlotsWidget::NormalCharacterColor' has a wrong offset!");

// Class DeadByDaylight.DreamSnareTrapPlacementValidationStrategy
// 0x0010 (0x00F0 - 0x00E0)
class UDreamSnareTrapPlacementValidationStrategy final : public UDefaultObjectPlacementValidationStrategy
{
public:
	float                                         NumberOfGroundTest;                                // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TrapRadius;                                        // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxElevationDifferentialOnTrapEdge;                // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamSnareTrapPlacementValidationStrategy">();
	}
	static class UDreamSnareTrapPlacementValidationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamSnareTrapPlacementValidationStrategy>();
	}
};
static_assert(alignof(UDreamSnareTrapPlacementValidationStrategy) == 0x000008, "Wrong alignment on UDreamSnareTrapPlacementValidationStrategy");
static_assert(sizeof(UDreamSnareTrapPlacementValidationStrategy) == 0x0000F0, "Wrong size on UDreamSnareTrapPlacementValidationStrategy");
static_assert(offsetof(UDreamSnareTrapPlacementValidationStrategy, NumberOfGroundTest) == 0x0000E0, "Member 'UDreamSnareTrapPlacementValidationStrategy::NumberOfGroundTest' has a wrong offset!");
static_assert(offsetof(UDreamSnareTrapPlacementValidationStrategy, TrapRadius) == 0x0000E4, "Member 'UDreamSnareTrapPlacementValidationStrategy::TrapRadius' has a wrong offset!");
static_assert(offsetof(UDreamSnareTrapPlacementValidationStrategy, MaxElevationDifferentialOnTrapEdge) == 0x0000E8, "Member 'UDreamSnareTrapPlacementValidationStrategy::MaxElevationDifferentialOnTrapEdge' has a wrong offset!");

// Class DeadByDaylight.PromoPackContentDataAsset
// 0x0050 (0x0088 - 0x0038)
class UPromoPackContentDataAsset final : public UPrimaryDataAsset
{
public:
	TMap<EPromoPackContentType, struct FPromoPackContentTypeData> Data;                              // 0x0038(0x0050)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PromoPackContentDataAsset">();
	}
	static class UPromoPackContentDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPromoPackContentDataAsset>();
	}
};
static_assert(alignof(UPromoPackContentDataAsset) == 0x000008, "Wrong alignment on UPromoPackContentDataAsset");
static_assert(sizeof(UPromoPackContentDataAsset) == 0x000088, "Wrong size on UPromoPackContentDataAsset");
static_assert(offsetof(UPromoPackContentDataAsset, Data) == 0x000038, "Member 'UPromoPackContentDataAsset::Data' has a wrong offset!");

// Class DeadByDaylight.BaseLockerItem
// 0x0018 (0x0248 - 0x0230)
class ABaseLockerItem : public AActor
{
public:
	class ALocker*                                _owningLocker;                                     // 0x0230(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x4];                                      // 0x0238(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _adjustedRelativePosition;                         // 0x023C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AdjustPositionOnLocker();
	void OnRep_OwningLocker();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseLockerItem">();
	}
	static class ABaseLockerItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseLockerItem>();
	}
};
static_assert(alignof(ABaseLockerItem) == 0x000008, "Wrong alignment on ABaseLockerItem");
static_assert(sizeof(ABaseLockerItem) == 0x000248, "Wrong size on ABaseLockerItem");
static_assert(offsetof(ABaseLockerItem, _owningLocker) == 0x000230, "Member 'ABaseLockerItem::_owningLocker' has a wrong offset!");
static_assert(offsetof(ABaseLockerItem, _adjustedRelativePosition) == 0x00023C, "Member 'ABaseLockerItem::_adjustedRelativePosition' has a wrong offset!");

// Class DeadByDaylight.UMGPlayersStatusWidget
// 0x0100 (0x0438 - 0x0338)
class UUMGPlayersStatusWidget final : public UMobileBaseUserWidget
{
public:
	TMap<EPlayerRole, struct FCustomizedHudPlayerWrapperIdMapContainer> CustomizedHudWrapperIdMap;   // 0x0338(0x0050)(Edit, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PlayerStatusIconClass;                             // 0x0388(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         playersContainer;                                  // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class UUMGPlayerStatusIcon*> playerIconsByName;                              // 0x03C0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UUMGPlayerStatusIcon*>           _playerIcons;                                      // 0x0410(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x18];                                     // 0x0420(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerStatusClicked(class UUMGPlayerStatusIcon* playerStatusIcon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPlayersStatusWidget">();
	}
	static class UUMGPlayersStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPlayersStatusWidget>();
	}
};
static_assert(alignof(UUMGPlayersStatusWidget) == 0x000008, "Wrong alignment on UUMGPlayersStatusWidget");
static_assert(sizeof(UUMGPlayersStatusWidget) == 0x000438, "Wrong size on UUMGPlayersStatusWidget");
static_assert(offsetof(UUMGPlayersStatusWidget, CustomizedHudWrapperIdMap) == 0x000338, "Member 'UUMGPlayersStatusWidget::CustomizedHudWrapperIdMap' has a wrong offset!");
static_assert(offsetof(UUMGPlayersStatusWidget, PlayerStatusIconClass) == 0x000388, "Member 'UUMGPlayersStatusWidget::PlayerStatusIconClass' has a wrong offset!");
static_assert(offsetof(UUMGPlayersStatusWidget, playersContainer) == 0x0003B8, "Member 'UUMGPlayersStatusWidget::playersContainer' has a wrong offset!");
static_assert(offsetof(UUMGPlayersStatusWidget, playerIconsByName) == 0x0003C0, "Member 'UUMGPlayersStatusWidget::playerIconsByName' has a wrong offset!");
static_assert(offsetof(UUMGPlayersStatusWidget, _playerIcons) == 0x000410, "Member 'UUMGPlayersStatusWidget::_playerIcons' has a wrong offset!");

// Class DeadByDaylight.BaseTrap
// 0x0008 (0x04B8 - 0x04B0)
class ABaseTrap : public ACollectable
{
public:
	bool                                          _isTrapSet;                                        // 0x04B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B1[0x7];                                      // 0x04B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIsTrapSet(const bool value);

	bool IsTrapSet() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseTrap">();
	}
	static class ABaseTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABaseTrap>();
	}
};
static_assert(alignof(ABaseTrap) == 0x000008, "Wrong alignment on ABaseTrap");
static_assert(sizeof(ABaseTrap) == 0x0004B8, "Wrong size on ABaseTrap");
static_assert(offsetof(ABaseTrap, _isTrapSet) == 0x0004B0, "Member 'ABaseTrap::_isTrapSet' has a wrong offset!");

// Class DeadByDaylight.BearTrapOutlineUpdateStrategy
// 0x0038 (0x00F8 - 0x00C0)
class UBearTrapOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           UnrevealedColor;                                   // 0x00C0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           RevealedColorToSurvivor;                           // 0x00D0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveLinearColor*                      KillerOutlineFadeCurve;                            // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMapActorComponent*                     _owningBearTrapMapActorComponent;                  // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetOwningBearTrapMapActorComponent(class UMapActorComponent* mapActorComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BearTrapOutlineUpdateStrategy">();
	}
	static class UBearTrapOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBearTrapOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UBearTrapOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UBearTrapOutlineUpdateStrategy");
static_assert(sizeof(UBearTrapOutlineUpdateStrategy) == 0x0000F8, "Wrong size on UBearTrapOutlineUpdateStrategy");
static_assert(offsetof(UBearTrapOutlineUpdateStrategy, UnrevealedColor) == 0x0000C0, "Member 'UBearTrapOutlineUpdateStrategy::UnrevealedColor' has a wrong offset!");
static_assert(offsetof(UBearTrapOutlineUpdateStrategy, RevealedColorToSurvivor) == 0x0000D0, "Member 'UBearTrapOutlineUpdateStrategy::RevealedColorToSurvivor' has a wrong offset!");
static_assert(offsetof(UBearTrapOutlineUpdateStrategy, KillerOutlineFadeCurve) == 0x0000E0, "Member 'UBearTrapOutlineUpdateStrategy::KillerOutlineFadeCurve' has a wrong offset!");
static_assert(offsetof(UBearTrapOutlineUpdateStrategy, _owningBearTrapMapActorComponent) == 0x0000F0, "Member 'UBearTrapOutlineUpdateStrategy::_owningBearTrapMapActorComponent' has a wrong offset!");

// Class DeadByDaylight.UMGBaseCurrencyStorefrontWidget
// 0x0010 (0x0348 - 0x0338)
class UUMGBaseCurrencyStorefrontWidget : public UUMGBaseStorefrontWidget
{
public:
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastOnAuricCellButtonClicked(int32 cellIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBaseCurrencyStorefrontWidget">();
	}
	static class UUMGBaseCurrencyStorefrontWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBaseCurrencyStorefrontWidget>();
	}
};
static_assert(alignof(UUMGBaseCurrencyStorefrontWidget) == 0x000008, "Wrong alignment on UUMGBaseCurrencyStorefrontWidget");
static_assert(sizeof(UUMGBaseCurrencyStorefrontWidget) == 0x000348, "Wrong size on UUMGBaseCurrencyStorefrontWidget");

// Class DeadByDaylight.UMGAtlCurrencyStorefrontWidget
// 0x00D0 (0x0418 - 0x0348)
class UUMGAtlCurrencyStorefrontWidget final : public UUMGBaseCurrencyStorefrontWidget
{
public:
	class UCanvasPanel*                           AuricCellsCanvasPanel;                             // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      AuricCellsGridPanel;                               // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         BottomPurchaseBox;                                 // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         BottomRightPurchaseRichText;                       // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               BottomTimer;                                       // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 AuricsBgR;                                         // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 AuricsBgL;                                         // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         EventItemsPackContainerBox;                        // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FMargin                                PaddingEventItemsPackButton;                       // 0x0388(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   EventItemsPackWidgetClass;                         // 0x0398(0x0030)(Edit, DisableEditOnInstance, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x18];                                     // 0x03C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UUMGStoreAuricCellButton*>       _auricCellButtons;                                 // 0x03E0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x28];                                     // 0x03F0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateFirstPurchaseForAllAuricCellsEndInUI(const class FString& endInText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlCurrencyStorefrontWidget">();
	}
	static class UUMGAtlCurrencyStorefrontWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlCurrencyStorefrontWidget>();
	}
};
static_assert(alignof(UUMGAtlCurrencyStorefrontWidget) == 0x000008, "Wrong alignment on UUMGAtlCurrencyStorefrontWidget");
static_assert(sizeof(UUMGAtlCurrencyStorefrontWidget) == 0x000418, "Wrong size on UUMGAtlCurrencyStorefrontWidget");
static_assert(offsetof(UUMGAtlCurrencyStorefrontWidget, AuricCellsCanvasPanel) == 0x000348, "Member 'UUMGAtlCurrencyStorefrontWidget::AuricCellsCanvasPanel' has a wrong offset!");
static_assert(offsetof(UUMGAtlCurrencyStorefrontWidget, AuricCellsGridPanel) == 0x000350, "Member 'UUMGAtlCurrencyStorefrontWidget::AuricCellsGridPanel' has a wrong offset!");
static_assert(offsetof(UUMGAtlCurrencyStorefrontWidget, BottomPurchaseBox) == 0x000358, "Member 'UUMGAtlCurrencyStorefrontWidget::BottomPurchaseBox' has a wrong offset!");
static_assert(offsetof(UUMGAtlCurrencyStorefrontWidget, BottomRightPurchaseRichText) == 0x000360, "Member 'UUMGAtlCurrencyStorefrontWidget::BottomRightPurchaseRichText' has a wrong offset!");
static_assert(offsetof(UUMGAtlCurrencyStorefrontWidget, BottomTimer) == 0x000368, "Member 'UUMGAtlCurrencyStorefrontWidget::BottomTimer' has a wrong offset!");
static_assert(offsetof(UUMGAtlCurrencyStorefrontWidget, AuricsBgR) == 0x000370, "Member 'UUMGAtlCurrencyStorefrontWidget::AuricsBgR' has a wrong offset!");
static_assert(offsetof(UUMGAtlCurrencyStorefrontWidget, AuricsBgL) == 0x000378, "Member 'UUMGAtlCurrencyStorefrontWidget::AuricsBgL' has a wrong offset!");
static_assert(offsetof(UUMGAtlCurrencyStorefrontWidget, EventItemsPackContainerBox) == 0x000380, "Member 'UUMGAtlCurrencyStorefrontWidget::EventItemsPackContainerBox' has a wrong offset!");
static_assert(offsetof(UUMGAtlCurrencyStorefrontWidget, PaddingEventItemsPackButton) == 0x000388, "Member 'UUMGAtlCurrencyStorefrontWidget::PaddingEventItemsPackButton' has a wrong offset!");
static_assert(offsetof(UUMGAtlCurrencyStorefrontWidget, EventItemsPackWidgetClass) == 0x000398, "Member 'UUMGAtlCurrencyStorefrontWidget::EventItemsPackWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGAtlCurrencyStorefrontWidget, _auricCellButtons) == 0x0003E0, "Member 'UUMGAtlCurrencyStorefrontWidget::_auricCellButtons' has a wrong offset!");

// Class DeadByDaylight.BlessedVignetteController
// 0x0010 (0x00C8 - 0x00B8)
class UBlessedVignetteController final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActivateBlessedVignette();
	void OnDeactivateBlessedVignette();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlessedVignetteController">();
	}
	static class UBlessedVignetteController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlessedVignetteController>();
	}
};
static_assert(alignof(UBlessedVignetteController) == 0x000008, "Wrong alignment on UBlessedVignetteController");
static_assert(sizeof(UBlessedVignetteController) == 0x0000C8, "Wrong size on UBlessedVignetteController");

// Class DeadByDaylight.BlindableComponent
// 0x0008 (0x0248 - 0x0240)
class UBlindableComponent final : public UBlindableBaseComponent
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindableComponent">();
	}
	static class UBlindableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindableComponent>();
	}
};
static_assert(alignof(UBlindableComponent) == 0x000008, "Wrong alignment on UBlindableComponent");
static_assert(sizeof(UBlindableComponent) == 0x000248, "Wrong size on UBlindableComponent");

// Class DeadByDaylight.BlindingFXComponent
// 0x0050 (0x0108 - 0x00B8)
class UBlindingFXComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _blindnessIntensityParameter;                      // 0x00C8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _blindnessMaterialCurve;                           // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _blindnessCurve;                                   // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPostProcessComponent*                  _postProcess;                                      // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _postProcessMaterial;                              // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPostProcess(class UPostProcessComponent* value);
	void SetPostProcessMaterial(class UMaterialInstanceDynamic* value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlindingFXComponent">();
	}
	static class UBlindingFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlindingFXComponent>();
	}
};
static_assert(alignof(UBlindingFXComponent) == 0x000008, "Wrong alignment on UBlindingFXComponent");
static_assert(sizeof(UBlindingFXComponent) == 0x000108, "Wrong size on UBlindingFXComponent");
static_assert(offsetof(UBlindingFXComponent, _blindnessIntensityParameter) == 0x0000C8, "Member 'UBlindingFXComponent::_blindnessIntensityParameter' has a wrong offset!");
static_assert(offsetof(UBlindingFXComponent, _blindnessMaterialCurve) == 0x0000D8, "Member 'UBlindingFXComponent::_blindnessMaterialCurve' has a wrong offset!");
static_assert(offsetof(UBlindingFXComponent, _blindnessCurve) == 0x0000E0, "Member 'UBlindingFXComponent::_blindnessCurve' has a wrong offset!");
static_assert(offsetof(UBlindingFXComponent, _postProcess) == 0x0000E8, "Member 'UBlindingFXComponent::_postProcess' has a wrong offset!");
static_assert(offsetof(UBlindingFXComponent, _postProcessMaterial) == 0x0000F0, "Member 'UBlindingFXComponent::_postProcessMaterial' has a wrong offset!");

// Class DeadByDaylight.BlockableComponent
// 0x0088 (0x0140 - 0x00B8)
class UBlockableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlockableReplicatedDatum              _replicatedDatum;                                  // 0x00D0(0x0020)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TSet<class UBlockElement*>                    _blockElements;                                    // 0x00F0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void Authority_AddBlock(const class UObject* source, const TSet<class ADBDPlayer*>& affectedPlayers);
	void Authority_AddTimedBlock(const class UObject* source, const float duration, const TSet<class ADBDPlayer*>& affectedPlayers);
	void Authority_RemoveBlock(const class UObject* source);
	void OnRep_ReplicatedDatum();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockableComponent">();
	}
	static class UBlockableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockableComponent>();
	}
};
static_assert(alignof(UBlockableComponent) == 0x000008, "Wrong alignment on UBlockableComponent");
static_assert(sizeof(UBlockableComponent) == 0x000140, "Wrong size on UBlockableComponent");
static_assert(offsetof(UBlockableComponent, _replicatedDatum) == 0x0000D0, "Member 'UBlockableComponent::_replicatedDatum' has a wrong offset!");
static_assert(offsetof(UBlockableComponent, _blockElements) == 0x0000F0, "Member 'UBlockableComponent::_blockElements' has a wrong offset!");

// Class DeadByDaylight.PollableEventListener
// 0x0010 (0x00C8 - 0x00B8)
class UPollableEventListener final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PollableEventListener">();
	}
	static class UPollableEventListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPollableEventListener>();
	}
};
static_assert(alignof(UPollableEventListener) == 0x000008, "Wrong alignment on UPollableEventListener");
static_assert(sizeof(UPollableEventListener) == 0x0000C8, "Wrong size on UPollableEventListener");

// Class DeadByDaylight.DBDAggregateCullDistanceVolumes
// 0x0000 (0x0230 - 0x0230)
class ADBDAggregateCullDistanceVolumes final : public AActor
{
public:
	void SpawnCullDistanceVolumes();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAggregateCullDistanceVolumes">();
	}
	static class ADBDAggregateCullDistanceVolumes* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDAggregateCullDistanceVolumes>();
	}
};
static_assert(alignof(ADBDAggregateCullDistanceVolumes) == 0x000008, "Wrong alignment on ADBDAggregateCullDistanceVolumes");
static_assert(sizeof(ADBDAggregateCullDistanceVolumes) == 0x000230, "Wrong size on ADBDAggregateCullDistanceVolumes");

// Class DeadByDaylight.BloodDecalEffectIntensity
// 0x0018 (0x0050 - 0x0038)
class UBloodDecalEffectIntensity final : public UDataAsset
{
public:
	struct FColor                                 IntensifyBloodColor;                               // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 IntensifyBloodColor2;                              // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 IntensifyBloodColorEmissive;                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntensifyBloodColorEmissiveMinimumIntensity;       // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntensifyBloodColorEmissiveMaximumIntensity;       // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodDecalEffectIntensity">();
	}
	static class UBloodDecalEffectIntensity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodDecalEffectIntensity>();
	}
};
static_assert(alignof(UBloodDecalEffectIntensity) == 0x000008, "Wrong alignment on UBloodDecalEffectIntensity");
static_assert(sizeof(UBloodDecalEffectIntensity) == 0x000050, "Wrong size on UBloodDecalEffectIntensity");
static_assert(offsetof(UBloodDecalEffectIntensity, IntensifyBloodColor) == 0x000038, "Member 'UBloodDecalEffectIntensity::IntensifyBloodColor' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffectIntensity, IntensifyBloodColor2) == 0x00003C, "Member 'UBloodDecalEffectIntensity::IntensifyBloodColor2' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffectIntensity, IntensifyBloodColorEmissive) == 0x000040, "Member 'UBloodDecalEffectIntensity::IntensifyBloodColorEmissive' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffectIntensity, IntensifyBloodColorEmissiveMinimumIntensity) == 0x000044, "Member 'UBloodDecalEffectIntensity::IntensifyBloodColorEmissiveMinimumIntensity' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffectIntensity, IntensifyBloodColorEmissiveMaximumIntensity) == 0x000048, "Member 'UBloodDecalEffectIntensity::IntensifyBloodColorEmissiveMaximumIntensity' has a wrong offset!");

// Class DeadByDaylight.BloodDecalEffect
// 0x00E0 (0x0118 - 0x0038)
class UBloodDecalEffect final : public UDataAsset
{
public:
	class UCurveFloat*                            AnimationTimelineCurve;                            // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DestroyTimelineCurve;                              // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     Textures;                                          // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     Normals;                                           // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          EnableVisualEffects;                               // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodDecalEffectIntensity*             BloodDecalEffectIntensity;                         // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorInterpolationSpeed;                           // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     DefalultDecalMaterial;                             // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x90];                                      // 0x0088(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodDecalEffect">();
	}
	static class UBloodDecalEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodDecalEffect>();
	}
};
static_assert(alignof(UBloodDecalEffect) == 0x000008, "Wrong alignment on UBloodDecalEffect");
static_assert(sizeof(UBloodDecalEffect) == 0x000118, "Wrong size on UBloodDecalEffect");
static_assert(offsetof(UBloodDecalEffect, AnimationTimelineCurve) == 0x000038, "Member 'UBloodDecalEffect::AnimationTimelineCurve' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, DestroyTimelineCurve) == 0x000040, "Member 'UBloodDecalEffect::DestroyTimelineCurve' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, Textures) == 0x000048, "Member 'UBloodDecalEffect::Textures' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, Normals) == 0x000058, "Member 'UBloodDecalEffect::Normals' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, EnableVisualEffects) == 0x000068, "Member 'UBloodDecalEffect::EnableVisualEffects' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, BloodDecalEffectIntensity) == 0x000070, "Member 'UBloodDecalEffect::BloodDecalEffectIntensity' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, ColorInterpolationSpeed) == 0x000078, "Member 'UBloodDecalEffect::ColorInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UBloodDecalEffect, DefalultDecalMaterial) == 0x000080, "Member 'UBloodDecalEffect::DefalultDecalMaterial' has a wrong offset!");

// Class DeadByDaylight.WakerObject
// 0x0030 (0x0358 - 0x0328)
class AWakerObject final : public AInteractable
{
public:
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCamperDreamworldComponent*             _linkedCamperDreamworldComponent;                  // 0x0330(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsInteracting;                                     // 0x0338(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _chargeComplete;                                   // 0x0339(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_33A[0x1E];                                     // 0x033A(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindToCamperDreamStateChanged(class ADBDPlayer* player);
	void LinkCampersOnLevelReadyToPlay();
	void OnAnyCamperDreamStateChanged(bool isInDreamworld, bool locallyObservedChanged);
	void OnLinkedCamperDreamStateChanged(bool isInDreamworld, bool locallyObservedChanged);
	void OnNewLinkedCamper(class UCamperDreamworldComponent* dreamworldComponent);
	void OnRep_LinkedCamperChanged(class UCamperDreamworldComponent* previous);
	void SetChargeComplete(bool complete);
	void UpdateVisibilityAndOutline();

	bool CanWakeUpCamper(const class ADBDPlayer* camper) const;
	bool GetChargeComplete() const;
	float GetInteractionPercentComplete() const;
	class UPrimitiveComponent* GetInteractorPrimitiveComponent() const;
	bool GetIsInteracting() const;
	class USkeletalMeshComponent* GetMesh() const;
	bool HasLinkedCamper() const;
	bool IsLinkedToCamper(const class ADBDPlayer* camper) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WakerObject">();
	}
	static class AWakerObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWakerObject>();
	}
};
static_assert(alignof(AWakerObject) == 0x000008, "Wrong alignment on AWakerObject");
static_assert(sizeof(AWakerObject) == 0x000358, "Wrong size on AWakerObject");
static_assert(offsetof(AWakerObject, _linkedCamperDreamworldComponent) == 0x000330, "Member 'AWakerObject::_linkedCamperDreamworldComponent' has a wrong offset!");
static_assert(offsetof(AWakerObject, IsInteracting) == 0x000338, "Member 'AWakerObject::IsInteracting' has a wrong offset!");
static_assert(offsetof(AWakerObject, _chargeComplete) == 0x000339, "Member 'AWakerObject::_chargeComplete' has a wrong offset!");

// Class DeadByDaylight.DBDDiceRoller
// 0x0000 (0x0030 - 0x0030)
class UDBDDiceRoller final : public UBlueprintFunctionLibrary
{
public:
	static bool CalculateOverTimeRollResult(const class AActor* RollingActor, float BaseProbability, float DeltaTime, float ExpectedTime, float MultiplicativeModifier, float AdditiveModifier);
	static bool CalculateRollResult(const class AActor* RollingActor, float BaseProbability, float MultiplicativeModifier, float AdditiveModifier);
	static bool CalculateTickedRollResult(const class AActor* RollingActor, float BaseProbability, float ticks, float MultiplicativeModifier, float AdditiveModifier);
	static float GetInteractionRollSuccessPercentageByDiceRollType(const class UInteractionDefinition* interaction, const class ADBDPlayer* RollingPlayer, EDiceRollType DiceRollType);
	static bool GetRollResultByDiceRollType(const class ADBDPlayer* RollingPlayer, EDiceRollType DiceRollType);
	static bool GetRollResultByTunableValue(const class AActor* RollingActor, class FName TunableValueName, float MultiplicativeModifier, float AdditiveModifier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDiceRoller">();
	}
	static class UDBDDiceRoller* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDiceRoller>();
	}
};
static_assert(alignof(UDBDDiceRoller) == 0x000008, "Wrong alignment on UDBDDiceRoller");
static_assert(sizeof(UDBDDiceRoller) == 0x000030, "Wrong size on UDBDDiceRoller");

// Class DeadByDaylight.UMGAtlantaFriendListScreen
// 0x03B8 (0x06F0 - 0x0338)
class UUMGAtlantaFriendListScreen final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x60];                                     // 0x0338(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSwitcher*                        ListSwitcher;                                      // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        SearchResultSwitcher;                              // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBaseFriendListElement*              NonFriendSearchResult;                             // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBaseFriendListElement*              RequestReceivedSearchResult;                       // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBaseFriendListElement*              RequestSentSearchResult;                           // 0x03B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBaseFriendListElement*              FriendSearchResult;                                // 0x03C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SearchFailureText;                                 // 0x03C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBaseButtonWidget*                   CloseButton;                                       // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGFriendSearchBarWidget*              SearchBar;                                         // 0x03D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         ButtonTabContainer;                                // 0x03E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGFriendListTabWidget*                FriendListTabWidget;                               // 0x03E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGSuggestionsListTabWidget*           SuggestionListTabWidget;                           // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGRequestsListTabWidget*              RequestListTabWidget;                              // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGFriendTabButtonWidget*              FriendsTabButton;                                  // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGFriendTabButtonWidget*              SuggestionsTabButton;                              // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGFriendTabButtonWidget*              RequestsTabButton;                                 // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBaseFriendListContextualMenuWidget* CurrentContextualMenuWidget;                       // 0x0418(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   FriendWidget;                                      // 0x0420(0x0030)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   RequestSentWidget;                                 // 0x0450(0x0030)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   FriendRequestReceivedWidget;                       // 0x0480(0x0030)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   FriendsSuggestionWidget;                           // 0x04B0(0x0030)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   FriendsSuggestion;                                 // 0x04E0(0x0030)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   FriendPartyInviteWidgetClass;                      // 0x0510(0x0030)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ContextualMenuInvite;                              // 0x0540(0x0030)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ContextualMenuConfirmDeclineAction;                // 0x0570(0x0030)(Edit, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A0[0x90];                                     // 0x05A0(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FFriendWidgetList> _existingFriendListWidgets;                        // 0x0630(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FString, class UUMGBaseFriendListElement*> _existingFriendInvitePartyWidget;          // 0x0680(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6D0[0x20];                                     // 0x06D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCloseButtonClicked();
	void HandleContextualMenuAction(EActionOnFriendType action);
	void HandleOnActionOnFriend(const struct FActionOnFriend& actionOnFriend);
	void HandleSearchButtonClicked();
	void HandleSearchInputChanged(const class FText& inputText);
	void HandleTabButtonClicked(uint8 tabIndex);
	void OnFinishedOutAnimation();
	void VerifyReceivedFriendRequestFocus(class UExpandableArea* expandableArea, bool bIsExpanded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaFriendListScreen">();
	}
	static class UUMGAtlantaFriendListScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaFriendListScreen>();
	}
};
static_assert(alignof(UUMGAtlantaFriendListScreen) == 0x000008, "Wrong alignment on UUMGAtlantaFriendListScreen");
static_assert(sizeof(UUMGAtlantaFriendListScreen) == 0x0006F0, "Wrong size on UUMGAtlantaFriendListScreen");
static_assert(offsetof(UUMGAtlantaFriendListScreen, ListSwitcher) == 0x000398, "Member 'UUMGAtlantaFriendListScreen::ListSwitcher' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, SearchResultSwitcher) == 0x0003A0, "Member 'UUMGAtlantaFriendListScreen::SearchResultSwitcher' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, NonFriendSearchResult) == 0x0003A8, "Member 'UUMGAtlantaFriendListScreen::NonFriendSearchResult' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, RequestReceivedSearchResult) == 0x0003B0, "Member 'UUMGAtlantaFriendListScreen::RequestReceivedSearchResult' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, RequestSentSearchResult) == 0x0003B8, "Member 'UUMGAtlantaFriendListScreen::RequestSentSearchResult' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, FriendSearchResult) == 0x0003C0, "Member 'UUMGAtlantaFriendListScreen::FriendSearchResult' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, SearchFailureText) == 0x0003C8, "Member 'UUMGAtlantaFriendListScreen::SearchFailureText' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, CloseButton) == 0x0003D0, "Member 'UUMGAtlantaFriendListScreen::CloseButton' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, SearchBar) == 0x0003D8, "Member 'UUMGAtlantaFriendListScreen::SearchBar' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, ButtonTabContainer) == 0x0003E0, "Member 'UUMGAtlantaFriendListScreen::ButtonTabContainer' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, FriendListTabWidget) == 0x0003E8, "Member 'UUMGAtlantaFriendListScreen::FriendListTabWidget' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, SuggestionListTabWidget) == 0x0003F0, "Member 'UUMGAtlantaFriendListScreen::SuggestionListTabWidget' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, RequestListTabWidget) == 0x0003F8, "Member 'UUMGAtlantaFriendListScreen::RequestListTabWidget' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, FriendsTabButton) == 0x000400, "Member 'UUMGAtlantaFriendListScreen::FriendsTabButton' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, SuggestionsTabButton) == 0x000408, "Member 'UUMGAtlantaFriendListScreen::SuggestionsTabButton' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, RequestsTabButton) == 0x000410, "Member 'UUMGAtlantaFriendListScreen::RequestsTabButton' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, CurrentContextualMenuWidget) == 0x000418, "Member 'UUMGAtlantaFriendListScreen::CurrentContextualMenuWidget' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, FriendWidget) == 0x000420, "Member 'UUMGAtlantaFriendListScreen::FriendWidget' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, RequestSentWidget) == 0x000450, "Member 'UUMGAtlantaFriendListScreen::RequestSentWidget' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, FriendRequestReceivedWidget) == 0x000480, "Member 'UUMGAtlantaFriendListScreen::FriendRequestReceivedWidget' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, FriendsSuggestionWidget) == 0x0004B0, "Member 'UUMGAtlantaFriendListScreen::FriendsSuggestionWidget' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, FriendsSuggestion) == 0x0004E0, "Member 'UUMGAtlantaFriendListScreen::FriendsSuggestion' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, FriendPartyInviteWidgetClass) == 0x000510, "Member 'UUMGAtlantaFriendListScreen::FriendPartyInviteWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, ContextualMenuInvite) == 0x000540, "Member 'UUMGAtlantaFriendListScreen::ContextualMenuInvite' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, ContextualMenuConfirmDeclineAction) == 0x000570, "Member 'UUMGAtlantaFriendListScreen::ContextualMenuConfirmDeclineAction' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, _existingFriendListWidgets) == 0x000630, "Member 'UUMGAtlantaFriendListScreen::_existingFriendListWidgets' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFriendListScreen, _existingFriendInvitePartyWidget) == 0x000680, "Member 'UUMGAtlantaFriendListScreen::_existingFriendInvitePartyWidget' has a wrong offset!");

// Class DeadByDaylight.Bloodlust
// 0x0138 (0x0488 - 0x0350)
class UBloodlust final : public UStatusEffect
{
public:
	class UCurveFloat*                            BloodlustCurve;                                    // 0x0350(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x20];                                     // 0x0358(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _bloodlustTime;                                    // 0x0378(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_37C[0x2C];                                     // 0x037C(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   _bloodlustResettingGameEvents;                     // 0x03A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B8[0xD0];                                     // 0x03B8(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_SetBloodlust(const int32 amount, const bool enableDecay);
	void OnAllChaseEndedEvent();
	void OnChaseStartedEvent(class ADBDPlayer* chasedPlayer);
	void OnRep_BloodlustTime(float oldBloodlustTime);

	float GetBloodlustTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Bloodlust">();
	}
	static class UBloodlust* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodlust>();
	}
};
static_assert(alignof(UBloodlust) == 0x000008, "Wrong alignment on UBloodlust");
static_assert(sizeof(UBloodlust) == 0x000488, "Wrong size on UBloodlust");
static_assert(offsetof(UBloodlust, BloodlustCurve) == 0x000350, "Member 'UBloodlust::BloodlustCurve' has a wrong offset!");
static_assert(offsetof(UBloodlust, _bloodlustTime) == 0x000378, "Member 'UBloodlust::_bloodlustTime' has a wrong offset!");
static_assert(offsetof(UBloodlust, _bloodlustResettingGameEvents) == 0x0003A8, "Member 'UBloodlust::_bloodlustResettingGameEvents' has a wrong offset!");

// Class DeadByDaylight.RankTooltipWidget
// 0x0028 (0x0398 - 0x0370)
class URankTooltipWidget final : public UBaseTooltipWidget
{
public:
	class UTextBlock*                             RankInfoLabel;                                     // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ResetInfoLabel;                                    // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGridPanel*                             RankInfoSlotsContainer;                            // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGPlayerRankInfo*                     SurvivorRankInfoWidget;                            // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGPlayerRankInfo*                     KillerRankInfoWidget;                              // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RankTooltipWidget">();
	}
	static class URankTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URankTooltipWidget>();
	}
};
static_assert(alignof(URankTooltipWidget) == 0x000008, "Wrong alignment on URankTooltipWidget");
static_assert(sizeof(URankTooltipWidget) == 0x000398, "Wrong size on URankTooltipWidget");
static_assert(offsetof(URankTooltipWidget, RankInfoLabel) == 0x000370, "Member 'URankTooltipWidget::RankInfoLabel' has a wrong offset!");
static_assert(offsetof(URankTooltipWidget, ResetInfoLabel) == 0x000378, "Member 'URankTooltipWidget::ResetInfoLabel' has a wrong offset!");
static_assert(offsetof(URankTooltipWidget, RankInfoSlotsContainer) == 0x000380, "Member 'URankTooltipWidget::RankInfoSlotsContainer' has a wrong offset!");
static_assert(offsetof(URankTooltipWidget, SurvivorRankInfoWidget) == 0x000388, "Member 'URankTooltipWidget::SurvivorRankInfoWidget' has a wrong offset!");
static_assert(offsetof(URankTooltipWidget, KillerRankInfoWidget) == 0x000390, "Member 'URankTooltipWidget::KillerRankInfoWidget' has a wrong offset!");

// Class DeadByDaylight.BloodTrailSettings
// 0x0168 (0x01A0 - 0x0038)
class UBloodTrailSettings final : public UDataAsset
{
public:
	float                                         _initialDelay;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _numBloodDropsPerBloodPool;                        // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _bloodDropsInterval;                               // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _randomlyRotateBloodDrops;                         // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _bloodDropsRandomScatter;                          // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               _bloodTraceChannel;                                // 0x004C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodDecalEffect*                      _bloodDecalEffect;                                 // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBHVRPerDetailModeInt                  _decalPoolSize;                                    // 0x0058(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         _recycleThresholdPercentage;                       // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _recycleDistancePercentage;                        // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBHVRPerDetailModeInt                  _maxOverlapping;                                   // 0x0100(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodTrailSettings">();
	}
	static class UBloodTrailSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodTrailSettings>();
	}
};
static_assert(alignof(UBloodTrailSettings) == 0x000008, "Wrong alignment on UBloodTrailSettings");
static_assert(sizeof(UBloodTrailSettings) == 0x0001A0, "Wrong size on UBloodTrailSettings");
static_assert(offsetof(UBloodTrailSettings, _initialDelay) == 0x000038, "Member 'UBloodTrailSettings::_initialDelay' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _numBloodDropsPerBloodPool) == 0x00003C, "Member 'UBloodTrailSettings::_numBloodDropsPerBloodPool' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _bloodDropsInterval) == 0x000040, "Member 'UBloodTrailSettings::_bloodDropsInterval' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _randomlyRotateBloodDrops) == 0x000044, "Member 'UBloodTrailSettings::_randomlyRotateBloodDrops' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _bloodDropsRandomScatter) == 0x000048, "Member 'UBloodTrailSettings::_bloodDropsRandomScatter' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _bloodTraceChannel) == 0x00004C, "Member 'UBloodTrailSettings::_bloodTraceChannel' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _bloodDecalEffect) == 0x000050, "Member 'UBloodTrailSettings::_bloodDecalEffect' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _decalPoolSize) == 0x000058, "Member 'UBloodTrailSettings::_decalPoolSize' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _recycleThresholdPercentage) == 0x0000F8, "Member 'UBloodTrailSettings::_recycleThresholdPercentage' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _recycleDistancePercentage) == 0x0000FC, "Member 'UBloodTrailSettings::_recycleDistancePercentage' has a wrong offset!");
static_assert(offsetof(UBloodTrailSettings, _maxOverlapping) == 0x000100, "Member 'UBloodTrailSettings::_maxOverlapping' has a wrong offset!");

// Class DeadByDaylight.DBDBaseGameMode
// 0x0038 (0x0360 - 0x0328)
class ADBDBaseGameMode : public AGameMode
{
public:
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataTableDropdown                     DebugSpecialEvent;                                 // 0x0330(0x0030)(Edit, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseGameMode">();
	}
	static class ADBDBaseGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDBaseGameMode>();
	}
};
static_assert(alignof(ADBDBaseGameMode) == 0x000008, "Wrong alignment on ADBDBaseGameMode");
static_assert(sizeof(ADBDBaseGameMode) == 0x000360, "Wrong size on ADBDBaseGameMode");
static_assert(offsetof(ADBDBaseGameMode, DebugSpecialEvent) == 0x000330, "Member 'ADBDBaseGameMode::DebugSpecialEvent' has a wrong offset!");

// Class DeadByDaylight.DBDBaseMatchGameMode
// 0x0018 (0x0378 - 0x0360)
class ADBDBaseMatchGameMode : public ADBDBaseGameMode
{
public:
	class UEndGameComponent*                      _endGameComponent;                                 // 0x0360(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEscapeRequirementTracker*              _escapeRequirementTracker;                         // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ANetworkFenceActor*                     _theFence;                                         // 0x0370(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UEndGameComponent* GetEndGameComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseMatchGameMode">();
	}
	static class ADBDBaseMatchGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDBaseMatchGameMode>();
	}
};
static_assert(alignof(ADBDBaseMatchGameMode) == 0x000008, "Wrong alignment on ADBDBaseMatchGameMode");
static_assert(sizeof(ADBDBaseMatchGameMode) == 0x000378, "Wrong size on ADBDBaseMatchGameMode");
static_assert(offsetof(ADBDBaseMatchGameMode, _endGameComponent) == 0x000360, "Member 'ADBDBaseMatchGameMode::_endGameComponent' has a wrong offset!");
static_assert(offsetof(ADBDBaseMatchGameMode, _escapeRequirementTracker) == 0x000368, "Member 'ADBDBaseMatchGameMode::_escapeRequirementTracker' has a wrong offset!");
static_assert(offsetof(ADBDBaseMatchGameMode, _theFence) == 0x000370, "Member 'ADBDBaseMatchGameMode::_theFence' has a wrong offset!");

// Class DeadByDaylight.DBDGameMode
// 0x0158 (0x04D0 - 0x0378)
class ADBDGameMode : public ADBDBaseMatchGameMode
{
public:
	uint8                                         Pad_378[0x20];                                     // 0x0378(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnPlayersLoadoutsCreated;                          // 0x0398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class APlayerController>          _killerPlayerControllerClass;                      // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APlayerController>          _survivorPlayerControllerClass;                    // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class APlayerStart*>                   _initialPlayerStarts;                              // 0x03B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x34];                                     // 0x03C8(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KillerCreationPositionOrder;                       // 0x03FC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0xD0];                                     // 0x0400(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_BlockCamperEscape(bool shouldBlock);
	void HostGame();
	void InitializeEscapeRequirements();
	void LevelLoaded(const class FString& levelName);
	void OnPlayerGameStateChanged(class ADBDPlayerState* playerState, EGameState playerGameState);
	void RegisterOnPlayerStateChanged(class APlayerState* playerState);
	void SetEscapeOpened(bool val);
	void SetPlayerCount(int32 playerAmount);

	bool AreLoadoutsCreated() const;
	bool IsEscapeOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameMode">();
	}
	static class ADBDGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGameMode>();
	}
};
static_assert(alignof(ADBDGameMode) == 0x000008, "Wrong alignment on ADBDGameMode");
static_assert(sizeof(ADBDGameMode) == 0x0004D0, "Wrong size on ADBDGameMode");
static_assert(offsetof(ADBDGameMode, OnPlayersLoadoutsCreated) == 0x000398, "Member 'ADBDGameMode::OnPlayersLoadoutsCreated' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _killerPlayerControllerClass) == 0x0003A8, "Member 'ADBDGameMode::_killerPlayerControllerClass' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _survivorPlayerControllerClass) == 0x0003B0, "Member 'ADBDGameMode::_survivorPlayerControllerClass' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, _initialPlayerStarts) == 0x0003B8, "Member 'ADBDGameMode::_initialPlayerStarts' has a wrong offset!");
static_assert(offsetof(ADBDGameMode, KillerCreationPositionOrder) == 0x0003FC, "Member 'ADBDGameMode::KillerCreationPositionOrder' has a wrong offset!");

// Class DeadByDaylight.DBDDebugGameMode
// 0x00D8 (0x05A8 - 0x04D0)
class ADBDDebugGameMode final : public ADBDGameMode
{
public:
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayerController*, int32>      LoadoutIndex;                                      // 0x04D8(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class ADBDPlayer*>                       PlayersWithItems;                                  // 0x0528(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FCamperLoadout>                 CamperPawnOverrides;                               // 0x0578(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FSlasherLoadout>                SlasherPawnOverrides;                              // 0x0588(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FDebugQuestModelExtArchiveObjective> _questObjectives;                             // 0x0598(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDebugGameMode">();
	}
	static class ADBDDebugGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDDebugGameMode>();
	}
};
static_assert(alignof(ADBDDebugGameMode) == 0x000008, "Wrong alignment on ADBDDebugGameMode");
static_assert(sizeof(ADBDDebugGameMode) == 0x0005A8, "Wrong size on ADBDDebugGameMode");
static_assert(offsetof(ADBDDebugGameMode, LoadoutIndex) == 0x0004D8, "Member 'ADBDDebugGameMode::LoadoutIndex' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, PlayersWithItems) == 0x000528, "Member 'ADBDDebugGameMode::PlayersWithItems' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, CamperPawnOverrides) == 0x000578, "Member 'ADBDDebugGameMode::CamperPawnOverrides' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, SlasherPawnOverrides) == 0x000588, "Member 'ADBDDebugGameMode::SlasherPawnOverrides' has a wrong offset!");
static_assert(offsetof(ADBDDebugGameMode, _questObjectives) == 0x000598, "Member 'ADBDDebugGameMode::_questObjectives' has a wrong offset!");

// Class DeadByDaylight.BloodTrailComponent
// 0x0188 (0x0240 - 0x00B8)
class alignas(0x10) UBloodTrailComponent : public UActorComponent
{
public:
	class UBloodTrailSettings*                    _bloodTrailSettings;                               // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x80];                                      // 0x00C0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UDBDDecalComponent*, struct FBloodDecal> _bloodDecals;                                // 0x0140(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UBloodDecalEffect*                      _bloodDecalEffect;                                 // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x90];                                     // 0x0198(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalSpawner*                          _decalSpawner;                                     // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConditionalStartBleeding();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodTrailComponent">();
	}
	static class UBloodTrailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodTrailComponent>();
	}
};
static_assert(alignof(UBloodTrailComponent) == 0x000010, "Wrong alignment on UBloodTrailComponent");
static_assert(sizeof(UBloodTrailComponent) == 0x000240, "Wrong size on UBloodTrailComponent");
static_assert(offsetof(UBloodTrailComponent, _bloodTrailSettings) == 0x0000B8, "Member 'UBloodTrailComponent::_bloodTrailSettings' has a wrong offset!");
static_assert(offsetof(UBloodTrailComponent, _bloodDecals) == 0x000140, "Member 'UBloodTrailComponent::_bloodDecals' has a wrong offset!");
static_assert(offsetof(UBloodTrailComponent, _bloodDecalEffect) == 0x000190, "Member 'UBloodTrailComponent::_bloodDecalEffect' has a wrong offset!");
static_assert(offsetof(UBloodTrailComponent, _decalSpawner) == 0x000228, "Member 'UBloodTrailComponent::_decalSpawner' has a wrong offset!");

// Class DeadByDaylight.BloodwebTunables
// 0x0008 (0x0038 - 0x0030)
class UBloodwebTunables : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebTunables">();
	}
	static class UBloodwebTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebTunables>();
	}
};
static_assert(alignof(UBloodwebTunables) == 0x000008, "Wrong alignment on UBloodwebTunables");
static_assert(sizeof(UBloodwebTunables) == 0x000038, "Wrong size on UBloodwebTunables");

// Class DeadByDaylight.DBD_SoundClipUtil
// 0x00C8 (0x0180 - 0x00B8)
class UDBD_SoundClipUtil final : public UActorComponent
{
public:
	TArray<struct FMapMeshToAkAudioEvent>         AudioMap;                                          // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FMapMeshToAkAudioEvent> _audioEventMap;                                 // 0x00C8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMapSoundsToAvoid>              _objectsWhoHavePlayedASound;                       // 0x0118(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UAkAudioEvent*, float>             _nextSoundPlayTime;                                // 0x0128(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cosmetic_OnSoundTriggered(class AActor* actor);
	class UAkAudioEvent* GetAudioEventForMesh(class UStaticMeshComponent* usm);
	void OnCharacterEnterSoundRegion(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBD_SoundClipUtil">();
	}
	static class UDBD_SoundClipUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBD_SoundClipUtil>();
	}
};
static_assert(alignof(UDBD_SoundClipUtil) == 0x000008, "Wrong alignment on UDBD_SoundClipUtil");
static_assert(sizeof(UDBD_SoundClipUtil) == 0x000180, "Wrong size on UDBD_SoundClipUtil");
static_assert(offsetof(UDBD_SoundClipUtil, AudioMap) == 0x0000B8, "Member 'UDBD_SoundClipUtil::AudioMap' has a wrong offset!");
static_assert(offsetof(UDBD_SoundClipUtil, _audioEventMap) == 0x0000C8, "Member 'UDBD_SoundClipUtil::_audioEventMap' has a wrong offset!");
static_assert(offsetof(UDBD_SoundClipUtil, _objectsWhoHavePlayedASound) == 0x000118, "Member 'UDBD_SoundClipUtil::_objectsWhoHavePlayedASound' has a wrong offset!");
static_assert(offsetof(UDBD_SoundClipUtil, _nextSoundPlayTime) == 0x000128, "Member 'UDBD_SoundClipUtil::_nextSoundPlayTime' has a wrong offset!");

// Class DeadByDaylight.BloodwebBackendTunables
// 0x0070 (0x00A8 - 0x0038)
class UBloodwebBackendTunables final : public UBloodwebTunables
{
public:
	uint8                                         Pad_38[0x70];                                      // 0x0038(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebBackendTunables">();
	}
	static class UBloodwebBackendTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebBackendTunables>();
	}
};
static_assert(alignof(UBloodwebBackendTunables) == 0x000008, "Wrong alignment on UBloodwebBackendTunables");
static_assert(sizeof(UBloodwebBackendTunables) == 0x0000A8, "Wrong size on UBloodwebBackendTunables");

// Class DeadByDaylight.BloodwebClientTunables
// 0x0000 (0x0038 - 0x0038)
class UBloodwebClientTunables final : public UBloodwebTunables
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebClientTunables">();
	}
	static class UBloodwebClientTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebClientTunables>();
	}
};
static_assert(alignof(UBloodwebClientTunables) == 0x000008, "Wrong alignment on UBloodwebClientTunables");
static_assert(sizeof(UBloodwebClientTunables) == 0x000038, "Wrong size on UBloodwebClientTunables");

// Class DeadByDaylight.PremiumTransactionSubsystem
// 0x0020 (0x0058 - 0x0038)
class UPremiumTransactionSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PremiumTransactionSubsystem">();
	}
	static class UPremiumTransactionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPremiumTransactionSubsystem>();
	}
};
static_assert(alignof(UPremiumTransactionSubsystem) == 0x000008, "Wrong alignment on UPremiumTransactionSubsystem");
static_assert(sizeof(UPremiumTransactionSubsystem) == 0x000058, "Wrong size on UPremiumTransactionSubsystem");

// Class DeadByDaylight.BloodwebDistribution
// 0x02F8 (0x0328 - 0x0030)
class UBloodwebDistribution final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDDesignTunables*                     _designTunables;                                   // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodwebTunables*                      _bloodwebTunables;                                 // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x2D8];                                     // 0x0050(0x02D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebDistribution">();
	}
	static class UBloodwebDistribution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebDistribution>();
	}
};
static_assert(alignof(UBloodwebDistribution) == 0x000008, "Wrong alignment on UBloodwebDistribution");
static_assert(sizeof(UBloodwebDistribution) == 0x000328, "Wrong size on UBloodwebDistribution");
static_assert(offsetof(UBloodwebDistribution, _designTunables) == 0x000040, "Member 'UBloodwebDistribution::_designTunables' has a wrong offset!");
static_assert(offsetof(UBloodwebDistribution, _bloodwebTunables) == 0x000048, "Member 'UBloodwebDistribution::_bloodwebTunables' has a wrong offset!");

// Class DeadByDaylight.BloodwebEntity
// 0x0048 (0x0078 - 0x0030)
class UBloodwebEntity final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodwebTunables*                      _bloodwebTunables;                                 // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TScriptInterface<class IDBDBloodwebDefinitionBase> _bloodWebDefinition;                          // 0x0048(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebEntity">();
	}
	static class UBloodwebEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebEntity>();
	}
};
static_assert(alignof(UBloodwebEntity) == 0x000008, "Wrong alignment on UBloodwebEntity");
static_assert(sizeof(UBloodwebEntity) == 0x000078, "Wrong size on UBloodwebEntity");
static_assert(offsetof(UBloodwebEntity, _gameInstance) == 0x000038, "Member 'UBloodwebEntity::_gameInstance' has a wrong offset!");
static_assert(offsetof(UBloodwebEntity, _bloodwebTunables) == 0x000040, "Member 'UBloodwebEntity::_bloodwebTunables' has a wrong offset!");
static_assert(offsetof(UBloodwebEntity, _bloodWebDefinition) == 0x000048, "Member 'UBloodwebEntity::_bloodWebDefinition' has a wrong offset!");

// Class DeadByDaylight.XboxProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UXboxProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XboxProfileDAL">();
	}
	static class UXboxProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXboxProfileDAL>();
	}
};
static_assert(alignof(UXboxProfileDAL) == 0x000008, "Wrong alignment on UXboxProfileDAL");
static_assert(sizeof(UXboxProfileDAL) == 0x000088, "Wrong size on UXboxProfileDAL");

// Class DeadByDaylight.DBDAggregateParticleSystemComponent
// 0x0060 (0x0760 - 0x0700)
class UDBDAggregateParticleSystemComponent final : public UParticleSystemComponent
{
public:
	float                                         CullAngle;                                         // 0x06F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndFadeDistance;                                   // 0x06FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class USceneComponent*>                  LocatorComponentCache;                             // 0x0700(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          PendingReset;                                      // 0x0750(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_751[0xF];                                      // 0x0751(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAggregateParticleSystemComponent">();
	}
	static class UDBDAggregateParticleSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAggregateParticleSystemComponent>();
	}
};
static_assert(alignof(UDBDAggregateParticleSystemComponent) == 0x000010, "Wrong alignment on UDBDAggregateParticleSystemComponent");
static_assert(sizeof(UDBDAggregateParticleSystemComponent) == 0x000760, "Wrong size on UDBDAggregateParticleSystemComponent");
static_assert(offsetof(UDBDAggregateParticleSystemComponent, CullAngle) == 0x0006F8, "Member 'UDBDAggregateParticleSystemComponent::CullAngle' has a wrong offset!");
static_assert(offsetof(UDBDAggregateParticleSystemComponent, EndFadeDistance) == 0x0006FC, "Member 'UDBDAggregateParticleSystemComponent::EndFadeDistance' has a wrong offset!");
static_assert(offsetof(UDBDAggregateParticleSystemComponent, LocatorComponentCache) == 0x000700, "Member 'UDBDAggregateParticleSystemComponent::LocatorComponentCache' has a wrong offset!");
static_assert(offsetof(UDBDAggregateParticleSystemComponent, PendingReset) == 0x000750, "Member 'UDBDAggregateParticleSystemComponent::PendingReset' has a wrong offset!");

// Class DeadByDaylight.BloodwebGenerator
// 0x00D0 (0x0100 - 0x0030)
class alignas(0x10) UBloodwebGenerator final : public UObject
{
public:
	uint8                                         Pad_30[0xC];                                       // 0x0030(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomStream                          _randomizationStream;                              // 0x003C(0x0008)(ZeroConstructor, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         _selectedNodes;                                    // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _selectedContent;                                  // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x48];                                      // 0x0068(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IDBDBloodwebDefinitionBase> _bloodWebDefinition;                          // 0x00B0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UDBDDesignTunables*                     _designTunables;                                   // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodwebTunables*                      _bloodwebTunables;                                 // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _alternativePathOccurenceFactor;                   // 0x00D0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodwebDistribution*                  _dataDistribution;                                 // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodwebSettings*                      _bloodwebSettings;                                 // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebGenerator">();
	}
	static class UBloodwebGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebGenerator>();
	}
};
static_assert(alignof(UBloodwebGenerator) == 0x000010, "Wrong alignment on UBloodwebGenerator");
static_assert(sizeof(UBloodwebGenerator) == 0x000100, "Wrong size on UBloodwebGenerator");
static_assert(offsetof(UBloodwebGenerator, _randomizationStream) == 0x00003C, "Member 'UBloodwebGenerator::_randomizationStream' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _selectedNodes) == 0x000048, "Member 'UBloodwebGenerator::_selectedNodes' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _selectedContent) == 0x000058, "Member 'UBloodwebGenerator::_selectedContent' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _bloodWebDefinition) == 0x0000B0, "Member 'UBloodwebGenerator::_bloodWebDefinition' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _designTunables) == 0x0000C0, "Member 'UBloodwebGenerator::_designTunables' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _bloodwebTunables) == 0x0000C8, "Member 'UBloodwebGenerator::_bloodwebTunables' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _alternativePathOccurenceFactor) == 0x0000D0, "Member 'UBloodwebGenerator::_alternativePathOccurenceFactor' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _dataDistribution) == 0x0000D8, "Member 'UBloodwebGenerator::_dataDistribution' has a wrong offset!");
static_assert(offsetof(UBloodwebGenerator, _bloodwebSettings) == 0x0000E0, "Member 'UBloodwebGenerator::_bloodwebSettings' has a wrong offset!");

// Class DeadByDaylight.BloodwebHandler
// 0x0068 (0x0098 - 0x0030)
class UBloodwebHandler final : public UObject
{
public:
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebHandler">();
	}
	static class UBloodwebHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebHandler>();
	}
};
static_assert(alignof(UBloodwebHandler) == 0x000008, "Wrong alignment on UBloodwebHandler");
static_assert(sizeof(UBloodwebHandler) == 0x000098, "Wrong size on UBloodwebHandler");

// Class DeadByDaylight.DailyRitualsScreen
// 0x0060 (0x0180 - 0x0120)
class UDailyRitualsScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0x60];                                     // 0x0120(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnClaimAllRituals();
	void OnClaimRitual(const class FString& id);
	void OnClosed();
	void OnRemoveRitual(const class FString& id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DailyRitualsScreen">();
	}
	static class UDailyRitualsScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDailyRitualsScreen>();
	}
};
static_assert(alignof(UDailyRitualsScreen) == 0x000008, "Wrong alignment on UDailyRitualsScreen");
static_assert(sizeof(UDailyRitualsScreen) == 0x000180, "Wrong size on UDailyRitualsScreen");

// Class DeadByDaylight.BloodwebManager
// 0x01B8 (0x01E8 - 0x0030)
class UBloodwebManager final : public UObject
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBloodwebGenerator>         _bloodwebBuilderClass;                             // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0080(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDDesignTunables*                     _designTunables;                                   // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseBloodwebContentAdapter*            _bloodWebContentAdapter;                           // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodwebHandler*                       _bloodwebHandler;                                  // 0x0098(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodwebPathfinder*                    _bloodwebPathfinder;                               // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x140];                                     // 0x00A8(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(class UDBDGameInstance* gameInstance, class UDBDDesignTunables* tunables);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebManager">();
	}
	static class UBloodwebManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebManager>();
	}
};
static_assert(alignof(UBloodwebManager) == 0x000008, "Wrong alignment on UBloodwebManager");
static_assert(sizeof(UBloodwebManager) == 0x0001E8, "Wrong size on UBloodwebManager");
static_assert(offsetof(UBloodwebManager, _bloodwebBuilderClass) == 0x000078, "Member 'UBloodwebManager::_bloodwebBuilderClass' has a wrong offset!");
static_assert(offsetof(UBloodwebManager, _gameInstance) == 0x000080, "Member 'UBloodwebManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(UBloodwebManager, _designTunables) == 0x000088, "Member 'UBloodwebManager::_designTunables' has a wrong offset!");
static_assert(offsetof(UBloodwebManager, _bloodWebContentAdapter) == 0x000090, "Member 'UBloodwebManager::_bloodWebContentAdapter' has a wrong offset!");
static_assert(offsetof(UBloodwebManager, _bloodwebHandler) == 0x000098, "Member 'UBloodwebManager::_bloodwebHandler' has a wrong offset!");
static_assert(offsetof(UBloodwebManager, _bloodwebPathfinder) == 0x0000A0, "Member 'UBloodwebManager::_bloodwebPathfinder' has a wrong offset!");

// Class DeadByDaylight.BloodwebPathfinder
// 0x0018 (0x0048 - 0x0030)
class UBloodwebPathfinder final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebPathfinder">();
	}
	static class UBloodwebPathfinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebPathfinder>();
	}
};
static_assert(alignof(UBloodwebPathfinder) == 0x000008, "Wrong alignment on UBloodwebPathfinder");
static_assert(sizeof(UBloodwebPathfinder) == 0x000048, "Wrong size on UBloodwebPathfinder");

// Class DeadByDaylight.DBDAIPlayerController
// 0x0028 (0x0610 - 0x05E8)
class ADBDAIPlayerController final : public ADBDAIController
{
public:
	uint8                                         Pad_5E8[0x18];                                     // 0x05E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAICharacterBehaviour*>          _currentBehaviours;                                // 0x0600(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void MovePlayerToActor(class AActor* goal, float acceptanceRadius);
	void OnBehaviourEndedHandler(class UAICharacterBehaviour* behaviourEnded);
	void PauseCharacterBehaviour(const class UClass* behaviourClass);
	void ResumeCharacterBehaviour(const class UClass* behaviourClass);
	void StartCharacterBehaviour(class UClass* behaviourClass, class UAICharacterBehaviourData* characterBehaviourData);
	void StopAllCharacterBehaviours();
	void StopCharacterBehaviour(const class UClass* behaviourClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAIPlayerController">();
	}
	static class ADBDAIPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDAIPlayerController>();
	}
};
static_assert(alignof(ADBDAIPlayerController) == 0x000008, "Wrong alignment on ADBDAIPlayerController");
static_assert(sizeof(ADBDAIPlayerController) == 0x000610, "Wrong size on ADBDAIPlayerController");
static_assert(offsetof(ADBDAIPlayerController, _currentBehaviours) == 0x000600, "Member 'ADBDAIPlayerController::_currentBehaviours' has a wrong offset!");

// Class DeadByDaylight.BloodwebSettings
// 0x0010 (0x0048 - 0x0038)
class UBloodwebSettings final : public UDataAsset
{
public:
	TArray<class FName>                           _duplicableItems;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodwebSettings">();
	}
	static class UBloodwebSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodwebSettings>();
	}
};
static_assert(alignof(UBloodwebSettings) == 0x000008, "Wrong alignment on UBloodwebSettings");
static_assert(sizeof(UBloodwebSettings) == 0x000048, "Wrong size on UBloodwebSettings");
static_assert(offsetof(UBloodwebSettings, _duplicableItems) == 0x000038, "Member 'UBloodwebSettings::_duplicableItems' has a wrong offset!");

// Class DeadByDaylight.BlueprintDebugUtilities
// 0x0000 (0x0030 - 0x0030)
class UBlueprintDebugUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void EnsureFalseWithMessage(const class FString& ensureMessage);
	static void EnsureOnConditionWithMessage(const bool condition, const class FString& ensureMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintDebugUtilities">();
	}
	static class UBlueprintDebugUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintDebugUtilities>();
	}
};
static_assert(alignof(UBlueprintDebugUtilities) == 0x000008, "Wrong alignment on UBlueprintDebugUtilities");
static_assert(sizeof(UBlueprintDebugUtilities) == 0x000030, "Wrong size on UBlueprintDebugUtilities");

// Class DeadByDaylight.SlasherHitsWhileCarryingTrackerComponent
// 0x0068 (0x0120 - 0x00B8)
class USlasherHitsWhileCarryingTrackerComponent final : public UActorComponent
{
public:
	TSet<class ACamperPlayer*>                    _campersHitDuringLastCarry;                        // 0x00B8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttack(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void OnPickup(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void OnPostAttack(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherHitsWhileCarryingTrackerComponent">();
	}
	static class USlasherHitsWhileCarryingTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherHitsWhileCarryingTrackerComponent>();
	}
};
static_assert(alignof(USlasherHitsWhileCarryingTrackerComponent) == 0x000008, "Wrong alignment on USlasherHitsWhileCarryingTrackerComponent");
static_assert(sizeof(USlasherHitsWhileCarryingTrackerComponent) == 0x000120, "Wrong size on USlasherHitsWhileCarryingTrackerComponent");
static_assert(offsetof(USlasherHitsWhileCarryingTrackerComponent, _campersHitDuringLastCarry) == 0x0000B8, "Member 'USlasherHitsWhileCarryingTrackerComponent::_campersHitDuringLastCarry' has a wrong offset!");

// Class DeadByDaylight.UmgPlayerHud
// 0x02C8 (0x0560 - 0x0298)
class UUmgPlayerHud : public UUserWidget
{
public:
	class UCanvasPanel*                           GameStartingPanel;                                 // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           InGamePanel;                                       // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAtlantaSkillCheckWidget*               SkillCheckWidget;                                  // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGMapThemeWidget*                     MapThemeWidget;                                    // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGAlertsWidget*                       AtlantaAlertsWidget;                               // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGObjectivesWidget*                   AtlantaObjectivesWidget;                           // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPerkHudWidget*                         AtlantaPerksWidget;                                // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPerkActionButton*                      ActivablePerkActionButton;                         // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGStatusEffectsWidget*                AtlantaStatusEffectsWidget;                        // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGChargeableInteractionWidget*        AtlantaInteractionWidget;                          // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAtlantaPromptWidget*                   AtlantaPromptWidget;                               // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAtlantaPromptWidget*                   AtlantaTutorialPromptWidget;                       // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGPlayersStatusWidget*                AtlantaPlayersStatusWidget;                        // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           AtlantaObjectivesContainer;                        // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActionButton*                          ActionButton;                                      // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           ActionButtonContainer;                             // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPerkSoundHudWidget*                    PerkSoundHudWidget;                                // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMobileBaseUserWidget*                  CenterInteractionButton;                           // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           CenterInteractionContainer;                        // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           CancelButtonContainer;                             // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGEndGameCollapseWidget*              EndGameCollapseWidget;                             // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName perkId, bool clickedOnPerksWidget)> OnPerkClickedEvent; // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTutorialLeaveClickedEvent;                       // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnTutorialNextClickedEvent;                        // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSettingsClickedEvent;                            // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ADBDPlayerController*                   LocalController;                                   // 0x0380(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAtlantaHudDirectionalStick*            AtlantaDirectionalStick;                           // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           AtlantaDirectionalStickContainer;                  // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDPlayer*                             _localPlayer;                                      // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            _unlockedVirtualJoystickThumbImage;                // 0x03A8(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _lockedVirtualJoystickThumbImage;                  // 0x0438(0x0090)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x98];                                     // 0x04C8(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInitializeHUD();
	void OnInteractionEnded(class UInteractionDefinition* interaction);
	void OnInteractionStarted(class UInteractionDefinition* interaction);
	void OnPerkClicked(class FName perkID, bool clickedOnPerksWidget);
	void OnSettingsButtonPressed();
	void SetVirtualJoystickThumbImage(bool locked);
	void TutorialTallyLeaveSelected();
	void TutorialTallyNextSelected();

	class UInteractionDefinition* GetCurrentOrAvailableInteractionOfType(EInputInteractionType interactionInputType) const;
	struct FSlateBrush GetInteractionIconByType(EInputInteractionType interactionInputType) const;
	bool IsInitialized() const;
	bool IsInteractionAllowed(class UInteractionDefinition* interaction) const;
	bool IsInteractionAvailable(EInputInteractionType interactionType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UmgPlayerHud">();
	}
	static class UUmgPlayerHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUmgPlayerHud>();
	}
};
static_assert(alignof(UUmgPlayerHud) == 0x000008, "Wrong alignment on UUmgPlayerHud");
static_assert(sizeof(UUmgPlayerHud) == 0x000560, "Wrong size on UUmgPlayerHud");
static_assert(offsetof(UUmgPlayerHud, GameStartingPanel) == 0x000298, "Member 'UUmgPlayerHud::GameStartingPanel' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, InGamePanel) == 0x0002A0, "Member 'UUmgPlayerHud::InGamePanel' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, SkillCheckWidget) == 0x0002A8, "Member 'UUmgPlayerHud::SkillCheckWidget' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, MapThemeWidget) == 0x0002B0, "Member 'UUmgPlayerHud::MapThemeWidget' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, AtlantaAlertsWidget) == 0x0002B8, "Member 'UUmgPlayerHud::AtlantaAlertsWidget' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, AtlantaObjectivesWidget) == 0x0002C0, "Member 'UUmgPlayerHud::AtlantaObjectivesWidget' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, AtlantaPerksWidget) == 0x0002C8, "Member 'UUmgPlayerHud::AtlantaPerksWidget' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, ActivablePerkActionButton) == 0x0002D0, "Member 'UUmgPlayerHud::ActivablePerkActionButton' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, AtlantaStatusEffectsWidget) == 0x0002D8, "Member 'UUmgPlayerHud::AtlantaStatusEffectsWidget' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, AtlantaInteractionWidget) == 0x0002E0, "Member 'UUmgPlayerHud::AtlantaInteractionWidget' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, AtlantaPromptWidget) == 0x0002E8, "Member 'UUmgPlayerHud::AtlantaPromptWidget' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, AtlantaTutorialPromptWidget) == 0x0002F0, "Member 'UUmgPlayerHud::AtlantaTutorialPromptWidget' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, AtlantaPlayersStatusWidget) == 0x0002F8, "Member 'UUmgPlayerHud::AtlantaPlayersStatusWidget' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, AtlantaObjectivesContainer) == 0x000300, "Member 'UUmgPlayerHud::AtlantaObjectivesContainer' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, ActionButton) == 0x000308, "Member 'UUmgPlayerHud::ActionButton' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, ActionButtonContainer) == 0x000310, "Member 'UUmgPlayerHud::ActionButtonContainer' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, PerkSoundHudWidget) == 0x000318, "Member 'UUmgPlayerHud::PerkSoundHudWidget' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, CenterInteractionButton) == 0x000320, "Member 'UUmgPlayerHud::CenterInteractionButton' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, CenterInteractionContainer) == 0x000328, "Member 'UUmgPlayerHud::CenterInteractionContainer' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, CancelButtonContainer) == 0x000330, "Member 'UUmgPlayerHud::CancelButtonContainer' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, EndGameCollapseWidget) == 0x000338, "Member 'UUmgPlayerHud::EndGameCollapseWidget' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, OnPerkClickedEvent) == 0x000340, "Member 'UUmgPlayerHud::OnPerkClickedEvent' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, OnTutorialLeaveClickedEvent) == 0x000350, "Member 'UUmgPlayerHud::OnTutorialLeaveClickedEvent' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, OnTutorialNextClickedEvent) == 0x000360, "Member 'UUmgPlayerHud::OnTutorialNextClickedEvent' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, OnSettingsClickedEvent) == 0x000370, "Member 'UUmgPlayerHud::OnSettingsClickedEvent' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, LocalController) == 0x000380, "Member 'UUmgPlayerHud::LocalController' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, AtlantaDirectionalStick) == 0x000388, "Member 'UUmgPlayerHud::AtlantaDirectionalStick' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, AtlantaDirectionalStickContainer) == 0x000390, "Member 'UUmgPlayerHud::AtlantaDirectionalStickContainer' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, _localPlayer) == 0x000398, "Member 'UUmgPlayerHud::_localPlayer' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, _unlockedVirtualJoystickThumbImage) == 0x0003A8, "Member 'UUmgPlayerHud::_unlockedVirtualJoystickThumbImage' has a wrong offset!");
static_assert(offsetof(UUmgPlayerHud, _lockedVirtualJoystickThumbImage) == 0x000438, "Member 'UUmgPlayerHud::_lockedVirtualJoystickThumbImage' has a wrong offset!");

// Class DeadByDaylight.UmgPlayableHud
// 0x0000 (0x0560 - 0x0560)
class UUmgPlayableHud : public UUmgPlayerHud
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UmgPlayableHud">();
	}
	static class UUmgPlayableHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUmgPlayableHud>();
	}
};
static_assert(alignof(UUmgPlayableHud) == 0x000008, "Wrong alignment on UUmgPlayableHud");
static_assert(sizeof(UUmgPlayableHud) == 0x000560, "Wrong size on UUmgPlayableHud");

// Class DeadByDaylight.UmgSurvivorHud
// 0x0300 (0x0860 - 0x0560)
class UUmgSurvivorHud final : public UUmgPlayableHud
{
public:
	uint8                                         Pad_560[0x8];                                      // 0x0560(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UActionButton*                          CrouchButton;                                      // 0x0568(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CrouchButtonContainer;                             // 0x0570(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWiggleWidget*                          StruggleWidget;                                    // 0x0578(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           StruggleWidgetContainer;                           // 0x0580(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWiggleWidget*                          WiggleWidget;                                      // 0x0588(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           WiggleWidgetContainer;                             // 0x0590(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACamperPlayer*                          Survivor;                                          // 0x0598(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActionButton*                          CancelButton;                                      // 0x05A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CenterInteractionButtonContainer;                  // 0x05A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           LookBackButtonContainer;                           // 0x05B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAtlantaHudLookBackJoystick*            LookBackJoystick;                                  // 0x05B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActionButton*                          SkillCheckButton;                                  // 0x05C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           SkillCheckButtonCanvas;                            // 0x05C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           InsaneSkillCheckButtonCanvas;                      // 0x05D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            _unpressedLookBackJoystickThumbImage;              // 0x05E0(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _pressedLookBackJoystickThumbImage;                // 0x0670(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_700[0x20];                                     // 0x0700(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            _unpressedLookBackJoystickBackgroundImage;         // 0x0720(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FSlateBrush                            _pressedLookBackJoystickBackgroundImage;           // 0x07B0(0x0090)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_840[0x20];                                     // 0x0840(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CenterItemClicked(bool fromCancelRequest);
	bool GetLookBackJoystickIsPressed();
	struct FVector2D GetLookBackJoystickNormalizedOffset();
	void InitializeLookBackJoystickPosition();
	void OnCancelButtonClicked();
	void RespondToVirtualJoystickPressChanged(int32 controlIndex, bool pressed);
	void SetLookBackJoystickImage(bool pressed);
	void SetLookBackJoystickPosition(struct FVector2D& position);
	void SetNonRestrictedControlsVisibility(bool visible);
	void SetSkillCheckButtonPosition(bool isInsane);
	void UpdateCancelButton();

	class UTexture2D* GetCenterItemIcon() const;
	const class FText GetCenterItemText() const;
	bool HasSecondaryActionAvailable() const;
	bool ShouldUseContextualItemButton() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UmgSurvivorHud">();
	}
	static class UUmgSurvivorHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUmgSurvivorHud>();
	}
};
static_assert(alignof(UUmgSurvivorHud) == 0x000008, "Wrong alignment on UUmgSurvivorHud");
static_assert(sizeof(UUmgSurvivorHud) == 0x000860, "Wrong size on UUmgSurvivorHud");
static_assert(offsetof(UUmgSurvivorHud, CrouchButton) == 0x000568, "Member 'UUmgSurvivorHud::CrouchButton' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, CrouchButtonContainer) == 0x000570, "Member 'UUmgSurvivorHud::CrouchButtonContainer' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, StruggleWidget) == 0x000578, "Member 'UUmgSurvivorHud::StruggleWidget' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, StruggleWidgetContainer) == 0x000580, "Member 'UUmgSurvivorHud::StruggleWidgetContainer' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, WiggleWidget) == 0x000588, "Member 'UUmgSurvivorHud::WiggleWidget' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, WiggleWidgetContainer) == 0x000590, "Member 'UUmgSurvivorHud::WiggleWidgetContainer' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, Survivor) == 0x000598, "Member 'UUmgSurvivorHud::Survivor' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, CancelButton) == 0x0005A0, "Member 'UUmgSurvivorHud::CancelButton' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, CenterInteractionButtonContainer) == 0x0005A8, "Member 'UUmgSurvivorHud::CenterInteractionButtonContainer' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, LookBackButtonContainer) == 0x0005B0, "Member 'UUmgSurvivorHud::LookBackButtonContainer' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, LookBackJoystick) == 0x0005B8, "Member 'UUmgSurvivorHud::LookBackJoystick' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, SkillCheckButton) == 0x0005C0, "Member 'UUmgSurvivorHud::SkillCheckButton' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, SkillCheckButtonCanvas) == 0x0005C8, "Member 'UUmgSurvivorHud::SkillCheckButtonCanvas' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, InsaneSkillCheckButtonCanvas) == 0x0005D0, "Member 'UUmgSurvivorHud::InsaneSkillCheckButtonCanvas' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, _unpressedLookBackJoystickThumbImage) == 0x0005E0, "Member 'UUmgSurvivorHud::_unpressedLookBackJoystickThumbImage' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, _pressedLookBackJoystickThumbImage) == 0x000670, "Member 'UUmgSurvivorHud::_pressedLookBackJoystickThumbImage' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, _unpressedLookBackJoystickBackgroundImage) == 0x000720, "Member 'UUmgSurvivorHud::_unpressedLookBackJoystickBackgroundImage' has a wrong offset!");
static_assert(offsetof(UUmgSurvivorHud, _pressedLookBackJoystickBackgroundImage) == 0x0007B0, "Member 'UUmgSurvivorHud::_pressedLookBackJoystickBackgroundImage' has a wrong offset!");

// Class DeadByDaylight.DBDAtlantaTutorialParameters
// 0x0008 (0x0038 - 0x0030)
class UDBDAtlantaTutorialParameters final : public UObject
{
public:
	float                                         SurvTutorial_WiggleChargeRateMultiplier;           // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAtlantaTutorialParameters">();
	}
	static class UDBDAtlantaTutorialParameters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAtlantaTutorialParameters>();
	}
};
static_assert(alignof(UDBDAtlantaTutorialParameters) == 0x000008, "Wrong alignment on UDBDAtlantaTutorialParameters");
static_assert(sizeof(UDBDAtlantaTutorialParameters) == 0x000038, "Wrong size on UDBDAtlantaTutorialParameters");
static_assert(offsetof(UDBDAtlantaTutorialParameters, SurvTutorial_WiggleChargeRateMultiplier) == 0x000030, "Member 'UDBDAtlantaTutorialParameters::SurvTutorial_WiggleChargeRateMultiplier' has a wrong offset!");

// Class DeadByDaylight.BlueprintPlatformUtilities
// 0x0000 (0x0030 - 0x0030)
class UBlueprintPlatformUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float ToFloat(const struct FDBDPerPlatformFloat& perPlatformFloat, const class UObject* objectInWorld);
	static int32 ToInteger(const struct FDBDPerPlatformInt& perPlatformInt, const class UObject* objectInWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintPlatformUtilities">();
	}
	static class UBlueprintPlatformUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintPlatformUtilities>();
	}
};
static_assert(alignof(UBlueprintPlatformUtilities) == 0x000008, "Wrong alignment on UBlueprintPlatformUtilities");
static_assert(sizeof(UBlueprintPlatformUtilities) == 0x000030, "Wrong size on UBlueprintPlatformUtilities");

// Class DeadByDaylight.DBDAtlantaBloodwebDefinition
// 0x0110 (0x0140 - 0x0030)
class UDBDAtlantaBloodwebDefinition final : public UObject
{
public:
	uint8                                         Pad_30[0x110];                                     // 0x0030(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAtlantaBloodwebDefinition">();
	}
	static class UDBDAtlantaBloodwebDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAtlantaBloodwebDefinition>();
	}
};
static_assert(alignof(UDBDAtlantaBloodwebDefinition) == 0x000008, "Wrong alignment on UDBDAtlantaBloodwebDefinition");
static_assert(sizeof(UDBDAtlantaBloodwebDefinition) == 0x000140, "Wrong size on UDBDAtlantaBloodwebDefinition");

// Class DeadByDaylight.ReverseBearTrapUtilities
// 0x0000 (0x0030 - 0x0030)
class UReverseBearTrapUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class AReverseBearTrap* GetAttachedRBT(class ADBDPlayer* player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReverseBearTrapUtilities">();
	}
	static class UReverseBearTrapUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReverseBearTrapUtilities>();
	}
};
static_assert(alignof(UReverseBearTrapUtilities) == 0x000008, "Wrong alignment on UReverseBearTrapUtilities");
static_assert(sizeof(UReverseBearTrapUtilities) == 0x000030, "Wrong size on UReverseBearTrapUtilities");

// Class DeadByDaylight.BorderTile
// 0x0020 (0x0368 - 0x0348)
class ABorderTile final : public ATile
{
public:
	TArray<struct FBorderElements>                Borders;                                           // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UMapData*                               _map;                                              // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BorderTile">();
	}
	static class ABorderTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABorderTile>();
	}
};
static_assert(alignof(ABorderTile) == 0x000008, "Wrong alignment on ABorderTile");
static_assert(sizeof(ABorderTile) == 0x000368, "Wrong size on ABorderTile");
static_assert(offsetof(ABorderTile, Borders) == 0x000348, "Member 'ABorderTile::Borders' has a wrong offset!");
static_assert(offsetof(ABorderTile, _map) == 0x000358, "Member 'ABorderTile::_map' has a wrong offset!");

// Class DeadByDaylight.BreakableBase
// 0x0028 (0x0350 - 0x0328)
class ABreakableBase final : public AInteractable
{
public:
	class UBoxComponent*                          _breakableCollision;                               // 0x0328(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBreakableState                               _state;                                            // 0x0330(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           _akAudioBreakable;                                 // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _akAudioBreakEvent;                                // 0x0340(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootComponent;                                    // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Explode(class ADBDPlayer* player);
	void ExplodeVfxSfx(const struct FVector& impulseDir);
	void PlayAudioBreakable();

	bool IsUnbroken() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreakableBase">();
	}
	static class ABreakableBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABreakableBase>();
	}
};
static_assert(alignof(ABreakableBase) == 0x000008, "Wrong alignment on ABreakableBase");
static_assert(sizeof(ABreakableBase) == 0x000350, "Wrong size on ABreakableBase");
static_assert(offsetof(ABreakableBase, _breakableCollision) == 0x000328, "Member 'ABreakableBase::_breakableCollision' has a wrong offset!");
static_assert(offsetof(ABreakableBase, _state) == 0x000330, "Member 'ABreakableBase::_state' has a wrong offset!");
static_assert(offsetof(ABreakableBase, _akAudioBreakable) == 0x000338, "Member 'ABreakableBase::_akAudioBreakable' has a wrong offset!");
static_assert(offsetof(ABreakableBase, _akAudioBreakEvent) == 0x000340, "Member 'ABreakableBase::_akAudioBreakEvent' has a wrong offset!");
static_assert(offsetof(ABreakableBase, _rootComponent) == 0x000348, "Member 'ABreakableBase::_rootComponent' has a wrong offset!");

// Class DeadByDaylight.BreakableWallOutlineUpdateStrategy
// 0x0000 (0x0138 - 0x0138)
class UBreakableWallOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreakableWallOutlineUpdateStrategy">();
	}
	static class UBreakableWallOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBreakableWallOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UBreakableWallOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UBreakableWallOutlineUpdateStrategy");
static_assert(sizeof(UBreakableWallOutlineUpdateStrategy) == 0x000138, "Wrong size on UBreakableWallOutlineUpdateStrategy");

// Class DeadByDaylight.AtlantaRitualEvaluatorBase
// 0x0000 (0x0030 - 0x0030)
class UAtlantaRitualEvaluatorBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaRitualEvaluatorBase">();
	}
	static class UAtlantaRitualEvaluatorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaRitualEvaluatorBase>();
	}
};
static_assert(alignof(UAtlantaRitualEvaluatorBase) == 0x000008, "Wrong alignment on UAtlantaRitualEvaluatorBase");
static_assert(sizeof(UAtlantaRitualEvaluatorBase) == 0x000030, "Wrong size on UAtlantaRitualEvaluatorBase");

// Class DeadByDaylight.AtlantaRitualEvaluatorInvalid
// 0x0000 (0x0030 - 0x0030)
class UAtlantaRitualEvaluatorInvalid final : public UAtlantaRitualEvaluatorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaRitualEvaluatorInvalid">();
	}
	static class UAtlantaRitualEvaluatorInvalid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaRitualEvaluatorInvalid>();
	}
};
static_assert(alignof(UAtlantaRitualEvaluatorInvalid) == 0x000008, "Wrong alignment on UAtlantaRitualEvaluatorInvalid");
static_assert(sizeof(UAtlantaRitualEvaluatorInvalid) == 0x000030, "Wrong size on UAtlantaRitualEvaluatorInvalid");

// Class DeadByDaylight.BubbleIndicator
// 0x0008 (0x0238 - 0x0230)
class ABubbleIndicator final : public AActor
{
public:
	float                                         _lifeTime;                                         // 0x0230(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _displayToLocallyObserved;                         // 0x0234(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInRange;                                        // 0x0235(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPreSpawned;                                     // 0x0236(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_237[0x1];                                      // 0x0237(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateBubbleFX(const float duration);
	void DeactivateBubble();
	void SetSilhouette(class UStaticMesh* staticMesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BubbleIndicator">();
	}
	static class ABubbleIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABubbleIndicator>();
	}
};
static_assert(alignof(ABubbleIndicator) == 0x000008, "Wrong alignment on ABubbleIndicator");
static_assert(sizeof(ABubbleIndicator) == 0x000238, "Wrong size on ABubbleIndicator");
static_assert(offsetof(ABubbleIndicator, _lifeTime) == 0x000230, "Member 'ABubbleIndicator::_lifeTime' has a wrong offset!");
static_assert(offsetof(ABubbleIndicator, _displayToLocallyObserved) == 0x000234, "Member 'ABubbleIndicator::_displayToLocallyObserved' has a wrong offset!");
static_assert(offsetof(ABubbleIndicator, _isInRange) == 0x000235, "Member 'ABubbleIndicator::_isInRange' has a wrong offset!");
static_assert(offsetof(ABubbleIndicator, _isPreSpawned) == 0x000236, "Member 'ABubbleIndicator::_isPreSpawned' has a wrong offset!");

// Class DeadByDaylight.BubbleIndicatorNotifier
// 0x0000 (0x0030 - 0x0030)
class UBubbleIndicatorNotifier final : public UBlueprintFunctionLibrary
{
public:
	static void ActivateBubbleIndicator(class UObject* worldContextObject, class ABubbleIndicator* bubbleIndicator, const struct FTransform& transform, bool triggerLoudNoise, float lifetime, float audibleRange);
	static class ABubbleIndicator* PreSpawnBubbleIndicator(class UObject* worldContextObject, TSubclassOf<class ABubbleIndicator> bubbleIndicatorBP, class UStaticMesh* silhouetteStaticMesh);
	static void SpawnBubbleIndicator(class UObject* worldContextObject, TSubclassOf<class ABubbleIndicator> bubbleIndicatorBP, const struct FTransform& transform, bool triggerLoudNoise, bool spawnOnKillerSideOnly, float lifetime, class UStaticMesh* silhouetteStaticMesh, float audibleRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BubbleIndicatorNotifier">();
	}
	static class UBubbleIndicatorNotifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBubbleIndicatorNotifier>();
	}
};
static_assert(alignof(UBubbleIndicatorNotifier) == 0x000008, "Wrong alignment on UBubbleIndicatorNotifier");
static_assert(sizeof(UBubbleIndicatorNotifier) == 0x000030, "Wrong size on UBubbleIndicatorNotifier");

// Class DeadByDaylight.SoftBanManager
// 0x0040 (0x0070 - 0x0030)
class USoftBanManager final : public UObject
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoftBanManager">();
	}
	static class USoftBanManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoftBanManager>();
	}
};
static_assert(alignof(USoftBanManager) == 0x000008, "Wrong alignment on USoftBanManager");
static_assert(sizeof(USoftBanManager) == 0x000070, "Wrong size on USoftBanManager");

// Class DeadByDaylight.UMGTallyEmblemMarker
// 0x0058 (0x0390 - 0x0338)
class UUMGTallyEmblemMarker final : public UMobileBaseUserWidget
{
public:
	class UImage*                                 QualityImage;                                      // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EEmblemQuality, struct FEmblemQualityImages> _qualityImages;                                // 0x0340(0x0050)(Edit, DisableEditOnInstance, NoClear, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyEmblemMarker">();
	}
	static class UUMGTallyEmblemMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyEmblemMarker>();
	}
};
static_assert(alignof(UUMGTallyEmblemMarker) == 0x000008, "Wrong alignment on UUMGTallyEmblemMarker");
static_assert(sizeof(UUMGTallyEmblemMarker) == 0x000390, "Wrong size on UUMGTallyEmblemMarker");
static_assert(offsetof(UUMGTallyEmblemMarker, QualityImage) == 0x000338, "Member 'UUMGTallyEmblemMarker::QualityImage' has a wrong offset!");
static_assert(offsetof(UUMGTallyEmblemMarker, _qualityImages) == 0x000340, "Member 'UUMGTallyEmblemMarker::_qualityImages' has a wrong offset!");

// Class DeadByDaylight.CameraAttachmentComponent
// 0x00B0 (0x0168 - 0x00B8)
class UCameraAttachmentComponent final : public UActorComponent
{
public:
	class USceneComponent*                        _anchor;                                           // 0x00B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCameraAttachment                      _defaultCameraAttachment;                          // 0x00D0(0x0018)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FCameraAttachment                      _currentCameraAttachment;                          // 0x00E8(0x0018)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x68];                                     // 0x0100(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Detach();
	void Reset();

	bool IsAttached() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraAttachmentComponent">();
	}
	static class UCameraAttachmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraAttachmentComponent>();
	}
};
static_assert(alignof(UCameraAttachmentComponent) == 0x000008, "Wrong alignment on UCameraAttachmentComponent");
static_assert(sizeof(UCameraAttachmentComponent) == 0x000168, "Wrong size on UCameraAttachmentComponent");
static_assert(offsetof(UCameraAttachmentComponent, _anchor) == 0x0000B8, "Member 'UCameraAttachmentComponent::_anchor' has a wrong offset!");
static_assert(offsetof(UCameraAttachmentComponent, _defaultCameraAttachment) == 0x0000D0, "Member 'UCameraAttachmentComponent::_defaultCameraAttachment' has a wrong offset!");
static_assert(offsetof(UCameraAttachmentComponent, _currentCameraAttachment) == 0x0000E8, "Member 'UCameraAttachmentComponent::_currentCameraAttachment' has a wrong offset!");

// Class DeadByDaylight.CameraFadeComponent
// 0x0038 (0x00F0 - 0x00B8)
class UCameraFadeComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x38];                                      // 0x00B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFadedIn();
	void OnFadedOut();

	ECameraFadeState GetCameraFadeState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraFadeComponent">();
	}
	static class UCameraFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraFadeComponent>();
	}
};
static_assert(alignof(UCameraFadeComponent) == 0x000008, "Wrong alignment on UCameraFadeComponent");
static_assert(sizeof(UCameraFadeComponent) == 0x0000F0, "Wrong size on UCameraFadeComponent");

// Class DeadByDaylight.UMGStoreAuricCellButton
// 0x00A8 (0x0510 - 0x0468)
class UUMGStoreAuricCellButton final : public UUMGBaseButtonWidget
{
public:
	uint8                                         Pad_468[0x10];                                     // 0x0468(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurrencyPurchaseData                  CurrencyPurchaseData;                              // 0x0478(0x0068)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class UTextBlock*                             AuricCellTitleText;                                // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Timer;                                             // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F0[0x20];                                     // 0x04F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasBonusExpired(const struct FDateTime& endDate);
	void ReportInvalidPercentage(float percentage);
	void UpdateFirstPurchaseEndInUI(const class FString& endInString);
	void UpdateWidget(const int32 multiplier, const struct FDateTime& endDate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGStoreAuricCellButton">();
	}
	static class UUMGStoreAuricCellButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGStoreAuricCellButton>();
	}
};
static_assert(alignof(UUMGStoreAuricCellButton) == 0x000008, "Wrong alignment on UUMGStoreAuricCellButton");
static_assert(sizeof(UUMGStoreAuricCellButton) == 0x000510, "Wrong size on UUMGStoreAuricCellButton");
static_assert(offsetof(UUMGStoreAuricCellButton, CurrencyPurchaseData) == 0x000478, "Member 'UUMGStoreAuricCellButton::CurrencyPurchaseData' has a wrong offset!");
static_assert(offsetof(UUMGStoreAuricCellButton, AuricCellTitleText) == 0x0004E0, "Member 'UUMGStoreAuricCellButton::AuricCellTitleText' has a wrong offset!");
static_assert(offsetof(UUMGStoreAuricCellButton, Timer) == 0x0004E8, "Member 'UUMGStoreAuricCellButton::Timer' has a wrong offset!");

// Class DeadByDaylight.DBDAttackUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDAttackUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float GetCurrentAttackSubstateRemainingTime(const class AActor* attacker);
	static EAttackType GetCurrentAttackType(const class AActor* attacker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackUtilities">();
	}
	static class UDBDAttackUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackUtilities>();
	}
};
static_assert(alignof(UDBDAttackUtilities) == 0x000008, "Wrong alignment on UDBDAttackUtilities");
static_assert(sizeof(UDBDAttackUtilities) == 0x000030, "Wrong size on UDBDAttackUtilities");

// Class DeadByDaylight.CameraHandlerComponent
// 0x00F0 (0x01A8 - 0x00B8)
class UCameraHandlerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDBDCameraSocketID, class AActor*>       _cameraMap;                                        // 0x00D8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	EDBDCameraSocketID                            _delayedSocketID;                                  // 0x0128(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDBDCameraSocketID                            _currentSocketID;                                  // 0x0129(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12A[0x47];                                     // 0x012A(0x0047)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _manualZoomAllowPerkModifiers;                     // 0x0171(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_172[0x6];                                      // 0x0172(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _manualZoomCurveFloat;                             // 0x0178(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _cameraAttachmentSocket;                           // 0x0180(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _cameraAttachmentComponent;                        // 0x0190(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isFOVSystemActive;                                // 0x01A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCameraToSocket(EDBDCameraSocketID mode, class AActor* camera);
	class AActor* GetCurrentCamera();
	EDBDCameraSocketID GetSocketID();
	void PlayVFXOnCurrentCamera(class UParticleSystemComponent* component);
	void SetAttachmentComponent(class USceneComponent* attachmentComponent);
	void SetSocketID(EDBDCameraSocketID mode);

	float GetDesiredFOV() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraHandlerComponent">();
	}
	static class UCameraHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraHandlerComponent>();
	}
};
static_assert(alignof(UCameraHandlerComponent) == 0x000008, "Wrong alignment on UCameraHandlerComponent");
static_assert(sizeof(UCameraHandlerComponent) == 0x0001A8, "Wrong size on UCameraHandlerComponent");
static_assert(offsetof(UCameraHandlerComponent, _cameraMap) == 0x0000D8, "Member 'UCameraHandlerComponent::_cameraMap' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _delayedSocketID) == 0x000128, "Member 'UCameraHandlerComponent::_delayedSocketID' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _currentSocketID) == 0x000129, "Member 'UCameraHandlerComponent::_currentSocketID' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _manualZoomAllowPerkModifiers) == 0x000171, "Member 'UCameraHandlerComponent::_manualZoomAllowPerkModifiers' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _manualZoomCurveFloat) == 0x000178, "Member 'UCameraHandlerComponent::_manualZoomCurveFloat' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _cameraAttachmentSocket) == 0x000180, "Member 'UCameraHandlerComponent::_cameraAttachmentSocket' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _cameraAttachmentComponent) == 0x000190, "Member 'UCameraHandlerComponent::_cameraAttachmentComponent' has a wrong offset!");
static_assert(offsetof(UCameraHandlerComponent, _isFOVSystemActive) == 0x0001A0, "Member 'UCameraHandlerComponent::_isFOVSystemActive' has a wrong offset!");

// Class DeadByDaylight.PlayerNameRegistration
// 0x0068 (0x0098 - 0x0030)
class UPlayerNameRegistration final : public UObject
{
public:
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerNameRegistration">();
	}
	static class UPlayerNameRegistration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerNameRegistration>();
	}
};
static_assert(alignof(UPlayerNameRegistration) == 0x000008, "Wrong alignment on UPlayerNameRegistration");
static_assert(sizeof(UPlayerNameRegistration) == 0x000098, "Wrong size on UPlayerNameRegistration");

// Class DeadByDaylight.CameraOffsetController
// 0x0048 (0x0100 - 0x00B8)
class UCameraOffsetController final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x48];                                      // 0x00B8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOffsetController">();
	}
	static class UCameraOffsetController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOffsetController>();
	}
};
static_assert(alignof(UCameraOffsetController) == 0x000008, "Wrong alignment on UCameraOffsetController");
static_assert(sizeof(UCameraOffsetController) == 0x000100, "Wrong size on UCameraOffsetController");

// Class DeadByDaylight.DBDBaseInputHandler
// 0x00A8 (0x00D8 - 0x0030)
class UDBDBaseInputHandler : public UObject
{
public:
	class APawn*                                  _pawn;                                             // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    _cameraBoom;                                       // 0x0038(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x98];                                      // 0x0040(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseInputHandler">();
	}
	static class UDBDBaseInputHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBaseInputHandler>();
	}
};
static_assert(alignof(UDBDBaseInputHandler) == 0x000008, "Wrong alignment on UDBDBaseInputHandler");
static_assert(sizeof(UDBDBaseInputHandler) == 0x0000D8, "Wrong size on UDBDBaseInputHandler");
static_assert(offsetof(UDBDBaseInputHandler, _pawn) == 0x000030, "Member 'UDBDBaseInputHandler::_pawn' has a wrong offset!");
static_assert(offsetof(UDBDBaseInputHandler, _cameraBoom) == 0x000038, "Member 'UDBDBaseInputHandler::_cameraBoom' has a wrong offset!");

// Class DeadByDaylight.DBDAtlantaInputHandler
// 0x00D8 (0x01B0 - 0x00D8)
class UDBDAtlantaInputHandler final : public UDBDBaseInputHandler
{
public:
	uint8                                         Pad_D8[0xD8];                                      // 0x00D8(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetVirtualJoystickCenter(const int32 controlIndex, const struct FVector2D& controlCenter);

	struct FVector2D GetVirtualJoystickNormalizedOffset(const int32 controlIndex) const;
	struct FVector2D GetVirtualJoystickPosition(const int32 controlIndex) const;
	struct FVector2D GetVirtualJoystickVisualCenter(const int32 controlIndex) const;
	struct FVector2D GetVirtualJoystickVisualSize(const int32 controlIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAtlantaInputHandler">();
	}
	static class UDBDAtlantaInputHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAtlantaInputHandler>();
	}
};
static_assert(alignof(UDBDAtlantaInputHandler) == 0x000008, "Wrong alignment on UDBDAtlantaInputHandler");
static_assert(sizeof(UDBDAtlantaInputHandler) == 0x0001B0, "Wrong size on UDBDAtlantaInputHandler");

// Class DeadByDaylight.CamperBloodTrailComponent
// 0x0030 (0x0270 - 0x0240)
class UCamperBloodTrailComponent final : public UBloodTrailComponent
{
public:
	class UPerkManager*                           _camperPerkManager;                                // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x28];                                     // 0x0248(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDamageStateChanged(ECamperDamageState oldDamageState, ECamperDamageState currentDamageState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperBloodTrailComponent">();
	}
	static class UCamperBloodTrailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperBloodTrailComponent>();
	}
};
static_assert(alignof(UCamperBloodTrailComponent) == 0x000010, "Wrong alignment on UCamperBloodTrailComponent");
static_assert(sizeof(UCamperBloodTrailComponent) == 0x000270, "Wrong size on UCamperBloodTrailComponent");
static_assert(offsetof(UCamperBloodTrailComponent, _camperPerkManager) == 0x000240, "Member 'UCamperBloodTrailComponent::_camperPerkManager' has a wrong offset!");

// Class DeadByDaylight.CharacterDreamworldComponent
// 0x0050 (0x0108 - 0x00B8)
class UCharacterDreamworldComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(bool isInDreamworld, bool locallyObservedChanged)> DreamStateChanged; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     _mobileDreamworldPostProcessClass;                 // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _isInDreamworld;                                   // 0x00D0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APostProcessUpdate*                     _mobileDreamworldPostProcess;                      // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x28];                                      // 0x00E0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ADBDPlayer* GetLocallyObservedOrLocalCharacter(class UObject* WorldContextObject);

	void Authority_SetIsInDreamworld(bool newValue, bool isScripted);
	void FireWakeUpScoreEvent(class ADBDPlayer* instigator);
	void OnRep_IsInDreamworld(bool previous);

	bool IsInDreamworld() const;
	bool ShouldShowVignette() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterDreamworldComponent">();
	}
	static class UCharacterDreamworldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterDreamworldComponent>();
	}
};
static_assert(alignof(UCharacterDreamworldComponent) == 0x000008, "Wrong alignment on UCharacterDreamworldComponent");
static_assert(sizeof(UCharacterDreamworldComponent) == 0x000108, "Wrong size on UCharacterDreamworldComponent");
static_assert(offsetof(UCharacterDreamworldComponent, DreamStateChanged) == 0x0000B8, "Member 'UCharacterDreamworldComponent::DreamStateChanged' has a wrong offset!");
static_assert(offsetof(UCharacterDreamworldComponent, _mobileDreamworldPostProcessClass) == 0x0000C8, "Member 'UCharacterDreamworldComponent::_mobileDreamworldPostProcessClass' has a wrong offset!");
static_assert(offsetof(UCharacterDreamworldComponent, _isInDreamworld) == 0x0000D0, "Member 'UCharacterDreamworldComponent::_isInDreamworld' has a wrong offset!");
static_assert(offsetof(UCharacterDreamworldComponent, _mobileDreamworldPostProcess) == 0x0000D8, "Member 'UCharacterDreamworldComponent::_mobileDreamworldPostProcess' has a wrong offset!");

// Class DeadByDaylight.CamperDreamworldComponent
// 0x00E8 (0x01F0 - 0x0108)
class UCamperDreamworldComponent final : public UCharacterDreamworldComponent
{
public:
	TMulticastInlineDelegate<void(class ADBDPlayer* camper, class AActor* triggeredDreamTrap)> OnCamperTriggeredDreamTrap; // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FSurvivorSleepiness                    _survivorSleepiness;                               // 0x0118(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, Transient, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         _sleepinessProtectionRemainingDuration;            // 0x0120(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sleepGainPerSecond;                               // 0x0124(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x4];                                      // 0x0128(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _wakeUpByOtherCount;                               // 0x012C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _showKiller;                                       // 0x0130(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFastTimer                             _killerGlimpseDurationTimer;                       // 0x0138(0x0030)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFastTimer                             _killerGlimpseCooldownTimer;                       // 0x0178(0x0030)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8[0x10];                                     // 0x01A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _glimpseMinDistance;                               // 0x01B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _glimpseMaxDistance;                               // 0x01BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _killerGlimpseCooldown;                            // 0x01C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _killerGlimpseDuration;                            // 0x01C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _wakeUpBySkillCheckCount;                          // 0x01C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _fellAsleepCount;                                  // 0x01CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _forcedAsleep;                                     // 0x01D0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AWakerObject*                           _linkedWaker;                                      // 0x01D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _useScriptedKillerVisibility;                      // 0x01E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E1[0x7];                                      // 0x01E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _showKillerInstantly;                              // 0x01E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_HandleSkillCheckFailure(bool wakeUpEveryoneInteracting, class ADBDPlayer* instigator);
	void Authority_OnAttacked();
	void Authority_PutAsleep();
	void Authority_WakeUpByHook();
	void Authority_WakeUpByOther(class ADBDPlayer* instigator);
	void Authority_WakeUpByWakerObject();
	void BroadcastCamperTriggeredDreamTrap(class AActor* dreamObject);
	void HandleShowKillerChanged(bool showKiller, bool instantly);
	void InitializeTunableValues(class ASlasherPlayer* killer);
	void Local_SetShowKiller(bool showKiller, bool instantly);
	void OnRep_ShowKiller();
	void SetScriptedKillerVisibility(bool useScriptedKillerVisibility);

	int32 Authority_GetFellAsleepCount() const;
	int32 Authority_GetWakeUpBySkillCheckCount() const;
	void Authority_SpawnDreamworldStatusEffect() const;
	bool CanWakeUp() const;
	bool CanWakeUpBySkillCheck() const;
	int32 GetWakeUpByOtherCount() const;
	bool ShouldLookSleepyToLocalPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperDreamworldComponent">();
	}
	static class UCamperDreamworldComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperDreamworldComponent>();
	}
};
static_assert(alignof(UCamperDreamworldComponent) == 0x000008, "Wrong alignment on UCamperDreamworldComponent");
static_assert(sizeof(UCamperDreamworldComponent) == 0x0001F0, "Wrong size on UCamperDreamworldComponent");
static_assert(offsetof(UCamperDreamworldComponent, OnCamperTriggeredDreamTrap) == 0x000108, "Member 'UCamperDreamworldComponent::OnCamperTriggeredDreamTrap' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _survivorSleepiness) == 0x000118, "Member 'UCamperDreamworldComponent::_survivorSleepiness' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _sleepinessProtectionRemainingDuration) == 0x000120, "Member 'UCamperDreamworldComponent::_sleepinessProtectionRemainingDuration' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _sleepGainPerSecond) == 0x000124, "Member 'UCamperDreamworldComponent::_sleepGainPerSecond' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _wakeUpByOtherCount) == 0x00012C, "Member 'UCamperDreamworldComponent::_wakeUpByOtherCount' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _showKiller) == 0x000130, "Member 'UCamperDreamworldComponent::_showKiller' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _killerGlimpseDurationTimer) == 0x000138, "Member 'UCamperDreamworldComponent::_killerGlimpseDurationTimer' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _killerGlimpseCooldownTimer) == 0x000178, "Member 'UCamperDreamworldComponent::_killerGlimpseCooldownTimer' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _glimpseMinDistance) == 0x0001B8, "Member 'UCamperDreamworldComponent::_glimpseMinDistance' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _glimpseMaxDistance) == 0x0001BC, "Member 'UCamperDreamworldComponent::_glimpseMaxDistance' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _killerGlimpseCooldown) == 0x0001C0, "Member 'UCamperDreamworldComponent::_killerGlimpseCooldown' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _killerGlimpseDuration) == 0x0001C4, "Member 'UCamperDreamworldComponent::_killerGlimpseDuration' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _wakeUpBySkillCheckCount) == 0x0001C8, "Member 'UCamperDreamworldComponent::_wakeUpBySkillCheckCount' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _fellAsleepCount) == 0x0001CC, "Member 'UCamperDreamworldComponent::_fellAsleepCount' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _forcedAsleep) == 0x0001D0, "Member 'UCamperDreamworldComponent::_forcedAsleep' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _linkedWaker) == 0x0001D8, "Member 'UCamperDreamworldComponent::_linkedWaker' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _useScriptedKillerVisibility) == 0x0001E0, "Member 'UCamperDreamworldComponent::_useScriptedKillerVisibility' has a wrong offset!");
static_assert(offsetof(UCamperDreamworldComponent, _showKillerInstantly) == 0x0001E8, "Member 'UCamperDreamworldComponent::_showKillerInstantly' has a wrong offset!");

// Class DeadByDaylight.CamperEndGameComponent
// 0x0060 (0x0118 - 0x00B8)
class UCamperEndGameComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x48];                                      // 0x00B8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AEndGameEntity>             _endGameEntityClass;                               // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x4];                                      // 0x0108(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _delayBeforeSacrifice;                             // 0x010C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _readyToBeSacrificed;                              // 0x0110(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDelayBeforeSacrificeEnd();
	void OnEndGameSacrificeEnd();

	bool GetSacrificedByEndGame() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperEndGameComponent">();
	}
	static class UCamperEndGameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperEndGameComponent>();
	}
};
static_assert(alignof(UCamperEndGameComponent) == 0x000008, "Wrong alignment on UCamperEndGameComponent");
static_assert(sizeof(UCamperEndGameComponent) == 0x000118, "Wrong size on UCamperEndGameComponent");
static_assert(offsetof(UCamperEndGameComponent, _endGameEntityClass) == 0x000100, "Member 'UCamperEndGameComponent::_endGameEntityClass' has a wrong offset!");
static_assert(offsetof(UCamperEndGameComponent, _delayBeforeSacrifice) == 0x00010C, "Member 'UCamperEndGameComponent::_delayBeforeSacrifice' has a wrong offset!");
static_assert(offsetof(UCamperEndGameComponent, _readyToBeSacrificed) == 0x000110, "Member 'UCamperEndGameComponent::_readyToBeSacrificed' has a wrong offset!");

// Class DeadByDaylight.UMGPlayerStatusIcon
// 0x0278 (0x05B0 - 0x0338)
class UUMGPlayerStatusIcon final : public UMobileBaseUserWidget
{
public:
	class UProgressBar*                           HealthBar;                                         // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProgressBar*                           TimerBar;                                          // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           HealthBarContainer;                                // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           TimerBarContainer;                                 // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             PlayerName;                                        // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 StatusIconBloodTop;                                // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 StatusIconBloodBottom;                             // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 StatusIcon;                                        // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           ObsessionCanvas;                                   // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           BrokenIndicatorCanvas;                             // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           AfflictionCanvas;                                  // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           AfflictionIntroCanvas;                             // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           SleepStatusCanvas;                                 // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           SleepTimerCanvas;                                  // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           ReverseBearTrapCanvas;                             // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ReverseBearTrapArrow;                              // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           SicknessCanvas;                                    // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 SicknessFill;                                      // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           SpectateCanvas;                                    // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           SelectedSpectatorCanvas;                           // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           AgonyCanvas;                                       // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           HandsGrabbing;                                     // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SicknessFillHighOpacity;                           // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SicknessFillLowOpacity;                            // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           StatusEffectContainerCanvas;                       // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               SicknessFillMI;                                    // 0x03F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _hookedTexture;                                    // 0x0400(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _hookedBloodTexture;                               // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _trappedTexture;                                   // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _trappedBloodTexture;                              // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _deadTexture;                                      // 0x0420(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _deadBloodTexture;                                 // 0x0428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _escapedTexture;                                   // 0x0430(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _carriedTexture;                                   // 0x0438(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _injuredTexture;                                   // 0x0440(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _injuredBloodTexture;                              // 0x0448(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _crawlingTexture;                                  // 0x0450(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _crawlingBloodTexture;                             // 0x0458(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _sacrificedTexture;                                // 0x0460(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _sacrificedBloodTexture;                           // 0x0468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _disconnectedTexture;                              // 0x0470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _deathBedTexture;                                  // 0x0478(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             _defaultTexture;                                   // 0x0480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   UMGStalkingStatusEffectUIClass;                    // 0x0488(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   UMGLacerationStatusEffectUIClass;                  // 0x04B8(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _maxNumberCharacterInName;                         // 0x04E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4EC[0xB4];                                     // 0x04EC(0x00B4)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGStalkingStatusEffectUI*             _stalkingStatusEffectUI;                           // 0x05A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGLacerationStatusEffectUI*           _lacerationStatusEffectUI;                         // 0x05A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnPlayerStatusButtonClicked();
	void SetReverseTrapProgressionTimer(float seconds);
	void SetSleepingTimer(const float progress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPlayerStatusIcon">();
	}
	static class UUMGPlayerStatusIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPlayerStatusIcon>();
	}
};
static_assert(alignof(UUMGPlayerStatusIcon) == 0x000008, "Wrong alignment on UUMGPlayerStatusIcon");
static_assert(sizeof(UUMGPlayerStatusIcon) == 0x0005B0, "Wrong size on UUMGPlayerStatusIcon");
static_assert(offsetof(UUMGPlayerStatusIcon, HealthBar) == 0x000338, "Member 'UUMGPlayerStatusIcon::HealthBar' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, TimerBar) == 0x000340, "Member 'UUMGPlayerStatusIcon::TimerBar' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, HealthBarContainer) == 0x000348, "Member 'UUMGPlayerStatusIcon::HealthBarContainer' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, TimerBarContainer) == 0x000350, "Member 'UUMGPlayerStatusIcon::TimerBarContainer' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, PlayerName) == 0x000358, "Member 'UUMGPlayerStatusIcon::PlayerName' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, StatusIconBloodTop) == 0x000360, "Member 'UUMGPlayerStatusIcon::StatusIconBloodTop' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, StatusIconBloodBottom) == 0x000368, "Member 'UUMGPlayerStatusIcon::StatusIconBloodBottom' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, StatusIcon) == 0x000370, "Member 'UUMGPlayerStatusIcon::StatusIcon' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, ObsessionCanvas) == 0x000378, "Member 'UUMGPlayerStatusIcon::ObsessionCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, BrokenIndicatorCanvas) == 0x000380, "Member 'UUMGPlayerStatusIcon::BrokenIndicatorCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, AfflictionCanvas) == 0x000388, "Member 'UUMGPlayerStatusIcon::AfflictionCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, AfflictionIntroCanvas) == 0x000390, "Member 'UUMGPlayerStatusIcon::AfflictionIntroCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, SleepStatusCanvas) == 0x000398, "Member 'UUMGPlayerStatusIcon::SleepStatusCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, SleepTimerCanvas) == 0x0003A0, "Member 'UUMGPlayerStatusIcon::SleepTimerCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, ReverseBearTrapCanvas) == 0x0003A8, "Member 'UUMGPlayerStatusIcon::ReverseBearTrapCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, ReverseBearTrapArrow) == 0x0003B0, "Member 'UUMGPlayerStatusIcon::ReverseBearTrapArrow' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, SicknessCanvas) == 0x0003B8, "Member 'UUMGPlayerStatusIcon::SicknessCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, SicknessFill) == 0x0003C0, "Member 'UUMGPlayerStatusIcon::SicknessFill' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, SpectateCanvas) == 0x0003C8, "Member 'UUMGPlayerStatusIcon::SpectateCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, SelectedSpectatorCanvas) == 0x0003D0, "Member 'UUMGPlayerStatusIcon::SelectedSpectatorCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, AgonyCanvas) == 0x0003D8, "Member 'UUMGPlayerStatusIcon::AgonyCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, HandsGrabbing) == 0x0003E0, "Member 'UUMGPlayerStatusIcon::HandsGrabbing' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, SicknessFillHighOpacity) == 0x0003E8, "Member 'UUMGPlayerStatusIcon::SicknessFillHighOpacity' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, SicknessFillLowOpacity) == 0x0003EC, "Member 'UUMGPlayerStatusIcon::SicknessFillLowOpacity' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, StatusEffectContainerCanvas) == 0x0003F0, "Member 'UUMGPlayerStatusIcon::StatusEffectContainerCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, SicknessFillMI) == 0x0003F8, "Member 'UUMGPlayerStatusIcon::SicknessFillMI' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _hookedTexture) == 0x000400, "Member 'UUMGPlayerStatusIcon::_hookedTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _hookedBloodTexture) == 0x000408, "Member 'UUMGPlayerStatusIcon::_hookedBloodTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _trappedTexture) == 0x000410, "Member 'UUMGPlayerStatusIcon::_trappedTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _trappedBloodTexture) == 0x000418, "Member 'UUMGPlayerStatusIcon::_trappedBloodTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _deadTexture) == 0x000420, "Member 'UUMGPlayerStatusIcon::_deadTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _deadBloodTexture) == 0x000428, "Member 'UUMGPlayerStatusIcon::_deadBloodTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _escapedTexture) == 0x000430, "Member 'UUMGPlayerStatusIcon::_escapedTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _carriedTexture) == 0x000438, "Member 'UUMGPlayerStatusIcon::_carriedTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _injuredTexture) == 0x000440, "Member 'UUMGPlayerStatusIcon::_injuredTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _injuredBloodTexture) == 0x000448, "Member 'UUMGPlayerStatusIcon::_injuredBloodTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _crawlingTexture) == 0x000450, "Member 'UUMGPlayerStatusIcon::_crawlingTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _crawlingBloodTexture) == 0x000458, "Member 'UUMGPlayerStatusIcon::_crawlingBloodTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _sacrificedTexture) == 0x000460, "Member 'UUMGPlayerStatusIcon::_sacrificedTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _sacrificedBloodTexture) == 0x000468, "Member 'UUMGPlayerStatusIcon::_sacrificedBloodTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _disconnectedTexture) == 0x000470, "Member 'UUMGPlayerStatusIcon::_disconnectedTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _deathBedTexture) == 0x000478, "Member 'UUMGPlayerStatusIcon::_deathBedTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _defaultTexture) == 0x000480, "Member 'UUMGPlayerStatusIcon::_defaultTexture' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, UMGStalkingStatusEffectUIClass) == 0x000488, "Member 'UUMGPlayerStatusIcon::UMGStalkingStatusEffectUIClass' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, UMGLacerationStatusEffectUIClass) == 0x0004B8, "Member 'UUMGPlayerStatusIcon::UMGLacerationStatusEffectUIClass' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _maxNumberCharacterInName) == 0x0004E8, "Member 'UUMGPlayerStatusIcon::_maxNumberCharacterInName' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _stalkingStatusEffectUI) == 0x0005A0, "Member 'UUMGPlayerStatusIcon::_stalkingStatusEffectUI' has a wrong offset!");
static_assert(offsetof(UUMGPlayerStatusIcon, _lacerationStatusEffectUI) == 0x0005A8, "Member 'UUMGPlayerStatusIcon::_lacerationStatusEffectUI' has a wrong offset!");

// Class DeadByDaylight.DBDCharacterMovementUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDCharacterMovementUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void Local_AddMaxSpeedMultiplierCurve(class ACharacter* character, const class UCurveFloat* curve, float duration, bool autoReset);
	static void Local_RemoveMaxSpeedMultiplierCurve(class ACharacter* character, const class UCurveFloat* curveToReset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCharacterMovementUtilities">();
	}
	static class UDBDCharacterMovementUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCharacterMovementUtilities>();
	}
};
static_assert(alignof(UDBDCharacterMovementUtilities) == 0x000008, "Wrong alignment on UDBDCharacterMovementUtilities");
static_assert(sizeof(UDBDCharacterMovementUtilities) == 0x000030, "Wrong size on UDBDCharacterMovementUtilities");

// Class DeadByDaylight.CamperExposerInstance
// 0x0030 (0x0260 - 0x0230)
class ACamperExposerInstance final : public AActor
{
public:
	bool                                          IsInterior;                                        // 0x0230(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 _audioAgravationLevelRtpc;                         // 0x0238(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x18];                                     // 0x0248(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExitSequenceComplete();
	void SetIsInteriorBP(bool interior);
	void StartExitSequence(bool withRandomDelay);
	void StartSpawnSequence(bool withRandomDelay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperExposerInstance">();
	}
	static class ACamperExposerInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACamperExposerInstance>();
	}
};
static_assert(alignof(ACamperExposerInstance) == 0x000008, "Wrong alignment on ACamperExposerInstance");
static_assert(sizeof(ACamperExposerInstance) == 0x000260, "Wrong size on ACamperExposerInstance");
static_assert(offsetof(ACamperExposerInstance, IsInterior) == 0x000230, "Member 'ACamperExposerInstance::IsInterior' has a wrong offset!");
static_assert(offsetof(ACamperExposerInstance, _audioAgravationLevelRtpc) == 0x000238, "Member 'ACamperExposerInstance::_audioAgravationLevelRtpc' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaEventsElement
// 0x0018 (0x0350 - 0x0338)
class UUMGAtlantaEventsElement final : public UMobileBaseUserWidget
{
public:
	class UVerticalBox*                           ImageBox;                                          // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             ElementName;                                       // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGPromoPackItemWidget*                CustomizationWidget;                               // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaEventsElement">();
	}
	static class UUMGAtlantaEventsElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaEventsElement>();
	}
};
static_assert(alignof(UUMGAtlantaEventsElement) == 0x000008, "Wrong alignment on UUMGAtlantaEventsElement");
static_assert(sizeof(UUMGAtlantaEventsElement) == 0x000350, "Wrong size on UUMGAtlantaEventsElement");
static_assert(offsetof(UUMGAtlantaEventsElement, ImageBox) == 0x000338, "Member 'UUMGAtlantaEventsElement::ImageBox' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsElement, ElementName) == 0x000340, "Member 'UUMGAtlantaEventsElement::ElementName' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsElement, CustomizationWidget) == 0x000348, "Member 'UUMGAtlantaEventsElement::CustomizationWidget' has a wrong offset!");

// Class DeadByDaylight.CamperHealthComponent
// 0x0230 (0x02E8 - 0x00B8)
class UCamperHealthComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const struct FCamperHealResult& healResult)> OnHealedDelegate;     // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInjuredBleedoutStarted;                          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInjuredBleedoutEnded;                            // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* injuredBleedoutInstigator)> OnInjuredBleedoutKO; // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x30];                                      // 0x00F8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(ECamperDamageState oldDamageState, ECamperDamageState newDamageState)> OnDamageStateChanged; // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDamageStateChangedCosmetic;                      // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_148[0x18];                                     // 0x0148(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _bleedoutBaseDuration;                             // 0x0160(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTagStateBool                          _inInjuredBleedOut;                                // 0x0188(0x0030)(Net, Transient, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTimer                              _bleedOutTimer;                                    // 0x01B8(0x0028)(Net, Transient, NativeAccessSpecifierPrivate)
	bool                                          _canBleedout;                                      // 0x01E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E1[0x7];                                      // 0x01E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UInteractionDefinition>> _pauseInjuredBleedoutTimerInteractions;        // 0x01E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         _currentHealthStateCount;                          // 0x01F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _numHealthyHeals;                                  // 0x0200(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTimer                              _dyingTimer;                                       // 0x0208(0x0028)(Net, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _healFromDyingChargeable;                          // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _healFromInjuredChargeable;                        // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _mendChargeable;                                   // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _injuredBleedoutInstigator;                        // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_258[0x90];                                     // 0x0258(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_ApplyDamage(class AActor* damageSource, class ACharacter* damagePlayerOwner);
	void Authority_ApplyDeepWound(class AActor* damageSource, class ACharacter* damagePlayerOwner);
	void Authority_ApplyDoubleDamage(class AActor* damageSource, class ACharacter* damagePlayerOwner);
	void Authority_EndInjuredBleedout();
	void Authority_HealTryGrantScoresOnChargeApplied(float individualChargeAmount, float totalChargeAmount, class AActor* chargeInstigator, bool wasCoop, float deltaTime);
	void Authority_MendTryGrantScoresOnChargeApplied(float individualChargeAmount, float totalChargeAmount, class AActor* chargeInstigator, bool wasCoop, float deltaTime);
	void Authority_OnHealthBarCharged(bool complete, const TArray<class AActor*>& instigators);
	void Authority_OnMendChargeCompletionStateChanged(bool complete, const TArray<class AActor*>& instigators);
	void Authority_OnSurvivorRemoved(class ACamperPlayer* survivor);
	void Authority_SetDamageState(ECamperDamageState damageState, bool fireScoreEvent, bool sacrificed);
	class UChargeableComponent* GetCurrentHPSlot();
	void IncreaseHPSlotSize(float percent);
	void Multicast_OnHealed(const struct FCamperHealResult& healResult);
	void Multicast_OnInjuredBleedoutKO(class ADBDPlayer* injuredBleedoutInstigator);
	void Multicast_OnSurvivorGainedHealthStateByOthersEvents(const bool healedFromKO, class ADBDPlayer* healedSurvivor, const TArray<class ADBDPlayer*>& healers, const TArray<bool>& healedSurvivorFarEnoughAway);
	void Multicast_SetCurrentHealthStateCount(int32 newHealth, bool fireScoreEvent);
	void Multicast_SetDamageState(ECamperDamageState damageState, bool fireScoreEvent, bool sacrificed);
	void Multicast_SetHealthStateFromDamageState(ECamperDamageState damageState, bool fireScoreEvent);
	void Multicast_SetHealthType(EHealthType healthType);
	void OnImmobilizedStateChanged(const ECamperImmobilizeState oldImmobilizeState, const ECamperImmobilizeState newImmobilizeState);
	void OnRep_InInjuredBleedOut();
	void SetCanBleedout(bool canBleedout);

	bool CanBecomeHealthy() const;
	bool CanBeHealed() const;
	bool CanBeHealedFromInjured() const;
	bool CanHealSelf() const;
	float GetCurrentTotalHealthBarPercent() const;
	ECamperDamageState GetDamageState() const;
	float GetPercentDyingTimer() const;
	float GetPercentInjuredBleedoutTimer() const;
	bool IsDead() const;
	bool IsDyingTimerExpired() const;
	bool IsHealthy() const;
	bool IsInInjuredBleedout() const;
	bool IsInjured() const;
	bool IsInjuredBleedoutTimerExpired() const;
	bool IsKO() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperHealthComponent">();
	}
	static class UCamperHealthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperHealthComponent>();
	}
};
static_assert(alignof(UCamperHealthComponent) == 0x000008, "Wrong alignment on UCamperHealthComponent");
static_assert(sizeof(UCamperHealthComponent) == 0x0002E8, "Wrong size on UCamperHealthComponent");
static_assert(offsetof(UCamperHealthComponent, OnHealedDelegate) == 0x0000B8, "Member 'UCamperHealthComponent::OnHealedDelegate' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, OnInjuredBleedoutStarted) == 0x0000C8, "Member 'UCamperHealthComponent::OnInjuredBleedoutStarted' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, OnInjuredBleedoutEnded) == 0x0000D8, "Member 'UCamperHealthComponent::OnInjuredBleedoutEnded' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, OnInjuredBleedoutKO) == 0x0000E8, "Member 'UCamperHealthComponent::OnInjuredBleedoutKO' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, OnDamageStateChanged) == 0x000128, "Member 'UCamperHealthComponent::OnDamageStateChanged' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, OnDamageStateChangedCosmetic) == 0x000138, "Member 'UCamperHealthComponent::OnDamageStateChangedCosmetic' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _bleedoutBaseDuration) == 0x000160, "Member 'UCamperHealthComponent::_bleedoutBaseDuration' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _inInjuredBleedOut) == 0x000188, "Member 'UCamperHealthComponent::_inInjuredBleedOut' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _bleedOutTimer) == 0x0001B8, "Member 'UCamperHealthComponent::_bleedOutTimer' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _canBleedout) == 0x0001E0, "Member 'UCamperHealthComponent::_canBleedout' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _pauseInjuredBleedoutTimerInteractions) == 0x0001E8, "Member 'UCamperHealthComponent::_pauseInjuredBleedoutTimerInteractions' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _currentHealthStateCount) == 0x0001F8, "Member 'UCamperHealthComponent::_currentHealthStateCount' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _numHealthyHeals) == 0x000200, "Member 'UCamperHealthComponent::_numHealthyHeals' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _dyingTimer) == 0x000208, "Member 'UCamperHealthComponent::_dyingTimer' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _healFromDyingChargeable) == 0x000238, "Member 'UCamperHealthComponent::_healFromDyingChargeable' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _healFromInjuredChargeable) == 0x000240, "Member 'UCamperHealthComponent::_healFromInjuredChargeable' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _mendChargeable) == 0x000248, "Member 'UCamperHealthComponent::_mendChargeable' has a wrong offset!");
static_assert(offsetof(UCamperHealthComponent, _injuredBleedoutInstigator) == 0x000250, "Member 'UCamperHealthComponent::_injuredBleedoutInstigator' has a wrong offset!");

// Class DeadByDaylight.PlayerInteractable
// 0x0020 (0x0348 - 0x0328)
class APlayerInteractable : public AInteractable
{
public:
	uint8                                         Pad_328[0x20];                                     // 0x0328(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitInteractable(class ADBDPlayer* player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInteractable">();
	}
	static class APlayerInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerInteractable>();
	}
};
static_assert(alignof(APlayerInteractable) == 0x000008, "Wrong alignment on APlayerInteractable");
static_assert(sizeof(APlayerInteractable) == 0x000348, "Wrong size on APlayerInteractable");

// Class DeadByDaylight.CamperInteractable
// 0x0108 (0x0450 - 0x0348)
class ACamperInteractable final : public APlayerInteractable
{
public:
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractor*>                    HealingInteractors;                                // 0x0350(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UChargeableInteractionDefinition*> _healInteractions;                               // 0x0360(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _killCharge;                                       // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _snapOutOfItCharge;                                // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _wakeUpCharge;                                     // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _crowDismissCharge;                                // 0x0388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActivatorComponent*                    _activator;                                        // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_398[0x68];                                     // 0x0398(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractor*                            _killInteractor;                                   // 0x0400(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _killInteractionZone;                              // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _killHealthyInteractionZone;                       // 0x0410(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _mainInteractionZone;                              // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _healingInteractor1;                               // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _selfInteractionsInteractor;                       // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _rootComponent;                                    // 0x0430(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x18];                                     // 0x0438(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerMoveOut();
	void SetKillInteraction(class UInteractionDefinition* killInteraction);
	void UpdateTargetHPSlot();

	class ACamperPlayer* GetOwningSurvivor() const;
	class UInteractor* GetSlasherInteractor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperInteractable">();
	}
	static class ACamperInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACamperInteractable>();
	}
};
static_assert(alignof(ACamperInteractable) == 0x000008, "Wrong alignment on ACamperInteractable");
static_assert(sizeof(ACamperInteractable) == 0x000450, "Wrong size on ACamperInteractable");
static_assert(offsetof(ACamperInteractable, HealingInteractors) == 0x000350, "Member 'ACamperInteractable::HealingInteractors' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _healInteractions) == 0x000360, "Member 'ACamperInteractable::_healInteractions' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _killCharge) == 0x000370, "Member 'ACamperInteractable::_killCharge' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _snapOutOfItCharge) == 0x000378, "Member 'ACamperInteractable::_snapOutOfItCharge' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _wakeUpCharge) == 0x000380, "Member 'ACamperInteractable::_wakeUpCharge' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _crowDismissCharge) == 0x000388, "Member 'ACamperInteractable::_crowDismissCharge' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _activator) == 0x000390, "Member 'ACamperInteractable::_activator' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _killInteractor) == 0x000400, "Member 'ACamperInteractable::_killInteractor' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _killInteractionZone) == 0x000408, "Member 'ACamperInteractable::_killInteractionZone' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _killHealthyInteractionZone) == 0x000410, "Member 'ACamperInteractable::_killHealthyInteractionZone' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _mainInteractionZone) == 0x000418, "Member 'ACamperInteractable::_mainInteractionZone' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _healingInteractor1) == 0x000420, "Member 'ACamperInteractable::_healingInteractor1' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _selfInteractionsInteractor) == 0x000428, "Member 'ACamperInteractable::_selfInteractionsInteractor' has a wrong offset!");
static_assert(offsetof(ACamperInteractable, _rootComponent) == 0x000430, "Member 'ACamperInteractable::_rootComponent' has a wrong offset!");

// Class DeadByDaylight.CamperMaterialHelperController
// 0x0070 (0x0128 - 0x00B8)
class UCamperMaterialHelperController final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x60];                                      // 0x00B8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FManagedMaterialGroup>          _managedGroups;                                    // 0x0118(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddManagedGroup(class UObject* source, const class FString& group);
	void AddManagedWithCondition(class UObject* source, const class FString& group, const TDelegate<void()>& condition);
	void RemoveGroupsBySource(class UObject* source);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperMaterialHelperController">();
	}
	static class UCamperMaterialHelperController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperMaterialHelperController>();
	}
};
static_assert(alignof(UCamperMaterialHelperController) == 0x000008, "Wrong alignment on UCamperMaterialHelperController");
static_assert(sizeof(UCamperMaterialHelperController) == 0x000128, "Wrong size on UCamperMaterialHelperController");
static_assert(offsetof(UCamperMaterialHelperController, _managedGroups) == 0x000118, "Member 'UCamperMaterialHelperController::_managedGroups' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerData
// 0x0090 (0x0148 - 0x00B8)
class UDBDPlayerData : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(bool isPressed)> OnItemUseButtonStateChanged;                      // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x74];                                      // 0x00C8(0x0074)(Fixing Size After Last Property [ Dumper-7 ])
	struct FYawAndPitchRotator_NetQuantize16      _controlRotation;                                  // 0x013C(0x000C)(Net, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void Server_CampaignDataSynced();
	void Server_LoadoutSpawned();
	void Server_NotifyAIPawnSpawned();
	void Server_RenderingFeaturesCompleted();
	void Server_SetIntroCompleted();
	void Server_SetPlayerReady();

	struct FRotator GetControlRotation() const;
	bool GetUseInputPressed() const;
	bool IsInteractionInputPressed(EInputInteractionType interactionType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerData">();
	}
	static class UDBDPlayerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPlayerData>();
	}
};
static_assert(alignof(UDBDPlayerData) == 0x000008, "Wrong alignment on UDBDPlayerData");
static_assert(sizeof(UDBDPlayerData) == 0x000148, "Wrong size on UDBDPlayerData");
static_assert(offsetof(UDBDPlayerData, OnItemUseButtonStateChanged) == 0x0000B8, "Member 'UDBDPlayerData::OnItemUseButtonStateChanged' has a wrong offset!");
static_assert(offsetof(UDBDPlayerData, _controlRotation) == 0x00013C, "Member 'UDBDPlayerData::_controlRotation' has a wrong offset!");

// Class DeadByDaylight.DBDCharacterMovementComponent
// 0x0350 (0x0E60 - 0x0B10)
class UDBDCharacterMovementComponent : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_B10[0x18];                                     // 0x0B10(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectedWallSlidingFactor;                        // 0x0B28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomInputFrontMultiplier;                        // 0x0B2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomInputSideMultiplier;                         // 0x0B30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomInputBackMultiplier;                         // 0x0B34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B38[0x90];                                     // 0x0B38(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _forceUseDropStaggerFix;                           // 0x0BC8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC9[0x1F];                                     // 0x0BC9(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCurveFloat*>                    _maxSpeedMultiplierCurvesToRemoveOnTheServer;      // 0x0BE8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BF8[0x10];                                     // 0x0BF8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCurveFloat*>                    _maxSpeedAdditiveCurvesToRemoveOnTheServer;        // 0x0C08(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C18[0x1A0];                                    // 0x0C18(0x01A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseCharacterVelocityAdditiveStrategy* _velocityAdditiveStrategy;                         // 0x0DB8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseInputAccelerationConstraintStrategy* _inputAccelerationConstraintStrategy;            // 0x0DC0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBaseCharacterRotationStrategy*         _rotationStrategy;                                 // 0x0DC8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _lookAtTarget;                                     // 0x0DD0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DD8[0x88];                                     // 0x0DD8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_PreventMovement(const bool value);
	void Client_Stop();
	void Client_TeleportTo(const struct FVector_NetQuantize100& location, const struct FYawAndPitchRotator_NetQuantize32& rotation);
	void DBD_SimulateHack_LocalLaunch(const float xVelocity, const float yVelocity, const float zVelocity);
	void DBD_SimulateHack_LocalSurvivorMaxSpeedMultiplierUsingServerRPC(const float maxSpeedMultiplier);
	void OnMontageStarted(const struct FMontagePlaybackDefinition& montageDefinition, const class UAnimMontage* montage);
	void OnPreMontageStop(const struct FMontageStopDefinition& montageDefinition, const class UAnimMontage* montage);
	void Server_AddMaxSpeedMovementCurve(float timestamp, const uint32 curveNetId, float duration, float startOffset, const EMovementCurveType movementCurveType);
	void Server_Launch(float timestamp, const struct FVector& launchVelocity, int32 launchCallCount);
	void Server_PlayMontage(float timestamp, const struct FMontagePlaybackDefinition& montagePlaybackDefinition);
	void Server_RemoveMaxSpeedMovementCurve(float timestamp, const uint32 curveNetId, const EMovementCurveType movementCurveType);
	void Server_ReplicateControlRotation(uint8 clientRoll, uint32 view);
	void Server_SetAdditiveMaxSpeedScalar(float timestamp, float value);
	void Server_SetGroundFriction(float timestamp, float value);
	void Server_SetIgnorePawnCollisionOverride(float timestamp, bool isIgnoringPawnCollision);
	void Server_SetMaxAcceleration(float timestamp, float value);
	void Server_SetMaxSpeedMultiplierScalar(float timestamp, float value);
	void Server_SetMaxSpeedOverride(float timestamp, float value, bool isSet);
	void Server_SetStopSnapping(float timestamp, const bool snapToFinalDestination);
	void Server_StartSnapping(float timestamp, const struct FSnappingData& data, int32 snappingCallCount);
	void Server_StopMontage(float timestamp, const struct FMontageStopDefinition& montageStopDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCharacterMovementComponent">();
	}
	static class UDBDCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCharacterMovementComponent>();
	}
};
static_assert(alignof(UDBDCharacterMovementComponent) == 0x000010, "Wrong alignment on UDBDCharacterMovementComponent");
static_assert(sizeof(UDBDCharacterMovementComponent) == 0x000E60, "Wrong size on UDBDCharacterMovementComponent");
static_assert(offsetof(UDBDCharacterMovementComponent, ProjectedWallSlidingFactor) == 0x000B28, "Member 'UDBDCharacterMovementComponent::ProjectedWallSlidingFactor' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, RandomInputFrontMultiplier) == 0x000B2C, "Member 'UDBDCharacterMovementComponent::RandomInputFrontMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, RandomInputSideMultiplier) == 0x000B30, "Member 'UDBDCharacterMovementComponent::RandomInputSideMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, RandomInputBackMultiplier) == 0x000B34, "Member 'UDBDCharacterMovementComponent::RandomInputBackMultiplier' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _forceUseDropStaggerFix) == 0x000BC8, "Member 'UDBDCharacterMovementComponent::_forceUseDropStaggerFix' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _maxSpeedMultiplierCurvesToRemoveOnTheServer) == 0x000BE8, "Member 'UDBDCharacterMovementComponent::_maxSpeedMultiplierCurvesToRemoveOnTheServer' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _maxSpeedAdditiveCurvesToRemoveOnTheServer) == 0x000C08, "Member 'UDBDCharacterMovementComponent::_maxSpeedAdditiveCurvesToRemoveOnTheServer' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _velocityAdditiveStrategy) == 0x000DB8, "Member 'UDBDCharacterMovementComponent::_velocityAdditiveStrategy' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _inputAccelerationConstraintStrategy) == 0x000DC0, "Member 'UDBDCharacterMovementComponent::_inputAccelerationConstraintStrategy' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _rotationStrategy) == 0x000DC8, "Member 'UDBDCharacterMovementComponent::_rotationStrategy' has a wrong offset!");
static_assert(offsetof(UDBDCharacterMovementComponent, _lookAtTarget) == 0x000DD0, "Member 'UDBDCharacterMovementComponent::_lookAtTarget' has a wrong offset!");

// Class DeadByDaylight.CamperMovementComponent
// 0x0090 (0x0EF0 - 0x0E60)
class UCamperMovementComponent final : public UDBDCharacterMovementComponent
{
public:
	uint8                                         Pad_E60[0x10];                                     // 0x0E60(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxCrawlSpeed;                                     // 0x0E70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRunSpeed;                                       // 0x0E74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               _defaultRotationRate;                              // 0x0E78(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               _rotationRateWhileCrawling;                        // 0x0E84(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _dropStaggerDuration;                              // 0x0E90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _dropStaggerMaxSpeed;                              // 0x0E98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EA0[0x50];                                     // 0x0EA0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_Debug_SetSurvivorMaxSpeedMultiplier(const float maxSpeedMultiplier);
	void DBD_SimulateHack_LocalSurvivorMaxSpeedMultiplier(const float maxSpeedMultiplier);
	void DBD_SurvivorMaxSpeedMultiplier(const float maxSpeedMultiplier);
	void OnCamperHealthStateChanged(ECamperDamageState oldDamageState, ECamperDamageState currentDamageState);

	struct FRotator GetDefaultRotationRate() const;
	float GetDropStaggerTimeLeft() const;
	struct FRotator GetRotationRateWhileCrawling() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperMovementComponent">();
	}
	static class UCamperMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperMovementComponent>();
	}
};
static_assert(alignof(UCamperMovementComponent) == 0x000010, "Wrong alignment on UCamperMovementComponent");
static_assert(sizeof(UCamperMovementComponent) == 0x000EF0, "Wrong size on UCamperMovementComponent");
static_assert(offsetof(UCamperMovementComponent, MaxCrawlSpeed) == 0x000E70, "Member 'UCamperMovementComponent::MaxCrawlSpeed' has a wrong offset!");
static_assert(offsetof(UCamperMovementComponent, MaxRunSpeed) == 0x000E74, "Member 'UCamperMovementComponent::MaxRunSpeed' has a wrong offset!");
static_assert(offsetof(UCamperMovementComponent, _defaultRotationRate) == 0x000E78, "Member 'UCamperMovementComponent::_defaultRotationRate' has a wrong offset!");
static_assert(offsetof(UCamperMovementComponent, _rotationRateWhileCrawling) == 0x000E84, "Member 'UCamperMovementComponent::_rotationRateWhileCrawling' has a wrong offset!");
static_assert(offsetof(UCamperMovementComponent, _dropStaggerDuration) == 0x000E90, "Member 'UCamperMovementComponent::_dropStaggerDuration' has a wrong offset!");
static_assert(offsetof(UCamperMovementComponent, _dropStaggerMaxSpeed) == 0x000E98, "Member 'UCamperMovementComponent::_dropStaggerMaxSpeed' has a wrong offset!");

// Class DeadByDaylight.ReportPlayerPopupScreen
// 0x0030 (0x0170 - 0x0140)
class UReportPlayerPopupScreen final : public UGenericPopupScreen
{
public:
	uint8                                         Pad_140[0x30];                                     // 0x0140(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConfirmReportPlayer(const class FString& category, const class FString& comment);
	void OnTextInputMouseOver(bool isMouseOver);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReportPlayerPopupScreen">();
	}
	static class UReportPlayerPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReportPlayerPopupScreen>();
	}
};
static_assert(alignof(UReportPlayerPopupScreen) == 0x000008, "Wrong alignment on UReportPlayerPopupScreen");
static_assert(sizeof(UReportPlayerPopupScreen) == 0x000170, "Wrong size on UReportPlayerPopupScreen");

// Class DeadByDaylight.UMGPromoPackSuggestionButton
// 0x0010 (0x0478 - 0x0468)
class UUMGPromoPackSuggestionButton final : public UUMGBaseButtonWidget
{
public:
	class URichTextBlock*                         RichTextButtonLabel;                               // 0x0468(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LineGlow;                                          // 0x0470(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPromoPackSuggestionButton">();
	}
	static class UUMGPromoPackSuggestionButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPromoPackSuggestionButton>();
	}
};
static_assert(alignof(UUMGPromoPackSuggestionButton) == 0x000008, "Wrong alignment on UUMGPromoPackSuggestionButton");
static_assert(sizeof(UUMGPromoPackSuggestionButton) == 0x000478, "Wrong size on UUMGPromoPackSuggestionButton");
static_assert(offsetof(UUMGPromoPackSuggestionButton, RichTextButtonLabel) == 0x000468, "Member 'UUMGPromoPackSuggestionButton::RichTextButtonLabel' has a wrong offset!");
static_assert(offsetof(UUMGPromoPackSuggestionButton, LineGlow) == 0x000470, "Member 'UUMGPromoPackSuggestionButton::LineGlow' has a wrong offset!");

// Class DeadByDaylight.DBDCoreUMGDesignTunables
// 0x0060 (0x0090 - 0x0030)
class UDBDCoreUMGDesignTunables : public UObject
{
public:
	TSoftClassPtr<class UClass>                   CoreHudRootWidgetClass;                            // 0x0030(0x0030)(Edit, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CorePlayerControllerClass;                         // 0x0060(0x0030)(Edit, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCoreUMGDesignTunables">();
	}
	static class UDBDCoreUMGDesignTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCoreUMGDesignTunables>();
	}
};
static_assert(alignof(UDBDCoreUMGDesignTunables) == 0x000008, "Wrong alignment on UDBDCoreUMGDesignTunables");
static_assert(sizeof(UDBDCoreUMGDesignTunables) == 0x000090, "Wrong size on UDBDCoreUMGDesignTunables");
static_assert(offsetof(UDBDCoreUMGDesignTunables, CoreHudRootWidgetClass) == 0x000030, "Member 'UDBDCoreUMGDesignTunables::CoreHudRootWidgetClass' has a wrong offset!");
static_assert(offsetof(UDBDCoreUMGDesignTunables, CorePlayerControllerClass) == 0x000060, "Member 'UDBDCoreUMGDesignTunables::CorePlayerControllerClass' has a wrong offset!");

// Class DeadByDaylight.DBDBasePlayer
// 0x0090 (0x0560 - 0x04D0)
class ADBDBasePlayer : public ACharacter
{
public:
	TMulticastInlineDelegate<void()>              OnCustomizationChanged;                            // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  _semanticGameplayTags;                             // 0x04E0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UBaseGroundDetectorComponent*           _leftFootGroundDetector;                           // 0x0500(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBaseGroundDetectorComponent*           _rightFootGroundDetector;                          // 0x0508(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_510[0x8];                                      // 0x0510(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _characterIndex;                                   // 0x0518(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51C[0x44];                                     // 0x051C(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_SwapCosmetics(class FName cosmeticId);
	void Multicast_SwapCosmetics(class FName cosmeticId);
	bool TeleportWithClothHandling(const struct FVector& location, const struct FRotator& rotation, bool checkCollisions);

	class UAkComponent* GetAudioComponent() const;
	int32 GetCharacterIndex() const;
	class FName GetCharacterName() const;
	class UCustomizedAudioComponent* GetCustomizedAudio() const;
	class UCustomizedSkeletalMesh* GetCustomizedSkeletalMesh() const;
	class FString GetLeftFootAudioSurfaceName() const;
	EPhysicalSurface GetLeftFootSurfaceType() const;
	class FString GetRightFootAudioSurfaceName() const;
	EPhysicalSurface GetRightFootSurfaceType() const;
	const struct FGameplayTagContainer GetSemanticTag() const;
	bool GetShowBlindDebugInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBasePlayer">();
	}
	static class ADBDBasePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDBasePlayer>();
	}
};
static_assert(alignof(ADBDBasePlayer) == 0x000010, "Wrong alignment on ADBDBasePlayer");
static_assert(sizeof(ADBDBasePlayer) == 0x000560, "Wrong size on ADBDBasePlayer");
static_assert(offsetof(ADBDBasePlayer, OnCustomizationChanged) == 0x0004D0, "Member 'ADBDBasePlayer::OnCustomizationChanged' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _semanticGameplayTags) == 0x0004E0, "Member 'ADBDBasePlayer::_semanticGameplayTags' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _leftFootGroundDetector) == 0x000500, "Member 'ADBDBasePlayer::_leftFootGroundDetector' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _rightFootGroundDetector) == 0x000508, "Member 'ADBDBasePlayer::_rightFootGroundDetector' has a wrong offset!");
static_assert(offsetof(ADBDBasePlayer, _characterIndex) == 0x000518, "Member 'ADBDBasePlayer::_characterIndex' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaLegalMenuScreen
// 0x0010 (0x0348 - 0x0338)
class UUMGAtlantaLegalMenuScreen final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMenuButtonClickEvent(bool isAccept);
	void SetButtonText(const class FText& acceptText, const class FText& declineText);
	void SetLegalText(const class FString& title, const class FString& legalText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaLegalMenuScreen">();
	}
	static class UUMGAtlantaLegalMenuScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaLegalMenuScreen>();
	}
};
static_assert(alignof(UUMGAtlantaLegalMenuScreen) == 0x000008, "Wrong alignment on UUMGAtlantaLegalMenuScreen");
static_assert(sizeof(UUMGAtlantaLegalMenuScreen) == 0x000348, "Wrong size on UUMGAtlantaLegalMenuScreen");

// Class DeadByDaylight.DBDPlayer
// 0x0C00 (0x1160 - 0x0560)
#pragma pack(push, 0x1)
class alignas(0x10) ADBDPlayer : public ADBDBasePlayer
{
public:
	uint8                                         Pad_560[0x98];                                     // 0x0560(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          AllowInterrupting;                                 // 0x05F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F9[0x3];                                      // 0x05F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinFallHeight;                                     // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInterruptable;                                   // 0x0600(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowNavigationInput;                              // 0x0601(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowNavigationBackwardInput;                      // 0x0602(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowTurningInput;                                 // 0x0603(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowPitchInput;                                   // 0x0604(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AllowStrafeInput;                                  // 0x0605(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInInteractionUpdate;                             // 0x0606(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInteractionChargeCompleted;                      // 0x0607(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchLimitLower;                                   // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchLimitUpper;                                   // 0x060C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StrafingOffset;                                    // 0x0610(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisHeight;                                      // 0x061C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisHeightForPounceOnStandingCamper;             // 0x0620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PelvisHeightForPounceOnCrouchingCamper;            // 0x0624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_628[0x30];                                     // 0x0628(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              Authority_OnAttackedDelegate;                      // 0x0658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* source, class ADBDPlayer* target, EAttackType attackType, bool didDamage)> OnDamageTargetDelegate; // 0x0668(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* player)> OnSensed;                               // 0x0678(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* player)> OnAnimNotify_Pickup;                    // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* player)> OnAnimNotify_Release;                   // 0x0698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* player, class UInteractionDefinition* interaction, bool fromCancelRequest)> Authority_OnSecondaryActionInput; // 0x06A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool firstPerson)> OnFirstPersonModeChanged;                       // 0x06B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* player)> OnDreamworldComponentSet;               // 0x06C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool forwardInputLockValue)> OnForwardInputLockedChanged;          // 0x06D8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    CameraBoom;                                        // 0x06E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F0[0x30];                                     // 0x06F0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ForceSkillChecks;                                  // 0x0720(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_721[0xF];                                      // 0x0721(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             IKLeftHandTransform;                               // 0x0730(0x0030)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             IKRightHandTransform;                              // 0x0760(0x0030)(BlueprintVisible, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CameraResetSpeed;                                  // 0x0790(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_794[0x4];                                      // 0x0794(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AverageSpeedBufferTime;                            // 0x0798(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlmostCurrentSpeedBufferTime;                      // 0x079C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GamepadYawCurve;                                   // 0x07A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GamepadPitchCurve;                                 // 0x07A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GamepadSettingToYawRateCurve;                      // 0x07B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GamepadSettingToPitchRateCurve;                    // 0x07B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            JoyconSettingToYawRateCurve;                       // 0x07C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            JoyconSettingToPitchRateCurve;                     // 0x07C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool isCrouched)> OnIsCrouchedChanged;                             // 0x07D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool isRunningAndMoving)> OnRunningAndMovingChanged;               // 0x07E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F0[0x20];                                     // 0x07F0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ADBDPlayer* player)> OnLocallyObservedChangedForPlayer;      // 0x0810(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UCameraComponent*                       Camera;                                            // 0x0820(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialHelper*                        MaterialHelper;                                    // 0x0828(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_830[0x30];                                     // 0x0830(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APlayerInteractable>        Interactable;                                      // 0x0860(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_868[0x18];                                     // 0x0868(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterInventoryComponent*           _characterInventoryComponent;                      // 0x0880(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CarryJointName;                                    // 0x0888(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pitchOffsetForInteractionPriority;                // 0x0894(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxOcclusionQueryComponent*            _renderedPixelCounter;                             // 0x0898(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _standingOcclusionBox;                             // 0x08A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _crouchingOcclusionBox;                            // 0x08A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActivatorComponent*                    _activator;                                        // 0x08B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInteracting;                                     // 0x08B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8B9[0x3];                                      // 0x08B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _aiCanBeSeenTestCrouchScale;                       // 0x08BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aiCanBeSeenTestRightOffset;                       // 0x08C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aiCanBeSeenTestHighOffset;                        // 0x08C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _aiCanBeSeenTestLowOffset;                         // 0x08C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClearPathTestRadiusMultiplier;                     // 0x08CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClearPathTestHeightMultiplier;                     // 0x08D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocationClearTestRadiusMultiplier;                 // 0x08D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocationClearTestHeightMultiplier;                 // 0x08D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClearPathTestStepHeight;                           // 0x08DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouseTurnSpeedMultiplier;                          // 0x08E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MouseLookUpSpeedMultiplier;                        // 0x08E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              DeathSound;                                        // 0x08E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECamperState                                  CurrentCamperState;                                // 0x08F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8F1[0x3];                                      // 0x08F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollectableAttachPoint;                            // 0x08F4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStateMachine*                          _stateMachine;                                     // 0x0900(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerInteractionHandler*              _interactionHandler;                               // 0x0908(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x0910(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPerkManager*                           _perkManager;                                      // 0x0918(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDPlayerData*                         _playerData;                                       // 0x0920(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerInteractable*                    _interactable;                                     // 0x0928(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_930[0x50];                                     // 0x0930(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _guidingPlayer;                                    // 0x0980(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_988[0x8];                                      // 0x0988(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _interactingPlayer;                                // 0x0990(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_998[0x30];                                     // 0x0998(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	EAttackSubstate                               _nextAttackSubstate;                               // 0x09C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C9[0x7];                                      // 0x09C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _hitTargets;                                       // 0x09D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UCharacterDreamworldComponent*          _dreamworldComponent;                              // 0x09E0(0x0008)(Edit, BlueprintVisible, ExportObject, Net, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterChaseVisualComponent*         _characterChaseVisualComponent;                    // 0x09E8(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraHandlerComponent*                _cameraHandlerComponent;                           // 0x09F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UReversibleActionSystemComponent*       _reversibleActionSystemComponent;                  // 0x09F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _itemDropOffPosition;                              // 0x0A00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0A08(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         _ignoreActors;                                     // 0x0A10(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FEffectCameraTypeSettings>      EffectCameraTypeSettings;                          // 0x0A20(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class USceneComponent*, bool>            _detectionZoneEnabledMap;                          // 0x0A30(0x0050)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A80[0x28];                                     // 0x0A80(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _blindingChargeableComponent;                      // 0x0AA8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB0[0x90];                                     // 0x0AB0(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _shouldUpdateStateMachineDriverOnPossessed;        // 0x0B40(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B41[0x7];                                      // 0x0B41(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlindableComponent*                    _blindableComponent;                               // 0x0B48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B50[0x4];                                      // 0x0B50(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _tutorialChargeableInteractionMultiplier;          // 0x0B54(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B58[0x8];                                      // 0x0B58(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPollableEventListener*                 _eventListener;                                    // 0x0B60(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B68[0x8];                                      // 0x0B68(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UChaseComponent*                        _chaseComponent;                                   // 0x0B70(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZoneDetectorComponent*                 _meatHookZoneDetector;                             // 0x0B78(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UZoneDetectorComponent*                 _basementZoneDetector;                             // 0x0B80(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B88[0x40];                                     // 0x0B88(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _animGameplayTags;                                 // 0x0BC8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BE8[0x58];                                     // 0x0BE8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _bookmarkedInteraction;                            // 0x0C40(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EDetectionZone, class UPrimitiveComponent*> _detectionZoneMap;                              // 0x0C48(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C98[0x60];                                     // 0x0C98(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UAuthoritativeMovementComponent*        _authoritativeMovementComponent;                   // 0x0CF8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D00[0x2F0];                                    // 0x0D00(0x02F0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _screenAspectRatio;                                // 0x0FF0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FF4[0x1C];                                     // 0x0FF4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameplayTagContainerComponent*         _objectState;                                      // 0x1010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioFXComponent*                      _audioFXComponent;                                 // 0x1018(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerPerspectiveComponent*            _playerPerspectiveComponent;                       // 0x1020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1028[0x8];                                     // 0x1028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterSightComponent*               _characterSightComponent;                          // 0x1030(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1038[0x8];                                     // 0x1038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterSightableComponent*           _characterSightableComponent;                      // 0x1040(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1048[0x10];                                    // 0x1048(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDetectorComponent*          _interactionDetectorComponent;                     // 0x1058(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitivesRegistererComponent*         _clippablePrimitivesRegistererComponent;           // 0x1060(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClippableProviderComponent*            _clippableProviderComponent;                       // 0x1068(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDynamicCapsuleResizerComponent*        _dynCapsuleResizer;                                // 0x1070(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerGameRelevancyComponent*          _playerGameRelevancyComponent;                     // 0x1078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UContextualQuestComponent*              _contextualQuestComponent;                         // 0x1080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1088[0x20];                                    // 0x1088(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorComponent*                        _questEventHandler;                                // 0x10A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableProgressProviderComponent*   _presentationChargeableProgressComponent;          // 0x10B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10B8[0x18];                                    // 0x10B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _currentGamepadYawCurve;                           // 0x10D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            _currentGamepadPitchCurve;                         // 0x10D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayerState*                        _associatedPlayerStateCache;                       // 0x10E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FOnMovementCacheStruct                 _onMovementCacheStruct;                            // 0x10E8(0x000C)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10F4[0x4];                                     // 0x10F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOtherCharactersVerticalCollisionsHandler* _otherCharactersVerticalCollisionsHandler;      // 0x10F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1100[0x58];                                    // 0x1100(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilityInputReleased();
	void AbilityTwoInputPressed();
	void AbilityTwoInputReleased();
	void AddDetectionZone(EDetectionZone detectionZoneID, class UPrimitiveComponent* zone);
	void AttachInteractor(class UInteractor* interactor);
	void Authority_HandleScoreEvent(const struct FGameplayTag& scoreTypeTag, const struct FScoreEventData& scoreEventData);
	class UStatusEffect* Authority_ImposeDynamicStatusEffect_DEPRECATED(class FName statusEffectID, class ADBDPlayer* originatingPlayer, float customParam, class UGameplayModifierContainer* originatingEffect);
	class UStatusEffect* Authority_ImposeStatusEffect_DEPRECATED(class FName statusEffectID, class ADBDPlayer* originatingPlayer, float customParam, class UGameplayModifierContainer* originatingEffect, bool shouldDisplay, float lifetime);
	void Authority_RemoveStatusEffectByID(class FName statusEffectId, bool bRemoveAllWithID);
	void Authority_RequestStun(EStunType stunType, class ADBDPlayer* stunner);
	void Authority_SetDreamworldComponent(class UCharacterDreamworldComponent* component);
	void CameraUpdated();
	void CancelCarry(bool alsoCancelForOtherPlayer);
	void Client_Debug_PlayerStartSnapping(const struct FVector& location, const float duration);
	void Client_SendCancelInteraction(const class UInteractionDefinition* interactionDefinition);
	void Client_TryInteraction(class UInteractionDefinition* interaction, class ADBDPlayer* requester, bool force, bool usingInputPersistence);
	void Client_TryInteractionType(EInputInteractionType interactionType, class ADBDPlayer* requester);
	void DBD_DebugStartInteraction();
	void DBD_SetMouseLookUpSpeedMultiplier(float value);
	void DBD_SetMouseTurnSpeedMultiplier(float value);
	void DBD_ToggleDebugInteractionInZone();
	void DBD_ToggleForceAuthoritativeMovement();
	void DBDCrouch();
	void DBDUnCrouch();
	void DetachInteractor();
	void Dissolve(bool dissolve);
	void FastInteractionInputPressed();
	void FastInteractionInputReleased();
	const struct FInteractionPlayerProperties GetInteractionPlayerProperties();
	void InteractionInputPressed();
	void InteractionInputReleased();
	void ItemUsePressed();
	void ItemUseReleased();
	bool K2_SetActorLocationByBottomCapsule(const struct FVector& NewLocation, bool bSweep, struct FHitResult* SweepHitResult);
	void Local_NotifyMatchEnded();
	void Multicast_Broadcast_DebugPlayMontage(const struct FAnimationMontageDescriptor& animMontageID, float playRate);
	void Multicast_ConfirmItemDrop(bool pressed);
	void Multicast_Debug_SetMaxWalkSpeed(float maxWalkSpeed);
	void Multicast_LeaveGame(const struct FGuid& uniqueLeavingPlayerId);
	void Multicast_ReplicateController(class AController* newController);
	void Multicast_ServerResetMeshRelativeOffSet();
	void Multicast_SetAuthoritativeMovement(bool enabled);
	void Multicast_SetContinuousPrintDebug(bool enabled);
	void Multicast_SetCustomization(const struct FEquippedPlayerCustomization& customization);
	void Multicast_SetDebugCarry(bool enabled);
	void Multicast_SetDebugPrintAvailableInteractions(bool enabled);
	void Multicast_SetDebugSnapPoint(bool enabled);
	void Multicast_SetEnableCapsuleDynamicResize(bool enabled);
	void Multicast_SetForceAuthoritativeMovement(bool value);
	void Multicast_SetInteractingPlayer(class ADBDPlayer* interactingPlayer);
	void Multicast_SetReverseTraverseEnabled(bool enabled);
	void Multicast_SetRunVaultEnabled(bool enabled);
	void OnAllPlayerLoaded();
	void OnAnimInstanceChanged();
	void OnBlindChargeEmptied();
	void OnClientRestart();
	void OnControllerChanged(class APawn* pawn, class AController* oldController, class AController* newController);
	void OnCurrentMontageBlendingOut(class UAnimMontage* MontageAsset, bool interrupted);
	void OnCurrentMontageComplete(class UAnimMontage* MontageAsset, bool interrupted);
	void OnEscapeDoorActivated();
	void OnHudVisibilityChanged(const bool isVisible);
	void OnHudVisibilityChangedNative(const bool isVisible);
	void OnInterruptedStart();
	void OnIntroCompleted();
	void OnIntroCompletedNative();
	void OnLevelReadyToPlay();
	void OnLocallyObservedChanged();
	void OnPickupEnd(class ADBDPlayer* target);
	void OnPickupStart(class ADBDPlayer* target);
	void OnPostProcessInput();
	void OnRep_DreamworldComponent();
	void OnRep_Interactable();
	class UAnimMontage* PlayMontage(const struct FAnimationMontageDescriptor& animMontageID, float playRate, bool isFollower);
	void RemoveStatusEffect(class UStatusEffect* statusEffect);
	void ResetCamera();
	void ResetPitchScale(float adjustTime);
	void Server_Broadcast_DebugPlayMontage(const struct FAnimationMontageDescriptor& animMontageID, float playRate);
	void Server_DebugSetCustomization(const struct FEquippedPlayerCustomization& customization);
	void Server_Drop(class ACollectable* item, const struct FVector& location, const struct FRotator& rotation, bool onDeath);
	void Server_GameTimeSync();
	void Server_SendAbilityInput(bool pressed);
	void Server_SendAbilityTwoInput(bool pressed);
	void Server_SendFastInteractionInput(bool pressed);
	void Server_SendInteractionInput(bool pressed);
	void Server_SendItemDropInput(bool pressed);
	void Server_SendItemUseInput(bool pressed, bool requestItemUse);
	void Server_SendSecondaryActionPressed(bool fromCancelRequest);
	void Server_UpdateScreenAspectRatio(const float value);
	void SetAllDetectionZonesEnabled(bool enabled);
	void SetAllowNavigation(bool enable);
	void SetAnimationCrouchState(bool crouched);
	void SetDetectionZoneEnabled(EDetectionZone detectionZoneID, bool enabled);
	void SetFeetOnGround(bool feetOnGround);
	void SetFirstPersonModelEnabled(bool enabled, bool force);
	void SetFirstPersonVfxsVisibility(bool isFirstPerson);
	void SetForceDisableSkillChecks(bool isEnabled);
	void SetIsCloaked(bool isCloaked, bool forced);
	void SetItemUseAsToggle(bool value);
	void SetQuestEventHandlerComponent(class UActorComponent* component);
	void SetReverseMontage(bool reverse);
	void SetShouldPlayCarryAnim(bool shouldPlayCarryAnim);
	void SnapCharacter(bool snapPosition, const struct FVector& position, float stopSnapDistance, bool snapRotation, const struct FRotator& rotation, float time, bool useZCoord, bool sweepOnFinalSnap, bool snapRoll);
	void StopMontage();
	void TriggerAnimNotify(EAnimNotifyType animNotifyType);
	bool TryFireScoreEvent(EDBDScoreTypes scoreType, float percentToAward);
	bool TryInteraction(class UInteractionDefinition* interaction, class ADBDPlayer* requester, bool force, bool usingInputPersistence);
	bool TryInteractionType(EInputInteractionType interactionInputType, class ADBDPlayer* requester, bool usingInputPersistence, bool force);

	void Authority_EvaluateIfPlayerCanSee() const;
	bool CanInterrupt_BP() const;
	void DBD_CancelInteraction() const;
	class ADBDPlayer* FindClosestSlashablePlayerInDetectionZone(EDetectionZone detectionZoneID) const;
	struct FVector GetActorLocationFromFeetLocation(const struct FVector& FeetLocation) const;
	class UAnimInstance* GetAnimInstance() const;
	void GetAnimTags(TArray<class FName>* outTags) const;
	class APlayerState* GetAssociatedPlayerState() const;
	class USceneComponent* GetAttachPoint(class FName attachPointName) const;
	class UAuthoritativeMovementComponent* GetAuthoritativeMovementComponent() const;
	struct FVector GetAverageVelocity() const;
	class UBlindableComponent* GetBlindableComponent() const;
	struct FVector GetBoneLocation(class FName name, EBoneSpaces space) const;
	class ADBDPlayerCameraManager* GetCameraManager() const;
	class UCharacterInventoryComponent* GetCharacterInventoryComponent() const;
	class UChaseComponent* GetChaseComponent() const;
	class UInteractionDefinition* GetCurrentInteraction() const;
	EInteractionAnimation GetCurrentInteractionAnimation() const;
	class ADBDPlayerState* GetDBDPlayerState() const;
	class UPrimitiveComponent* GetDetectionZone(EDetectionZone detectionZoneID) const;
	class UCharacterDreamworldComponent* GetDreamworldComponent() const;
	struct FVector GetFeetPosition() const;
	class UActorComponent* GetFirstComponentByClass(TSubclassOf<class UActorComponent> ComponentClass) const;
	float GetGrassEffectRadiusMultiplier() const;
	class ADBDPlayer* GetGuidingPlayer() const;
	class AInteractable* GetInteractable() const;
	class UInteractionDetectorComponent* GetInteractionDetectorComponent() const;
	bool GetIsInFirstPerson() const;
	bool GetIsInteracting() const;
	bool GetIsInterrupting() const;
	const TArray<class UItemAddon*> GetItemAddons() const;
	const TArray<class UItemModifier*> GetItemModifiers() const;
	float GetLuck() const;
	float GetMaxSpeed() const;
	class UAnimMontage* GetMontage(const struct FAnimationMontageDescriptor& animMontageID) const;
	float GetMontageLength(const struct FAnimationMontageDescriptor& animMontageID) const;
	struct FMontagePlaybackDefinition GetMontagePlaybackDefinition(const struct FAnimationMontageDescriptor& animMontageID, float playRate, bool isFollower) const;
	class UMontagePlayer* GetMontagePlayer() const;
	class FString GetNameDebugString() const;
	class UGameplayTagContainerComponent* GetObjectState() const;
	class UOtherCharactersVerticalCollisionsHandler* GetOtherCharactersVerticalCollisionsHandler() const;
	EPawnType GetPawnType() const;
	float GetPercentMovementSpeed() const;
	class UPerkManager* GetPerkManager() const;
	class UCameraComponent* GetPlayerCamera() const;
	class ADBDPlayerController* GetPlayerController() const;
	struct FRotator GetPlayerDirection() const;
	class UPlayerInteractionHandler* GetPlayerInteractionHandler() const;
	EPlayerRole GetPlayerRole() const;
	EPlayerTeam GetPlayerTeam() const;
	struct FRotator GetRepControlRotation() const;
	bool GetReverseTraverseEnabled() const;
	bool GetRunVaultEnabled() const;
	class ADBDPlayerController* GetSharedPlayerController() const;
	float GetTunableValue(class FName key, float defaultValue, bool warnIfRowMissing) const;
	bool HasClearPathToTarget(const struct FVector& targetPosition) const;
	bool HasClearPathToTargetWithIgnore(const struct FVector& targetPosition, const TArray<class AActor*>& ignoreActors) const;
	bool HasDamageImmunity() const;
	bool HasMoveInput() const;
	bool IsAllowedNavigation() const;
	bool IsBeingInterrupted() const;
	bool IsCloaked() const;
	bool IsCrouching() const;
	bool IsCrouchPressed() const;
	bool IsExhausted() const;
	bool IsHeadHidden() const;
	bool IsIncapacitated() const;
	bool IsInMeathookZone() const;
	bool IsInParadise() const;
	bool IsInsideCloset() const;
	bool IsInStalkMode() const;
	bool IsInteractionInputPressed(EInputInteractionType interactionType) const;
	bool IsInTerrorRadius() const;
	bool IsLocallyObserved() const;
	bool IsMoving() const;
	bool IsPlayingAnyMontage() const;
	bool IsPlayingMontage(const struct FAnimationMontageDescriptor& animMontageID) const;
	bool IsRunning() const;
	bool Local_IsInteractionInputPressed(EInputInteractionType interactionType) const;
	class FString OnGetCharacterName() const;
	bool ShouldFall() const;
	bool ShouldPlayCarryAnim() const;
	void UpdateLoadoutFromInventory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayer">();
	}
	static class ADBDPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayer>();
	}
};
#pragma pack(pop)
static_assert(alignof(ADBDPlayer) == 0x000010, "Wrong alignment on ADBDPlayer");
static_assert(sizeof(ADBDPlayer) == 0x001160, "Wrong size on ADBDPlayer");
static_assert(offsetof(ADBDPlayer, AllowInterrupting) == 0x0005F8, "Member 'ADBDPlayer::AllowInterrupting' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, MinFallHeight) == 0x0005FC, "Member 'ADBDPlayer::MinFallHeight' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, IsInterruptable) == 0x000600, "Member 'ADBDPlayer::IsInterruptable' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, AllowNavigationInput) == 0x000601, "Member 'ADBDPlayer::AllowNavigationInput' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, AllowNavigationBackwardInput) == 0x000602, "Member 'ADBDPlayer::AllowNavigationBackwardInput' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, AllowTurningInput) == 0x000603, "Member 'ADBDPlayer::AllowTurningInput' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, AllowPitchInput) == 0x000604, "Member 'ADBDPlayer::AllowPitchInput' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, AllowStrafeInput) == 0x000605, "Member 'ADBDPlayer::AllowStrafeInput' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, IsInInteractionUpdate) == 0x000606, "Member 'ADBDPlayer::IsInInteractionUpdate' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, IsInteractionChargeCompleted) == 0x000607, "Member 'ADBDPlayer::IsInteractionChargeCompleted' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, PitchLimitLower) == 0x000608, "Member 'ADBDPlayer::PitchLimitLower' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, PitchLimitUpper) == 0x00060C, "Member 'ADBDPlayer::PitchLimitUpper' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, StrafingOffset) == 0x000610, "Member 'ADBDPlayer::StrafingOffset' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, PelvisHeight) == 0x00061C, "Member 'ADBDPlayer::PelvisHeight' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, PelvisHeightForPounceOnStandingCamper) == 0x000620, "Member 'ADBDPlayer::PelvisHeightForPounceOnStandingCamper' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, PelvisHeightForPounceOnCrouchingCamper) == 0x000624, "Member 'ADBDPlayer::PelvisHeightForPounceOnCrouchingCamper' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, Authority_OnAttackedDelegate) == 0x000658, "Member 'ADBDPlayer::Authority_OnAttackedDelegate' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnDamageTargetDelegate) == 0x000668, "Member 'ADBDPlayer::OnDamageTargetDelegate' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnSensed) == 0x000678, "Member 'ADBDPlayer::OnSensed' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnAnimNotify_Pickup) == 0x000688, "Member 'ADBDPlayer::OnAnimNotify_Pickup' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnAnimNotify_Release) == 0x000698, "Member 'ADBDPlayer::OnAnimNotify_Release' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, Authority_OnSecondaryActionInput) == 0x0006A8, "Member 'ADBDPlayer::Authority_OnSecondaryActionInput' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnFirstPersonModeChanged) == 0x0006B8, "Member 'ADBDPlayer::OnFirstPersonModeChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnDreamworldComponentSet) == 0x0006C8, "Member 'ADBDPlayer::OnDreamworldComponentSet' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnForwardInputLockedChanged) == 0x0006D8, "Member 'ADBDPlayer::OnForwardInputLockedChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, CameraBoom) == 0x0006E8, "Member 'ADBDPlayer::CameraBoom' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, ForceSkillChecks) == 0x000720, "Member 'ADBDPlayer::ForceSkillChecks' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, IKLeftHandTransform) == 0x000730, "Member 'ADBDPlayer::IKLeftHandTransform' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, IKRightHandTransform) == 0x000760, "Member 'ADBDPlayer::IKRightHandTransform' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, CameraResetSpeed) == 0x000790, "Member 'ADBDPlayer::CameraResetSpeed' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, AverageSpeedBufferTime) == 0x000798, "Member 'ADBDPlayer::AverageSpeedBufferTime' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, AlmostCurrentSpeedBufferTime) == 0x00079C, "Member 'ADBDPlayer::AlmostCurrentSpeedBufferTime' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, GamepadYawCurve) == 0x0007A0, "Member 'ADBDPlayer::GamepadYawCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, GamepadPitchCurve) == 0x0007A8, "Member 'ADBDPlayer::GamepadPitchCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, GamepadSettingToYawRateCurve) == 0x0007B0, "Member 'ADBDPlayer::GamepadSettingToYawRateCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, GamepadSettingToPitchRateCurve) == 0x0007B8, "Member 'ADBDPlayer::GamepadSettingToPitchRateCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, JoyconSettingToYawRateCurve) == 0x0007C0, "Member 'ADBDPlayer::JoyconSettingToYawRateCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, JoyconSettingToPitchRateCurve) == 0x0007C8, "Member 'ADBDPlayer::JoyconSettingToPitchRateCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnIsCrouchedChanged) == 0x0007D0, "Member 'ADBDPlayer::OnIsCrouchedChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnRunningAndMovingChanged) == 0x0007E0, "Member 'ADBDPlayer::OnRunningAndMovingChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, OnLocallyObservedChangedForPlayer) == 0x000810, "Member 'ADBDPlayer::OnLocallyObservedChangedForPlayer' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, Camera) == 0x000820, "Member 'ADBDPlayer::Camera' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, MaterialHelper) == 0x000828, "Member 'ADBDPlayer::MaterialHelper' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, Interactable) == 0x000860, "Member 'ADBDPlayer::Interactable' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _characterInventoryComponent) == 0x000880, "Member 'ADBDPlayer::_characterInventoryComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, CarryJointName) == 0x000888, "Member 'ADBDPlayer::CarryJointName' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _pitchOffsetForInteractionPriority) == 0x000894, "Member 'ADBDPlayer::_pitchOffsetForInteractionPriority' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _renderedPixelCounter) == 0x000898, "Member 'ADBDPlayer::_renderedPixelCounter' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _standingOcclusionBox) == 0x0008A0, "Member 'ADBDPlayer::_standingOcclusionBox' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _crouchingOcclusionBox) == 0x0008A8, "Member 'ADBDPlayer::_crouchingOcclusionBox' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _activator) == 0x0008B0, "Member 'ADBDPlayer::_activator' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, IsInteracting) == 0x0008B8, "Member 'ADBDPlayer::IsInteracting' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _aiCanBeSeenTestCrouchScale) == 0x0008BC, "Member 'ADBDPlayer::_aiCanBeSeenTestCrouchScale' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _aiCanBeSeenTestRightOffset) == 0x0008C0, "Member 'ADBDPlayer::_aiCanBeSeenTestRightOffset' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _aiCanBeSeenTestHighOffset) == 0x0008C4, "Member 'ADBDPlayer::_aiCanBeSeenTestHighOffset' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _aiCanBeSeenTestLowOffset) == 0x0008C8, "Member 'ADBDPlayer::_aiCanBeSeenTestLowOffset' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, ClearPathTestRadiusMultiplier) == 0x0008CC, "Member 'ADBDPlayer::ClearPathTestRadiusMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, ClearPathTestHeightMultiplier) == 0x0008D0, "Member 'ADBDPlayer::ClearPathTestHeightMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, LocationClearTestRadiusMultiplier) == 0x0008D4, "Member 'ADBDPlayer::LocationClearTestRadiusMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, LocationClearTestHeightMultiplier) == 0x0008D8, "Member 'ADBDPlayer::LocationClearTestHeightMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, ClearPathTestStepHeight) == 0x0008DC, "Member 'ADBDPlayer::ClearPathTestStepHeight' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, MouseTurnSpeedMultiplier) == 0x0008E0, "Member 'ADBDPlayer::MouseTurnSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, MouseLookUpSpeedMultiplier) == 0x0008E4, "Member 'ADBDPlayer::MouseLookUpSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, DeathSound) == 0x0008E8, "Member 'ADBDPlayer::DeathSound' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, CurrentCamperState) == 0x0008F0, "Member 'ADBDPlayer::CurrentCamperState' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, CollectableAttachPoint) == 0x0008F4, "Member 'ADBDPlayer::CollectableAttachPoint' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _stateMachine) == 0x000900, "Member 'ADBDPlayer::_stateMachine' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _interactionHandler) == 0x000908, "Member 'ADBDPlayer::_interactionHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _montagePlayer) == 0x000910, "Member 'ADBDPlayer::_montagePlayer' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _perkManager) == 0x000918, "Member 'ADBDPlayer::_perkManager' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _playerData) == 0x000920, "Member 'ADBDPlayer::_playerData' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _interactable) == 0x000928, "Member 'ADBDPlayer::_interactable' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _guidingPlayer) == 0x000980, "Member 'ADBDPlayer::_guidingPlayer' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _interactingPlayer) == 0x000990, "Member 'ADBDPlayer::_interactingPlayer' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _nextAttackSubstate) == 0x0009C8, "Member 'ADBDPlayer::_nextAttackSubstate' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _hitTargets) == 0x0009D0, "Member 'ADBDPlayer::_hitTargets' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _dreamworldComponent) == 0x0009E0, "Member 'ADBDPlayer::_dreamworldComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _characterChaseVisualComponent) == 0x0009E8, "Member 'ADBDPlayer::_characterChaseVisualComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _cameraHandlerComponent) == 0x0009F0, "Member 'ADBDPlayer::_cameraHandlerComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _reversibleActionSystemComponent) == 0x0009F8, "Member 'ADBDPlayer::_reversibleActionSystemComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _itemDropOffPosition) == 0x000A00, "Member 'ADBDPlayer::_itemDropOffPosition' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _perceptionStimuliComponent) == 0x000A08, "Member 'ADBDPlayer::_perceptionStimuliComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _ignoreActors) == 0x000A10, "Member 'ADBDPlayer::_ignoreActors' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, EffectCameraTypeSettings) == 0x000A20, "Member 'ADBDPlayer::EffectCameraTypeSettings' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _detectionZoneEnabledMap) == 0x000A30, "Member 'ADBDPlayer::_detectionZoneEnabledMap' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _blindingChargeableComponent) == 0x000AA8, "Member 'ADBDPlayer::_blindingChargeableComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _shouldUpdateStateMachineDriverOnPossessed) == 0x000B40, "Member 'ADBDPlayer::_shouldUpdateStateMachineDriverOnPossessed' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _blindableComponent) == 0x000B48, "Member 'ADBDPlayer::_blindableComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _tutorialChargeableInteractionMultiplier) == 0x000B54, "Member 'ADBDPlayer::_tutorialChargeableInteractionMultiplier' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _eventListener) == 0x000B60, "Member 'ADBDPlayer::_eventListener' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _chaseComponent) == 0x000B70, "Member 'ADBDPlayer::_chaseComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _meatHookZoneDetector) == 0x000B78, "Member 'ADBDPlayer::_meatHookZoneDetector' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _basementZoneDetector) == 0x000B80, "Member 'ADBDPlayer::_basementZoneDetector' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _animGameplayTags) == 0x000BC8, "Member 'ADBDPlayer::_animGameplayTags' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _bookmarkedInteraction) == 0x000C40, "Member 'ADBDPlayer::_bookmarkedInteraction' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _detectionZoneMap) == 0x000C48, "Member 'ADBDPlayer::_detectionZoneMap' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _authoritativeMovementComponent) == 0x000CF8, "Member 'ADBDPlayer::_authoritativeMovementComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _screenAspectRatio) == 0x000FF0, "Member 'ADBDPlayer::_screenAspectRatio' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _objectState) == 0x001010, "Member 'ADBDPlayer::_objectState' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _audioFXComponent) == 0x001018, "Member 'ADBDPlayer::_audioFXComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _playerPerspectiveComponent) == 0x001020, "Member 'ADBDPlayer::_playerPerspectiveComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _characterSightComponent) == 0x001030, "Member 'ADBDPlayer::_characterSightComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _characterSightableComponent) == 0x001040, "Member 'ADBDPlayer::_characterSightableComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _interactionDetectorComponent) == 0x001058, "Member 'ADBDPlayer::_interactionDetectorComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _clippablePrimitivesRegistererComponent) == 0x001060, "Member 'ADBDPlayer::_clippablePrimitivesRegistererComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _clippableProviderComponent) == 0x001068, "Member 'ADBDPlayer::_clippableProviderComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _dynCapsuleResizer) == 0x001070, "Member 'ADBDPlayer::_dynCapsuleResizer' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _playerGameRelevancyComponent) == 0x001078, "Member 'ADBDPlayer::_playerGameRelevancyComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _contextualQuestComponent) == 0x001080, "Member 'ADBDPlayer::_contextualQuestComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _questEventHandler) == 0x0010A8, "Member 'ADBDPlayer::_questEventHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _presentationChargeableProgressComponent) == 0x0010B0, "Member 'ADBDPlayer::_presentationChargeableProgressComponent' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _currentGamepadYawCurve) == 0x0010D0, "Member 'ADBDPlayer::_currentGamepadYawCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _currentGamepadPitchCurve) == 0x0010D8, "Member 'ADBDPlayer::_currentGamepadPitchCurve' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _associatedPlayerStateCache) == 0x0010E0, "Member 'ADBDPlayer::_associatedPlayerStateCache' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _onMovementCacheStruct) == 0x0010E8, "Member 'ADBDPlayer::_onMovementCacheStruct' has a wrong offset!");
static_assert(offsetof(ADBDPlayer, _otherCharactersVerticalCollisionsHandler) == 0x0010F8, "Member 'ADBDPlayer::_otherCharactersVerticalCollisionsHandler' has a wrong offset!");

// Class DeadByDaylight.UMGPartyBotSlotWidget
// 0x0180 (0x04B8 - 0x0338)
class UUMGPartyBotSlotWidget final : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             RoleText;                                          // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             BotDifficultyText;                                 // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CharacterNameText;                                 // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBaseButtonWidget*                   EditButton;                                        // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 EditIcon;                                          // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBaseButtonWidget*                   InvitePartyButton;                                 // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           InvitePartyCanvas;                                 // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EAIDifficultyLevel, struct FSlateColor>  DifficultyColors;                                  // 0x0370(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0xF8];                                     // 0x03C0(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleEditButtonEvent();
	void HandleInvitePartyButtonEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPartyBotSlotWidget">();
	}
	static class UUMGPartyBotSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPartyBotSlotWidget>();
	}
};
static_assert(alignof(UUMGPartyBotSlotWidget) == 0x000008, "Wrong alignment on UUMGPartyBotSlotWidget");
static_assert(sizeof(UUMGPartyBotSlotWidget) == 0x0004B8, "Wrong size on UUMGPartyBotSlotWidget");
static_assert(offsetof(UUMGPartyBotSlotWidget, RoleText) == 0x000338, "Member 'UUMGPartyBotSlotWidget::RoleText' has a wrong offset!");
static_assert(offsetof(UUMGPartyBotSlotWidget, BotDifficultyText) == 0x000340, "Member 'UUMGPartyBotSlotWidget::BotDifficultyText' has a wrong offset!");
static_assert(offsetof(UUMGPartyBotSlotWidget, CharacterNameText) == 0x000348, "Member 'UUMGPartyBotSlotWidget::CharacterNameText' has a wrong offset!");
static_assert(offsetof(UUMGPartyBotSlotWidget, EditButton) == 0x000350, "Member 'UUMGPartyBotSlotWidget::EditButton' has a wrong offset!");
static_assert(offsetof(UUMGPartyBotSlotWidget, EditIcon) == 0x000358, "Member 'UUMGPartyBotSlotWidget::EditIcon' has a wrong offset!");
static_assert(offsetof(UUMGPartyBotSlotWidget, InvitePartyButton) == 0x000360, "Member 'UUMGPartyBotSlotWidget::InvitePartyButton' has a wrong offset!");
static_assert(offsetof(UUMGPartyBotSlotWidget, InvitePartyCanvas) == 0x000368, "Member 'UUMGPartyBotSlotWidget::InvitePartyCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPartyBotSlotWidget, DifficultyColors) == 0x000370, "Member 'UUMGPartyBotSlotWidget::DifficultyColors' has a wrong offset!");

// Class DeadByDaylight.DBDCheatValidatorSubsystem
// 0x0000 (0x0038 - 0x0038)
class UDBDCheatValidatorSubsystem final : public UEngineSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCheatValidatorSubsystem">();
	}
	static class UDBDCheatValidatorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCheatValidatorSubsystem>();
	}
};
static_assert(alignof(UDBDCheatValidatorSubsystem) == 0x000008, "Wrong alignment on UDBDCheatValidatorSubsystem");
static_assert(sizeof(UDBDCheatValidatorSubsystem) == 0x000038, "Wrong size on UDBDCheatValidatorSubsystem");

// Class DeadByDaylight.TutorialGameState
// 0x00A0 (0x0908 - 0x0868)
class ATutorialGameState final : public ADBDGameState
{
public:
	TMulticastInlineDelegate<void(ETutorialStep step)> OnCurrentTutorialStepChanged;                 // 0x0868(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_878[0x38];                                     // 0x0878(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _forceHatchVisible;                                // 0x08B0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8B1[0x57];                                     // 0x08B1(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurrentTutorialStep(ETutorialStep step);
	void SetForcedHatchVisibility(bool isHatchVisible);
	void TutorialEndReached();

	void CompleteLocallyControlledCharacterIntros() const;
	ETutorialStep GetCurrentTutorialStep() const;
	bool IsTutorialStarted() const;
	void SetEscapeRequirementsVisibility(bool isVisible) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialGameState">();
	}
	static class ATutorialGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialGameState>();
	}
};
static_assert(alignof(ATutorialGameState) == 0x000008, "Wrong alignment on ATutorialGameState");
static_assert(sizeof(ATutorialGameState) == 0x000908, "Wrong size on ATutorialGameState");
static_assert(offsetof(ATutorialGameState, OnCurrentTutorialStepChanged) == 0x000868, "Member 'ATutorialGameState::OnCurrentTutorialStepChanged' has a wrong offset!");
static_assert(offsetof(ATutorialGameState, _forceHatchVisible) == 0x0008B0, "Member 'ATutorialGameState::_forceHatchVisible' has a wrong offset!");

// Class DeadByDaylight.CamperPlayer
// 0x04C0 (0x1620 - 0x1160)
class ACamperPlayer final : public ADBDPlayer
{
public:
	uint8                                         Pad_1158[0x20];                                    // 0x1158(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnHookedStateChanged;                              // 0x1178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnGuidedStateChanged;                              // 0x1188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* picker)> OnPickedUpDelegate;                     // 0x1198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* picker)> OnPickedUpEndDelegate;                  // 0x11A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnHPSlotChanged;                                   // 0x11B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C8[0x40];                                    // 0x11C8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(ECamperImmobilizeState oldState, ECamperImmobilizeState newState)> OnImmobilizeStateChanged; // 0x1208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1218[0x30];                                    // 0x1218(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnHookEscapeFailedCosmetic;                        // 0x1248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   ReverseBearTrapAttachSocket;                       // 0x1258(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isBeingDissolved;                                  // 0x1264(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1265[0x3];                                     // 0x1265(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootprintAudibleRange;                             // 0x1268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_126C[0x4];                                     // 0x126C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStalkedComponent*                      StalkedComponent;                                  // 0x1270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraResetToleranceYaw;                           // 0x1278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraResetTolerancePitch;                         // 0x127C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRecenterOffsetYaw;                           // 0x1280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRecenterOffsetPitch;                         // 0x1284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGender                                       Gender;                                            // 0x1288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1289[0x7];                                     // 0x1289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DropStaggerDuration;                               // 0x1290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DropStaggerMaxSpeed;                               // 0x1298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeforDeathWhileCrawling;                         // 0x12A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeforDeathWhileHooked;                           // 0x12A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondsUntilFootprintTrigger;                      // 0x12A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TriggerAfflictionHUDIntro;                         // 0x12AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12AD[0x93];                                    // 0x12AD(0x0093)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      _storedPlayerController;                           // 0x1340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCamperStillnessTrackerComponent*       _stillnessTracker;                                 // 0x1348(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PartiallyHiddenStillnessThreshold;                 // 0x1350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1354[0x4];                                     // 0x1354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _escape;                                           // 0x1358(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _overlappingEscape;                                // 0x1360(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpherePlayerOverlapComponent*          ProximityZone;                                     // 0x1368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1370[0x18];                                    // 0x1370(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      SlashableZone;                                     // 0x1388(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      HookSlashableZone;                                 // 0x1390(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCamperSlashableComponent*              _camperSlashable;                                  // 0x1398(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrouchCapsuleHalfHeight;                           // 0x13A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IKOffsetRightFoot;                                 // 0x13A4(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IKOffsetLeftFoot;                                  // 0x13A8(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13AC[0xC];                                     // 0x13AC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDPawnSensingComponent*               _camperSensor;                                     // 0x13B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USurviveTimerScoreEventComponent*       _surviveTimerScoreComponent;                       // 0x13C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C8[0x18];                                    // 0x13C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _foundCampers;                                     // 0x13E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ADBDPlayer*>                     _potentialSaviors;                                 // 0x13F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UCamperHealthComponent*                 _healthComponent;                                  // 0x1400(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _hpSlot01;                                         // 0x1408(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _hpSlot02;                                         // 0x1410(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _mendChargeable;                                   // 0x1418(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodTrailSettings*                    _bloodTrailSettings;                               // 0x1420(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCamperBloodTrailComponent*             _bloodTrailComponent;                              // 0x1428(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraAttachmentComponent*             _cameraAttachment;                                 // 0x1430(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharmSpawnerComponent*                 _charmSpawnerComponent;                            // 0x1438(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHookableComponent*                     _hookableComponent;                                // 0x1440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHookAntiCampingComponent*              _hookAntiCampingComponent;                         // 0x1448(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UProtectionHitComponent*                _protectionHitComponent;                           // 0x1450(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UScreamComponent*                       _screamComponent;                                  // 0x1458(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCharacterPositionRecorderComponent*    _positionRecorder;                                 // 0x1460(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1468[0xA5];                                    // 0x1468(0x00A5)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _lastEscaped;                                      // 0x150D(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150E[0x6];                                     // 0x150E(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _runInputPressed;                                  // 0x1514(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1515[0x23];                                    // 0x1515(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _trapIndicatorActive;                              // 0x1538(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1539[0x7];                                     // 0x1539(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCamperEndGameComponent*                _camperEndGameComponent;                           // 0x1540(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           _noOcclusionAkComponent;                           // 0x1548(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           _attenuationAkComponent;                           // 0x1550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1558[0x24];                                    // 0x1558(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isHealingKOCamper;                                // 0x157C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isSkillCheckFailed;                               // 0x157D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isBeingSacrificed;                                // 0x157E(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isWiggleProgressionAllowed;                       // 0x157F(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1580[0x70];                                    // 0x1580(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UMoveComponentToComponent*              _meshMover;                                        // 0x15F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCarriedMovementComponent*              _carriedMovementComponent;                         // 0x15F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USurvivorHitSprintEffect*               _sprintEffect;                                     // 0x1600(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1608[0x18];                                    // 0x1608(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionInputPressed();
	void ActionInputReleased();
	void ActivateLocalPlayerExposedVFX();
	void ActivatePlayerExposedVFX();
	void AddBloodDecalToGK_Mori();
	void AddBloodDrippingToGK_Mori();
	void AddBloodDropsToLeftHand();
	void AddBloodDropsToRightHand();
	void AttachToGuidingPlayer();
	void Authority_ApplySprintEffect();
	void Authority_DropItemAtLastSafePosition();
	void Authority_OnSlashed(class ADBDPlayer* attacker);
	void Authority_SetImmobilized(ECamperImmobilizeState state);
	void CallOnDroppedByBearTrap();
	void Client_OnSlashedOutOfTrap(class ADBDPlayer* requester);
	bool ComputeBeartrapEscapeResult();
	bool ComputeHookEscapeResult();
	float ComputeInteractionSuccessPercentage(const class UInteractionDefinition* interaction);
	void DBD_CheatEscaped();
	void DBD_ForceRun(bool forced);
	void DBD_LeaveParadise();
	void DBD_SetImmobilized(ECamperImmobilizeState state);
	void DBD_SetSurvivorCameraArmLength(float cameraArmLength);
	void DBD_SetSurvivorCameraArmLengthCommand(float cameraArmLength);
	void DecalBlood_Puddles();
	void DetachFromGuidingPlayer();
	void DoSacrificialDissolve();
	void EscapeTutorial();
	void EventOnDeath();
	class UCamperStillnessTrackerComponent* GetCamperStillnessComponent();
	bool GetIsHealingKOCamper();
	bool GetIsSkillCheckFailed();
	class UAnimationMontageSlave* GetMontageFollower();
	void HatchEscapeZoneEntered(class AActor* escape);
	void Input_ToggleRun();
	bool IsRunLocked();
	void Kill(EHealthType healthType);
	void Local_SetImmobilized(ECamperImmobilizeState state);
	void MakeCamperDisappear();
	void MakeCamperDisappearBleedOut();
	void Multicast_EscapeItemEvents(bool isItemFromSpawn);
	void Multicast_RemoveReverseBearTrap();
	void Multicast_SetAuthoritativeMovementFlag(EAuthoritativeMovementFlag flag, bool value);
	void Multicast_SetGuidedAction(ECamperGuidedAction action);
	void Multicast_SetHookEscapeAutoFail(bool enabled);
	void Multicast_SetImmobilized(ECamperImmobilizeState state);
	void Multicast_SetOverlappingEscape(class AActor* escape);
	void OnDroppedByBearTrap();
	void OnDroppedEnd(bool clearLeader);
	void OnDroppedStart();
	void OnFinishedPlaying();
	void OnHooked();
	void OnHookedStateChangedCosmetic(bool hooked);
	void OnHpSlotSkillCheckResponseAesthetic(bool success, bool bonus, class ADBDPlayer* player, bool triggerLoudNoise, bool hadInput, ESkillCheckCustomType type, float chargeChange);
	void OnObsessionChanged(class ACamperPlayer* newObsession, class ACamperPlayer* previousObsession);
	void OnPawnSensed(class APawn* pawn);
	void OnPickUpDenied();
	void OnPickUpEnter(class ADBDPlayer* picker, float transitionTime);
	void OnProximityEntered(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult);
	void OnRep_RunInputPressed();
	void OnRep_SprintEffect();
	void OnUnhooked();
	void RemoveReverseBearTrap();
	void ResetCameraAttach();
	void ResetPotentialSaviors();
	void RunLocked(bool lock);
	void Server_SetOverlappingEscape(class AActor* escape);
	void Server_SetRunInput(bool pressed);
	void SetBeingCarried(bool isBeingCarried, class ADBDPlayer* carrier);
	void SetGuidedAction(ECamperGuidedAction action);
	void SetGuidedActionLocal(ECamperGuidedAction action);
	void SetIsHealingKOCamper(bool isHealingKOCamper);
	void SetIsSkillCheckFailed(bool isSkillCheckFailed);
	void SetPlayerExposedVFX();
	void SetVignetteVisible(bool visible);
	void StartHealingTimer(float time);
	void StopHealingTimer();
	void TriggerAfflictionHUDFeedback();
	void TriggerPickUpAnimation();
	void TriggerPutDownAnimation();
	void UpdateHealingTimer(float deltaTime);

	bool AcceptsHealing() const;
	bool CanBeKilled() const;
	bool CanBePickedUp() const;
	bool CanBeShocked() const;
	bool CanRushQuietly() const;
	struct FVector GetAimPoint() const;
	TArray<class UDBDClipRegionComponent*> GetAllEntityRenderRegions() const;
	class UAkComponent* GetAttenuationAudioComponent() const;
	class UCamperBloodTrailComponent* GetBloodTrailComponent() const;
	class UCameraAttachmentComponent* GetCameraAttachmentComponent() const;
	class UDBDCamperData* GetCamperData() const;
	class UChaseeCharacterComponent* GetChaseeCharacterComponent() const;
	class UDBDClipRegionComponent* GetEntityRenderRegionAtIndex(int32 InIndex) const;
	ECamperGuidedAction GetGuidedAction() const;
	class UCamperHealthComponent* GetHealthComponent() const;
	class UHookableComponent* GetHookableComponent() const;
	class UHookAntiCampingComponent* GetHookAntiCampingComponent() const;
	ECamperImmobilizeState GetImmobilizedState() const;
	bool GetIsBeingDissolved() const;
	bool GetIsWiggleProgressionAllowed() const;
	float GetMaxGruntDistance(bool isLocalPlayerKiller) const;
	class UMoveComponentToComponent* GetMeshMover() const;
	class UAkComponent* GetNoOcclusionAudioComponent() const;
	int32 GetNumberOfEntityRenderRegions() const;
	float GetObsessionTargetWeight() const;
	class AActor* GetOverlappingEscape() const;
	float GetPercentHealingTimer() const;
	class AReverseBearTrap* GetReverseBearTrap() const;
	float GetStillness() const;
	struct FRotator GetToAimPointRotation() const;
	class UChargeableComponent* GetWiggleChargeable() const;
	bool HasGuidedAction() const;
	bool HasHitEvents() const;
	bool HasReverseBearTrap() const;
	bool IsBeingCarried() const;
	bool IsBeingEndGameSacrificed() const;
	bool IsBeingHealed() const;
	bool IsBeingInteractedWith() const;
	bool IsBeingKilled() const;
	bool IsBeingMended() const;
	bool IsBeingPickedUp() const;
	bool IsBeingPulledFromCloset() const;
	bool IsBeingPutDown() const;
	bool IsBeingPutOnHook() const;
	bool IsBeingUnhooked() const;
	bool IsCrawling() const;
	bool IsDeadOrInParadise() const;
	bool IsEscaped() const;
	bool IsGuidedBySlasher() const;
	bool IsHealingTimerExpired() const;
	bool IsHooked() const;
	bool IsImmobilized() const;
	bool IsInDeathBed() const;
	bool IsInNeed() const;
	bool IsMovementGuided() const;
	bool IsObsessionTarget() const;
	bool IsSacrificed() const;
	bool IsTrapped() const;
	bool IsUnhookingSelf() const;
	bool IsUnintentionallyImmobilized() const;
	bool IsVaulting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperPlayer">();
	}
	static class ACamperPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACamperPlayer>();
	}
};
static_assert(alignof(ACamperPlayer) == 0x000010, "Wrong alignment on ACamperPlayer");
static_assert(sizeof(ACamperPlayer) == 0x001620, "Wrong size on ACamperPlayer");
static_assert(offsetof(ACamperPlayer, OnHookedStateChanged) == 0x001178, "Member 'ACamperPlayer::OnHookedStateChanged' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, OnGuidedStateChanged) == 0x001188, "Member 'ACamperPlayer::OnGuidedStateChanged' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, OnPickedUpDelegate) == 0x001198, "Member 'ACamperPlayer::OnPickedUpDelegate' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, OnPickedUpEndDelegate) == 0x0011A8, "Member 'ACamperPlayer::OnPickedUpEndDelegate' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, OnHPSlotChanged) == 0x0011B8, "Member 'ACamperPlayer::OnHPSlotChanged' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, OnImmobilizeStateChanged) == 0x001208, "Member 'ACamperPlayer::OnImmobilizeStateChanged' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, OnHookEscapeFailedCosmetic) == 0x001248, "Member 'ACamperPlayer::OnHookEscapeFailedCosmetic' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, ReverseBearTrapAttachSocket) == 0x001258, "Member 'ACamperPlayer::ReverseBearTrapAttachSocket' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, isBeingDissolved) == 0x001264, "Member 'ACamperPlayer::isBeingDissolved' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, FootprintAudibleRange) == 0x001268, "Member 'ACamperPlayer::FootprintAudibleRange' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, StalkedComponent) == 0x001270, "Member 'ACamperPlayer::StalkedComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, CameraResetToleranceYaw) == 0x001278, "Member 'ACamperPlayer::CameraResetToleranceYaw' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, CameraResetTolerancePitch) == 0x00127C, "Member 'ACamperPlayer::CameraResetTolerancePitch' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, CameraRecenterOffsetYaw) == 0x001280, "Member 'ACamperPlayer::CameraRecenterOffsetYaw' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, CameraRecenterOffsetPitch) == 0x001284, "Member 'ACamperPlayer::CameraRecenterOffsetPitch' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, Gender) == 0x001288, "Member 'ACamperPlayer::Gender' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, DropStaggerDuration) == 0x001290, "Member 'ACamperPlayer::DropStaggerDuration' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, DropStaggerMaxSpeed) == 0x001298, "Member 'ACamperPlayer::DropStaggerMaxSpeed' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, TimeforDeathWhileCrawling) == 0x0012A0, "Member 'ACamperPlayer::TimeforDeathWhileCrawling' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, TimeforDeathWhileHooked) == 0x0012A4, "Member 'ACamperPlayer::TimeforDeathWhileHooked' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, SecondsUntilFootprintTrigger) == 0x0012A8, "Member 'ACamperPlayer::SecondsUntilFootprintTrigger' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, TriggerAfflictionHUDIntro) == 0x0012AC, "Member 'ACamperPlayer::TriggerAfflictionHUDIntro' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _storedPlayerController) == 0x001340, "Member 'ACamperPlayer::_storedPlayerController' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _stillnessTracker) == 0x001348, "Member 'ACamperPlayer::_stillnessTracker' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, PartiallyHiddenStillnessThreshold) == 0x001350, "Member 'ACamperPlayer::PartiallyHiddenStillnessThreshold' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _escape) == 0x001358, "Member 'ACamperPlayer::_escape' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _overlappingEscape) == 0x001360, "Member 'ACamperPlayer::_overlappingEscape' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, ProximityZone) == 0x001368, "Member 'ACamperPlayer::ProximityZone' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, SlashableZone) == 0x001388, "Member 'ACamperPlayer::SlashableZone' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, HookSlashableZone) == 0x001390, "Member 'ACamperPlayer::HookSlashableZone' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _camperSlashable) == 0x001398, "Member 'ACamperPlayer::_camperSlashable' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, CrouchCapsuleHalfHeight) == 0x0013A0, "Member 'ACamperPlayer::CrouchCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, IKOffsetRightFoot) == 0x0013A4, "Member 'ACamperPlayer::IKOffsetRightFoot' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, IKOffsetLeftFoot) == 0x0013A8, "Member 'ACamperPlayer::IKOffsetLeftFoot' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _camperSensor) == 0x0013B8, "Member 'ACamperPlayer::_camperSensor' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _surviveTimerScoreComponent) == 0x0013C0, "Member 'ACamperPlayer::_surviveTimerScoreComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _foundCampers) == 0x0013E0, "Member 'ACamperPlayer::_foundCampers' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _potentialSaviors) == 0x0013F0, "Member 'ACamperPlayer::_potentialSaviors' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _healthComponent) == 0x001400, "Member 'ACamperPlayer::_healthComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _hpSlot01) == 0x001408, "Member 'ACamperPlayer::_hpSlot01' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _hpSlot02) == 0x001410, "Member 'ACamperPlayer::_hpSlot02' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _mendChargeable) == 0x001418, "Member 'ACamperPlayer::_mendChargeable' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _bloodTrailSettings) == 0x001420, "Member 'ACamperPlayer::_bloodTrailSettings' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _bloodTrailComponent) == 0x001428, "Member 'ACamperPlayer::_bloodTrailComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _cameraAttachment) == 0x001430, "Member 'ACamperPlayer::_cameraAttachment' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _charmSpawnerComponent) == 0x001438, "Member 'ACamperPlayer::_charmSpawnerComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _hookableComponent) == 0x001440, "Member 'ACamperPlayer::_hookableComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _hookAntiCampingComponent) == 0x001448, "Member 'ACamperPlayer::_hookAntiCampingComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _protectionHitComponent) == 0x001450, "Member 'ACamperPlayer::_protectionHitComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _screamComponent) == 0x001458, "Member 'ACamperPlayer::_screamComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _positionRecorder) == 0x001460, "Member 'ACamperPlayer::_positionRecorder' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _lastEscaped) == 0x00150D, "Member 'ACamperPlayer::_lastEscaped' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _runInputPressed) == 0x001514, "Member 'ACamperPlayer::_runInputPressed' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _trapIndicatorActive) == 0x001538, "Member 'ACamperPlayer::_trapIndicatorActive' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _camperEndGameComponent) == 0x001540, "Member 'ACamperPlayer::_camperEndGameComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _noOcclusionAkComponent) == 0x001548, "Member 'ACamperPlayer::_noOcclusionAkComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _attenuationAkComponent) == 0x001550, "Member 'ACamperPlayer::_attenuationAkComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _isHealingKOCamper) == 0x00157C, "Member 'ACamperPlayer::_isHealingKOCamper' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _isSkillCheckFailed) == 0x00157D, "Member 'ACamperPlayer::_isSkillCheckFailed' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _isBeingSacrificed) == 0x00157E, "Member 'ACamperPlayer::_isBeingSacrificed' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _isWiggleProgressionAllowed) == 0x00157F, "Member 'ACamperPlayer::_isWiggleProgressionAllowed' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _meshMover) == 0x0015F0, "Member 'ACamperPlayer::_meshMover' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _carriedMovementComponent) == 0x0015F8, "Member 'ACamperPlayer::_carriedMovementComponent' has a wrong offset!");
static_assert(offsetof(ACamperPlayer, _sprintEffect) == 0x001600, "Member 'ACamperPlayer::_sprintEffect' has a wrong offset!");

// Class DeadByDaylight.CamperSlashableComponent
// 0x00F0 (0x01A8 - 0x00B8)
class UCamperSlashableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      _slashableZone;                                    // 0x00C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      _hookSlashableZone;                                // 0x00C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _standingCapsuleHalfHeight;                        // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _crouchCapsuleHalfHeight;                          // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _slashableDisablingStateTags;                      // 0x00D8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _sourceActivationLingerDuration;                   // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x2C];                                      // 0x00FC(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	class USlashableActivationSourceCollection*   _slashableActivationSources;                       // 0x0128(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x78];                                     // 0x0130(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCrouchCapsuleHalfHeight(float height);
	void SetHookSlashableZone(class UCapsuleComponent* zone);
	void SetSlashableZone(class UCapsuleComponent* zone);
	void SetStandingCapsuleHalfHeight(float height);
	void SetUseCrouchSlashableCapsule(bool useCrouchCapsule);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperSlashableComponent">();
	}
	static class UCamperSlashableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperSlashableComponent>();
	}
};
static_assert(alignof(UCamperSlashableComponent) == 0x000008, "Wrong alignment on UCamperSlashableComponent");
static_assert(sizeof(UCamperSlashableComponent) == 0x0001A8, "Wrong size on UCamperSlashableComponent");
static_assert(offsetof(UCamperSlashableComponent, _slashableZone) == 0x0000C0, "Member 'UCamperSlashableComponent::_slashableZone' has a wrong offset!");
static_assert(offsetof(UCamperSlashableComponent, _hookSlashableZone) == 0x0000C8, "Member 'UCamperSlashableComponent::_hookSlashableZone' has a wrong offset!");
static_assert(offsetof(UCamperSlashableComponent, _standingCapsuleHalfHeight) == 0x0000D0, "Member 'UCamperSlashableComponent::_standingCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UCamperSlashableComponent, _crouchCapsuleHalfHeight) == 0x0000D4, "Member 'UCamperSlashableComponent::_crouchCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UCamperSlashableComponent, _slashableDisablingStateTags) == 0x0000D8, "Member 'UCamperSlashableComponent::_slashableDisablingStateTags' has a wrong offset!");
static_assert(offsetof(UCamperSlashableComponent, _sourceActivationLingerDuration) == 0x0000F8, "Member 'UCamperSlashableComponent::_sourceActivationLingerDuration' has a wrong offset!");
static_assert(offsetof(UCamperSlashableComponent, _slashableActivationSources) == 0x000128, "Member 'UCamperSlashableComponent::_slashableActivationSources' has a wrong offset!");

// Class DeadByDaylight.DBDBloodwebDefinitionBase
// 0x0000 (0x0000 - 0x0000)
class IDBDBloodwebDefinitionBase final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBloodwebDefinitionBase">();
	}
	static class IDBDBloodwebDefinitionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDBDBloodwebDefinitionBase>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDBDBloodwebDefinitionBase) == 0x000001, "Wrong alignment on IDBDBloodwebDefinitionBase");
static_assert(sizeof(IDBDBloodwebDefinitionBase) == 0x000001, "Wrong size on IDBDBloodwebDefinitionBase");

// Class DeadByDaylight.PlayerStateMachine
// 0x0000 (0x0130 - 0x0130)
class UPlayerStateMachine : public UStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateMachine">();
	}
	static class UPlayerStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStateMachine>();
	}
};
static_assert(alignof(UPlayerStateMachine) == 0x000010, "Wrong alignment on UPlayerStateMachine");
static_assert(sizeof(UPlayerStateMachine) == 0x000130, "Wrong size on UPlayerStateMachine");

// Class DeadByDaylight.CamperStateMachine
// 0x0000 (0x0130 - 0x0130)
class UCamperStateMachine final : public UPlayerStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperStateMachine">();
	}
	static class UCamperStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperStateMachine>();
	}
};
static_assert(alignof(UCamperStateMachine) == 0x000010, "Wrong alignment on UCamperStateMachine");
static_assert(sizeof(UCamperStateMachine) == 0x000130, "Wrong size on UCamperStateMachine");

// Class DeadByDaylight.ColorBlindSettingsListenerInterface
// 0x0000 (0x0000 - 0x0000)
class IColorBlindSettingsListenerInterface final
{
public:
	void OnColorBlindSettingsChange(EColorVisionDeficiency colorBlindMode, int32 colorBlindIntensity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ColorBlindSettingsListenerInterface">();
	}
	static class IColorBlindSettingsListenerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IColorBlindSettingsListenerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IColorBlindSettingsListenerInterface) == 0x000001, "Wrong alignment on IColorBlindSettingsListenerInterface");
static_assert(sizeof(IColorBlindSettingsListenerInterface) == 0x000001, "Wrong size on IColorBlindSettingsListenerInterface");

// Class DeadByDaylight.StillnessTrackerComponent
// 0x0038 (0x00F0 - 0x00B8)
class UStillnessTrackerComponent : public UActorComponent
{
public:
	float                                         SpeedThreshold;                                    // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceThreshold;                                 // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceDecay;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DecayWhileMoving;                                  // 0x00C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StillnessThreshhold;                               // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StillnessTimerLimit;                               // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecaySpeedMultiplier;                              // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x8];                                       // 0x00D4(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ADBDPlayer>              _trackedPlayer;                                    // 0x00DC(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0xC];                                       // 0x00E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartTracking();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StillnessTrackerComponent">();
	}
	static class UStillnessTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStillnessTrackerComponent>();
	}
};
static_assert(alignof(UStillnessTrackerComponent) == 0x000008, "Wrong alignment on UStillnessTrackerComponent");
static_assert(sizeof(UStillnessTrackerComponent) == 0x0000F0, "Wrong size on UStillnessTrackerComponent");
static_assert(offsetof(UStillnessTrackerComponent, SpeedThreshold) == 0x0000B8, "Member 'UStillnessTrackerComponent::SpeedThreshold' has a wrong offset!");
static_assert(offsetof(UStillnessTrackerComponent, DistanceThreshold) == 0x0000BC, "Member 'UStillnessTrackerComponent::DistanceThreshold' has a wrong offset!");
static_assert(offsetof(UStillnessTrackerComponent, DistanceDecay) == 0x0000C0, "Member 'UStillnessTrackerComponent::DistanceDecay' has a wrong offset!");
static_assert(offsetof(UStillnessTrackerComponent, DecayWhileMoving) == 0x0000C4, "Member 'UStillnessTrackerComponent::DecayWhileMoving' has a wrong offset!");
static_assert(offsetof(UStillnessTrackerComponent, StillnessThreshhold) == 0x0000C8, "Member 'UStillnessTrackerComponent::StillnessThreshhold' has a wrong offset!");
static_assert(offsetof(UStillnessTrackerComponent, StillnessTimerLimit) == 0x0000CC, "Member 'UStillnessTrackerComponent::StillnessTimerLimit' has a wrong offset!");
static_assert(offsetof(UStillnessTrackerComponent, DecaySpeedMultiplier) == 0x0000D0, "Member 'UStillnessTrackerComponent::DecaySpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UStillnessTrackerComponent, _trackedPlayer) == 0x0000DC, "Member 'UStillnessTrackerComponent::_trackedPlayer' has a wrong offset!");

// Class DeadByDaylight.CamperStillnessTrackerComponent
// 0x0060 (0x0150 - 0x00F0)
class UCamperStillnessTrackerComponent final : public UStillnessTrackerComponent
{
public:
	float                                         ChickenShitModifier;                               // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoudNoiseTime;                                     // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 ExposerSpawnTimes;                                 // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<float>                                 ExposerDespawnTimes;                               // 0x0118(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACamperExposerInstance>     _exposerInstanceToSpawn;                           // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACamperExposerInstance*>         _exposerInstances;                                 // 0x0130(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UExposerInteriorZoneComponent*          _interiorZone;                                     // 0x0140(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnterInteriorZone(class UExposerInteriorZoneComponent* zone);
	void ExitInteriorZone(class UExposerInteriorZoneComponent* zone);
	void OnLevelReadyToPlay();
	void OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamperStillnessTrackerComponent">();
	}
	static class UCamperStillnessTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamperStillnessTrackerComponent>();
	}
};
static_assert(alignof(UCamperStillnessTrackerComponent) == 0x000008, "Wrong alignment on UCamperStillnessTrackerComponent");
static_assert(sizeof(UCamperStillnessTrackerComponent) == 0x000150, "Wrong size on UCamperStillnessTrackerComponent");
static_assert(offsetof(UCamperStillnessTrackerComponent, ChickenShitModifier) == 0x0000F0, "Member 'UCamperStillnessTrackerComponent::ChickenShitModifier' has a wrong offset!");
static_assert(offsetof(UCamperStillnessTrackerComponent, LoudNoiseTime) == 0x0000F4, "Member 'UCamperStillnessTrackerComponent::LoudNoiseTime' has a wrong offset!");
static_assert(offsetof(UCamperStillnessTrackerComponent, ExposerSpawnTimes) == 0x000108, "Member 'UCamperStillnessTrackerComponent::ExposerSpawnTimes' has a wrong offset!");
static_assert(offsetof(UCamperStillnessTrackerComponent, ExposerDespawnTimes) == 0x000118, "Member 'UCamperStillnessTrackerComponent::ExposerDespawnTimes' has a wrong offset!");
static_assert(offsetof(UCamperStillnessTrackerComponent, _exposerInstanceToSpawn) == 0x000128, "Member 'UCamperStillnessTrackerComponent::_exposerInstanceToSpawn' has a wrong offset!");
static_assert(offsetof(UCamperStillnessTrackerComponent, _exposerInstances) == 0x000130, "Member 'UCamperStillnessTrackerComponent::_exposerInstances' has a wrong offset!");
static_assert(offsetof(UCamperStillnessTrackerComponent, _interiorZone) == 0x000140, "Member 'UCamperStillnessTrackerComponent::_interiorZone' has a wrong offset!");

// Class DeadByDaylight.PlayerInGameAssetPreloadState
// 0x0018 (0x00D0 - 0x00B8)
class UPlayerInGameAssetPreloadState final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_SetPreloadCompleted(const class FString& preloadInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInGameAssetPreloadState">();
	}
	static class UPlayerInGameAssetPreloadState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInGameAssetPreloadState>();
	}
};
static_assert(alignof(UPlayerInGameAssetPreloadState) == 0x000008, "Wrong alignment on UPlayerInGameAssetPreloadState");
static_assert(sizeof(UPlayerInGameAssetPreloadState) == 0x0000D0, "Wrong size on UPlayerInGameAssetPreloadState");

// Class DeadByDaylight.CarriedMovementComponent
// 0x00A8 (0x0160 - 0x00B8)
class UCarriedMovementComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xA8];                                      // 0x00B8(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CarriedMovementComponent">();
	}
	static class UCarriedMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCarriedMovementComponent>();
	}
};
static_assert(alignof(UCarriedMovementComponent) == 0x000008, "Wrong alignment on UCarriedMovementComponent");
static_assert(sizeof(UCarriedMovementComponent) == 0x000160, "Wrong size on UCarriedMovementComponent");

// Class DeadByDaylight.CartersSparkComponent
// 0x00F0 (0x01A8 - 0x00B8)
class UCartersSparkComponent final : public UActorComponent
{
public:
	bool                                          _staticBlastEnabled;                               // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9[0x8F];                                      // 0x00B9(0x008F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _totallyInsanePlayers;                             // 0x0148(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _owningPlayer;                                     // 0x0158(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x20];                                     // 0x0160(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _maxMadnessTier;                                   // 0x0180(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_AddTotallyInsaneSurvivor(class ADBDPlayer* insaneSurvivor);
	void Authority_RegisterToGameEvents();
	void Multicast_OnShockTherapyCooldownCheatEntered();
	void OnRequestAndBeginInteraction(class UInteractionDefinition* interaction);
	void TriggerShockTherapyCooldown();
	void TriggerStaticBlastCooldown();

	float GetStaticBlastCooldownPercentElapsed() const;
	bool IsShockTherapyOnCooldown() const;
	bool IsStaticBlastOnCooldown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CartersSparkComponent">();
	}
	static class UCartersSparkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCartersSparkComponent>();
	}
};
static_assert(alignof(UCartersSparkComponent) == 0x000008, "Wrong alignment on UCartersSparkComponent");
static_assert(sizeof(UCartersSparkComponent) == 0x0001A8, "Wrong size on UCartersSparkComponent");
static_assert(offsetof(UCartersSparkComponent, _staticBlastEnabled) == 0x0000B8, "Member 'UCartersSparkComponent::_staticBlastEnabled' has a wrong offset!");
static_assert(offsetof(UCartersSparkComponent, _totallyInsanePlayers) == 0x000148, "Member 'UCartersSparkComponent::_totallyInsanePlayers' has a wrong offset!");
static_assert(offsetof(UCartersSparkComponent, _owningPlayer) == 0x000158, "Member 'UCartersSparkComponent::_owningPlayer' has a wrong offset!");
static_assert(offsetof(UCartersSparkComponent, _maxMadnessTier) == 0x000180, "Member 'UCartersSparkComponent::_maxMadnessTier' has a wrong offset!");

// Class DeadByDaylight.DBDCustomizationTool
// 0x0E60 (0x1090 - 0x0230)
class ADBDCustomizationTool final : public AActor
{
public:
	TSoftClassPtr<class UClass>                   OverallLightingClass;                              // 0x0230(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDCustomizationToolData              CustomizationData;                                 // 0x0260(0x0E18)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         _spawnedActors;                                    // 0x1078(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1088[0x8];                                     // 0x1088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCustomizationTool">();
	}
	static class ADBDCustomizationTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDCustomizationTool>();
	}
};
static_assert(alignof(ADBDCustomizationTool) == 0x000008, "Wrong alignment on ADBDCustomizationTool");
static_assert(sizeof(ADBDCustomizationTool) == 0x001090, "Wrong size on ADBDCustomizationTool");
static_assert(offsetof(ADBDCustomizationTool, OverallLightingClass) == 0x000230, "Member 'ADBDCustomizationTool::OverallLightingClass' has a wrong offset!");
static_assert(offsetof(ADBDCustomizationTool, CustomizationData) == 0x000260, "Member 'ADBDCustomizationTool::CustomizationData' has a wrong offset!");
static_assert(offsetof(ADBDCustomizationTool, _spawnedActors) == 0x001078, "Member 'ADBDCustomizationTool::_spawnedActors' has a wrong offset!");

// Class DeadByDaylight.UMGLoadoutItemButton
// 0x0340 (0x0678 - 0x0338)
class UUMGLoadoutItemButton : public UMobileBaseUserWidget
{
public:
	TMulticastInlineDelegate<void(class FName itemID)> OnLoadoutItemButtonClicked;                   // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName itemID)> OnDisabledItemButtonClicked;                  // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FInventorySlotData& itemSlotData, const struct FVector2D& position)> OnLoadoutItemButtonLongPress; // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          HideStackCount;                                    // 0x0368(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_369[0x7];                                      // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             TextStackCount;                                    // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           EmptyCanvas;                                       // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                EmptyButton;                                       // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                LockedButton;                                      // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ActionCanvas;                                      // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageRarityBG;                                     // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageGradient;                                     // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImagePaint;                                        // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageEventBorder;                                  // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImagePaintTop;                                     // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImagePaintBottom;                                  // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              EmptyCanvasVisibility;                             // 0x03C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              ActionCanvasVisibility;                            // 0x03C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              PrivateCanvasVisibility;                           // 0x03CA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              LockIconVisibility;                                // 0x03CB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              EmptyIconVisibility;                               // 0x03CC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              SpecialEventVisiblity;                             // 0x03CD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              LoadoutSelectedVisibility;                         // 0x03CE(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              LoadoutLockVisibility;                             // 0x03CF(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageIcon;                                         // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageShadow;                                       // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ActionButton;                                      // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            EmptyBGAsset;                                      // 0x03E8(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            DisableBGAsset;                                    // 0x0478(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FInventorySlotData                     LoadoutItemData;                                   // 0x0508(0x0128)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          _triggerClickEventForLoadoutWidget;                // 0x0630(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_631[0x7];                                      // 0x0631(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UVerticalBox*                           CanvasUnlock;                                      // 0x0638(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextUnlockLevel;                                   // 0x0640(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_648[0x30];                                     // 0x0648(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastClickedEvent(class FName itemID);
	void BroadcastLongPressEvent(class FName itemID);
	class FName GetLoadoutItemID();
	void InitializationForCharacterInfoWidget();
	void InitializationForLoadoutWidget();
	void OnLockedButtonClicked();
	void SetIconImageByPath(const class FString& iconPath);
	void SetIsSelected(bool isSelected);
	void ShowClickableOutline(bool clickable);
	void UpdateImageColor(EItemRarity rarity, EStatusEffectType effectType);
	void UpdateStackCount(int32 stackCount);
	void UpdateUnlockable(const class FString& nameToDisplay, int32 unlockableLevel);
	void UpdateWidgetByData(const struct FInventorySlotData& slotData);
	void UpdateWidgetByDataBP(const struct FInventorySlotData& slotData);
	void UpdateWidgetByState(EInventoryButtonState state);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLoadoutItemButton">();
	}
	static class UUMGLoadoutItemButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLoadoutItemButton>();
	}
};
static_assert(alignof(UUMGLoadoutItemButton) == 0x000008, "Wrong alignment on UUMGLoadoutItemButton");
static_assert(sizeof(UUMGLoadoutItemButton) == 0x000678, "Wrong size on UUMGLoadoutItemButton");
static_assert(offsetof(UUMGLoadoutItemButton, OnLoadoutItemButtonClicked) == 0x000338, "Member 'UUMGLoadoutItemButton::OnLoadoutItemButtonClicked' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, OnDisabledItemButtonClicked) == 0x000348, "Member 'UUMGLoadoutItemButton::OnDisabledItemButtonClicked' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, OnLoadoutItemButtonLongPress) == 0x000358, "Member 'UUMGLoadoutItemButton::OnLoadoutItemButtonLongPress' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, HideStackCount) == 0x000368, "Member 'UUMGLoadoutItemButton::HideStackCount' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, TextStackCount) == 0x000370, "Member 'UUMGLoadoutItemButton::TextStackCount' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, EmptyCanvas) == 0x000378, "Member 'UUMGLoadoutItemButton::EmptyCanvas' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, EmptyButton) == 0x000380, "Member 'UUMGLoadoutItemButton::EmptyButton' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, LockedButton) == 0x000388, "Member 'UUMGLoadoutItemButton::LockedButton' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, ActionCanvas) == 0x000390, "Member 'UUMGLoadoutItemButton::ActionCanvas' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, ImageRarityBG) == 0x000398, "Member 'UUMGLoadoutItemButton::ImageRarityBG' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, ImageGradient) == 0x0003A0, "Member 'UUMGLoadoutItemButton::ImageGradient' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, ImagePaint) == 0x0003A8, "Member 'UUMGLoadoutItemButton::ImagePaint' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, ImageEventBorder) == 0x0003B0, "Member 'UUMGLoadoutItemButton::ImageEventBorder' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, ImagePaintTop) == 0x0003B8, "Member 'UUMGLoadoutItemButton::ImagePaintTop' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, ImagePaintBottom) == 0x0003C0, "Member 'UUMGLoadoutItemButton::ImagePaintBottom' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, EmptyCanvasVisibility) == 0x0003C8, "Member 'UUMGLoadoutItemButton::EmptyCanvasVisibility' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, ActionCanvasVisibility) == 0x0003C9, "Member 'UUMGLoadoutItemButton::ActionCanvasVisibility' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, PrivateCanvasVisibility) == 0x0003CA, "Member 'UUMGLoadoutItemButton::PrivateCanvasVisibility' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, LockIconVisibility) == 0x0003CB, "Member 'UUMGLoadoutItemButton::LockIconVisibility' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, EmptyIconVisibility) == 0x0003CC, "Member 'UUMGLoadoutItemButton::EmptyIconVisibility' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, SpecialEventVisiblity) == 0x0003CD, "Member 'UUMGLoadoutItemButton::SpecialEventVisiblity' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, LoadoutSelectedVisibility) == 0x0003CE, "Member 'UUMGLoadoutItemButton::LoadoutSelectedVisibility' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, LoadoutLockVisibility) == 0x0003CF, "Member 'UUMGLoadoutItemButton::LoadoutLockVisibility' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, ImageIcon) == 0x0003D0, "Member 'UUMGLoadoutItemButton::ImageIcon' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, ImageShadow) == 0x0003D8, "Member 'UUMGLoadoutItemButton::ImageShadow' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, ActionButton) == 0x0003E0, "Member 'UUMGLoadoutItemButton::ActionButton' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, EmptyBGAsset) == 0x0003E8, "Member 'UUMGLoadoutItemButton::EmptyBGAsset' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, DisableBGAsset) == 0x000478, "Member 'UUMGLoadoutItemButton::DisableBGAsset' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, LoadoutItemData) == 0x000508, "Member 'UUMGLoadoutItemButton::LoadoutItemData' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, _triggerClickEventForLoadoutWidget) == 0x000630, "Member 'UUMGLoadoutItemButton::_triggerClickEventForLoadoutWidget' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, CanvasUnlock) == 0x000638, "Member 'UUMGLoadoutItemButton::CanvasUnlock' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutItemButton, TextUnlockLevel) == 0x000640, "Member 'UUMGLoadoutItemButton::TextUnlockLevel' has a wrong offset!");

// Class DeadByDaylight.UMGInventoryItemButton
// 0x0000 (0x0678 - 0x0678)
class UUMGInventoryItemButton : public UUMGLoadoutItemButton
{
public:
	void UpdateItemButton(class ACollectable* item);
	void UpdateItemButtonProgressBar(class ACollectable* item, class UProgressBar* itemProgressBar);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGInventoryItemButton">();
	}
	static class UUMGInventoryItemButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGInventoryItemButton>();
	}
};
static_assert(alignof(UUMGInventoryItemButton) == 0x000008, "Wrong alignment on UUMGInventoryItemButton");
static_assert(sizeof(UUMGInventoryItemButton) == 0x000678, "Wrong size on UUMGInventoryItemButton");

// Class DeadByDaylight.CDNPatchManager
// 0x0228 (0x0258 - 0x0030)
class UCDNPatchManager final : public UObject
{
public:
	class FString                                 InstallDirectory;                                  // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PakOrder;                                          // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PakMountPoint;                                     // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x48];                                      // 0x0058(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UGameInstance>           _gameInstance;                                     // 0x00A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0xF0];                                      // 0x00A8(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtlantaPendingContent*                 _currentContentToInstall;                          // 0x0198(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FString>                         _remainingManifestsToInstall;                      // 0x01A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class FString, class UAtlantaPendingContent*> _contentToInstall;                            // 0x01B0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0x48];                                     // 0x0200(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtlantaPendingContent*                 _MobilePendingContent;                             // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInstallFailed(const class FText& errorText, int32 errorCode);
	void OnInstallSucceeded();
	void OnRequestFailed(const class FText& errorText, int32 errorCode);
	void OnRequestSucceeded(class UAtlantaPendingContent* pendingContent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CDNPatchManager">();
	}
	static class UCDNPatchManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCDNPatchManager>();
	}
};
static_assert(alignof(UCDNPatchManager) == 0x000008, "Wrong alignment on UCDNPatchManager");
static_assert(sizeof(UCDNPatchManager) == 0x000258, "Wrong size on UCDNPatchManager");
static_assert(offsetof(UCDNPatchManager, InstallDirectory) == 0x000030, "Member 'UCDNPatchManager::InstallDirectory' has a wrong offset!");
static_assert(offsetof(UCDNPatchManager, PakOrder) == 0x000040, "Member 'UCDNPatchManager::PakOrder' has a wrong offset!");
static_assert(offsetof(UCDNPatchManager, PakMountPoint) == 0x000048, "Member 'UCDNPatchManager::PakMountPoint' has a wrong offset!");
static_assert(offsetof(UCDNPatchManager, _gameInstance) == 0x0000A0, "Member 'UCDNPatchManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(UCDNPatchManager, _currentContentToInstall) == 0x000198, "Member 'UCDNPatchManager::_currentContentToInstall' has a wrong offset!");
static_assert(offsetof(UCDNPatchManager, _remainingManifestsToInstall) == 0x0001A0, "Member 'UCDNPatchManager::_remainingManifestsToInstall' has a wrong offset!");
static_assert(offsetof(UCDNPatchManager, _contentToInstall) == 0x0001B0, "Member 'UCDNPatchManager::_contentToInstall' has a wrong offset!");
static_assert(offsetof(UCDNPatchManager, _MobilePendingContent) == 0x000248, "Member 'UCDNPatchManager::_MobilePendingContent' has a wrong offset!");

// Class DeadByDaylight.CharacterChaseVisualComponent
// 0x0078 (0x0130 - 0x00B8)
class UCharacterChaseVisualComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnChaseStartEvent;                                 // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnChaseEndEvent;                                   // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMaterialHelperUnaffectedStaticMeshComponent* _vignetteMeshComp;                           // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _relativeLocation;                                 // 0x00E0(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _relativeScale;                                    // 0x00EC(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               _relativeRotation;                                 // 0x00F8(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         _fovModifyFactor;                                  // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x28];                                     // 0x0108(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAllChaseEnd();
	void OnObservedCharacterChange(class ADBDPlayer* player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterChaseVisualComponent">();
	}
	static class UCharacterChaseVisualComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterChaseVisualComponent>();
	}
};
static_assert(alignof(UCharacterChaseVisualComponent) == 0x000008, "Wrong alignment on UCharacterChaseVisualComponent");
static_assert(sizeof(UCharacterChaseVisualComponent) == 0x000130, "Wrong size on UCharacterChaseVisualComponent");
static_assert(offsetof(UCharacterChaseVisualComponent, OnChaseStartEvent) == 0x0000B8, "Member 'UCharacterChaseVisualComponent::OnChaseStartEvent' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, OnChaseEndEvent) == 0x0000C8, "Member 'UCharacterChaseVisualComponent::OnChaseEndEvent' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, _vignetteMeshComp) == 0x0000D8, "Member 'UCharacterChaseVisualComponent::_vignetteMeshComp' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, _relativeLocation) == 0x0000E0, "Member 'UCharacterChaseVisualComponent::_relativeLocation' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, _relativeScale) == 0x0000EC, "Member 'UCharacterChaseVisualComponent::_relativeScale' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, _relativeRotation) == 0x0000F8, "Member 'UCharacterChaseVisualComponent::_relativeRotation' has a wrong offset!");
static_assert(offsetof(UCharacterChaseVisualComponent, _fovModifyFactor) == 0x000104, "Member 'UCharacterChaseVisualComponent::_fovModifyFactor' has a wrong offset!");

// Class DeadByDaylight.DBDClipRegionComponent
// 0x0010 (0x0230 - 0x0220)
class UDBDClipRegionComponent final : public UDBDLocatorComponent
{
public:
	TArray<struct FAffectedMaterialAndVariant>    AffectedMaterialsAndVariants;                      // 0x0218(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ApplyArrayOfClipsToDynamicMaterial(const TArray<class UDBDClipRegionComponent*>& InRegions, class UMaterialInstanceDynamic* dynamicInstanceToClip);

	void ApplyClip(class UMaterialInstanceDynamic* InMaterial2clip, int32 InRegionID);
	void ApplyClipToDynamicMaterial(class UMaterialInstanceDynamic* dynamicInstanceToClip, int32 InRegionID);
	float ClipDistance(class UMeshComponent* InMeshComponent);
	void NotifyShouldClipComponent(class UMeshComponent* InMeshComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDClipRegionComponent">();
	}
	static class UDBDClipRegionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDClipRegionComponent>();
	}
};
static_assert(alignof(UDBDClipRegionComponent) == 0x000010, "Wrong alignment on UDBDClipRegionComponent");
static_assert(sizeof(UDBDClipRegionComponent) == 0x000230, "Wrong size on UDBDClipRegionComponent");
static_assert(offsetof(UDBDClipRegionComponent, AffectedMaterialsAndVariants) == 0x000218, "Member 'UDBDClipRegionComponent::AffectedMaterialsAndVariants' has a wrong offset!");

// Class DeadByDaylight.CharacterCollection
// 0x0228 (0x02E0 - 0x00B8)
class UCharacterCollection final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x90];                                      // 0x00B8(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class ASlasherPlayer*                         _killer;                                           // 0x0148(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class ACamperPlayer*>                    _survivors;                                        // 0x0150(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class ADBDPlayer*>                       _mainDBDPlayers;                                   // 0x01A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class ADBDPlayer*>                       _otherCharacters;                                  // 0x01F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class ACharacter*>                       _nonPlayableCharacters;                            // 0x0240(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class ACharacter*>                       _allCharacters;                                    // 0x0290(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	const TArray<class ADBDPlayer*> GetAllDBDPlayers() const;
	class ASlasherPlayer* GetKiller() const;
	const TSet<class ADBDPlayer*> GetMainDBDPlayers() const;
	const TSet<class ACamperPlayer*> GetSurvivors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCollection">();
	}
	static class UCharacterCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCollection>();
	}
};
static_assert(alignof(UCharacterCollection) == 0x000008, "Wrong alignment on UCharacterCollection");
static_assert(sizeof(UCharacterCollection) == 0x0002E0, "Wrong size on UCharacterCollection");
static_assert(offsetof(UCharacterCollection, _killer) == 0x000148, "Member 'UCharacterCollection::_killer' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _survivors) == 0x000150, "Member 'UCharacterCollection::_survivors' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _mainDBDPlayers) == 0x0001A0, "Member 'UCharacterCollection::_mainDBDPlayers' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _otherCharacters) == 0x0001F0, "Member 'UCharacterCollection::_otherCharacters' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _nonPlayableCharacters) == 0x000240, "Member 'UCharacterCollection::_nonPlayableCharacters' has a wrong offset!");
static_assert(offsetof(UCharacterCollection, _allCharacters) == 0x000290, "Member 'UCharacterCollection::_allCharacters' has a wrong offset!");

// Class DeadByDaylight.CharacterCollectionUtilities
// 0x0000 (0x0030 - 0x0030)
class UCharacterCollectionUtilities final : public UBlueprintFunctionLibrary
{
public:
	static const TSet<class ACharacter*> GetAllCharacters(const class UObject* worldContextObject);
	static TArray<class ADBDPlayer*> GetAllDBDPlayers(const class UObject* worldContextObject);
	static TArray<class ADBDPlayer*> GetCharactersByPlayerTeam(EPlayerTeam playerTeam, const class UObject* worldContextObject);
	static TArray<class ADBDPlayer*> GetInGamePlayers(const class UObject* worldContextObject);
	static TArray<class ACamperPlayer*> GetInGameSurvivors(const class UObject* worldContextObject);
	static TArray<class ADBDPlayer*> GetInGameSurvivorsAsPlayers(const class UObject* worldContextObject);
	static const TSet<class ACamperPlayer*> GetInGameSurvivorsByRef(const class UObject* worldContextObject);
	static class ASlasherPlayer* GetKiller(const class UObject* worldContextObject);
	static const int32 GetNumberOfInjuredHookedOrDyingSurvivors(const class UObject* worldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterCollectionUtilities">();
	}
	static class UCharacterCollectionUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterCollectionUtilities>();
	}
};
static_assert(alignof(UCharacterCollectionUtilities) == 0x000008, "Wrong alignment on UCharacterCollectionUtilities");
static_assert(sizeof(UCharacterCollectionUtilities) == 0x000030, "Wrong size on UCharacterCollectionUtilities");

// Class DeadByDaylight.CharacterDataSubsystem
// 0x0000 (0x0038 - 0x0038)
class UCharacterDataSubsystem final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterDataSubsystem">();
	}
	static class UCharacterDataSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterDataSubsystem>();
	}
};
static_assert(alignof(UCharacterDataSubsystem) == 0x000008, "Wrong alignment on UCharacterDataSubsystem");
static_assert(sizeof(UCharacterDataSubsystem) == 0x000038, "Wrong size on UCharacterDataSubsystem");

// Class DeadByDaylight.CapsulePlayerOverlapComponent
// 0x0000 (0x04A0 - 0x04A0)
class UCapsulePlayerOverlapComponent final : public UCapsuleComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CapsulePlayerOverlapComponent">();
	}
	static class UCapsulePlayerOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCapsulePlayerOverlapComponent>();
	}
};
static_assert(alignof(UCapsulePlayerOverlapComponent) == 0x000010, "Wrong alignment on UCapsulePlayerOverlapComponent");
static_assert(sizeof(UCapsulePlayerOverlapComponent) == 0x0004A0, "Wrong size on UCapsulePlayerOverlapComponent");

// Class DeadByDaylight.WiggleWidget
// 0x0020 (0x0358 - 0x0338)
class UWiggleWidget final : public UMobileBaseUserWidget
{
public:
	float                                         TimeBetweenAnimationStart;                         // 0x0338(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMobileBaseUserWidget*                  WiggleButtonLeft;                                  // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMobileBaseUserWidget*                  WiggleButtonRight;                                 // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BecomeAvailable();
	void BecomeUnavailable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WiggleWidget">();
	}
	static class UWiggleWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWiggleWidget>();
	}
};
static_assert(alignof(UWiggleWidget) == 0x000008, "Wrong alignment on UWiggleWidget");
static_assert(sizeof(UWiggleWidget) == 0x000358, "Wrong size on UWiggleWidget");
static_assert(offsetof(UWiggleWidget, TimeBetweenAnimationStart) == 0x000338, "Member 'UWiggleWidget::TimeBetweenAnimationStart' has a wrong offset!");
static_assert(offsetof(UWiggleWidget, WiggleButtonLeft) == 0x000340, "Member 'UWiggleWidget::WiggleButtonLeft' has a wrong offset!");
static_assert(offsetof(UWiggleWidget, WiggleButtonRight) == 0x000348, "Member 'UWiggleWidget::WiggleButtonRight' has a wrong offset!");

// Class DeadByDaylight.DBDDesignTunables
// 0x0208 (0x0238 - 0x0030)
class UDBDDesignTunables : public UObject
{
public:
	int8                                          EntityDispleasedKills;                             // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          BrutalKillerKills;                                 // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          RuthlessKillerKills;                               // 0x0032(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          MercilessKillerKills;                              // 0x0033(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WinStreakThresholdLarge;                           // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WinStreakThresholdSmall;                           // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFearTokens;                                     // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuantityOfItemsToBuyBeforeFreeBloodwebRefresh;     // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPerkLevelDefinition>           PerkLevelDefinitions;                              // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TSet<struct FGameplayTag>                     MetaModifiers;                                     // 0x0058(0x0050)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	TSet<struct FGameplayTag>                     RangedSurvivorAuraPerceptionModifiers;             // 0x00A8(0x0050)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	TSet<struct FGameplayTag>                     SurvivorRevelatoryAuraPerceptionModifiers;         // 0x00F8(0x0050)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	TSet<struct FGameplayTag>                     DisruptableAuraReadingFlags;                       // 0x0148(0x0050)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   TextDesignTunableClass;                            // 0x0198(0x0030)(Edit, BlueprintVisible, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDBDTextDesignTunables*                 TextTunables;                                      // 0x01C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameEventForwarderInfo>        GameEventForwarderInfos;                           // 0x01D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CoreUMGDesignTunableClass;                         // 0x01E0(0x0030)(Edit, BlueprintVisible, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDBDCoreUMGDesignTunables*              CoreUMGDesignTunables;                             // 0x0210(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _overrideDefaultLobby;                             // 0x0218(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_219[0x3];                                      // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _lobbyOverrideName;                                // 0x021C(0x000C)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _conspicuousActionEvents;                          // 0x0228(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	float GetTunableValue(class FName ID, bool warnIfRowMissing) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDesignTunables">();
	}
	static class UDBDDesignTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDesignTunables>();
	}
};
static_assert(alignof(UDBDDesignTunables) == 0x000008, "Wrong alignment on UDBDDesignTunables");
static_assert(sizeof(UDBDDesignTunables) == 0x000238, "Wrong size on UDBDDesignTunables");
static_assert(offsetof(UDBDDesignTunables, EntityDispleasedKills) == 0x000030, "Member 'UDBDDesignTunables::EntityDispleasedKills' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, BrutalKillerKills) == 0x000031, "Member 'UDBDDesignTunables::BrutalKillerKills' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, RuthlessKillerKills) == 0x000032, "Member 'UDBDDesignTunables::RuthlessKillerKills' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, MercilessKillerKills) == 0x000033, "Member 'UDBDDesignTunables::MercilessKillerKills' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, WinStreakThresholdLarge) == 0x000034, "Member 'UDBDDesignTunables::WinStreakThresholdLarge' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, WinStreakThresholdSmall) == 0x000038, "Member 'UDBDDesignTunables::WinStreakThresholdSmall' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, MaxFearTokens) == 0x00003C, "Member 'UDBDDesignTunables::MaxFearTokens' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, QuantityOfItemsToBuyBeforeFreeBloodwebRefresh) == 0x000040, "Member 'UDBDDesignTunables::QuantityOfItemsToBuyBeforeFreeBloodwebRefresh' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, PerkLevelDefinitions) == 0x000048, "Member 'UDBDDesignTunables::PerkLevelDefinitions' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, MetaModifiers) == 0x000058, "Member 'UDBDDesignTunables::MetaModifiers' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, RangedSurvivorAuraPerceptionModifiers) == 0x0000A8, "Member 'UDBDDesignTunables::RangedSurvivorAuraPerceptionModifiers' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, SurvivorRevelatoryAuraPerceptionModifiers) == 0x0000F8, "Member 'UDBDDesignTunables::SurvivorRevelatoryAuraPerceptionModifiers' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, DisruptableAuraReadingFlags) == 0x000148, "Member 'UDBDDesignTunables::DisruptableAuraReadingFlags' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, TextDesignTunableClass) == 0x000198, "Member 'UDBDDesignTunables::TextDesignTunableClass' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, TextTunables) == 0x0001C8, "Member 'UDBDDesignTunables::TextTunables' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, GameEventForwarderInfos) == 0x0001D0, "Member 'UDBDDesignTunables::GameEventForwarderInfos' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, CoreUMGDesignTunableClass) == 0x0001E0, "Member 'UDBDDesignTunables::CoreUMGDesignTunableClass' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, CoreUMGDesignTunables) == 0x000210, "Member 'UDBDDesignTunables::CoreUMGDesignTunables' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, _overrideDefaultLobby) == 0x000218, "Member 'UDBDDesignTunables::_overrideDefaultLobby' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, _lobbyOverrideName) == 0x00021C, "Member 'UDBDDesignTunables::_lobbyOverrideName' has a wrong offset!");
static_assert(offsetof(UDBDDesignTunables, _conspicuousActionEvents) == 0x000228, "Member 'UDBDDesignTunables::_conspicuousActionEvents' has a wrong offset!");

// Class DeadByDaylight.CharacterHelper
// 0x0000 (0x0030 - 0x0030)
class UCharacterHelper final : public UObject
{
public:
	static TArray<class FString> GetAllEnabledCharms();
	static void GetAllOutfitComponentsOfCharacter(TArray<struct FCustomizationItemData>* returnHeads, TArray<struct FCustomizationItemData>* returnTorsos, TArray<struct FCustomizationItemData>* returnLegsWeapons, const class FString& characterId);
	static TArray<struct FCharacterDescription> GetCharactersByRole(const EPlayerRole role);
	static void GetOutfitComposition(struct FCustomizationItemData* returnHead, struct FCustomizationItemData* returnTorso, struct FCustomizationItemData* returnLegsWeapon, const class FString& outfitId);
	static TArray<struct FOutfitData> GetOutfitsByCharacterID(const class FString& characterId);
	static struct FCharmIdSlot SetCharmSlot(class ADBDPlayerState* playerState, const class FName& charmId, int32 slotIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterHelper">();
	}
	static class UCharacterHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterHelper>();
	}
};
static_assert(alignof(UCharacterHelper) == 0x000008, "Wrong alignment on UCharacterHelper");
static_assert(sizeof(UCharacterHelper) == 0x000030, "Wrong size on UCharacterHelper");

// Class DeadByDaylight.UMGUtilities
// 0x0000 (0x0030 - 0x0030)
class UUMGUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGUtilities">();
	}
	static class UUMGUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGUtilities>();
	}
};
static_assert(alignof(UUMGUtilities) == 0x000008, "Wrong alignment on UUMGUtilities");
static_assert(sizeof(UUMGUtilities) == 0x000030, "Wrong size on UUMGUtilities");

// Class DeadByDaylight.DBDDebugCameraController
// 0x0000 (0x06A0 - 0x06A0)
class ADBDDebugCameraController final : public ADebugCameraController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDebugCameraController">();
	}
	static class ADBDDebugCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDDebugCameraController>();
	}
};
static_assert(alignof(ADBDDebugCameraController) == 0x000008, "Wrong alignment on ADBDDebugCameraController");
static_assert(sizeof(ADBDDebugCameraController) == 0x0006A0, "Wrong size on ADBDDebugCameraController");

// Class DeadByDaylight.UMGAtlantaDailyRewardsScreen
// 0x00A0 (0x03D8 - 0x0338)
class UUMGAtlantaDailyRewardsScreen final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGAtlantaDailyRewardsGrid*            DailyRewardWidgetsGrid;                            // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ContinueButtonPanel;                               // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGPopupButton*                        ContinueButton;                                    // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RemainingTimeTextBlock;                            // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            NormalColor;                                       // 0x0368(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            WarningColor;                                      // 0x0390(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x20];                                     // 0x03B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleContinueButtonClick();
	void HandleCurrentActiveDailyRewardStateChanged(int32 dailyRewardIndex, int32 dailyRewardNewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaDailyRewardsScreen">();
	}
	static class UUMGAtlantaDailyRewardsScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaDailyRewardsScreen>();
	}
};
static_assert(alignof(UUMGAtlantaDailyRewardsScreen) == 0x000008, "Wrong alignment on UUMGAtlantaDailyRewardsScreen");
static_assert(sizeof(UUMGAtlantaDailyRewardsScreen) == 0x0003D8, "Wrong size on UUMGAtlantaDailyRewardsScreen");
static_assert(offsetof(UUMGAtlantaDailyRewardsScreen, DailyRewardWidgetsGrid) == 0x000348, "Member 'UUMGAtlantaDailyRewardsScreen::DailyRewardWidgetsGrid' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsScreen, ContinueButtonPanel) == 0x000350, "Member 'UUMGAtlantaDailyRewardsScreen::ContinueButtonPanel' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsScreen, ContinueButton) == 0x000358, "Member 'UUMGAtlantaDailyRewardsScreen::ContinueButton' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsScreen, RemainingTimeTextBlock) == 0x000360, "Member 'UUMGAtlantaDailyRewardsScreen::RemainingTimeTextBlock' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsScreen, NormalColor) == 0x000368, "Member 'UUMGAtlantaDailyRewardsScreen::NormalColor' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaDailyRewardsScreen, WarningColor) == 0x000390, "Member 'UUMGAtlantaDailyRewardsScreen::WarningColor' has a wrong offset!");

// Class DeadByDaylight.CharacterInventoryComponent
// 0x00B8 (0x0170 - 0x00B8)
class UCharacterInventoryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x58];                                      // 0x00B8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACollectable*>                   _inventory;                                        // 0x0110(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class UItemAddon*>                     _generalAddons;                                    // 0x0120(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class ACollectable*>                   _backpackInventory;                                // 0x0130(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class ACollectable*>                   _localInventory;                                   // 0x0140(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ACollectable*>                   _localBackpackInventory;                           // 0x0150(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UItemAddon*>                     _allAddons;                                        // 0x0160(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddToInventory(class ACollectable* item, EInventoryType inventoryType);
	void Authority_Drop(class ACollectable* item, const struct FVector& location, const struct FRotator& rotation, bool onDeath, bool adjustToGround, bool dropInChest);
	void Authority_UseInventoryItem();
	void ClearAndDestroyInventory();
	void Collect(class ACollectable* item, EInventoryType inventoryType);
	void EquipItem();
	const TArray<class UItemAddon*> GetAddons();
	class ACollectable* GetFirstItemFromInventory(TSubclassOf<class ACollectable> item, EInventoryType inventoryType);
	bool HasInInventory(TSubclassOf<class ACollectable> item, EInventoryType inventoryType);
	void Multicast_AddToInventory(class ACollectable* item, EInventoryType inventoryType);
	void Multicast_ClearAndDestroyInventory();
	void Multicast_RemoveFromInventory(class ACollectable* item);
	void OnRep_BackpackInventory();
	void OnRep_GeneralAddons();
	void OnRep_Inventory();
	void RemoveFromInventory(class ACollectable* item);
	class ACollectable* SpawnAndCollectItem(class FName itemID);
	void StoreItem();

	class ACollectable* GetItem() const;
	int32 GetItemCount() const;
	int32 GetItemCountByID(class FName itemID) const;
	class FName GetItemID() const;
	bool HasEquippedItem() const;
	bool HasItem() const;
	bool HasMaximumItemCount(const class ACollectable* item) const;
	bool HasStoredItem() const;
	bool IsUsingAimItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterInventoryComponent">();
	}
	static class UCharacterInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterInventoryComponent>();
	}
};
static_assert(alignof(UCharacterInventoryComponent) == 0x000008, "Wrong alignment on UCharacterInventoryComponent");
static_assert(sizeof(UCharacterInventoryComponent) == 0x000170, "Wrong size on UCharacterInventoryComponent");
static_assert(offsetof(UCharacterInventoryComponent, _inventory) == 0x000110, "Member 'UCharacterInventoryComponent::_inventory' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _generalAddons) == 0x000120, "Member 'UCharacterInventoryComponent::_generalAddons' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _backpackInventory) == 0x000130, "Member 'UCharacterInventoryComponent::_backpackInventory' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _localInventory) == 0x000140, "Member 'UCharacterInventoryComponent::_localInventory' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _localBackpackInventory) == 0x000150, "Member 'UCharacterInventoryComponent::_localBackpackInventory' has a wrong offset!");
static_assert(offsetof(UCharacterInventoryComponent, _allAddons) == 0x000160, "Member 'UCharacterInventoryComponent::_allAddons' has a wrong offset!");

// Class DeadByDaylight.DBDDangerPredictionComponent
// 0x0010 (0x00C8 - 0x00B8)
class UDBDDangerPredictionComponent : public UActorComponent
{
public:
	float                                         RelevantHorizontalDistance;                        // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RelevantVerticalDistance;                          // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerRole                                   RelevantRole;                                      // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDangerPredictionComponent">();
	}
	static class UDBDDangerPredictionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDangerPredictionComponent>();
	}
};
static_assert(alignof(UDBDDangerPredictionComponent) == 0x000008, "Wrong alignment on UDBDDangerPredictionComponent");
static_assert(sizeof(UDBDDangerPredictionComponent) == 0x0000C8, "Wrong size on UDBDDangerPredictionComponent");
static_assert(offsetof(UDBDDangerPredictionComponent, RelevantHorizontalDistance) == 0x0000B8, "Member 'UDBDDangerPredictionComponent::RelevantHorizontalDistance' has a wrong offset!");
static_assert(offsetof(UDBDDangerPredictionComponent, RelevantVerticalDistance) == 0x0000BC, "Member 'UDBDDangerPredictionComponent::RelevantVerticalDistance' has a wrong offset!");
static_assert(offsetof(UDBDDangerPredictionComponent, RelevantRole) == 0x0000C0, "Member 'UDBDDangerPredictionComponent::RelevantRole' has a wrong offset!");

// Class DeadByDaylight.CharacterItemsAssetLibrary
// 0x0018 (0x0138 - 0x0120)
class UCharacterItemsAssetLibrary final : public UItemsAssetLibrary
{
public:
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterItemsAssetLibrary">();
	}
	static class UCharacterItemsAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterItemsAssetLibrary>();
	}
};
static_assert(alignof(UCharacterItemsAssetLibrary) == 0x000008, "Wrong alignment on UCharacterItemsAssetLibrary");
static_assert(sizeof(UCharacterItemsAssetLibrary) == 0x000138, "Wrong size on UCharacterItemsAssetLibrary");

// Class DeadByDaylight.CharacterPositionRecorderConfigurator
// 0x0010 (0x00D0 - 0x00C0)
class UCharacterPositionRecorderConfigurator final : public UBaseHitValidationConfigurator
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPositionRecorderConfigurator">();
	}
	static class UCharacterPositionRecorderConfigurator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPositionRecorderConfigurator>();
	}
};
static_assert(alignof(UCharacterPositionRecorderConfigurator) == 0x000008, "Wrong alignment on UCharacterPositionRecorderConfigurator");
static_assert(sizeof(UCharacterPositionRecorderConfigurator) == 0x0000D0, "Wrong size on UCharacterPositionRecorderConfigurator");

// Class DeadByDaylight.GlassCollectionSubsystem
// 0x0010 (0x0048 - 0x0038)
class UGlassCollectionSubsystem final : public UGameInstanceSubsystem
{
public:
	TArray<class UGlassStaticMesh*>               _glassCollection;                                  // 0x0038(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlassCollectionSubsystem">();
	}
	static class UGlassCollectionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlassCollectionSubsystem>();
	}
};
static_assert(alignof(UGlassCollectionSubsystem) == 0x000008, "Wrong alignment on UGlassCollectionSubsystem");
static_assert(sizeof(UGlassCollectionSubsystem) == 0x000048, "Wrong size on UGlassCollectionSubsystem");
static_assert(offsetof(UGlassCollectionSubsystem, _glassCollection) == 0x000038, "Member 'UGlassCollectionSubsystem::_glassCollection' has a wrong offset!");

// Class DeadByDaylight.DBDPartyFacade
// 0x0010 (0x04D8 - 0x04C8)
class UDBDPartyFacade final : public UPartyFacade
{
public:
	uint8                                         Pad_4C8[0x10];                                     // 0x04C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPartyFacade">();
	}
	static class UDBDPartyFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPartyFacade>();
	}
};
static_assert(alignof(UDBDPartyFacade) == 0x000008, "Wrong alignment on UDBDPartyFacade");
static_assert(sizeof(UDBDPartyFacade) == 0x0004D8, "Wrong size on UDBDPartyFacade");

// Class DeadByDaylight.CharacterProgressionManager
// 0x0008 (0x0038 - 0x0030)
class UCharacterProgressionManager final : public UObject
{
public:
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterProgressionManager">();
	}
	static class UCharacterProgressionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterProgressionManager>();
	}
};
static_assert(alignof(UCharacterProgressionManager) == 0x000008, "Wrong alignment on UCharacterProgressionManager");
static_assert(sizeof(UCharacterProgressionManager) == 0x000038, "Wrong size on UCharacterProgressionManager");
static_assert(offsetof(UCharacterProgressionManager, _gameInstance) == 0x000030, "Member 'UCharacterProgressionManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.CharacterStatsHandlerComponent
// 0x0010 (0x00C8 - 0x00B8)
class UCharacterStatsHandlerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializePreMatchStats();
	void OnGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void ReceiveGameEvent(EDBDScoreTypes scoreType, float amount, class AActor* instigator, class AActor* target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStatsHandlerComponent">();
	}
	static class UCharacterStatsHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStatsHandlerComponent>();
	}
};
static_assert(alignof(UCharacterStatsHandlerComponent) == 0x000008, "Wrong alignment on UCharacterStatsHandlerComponent");
static_assert(sizeof(UCharacterStatsHandlerComponent) == 0x0000C8, "Wrong size on UCharacterStatsHandlerComponent");

// Class DeadByDaylight.ScreenSpaceLocationComponent
// 0x0020 (0x0240 - 0x0220)
class UScreenSpaceLocationComponent final : public USceneComponent
{
public:
	float                                         ScreenSpaceX;                                      // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScreenSpaceY;                                      // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FrameDelay;                                        // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _currentResolution;                                // 0x0224(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     _previousTransforms;                               // 0x0230(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	struct FVector2D GetCurrentResolution() const;
	bool HasValidPosition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenSpaceLocationComponent">();
	}
	static class UScreenSpaceLocationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenSpaceLocationComponent>();
	}
};
static_assert(alignof(UScreenSpaceLocationComponent) == 0x000010, "Wrong alignment on UScreenSpaceLocationComponent");
static_assert(sizeof(UScreenSpaceLocationComponent) == 0x000240, "Wrong size on UScreenSpaceLocationComponent");
static_assert(offsetof(UScreenSpaceLocationComponent, ScreenSpaceX) == 0x000218, "Member 'UScreenSpaceLocationComponent::ScreenSpaceX' has a wrong offset!");
static_assert(offsetof(UScreenSpaceLocationComponent, ScreenSpaceY) == 0x00021C, "Member 'UScreenSpaceLocationComponent::ScreenSpaceY' has a wrong offset!");
static_assert(offsetof(UScreenSpaceLocationComponent, FrameDelay) == 0x000220, "Member 'UScreenSpaceLocationComponent::FrameDelay' has a wrong offset!");
static_assert(offsetof(UScreenSpaceLocationComponent, _currentResolution) == 0x000224, "Member 'UScreenSpaceLocationComponent::_currentResolution' has a wrong offset!");
static_assert(offsetof(UScreenSpaceLocationComponent, _previousTransforms) == 0x000230, "Member 'UScreenSpaceLocationComponent::_previousTransforms' has a wrong offset!");

// Class DeadByDaylight.DBDGame_Lobby
// 0x0080 (0x03E0 - 0x0360)
class ADBDGame_Lobby final : public ADBDBaseGameMode
{
public:
	uint8                                         Pad_360[0x18];                                     // 0x0360(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UIdentityValidation*                    _identityValidation;                               // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x60];                                     // 0x0380(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_AddBotToLobby(int32 selectedCharacter, const class FString& item, const class FString& addon1, const class FString& addon2, const class FString& offering, const class FString& perk1, const class FString& perk2, const class FString& perk3, const class FString& perk4, int32 rank);
	void DBD_AddBotToLobbyByName(const class FString& selectedCharacter, const class FString& item, const class FString& addon1, const class FString& addon2, const class FString& offering, const class FString& perk1, const class FString& perk2, const class FString& perk3, const class FString& perk4, int32 rank);
	void DBD_AddBotToLobbyNoLoadout(int32 selectedCharacter);
	void DBD_AddBotToLobbyNoLoadoutByName(const class FString& selectedCharacter);
	void DBD_FillLobby();
	void DBD_FillLobbyWithBotsByName(const class FString& selectedKiller, int32 rank);
	void DBD_RemoveBotByIndex(int32 botIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGame_Lobby">();
	}
	static class ADBDGame_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGame_Lobby>();
	}
};
static_assert(alignof(ADBDGame_Lobby) == 0x000008, "Wrong alignment on ADBDGame_Lobby");
static_assert(sizeof(ADBDGame_Lobby) == 0x0003E0, "Wrong size on ADBDGame_Lobby");
static_assert(offsetof(ADBDGame_Lobby, _identityValidation) == 0x000378, "Member 'ADBDGame_Lobby::_identityValidation' has a wrong offset!");

// Class DeadByDaylight.CharacterStatsUtilities
// 0x0000 (0x0030 - 0x0030)
class UCharacterStatsUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStatsUtilities">();
	}
	static class UCharacterStatsUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStatsUtilities>();
	}
};
static_assert(alignof(UCharacterStatsUtilities) == 0x000008, "Wrong alignment on UCharacterStatsUtilities");
static_assert(sizeof(UCharacterStatsUtilities) == 0x000030, "Wrong size on UCharacterStatsUtilities");

// Class DeadByDaylight.DBDEditorActor
// 0x0000 (0x0230 - 0x0230)
class ADBDEditorActor : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEditorActor">();
	}
	static class ADBDEditorActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDEditorActor>();
	}
};
static_assert(alignof(ADBDEditorActor) == 0x000008, "Wrong alignment on ADBDEditorActor");
static_assert(sizeof(ADBDEditorActor) == 0x000230, "Wrong size on ADBDEditorActor");

// Class DeadByDaylight.DBDPlayerAudioHandlerComponent
// 0x0080 (0x0138 - 0x00B8)
class UDBDPlayerAudioHandlerComponent : public UActorComponent
{
public:
	class FString                                 _stopMovingRTPC;                                   // 0x00B8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x70];                                      // 0x00C8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerAudioHandlerComponent">();
	}
	static class UDBDPlayerAudioHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPlayerAudioHandlerComponent>();
	}
};
static_assert(alignof(UDBDPlayerAudioHandlerComponent) == 0x000008, "Wrong alignment on UDBDPlayerAudioHandlerComponent");
static_assert(sizeof(UDBDPlayerAudioHandlerComponent) == 0x000138, "Wrong size on UDBDPlayerAudioHandlerComponent");
static_assert(offsetof(UDBDPlayerAudioHandlerComponent, _stopMovingRTPC) == 0x0000B8, "Member 'UDBDPlayerAudioHandlerComponent::_stopMovingRTPC' has a wrong offset!");

// Class DeadByDaylight.CharacterTool
// 0x0150 (0x0380 - 0x0230)
class ACharacterTool : public ADBDEditorActor
{
public:
	TArray<class ATargetPoint*>                   SpawnLocations;                                    // 0x0230(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FCharacterToolData                     _customizationData;                                // 0x0240(0x0080)(Edit, NativeAccessSpecifierPrivate)
	struct FCharacterToolSpawnParameters          _defaultSpawnParams;                               // 0x02C0(0x0003)(Edit, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C3[0x1];                                      // 0x02C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _powerSocket;                                      // 0x02C4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAttachmentRule                               _powerAttachmentRule;                              // 0x02D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _muteAudioInPIE;                                   // 0x02D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isUsingGameSkeleton;                              // 0x02D2(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D3[0x5];                                      // 0x02D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _overallLightingClass;                             // 0x02D8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FNamedButton                           _showHelp;                                         // 0x0308(0x0018)(Edit, NativeAccessSpecifierPrivate)
	TMap<class ADBDMenuPlayer*, struct FCharacterToolSpawnParameters> _characters;                   // 0x0320(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class AActor*                                 _lighting;                                         // 0x0370(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterTool">();
	}
	static class ACharacterTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterTool>();
	}
};
static_assert(alignof(ACharacterTool) == 0x000008, "Wrong alignment on ACharacterTool");
static_assert(sizeof(ACharacterTool) == 0x000380, "Wrong size on ACharacterTool");
static_assert(offsetof(ACharacterTool, SpawnLocations) == 0x000230, "Member 'ACharacterTool::SpawnLocations' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _customizationData) == 0x000240, "Member 'ACharacterTool::_customizationData' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _defaultSpawnParams) == 0x0002C0, "Member 'ACharacterTool::_defaultSpawnParams' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _powerSocket) == 0x0002C4, "Member 'ACharacterTool::_powerSocket' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _powerAttachmentRule) == 0x0002D0, "Member 'ACharacterTool::_powerAttachmentRule' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _muteAudioInPIE) == 0x0002D1, "Member 'ACharacterTool::_muteAudioInPIE' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _isUsingGameSkeleton) == 0x0002D2, "Member 'ACharacterTool::_isUsingGameSkeleton' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _overallLightingClass) == 0x0002D8, "Member 'ACharacterTool::_overallLightingClass' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _showHelp) == 0x000308, "Member 'ACharacterTool::_showHelp' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _characters) == 0x000320, "Member 'ACharacterTool::_characters' has a wrong offset!");
static_assert(offsetof(ACharacterTool, _lighting) == 0x000370, "Member 'ACharacterTool::_lighting' has a wrong offset!");

// Class DeadByDaylight.SpecialEventManager
// 0x0478 (0x04A8 - 0x0030)
class USpecialEventManager final : public UObject
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class USpecialEventsContainer*                _specialEventsContainer;                           // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x3F0];                                     // 0x00B8(0x03F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool GetCurrentMainSpecialEvent(const class UObject* worldContextObject, struct FCombinedSpecialEventData* outSpecialEventData);
	static bool GetCurrentSpecialEvent(const class UObject* worldContextObject, struct FCombinedSpecialEventData* outSpecialEventData);
	static bool GetEventMainEndDate(const class FString& eventId, struct FDateTime* outDate);
	static bool GetEventPostEndDate(const class FString& eventId, struct FDateTime* outDate);
	static bool GetEventStartDate(const class FString& eventId, struct FDateTime* outDate);
	static bool GetEventTimeSinceStartDate(const class FString& eventId, struct FTimespan* outDate);
	static bool GetEventTimeTillMainEndDate(const class FString& eventId, struct FTimespan* outDate);
	static bool GetEventTimeTillPostEndDate(const class FString& eventId, struct FTimespan* outDate);
	static struct FDateTime GetMainEndDate(const struct FCombinedSpecialEventData& specialEventData);
	static struct FDateTime GetPostEndDate(const struct FCombinedSpecialEventData& specialEventData);
	static bool GetSpecialEvent(class UObject* worldContextObject, const class FName eventId, struct FCombinedSpecialEventData* outSpecialEventData);
	static struct FDateTime GetStartDate(const struct FCombinedSpecialEventData& specialEventData);
	static ESpecialEventStatus GetStatus(const struct FCombinedSpecialEventData& specialEventData);
	static struct FTimespan GetTimeSinceStartDate(const struct FCombinedSpecialEventData& specialEventData);
	static struct FTimespan GetTimeTillMainEndDate(const struct FCombinedSpecialEventData& specialEventData);
	static struct FTimespan GetTimeTillPostEndDate(const struct FCombinedSpecialEventData& specialEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventManager">();
	}
	static class USpecialEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialEventManager>();
	}
};
static_assert(alignof(USpecialEventManager) == 0x000008, "Wrong alignment on USpecialEventManager");
static_assert(sizeof(USpecialEventManager) == 0x0004A8, "Wrong size on USpecialEventManager");
static_assert(offsetof(USpecialEventManager, _specialEventsContainer) == 0x0000B0, "Member 'USpecialEventManager::_specialEventsContainer' has a wrong offset!");

// Class DeadByDaylight.CharacterToolAnimation
// 0x0010 (0x02D0 - 0x02C0)
class UCharacterToolAnimation final : public UAnimInstance
{
public:
	TArray<struct FCharacterToolItemData>         SelectedItems;                                     // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterToolAnimation">();
	}
	static class UCharacterToolAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterToolAnimation>();
	}
};
static_assert(alignof(UCharacterToolAnimation) == 0x000010, "Wrong alignment on UCharacterToolAnimation");
static_assert(sizeof(UCharacterToolAnimation) == 0x0002D0, "Wrong size on UCharacterToolAnimation");
static_assert(offsetof(UCharacterToolAnimation, SelectedItems) == 0x0002C0, "Member 'UCharacterToolAnimation::SelectedItems' has a wrong offset!");

// Class DeadByDaylight.CharacterUtilities
// 0x0000 (0x0030 - 0x0030)
class UCharacterUtilities final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector GetActorLocationFromFeetLocation(const class ACharacter* character, const struct FVector& feetLocation);
	static struct FVector GetFeetPosition(const class ACharacter* character);
	static struct FVector GetFeetPositionAtTargetLocation(const class ACharacter* character, const struct FVector& location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterUtilities">();
	}
	static class UCharacterUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterUtilities>();
	}
};
static_assert(alignof(UCharacterUtilities) == 0x000008, "Wrong alignment on UCharacterUtilities");
static_assert(sizeof(UCharacterUtilities) == 0x000030, "Wrong size on UCharacterUtilities");

// Class DeadByDaylight.GlassStaticMesh
// 0x0050 (0x05A0 - 0x0550)
class UGlassStaticMesh final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_548[0x48];                                     // 0x0548(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                defaultGlassNormalVector;                          // 0x0590(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59C[0x4];                                      // 0x059C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlassStaticMesh">();
	}
	static class UGlassStaticMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlassStaticMesh>();
	}
};
static_assert(alignof(UGlassStaticMesh) == 0x000010, "Wrong alignment on UGlassStaticMesh");
static_assert(sizeof(UGlassStaticMesh) == 0x0005A0, "Wrong size on UGlassStaticMesh");
static_assert(offsetof(UGlassStaticMesh, defaultGlassNormalVector) == 0x000590, "Member 'UGlassStaticMesh::defaultGlassNormalVector' has a wrong offset!");

// Class DeadByDaylight.CharacterXPManager
// 0x00E0 (0x0110 - 0x0030)
class UCharacterXPManager final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0xC0];                                      // 0x0050(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterXPManager">();
	}
	static class UCharacterXPManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterXPManager>();
	}
};
static_assert(alignof(UCharacterXPManager) == 0x000008, "Wrong alignment on UCharacterXPManager");
static_assert(sizeof(UCharacterXPManager) == 0x000110, "Wrong size on UCharacterXPManager");
static_assert(offsetof(UCharacterXPManager, _gameInstance) == 0x000048, "Member 'UCharacterXPManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.HasTokenPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UHasTokenPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasTokenPerkIconStrategy">();
	}
	static class UHasTokenPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasTokenPerkIconStrategy>();
	}
};
static_assert(alignof(UHasTokenPerkIconStrategy) == 0x000008, "Wrong alignment on UHasTokenPerkIconStrategy");
static_assert(sizeof(UHasTokenPerkIconStrategy) == 0x000038, "Wrong size on UHasTokenPerkIconStrategy");

// Class DeadByDaylight.ChargeableProgressProviderComponent
// 0x0010 (0x00C8 - 0x00B8)
class UChargeableProgressProviderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeableProgressProviderComponent">();
	}
	static class UChargeableProgressProviderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeableProgressProviderComponent>();
	}
};
static_assert(alignof(UChargeableProgressProviderComponent) == 0x000008, "Wrong alignment on UChargeableProgressProviderComponent");
static_assert(sizeof(UChargeableProgressProviderComponent) == 0x0000C8, "Wrong size on UChargeableProgressProviderComponent");

// Class DeadByDaylight.SelectiveVisibilityComponent
// 0x0000 (0x0220 - 0x0220)
class USelectiveVisibilityComponent final : public USceneComponent
{
public:
	void Local_SetVisibility(bool bNewVisibility, bool bPropagateToChildren);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelectiveVisibilityComponent">();
	}
	static class USelectiveVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelectiveVisibilityComponent>();
	}
};
static_assert(alignof(USelectiveVisibilityComponent) == 0x000010, "Wrong alignment on USelectiveVisibilityComponent");
static_assert(sizeof(USelectiveVisibilityComponent) == 0x000220, "Wrong size on USelectiveVisibilityComponent");

// Class DeadByDaylight.DBDGameFlowUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDGameFlowUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void TriggerUIFlowEvent(class UObject* worldContextObject, EUIFlowEvent uiFlowEvent);
	static void TriggerWorldFlowEvent(class UObject* worldContextObject, EWorldFlowEvent worldFlowEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameFlowUtilities">();
	}
	static class UDBDGameFlowUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameFlowUtilities>();
	}
};
static_assert(alignof(UDBDGameFlowUtilities) == 0x000008, "Wrong alignment on UDBDGameFlowUtilities");
static_assert(sizeof(UDBDGameFlowUtilities) == 0x000030, "Wrong size on UDBDGameFlowUtilities");

// Class DeadByDaylight.ChargedAttackStateComponent
// 0x0008 (0x00C0 - 0x00B8)
class UChargedAttackStateComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetChargingPercent(float chargePercent);
	void SetIsCharging(bool isCharging);

	float GetChargingPercent() const;
	bool GetIsCharging() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargedAttackStateComponent">();
	}
	static class UChargedAttackStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargedAttackStateComponent>();
	}
};
static_assert(alignof(UChargedAttackStateComponent) == 0x000008, "Wrong alignment on UChargedAttackStateComponent");
static_assert(sizeof(UChargedAttackStateComponent) == 0x0000C0, "Wrong size on UChargedAttackStateComponent");

// Class DeadByDaylight.ChargerComponent
// 0x0080 (0x0138 - 0x00B8)
class UChargerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChargerComponentID;                                // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool Empty)>    OnChargeStateChange;                               // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float ChargePercent)> OnChargePercentChange;                       // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x18];                                      // 0x00F0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EEnergyTypeEnum                               EnergyType;                                        // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _currentEnergyLevel;                               // 0x010C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxEnergyLevel;                                   // 0x0110(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_114[0x24];                                     // 0x0114(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_EnergyLevel(float previousEnergyLevel);
	void Reset();
	void SetEnergyLevel(float energyLevel);
	void SetMaxEnergyLevel(float energyLevel);
	void SetNormalizedEnergyLevel(float energyLevel);
	void UseEnergy(float seconds, float energyUseModifier);

	float GetEnergyLevel() const;
	float GetMaxEnergyLevel() const;
	float GetNormalizedEnergyLevel() const;
	bool HasCharge() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargerComponent">();
	}
	static class UChargerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargerComponent>();
	}
};
static_assert(alignof(UChargerComponent) == 0x000008, "Wrong alignment on UChargerComponent");
static_assert(sizeof(UChargerComponent) == 0x000138, "Wrong size on UChargerComponent");
static_assert(offsetof(UChargerComponent, ChargerComponentID) == 0x0000C0, "Member 'UChargerComponent::ChargerComponentID' has a wrong offset!");
static_assert(offsetof(UChargerComponent, OnChargeStateChange) == 0x0000D0, "Member 'UChargerComponent::OnChargeStateChange' has a wrong offset!");
static_assert(offsetof(UChargerComponent, OnChargePercentChange) == 0x0000E0, "Member 'UChargerComponent::OnChargePercentChange' has a wrong offset!");
static_assert(offsetof(UChargerComponent, EnergyType) == 0x000108, "Member 'UChargerComponent::EnergyType' has a wrong offset!");
static_assert(offsetof(UChargerComponent, _currentEnergyLevel) == 0x00010C, "Member 'UChargerComponent::_currentEnergyLevel' has a wrong offset!");
static_assert(offsetof(UChargerComponent, _maxEnergyLevel) == 0x000110, "Member 'UChargerComponent::_maxEnergyLevel' has a wrong offset!");

// Class DeadByDaylight.DBDGame_Start
// 0x00A8 (0x0408 - 0x0360)
class ADBDGame_Start final : public ADBDBaseGameMode
{
public:
	uint8                                         Pad_360[0x60];                                     // 0x0360(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TScriptInterface<class IClientStartupInitializerInterface> _startupInitializer;                  // 0x03C0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x38];                                     // 0x03D0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGame_Start">();
	}
	static class ADBDGame_Start* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGame_Start>();
	}
};
static_assert(alignof(ADBDGame_Start) == 0x000008, "Wrong alignment on ADBDGame_Start");
static_assert(sizeof(ADBDGame_Start) == 0x000408, "Wrong size on ADBDGame_Start");
static_assert(offsetof(ADBDGame_Start, _startupInitializer) == 0x0003C0, "Member 'ADBDGame_Start::_startupInitializer' has a wrong offset!");

// Class DeadByDaylight.ChargeStrategy
// 0x0018 (0x0048 - 0x0030)
class UChargeStrategy final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _shouldApplyRedirectedChargeNormally;              // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldBroadcastChargeApplied;                     // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldApplyModifiersToRedirectedCharge;           // 0x0042(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldAllowChargeFromItem;                        // 0x0043(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldRedirectSkillcheckChargePenalty;            // 0x0044(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeStrategy">();
	}
	static class UChargeStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeStrategy>();
	}
};
static_assert(alignof(UChargeStrategy) == 0x000008, "Wrong alignment on UChargeStrategy");
static_assert(sizeof(UChargeStrategy) == 0x000048, "Wrong size on UChargeStrategy");
static_assert(offsetof(UChargeStrategy, _shouldApplyRedirectedChargeNormally) == 0x000040, "Member 'UChargeStrategy::_shouldApplyRedirectedChargeNormally' has a wrong offset!");
static_assert(offsetof(UChargeStrategy, _shouldBroadcastChargeApplied) == 0x000041, "Member 'UChargeStrategy::_shouldBroadcastChargeApplied' has a wrong offset!");
static_assert(offsetof(UChargeStrategy, _shouldApplyModifiersToRedirectedCharge) == 0x000042, "Member 'UChargeStrategy::_shouldApplyModifiersToRedirectedCharge' has a wrong offset!");
static_assert(offsetof(UChargeStrategy, _shouldAllowChargeFromItem) == 0x000043, "Member 'UChargeStrategy::_shouldAllowChargeFromItem' has a wrong offset!");
static_assert(offsetof(UChargeStrategy, _shouldRedirectSkillcheckChargePenalty) == 0x000044, "Member 'UChargeStrategy::_shouldRedirectSkillcheckChargePenalty' has a wrong offset!");

// Class DeadByDaylight.CharmAttachable
// 0x0000 (0x0000 - 0x0000)
class ICharmAttachable final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharmAttachable">();
	}
	static class ICharmAttachable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICharmAttachable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICharmAttachable) == 0x000001, "Wrong alignment on ICharmAttachable");
static_assert(sizeof(ICharmAttachable) == 0x000001, "Wrong size on ICharmAttachable");

// Class DeadByDaylight.HasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy">();
	}
	static class UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy>();
	}
};
static_assert(alignof(UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy) == 0x000008, "Wrong alignment on UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy");
static_assert(sizeof(UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy) == 0x000038, "Wrong size on UHasTokenOrCooldownTimerRemainingActivationElapsedIconStrategy");

// Class DeadByDaylight.CharmAttacher
// 0x0038 (0x0268 - 0x0230)
class ACharmAttacher final : public AActor
{
public:
	TMulticastInlineDelegate<void()>              OnAttachedOnActor;                                 // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCharmAnimationTagsChanged;                       // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UDBDSkeletalMeshComponentBudgeted*      _chain;                                            // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACharm*                                 _attachedCharm;                                    // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindOnCharmAnimationTagsChanged();
	void DispatchOnCharmAnimationTagsChanged();
	class AActor* GetActorAttachedOn();
	struct FCharmAttacherAnimationTweak GetAnimationTweak();
	class ACharm* GetAttachedCharm();
	class USkeletalMeshComponent* GetSkeletalMeshComponentAttachedOn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharmAttacher">();
	}
	static class ACharmAttacher* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharmAttacher>();
	}
};
static_assert(alignof(ACharmAttacher) == 0x000008, "Wrong alignment on ACharmAttacher");
static_assert(sizeof(ACharmAttacher) == 0x000268, "Wrong size on ACharmAttacher");
static_assert(offsetof(ACharmAttacher, OnAttachedOnActor) == 0x000230, "Member 'ACharmAttacher::OnAttachedOnActor' has a wrong offset!");
static_assert(offsetof(ACharmAttacher, OnCharmAnimationTagsChanged) == 0x000240, "Member 'ACharmAttacher::OnCharmAnimationTagsChanged' has a wrong offset!");
static_assert(offsetof(ACharmAttacher, _chain) == 0x000250, "Member 'ACharmAttacher::_chain' has a wrong offset!");
static_assert(offsetof(ACharmAttacher, _attachedCharm) == 0x000258, "Member 'ACharmAttacher::_attachedCharm' has a wrong offset!");

// Class DeadByDaylight.HitValidatorConfigurator
// 0x0010 (0x00D0 - 0x00C0)
class UHitValidatorConfigurator final : public UBaseHitValidationConfigurator
{
public:
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitValidatorConfigurator">();
	}
	static class UHitValidatorConfigurator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitValidatorConfigurator>();
	}
};
static_assert(alignof(UHitValidatorConfigurator) == 0x000008, "Wrong alignment on UHitValidatorConfigurator");
static_assert(sizeof(UHitValidatorConfigurator) == 0x0000D0, "Wrong size on UHitValidatorConfigurator");

// Class DeadByDaylight.DBDGameEventForwarderComponent
// 0x0018 (0x00D0 - 0x00B8)
class UDBDGameEventForwarderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameEventForwarderComponent">();
	}
	static class UDBDGameEventForwarderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameEventForwarderComponent>();
	}
};
static_assert(alignof(UDBDGameEventForwarderComponent) == 0x000008, "Wrong alignment on UDBDGameEventForwarderComponent");
static_assert(sizeof(UDBDGameEventForwarderComponent) == 0x0000D0, "Wrong size on UDBDGameEventForwarderComponent");

// Class DeadByDaylight.CharmSpawnerComponent
// 0x0030 (0x00E8 - 0x00B8)
class UCharmSpawnerComponent final : public UActorComponent
{
public:
	class FName                                   SocketRootName;                                    // 0x00B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharmSlot>                     CharmSlots;                                        // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                ScaleCharm;                                        // 0x00D8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _forcedLOD;                                        // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ReplaceCharmTextures(const TArray<struct FCharmIdSlot>& customization);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharmSpawnerComponent">();
	}
	static class UCharmSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharmSpawnerComponent>();
	}
};
static_assert(alignof(UCharmSpawnerComponent) == 0x000008, "Wrong alignment on UCharmSpawnerComponent");
static_assert(sizeof(UCharmSpawnerComponent) == 0x0000E8, "Wrong size on UCharmSpawnerComponent");
static_assert(offsetof(UCharmSpawnerComponent, SocketRootName) == 0x0000B8, "Member 'UCharmSpawnerComponent::SocketRootName' has a wrong offset!");
static_assert(offsetof(UCharmSpawnerComponent, CharmSlots) == 0x0000C8, "Member 'UCharmSpawnerComponent::CharmSlots' has a wrong offset!");
static_assert(offsetof(UCharmSpawnerComponent, ScaleCharm) == 0x0000D8, "Member 'UCharmSpawnerComponent::ScaleCharm' has a wrong offset!");
static_assert(offsetof(UCharmSpawnerComponent, _forcedLOD) == 0x0000E4, "Member 'UCharmSpawnerComponent::_forcedLOD' has a wrong offset!");

// Class DeadByDaylight.ChaseComponent
// 0x0070 (0x0128 - 0x00B8)
class UChaseComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class ADBDPlayer* player)> OnChaseStarted;                         // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* player, float chaseTime)> OnChaseEnded;          // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAllChaseEnded;                                   // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool isInChase)> OnIsInChaseChanged;                               // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTagStateBool                          _isInChase;                                        // 0x00F8(0x0030)(Net, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_IsInChase();

	bool IsInChase() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChaseComponent">();
	}
	static class UChaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChaseComponent>();
	}
};
static_assert(alignof(UChaseComponent) == 0x000008, "Wrong alignment on UChaseComponent");
static_assert(sizeof(UChaseComponent) == 0x000128, "Wrong size on UChaseComponent");
static_assert(offsetof(UChaseComponent, OnChaseStarted) == 0x0000B8, "Member 'UChaseComponent::OnChaseStarted' has a wrong offset!");
static_assert(offsetof(UChaseComponent, OnChaseEnded) == 0x0000C8, "Member 'UChaseComponent::OnChaseEnded' has a wrong offset!");
static_assert(offsetof(UChaseComponent, OnAllChaseEnded) == 0x0000D8, "Member 'UChaseComponent::OnAllChaseEnded' has a wrong offset!");
static_assert(offsetof(UChaseComponent, OnIsInChaseChanged) == 0x0000E8, "Member 'UChaseComponent::OnIsInChaseChanged' has a wrong offset!");
static_assert(offsetof(UChaseComponent, _isInChase) == 0x0000F8, "Member 'UChaseComponent::_isInChase' has a wrong offset!");

// Class DeadByDaylight.TallyScreen
// 0x00F0 (0x0210 - 0x0120)
class UTallyScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0xF0];                                     // 0x0120(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBloodwebButtonClick();
	void OnCustomerSupportButtonClick();
	void OnLeaveButtonClick();
	void OnLevelingSequenceComplete();
	void OnPlayerInfoClick(const class FString& playerId);
	void OnPlayerOptionClick(const class FString& krakenId, const class FString& playerId, uint8 option);
	void OnRateMatch(int32 rateValue);
	void OnReportPlayerButtonClick(const class FString& playerId);
	void OnShowSlasherInfos();
	void OnSpectateButtonClick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TallyScreen">();
	}
	static class UTallyScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTallyScreen>();
	}
};
static_assert(alignof(UTallyScreen) == 0x000008, "Wrong alignment on UTallyScreen");
static_assert(sizeof(UTallyScreen) == 0x000210, "Wrong size on UTallyScreen");

// Class DeadByDaylight.DBDGameViewportClient
// 0x0038 (0x03A8 - 0x0370)
class UDBDGameViewportClient final : public UGameViewportClient
{
public:
	uint8                                         Pad_370[0x38];                                     // 0x0370(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameViewportClient">();
	}
	static class UDBDGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameViewportClient>();
	}
};
static_assert(alignof(UDBDGameViewportClient) == 0x000008, "Wrong alignment on UDBDGameViewportClient");
static_assert(sizeof(UDBDGameViewportClient) == 0x0003A8, "Wrong size on UDBDGameViewportClient");

// Class DeadByDaylight.ChaseeCharacterComponent
// 0x0068 (0x0190 - 0x0128)
class UChaseeCharacterComponent final : public UChaseComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _totalChaseTimeThisMatchDebugReplicated;           // 0x0130(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_134[0x5C];                                     // 0x0134(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnGeneratorPercentChanged(class UChargeableComponent* chargeableComponent, float percentCompletionChange, float totalPercentComplete);
	void Authority_OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChaseeCharacterComponent">();
	}
	static class UChaseeCharacterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChaseeCharacterComponent>();
	}
};
static_assert(alignof(UChaseeCharacterComponent) == 0x000008, "Wrong alignment on UChaseeCharacterComponent");
static_assert(sizeof(UChaseeCharacterComponent) == 0x000190, "Wrong size on UChaseeCharacterComponent");
static_assert(offsetof(UChaseeCharacterComponent, _totalChaseTimeThisMatchDebugReplicated) == 0x000130, "Member 'UChaseeCharacterComponent::_totalChaseTimeThisMatchDebugReplicated' has a wrong offset!");

// Class DeadByDaylight.ChaserCharacterComponent
// 0x00D8 (0x0200 - 0x0128)
class UChaserCharacterComponent final : public UChaseComponent
{
public:
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDPawnSensingComponent*               _camperSensor;                                     // 0x0138(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ADBDPlayer*, struct FChaseUpdateInfo> _chaseUpdateInfo;                               // 0x0140(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<class ADBDPlayer*>                     _chasedPlayers;                                    // 0x0190(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ADBDPlayer*>                     _authority_survivorsWhoStunnedKillerByPalletDuringChase; // 0x01A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x30];                                     // 0x01B0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _preventChaseTags;                                 // 0x01E0(0x0020)(Edit, NativeAccessSpecifierPrivate)

public:
	void Authority_OnChaseTargetFound(class APawn* pawn);
	void Multicast_OnAllChaseEnd();
	void Multicast_OnChaseEnd(class ACamperPlayer* survivor, const struct FChaseUpdateInfo& chaseUpdateInfo);
	void Multicast_OnChaseStart(class ACamperPlayer* survivor);
	void OnKillerLocallyObservedChanged(bool locallyObserved);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChaserCharacterComponent">();
	}
	static class UChaserCharacterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChaserCharacterComponent>();
	}
};
static_assert(alignof(UChaserCharacterComponent) == 0x000008, "Wrong alignment on UChaserCharacterComponent");
static_assert(sizeof(UChaserCharacterComponent) == 0x000200, "Wrong size on UChaserCharacterComponent");
static_assert(offsetof(UChaserCharacterComponent, _camperSensor) == 0x000138, "Member 'UChaserCharacterComponent::_camperSensor' has a wrong offset!");
static_assert(offsetof(UChaserCharacterComponent, _chaseUpdateInfo) == 0x000140, "Member 'UChaserCharacterComponent::_chaseUpdateInfo' has a wrong offset!");
static_assert(offsetof(UChaserCharacterComponent, _chasedPlayers) == 0x000190, "Member 'UChaserCharacterComponent::_chasedPlayers' has a wrong offset!");
static_assert(offsetof(UChaserCharacterComponent, _authority_survivorsWhoStunnedKillerByPalletDuringChase) == 0x0001A0, "Member 'UChaserCharacterComponent::_authority_survivorsWhoStunnedKillerByPalletDuringChase' has a wrong offset!");
static_assert(offsetof(UChaserCharacterComponent, _preventChaseTags) == 0x0001E0, "Member 'UChaserCharacterComponent::_preventChaseTags' has a wrong offset!");

// Class DeadByDaylight.ChatManager
// 0x0020 (0x0250 - 0x0230)
class AChatManager final : public AActor
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_238[0x18];                                     // 0x0238(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_DisplayMessage(const class FString& chatIdentifier, int32 playerIndex, const class FString& mirrorsId, const class FString& msg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatManager">();
	}
	static class AChatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChatManager>();
	}
};
static_assert(alignof(AChatManager) == 0x000008, "Wrong alignment on AChatManager");
static_assert(sizeof(AChatManager) == 0x000250, "Wrong size on AChatManager");
static_assert(offsetof(AChatManager, _gameInstance) == 0x000230, "Member 'AChatManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.StationarySpotLightComponent
// 0x0000 (0x0430 - 0x0430)
class UStationarySpotLightComponent final : public USpotLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StationarySpotLightComponent">();
	}
	static class UStationarySpotLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStationarySpotLightComponent>();
	}
};
static_assert(alignof(UStationarySpotLightComponent) == 0x000010, "Wrong alignment on UStationarySpotLightComponent");
static_assert(sizeof(UStationarySpotLightComponent) == 0x000430, "Wrong size on UStationarySpotLightComponent");

// Class DeadByDaylight.ChatSimulator
// 0x0020 (0x0050 - 0x0030)
class UChatSimulator final : public UObject
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatSimulator">();
	}
	static class UChatSimulator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatSimulator>();
	}
};
static_assert(alignof(UChatSimulator) == 0x000008, "Wrong alignment on UChatSimulator");
static_assert(sizeof(UChatSimulator) == 0x000050, "Wrong size on UChatSimulator");

// Class DeadByDaylight.ChunkingManager
// 0x0038 (0x0068 - 0x0030)
class UChunkingManager final : public UObject
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChunkingManager">();
	}
	static class UChunkingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChunkingManager>();
	}
};
static_assert(alignof(UChunkingManager) == 0x000008, "Wrong alignment on UChunkingManager");
static_assert(sizeof(UChunkingManager) == 0x000068, "Wrong size on UChunkingManager");
static_assert(offsetof(UChunkingManager, _gameInstance) == 0x000030, "Member 'UChunkingManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.CannibalChainsawPower
// 0x0000 (0x0000 - 0x0000)
class ICannibalChainsawPower final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CannibalChainsawPower">();
	}
	static class ICannibalChainsawPower* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICannibalChainsawPower>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ICannibalChainsawPower) == 0x000001, "Wrong alignment on ICannibalChainsawPower");
static_assert(sizeof(ICannibalChainsawPower) == 0x000001, "Wrong size on ICannibalChainsawPower");

// Class DeadByDaylight.CinematicManager
// 0x0030 (0x0060 - 0x0030)
class UCinematicManager final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCinematic>                     _cinematicQueue;                                   // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UBackendCinematicContainer*             _backendContainer;                                 // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CancelAllCinematicToPlay();
	struct FCinematic GetNextCinematicToPlay();
	void PlayMultiple(const TArray<struct FCinematic>& cinematics);
	void PlaySingle(const struct FCinematic& cinematic);

	bool HasCinematicToPlay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinematicManager">();
	}
	static class UCinematicManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCinematicManager>();
	}
};
static_assert(alignof(UCinematicManager) == 0x000008, "Wrong alignment on UCinematicManager");
static_assert(sizeof(UCinematicManager) == 0x000060, "Wrong size on UCinematicManager");
static_assert(offsetof(UCinematicManager, _cinematicQueue) == 0x000048, "Member 'UCinematicManager::_cinematicQueue' has a wrong offset!");
static_assert(offsetof(UCinematicManager, _backendContainer) == 0x000058, "Member 'UCinematicManager::_backendContainer' has a wrong offset!");

// Class DeadByDaylight.CinematicScreen
// 0x0000 (0x0120 - 0x0120)
class UCinematicScreen final : public UScreenBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CinematicScreen">();
	}
	static class UCinematicScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCinematicScreen>();
	}
};
static_assert(alignof(UCinematicScreen) == 0x000008, "Wrong alignment on UCinematicScreen");
static_assert(sizeof(UCinematicScreen) == 0x000120, "Wrong size on UCinematicScreen");

// Class DeadByDaylight.TileMatrix
// 0x0058 (0x0088 - 0x0030)
class UTileMatrix final : public UObject
{
public:
	TArray<struct FArrayOfATile>                  _matrix;                                           // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ATile*>                          _tiles;                                            // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ATile*>                          _extraTiles;                                       // 0x0050(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class AActor*                                 _basementActor;                                    // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FQuadrantInfo>                  _quadInfoArray;                                    // 0x0068(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FArrayOfInt32>                  _quadIndexMatrix;                                  // 0x0078(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileMatrix">();
	}
	static class UTileMatrix* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileMatrix>();
	}
};
static_assert(alignof(UTileMatrix) == 0x000008, "Wrong alignment on UTileMatrix");
static_assert(sizeof(UTileMatrix) == 0x000088, "Wrong size on UTileMatrix");
static_assert(offsetof(UTileMatrix, _matrix) == 0x000030, "Member 'UTileMatrix::_matrix' has a wrong offset!");
static_assert(offsetof(UTileMatrix, _tiles) == 0x000040, "Member 'UTileMatrix::_tiles' has a wrong offset!");
static_assert(offsetof(UTileMatrix, _extraTiles) == 0x000050, "Member 'UTileMatrix::_extraTiles' has a wrong offset!");
static_assert(offsetof(UTileMatrix, _basementActor) == 0x000060, "Member 'UTileMatrix::_basementActor' has a wrong offset!");
static_assert(offsetof(UTileMatrix, _quadInfoArray) == 0x000068, "Member 'UTileMatrix::_quadInfoArray' has a wrong offset!");
static_assert(offsetof(UTileMatrix, _quadIndexMatrix) == 0x000078, "Member 'UTileMatrix::_quadIndexMatrix' has a wrong offset!");

// Class DeadByDaylight.DBDInstancedFoliageComponent
// 0x0068 (0x0120 - 0x00B8)
class UDBDInstancedFoliageComponent final : public UActorComponent
{
public:
	int32                                         NextBaseId;                                        // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class USceneComponent*>           InstanceBaseMap;                                   // 0x00C0(0x0050)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FDBDFoliageInfo>                foliage;                                           // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInstancedFoliageComponent">();
	}
	static class UDBDInstancedFoliageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDInstancedFoliageComponent>();
	}
};
static_assert(alignof(UDBDInstancedFoliageComponent) == 0x000008, "Wrong alignment on UDBDInstancedFoliageComponent");
static_assert(sizeof(UDBDInstancedFoliageComponent) == 0x000120, "Wrong size on UDBDInstancedFoliageComponent");
static_assert(offsetof(UDBDInstancedFoliageComponent, NextBaseId) == 0x0000B8, "Member 'UDBDInstancedFoliageComponent::NextBaseId' has a wrong offset!");
static_assert(offsetof(UDBDInstancedFoliageComponent, InstanceBaseMap) == 0x0000C0, "Member 'UDBDInstancedFoliageComponent::InstanceBaseMap' has a wrong offset!");
static_assert(offsetof(UDBDInstancedFoliageComponent, foliage) == 0x000110, "Member 'UDBDInstancedFoliageComponent::foliage' has a wrong offset!");

// Class DeadByDaylight.ClientBloodwebContentAdapter
// 0x0010 (0x0070 - 0x0060)
class UClientBloodwebContentAdapter final : public UBaseBloodwebContentAdapter
{
public:
	class UBloodwebGenerator*                     _bloodwebBuilder;                                  // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientBloodwebContentAdapter">();
	}
	static class UClientBloodwebContentAdapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientBloodwebContentAdapter>();
	}
};
static_assert(alignof(UClientBloodwebContentAdapter) == 0x000008, "Wrong alignment on UClientBloodwebContentAdapter");
static_assert(sizeof(UClientBloodwebContentAdapter) == 0x000070, "Wrong size on UClientBloodwebContentAdapter");
static_assert(offsetof(UClientBloodwebContentAdapter, _bloodwebBuilder) == 0x000060, "Member 'UClientBloodwebContentAdapter::_bloodwebBuilder' has a wrong offset!");

// Class DeadByDaylight.DBDGenericTeamAgentInterface
// 0x0000 (0x0000 - 0x0000)
class IDBDGenericTeamAgentInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGenericTeamAgentInterface">();
	}
	static class IDBDGenericTeamAgentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDBDGenericTeamAgentInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDBDGenericTeamAgentInterface) == 0x000001, "Wrong alignment on IDBDGenericTeamAgentInterface");
static_assert(sizeof(IDBDGenericTeamAgentInterface) == 0x000001, "Wrong size on IDBDGenericTeamAgentInterface");

// Class DeadByDaylight.ClipManager
// 0x0118 (0x0348 - 0x0230)
class AClipManager final : public AActor
{
public:
	TArray<class UDBDClipRegionComponent*>        _clippingZones;                                    // 0x0230(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UMeshComponent*>                   _meshComponents;                                   // 0x0240(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FMaterialOriginalState>         _dissolvedMeshes;                                  // 0x0290(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UMaterialInterface*, class UMaterialInterface*> _normal2dissolve;                     // 0x02A0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class UMaterialInterface*, class UMaterialInterface*> _dissolve2normal;                     // 0x02F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UDataTable*                             _sphericalDissolveMaterials;                       // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void RemoveDissolveMaterials();
	void SphericalDissolveAt(const struct FVector& Location, float radius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClipManager">();
	}
	static class AClipManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AClipManager>();
	}
};
static_assert(alignof(AClipManager) == 0x000008, "Wrong alignment on AClipManager");
static_assert(sizeof(AClipManager) == 0x000348, "Wrong size on AClipManager");
static_assert(offsetof(AClipManager, _clippingZones) == 0x000230, "Member 'AClipManager::_clippingZones' has a wrong offset!");
static_assert(offsetof(AClipManager, _meshComponents) == 0x000240, "Member 'AClipManager::_meshComponents' has a wrong offset!");
static_assert(offsetof(AClipManager, _dissolvedMeshes) == 0x000290, "Member 'AClipManager::_dissolvedMeshes' has a wrong offset!");
static_assert(offsetof(AClipManager, _normal2dissolve) == 0x0002A0, "Member 'AClipManager::_normal2dissolve' has a wrong offset!");
static_assert(offsetof(AClipManager, _dissolve2normal) == 0x0002F0, "Member 'AClipManager::_dissolve2normal' has a wrong offset!");
static_assert(offsetof(AClipManager, _sphericalDissolveMaterials) == 0x000340, "Member 'AClipManager::_sphericalDissolveMaterials' has a wrong offset!");

// Class DeadByDaylight.S3GameConfigsDS
// 0x0100 (0x0138 - 0x0038)
class US3GameConfigsDS final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x100];                                     // 0x0038(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S3GameConfigsDS">();
	}
	static class US3GameConfigsDS* GetDefaultObj()
	{
		return GetDefaultObjImpl<US3GameConfigsDS>();
	}
};
static_assert(alignof(US3GameConfigsDS) == 0x000008, "Wrong alignment on US3GameConfigsDS");
static_assert(sizeof(US3GameConfigsDS) == 0x000138, "Wrong size on US3GameConfigsDS");

// Class DeadByDaylight.CollectableCollection
// 0x0048 (0x0100 - 0x00B8)
class UCollectableCollection final : public UActorComponent
{
public:
	TArray<class ACollectable*>                   _collectables;                                     // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x38];                                      // 0x00C8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectableCollection">();
	}
	static class UCollectableCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectableCollection>();
	}
};
static_assert(alignof(UCollectableCollection) == 0x000008, "Wrong alignment on UCollectableCollection");
static_assert(sizeof(UCollectableCollection) == 0x000100, "Wrong size on UCollectableCollection");
static_assert(offsetof(UCollectableCollection, _collectables) == 0x0000B8, "Member 'UCollectableCollection::_collectables' has a wrong offset!");

// Class DeadByDaylight.CombinedPartyFriendFacade
// 0x0138 (0x0168 - 0x0030)
class UCombinedPartyFriendFacade final : public UObject
{
public:
	uint8                                         Pad_30[0x138];                                     // 0x0030(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CombinedPartyFriendFacade">();
	}
	static class UCombinedPartyFriendFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCombinedPartyFriendFacade>();
	}
};
static_assert(alignof(UCombinedPartyFriendFacade) == 0x000008, "Wrong alignment on UCombinedPartyFriendFacade");
static_assert(sizeof(UCombinedPartyFriendFacade) == 0x000168, "Wrong size on UCombinedPartyFriendFacade");

// Class DeadByDaylight.ButtonPromptSource
// 0x0000 (0x0000 - 0x0000)
class IButtonPromptSource final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ButtonPromptSource">();
	}
	static class IButtonPromptSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IButtonPromptSource>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IButtonPromptSource) == 0x000001, "Wrong alignment on IButtonPromptSource");
static_assert(sizeof(IButtonPromptSource) == 0x000001, "Wrong size on IButtonPromptSource");

// Class DeadByDaylight.CombinedSpecialEventDataUtilities
// 0x0000 (0x0030 - 0x0030)
class UCombinedSpecialEventDataUtilities final : public UBlueprintFunctionLibrary
{
public:
	static struct FColor GetObjectOutlineColour(const struct FCombinedSpecialEventData& data);
	static class FName GetSpecialMusicState(const struct FCombinedSpecialEventData& data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CombinedSpecialEventDataUtilities">();
	}
	static class UCombinedSpecialEventDataUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCombinedSpecialEventDataUtilities>();
	}
};
static_assert(alignof(UCombinedSpecialEventDataUtilities) == 0x000008, "Wrong alignment on UCombinedSpecialEventDataUtilities");
static_assert(sizeof(UCombinedSpecialEventDataUtilities) == 0x000030, "Wrong size on UCombinedSpecialEventDataUtilities");

// Class DeadByDaylight.ConeAroundDirectionCameraStrategy
// 0x0028 (0x0058 - 0x0030)
class UConeAroundDirectionCameraStrategy final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxPitchDifference;                               // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxYawDifference;                                 // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxRollDifference;                                // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConeAroundDirectionCameraStrategy">();
	}
	static class UConeAroundDirectionCameraStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConeAroundDirectionCameraStrategy>();
	}
};
static_assert(alignof(UConeAroundDirectionCameraStrategy) == 0x000008, "Wrong alignment on UConeAroundDirectionCameraStrategy");
static_assert(sizeof(UConeAroundDirectionCameraStrategy) == 0x000058, "Wrong size on UConeAroundDirectionCameraStrategy");
static_assert(offsetof(UConeAroundDirectionCameraStrategy, _maxPitchDifference) == 0x000048, "Member 'UConeAroundDirectionCameraStrategy::_maxPitchDifference' has a wrong offset!");
static_assert(offsetof(UConeAroundDirectionCameraStrategy, _maxYawDifference) == 0x00004C, "Member 'UConeAroundDirectionCameraStrategy::_maxYawDifference' has a wrong offset!");
static_assert(offsetof(UConeAroundDirectionCameraStrategy, _maxRollDifference) == 0x000050, "Member 'UConeAroundDirectionCameraStrategy::_maxRollDifference' has a wrong offset!");

// Class DeadByDaylight.ConnectionStatusSubsystem
// 0x00E0 (0x0118 - 0x0038)
class UConnectionStatusSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xE0];                                      // 0x0038(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConnectionStatusSubsystem">();
	}
	static class UConnectionStatusSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConnectionStatusSubsystem>();
	}
};
static_assert(alignof(UConnectionStatusSubsystem) == 0x000008, "Wrong alignment on UConnectionStatusSubsystem");
static_assert(sizeof(UConnectionStatusSubsystem) == 0x000118, "Wrong size on UConnectionStatusSubsystem");

// Class DeadByDaylight.PS4GRDKBaseProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UPS4GRDKBaseProfileDAL : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PS4GRDKBaseProfileDAL">();
	}
	static class UPS4GRDKBaseProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPS4GRDKBaseProfileDAL>();
	}
};
static_assert(alignof(UPS4GRDKBaseProfileDAL) == 0x000008, "Wrong alignment on UPS4GRDKBaseProfileDAL");
static_assert(sizeof(UPS4GRDKBaseProfileDAL) == 0x000088, "Wrong size on UPS4GRDKBaseProfileDAL");

// Class DeadByDaylight.StadiaProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UStadiaProfileDAL final : public UPS4GRDKBaseProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StadiaProfileDAL">();
	}
	static class UStadiaProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStadiaProfileDAL>();
	}
};
static_assert(alignof(UStadiaProfileDAL) == 0x000008, "Wrong alignment on UStadiaProfileDAL");
static_assert(sizeof(UStadiaProfileDAL) == 0x000088, "Wrong size on UStadiaProfileDAL");

// Class DeadByDaylight.ConstrainAspectRatioComponent
// 0x00B8 (0x0170 - 0x00B8)
class UConstrainAspectRatioComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xB8];                                      // 0x00B8(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_ToggleBlackBars(int32 option);
	void OnIntroCompleted();
	void SetCinematicMode(bool cinematicMode);

	struct FIntPoint GetCameraConstrainedViewSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConstrainAspectRatioComponent">();
	}
	static class UConstrainAspectRatioComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConstrainAspectRatioComponent>();
	}
};
static_assert(alignof(UConstrainAspectRatioComponent) == 0x000008, "Wrong alignment on UConstrainAspectRatioComponent");
static_assert(sizeof(UConstrainAspectRatioComponent) == 0x000170, "Wrong size on UConstrainAspectRatioComponent");

// Class DeadByDaylight.UMGTallyBloodpointsScoreWidget
// 0x0000 (0x0338 - 0x0338)
class UUMGTallyBloodpointsScoreWidget final : public UMobileBaseUserWidget
{
public:
	void UpdateWidgetByScoreData(const class FText& title, const class UTexture2D* asset, int32 scoreValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyBloodpointsScoreWidget">();
	}
	static class UUMGTallyBloodpointsScoreWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyBloodpointsScoreWidget>();
	}
};
static_assert(alignof(UUMGTallyBloodpointsScoreWidget) == 0x000008, "Wrong alignment on UUMGTallyBloodpointsScoreWidget");
static_assert(sizeof(UUMGTallyBloodpointsScoreWidget) == 0x000338, "Wrong size on UUMGTallyBloodpointsScoreWidget");

// Class DeadByDaylight.BatchDrawing
// 0x0080 (0x00B0 - 0x0030)
class UBatchDrawing final : public UObject
{
public:
	class AActor*                                 _actorToSpawnInstancesInto;                        // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UStaticMesh*, struct FPerMeshInstancingData> _meshesToInstancingData;                 // 0x0038(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UHISMMaterialHelperSettings*            _hismMaterialHelperSettings;                       // 0x0088(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 _currentWorld;                                     // 0x0090(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FStaticMeshAutoBatch>           _meshAutoBatch;                                    // 0x0098(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BatchDrawing">();
	}
	static class UBatchDrawing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBatchDrawing>();
	}
};
static_assert(alignof(UBatchDrawing) == 0x000008, "Wrong alignment on UBatchDrawing");
static_assert(sizeof(UBatchDrawing) == 0x0000B0, "Wrong size on UBatchDrawing");
static_assert(offsetof(UBatchDrawing, _actorToSpawnInstancesInto) == 0x000030, "Member 'UBatchDrawing::_actorToSpawnInstancesInto' has a wrong offset!");
static_assert(offsetof(UBatchDrawing, _meshesToInstancingData) == 0x000038, "Member 'UBatchDrawing::_meshesToInstancingData' has a wrong offset!");
static_assert(offsetof(UBatchDrawing, _hismMaterialHelperSettings) == 0x000088, "Member 'UBatchDrawing::_hismMaterialHelperSettings' has a wrong offset!");
static_assert(offsetof(UBatchDrawing, _currentWorld) == 0x000090, "Member 'UBatchDrawing::_currentWorld' has a wrong offset!");
static_assert(offsetof(UBatchDrawing, _meshAutoBatch) == 0x000098, "Member 'UBatchDrawing::_meshAutoBatch' has a wrong offset!");

// Class DeadByDaylight.ContainsItemInterface
// 0x0000 (0x0000 - 0x0000)
class IContainsItemInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContainsItemInterface">();
	}
	static class IContainsItemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IContainsItemInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IContainsItemInterface) == 0x000001, "Wrong alignment on IContainsItemInterface");
static_assert(sizeof(IContainsItemInterface) == 0x000001, "Wrong size on IContainsItemInterface");

// Class DeadByDaylight.PlayerScoreComponent
// 0x00A0 (0x0158 - 0x00B8)
class UPlayerScoreComponent final : public UActorComponent
{
public:
	TSoftObjectPtr<class UDataTable>              _scoreEmitterDB;                                   // 0x00B8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class UPlayerScoreEmitter*>              _emitters;                                         // 0x00E8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x20];                                     // 0x0138(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerScoreComponent">();
	}
	static class UPlayerScoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerScoreComponent>();
	}
};
static_assert(alignof(UPlayerScoreComponent) == 0x000008, "Wrong alignment on UPlayerScoreComponent");
static_assert(sizeof(UPlayerScoreComponent) == 0x000158, "Wrong size on UPlayerScoreComponent");
static_assert(offsetof(UPlayerScoreComponent, _scoreEmitterDB) == 0x0000B8, "Member 'UPlayerScoreComponent::_scoreEmitterDB' has a wrong offset!");
static_assert(offsetof(UPlayerScoreComponent, _emitters) == 0x0000E8, "Member 'UPlayerScoreComponent::_emitters' has a wrong offset!");

// Class DeadByDaylight.ContentScheduleManager
// 0x0110 (0x0140 - 0x0030)
class UContentScheduleManager final : public UObject
{
public:
	uint8                                         Pad_30[0x108];                                     // 0x0030(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectLibrary*                         _availableMapLibrary;                              // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentScheduleManager">();
	}
	static class UContentScheduleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentScheduleManager>();
	}
};
static_assert(alignof(UContentScheduleManager) == 0x000008, "Wrong alignment on UContentScheduleManager");
static_assert(sizeof(UContentScheduleManager) == 0x000140, "Wrong size on UContentScheduleManager");
static_assert(offsetof(UContentScheduleManager, _availableMapLibrary) == 0x000138, "Member 'UContentScheduleManager::_availableMapLibrary' has a wrong offset!");

// Class DeadByDaylight.ContentVersionManager
// 0x0018 (0x0050 - 0x0038)
class UContentVersionManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContentVersionManager">();
	}
	static class UContentVersionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContentVersionManager>();
	}
};
static_assert(alignof(UContentVersionManager) == 0x000008, "Wrong alignment on UContentVersionManager");
static_assert(sizeof(UContentVersionManager) == 0x000050, "Wrong size on UContentVersionManager");

// Class DeadByDaylight.ContextualQuestComponent
// 0x0040 (0x00F8 - 0x00B8)
class UContextualQuestComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSpecialBehaviourObjectsInfo>   _specialBehaviourObjectsInfo;                      // 0x00E0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          _isInitialized;                                    // 0x00F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_DebugAddSpecialBehaviour(class FName id, int32 amountRequired);
	void Authority_DebugRemoveSpecialBehaviour(class FName id);
	void OnRep_SpecialBehaviourObjectsInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualQuestComponent">();
	}
	static class UContextualQuestComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualQuestComponent>();
	}
};
static_assert(alignof(UContextualQuestComponent) == 0x000008, "Wrong alignment on UContextualQuestComponent");
static_assert(sizeof(UContextualQuestComponent) == 0x0000F8, "Wrong size on UContextualQuestComponent");
static_assert(offsetof(UContextualQuestComponent, _specialBehaviourObjectsInfo) == 0x0000E0, "Member 'UContextualQuestComponent::_specialBehaviourObjectsInfo' has a wrong offset!");
static_assert(offsetof(UContextualQuestComponent, _isInitialized) == 0x0000F0, "Member 'UContextualQuestComponent::_isInitialized' has a wrong offset!");

// Class DeadByDaylight.DBDMaterialBlueprintLibrary
// 0x0000 (0x0030 - 0x0030)
class UDBDMaterialBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class UMaterialInstanceDynamic*> CreateDynamicMaterialInstanceForParticleSystem(class UParticleSystemComponent* System);
	static void SetTransformParameterInverseValueOnMaterialDynamic(class UMaterialInstanceDynamic* Material, class FName ParameterName, const struct FTransform& Value);
	static void SetTransformParameterValueOnMaterialDynamic(class UMaterialInstanceDynamic* Material, class FName ParameterName, const struct FTransform& Value);
	static void SetTransformParameterValueOnMeshComponent(class UMeshComponent* Mesh, class FName ParameterName, const struct FTransform& Value);
	static void SetVectorParameterValueOnMeshComponent(class UMeshComponent* Mesh, class FName ParameterName, const struct FLinearColor& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMaterialBlueprintLibrary">();
	}
	static class UDBDMaterialBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDMaterialBlueprintLibrary>();
	}
};
static_assert(alignof(UDBDMaterialBlueprintLibrary) == 0x000008, "Wrong alignment on UDBDMaterialBlueprintLibrary");
static_assert(sizeof(UDBDMaterialBlueprintLibrary) == 0x000030, "Wrong size on UDBDMaterialBlueprintLibrary");

// Class DeadByDaylight.ControllerPairingManager
// 0x0010 (0x0040 - 0x0030)
class UControllerPairingManager final : public UObject
{
public:
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllerPairingManager">();
	}
	static class UControllerPairingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllerPairingManager>();
	}
};
static_assert(alignof(UControllerPairingManager) == 0x000008, "Wrong alignment on UControllerPairingManager");
static_assert(sizeof(UControllerPairingManager) == 0x000040, "Wrong size on UControllerPairingManager");
static_assert(offsetof(UControllerPairingManager, _gameInstance) == 0x000030, "Member 'UControllerPairingManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.CooldownTimerPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UCooldownTimerPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CooldownTimerPerkIconStrategy">();
	}
	static class UCooldownTimerPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCooldownTimerPerkIconStrategy>();
	}
};
static_assert(alignof(UCooldownTimerPerkIconStrategy) == 0x000008, "Wrong alignment on UCooldownTimerPerkIconStrategy");
static_assert(sizeof(UCooldownTimerPerkIconStrategy) == 0x000038, "Wrong size on UCooldownTimerPerkIconStrategy");

// Class DeadByDaylight.StartupInitializerInterface
// 0x0000 (0x0000 - 0x0000)
class IStartupInitializerInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartupInitializerInterface">();
	}
	static class IStartupInitializerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStartupInitializerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStartupInitializerInterface) == 0x000001, "Wrong alignment on IStartupInitializerInterface");
static_assert(sizeof(IStartupInitializerInterface) == 0x000001, "Wrong size on IStartupInitializerInterface");

// Class DeadByDaylight.UMGToastNotificationScreen
// 0x0168 (0x04A0 - 0x0338)
class UUMGToastNotificationScreen final : public UMobileBaseUserWidget
{
public:
	TSoftClassPtr<class UClass>                   NotificationToast;                                 // 0x0338(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   InvitationPartyToast;                              // 0x0368(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ToastsContainer;                                   // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x30];                                     // 0x03A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint32, class UUMGBaseToastWidget*>      _toastsDisplayedOnScreen;                          // 0x03D0(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x80];                                     // 0x0420(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnButtonSelected(int32 buttonId, int32 notificationId);
	void HandleOnNotificationDisplayEnd(int32 notificationId);
	void HandleOnPromptSelected(int32 notificationId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGToastNotificationScreen">();
	}
	static class UUMGToastNotificationScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGToastNotificationScreen>();
	}
};
static_assert(alignof(UUMGToastNotificationScreen) == 0x000008, "Wrong alignment on UUMGToastNotificationScreen");
static_assert(sizeof(UUMGToastNotificationScreen) == 0x0004A0, "Wrong size on UUMGToastNotificationScreen");
static_assert(offsetof(UUMGToastNotificationScreen, NotificationToast) == 0x000338, "Member 'UUMGToastNotificationScreen::NotificationToast' has a wrong offset!");
static_assert(offsetof(UUMGToastNotificationScreen, InvitationPartyToast) == 0x000368, "Member 'UUMGToastNotificationScreen::InvitationPartyToast' has a wrong offset!");
static_assert(offsetof(UUMGToastNotificationScreen, ToastsContainer) == 0x000398, "Member 'UUMGToastNotificationScreen::ToastsContainer' has a wrong offset!");
static_assert(offsetof(UUMGToastNotificationScreen, _toastsDisplayedOnScreen) == 0x0003D0, "Member 'UUMGToastNotificationScreen::_toastsDisplayedOnScreen' has a wrong offset!");

// Class DeadByDaylight.DBDNavModifierComponent
// 0x0050 (0x01A0 - 0x0150)
class UDBDNavModifierComponent final : public UNavModifierComponent
{
public:
	bool                                          ForceUseFailsafeExtent;                            // 0x0150(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateModifierInterval;                            // 0x0154(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartNavigationRelevant;                           // 0x0158(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlwaysTickToCheckTransform;                        // 0x0159(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RelevantPassiveMode;                               // 0x015A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15B[0x45];                                     // 0x015B(0x0045)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDNavModifierComponent">();
	}
	static class UDBDNavModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDNavModifierComponent>();
	}
};
static_assert(alignof(UDBDNavModifierComponent) == 0x000010, "Wrong alignment on UDBDNavModifierComponent");
static_assert(sizeof(UDBDNavModifierComponent) == 0x0001A0, "Wrong size on UDBDNavModifierComponent");
static_assert(offsetof(UDBDNavModifierComponent, ForceUseFailsafeExtent) == 0x000150, "Member 'UDBDNavModifierComponent::ForceUseFailsafeExtent' has a wrong offset!");
static_assert(offsetof(UDBDNavModifierComponent, UpdateModifierInterval) == 0x000154, "Member 'UDBDNavModifierComponent::UpdateModifierInterval' has a wrong offset!");
static_assert(offsetof(UDBDNavModifierComponent, StartNavigationRelevant) == 0x000158, "Member 'UDBDNavModifierComponent::StartNavigationRelevant' has a wrong offset!");
static_assert(offsetof(UDBDNavModifierComponent, AlwaysTickToCheckTransform) == 0x000159, "Member 'UDBDNavModifierComponent::AlwaysTickToCheckTransform' has a wrong offset!");
static_assert(offsetof(UDBDNavModifierComponent, RelevantPassiveMode) == 0x00015A, "Member 'UDBDNavModifierComponent::RelevantPassiveMode' has a wrong offset!");

// Class DeadByDaylight.CoreCursor
// 0x0008 (0x02A0 - 0x0298)
class UCoreCursor : public UUserWidget
{
public:
	class UScaleBox*                              CursorScaleBox;                                    // 0x0298(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreCursor">();
	}
	static class UCoreCursor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreCursor>();
	}
};
static_assert(alignof(UCoreCursor) == 0x000008, "Wrong alignment on UCoreCursor");
static_assert(sizeof(UCoreCursor) == 0x0002A0, "Wrong size on UCoreCursor");
static_assert(offsetof(UCoreCursor, CursorScaleBox) == 0x000298, "Member 'UCoreCursor::CursorScaleBox' has a wrong offset!");

// Class DeadByDaylight.CoreHudRootWidget
// 0x00D8 (0x0370 - 0x0298)
class UCoreHudRootWidget final : public UUserWidget
{
public:
	class UOverlay*                               WidgetContainer;                                   // 0x0298(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               OuterContainer;                                    // 0x02A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               SpectateContainer;                                 // 0x02A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScaleBox*                              ScaleHud;                                          // 0x02B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnfocusedOpacity;                                  // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            Test4kDpiScalingCurve;                             // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                Test4kDpiCurveClass;                               // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            Test4kDpiCurveWidget;                              // 0x02D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                EquippedItemWidgetClass;                           // 0x02D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                EquippedPowerWidgetClass;                          // 0x02E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                ExternalEffectsWidgetClass;                        // 0x02E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                HudAlertWidgetClass;                               // 0x02F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                InteractionProgressWidgetClass;                    // 0x02F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                InteractionPromptsContainerWidgetClass;            // 0x0300(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                ItemInteractionWidgetClass;                        // 0x0308(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                MatchResultWidgetClass;                            // 0x0310(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                OfferingInteractionWidgetClass;                    // 0x0318(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                PerksContainerWidgetClass;                         // 0x0320(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                PingStatusWidgetClass;                             // 0x0328(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                PlayerStatusesWidgetClass;                         // 0x0330(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                ScreenIndicatorWidgetClass;                        // 0x0338(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                StartSequenceWidgetClass;                          // 0x0340(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                StatusEffectWidgetClass;                           // 0x0348(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TScriptInterface<class ICoreBaseViewInterface>> _coreBaseViewInterfaces;                  // 0x0350(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              HUDWidgetsFadeOutCompletedDelegate;                // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPrivate)

public:
	void ApplyConstrainedAspectRatio(bool isConstrained, float aspectRatio);
	void FadeInWidgets();
	void FadeOutWidgets();
	void SetWidgetsVisibility(bool visible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreHudRootWidget">();
	}
	static class UCoreHudRootWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreHudRootWidget>();
	}
};
static_assert(alignof(UCoreHudRootWidget) == 0x000008, "Wrong alignment on UCoreHudRootWidget");
static_assert(sizeof(UCoreHudRootWidget) == 0x000370, "Wrong size on UCoreHudRootWidget");
static_assert(offsetof(UCoreHudRootWidget, WidgetContainer) == 0x000298, "Member 'UCoreHudRootWidget::WidgetContainer' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, OuterContainer) == 0x0002A0, "Member 'UCoreHudRootWidget::OuterContainer' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, SpectateContainer) == 0x0002A8, "Member 'UCoreHudRootWidget::SpectateContainer' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, ScaleHud) == 0x0002B0, "Member 'UCoreHudRootWidget::ScaleHud' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, UnfocusedOpacity) == 0x0002B8, "Member 'UCoreHudRootWidget::UnfocusedOpacity' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, Test4kDpiScalingCurve) == 0x0002C0, "Member 'UCoreHudRootWidget::Test4kDpiScalingCurve' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, Test4kDpiCurveClass) == 0x0002C8, "Member 'UCoreHudRootWidget::Test4kDpiCurveClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, Test4kDpiCurveWidget) == 0x0002D0, "Member 'UCoreHudRootWidget::Test4kDpiCurveWidget' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, EquippedItemWidgetClass) == 0x0002D8, "Member 'UCoreHudRootWidget::EquippedItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, EquippedPowerWidgetClass) == 0x0002E0, "Member 'UCoreHudRootWidget::EquippedPowerWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, ExternalEffectsWidgetClass) == 0x0002E8, "Member 'UCoreHudRootWidget::ExternalEffectsWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, HudAlertWidgetClass) == 0x0002F0, "Member 'UCoreHudRootWidget::HudAlertWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, InteractionProgressWidgetClass) == 0x0002F8, "Member 'UCoreHudRootWidget::InteractionProgressWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, InteractionPromptsContainerWidgetClass) == 0x000300, "Member 'UCoreHudRootWidget::InteractionPromptsContainerWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, ItemInteractionWidgetClass) == 0x000308, "Member 'UCoreHudRootWidget::ItemInteractionWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, MatchResultWidgetClass) == 0x000310, "Member 'UCoreHudRootWidget::MatchResultWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, OfferingInteractionWidgetClass) == 0x000318, "Member 'UCoreHudRootWidget::OfferingInteractionWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, PerksContainerWidgetClass) == 0x000320, "Member 'UCoreHudRootWidget::PerksContainerWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, PingStatusWidgetClass) == 0x000328, "Member 'UCoreHudRootWidget::PingStatusWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, PlayerStatusesWidgetClass) == 0x000330, "Member 'UCoreHudRootWidget::PlayerStatusesWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, ScreenIndicatorWidgetClass) == 0x000338, "Member 'UCoreHudRootWidget::ScreenIndicatorWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, StartSequenceWidgetClass) == 0x000340, "Member 'UCoreHudRootWidget::StartSequenceWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, StatusEffectWidgetClass) == 0x000348, "Member 'UCoreHudRootWidget::StatusEffectWidgetClass' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, _coreBaseViewInterfaces) == 0x000350, "Member 'UCoreHudRootWidget::_coreBaseViewInterfaces' has a wrong offset!");
static_assert(offsetof(UCoreHudRootWidget, HUDWidgetsFadeOutCompletedDelegate) == 0x000360, "Member 'UCoreHudRootWidget::HUDWidgetsFadeOutCompletedDelegate' has a wrong offset!");

// Class DeadByDaylight.UMGTallyEmblemProgressionWidget
// 0x0070 (0x03A8 - 0x0338)
class UUMGTallyEmblemProgressionWidget final : public UMobileBaseUserWidget
{
public:
	class UImage*                                 PositiveIcon;                                      // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NegativeIcon;                                      // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PercentText;                                       // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DescriptionText;                                   // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            WarningPercentColor;                               // 0x0358(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            WarningDescriptionColor;                           // 0x0380(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyEmblemProgressionWidget">();
	}
	static class UUMGTallyEmblemProgressionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyEmblemProgressionWidget>();
	}
};
static_assert(alignof(UUMGTallyEmblemProgressionWidget) == 0x000008, "Wrong alignment on UUMGTallyEmblemProgressionWidget");
static_assert(sizeof(UUMGTallyEmblemProgressionWidget) == 0x0003A8, "Wrong size on UUMGTallyEmblemProgressionWidget");
static_assert(offsetof(UUMGTallyEmblemProgressionWidget, PositiveIcon) == 0x000338, "Member 'UUMGTallyEmblemProgressionWidget::PositiveIcon' has a wrong offset!");
static_assert(offsetof(UUMGTallyEmblemProgressionWidget, NegativeIcon) == 0x000340, "Member 'UUMGTallyEmblemProgressionWidget::NegativeIcon' has a wrong offset!");
static_assert(offsetof(UUMGTallyEmblemProgressionWidget, PercentText) == 0x000348, "Member 'UUMGTallyEmblemProgressionWidget::PercentText' has a wrong offset!");
static_assert(offsetof(UUMGTallyEmblemProgressionWidget, DescriptionText) == 0x000350, "Member 'UUMGTallyEmblemProgressionWidget::DescriptionText' has a wrong offset!");
static_assert(offsetof(UUMGTallyEmblemProgressionWidget, WarningPercentColor) == 0x000358, "Member 'UUMGTallyEmblemProgressionWidget::WarningPercentColor' has a wrong offset!");
static_assert(offsetof(UUMGTallyEmblemProgressionWidget, WarningDescriptionColor) == 0x000380, "Member 'UUMGTallyEmblemProgressionWidget::WarningDescriptionColor' has a wrong offset!");

// Class DeadByDaylight.DBDMenuPlayer
// 0x00F0 (0x0650 - 0x0560)
class ADBDMenuPlayer final : public ADBDBasePlayer
{
public:
	uint8                                         Pad_560[0x28];                                     // 0x0560(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          RoleSelected;                                      // 0x0588(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOnline;                                          // 0x0589(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58A[0x6];                                      // 0x058A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnItemEquipped;                                    // 0x0590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A0[0x18];                                     // 0x05A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialInterface>      DarkMaterial;                                      // 0x05B8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EItemHandPosition                             _handPosition;                                     // 0x05E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E9[0x7];                                      // 0x05E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 ItemMesh;                                          // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialHelper*                        MaterialHelper;                                    // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomizedSkeletalMesh*                _customizedSkeletalMeshComponent;                  // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _equippedItemName;                                 // 0x0608(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_614[0x28];                                     // 0x0614(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _blockRotationDuringSpawnAnimationDuration;        // 0x063C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isLocalPlayerCharacter;                           // 0x0640(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isReady;                                          // 0x0641(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_642[0xE];                                      // 0x0642(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginCreateSequence();
	void BeginDestroySequence_Internal();
	void BlockCharacterRotation(bool shouldBlock);
	class UCharmSpawnerComponent* GetCharmSpawnerComponent();
	bool IsInMenuPlayer();
	void OnAllPlayersReadyInOnlineLobby();
	void OnCustomizationTransactionCompleted(ECustomizationCategory category);
	void OnGuestPlayerDespawned(class ADBDMenuPlayer* player);
	void OnGuestPlayerReadyChanged(class ADBDMenuPlayer* player, bool isReady);
	void OnGuestPlayerSpawned(class ADBDMenuPlayer* player);
	void OnIsReadyChanged(bool isReady);
	void OnLocalPlayerReadyChanged(bool isReady);
	void OnLocalPlayerSpawned();
	void RestartInSequence_Internal();
	void WrappedOnDestroyed(class AActor* DestroyedActor);

	float GetBlockRotationAfterSpawningTime() const;
	EGameFlowStep GetCurrentMenu() const;
	EItemHandPosition GetHandPosition() const;
	bool GetIsLocalPlayerCharacter() const;
	bool GetIsReady() const;
	bool ShouldApplyPositionOffset() const;
	bool ShouldShowSpawnAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMenuPlayer">();
	}
	static class ADBDMenuPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDMenuPlayer>();
	}
};
static_assert(alignof(ADBDMenuPlayer) == 0x000010, "Wrong alignment on ADBDMenuPlayer");
static_assert(sizeof(ADBDMenuPlayer) == 0x000650, "Wrong size on ADBDMenuPlayer");
static_assert(offsetof(ADBDMenuPlayer, RoleSelected) == 0x000588, "Member 'ADBDMenuPlayer::RoleSelected' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, IsOnline) == 0x000589, "Member 'ADBDMenuPlayer::IsOnline' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, OnItemEquipped) == 0x000590, "Member 'ADBDMenuPlayer::OnItemEquipped' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, DarkMaterial) == 0x0005B8, "Member 'ADBDMenuPlayer::DarkMaterial' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _handPosition) == 0x0005E8, "Member 'ADBDMenuPlayer::_handPosition' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, ItemMesh) == 0x0005F0, "Member 'ADBDMenuPlayer::ItemMesh' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, MaterialHelper) == 0x0005F8, "Member 'ADBDMenuPlayer::MaterialHelper' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _customizedSkeletalMeshComponent) == 0x000600, "Member 'ADBDMenuPlayer::_customizedSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _equippedItemName) == 0x000608, "Member 'ADBDMenuPlayer::_equippedItemName' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _blockRotationDuringSpawnAnimationDuration) == 0x00063C, "Member 'ADBDMenuPlayer::_blockRotationDuringSpawnAnimationDuration' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _isLocalPlayerCharacter) == 0x000640, "Member 'ADBDMenuPlayer::_isLocalPlayerCharacter' has a wrong offset!");
static_assert(offsetof(ADBDMenuPlayer, _isReady) == 0x000641, "Member 'ADBDMenuPlayer::_isReady' has a wrong offset!");

// Class DeadByDaylight.CrossPlatformManager
// 0x0008 (0x0038 - 0x0030)
class UCrossPlatformManager final : public UObject
{
public:
	bool                                          _crossPlayAllowedByPlatform;                       // 0x0030(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _crossPlayAllowedByKraken;                         // 0x0031(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrossPlatformManager">();
	}
	static class UCrossPlatformManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrossPlatformManager>();
	}
};
static_assert(alignof(UCrossPlatformManager) == 0x000008, "Wrong alignment on UCrossPlatformManager");
static_assert(sizeof(UCrossPlatformManager) == 0x000038, "Wrong size on UCrossPlatformManager");
static_assert(offsetof(UCrossPlatformManager, _crossPlayAllowedByPlatform) == 0x000030, "Member 'UCrossPlatformManager::_crossPlayAllowedByPlatform' has a wrong offset!");
static_assert(offsetof(UCrossPlatformManager, _crossPlayAllowedByKraken) == 0x000031, "Member 'UCrossPlatformManager::_crossPlayAllowedByKraken' has a wrong offset!");

// Class DeadByDaylight.DBDLocalPlayer
// 0x0000 (0x0268 - 0x0268)
class UDBDLocalPlayer final : public ULocalPlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDLocalPlayer">();
	}
	static class UDBDLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDLocalPlayer>();
	}
};
static_assert(alignof(UDBDLocalPlayer) == 0x000008, "Wrong alignment on UDBDLocalPlayer");
static_assert(sizeof(UDBDLocalPlayer) == 0x000268, "Wrong size on UDBDLocalPlayer");

// Class DeadByDaylight.DBDNavEvadeLoopComponent
// 0x00A0 (0x0158 - 0x00B8)
class UDBDNavEvadeLoopComponent final : public UActorComponent
{
public:
	struct FVector                                EvadeDoorExtent;                                   // 0x00B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvadeDoorFrontPointOffset;                         // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EvadeDoorSideOffset;                               // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideBlockerOffset;                                 // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSnapPointsUpHeight;                            // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoSnapPointsDownHeight;                          // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             AutoSnapCollisionChannel;                          // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     EvadeLoopFilterClass;                              // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSafetyLength;                                   // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSafetyLength;                                   // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIEvadeLoopSides                             LimitToSide;                                       // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugEditMode;                                     // 0x00F1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawDebugFilter;                                   // 0x00F2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F3[0x65];                                      // 0x00F3(0x0065)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDNavEvadeLoopComponent">();
	}
	static class UDBDNavEvadeLoopComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDNavEvadeLoopComponent>();
	}
};
static_assert(alignof(UDBDNavEvadeLoopComponent) == 0x000008, "Wrong alignment on UDBDNavEvadeLoopComponent");
static_assert(sizeof(UDBDNavEvadeLoopComponent) == 0x000158, "Wrong size on UDBDNavEvadeLoopComponent");
static_assert(offsetof(UDBDNavEvadeLoopComponent, EvadeDoorExtent) == 0x0000B8, "Member 'UDBDNavEvadeLoopComponent::EvadeDoorExtent' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, EvadeDoorFrontPointOffset) == 0x0000C4, "Member 'UDBDNavEvadeLoopComponent::EvadeDoorFrontPointOffset' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, EvadeDoorSideOffset) == 0x0000C8, "Member 'UDBDNavEvadeLoopComponent::EvadeDoorSideOffset' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, SideBlockerOffset) == 0x0000CC, "Member 'UDBDNavEvadeLoopComponent::SideBlockerOffset' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, AutoSnapPointsUpHeight) == 0x0000D0, "Member 'UDBDNavEvadeLoopComponent::AutoSnapPointsUpHeight' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, AutoSnapPointsDownHeight) == 0x0000D4, "Member 'UDBDNavEvadeLoopComponent::AutoSnapPointsDownHeight' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, AutoSnapCollisionChannel) == 0x0000D8, "Member 'UDBDNavEvadeLoopComponent::AutoSnapCollisionChannel' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, EvadeLoopFilterClass) == 0x0000E0, "Member 'UDBDNavEvadeLoopComponent::EvadeLoopFilterClass' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, MinSafetyLength) == 0x0000E8, "Member 'UDBDNavEvadeLoopComponent::MinSafetyLength' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, MaxSafetyLength) == 0x0000EC, "Member 'UDBDNavEvadeLoopComponent::MaxSafetyLength' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, LimitToSide) == 0x0000F0, "Member 'UDBDNavEvadeLoopComponent::LimitToSide' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, DebugEditMode) == 0x0000F1, "Member 'UDBDNavEvadeLoopComponent::DebugEditMode' has a wrong offset!");
static_assert(offsetof(UDBDNavEvadeLoopComponent, DrawDebugFilter) == 0x0000F2, "Member 'UDBDNavEvadeLoopComponent::DrawDebugFilter' has a wrong offset!");

// Class DeadByDaylight.CrowdChoiceTugOfWarPopupScreen
// 0x0000 (0x0140 - 0x0140)
class UCrowdChoiceTugOfWarPopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CrowdChoiceTugOfWarPopupScreen">();
	}
	static class UCrowdChoiceTugOfWarPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCrowdChoiceTugOfWarPopupScreen>();
	}
};
static_assert(alignof(UCrowdChoiceTugOfWarPopupScreen) == 0x000008, "Wrong alignment on UCrowdChoiceTugOfWarPopupScreen");
static_assert(sizeof(UCrowdChoiceTugOfWarPopupScreen) == 0x000140, "Wrong size on UCrowdChoiceTugOfWarPopupScreen");

// Class DeadByDaylight.CurrencyDisplayable
// 0x0060 (0x0290 - 0x0230)
class ACurrencyDisplayable final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<ECurrencyType, class USkeletalMesh*>     _currencyMeshes;                                   // 0x0240(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void BeginDestroySequence_Internal();
	void FinishSpawningCurrency(ECurrencyType currencyType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyDisplayable">();
	}
	static class ACurrencyDisplayable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACurrencyDisplayable>();
	}
};
static_assert(alignof(ACurrencyDisplayable) == 0x000008, "Wrong alignment on ACurrencyDisplayable");
static_assert(sizeof(ACurrencyDisplayable) == 0x000290, "Wrong size on ACurrencyDisplayable");
static_assert(offsetof(ACurrencyDisplayable, SkeletalMeshComponent) == 0x000238, "Member 'ACurrencyDisplayable::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ACurrencyDisplayable, _currencyMeshes) == 0x000240, "Member 'ACurrencyDisplayable::_currencyMeshes' has a wrong offset!");

// Class DeadByDaylight.RoleSelectionScreen
// 0x0048 (0x0168 - 0x0120)
class URoleSelectionScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0x48];                                     // 0x0120(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonSelected(int32 buttonId);
	void OnChangeUserButtonClick();
	void OnEventButtonClick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoleSelectionScreen">();
	}
	static class URoleSelectionScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoleSelectionScreen>();
	}
};
static_assert(alignof(URoleSelectionScreen) == 0x000008, "Wrong alignment on URoleSelectionScreen");
static_assert(sizeof(URoleSelectionScreen) == 0x000168, "Wrong size on URoleSelectionScreen");

// Class DeadByDaylight.DBDOutlineComponentConfiguration
// 0x00B0 (0x00E8 - 0x0038)
class UDBDOutlineComponentConfiguration : public UDataAsset
{
public:
	TMap<TSoftClassPtr<class UClass>, struct FOutlineConfig> OutlineConfigs;                         // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FOutlineColourConfiguration> OutlineColours;                            // 0x0088(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UMaterialInterface>> TranslucencyDefaultMaterials;                   // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOutlineComponentConfiguration">();
	}
	static class UDBDOutlineComponentConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOutlineComponentConfiguration>();
	}
};
static_assert(alignof(UDBDOutlineComponentConfiguration) == 0x000008, "Wrong alignment on UDBDOutlineComponentConfiguration");
static_assert(sizeof(UDBDOutlineComponentConfiguration) == 0x0000E8, "Wrong size on UDBDOutlineComponentConfiguration");
static_assert(offsetof(UDBDOutlineComponentConfiguration, OutlineConfigs) == 0x000038, "Member 'UDBDOutlineComponentConfiguration::OutlineConfigs' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponentConfiguration, OutlineColours) == 0x000088, "Member 'UDBDOutlineComponentConfiguration::OutlineColours' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponentConfiguration, TranslucencyDefaultMaterials) == 0x0000D8, "Member 'UDBDOutlineComponentConfiguration::TranslucencyDefaultMaterials' has a wrong offset!");

// Class DeadByDaylight.DBDOutlineComponentCustomDepthConfiguration
// 0x0000 (0x00E8 - 0x00E8)
class UDBDOutlineComponentCustomDepthConfiguration final : public UDBDOutlineComponentConfiguration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOutlineComponentCustomDepthConfiguration">();
	}
	static class UDBDOutlineComponentCustomDepthConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOutlineComponentCustomDepthConfiguration>();
	}
};
static_assert(alignof(UDBDOutlineComponentCustomDepthConfiguration) == 0x000008, "Wrong alignment on UDBDOutlineComponentCustomDepthConfiguration");
static_assert(sizeof(UDBDOutlineComponentCustomDepthConfiguration) == 0x0000E8, "Wrong size on UDBDOutlineComponentCustomDepthConfiguration");

// Class DeadByDaylight.CurveFloatNetIdSubsystem
// 0x0060 (0x0098 - 0x0038)
class UCurveFloatNetIdSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x60];                                      // 0x0038(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveFloatNetIdSubsystem">();
	}
	static class UCurveFloatNetIdSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveFloatNetIdSubsystem>();
	}
};
static_assert(alignof(UCurveFloatNetIdSubsystem) == 0x000008, "Wrong alignment on UCurveFloatNetIdSubsystem");
static_assert(sizeof(UCurveFloatNetIdSubsystem) == 0x000098, "Wrong size on UCurveFloatNetIdSubsystem");

// Class DeadByDaylight.UMGTallyRankBanner
// 0x0018 (0x0350 - 0x0338)
class UUMGTallyRankBanner final : public UMobileBaseUserWidget
{
public:
	class UUMGTallyPipsContainer*                 PipsContainerWidget;                               // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGRankBanner*                         RankBanner;                                        // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SmokeBackground;                                   // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetAsLocked(bool locked);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyRankBanner">();
	}
	static class UUMGTallyRankBanner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyRankBanner>();
	}
};
static_assert(alignof(UUMGTallyRankBanner) == 0x000008, "Wrong alignment on UUMGTallyRankBanner");
static_assert(sizeof(UUMGTallyRankBanner) == 0x000350, "Wrong size on UUMGTallyRankBanner");
static_assert(offsetof(UUMGTallyRankBanner, PipsContainerWidget) == 0x000338, "Member 'UUMGTallyRankBanner::PipsContainerWidget' has a wrong offset!");
static_assert(offsetof(UUMGTallyRankBanner, RankBanner) == 0x000340, "Member 'UUMGTallyRankBanner::RankBanner' has a wrong offset!");
static_assert(offsetof(UUMGTallyRankBanner, SmokeBackground) == 0x000348, "Member 'UUMGTallyRankBanner::SmokeBackground' has a wrong offset!");

// Class DeadByDaylight.DBDObserverPlayer
// 0x0040 (0x0510 - 0x04D0)
class ADBDObserverPlayer final : public ACharacter
{
public:
	class UDBDPlayerData*                         _playerData;                                       // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0x38];                                     // 0x04D8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_PlayerReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDObserverPlayer">();
	}
	static class ADBDObserverPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDObserverPlayer>();
	}
};
static_assert(alignof(ADBDObserverPlayer) == 0x000010, "Wrong alignment on ADBDObserverPlayer");
static_assert(sizeof(ADBDObserverPlayer) == 0x000510, "Wrong size on ADBDObserverPlayer");
static_assert(offsetof(ADBDObserverPlayer, _playerData) == 0x0004D0, "Member 'ADBDObserverPlayer::_playerData' has a wrong offset!");

// Class DeadByDaylight.CustomizationHelper
// 0x0000 (0x0030 - 0x0030)
class UCustomizationHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationHelper">();
	}
	static class UCustomizationHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationHelper>();
	}
};
static_assert(alignof(UCustomizationHelper) == 0x000008, "Wrong alignment on UCustomizationHelper");
static_assert(sizeof(UCustomizationHelper) == 0x000030, "Wrong size on UCustomizationHelper");

// Class DeadByDaylight.ProceduralGenerationData
// 0x0138 (0x0170 - 0x0038)
class UProceduralGenerationData final : public UDataAsset
{
public:
	TArray<struct FQuadrantSpawnTypeProperties>   QuadrantSpawnTypeProperties;                       // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FQuadrantSpawnCategories>       QuadrantSpawnCategories;                           // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FThemeProperties>               ThemeProperties;                                   // 0x0058(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	int32                                         MaxSurvivorCount;                                  // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKillerItemDependencies>        KillersItemDependencies;                           // 0x0070(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SurvivorItemPopulationProbability;                 // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSurvivorItemProperties>        SurvivorItemProperty;                              // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UCurveFloat*                            EscapeStrategyPopulationProbability;               // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEscapeStrategyProperty>        EscapeStrategyProperties;                          // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FEscapeTypeObjects>             EscapeTypeActors;                                  // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           Basements;                                         // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FGameplayElementsPopulation>    ElementsPopulation;                                // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FManagedGameplayElementsPopulation> ManagedElementsPopulation;                     // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FSurvivorGroupingProbability>   SurvivorGroupingProbabilities;                     // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FVector                                ProceduralMapOffset;                               // 0x0100(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralTileWidth;                               // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralTileHeight;                              // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ProceduralQuadTileMapOffset;                       // 0x0114(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralQuadTileCubeWidth;                       // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DifficultyModifier;                                // 0x0124(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterCameraHeight;                             // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterCollisionRadius;                          // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnerCollisionRadius;                            // 0x0130(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotemVisualHeight;                                 // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSpecialBehaviourPopulation>    SpecialBehaviourPopulation;                        // 0x0138(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	TArray<struct FEventSubstitionData>           _eventProperties;                                  // 0x0148(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x18];                                     // 0x0158(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralGenerationData">();
	}
	static class UProceduralGenerationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralGenerationData>();
	}
};
static_assert(alignof(UProceduralGenerationData) == 0x000008, "Wrong alignment on UProceduralGenerationData");
static_assert(sizeof(UProceduralGenerationData) == 0x000170, "Wrong size on UProceduralGenerationData");
static_assert(offsetof(UProceduralGenerationData, QuadrantSpawnTypeProperties) == 0x000038, "Member 'UProceduralGenerationData::QuadrantSpawnTypeProperties' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, QuadrantSpawnCategories) == 0x000048, "Member 'UProceduralGenerationData::QuadrantSpawnCategories' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ThemeProperties) == 0x000058, "Member 'UProceduralGenerationData::ThemeProperties' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, MaxSurvivorCount) == 0x000068, "Member 'UProceduralGenerationData::MaxSurvivorCount' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, KillersItemDependencies) == 0x000070, "Member 'UProceduralGenerationData::KillersItemDependencies' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, SurvivorItemPopulationProbability) == 0x000080, "Member 'UProceduralGenerationData::SurvivorItemPopulationProbability' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, SurvivorItemProperty) == 0x000088, "Member 'UProceduralGenerationData::SurvivorItemProperty' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, EscapeStrategyPopulationProbability) == 0x000098, "Member 'UProceduralGenerationData::EscapeStrategyPopulationProbability' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, EscapeStrategyProperties) == 0x0000A0, "Member 'UProceduralGenerationData::EscapeStrategyProperties' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, EscapeTypeActors) == 0x0000B0, "Member 'UProceduralGenerationData::EscapeTypeActors' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, Basements) == 0x0000C0, "Member 'UProceduralGenerationData::Basements' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ElementsPopulation) == 0x0000D0, "Member 'UProceduralGenerationData::ElementsPopulation' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ManagedElementsPopulation) == 0x0000E0, "Member 'UProceduralGenerationData::ManagedElementsPopulation' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, SurvivorGroupingProbabilities) == 0x0000F0, "Member 'UProceduralGenerationData::SurvivorGroupingProbabilities' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ProceduralMapOffset) == 0x000100, "Member 'UProceduralGenerationData::ProceduralMapOffset' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ProceduralTileWidth) == 0x00010C, "Member 'UProceduralGenerationData::ProceduralTileWidth' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ProceduralTileHeight) == 0x000110, "Member 'UProceduralGenerationData::ProceduralTileHeight' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ProceduralQuadTileMapOffset) == 0x000114, "Member 'UProceduralGenerationData::ProceduralQuadTileMapOffset' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, ProceduralQuadTileCubeWidth) == 0x000120, "Member 'UProceduralGenerationData::ProceduralQuadTileCubeWidth' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, DifficultyModifier) == 0x000124, "Member 'UProceduralGenerationData::DifficultyModifier' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, CharacterCameraHeight) == 0x000128, "Member 'UProceduralGenerationData::CharacterCameraHeight' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, CharacterCollisionRadius) == 0x00012C, "Member 'UProceduralGenerationData::CharacterCollisionRadius' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, SpawnerCollisionRadius) == 0x000130, "Member 'UProceduralGenerationData::SpawnerCollisionRadius' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, TotemVisualHeight) == 0x000134, "Member 'UProceduralGenerationData::TotemVisualHeight' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, SpecialBehaviourPopulation) == 0x000138, "Member 'UProceduralGenerationData::SpecialBehaviourPopulation' has a wrong offset!");
static_assert(offsetof(UProceduralGenerationData, _eventProperties) == 0x000148, "Member 'UProceduralGenerationData::_eventProperties' has a wrong offset!");

// Class DeadByDaylight.CustomizationPresetController
// 0x0000 (0x0030 - 0x0030)
class UCustomizationPresetController final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationPresetController">();
	}
	static class UCustomizationPresetController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationPresetController>();
	}
};
static_assert(alignof(UCustomizationPresetController) == 0x000008, "Wrong alignment on UCustomizationPresetController");
static_assert(sizeof(UCustomizationPresetController) == 0x000030, "Wrong size on UCustomizationPresetController");

// Class DeadByDaylight.DBDMistLocatorComponent
// 0x0000 (0x0220 - 0x0220)
class UDBDMistLocatorComponent final : public UDBDLocatorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMistLocatorComponent">();
	}
	static class UDBDMistLocatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDMistLocatorComponent>();
	}
};
static_assert(alignof(UDBDMistLocatorComponent) == 0x000010, "Wrong alignment on UDBDMistLocatorComponent");
static_assert(sizeof(UDBDMistLocatorComponent) == 0x000220, "Wrong size on UDBDMistLocatorComponent");

// Class DeadByDaylight.CustomizedAnimationComponent
// 0x0020 (0x00D8 - 0x00B8)
class UCustomizedAnimationComponent final : public UActorComponent
{
public:
	class ADBDBasePlayer*                         _owner;                                            // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomizedSkeletalMesh*                _customizedSkeletalMesh;                           // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UAnimInstance>              _defaultAnimClass;                                 // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCustomizationChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizedAnimationComponent">();
	}
	static class UCustomizedAnimationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizedAnimationComponent>();
	}
};
static_assert(alignof(UCustomizedAnimationComponent) == 0x000008, "Wrong alignment on UCustomizedAnimationComponent");
static_assert(sizeof(UCustomizedAnimationComponent) == 0x0000D8, "Wrong size on UCustomizedAnimationComponent");
static_assert(offsetof(UCustomizedAnimationComponent, _owner) == 0x0000B8, "Member 'UCustomizedAnimationComponent::_owner' has a wrong offset!");
static_assert(offsetof(UCustomizedAnimationComponent, _customizedSkeletalMesh) == 0x0000C0, "Member 'UCustomizedAnimationComponent::_customizedSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UCustomizedAnimationComponent, _defaultAnimClass) == 0x0000C8, "Member 'UCustomizedAnimationComponent::_defaultAnimClass' has a wrong offset!");

// Class DeadByDaylight.DBDOutlineComponent
// 0x00D0 (0x0380 - 0x02B0)
class UDBDOutlineComponent final : public UBatchMeshCommands
{
public:
	float                                         InterpolationSpeed;                                // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldBeAboveOutlines;                             // 0x02AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ForceOutlineFarAway;                               // 0x02AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LimitToCustomDepthObjects;                         // 0x02AE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FadeOutAsClosingIn;                                // 0x02AF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAlwaysVisible;                                   // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumOutlineDistance;                            // 0x02B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutlineName;                                       // 0x02B8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C8[0x58];                                     // 0x02C8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDOutlineRenderStrategySelector      _renderStrategySelector;                           // 0x0320(0x0040)(Transient, NativeAccessSpecifierPrivate)
	class UBatchMeshCommands*                     _batchMeshCommands;                                // 0x0360(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x10];                                     // 0x0368(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBaseOutlineRenderStrategy*             _renderingStrategy;                                // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitBatcher();
	void OnLevelReadyToPlay();
	void RefreshOutlineComponent();
	void ResetToTransparent();
	void SetFadeIntensity(float fadeIntensity);
	void SetFadeTexture(class UTexture* inFadeTexture);
	void SetIsOccludingOutlines(const bool isOccluding);
	void SetMaterialCopyTarget(class UMaterialInterface* inMaterialToCopy);
	void SetMinimumOutlineDistance(float distance);
	void SetOutlineIntensity(float outlineIntensity);
	void SetTargetColor(const struct FLinearColor& color);

	const struct FLinearColor GetTargetColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOutlineComponent">();
	}
	static class UDBDOutlineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOutlineComponent>();
	}
};
static_assert(alignof(UDBDOutlineComponent) == 0x000010, "Wrong alignment on UDBDOutlineComponent");
static_assert(sizeof(UDBDOutlineComponent) == 0x000380, "Wrong size on UDBDOutlineComponent");
static_assert(offsetof(UDBDOutlineComponent, InterpolationSpeed) == 0x0002A8, "Member 'UDBDOutlineComponent::InterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, ShouldBeAboveOutlines) == 0x0002AC, "Member 'UDBDOutlineComponent::ShouldBeAboveOutlines' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, ForceOutlineFarAway) == 0x0002AD, "Member 'UDBDOutlineComponent::ForceOutlineFarAway' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, LimitToCustomDepthObjects) == 0x0002AE, "Member 'UDBDOutlineComponent::LimitToCustomDepthObjects' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, FadeOutAsClosingIn) == 0x0002AF, "Member 'UDBDOutlineComponent::FadeOutAsClosingIn' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, IsAlwaysVisible) == 0x0002B0, "Member 'UDBDOutlineComponent::IsAlwaysVisible' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, MinimumOutlineDistance) == 0x0002B4, "Member 'UDBDOutlineComponent::MinimumOutlineDistance' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, OutlineName) == 0x0002B8, "Member 'UDBDOutlineComponent::OutlineName' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, _renderStrategySelector) == 0x000320, "Member 'UDBDOutlineComponent::_renderStrategySelector' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, _batchMeshCommands) == 0x000360, "Member 'UDBDOutlineComponent::_batchMeshCommands' has a wrong offset!");
static_assert(offsetof(UDBDOutlineComponent, _renderingStrategy) == 0x000378, "Member 'UDBDOutlineComponent::_renderingStrategy' has a wrong offset!");

// Class DeadByDaylight.CustomizedSkeletalMesh
// 0x0378 (0x0430 - 0x00B8)
class UCustomizedSkeletalMesh : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(ECustomizationCategory category, class USkeletalMeshComponent* mesh)> OnMeshSwitchBP; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnCustomizationReady;                              // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F0[0x30];                                      // 0x00F0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USkinnedMeshComponent*                  _meshOwner;                                        // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<ECustomizationCategory>                  _ignoredItemCategories;                            // 0x0130(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         _cosmeticPiecesMesh;                               // 0x0180(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<ECustomizationCategory, class USkeletalMeshComponent*> _cosmeticPiecesMeshPerCategory;      // 0x0190(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         _slaves;                                           // 0x01E0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<ECustomizationCategory, class AItemVfx*> _itemVfxs;                                         // 0x01F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0xA0];                                     // 0x0240(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _characterIdOverride;                              // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E4[0x5C];                                     // 0x02E4(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECustomizationCategory, struct FCosmeticPieceMeshLoadingData> _cosmeticPieceMeshesBeingLoaded; // 0x0340(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0xA0];                                     // 0x0390(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearAllVfxs();
	void CopyCustomization(const class UCustomizedSkeletalMesh* copyFrom);
	class USkinnedMeshComponent* GetMeshOwner();
	void SetAllAccessoriesVisibility(bool visible);
	void SetAllVfxsVisibility(bool visible);
	void SetCastShadow(bool castShadow);
	void SetMeshOwner(class USkinnedMeshComponent* mesh);
	void SetMeshVisibility(bool visible);
	void SetVfxsVisibility(ECustomizationCategory category, bool visible);

	bool Contains(const TArray<class FName>& itemIds) const;
	const TArray<class USkeletalMeshComponent*> GetComponents() const;
	TArray<class FName> GetCurrentCustomizationItems() const;
	class USkeletalMeshComponent* GetSkeletalMesh(ECustomizationCategory category) const;
	bool HasValidCustomization() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizedSkeletalMesh">();
	}
	static class UCustomizedSkeletalMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizedSkeletalMesh>();
	}
};
static_assert(alignof(UCustomizedSkeletalMesh) == 0x000008, "Wrong alignment on UCustomizedSkeletalMesh");
static_assert(sizeof(UCustomizedSkeletalMesh) == 0x000430, "Wrong size on UCustomizedSkeletalMesh");
static_assert(offsetof(UCustomizedSkeletalMesh, OnMeshSwitchBP) == 0x0000B8, "Member 'UCustomizedSkeletalMesh::OnMeshSwitchBP' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, OnCustomizationReady) == 0x0000E0, "Member 'UCustomizedSkeletalMesh::OnCustomizationReady' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _meshOwner) == 0x000120, "Member 'UCustomizedSkeletalMesh::_meshOwner' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _ignoredItemCategories) == 0x000130, "Member 'UCustomizedSkeletalMesh::_ignoredItemCategories' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _cosmeticPiecesMesh) == 0x000180, "Member 'UCustomizedSkeletalMesh::_cosmeticPiecesMesh' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _cosmeticPiecesMeshPerCategory) == 0x000190, "Member 'UCustomizedSkeletalMesh::_cosmeticPiecesMeshPerCategory' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _slaves) == 0x0001E0, "Member 'UCustomizedSkeletalMesh::_slaves' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _itemVfxs) == 0x0001F0, "Member 'UCustomizedSkeletalMesh::_itemVfxs' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _characterIdOverride) == 0x0002E0, "Member 'UCustomizedSkeletalMesh::_characterIdOverride' has a wrong offset!");
static_assert(offsetof(UCustomizedSkeletalMesh, _cosmeticPieceMeshesBeingLoaded) == 0x000340, "Member 'UCustomizedSkeletalMesh::_cosmeticPieceMeshesBeingLoaded' has a wrong offset!");

// Class DeadByDaylight.CustomWidgetWrapperInitializer
// 0x0010 (0x02A8 - 0x0298)
class UCustomWidgetWrapperInitializer final : public UUserWidget
{
public:
	class UCustomWidgetWrapper*                   ListeningWrapper;                                  // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomWidgetWrapperInitializer">();
	}
	static class UCustomWidgetWrapperInitializer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomWidgetWrapperInitializer>();
	}
};
static_assert(alignof(UCustomWidgetWrapperInitializer) == 0x000008, "Wrong alignment on UCustomWidgetWrapperInitializer");
static_assert(sizeof(UCustomWidgetWrapperInitializer) == 0x0002A8, "Wrong size on UCustomWidgetWrapperInitializer");
static_assert(offsetof(UCustomWidgetWrapperInitializer, ListeningWrapper) == 0x000298, "Member 'UCustomWidgetWrapperInitializer::ListeningWrapper' has a wrong offset!");

// Class DeadByDaylight.ScreenController
// 0x02B0 (0x02E0 - 0x0030)
class UScreenController final : public UObject
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGFxObject*                             _screenControllerObj;                              // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGFxMoviePlayer*                        _moviePlayer;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, class UScreenBase*>       _screenDictionary;                                 // 0x0048(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FString, EScreenType>              _screenTypeDictionary;                             // 0x0098(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<class UClass*, TWeakObjectPtr<class UUserWidget>> _cachedUMGScreens;                        // 0x00E8(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_138[0x1A8];                                    // 0x0138(0x01A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenController">();
	}
	static class UScreenController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenController>();
	}
};
static_assert(alignof(UScreenController) == 0x000008, "Wrong alignment on UScreenController");
static_assert(sizeof(UScreenController) == 0x0002E0, "Wrong size on UScreenController");
static_assert(offsetof(UScreenController, _gameInstance) == 0x000030, "Member 'UScreenController::_gameInstance' has a wrong offset!");
static_assert(offsetof(UScreenController, _screenControllerObj) == 0x000038, "Member 'UScreenController::_screenControllerObj' has a wrong offset!");
static_assert(offsetof(UScreenController, _moviePlayer) == 0x000040, "Member 'UScreenController::_moviePlayer' has a wrong offset!");
static_assert(offsetof(UScreenController, _screenDictionary) == 0x000048, "Member 'UScreenController::_screenDictionary' has a wrong offset!");
static_assert(offsetof(UScreenController, _screenTypeDictionary) == 0x000098, "Member 'UScreenController::_screenTypeDictionary' has a wrong offset!");
static_assert(offsetof(UScreenController, _cachedUMGScreens) == 0x0000E8, "Member 'UScreenController::_cachedUMGScreens' has a wrong offset!");

// Class DeadByDaylight.CustomWidgetWrapper
// 0x0050 (0x01A8 - 0x0158)
class UCustomWidgetWrapper : public UCanvasPanel
{
public:
	TMulticastInlineDelegate<void(int32 version)> OnVersion;                                         // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Id;                                                // 0x0168(0x000C)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomWidgetWrapper*                   ManuallyParentWrapper;                             // 0x0178(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCustomWidgetWrapper*>           ManuallyChildWrappers;                             // 0x0180(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UCustomWidgetWrapperInitializer*        InitializerWidget;                                 // 0x0190(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_198[0x10];                                     // 0x0198(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyOpacity(float opacity);
	void ApplyScale(float scale);
	void ApplyVersion(int32 version);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomWidgetWrapper">();
	}
	static class UCustomWidgetWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomWidgetWrapper>();
	}
};
static_assert(alignof(UCustomWidgetWrapper) == 0x000008, "Wrong alignment on UCustomWidgetWrapper");
static_assert(sizeof(UCustomWidgetWrapper) == 0x0001A8, "Wrong size on UCustomWidgetWrapper");
static_assert(offsetof(UCustomWidgetWrapper, OnVersion) == 0x000158, "Member 'UCustomWidgetWrapper::OnVersion' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper, Id) == 0x000168, "Member 'UCustomWidgetWrapper::Id' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper, ManuallyParentWrapper) == 0x000178, "Member 'UCustomWidgetWrapper::ManuallyParentWrapper' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper, ManuallyChildWrappers) == 0x000180, "Member 'UCustomWidgetWrapper::ManuallyChildWrappers' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper, InitializerWidget) == 0x000190, "Member 'UCustomWidgetWrapper::InitializerWidget' has a wrong offset!");

// Class DeadByDaylight.DBDOutlineComponentTranslucentConfiguration
// 0x0000 (0x00E8 - 0x00E8)
class UDBDOutlineComponentTranslucentConfiguration final : public UDBDOutlineComponentConfiguration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOutlineComponentTranslucentConfiguration">();
	}
	static class UDBDOutlineComponentTranslucentConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOutlineComponentTranslucentConfiguration>();
	}
};
static_assert(alignof(UDBDOutlineComponentTranslucentConfiguration) == 0x000008, "Wrong alignment on UDBDOutlineComponentTranslucentConfiguration");
static_assert(sizeof(UDBDOutlineComponentTranslucentConfiguration) == 0x0000E8, "Wrong size on UDBDOutlineComponentTranslucentConfiguration");

// Class DeadByDaylight.CustomWidgetWrapper_HudEditor
// 0x00C8 (0x0270 - 0x01A8)
class UCustomWidgetWrapper_HudEditor final : public UCustomWidgetWrapper
{
public:
	float                                         MinOpacity;                                        // 0x01A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxOpacity;                                        // 0x01AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScale;                                          // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScale;                                          // 0x01B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NbVersions;                                        // 0x01B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HideUnderOpacity;                                  // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 HiddenStatusTintColor;                             // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HiddenStatusOpacity;                               // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverlapAboveSizeRatio;                             // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  IgnoreOverlapIds;                                  // 0x01D0(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FHudEditorDragFromParentAxisLimit      ParentDragLimitX;                                  // 0x01F0(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FHudEditorDragFromParentAxisLimit      ParentDragLimitY;                                  // 0x0204(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsEditingHudByInput;                               // 0x0218(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x3];                                      // 0x0219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 OverlapStatusTintColor;                            // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_220[0x50];                                     // 0x0220(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToTranslation(const struct FVector2D& translation);
	void ApplyScaleWithOverlappingWrappers(float scale, class UWidget* widget, const TArray<class UCustomWidgetWrapper_HudEditor*>& allEditableWrappers, bool needDetectOverlapping);
	void ClampToViewport();
	void FlipPositionWithChildLinkWidget();
	void FlipScreenPosition();

	bool CanEditOpacity() const;
	bool CanEditScale() const;
	float GetOpacity() const;
	float GetScale() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomWidgetWrapper_HudEditor">();
	}
	static class UCustomWidgetWrapper_HudEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomWidgetWrapper_HudEditor>();
	}
};
static_assert(alignof(UCustomWidgetWrapper_HudEditor) == 0x000008, "Wrong alignment on UCustomWidgetWrapper_HudEditor");
static_assert(sizeof(UCustomWidgetWrapper_HudEditor) == 0x000270, "Wrong size on UCustomWidgetWrapper_HudEditor");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, MinOpacity) == 0x0001A8, "Member 'UCustomWidgetWrapper_HudEditor::MinOpacity' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, MaxOpacity) == 0x0001AC, "Member 'UCustomWidgetWrapper_HudEditor::MaxOpacity' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, MinScale) == 0x0001B0, "Member 'UCustomWidgetWrapper_HudEditor::MinScale' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, MaxScale) == 0x0001B4, "Member 'UCustomWidgetWrapper_HudEditor::MaxScale' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, NbVersions) == 0x0001B8, "Member 'UCustomWidgetWrapper_HudEditor::NbVersions' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, HideUnderOpacity) == 0x0001BC, "Member 'UCustomWidgetWrapper_HudEditor::HideUnderOpacity' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, HiddenStatusTintColor) == 0x0001C0, "Member 'UCustomWidgetWrapper_HudEditor::HiddenStatusTintColor' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, HiddenStatusOpacity) == 0x0001C4, "Member 'UCustomWidgetWrapper_HudEditor::HiddenStatusOpacity' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, OverlapAboveSizeRatio) == 0x0001C8, "Member 'UCustomWidgetWrapper_HudEditor::OverlapAboveSizeRatio' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, IgnoreOverlapIds) == 0x0001D0, "Member 'UCustomWidgetWrapper_HudEditor::IgnoreOverlapIds' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, ParentDragLimitX) == 0x0001F0, "Member 'UCustomWidgetWrapper_HudEditor::ParentDragLimitX' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, ParentDragLimitY) == 0x000204, "Member 'UCustomWidgetWrapper_HudEditor::ParentDragLimitY' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, IsEditingHudByInput) == 0x000218, "Member 'UCustomWidgetWrapper_HudEditor::IsEditingHudByInput' has a wrong offset!");
static_assert(offsetof(UCustomWidgetWrapper_HudEditor, OverlapStatusTintColor) == 0x00021C, "Member 'UCustomWidgetWrapper_HudEditor::OverlapStatusTintColor' has a wrong offset!");

// Class DeadByDaylight.SlasherStateMachine
// 0x0000 (0x0130 - 0x0130)
class USlasherStateMachine final : public UPlayerStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherStateMachine">();
	}
	static class USlasherStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherStateMachine>();
	}
};
static_assert(alignof(USlasherStateMachine) == 0x000010, "Wrong alignment on USlasherStateMachine");
static_assert(sizeof(USlasherStateMachine) == 0x000130, "Wrong size on USlasherStateMachine");

// Class DeadByDaylight.CustomWidgetWrapper_InGame
// 0x0028 (0x01D0 - 0x01A8)
class UCustomWidgetWrapper_InGame final : public UCustomWidgetWrapper
{
public:
	int32                                         VirtualJoystickIndex;                              // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x24];                                     // 0x01AC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomWidgetWrapper_InGame">();
	}
	static class UCustomWidgetWrapper_InGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomWidgetWrapper_InGame>();
	}
};
static_assert(alignof(UCustomWidgetWrapper_InGame) == 0x000008, "Wrong alignment on UCustomWidgetWrapper_InGame");
static_assert(sizeof(UCustomWidgetWrapper_InGame) == 0x0001D0, "Wrong size on UCustomWidgetWrapper_InGame");
static_assert(offsetof(UCustomWidgetWrapper_InGame, VirtualJoystickIndex) == 0x0001A8, "Member 'UCustomWidgetWrapper_InGame::VirtualJoystickIndex' has a wrong offset!");

// Class DeadByDaylight.DailyRewardUtilities
// 0x0000 (0x0030 - 0x0030)
class UDailyRewardUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DailyRewardUtilities">();
	}
	static class UDailyRewardUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDailyRewardUtilities>();
	}
};
static_assert(alignof(UDailyRewardUtilities) == 0x000008, "Wrong alignment on UDailyRewardUtilities");
static_assert(sizeof(UDailyRewardUtilities) == 0x000030, "Wrong size on UDailyRewardUtilities");

// Class DeadByDaylight.DBD_CrossDissolver
// 0x0030 (0x00E8 - 0x00B8)
class UDBD_CrossDissolver final : public UActorComponent
{
public:
	TArray<class UMaterialInterface*>             NewMaterials;                                      // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         BaseSkeletalMesh;                                  // 0x00C8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class USkeletalMeshComponent*>         ClonedSkeletalMeshes;                              // 0x00D8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void KillClone();
	void MakeClone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBD_CrossDissolver">();
	}
	static class UDBD_CrossDissolver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBD_CrossDissolver>();
	}
};
static_assert(alignof(UDBD_CrossDissolver) == 0x000008, "Wrong alignment on UDBD_CrossDissolver");
static_assert(sizeof(UDBD_CrossDissolver) == 0x0000E8, "Wrong size on UDBD_CrossDissolver");
static_assert(offsetof(UDBD_CrossDissolver, NewMaterials) == 0x0000B8, "Member 'UDBD_CrossDissolver::NewMaterials' has a wrong offset!");
static_assert(offsetof(UDBD_CrossDissolver, BaseSkeletalMesh) == 0x0000C8, "Member 'UDBD_CrossDissolver::BaseSkeletalMesh' has a wrong offset!");
static_assert(offsetof(UDBD_CrossDissolver, ClonedSkeletalMeshes) == 0x0000D8, "Member 'UDBD_CrossDissolver::ClonedSkeletalMeshes' has a wrong offset!");

// Class DeadByDaylight.DBD_SoundEventSpawner
// 0x0038 (0x0268 - 0x0230)
class ADBD_SoundEventSpawner final : public AActor
{
public:
	TArray<struct FDBD_SoundSpawnerData>          AtlantaSoundDescriptor;                            // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDBD_SoundSpawnerData>          SoundDescriptor;                                   // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             _loadedSoundAssets;                                // 0x0258(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	void AssetsLoaded();
	void OnLoudNoiseTriggered(class AActor* originator, class AActor* instigatingActor, const struct FVector& location, bool shouldTrack, float* audibleRange, bool isQuickAction, bool isDeceivingNoise);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBD_SoundEventSpawner">();
	}
	static class ADBD_SoundEventSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBD_SoundEventSpawner>();
	}
};
static_assert(alignof(ADBD_SoundEventSpawner) == 0x000008, "Wrong alignment on ADBD_SoundEventSpawner");
static_assert(sizeof(ADBD_SoundEventSpawner) == 0x000268, "Wrong size on ADBD_SoundEventSpawner");
static_assert(offsetof(ADBD_SoundEventSpawner, AtlantaSoundDescriptor) == 0x000230, "Member 'ADBD_SoundEventSpawner::AtlantaSoundDescriptor' has a wrong offset!");
static_assert(offsetof(ADBD_SoundEventSpawner, SoundDescriptor) == 0x000240, "Member 'ADBD_SoundEventSpawner::SoundDescriptor' has a wrong offset!");
static_assert(offsetof(ADBD_SoundEventSpawner, _loadedSoundAssets) == 0x000258, "Member 'ADBD_SoundEventSpawner::_loadedSoundAssets' has a wrong offset!");

// Class DeadByDaylight.MenuAssetLibrary
// 0x0010 (0x0130 - 0x0120)
class UMenuAssetLibrary final : public UItemsAssetLibrary
{
public:
	uint8                                         Pad_120[0x10];                                     // 0x0120(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuAssetLibrary">();
	}
	static class UMenuAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuAssetLibrary>();
	}
};
static_assert(alignof(UMenuAssetLibrary) == 0x000008, "Wrong alignment on UMenuAssetLibrary");
static_assert(sizeof(UMenuAssetLibrary) == 0x000130, "Wrong size on UMenuAssetLibrary");

// Class DeadByDaylight.LoudNoiseUtilities
// 0x0000 (0x0030 - 0x0030)
class ULoudNoiseUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudNoiseUtilities">();
	}
	static class ULoudNoiseUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoudNoiseUtilities>();
	}
};
static_assert(alignof(ULoudNoiseUtilities) == 0x000008, "Wrong alignment on ULoudNoiseUtilities");
static_assert(sizeof(ULoudNoiseUtilities) == 0x000030, "Wrong size on ULoudNoiseUtilities");

// Class DeadByDaylight.DBDAggregateParticleManager
// 0x0000 (0x0230 - 0x0230)
class ADBDAggregateParticleManager final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAggregateParticleManager">();
	}
	static class ADBDAggregateParticleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDAggregateParticleManager>();
	}
};
static_assert(alignof(ADBDAggregateParticleManager) == 0x000008, "Wrong alignment on ADBDAggregateParticleManager");
static_assert(sizeof(ADBDAggregateParticleManager) == 0x000230, "Wrong size on ADBDAggregateParticleManager");

// Class DeadByDaylight.DBDAITypes
// 0x01C8 (0x01F8 - 0x0030)
class UDBDAITypes final : public UObject
{
public:
	struct FGameplayTag                           AISkills_Context_Service_Root;                     // 0x0030(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Task_Slasher_AttackTarget;        // 0x003C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_AttackTarget;     // 0x0048(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Task_Slasher_CrawlingTarget;      // 0x0054(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_CrawlingTarget;   // 0x0060(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Investigate_NotInChase; // 0x006C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Investigate_InChase; // 0x0078(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Investigate_MoveAround; // 0x0084(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Patrol;           // 0x0090(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Slasher_Patrol_MoveAround; // 0x009C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Standing;          // 0x00A8(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Crawling;          // 0x00B4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Flee_Run_InChase;  // 0x00C0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Flee_Run_NotInChase; // 0x00CC(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Patrol;            // 0x00D8(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_RescueCarriedFriend; // 0x00E4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_RemoveTrap;        // 0x00F0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Chained;           // 0x00FC(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_HelpOther;         // 0x0108(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_GoalInTerror;      // 0x0114(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Carried;           // 0x0120(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_UseSelfItem;       // 0x012C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_InLocker;          // 0x0138(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_Flee_InLocker;     // 0x0144(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AISkills_Context_Service_Camper_RepairGenerator;   // 0x0150(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AIBlackboard_InteractableWishList_FindSkill;       // 0x015C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PointOfInterest_ActivatedDoor;                  // 0x0168(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PointOfInterest_ActivatedDoor_Opened;           // 0x0174(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PointOfInterest_BrokenGenerator;                // 0x0180(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PointOfInterest_OccupiedMeatHook;               // 0x018C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PointOfInterest_HexTotem;                       // 0x0198(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinLocation_WarpStart;                          // 0x01A4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinLocation_WarpEnd;                            // 0x01B0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinLocation_EQS;                                // 0x01BC(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinLocation_WishedObj;                          // 0x01C8(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinLocation_GoTo;                               // 0x01D4(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinObject_EQS;                                  // 0x01E0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AI_PinObject_WishedObj;                            // 0x01EC(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAITypes">();
	}
	static class UDBDAITypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAITypes>();
	}
};
static_assert(alignof(UDBDAITypes) == 0x000008, "Wrong alignment on UDBDAITypes");
static_assert(sizeof(UDBDAITypes) == 0x0001F8, "Wrong size on UDBDAITypes");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Root) == 0x000030, "Member 'UDBDAITypes::AISkills_Context_Service_Root' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Task_Slasher_AttackTarget) == 0x00003C, "Member 'UDBDAITypes::AISkills_Context_Task_Slasher_AttackTarget' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_AttackTarget) == 0x000048, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_AttackTarget' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Task_Slasher_CrawlingTarget) == 0x000054, "Member 'UDBDAITypes::AISkills_Context_Task_Slasher_CrawlingTarget' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_CrawlingTarget) == 0x000060, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_CrawlingTarget' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Investigate_NotInChase) == 0x00006C, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Investigate_NotInChase' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Investigate_InChase) == 0x000078, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Investigate_InChase' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Investigate_MoveAround) == 0x000084, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Investigate_MoveAround' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Patrol) == 0x000090, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Patrol' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Slasher_Patrol_MoveAround) == 0x00009C, "Member 'UDBDAITypes::AISkills_Context_Service_Slasher_Patrol_MoveAround' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Standing) == 0x0000A8, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Standing' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Crawling) == 0x0000B4, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Crawling' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Flee_Run_InChase) == 0x0000C0, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Flee_Run_InChase' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Flee_Run_NotInChase) == 0x0000CC, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Flee_Run_NotInChase' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Patrol) == 0x0000D8, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Patrol' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_RescueCarriedFriend) == 0x0000E4, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_RescueCarriedFriend' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_RemoveTrap) == 0x0000F0, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_RemoveTrap' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Chained) == 0x0000FC, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Chained' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_HelpOther) == 0x000108, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_HelpOther' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_GoalInTerror) == 0x000114, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_GoalInTerror' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Carried) == 0x000120, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Carried' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_UseSelfItem) == 0x00012C, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_UseSelfItem' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_InLocker) == 0x000138, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_InLocker' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_Flee_InLocker) == 0x000144, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_Flee_InLocker' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AISkills_Context_Service_Camper_RepairGenerator) == 0x000150, "Member 'UDBDAITypes::AISkills_Context_Service_Camper_RepairGenerator' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AIBlackboard_InteractableWishList_FindSkill) == 0x00015C, "Member 'UDBDAITypes::AIBlackboard_InteractableWishList_FindSkill' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PointOfInterest_ActivatedDoor) == 0x000168, "Member 'UDBDAITypes::AI_PointOfInterest_ActivatedDoor' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PointOfInterest_ActivatedDoor_Opened) == 0x000174, "Member 'UDBDAITypes::AI_PointOfInterest_ActivatedDoor_Opened' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PointOfInterest_BrokenGenerator) == 0x000180, "Member 'UDBDAITypes::AI_PointOfInterest_BrokenGenerator' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PointOfInterest_OccupiedMeatHook) == 0x00018C, "Member 'UDBDAITypes::AI_PointOfInterest_OccupiedMeatHook' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PointOfInterest_HexTotem) == 0x000198, "Member 'UDBDAITypes::AI_PointOfInterest_HexTotem' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinLocation_WarpStart) == 0x0001A4, "Member 'UDBDAITypes::AI_PinLocation_WarpStart' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinLocation_WarpEnd) == 0x0001B0, "Member 'UDBDAITypes::AI_PinLocation_WarpEnd' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinLocation_EQS) == 0x0001BC, "Member 'UDBDAITypes::AI_PinLocation_EQS' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinLocation_WishedObj) == 0x0001C8, "Member 'UDBDAITypes::AI_PinLocation_WishedObj' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinLocation_GoTo) == 0x0001D4, "Member 'UDBDAITypes::AI_PinLocation_GoTo' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinObject_EQS) == 0x0001E0, "Member 'UDBDAITypes::AI_PinObject_EQS' has a wrong offset!");
static_assert(offsetof(UDBDAITypes, AI_PinObject_WishedObj) == 0x0001EC, "Member 'UDBDAITypes::AI_PinObject_WishedObj' has a wrong offset!");

// Class DeadByDaylight.MoriComponent
// 0x0038 (0x00F0 - 0x00B8)
class UMoriComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UInteractionDefinition>> _moriInteractionClasses;                       // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoriChargeCompleted();
	void OnMoriFinished();
	void OnMoriUpdateStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoriComponent">();
	}
	static class UMoriComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoriComponent>();
	}
};
static_assert(alignof(UMoriComponent) == 0x000008, "Wrong alignment on UMoriComponent");
static_assert(sizeof(UMoriComponent) == 0x0000F0, "Wrong size on UMoriComponent");
static_assert(offsetof(UMoriComponent, _moriInteractionClasses) == 0x0000D0, "Member 'UMoriComponent::_moriInteractionClasses' has a wrong offset!");

// Class DeadByDaylight.DBDAssetManager
// 0x0018 (0x0498 - 0x0480)
class UDBDAssetManager final : public UAssetManager
{
public:
	uint8                                         Pad_480[0x18];                                     // 0x0480(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAssetManager">();
	}
	static class UDBDAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAssetManager>();
	}
};
static_assert(alignof(UDBDAssetManager) == 0x000008, "Wrong alignment on UDBDAssetManager");
static_assert(sizeof(UDBDAssetManager) == 0x000498, "Wrong size on UDBDAssetManager");

// Class DeadByDaylight.OutlineReveal
// 0x0098 (0x00C8 - 0x0030)
class UOutlineReveal final : public UObject
{
public:
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _affectedCharacters;                               // 0x0090(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x28];                                      // 0x00A0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutlineReveal">();
	}
	static class UOutlineReveal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutlineReveal>();
	}
};
static_assert(alignof(UOutlineReveal) == 0x000008, "Wrong alignment on UOutlineReveal");
static_assert(sizeof(UOutlineReveal) == 0x0000C8, "Wrong size on UOutlineReveal");
static_assert(offsetof(UOutlineReveal, _affectedCharacters) == 0x000090, "Member 'UOutlineReveal::_affectedCharacters' has a wrong offset!");

// Class DeadByDaylight.AtlantaRitualEvaluatorFullLoadout
// 0x0000 (0x0030 - 0x0030)
class UAtlantaRitualEvaluatorFullLoadout final : public UAtlantaRitualEvaluatorBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AtlantaRitualEvaluatorFullLoadout">();
	}
	static class UAtlantaRitualEvaluatorFullLoadout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAtlantaRitualEvaluatorFullLoadout>();
	}
};
static_assert(alignof(UAtlantaRitualEvaluatorFullLoadout) == 0x000008, "Wrong alignment on UAtlantaRitualEvaluatorFullLoadout");
static_assert(sizeof(UAtlantaRitualEvaluatorFullLoadout) == 0x000030, "Wrong size on UAtlantaRitualEvaluatorFullLoadout");

// Class DeadByDaylight.LightFollower
// 0x0030 (0x00E8 - 0x00B8)
class ULightFollower final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddFollower(class ULightComponent* follower);
	void SetLeader(class ULightComponent* leader, float maxIntensity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightFollower">();
	}
	static class ULightFollower* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightFollower>();
	}
};
static_assert(alignof(ULightFollower) == 0x000008, "Wrong alignment on ULightFollower");
static_assert(sizeof(ULightFollower) == 0x0000E8, "Wrong size on ULightFollower");

// Class DeadByDaylight.DBDAttackerComponent
// 0x0108 (0x01C0 - 0x00B8)
class UDBDAttackerComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const EAttackType attackType)> OnAttackStartDelegate;              // 0x00B8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const EAttackType attackType)> OnAttackFinishDelegate;             // 0x00C8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x38];                                      // 0x00D8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _autonomousHitPredictionDelay;                     // 0x0110(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UDBDAttack*>                     _attacks;                                          // 0x0138(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x10];                                     // 0x0148(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDAttack*                             _requestedAttack;                                  // 0x0158(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAttack*                             _currentAttack;                                    // 0x0160(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x48];                                     // 0x0168(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAttackDelegatePair>            _attackHitDelegates;                               // 0x01B0(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Local_RequestAttack(const EAttackType attackType);
	void Multicast_StoreAttack(const EAttackType attackType);
	void Server_StoreAttack(const EAttackType attackType);

	bool IsAnyAttackTransitionRequested() const;
	bool IsAttacking() const;
	bool IsAttackTransitionRequested(const EAttackType attackType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAttackerComponent">();
	}
	static class UDBDAttackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAttackerComponent>();
	}
};
static_assert(alignof(UDBDAttackerComponent) == 0x000008, "Wrong alignment on UDBDAttackerComponent");
static_assert(sizeof(UDBDAttackerComponent) == 0x0001C0, "Wrong size on UDBDAttackerComponent");
static_assert(offsetof(UDBDAttackerComponent, OnAttackStartDelegate) == 0x0000B8, "Member 'UDBDAttackerComponent::OnAttackStartDelegate' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, OnAttackFinishDelegate) == 0x0000C8, "Member 'UDBDAttackerComponent::OnAttackFinishDelegate' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, _autonomousHitPredictionDelay) == 0x000110, "Member 'UDBDAttackerComponent::_autonomousHitPredictionDelay' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, _attacks) == 0x000138, "Member 'UDBDAttackerComponent::_attacks' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, _requestedAttack) == 0x000158, "Member 'UDBDAttackerComponent::_requestedAttack' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, _currentAttack) == 0x000160, "Member 'UDBDAttackerComponent::_currentAttack' has a wrong offset!");
static_assert(offsetof(UDBDAttackerComponent, _attackHitDelegates) == 0x0001B0, "Member 'UDBDAttackerComponent::_attackHitDelegates' has a wrong offset!");

// Class DeadByDaylight.ParticleSystemDistanceFaderComponent
// 0x0020 (0x00D8 - 0x00B8)
class UParticleSystemDistanceFaderComponent final : public UActorComponent
{
public:
	class UParticleSystemComponent*               ParticleSystemComponent;                           // 0x00B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OpacityParameterName;                              // 0x00C0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartFadeDistance;                                 // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndFadeDistance;                                   // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleSystemDistanceFaderComponent">();
	}
	static class UParticleSystemDistanceFaderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleSystemDistanceFaderComponent>();
	}
};
static_assert(alignof(UParticleSystemDistanceFaderComponent) == 0x000008, "Wrong alignment on UParticleSystemDistanceFaderComponent");
static_assert(sizeof(UParticleSystemDistanceFaderComponent) == 0x0000D8, "Wrong size on UParticleSystemDistanceFaderComponent");
static_assert(offsetof(UParticleSystemDistanceFaderComponent, ParticleSystemComponent) == 0x0000B8, "Member 'UParticleSystemDistanceFaderComponent::ParticleSystemComponent' has a wrong offset!");
static_assert(offsetof(UParticleSystemDistanceFaderComponent, OpacityParameterName) == 0x0000C0, "Member 'UParticleSystemDistanceFaderComponent::OpacityParameterName' has a wrong offset!");
static_assert(offsetof(UParticleSystemDistanceFaderComponent, StartFadeDistance) == 0x0000CC, "Member 'UParticleSystemDistanceFaderComponent::StartFadeDistance' has a wrong offset!");
static_assert(offsetof(UParticleSystemDistanceFaderComponent, EndFadeDistance) == 0x0000D0, "Member 'UParticleSystemDistanceFaderComponent::EndFadeDistance' has a wrong offset!");

// Class DeadByDaylight.DBDAuthentication
// 0x0028 (0x0058 - 0x0030)
class UDBDAuthentication final : public UObject
{
public:
	TArray<struct FAuthenticationInfo>            _localInfos;                                       // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FAuthenticationInfo>            _remoteInfos;                                      // 0x0040(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDAuthentication">();
	}
	static class UDBDAuthentication* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDAuthentication>();
	}
};
static_assert(alignof(UDBDAuthentication) == 0x000008, "Wrong alignment on UDBDAuthentication");
static_assert(sizeof(UDBDAuthentication) == 0x000058, "Wrong size on UDBDAuthentication");
static_assert(offsetof(UDBDAuthentication, _localInfos) == 0x000030, "Member 'UDBDAuthentication::_localInfos' has a wrong offset!");
static_assert(offsetof(UDBDAuthentication, _remoteInfos) == 0x000040, "Member 'UDBDAuthentication::_remoteInfos' has a wrong offset!");
static_assert(offsetof(UDBDAuthentication, _gameInstance) == 0x000050, "Member 'UDBDAuthentication::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.DBDBaseHud
// 0x0010 (0x0330 - 0x0320)
class ADBDBaseHud : public AHUD
{
public:
	class UFont*                                  _debugFont;                                        // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_ShowAnimHud(bool show);
	void ShowAnimHudBP();

	bool ShouldDrawAnimHud() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBaseHud">();
	}
	static class ADBDBaseHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDBaseHud>();
	}
};
static_assert(alignof(ADBDBaseHud) == 0x000008, "Wrong alignment on ADBDBaseHud");
static_assert(sizeof(ADBDBaseHud) == 0x000330, "Wrong size on ADBDBaseHud");
static_assert(offsetof(ADBDBaseHud, _debugFont) == 0x000320, "Member 'ADBDBaseHud::_debugFont' has a wrong offset!");

// Class DeadByDaylight.LoadingScreen
// 0x0018 (0x0138 - 0x0120)
class ULoadingScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLoadingTextTimerComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingScreen">();
	}
	static class ULoadingScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingScreen>();
	}
};
static_assert(alignof(ULoadingScreen) == 0x000008, "Wrong alignment on ULoadingScreen");
static_assert(sizeof(ULoadingScreen) == 0x000138, "Wrong size on ULoadingScreen");

// Class DeadByDaylight.HISMMaterialHelperSettings
// 0x0050 (0x0088 - 0x0038)
class UHISMMaterialHelperSettings final : public UDataAsset
{
public:
	TMap<class UStaticMesh*, TSoftClassPtr<class UClass>> _meshMaterialOverride;                     // 0x0038(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HISMMaterialHelperSettings">();
	}
	static class UHISMMaterialHelperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHISMMaterialHelperSettings>();
	}
};
static_assert(alignof(UHISMMaterialHelperSettings) == 0x000008, "Wrong alignment on UHISMMaterialHelperSettings");
static_assert(sizeof(UHISMMaterialHelperSettings) == 0x000088, "Wrong size on UHISMMaterialHelperSettings");
static_assert(offsetof(UHISMMaterialHelperSettings, _meshMaterialOverride) == 0x000038, "Member 'UHISMMaterialHelperSettings::_meshMaterialOverride' has a wrong offset!");

// Class DeadByDaylight.PerkManagerOwnerInterface
// 0x0000 (0x0000 - 0x0000)
class IPerkManagerOwnerInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkManagerOwnerInterface">();
	}
	static class IPerkManagerOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPerkManagerOwnerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPerkManagerOwnerInterface) == 0x000001, "Wrong alignment on IPerkManagerOwnerInterface");
static_assert(sizeof(IPerkManagerOwnerInterface) == 0x000001, "Wrong size on IPerkManagerOwnerInterface");

// Class DeadByDaylight.DBDBloodWebDefinition
// 0x0110 (0x0140 - 0x0030)
class UDBDBloodWebDefinition final : public UObject
{
public:
	uint8                                         Pad_30[0x110];                                     // 0x0030(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBloodWebDefinition">();
	}
	static class UDBDBloodWebDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBloodWebDefinition>();
	}
};
static_assert(alignof(UDBDBloodWebDefinition) == 0x000008, "Wrong alignment on UDBDBloodWebDefinition");
static_assert(sizeof(UDBDBloodWebDefinition) == 0x000140, "Wrong size on UDBDBloodWebDefinition");

// Class DeadByDaylight.DBDBotsUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDBotsUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDBotsUtilities">();
	}
	static class UDBDBotsUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDBotsUtilities>();
	}
};
static_assert(alignof(UDBDBotsUtilities) == 0x000008, "Wrong alignment on UDBDBotsUtilities");
static_assert(sizeof(UDBDBotsUtilities) == 0x000030, "Wrong size on UDBDBotsUtilities");

// Class DeadByDaylight.DBDCamperData
// 0x0048 (0x0190 - 0x0148)
class UDBDCamperData final : public UDBDPlayerData
{
public:
	uint8                                         Pad_148[0x48];                                     // 0x0148(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCamperData">();
	}
	static class UDBDCamperData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCamperData>();
	}
};
static_assert(alignof(UDBDCamperData) == 0x000008, "Wrong alignment on UDBDCamperData");
static_assert(sizeof(UDBDCamperData) == 0x000190, "Wrong size on UDBDCamperData");

// Class DeadByDaylight.InteractionProficiency
// 0x0018 (0x0048 - 0x0030)
class UInteractionProficiency : public UObject
{
public:
	TArray<class FString>                         InteractionIDs;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsActive(const class UChargeableInteractionDefinition* chargeableInteraction, const class ADBDPlayer* player) const;
	int32 GetLevel(const class UChargeableInteractionDefinition* chargeableInteraction, const class ADBDPlayer* player) const;
	EStatusEffectType GetType(const float value) const;
	float GetValue(const class UChargeableInteractionDefinition* chargeableInteraction, const class ADBDPlayer* player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionProficiency">();
	}
	static class UInteractionProficiency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionProficiency>();
	}
};
static_assert(alignof(UInteractionProficiency) == 0x000008, "Wrong alignment on UInteractionProficiency");
static_assert(sizeof(UInteractionProficiency) == 0x000048, "Wrong size on UInteractionProficiency");
static_assert(offsetof(UInteractionProficiency, InteractionIDs) == 0x000030, "Member 'UInteractionProficiency::InteractionIDs' has a wrong offset!");

// Class DeadByDaylight.DBDCharacterUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDCharacterUtilities final : public UBlueprintFunctionLibrary
{
public:
	static EPlayerRole GetLocallyObservedPlayerRole(const class UObject* worldContextObject);
	static bool IsAceVisconti(const class ADBDBasePlayer* targetPlayer);
	static bool IsAdamFrancis(const class ADBDBasePlayer* targetPlayer);
	static bool IsAshleyWilliams(const class ADBDBasePlayer* targetPlayer);
	static bool IsClaudetteMorel(const class ADBDBasePlayer* targetPlayer);
	static bool IsDavidKing(const class ADBDBasePlayer* targetPlayer);
	static bool IsDavidTapp(const class ADBDBasePlayer* targetPlayer);
	static bool IsDwightFairfield(const class ADBDBasePlayer* targetPlayer);
	static bool IsFengMin(const class ADBDBasePlayer* targetPlayer);
	static bool IsInDreamworld(const class ADBDPlayer* player);
	static bool IsJakePark(const class ADBDBasePlayer* targetPlayer);
	static bool IsJaneRomero(const class ADBDBasePlayer* targetPlayer);
	static bool IsJeffJohansen(const class ADBDBasePlayer* targetPlayer);
	static bool IsKateDenson(const class ADBDBasePlayer* targetPlayer);
	static bool IsLaurieStrode(const class ADBDBasePlayer* targetPlayer);
	static bool IsMegThomas(const class ADBDBasePlayer* targetPlayer);
	static bool IsNancyWheeler(const class ADBDBasePlayer* targetPlayer);
	static bool IsNeaKarlsson(const class ADBDBasePlayer* targetPlayer);
	static bool IsPlague(const class ADBDBasePlayer* targetPlayer);
	static bool IsQuentinSmith(const class ADBDBasePlayer* targetPlayer);
	static bool IsSlasherLocallyObserved(const class UObject* worldContextObject);
	static bool IsSteveHarrington(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheBlight(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheCannibal(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheClown(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheDemogorgon(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheDoctor(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheExecutioner(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheGhost(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheHag(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheHillBilly(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheHuntress(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheLegion(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheNightmare(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheNurse(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheOni(const class ADBDBasePlayer* targetPlayer);
	static bool IsThePig(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheShape(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheSpirit(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheTrapper(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheTrickster(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheTwins(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheTwins_Brother(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheTwins_Sister(const class ADBDBasePlayer* targetPlayer);
	static bool IsTheWraith(const class ADBDBasePlayer* targetPlayer);
	static bool IsWilliamBillOverbeck(const class ADBDBasePlayer* targetPlayer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDCharacterUtilities">();
	}
	static class UDBDCharacterUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDCharacterUtilities>();
	}
};
static_assert(alignof(UDBDCharacterUtilities) == 0x000008, "Wrong alignment on UDBDCharacterUtilities");
static_assert(sizeof(UDBDCharacterUtilities) == 0x000030, "Wrong size on UDBDCharacterUtilities");

// Class DeadByDaylight.UIScreenshotTool
// 0x0000 (0x0380 - 0x0380)
class AUIScreenshotTool final : public ACharacterTool
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIScreenshotTool">();
	}
	static class AUIScreenshotTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<AUIScreenshotTool>();
	}
};
static_assert(alignof(AUIScreenshotTool) == 0x000008, "Wrong alignment on AUIScreenshotTool");
static_assert(sizeof(AUIScreenshotTool) == 0x000380, "Wrong size on AUIScreenshotTool");

// Class DeadByDaylight.NatAudioCustomMesh
// 0x0010 (0x0560 - 0x0550)
class UNatAudioCustomMesh final : public UAudioCustomMeshComponent
{
public:
	class UAkAudioEvent*                          _onBeginOverlapAudioEvent;                         // 0x0548(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _onEndOverlapAudioEvent;                           // 0x0550(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlapAudioMesh(class UPrimitiveComponent* overlappedComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult);
	void OnEndOverlapAudioMesh(class UPrimitiveComponent* overlappedComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NatAudioCustomMesh">();
	}
	static class UNatAudioCustomMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNatAudioCustomMesh>();
	}
};
static_assert(alignof(UNatAudioCustomMesh) == 0x000010, "Wrong alignment on UNatAudioCustomMesh");
static_assert(sizeof(UNatAudioCustomMesh) == 0x000560, "Wrong size on UNatAudioCustomMesh");
static_assert(offsetof(UNatAudioCustomMesh, _onBeginOverlapAudioEvent) == 0x000548, "Member 'UNatAudioCustomMesh::_onBeginOverlapAudioEvent' has a wrong offset!");
static_assert(offsetof(UNatAudioCustomMesh, _onEndOverlapAudioEvent) == 0x000550, "Member 'UNatAudioCustomMesh::_onEndOverlapAudioEvent' has a wrong offset!");

// Class DeadByDaylight.DBDClientSyncer
// 0x01F8 (0x0428 - 0x0230)
class ADBDClientSyncer final : public AActor
{
public:
	TArray<struct FSpawnInfo>                     _actorsToSpawnLocally;                             // 0x0230(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FSpawnInfo>                     _currentQueue;                                     // 0x0240(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x8];                                      // 0x0250(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPaperTileMap*                          _tileMap;                                          // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x1C8];                                    // 0x0260(0x01C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_SyncActorToSpawnLocally(const TArray<struct FSpawnInfo>& spawnInfos, int32 startIndex);
	void Multicast_SyncFinalLocallySpawnCount(int32 numLocal);
	void Multicast_SyncSeed(int32 seed, class UPaperTileMap* tileMap, int32 generationPlayerCount, const class FString& premadeMap);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDClientSyncer">();
	}
	static class ADBDClientSyncer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDClientSyncer>();
	}
};
static_assert(alignof(ADBDClientSyncer) == 0x000008, "Wrong alignment on ADBDClientSyncer");
static_assert(sizeof(ADBDClientSyncer) == 0x000428, "Wrong size on ADBDClientSyncer");
static_assert(offsetof(ADBDClientSyncer, _actorsToSpawnLocally) == 0x000230, "Member 'ADBDClientSyncer::_actorsToSpawnLocally' has a wrong offset!");
static_assert(offsetof(ADBDClientSyncer, _currentQueue) == 0x000240, "Member 'ADBDClientSyncer::_currentQueue' has a wrong offset!");
static_assert(offsetof(ADBDClientSyncer, _tileMap) == 0x000258, "Member 'ADBDClientSyncer::_tileMap' has a wrong offset!");

// Class DeadByDaylight.ColorBlindFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UColorBlindFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void CallOnColorBlindSettingsChange(class AActor* callingActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ColorBlindFunctionLibrary">();
	}
	static class UColorBlindFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UColorBlindFunctionLibrary>();
	}
};
static_assert(alignof(UColorBlindFunctionLibrary) == 0x000008, "Wrong alignment on UColorBlindFunctionLibrary");
static_assert(sizeof(UColorBlindFunctionLibrary) == 0x000030, "Wrong size on UColorBlindFunctionLibrary");

// Class DeadByDaylight.DBDConsoleCommandUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDConsoleCommandUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDConsoleCommandUtilities">();
	}
	static class UDBDConsoleCommandUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDConsoleCommandUtilities>();
	}
};
static_assert(alignof(UDBDConsoleCommandUtilities) == 0x000008, "Wrong alignment on UDBDConsoleCommandUtilities");
static_assert(sizeof(UDBDConsoleCommandUtilities) == 0x000030, "Wrong size on UDBDConsoleCommandUtilities");

// Class DeadByDaylight.StruggleSkillCheck
// 0x0000 (0x0000 - 0x0000)
class IStruggleSkillCheck final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StruggleSkillCheck">();
	}
	static class IStruggleSkillCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStruggleSkillCheck>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStruggleSkillCheck) == 0x000001, "Wrong alignment on IStruggleSkillCheck");
static_assert(sizeof(IStruggleSkillCheck) == 0x000001, "Wrong size on IStruggleSkillCheck");

// Class DeadByDaylight.LightingHelper
// 0x00C0 (0x00F0 - 0x0030)
class ULightingHelper final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSky*                               _levelLighting;                                    // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABaseSky*                               _levelLightingFixed;                               // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABaseSky*                               _levelLightingSpawned;                             // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABaseSky*                               _levelLightingWithoutExposure;                     // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 _adaptiveShadowMapControllersActor;                // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULightingInterpolator*                  _lightingInterpolator;                             // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULightingFactory*                       _lightingFactory;                                  // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPostProcessComponent*                  _postProcessCache;                                 // 0x0080(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _bIsDreamworldActive;                              // 0x0088(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x67];                                      // 0x0089(0x0067)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_ModifyExposure(float value);
	class UActorComponent* GetInitialComponentState(class FName componentName);
	class UClass* GetSourceLevelLightingClass();
	class UTextureCube* GetTextureCube(class FName mapTheme);
	void ToggleDreamworldLighting(bool bActivateDreamworld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingHelper">();
	}
	static class ULightingHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingHelper>();
	}
};
static_assert(alignof(ULightingHelper) == 0x000008, "Wrong alignment on ULightingHelper");
static_assert(sizeof(ULightingHelper) == 0x0000F0, "Wrong size on ULightingHelper");
static_assert(offsetof(ULightingHelper, _levelLighting) == 0x000048, "Member 'ULightingHelper::_levelLighting' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _levelLightingFixed) == 0x000050, "Member 'ULightingHelper::_levelLightingFixed' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _levelLightingSpawned) == 0x000058, "Member 'ULightingHelper::_levelLightingSpawned' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _levelLightingWithoutExposure) == 0x000060, "Member 'ULightingHelper::_levelLightingWithoutExposure' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _adaptiveShadowMapControllersActor) == 0x000068, "Member 'ULightingHelper::_adaptiveShadowMapControllersActor' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _lightingInterpolator) == 0x000070, "Member 'ULightingHelper::_lightingInterpolator' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _lightingFactory) == 0x000078, "Member 'ULightingHelper::_lightingFactory' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _postProcessCache) == 0x000080, "Member 'ULightingHelper::_postProcessCache' has a wrong offset!");
static_assert(offsetof(ULightingHelper, _bIsDreamworldActive) == 0x000088, "Member 'ULightingHelper::_bIsDreamworldActive' has a wrong offset!");

// Class DeadByDaylight.RitualEvaluatorBase
// 0x0000 (0x0030 - 0x0030)
class URitualEvaluatorBase final : public UObject
{
public:
	bool EvaluateEvent(const struct FRitualEvent& ritualEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RitualEvaluatorBase">();
	}
	static class URitualEvaluatorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<URitualEvaluatorBase>();
	}
};
static_assert(alignof(URitualEvaluatorBase) == 0x000008, "Wrong alignment on URitualEvaluatorBase");
static_assert(sizeof(URitualEvaluatorBase) == 0x000030, "Wrong size on URitualEvaluatorBase");

// Class DeadByDaylight.DBDDateTimeProvider
// 0x0000 (0x0030 - 0x0030)
class UDBDDateTimeProvider final : public UDateTimeProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDateTimeProvider">();
	}
	static class UDBDDateTimeProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDateTimeProvider>();
	}
};
static_assert(alignof(UDBDDateTimeProvider) == 0x000008, "Wrong alignment on UDBDDateTimeProvider");
static_assert(sizeof(UDBDDateTimeProvider) == 0x000030, "Wrong size on UDBDDateTimeProvider");

// Class DeadByDaylight.ManualIconStrategy
// 0x0008 (0x0040 - 0x0038)
class UManualIconStrategy final : public UBasePerkIconStrategy
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ManualIconStrategy">();
	}
	static class UManualIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UManualIconStrategy>();
	}
};
static_assert(alignof(UManualIconStrategy) == 0x000008, "Wrong alignment on UManualIconStrategy");
static_assert(sizeof(UManualIconStrategy) == 0x000040, "Wrong size on UManualIconStrategy");

// Class DeadByDaylight.LoadoutSlotFloatingWidget
// 0x0008 (0x0378 - 0x0370)
class ULoadoutSlotFloatingWidget final : public UBaseTooltipWidget
{
public:
	class UTextBlock*                             Message;                                           // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutSlotFloatingWidget">();
	}
	static class ULoadoutSlotFloatingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutSlotFloatingWidget>();
	}
};
static_assert(alignof(ULoadoutSlotFloatingWidget) == 0x000008, "Wrong alignment on ULoadoutSlotFloatingWidget");
static_assert(sizeof(ULoadoutSlotFloatingWidget) == 0x000378, "Wrong size on ULoadoutSlotFloatingWidget");
static_assert(offsetof(ULoadoutSlotFloatingWidget, Message) == 0x000370, "Member 'ULoadoutSlotFloatingWidget::Message' has a wrong offset!");

// Class DeadByDaylight.DBDDebugInputComponent
// 0x0020 (0x00D8 - 0x00B8)
class UDBDDebugInputComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_ItsAlive(bool aliveEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDebugInputComponent">();
	}
	static class UDBDDebugInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDebugInputComponent>();
	}
};
static_assert(alignof(UDBDDebugInputComponent) == 0x000008, "Wrong alignment on UDBDDebugInputComponent");
static_assert(sizeof(UDBDDebugInputComponent) == 0x0000D8, "Wrong size on UDBDDebugInputComponent");

// Class DeadByDaylight.DBDDecalComponent
// 0x00C0 (0x0320 - 0x0260)
class UDBDDecalComponent final : public UDecalComponent
{
public:
	TArray<class UStaticMeshComponent*>           staticMeshDecals;                                  // 0x0258(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class UStaticMeshComponent*, class UGlassStaticMesh*> staticMeshGlass;                      // 0x0268(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       materialInstances;                                 // 0x02B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x48];                                     // 0x02C8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalCollection*                       _decalCollection;                                  // 0x0310(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDDecalComponent">();
	}
	static class UDBDDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDDecalComponent>();
	}
};
static_assert(alignof(UDBDDecalComponent) == 0x000010, "Wrong alignment on UDBDDecalComponent");
static_assert(sizeof(UDBDDecalComponent) == 0x000320, "Wrong size on UDBDDecalComponent");
static_assert(offsetof(UDBDDecalComponent, staticMeshDecals) == 0x000258, "Member 'UDBDDecalComponent::staticMeshDecals' has a wrong offset!");
static_assert(offsetof(UDBDDecalComponent, staticMeshGlass) == 0x000268, "Member 'UDBDDecalComponent::staticMeshGlass' has a wrong offset!");
static_assert(offsetof(UDBDDecalComponent, materialInstances) == 0x0002B8, "Member 'UDBDDecalComponent::materialInstances' has a wrong offset!");
static_assert(offsetof(UDBDDecalComponent, _decalCollection) == 0x000310, "Member 'UDBDDecalComponent::_decalCollection' has a wrong offset!");

// Class DeadByDaylight.MatchMakingWidgetScreen
// 0x0000 (0x0120 - 0x0120)
class UMatchMakingWidgetScreen final : public UScreenBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchMakingWidgetScreen">();
	}
	static class UMatchMakingWidgetScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchMakingWidgetScreen>();
	}
};
static_assert(alignof(UMatchMakingWidgetScreen) == 0x000008, "Wrong alignment on UMatchMakingWidgetScreen");
static_assert(sizeof(UMatchMakingWidgetScreen) == 0x000120, "Wrong size on UMatchMakingWidgetScreen");

// Class DeadByDaylight.DBDTextDesignTunables
// 0x00D8 (0x0108 - 0x0030)
class UDBDTextDesignTunables : public UObject
{
public:
	class FText                                   LegalTextTitle;                                    // 0x0030(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   LegalText;                                         // 0x0048(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   ConsentTextTitle;                                  // 0x0060(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   ConsentText;                                       // 0x0078(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   LegalTextSIEA;                                     // 0x0090(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   LegalTextSIEE;                                     // 0x00A8(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   SystemMessage_ChatDisconnected;                    // 0x00C0(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   SystemMessage_ChatReturnedToLobby;                 // 0x00D8(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)
	class FText                                   SystemMessage_ChatMatchServerClosed;               // 0x00F0(0x0018)(Edit, BlueprintVisible, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTextDesignTunables">();
	}
	static class UDBDTextDesignTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTextDesignTunables>();
	}
};
static_assert(alignof(UDBDTextDesignTunables) == 0x000008, "Wrong alignment on UDBDTextDesignTunables");
static_assert(sizeof(UDBDTextDesignTunables) == 0x000108, "Wrong size on UDBDTextDesignTunables");
static_assert(offsetof(UDBDTextDesignTunables, LegalTextTitle) == 0x000030, "Member 'UDBDTextDesignTunables::LegalTextTitle' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, LegalText) == 0x000048, "Member 'UDBDTextDesignTunables::LegalText' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, ConsentTextTitle) == 0x000060, "Member 'UDBDTextDesignTunables::ConsentTextTitle' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, ConsentText) == 0x000078, "Member 'UDBDTextDesignTunables::ConsentText' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, LegalTextSIEA) == 0x000090, "Member 'UDBDTextDesignTunables::LegalTextSIEA' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, LegalTextSIEE) == 0x0000A8, "Member 'UDBDTextDesignTunables::LegalTextSIEE' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, SystemMessage_ChatDisconnected) == 0x0000C0, "Member 'UDBDTextDesignTunables::SystemMessage_ChatDisconnected' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, SystemMessage_ChatReturnedToLobby) == 0x0000D8, "Member 'UDBDTextDesignTunables::SystemMessage_ChatReturnedToLobby' has a wrong offset!");
static_assert(offsetof(UDBDTextDesignTunables, SystemMessage_ChatMatchServerClosed) == 0x0000F0, "Member 'UDBDTextDesignTunables::SystemMessage_ChatMatchServerClosed' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaPurchasePopup
// 0x00B0 (0x03E8 - 0x0338)
class UUMGAtlantaPurchasePopup final : public UMobileBaseUserWidget
{
public:
	class UWidgetSwitcher*                        LayoutSwitcher;                                    // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImagePopup;                                        // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             OfferTextWithInfo;                                 // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             OfferText;                                         // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TitleTextWithInfo;                                 // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TitleText;                                         // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DescriptionText;                                   // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         ItemsContainer;                                    // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGPurchaseBuyButton*                  BuyButtonWithInfo;                                 // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGPurchaseBuyButton*                  BuyButton;                                         // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBaseButtonWidget*                   CloseButton;                                       // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGPurchaseSticker*                    PurchaseSticker;                                   // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PurchaseItemsInfoWidgetClass;                      // 0x0398(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x20];                                     // 0x03C8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleBuyButtonClicked();
	void HandleCloseButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaPurchasePopup">();
	}
	static class UUMGAtlantaPurchasePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaPurchasePopup>();
	}
};
static_assert(alignof(UUMGAtlantaPurchasePopup) == 0x000008, "Wrong alignment on UUMGAtlantaPurchasePopup");
static_assert(sizeof(UUMGAtlantaPurchasePopup) == 0x0003E8, "Wrong size on UUMGAtlantaPurchasePopup");
static_assert(offsetof(UUMGAtlantaPurchasePopup, LayoutSwitcher) == 0x000338, "Member 'UUMGAtlantaPurchasePopup::LayoutSwitcher' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPurchasePopup, ImagePopup) == 0x000340, "Member 'UUMGAtlantaPurchasePopup::ImagePopup' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPurchasePopup, OfferTextWithInfo) == 0x000348, "Member 'UUMGAtlantaPurchasePopup::OfferTextWithInfo' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPurchasePopup, OfferText) == 0x000350, "Member 'UUMGAtlantaPurchasePopup::OfferText' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPurchasePopup, TitleTextWithInfo) == 0x000358, "Member 'UUMGAtlantaPurchasePopup::TitleTextWithInfo' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPurchasePopup, TitleText) == 0x000360, "Member 'UUMGAtlantaPurchasePopup::TitleText' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPurchasePopup, DescriptionText) == 0x000368, "Member 'UUMGAtlantaPurchasePopup::DescriptionText' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPurchasePopup, ItemsContainer) == 0x000370, "Member 'UUMGAtlantaPurchasePopup::ItemsContainer' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPurchasePopup, BuyButtonWithInfo) == 0x000378, "Member 'UUMGAtlantaPurchasePopup::BuyButtonWithInfo' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPurchasePopup, BuyButton) == 0x000380, "Member 'UUMGAtlantaPurchasePopup::BuyButton' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPurchasePopup, CloseButton) == 0x000388, "Member 'UUMGAtlantaPurchasePopup::CloseButton' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPurchasePopup, PurchaseSticker) == 0x000390, "Member 'UUMGAtlantaPurchasePopup::PurchaseSticker' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaPurchasePopup, PurchaseItemsInfoWidgetClass) == 0x000398, "Member 'UUMGAtlantaPurchasePopup::PurchaseItemsInfoWidgetClass' has a wrong offset!");

// Class DeadByDaylight.Locker
// 0x0138 (0x0460 - 0x0328)
class ALocker final : public AInteractable
{
public:
	uint8                                         Pad_328[0x18];                                     // 0x0328(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ADBDPlayer* playerWhoWasInLocker, class ADBDPlayer* playerNowInLocker)> OnPlayerInLockerChanged; // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         FastDoorActivationAudibleRange;                    // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalDoorActivationAudibleRange;                  // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          _boxComponent;                                     // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationMontageSlave*                 _montageFollower;                                  // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDPlayer*                             _playerOpeningLocker;                              // 0x0370(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDPlayer*                             _playerInLocker;                                   // 0x0378(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractor*                            _mainInteractor;                                   // 0x0380(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _frontInteractionZone;                             // 0x0388(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionDefinition*                 _searchEmpty;                                      // 0x0390(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionDefinition*                 _searchPlayer;                                     // 0x0398(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   _killerInteractionActor;                           // 0x03A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULockerAnimInstance*                    _lockerAnimInstance;                               // 0x03A8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  _interactionExitClosetSemantics;                   // 0x03B0(0x0020)(Edit, NativeAccessSpecifierPrivate)
	class UGameplayTagContainerComponent*         _lockerObjectState;                                // 0x03D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x40];                                     // 0x03D8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _preventAllInteractions;                           // 0x0418(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _local_preventAllInteractions;                     // 0x0419(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_41A[0x6];                                      // 0x041A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseLockerItem*                        _spawnedLockerItem;                                // 0x0420(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x30];                                     // 0x0428(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0458(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_EnableOtherInteractors(const class UInteractor* usableInteractor, bool usable);
	void Authority_ReportOpenLockerNoiseEventToAI(const bool fastActivation);
	void EjectSurvivor();
	void Multicast_EjectSurvivor();
	void OnRep_PreventAllInteractions();
	void OnSurvivorEndPlay(class AActor* actor, EEndPlayReason endPlayReason);
	void OnSurvivorHealthChanged(ECamperDamageState before, ECamperDamageState after);
	void SetPlayerOpeningLocker(class ADBDPlayer* player);
	void SetSurvivorInLocker(class ACamperPlayer* survivor);
	void StopMinNearOutlineDistLerp(class ADBDPlayer* player);

	class AActor* GetChildInteractionActor() const;
	class UInteractor* GetInteractor() const;
	class UGameplayTagContainerComponent* GetObjectState() const;
	class ADBDPlayer* GetPlayerInLocker() const;
	class UPrimitiveComponent* GetStunZone() const;
	class ACamperPlayer* GetSurvivorInLocker() const;
	bool IsFacingLocker(const class ADBDPlayer* player, float toleranceDegreeAngle) const;
	bool IsOccupied() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Locker">();
	}
	static class ALocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALocker>();
	}
};
static_assert(alignof(ALocker) == 0x000008, "Wrong alignment on ALocker");
static_assert(sizeof(ALocker) == 0x000460, "Wrong size on ALocker");
static_assert(offsetof(ALocker, OnPlayerInLockerChanged) == 0x000340, "Member 'ALocker::OnPlayerInLockerChanged' has a wrong offset!");
static_assert(offsetof(ALocker, FastDoorActivationAudibleRange) == 0x000350, "Member 'ALocker::FastDoorActivationAudibleRange' has a wrong offset!");
static_assert(offsetof(ALocker, NormalDoorActivationAudibleRange) == 0x000354, "Member 'ALocker::NormalDoorActivationAudibleRange' has a wrong offset!");
static_assert(offsetof(ALocker, _boxComponent) == 0x000358, "Member 'ALocker::_boxComponent' has a wrong offset!");
static_assert(offsetof(ALocker, _montageFollower) == 0x000360, "Member 'ALocker::_montageFollower' has a wrong offset!");
static_assert(offsetof(ALocker, _montagePlayer) == 0x000368, "Member 'ALocker::_montagePlayer' has a wrong offset!");
static_assert(offsetof(ALocker, _playerOpeningLocker) == 0x000370, "Member 'ALocker::_playerOpeningLocker' has a wrong offset!");
static_assert(offsetof(ALocker, _playerInLocker) == 0x000378, "Member 'ALocker::_playerInLocker' has a wrong offset!");
static_assert(offsetof(ALocker, _mainInteractor) == 0x000380, "Member 'ALocker::_mainInteractor' has a wrong offset!");
static_assert(offsetof(ALocker, _frontInteractionZone) == 0x000388, "Member 'ALocker::_frontInteractionZone' has a wrong offset!");
static_assert(offsetof(ALocker, _searchEmpty) == 0x000390, "Member 'ALocker::_searchEmpty' has a wrong offset!");
static_assert(offsetof(ALocker, _searchPlayer) == 0x000398, "Member 'ALocker::_searchPlayer' has a wrong offset!");
static_assert(offsetof(ALocker, _killerInteractionActor) == 0x0003A0, "Member 'ALocker::_killerInteractionActor' has a wrong offset!");
static_assert(offsetof(ALocker, _lockerAnimInstance) == 0x0003A8, "Member 'ALocker::_lockerAnimInstance' has a wrong offset!");
static_assert(offsetof(ALocker, _interactionExitClosetSemantics) == 0x0003B0, "Member 'ALocker::_interactionExitClosetSemantics' has a wrong offset!");
static_assert(offsetof(ALocker, _lockerObjectState) == 0x0003D0, "Member 'ALocker::_lockerObjectState' has a wrong offset!");
static_assert(offsetof(ALocker, _preventAllInteractions) == 0x000418, "Member 'ALocker::_preventAllInteractions' has a wrong offset!");
static_assert(offsetof(ALocker, _local_preventAllInteractions) == 0x000419, "Member 'ALocker::_local_preventAllInteractions' has a wrong offset!");
static_assert(offsetof(ALocker, _spawnedLockerItem) == 0x000420, "Member 'ALocker::_spawnedLockerItem' has a wrong offset!");
static_assert(offsetof(ALocker, _perceptionStimuliComponent) == 0x000458, "Member 'ALocker::_perceptionStimuliComponent' has a wrong offset!");

// Class DeadByDaylight.DBDEasyAntiCheatLinux
// 0x0000 (0x00E8 - 0x00E8)
class UDBDEasyAntiCheatLinux final : public UDBDEasyAntiCheatEnable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEasyAntiCheatLinux">();
	}
	static class UDBDEasyAntiCheatLinux* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEasyAntiCheatLinux>();
	}
};
static_assert(alignof(UDBDEasyAntiCheatLinux) == 0x000008, "Wrong alignment on UDBDEasyAntiCheatLinux");
static_assert(sizeof(UDBDEasyAntiCheatLinux) == 0x0000E8, "Wrong size on UDBDEasyAntiCheatLinux");

// Class DeadByDaylight.DBDEngineUtils
// 0x0000 (0x0030 - 0x0030)
class UDBDEngineUtils final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDEngineUtils">();
	}
	static class UDBDEngineUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDEngineUtils>();
	}
};
static_assert(alignof(UDBDEngineUtils) == 0x000008, "Wrong alignment on UDBDEngineUtils");
static_assert(sizeof(UDBDEngineUtils) == 0x000030, "Wrong size on UDBDEngineUtils");

// Class DeadByDaylight.PerkCollectionComponent
// 0x0028 (0x00E0 - 0x00B8)
class UPerkCollectionComponent final : public UActorComponent
{
public:
	TArray<class UPerk*>                          _array;                                            // 0x00B8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Array(const TArray<class UPerk*>& oldArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkCollectionComponent">();
	}
	static class UPerkCollectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkCollectionComponent>();
	}
};
static_assert(alignof(UPerkCollectionComponent) == 0x000008, "Wrong alignment on UPerkCollectionComponent");
static_assert(sizeof(UPerkCollectionComponent) == 0x0000E0, "Wrong size on UPerkCollectionComponent");
static_assert(offsetof(UPerkCollectionComponent, _array) == 0x0000B8, "Member 'UPerkCollectionComponent::_array' has a wrong offset!");

// Class DeadByDaylight.DBDGame_Menu
// 0x0030 (0x0390 - 0x0360)
class ADBDGame_Menu final : public ADBDBaseGameMode
{
public:
	bool                                          StartWithSlasher;                                  // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAtlantaPartyFlowHandler*               _partyFlowHandler;                                 // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ALevelSequenceActor*                    _sequenceFadeActor;                                // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelSequenceActor*                    _sequenceIntroActor;                               // 0x0380(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ALevelSequenceActor*                    _sequenceLoopActor;                                // 0x0388(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGame_Menu">();
	}
	static class ADBDGame_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGame_Menu>();
	}
};
static_assert(alignof(ADBDGame_Menu) == 0x000008, "Wrong alignment on ADBDGame_Menu");
static_assert(sizeof(ADBDGame_Menu) == 0x000390, "Wrong size on ADBDGame_Menu");
static_assert(offsetof(ADBDGame_Menu, StartWithSlasher) == 0x000360, "Member 'ADBDGame_Menu::StartWithSlasher' has a wrong offset!");
static_assert(offsetof(ADBDGame_Menu, _partyFlowHandler) == 0x000368, "Member 'ADBDGame_Menu::_partyFlowHandler' has a wrong offset!");
static_assert(offsetof(ADBDGame_Menu, _sequenceFadeActor) == 0x000378, "Member 'ADBDGame_Menu::_sequenceFadeActor' has a wrong offset!");
static_assert(offsetof(ADBDGame_Menu, _sequenceIntroActor) == 0x000380, "Member 'ADBDGame_Menu::_sequenceIntroActor' has a wrong offset!");
static_assert(offsetof(ADBDGame_Menu, _sequenceLoopActor) == 0x000388, "Member 'ADBDGame_Menu::_sequenceLoopActor' has a wrong offset!");

// Class DeadByDaylight.DBDGameEngine
// 0x0008 (0x0EC0 - 0x0EB8)
class UDBDGameEngine final : public UGameEngine
{
public:
	uint8                                         Pad_EB8[0x8];                                      // 0x0EB8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameEngine">();
	}
	static class UDBDGameEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameEngine>();
	}
};
static_assert(alignof(UDBDGameEngine) == 0x000008, "Wrong alignment on UDBDGameEngine");
static_assert(sizeof(UDBDGameEngine) == 0x000EC0, "Wrong size on UDBDGameEngine");

// Class DeadByDaylight.DBDGameEventUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDGameEventUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void Authority_AccumulateOngoingGameEvent(const class UObject* worldContextObject, const struct FGameplayTag& gameEventType, class ADBDPlayer* instigator, class AActor* target, float customValue, float ongoingWaitTime, class UObject* customObjectParameter, int32 customIntValue);
	static void Authority_DispatcherFireGameEvent(const class UObject* worldContextObject, const struct FGameplayTag& gameEventType, bool broadcastOverNetwork, class ADBDPlayer* instigator, class AActor* target, float customValue, class UObject* customObjectParameter, int32 customIntValue);
	static void DispatcherFireGameEvent(const class UObject* worldContextObject, const struct FGameplayTag& gameEventType, bool broadcastOverNetwork, class ADBDPlayer* instigator, class AActor* target, float customValue, class UObject* customObjectParameter, int32 customIntValue);
	static void LocallyDispatchGameEvent(const class UObject* worldContextObject, const struct FGameplayTag& gameEventType, class ADBDPlayer* instigator, class AActor* target, float customValue, class UObject* customObjectParameter, int32 customIntValue);
	static void RemotelyDispatchGameEvent(const class UObject* worldContextObject, const struct FGameplayTag& gameEventType, class ADBDPlayer* instigator, class AActor* target, float customValue, class UObject* customObjectParameter, int32 customIntValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameEventUtilities">();
	}
	static class UDBDGameEventUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameEventUtilities>();
	}
};
static_assert(alignof(UDBDGameEventUtilities) == 0x000008, "Wrong alignment on UDBDGameEventUtilities");
static_assert(sizeof(UDBDGameEventUtilities) == 0x000030, "Wrong size on UDBDGameEventUtilities");

// Class DeadByDaylight.PerkSoundHudIcon
// 0x0010 (0x0348 - 0x0338)
class UPerkSoundHudIcon : public UMobileBaseUserWidget
{
public:
	class FName                                   PerkID;                                            // 0x0338(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivatePerk(float percentage);
	void ClearPerk();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkSoundHudIcon">();
	}
	static class UPerkSoundHudIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkSoundHudIcon>();
	}
};
static_assert(alignof(UPerkSoundHudIcon) == 0x000008, "Wrong alignment on UPerkSoundHudIcon");
static_assert(sizeof(UPerkSoundHudIcon) == 0x000348, "Wrong size on UPerkSoundHudIcon");
static_assert(offsetof(UPerkSoundHudIcon, PerkID) == 0x000338, "Member 'UPerkSoundHudIcon::PerkID' has a wrong offset!");

// Class DeadByDaylight.PerkSoundHudIconSporadic
// 0x0038 (0x0380 - 0x0348)
class UPerkSoundHudIconSporadic final : public UPerkSoundHudIcon
{
public:
	class UCanvasPanel*                           SporadicIcon;                                      // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInRate;                                        // 0x0350(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutRate;                                       // 0x0354(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimationStartOpacity;                             // 0x0358(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FadePolynomialOrder;                               // 0x035C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DisplayIcon;                                       // 0x0360(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_361[0x1F];                                     // 0x0361(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NativeTick(const struct FGeometry& MyGeometry, float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkSoundHudIconSporadic">();
	}
	static class UPerkSoundHudIconSporadic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkSoundHudIconSporadic>();
	}
};
static_assert(alignof(UPerkSoundHudIconSporadic) == 0x000008, "Wrong alignment on UPerkSoundHudIconSporadic");
static_assert(sizeof(UPerkSoundHudIconSporadic) == 0x000380, "Wrong size on UPerkSoundHudIconSporadic");
static_assert(offsetof(UPerkSoundHudIconSporadic, SporadicIcon) == 0x000348, "Member 'UPerkSoundHudIconSporadic::SporadicIcon' has a wrong offset!");
static_assert(offsetof(UPerkSoundHudIconSporadic, FadeInRate) == 0x000350, "Member 'UPerkSoundHudIconSporadic::FadeInRate' has a wrong offset!");
static_assert(offsetof(UPerkSoundHudIconSporadic, FadeOutRate) == 0x000354, "Member 'UPerkSoundHudIconSporadic::FadeOutRate' has a wrong offset!");
static_assert(offsetof(UPerkSoundHudIconSporadic, AnimationStartOpacity) == 0x000358, "Member 'UPerkSoundHudIconSporadic::AnimationStartOpacity' has a wrong offset!");
static_assert(offsetof(UPerkSoundHudIconSporadic, FadePolynomialOrder) == 0x00035C, "Member 'UPerkSoundHudIconSporadic::FadePolynomialOrder' has a wrong offset!");
static_assert(offsetof(UPerkSoundHudIconSporadic, DisplayIcon) == 0x000360, "Member 'UPerkSoundHudIconSporadic::DisplayIcon' has a wrong offset!");

// Class DeadByDaylight.DBDGameInstance
// 0x0818 (0x0A18 - 0x0200)
class UDBDGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_200[0x48];                                     // 0x0200(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDBDDesignTunables>         DesignTunableClass;                                // 0x0248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDBDDesignTunables*                     DesignTunables;                                    // 0x0250(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class URegionFinder>              RegionClass;                                       // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UShopManager>               ShopManagerClass;                                  // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AOfferingSequenceManager>   OfferingSequenceManagerClass;                      // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UFriendManager>             FriendManagerClass;                                // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             AchievementsDataAsset;                             // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameEventTracker*                      GameEventTracker;                                  // 0x0280(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDBDKeyDisplayInfo*                     KeyDisplayInfo;                                    // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LeaveGameRequested;                                // 0x0290(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerProfileDAL*                      PlayerProfileDAL;                                  // 0x0298(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GenerationSeed;                                    // 0x02A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PaperTileAssetName;                                // 0x02A8(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GenerationPlayerCount;                             // 0x02B8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PremadeMap;                                        // 0x02C0(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FForceSpawnTileData>            ForceSpawnTileData;                                // 0x02D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x20];                                     // 0x02E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class AOfferingSequenceManager*               OfferingSequence;                                  // 0x0300(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FParadiseData>                  ParadiseData;                                      // 0x0308(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          PlayerProfileLoadFailed;                           // 0x0318(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNewsContentManager*                    NewsContentManager;                                // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UContentScheduleManager*                ContentScheduleManager;                            // 0x0328(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCDNPatchManager*                       CDNPatchManager;                                   // 0x0330(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterProgressionManager*           CharacterProgressionManager;                       // 0x0338(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCharacterXPManager*                    CharacterXPManager;                                // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAtlantaRitualsManager*                 AtlRitualsManager;                                 // 0x0348(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AuthOrEACErrorAdditionalInfo;                      // 0x0350(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasServerLeftMatch;                                // 0x0360(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasWrittenGameEndStats;                            // 0x0361(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_362[0x6];                                      // 0x0362(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UFearMarketManager*                     FearMarketManager;                                 // 0x0368(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UShopManager*                           ShopManager;                                       // 0x0370(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFriendManager*                         FriendManager;                                     // 0x0378(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWalletHandler*                         WalletHandler;                                     // 0x0380(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TutorialRequesterName;                             // 0x0388(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UControllerPairingManager*              ControllerPairingManager;                          // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0xE8];                                     // 0x03A0(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	class UChunkingManager*                       ChunkingManager;                                   // 0x0488(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* player)> OnPlayerDisconnect;                     // 0x0490(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A0[0x128];                                    // 0x04A0(0x0128)(Fixing Size After Last Property [ Dumper-7 ])
	class UAssetLibraryManager*                   _assetLibraryManager;                              // 0x05C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _bloodwebManagerClass;                             // 0x05D0(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOnlineTransactionServiceComponent*     _onlineTransactionService;                         // 0x0600(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _sharedAuthenticationManagerClass;                 // 0x0608(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_638[0x130];                                    // 0x0638(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDPersistentData*                     _persistentData;                                   // 0x0768(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerDataStorageFacade*               _playerDataFacade;                                 // 0x0770(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URankManager*                           _rankManager;                                      // 0x0778(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDPlayerLevelManager*                 _playerLevelManager;                               // 0x0780(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerNameRegistration*                _playerNameRegistration;                           // 0x0788(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpecialEventManager*                   _specialEventManager;                              // 0x0790(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBonusPointEventsManager*               _bonusPointEventsManager;                          // 0x0798(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDTimeTravelManager*                  _timeTravelManager;                                // 0x07A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UToastManager*                          _toastManager;                                     // 0x07A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDSocialNotificationFactory*          _socialNotificationFactory;                        // 0x07B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDPartyFacade*                        _partyFacade;                                      // 0x07B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPenaltyTracker*                        _penaltyTracker;                                   // 0x07C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C8[0x28];                                     // 0x07C8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class ULightingHelper*                        _ligthingHelper;                                   // 0x07F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOfferingHandler*                       _offeringHandler;                                  // 0x07F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_800[0x8];                                      // 0x0800(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActorKnowledgeCollection*>      _actorKnowledgeCollections;                        // 0x0808(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UMapActorDB*                            _mapActorDB;                                       // 0x0818(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInteractionProficiency*>        _interactionProficiencies;                         // 0x0820(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UDBDHud*                                _theHud;                                           // 0x0830(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_838[0x28];                                     // 0x0838(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodwebManager*                       _bloodwebManager;                                  // 0x0860(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USharedAuthenticationComponent*         _sharedAuthenticationManager;                      // 0x0868(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPopupSequencer*                        _popupSequencer;                                   // 0x0870(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPopupFactory*                          _popupFactory;                                     // 0x0878(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAuthentication*                     _auth;                                             // 0x0880(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDEasyAntiCheat*                      _eac;                                              // 0x0888(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_890[0x98];                                     // 0x0890(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UObject>>         _execObjects;                                      // 0x0928(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          _networkFailureDetected;                           // 0x0938(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _networkConnectionMonitoringOnly;                  // 0x0939(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _achievementStatsUploadEnabled;                    // 0x093A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isDisconnected;                                   // 0x093B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isGamepadReconnected;                             // 0x093C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isProfileOffline;                                 // 0x093D(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isAppSuspended;                                   // 0x093E(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isAppResumed;                                     // 0x093F(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInvitationRejected;                             // 0x0940(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isAdditionalContentInstalled;                     // 0x0941(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isCloudInventoryInitialized;                      // 0x0942(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_943[0x2D];                                     // 0x0943(0x002D)(Fixing Size After Last Property [ Dumper-7 ])
	class UOfferingEffectCollection*              _resultOfferingAndPerkEffects;                     // 0x0970(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInventoryHandler*                      _inventoryHandler;                                 // 0x0978(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCinematicManager*                      _cinematicManager;                                 // 0x0980(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoftBanManager*                        _softBanManager;                                   // 0x0988(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UConsentManager*                        _consentManager;                                   // 0x0990(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOnlineSystemHandler*                   _onlineSystemHandler;                              // 0x0998(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URegionFinder*                          _regionFinder;                                     // 0x09A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDecalSpawnerCollection*                _decalSpawnerCollection;                           // 0x09A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveCollection*                   _characterClippingPrimitiveCollection;             // 0x09B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtlantaTooltipManager*                 _atlantaTooltipManager;                            // 0x09B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint32                                        LastProviderErrorCode;                             // 0x09C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDisconnectErrors                             _disconnectError;                                  // 0x09C4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9C5[0x3];                                      // 0x09C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UDateTimerUpdater*                      _dateTimerUpdater;                                 // 0x09C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9D0[0x48];                                     // 0x09D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ForceCloseGame();

	void AddActorKnowledgeCollection(class UActorKnowledgeCollection* collection);
	void Authority_SimulatePerks(const TArray<class FName>& perks, int32 level);
	void BeginLoadingScreen(const class FString& MapName);
	void DBD_ApplyMist(const float fogModifier);
	void DBD_ApplyNoMist();
	void DBD_ChangeSteamOverlayPosition(int32 position, int32 verticalOffset, int32 horizontalOffset);
	void DBD_CheckForNewContent(const class FString& debugGameVersion, bool forceDisplay);
	void DBD_DeleteLocalSaveFile();
	void DBD_DestroySteamInventory();
	void DBD_DisplayCurrentAchievementStat(class FName statName);
	void DBD_DumpSessions();
	void DBD_ForceLoad();
	void DBD_ForceSave();
	void DBD_GetRegion();
	void DBD_PIXBeginCapture();
	void DBD_PIXEndCapture();
	void DBD_ResetCurrentAchievementStat(class FName statName, bool andUpload);
	void DBD_ResetCurrentAchievementStats(bool andUpload, bool andUpdateData);
	void DBD_ResetSaveData();
	void DBD_SetFearMarketDate(const class FString& dateString);
	void DBD_SetStatsUploadEnabled(bool enabled);
	void DBD_TestDiceRoll(float BaseProbability, float MultiplicativeModifier, float AdditiveModifier);
	void DBD_TestRegion();
	void DBD_TestSaveFile(const class FString& name);
	void DBD_TestTickedDiceRoll(float BaseProbability, float ticks, float MultiplicativeModifier, float AdditiveModifier);
	void DBD_ToggleLightingLoaded();
	void DBD_UpdateSteamInventory();
	void EndLoadingScreen(class UWorld* loadedWorld);
	class FName GetCharacterDefaultItem(int32 inCharacterIndex);
	class ABaseSky* GetLevelLighting();
	class ULightingHelper* GetLightingHelper();
	class ULightingInterpolator* GetLightInterpolator();
	void GotoSplashScreen(bool showDefaultDialogueOnSplashScreen);
	void RemoveActorKnowledgeCollection(class UActorKnowledgeCollection* collection);
	void SimulateOfferingSequence(const TArray<class FName>& offerings, bool playSequence);
	void StartOfferingSequence();

	void DBD_PrintAudioConfig() const;
	class UBonusPointEventsManager* GetBonusPointEventsManager() const;
	class UPrimitiveCollection* GetCharacterClippingPrimitiveCollection() const;
	class UCinematicManager* GetCinematicManager() const;
	class UConsentManager* GetConsentManager() const;
	int32 GetDeadOrDisconnectedCampersCount(class ADBDPlayerState* exception) const;
	class UDecalSpawnerCollection* GetDecalSpawnerCollection() const;
	class UDedicatedServerManager* GetDedicatedServerManager() const;
	class UInventoryHandler* GetInventoryHandler() const;
	class ULocalEventManager* GetLocalEventManager() const;
	class ADBDPlayer* GetLocallyControlledCharacter() const;
	class ULocalPlayer* GetLocalPlayer() const;
	class APlayerController* GetLocalPlayerController() const;
	class UMapActorDB* GetMapActorDB() const;
	int32 GetMaxSurvivorCount() const;
	class UDBDPlayerLevelManager* GetPlayerLevelManager() const;
	class UPlayerNameRegistration* GetPlayerNameRegistration() const;
	class URankManager* GetRankManager() const;
	class USoftBanManager* GetSoftBanManager() const;
	class USpecialEventManager* GetSpecialEventManager() const;
	class UDBDTimeUtilities* GetTimeUtils() const;
	bool HasOfferingByType(EOfferingEffectType type) const;
	bool HasOfferingOfType(EOfferingEffectType type, int32 playerId, class FName tag) const;
	bool IsActorKnown(const class ADBDPlayer* knowledgePossessor, class AActor* possiblyKnownActor) const;
	void OnTimeTravelComplete(bool success, const class FString& date) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameInstance">();
	}
	static class UDBDGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameInstance>();
	}
};
static_assert(alignof(UDBDGameInstance) == 0x000008, "Wrong alignment on UDBDGameInstance");
static_assert(sizeof(UDBDGameInstance) == 0x000A18, "Wrong size on UDBDGameInstance");
static_assert(offsetof(UDBDGameInstance, DesignTunableClass) == 0x000248, "Member 'UDBDGameInstance::DesignTunableClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, DesignTunables) == 0x000250, "Member 'UDBDGameInstance::DesignTunables' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, RegionClass) == 0x000258, "Member 'UDBDGameInstance::RegionClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ShopManagerClass) == 0x000260, "Member 'UDBDGameInstance::ShopManagerClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, OfferingSequenceManagerClass) == 0x000268, "Member 'UDBDGameInstance::OfferingSequenceManagerClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, FriendManagerClass) == 0x000270, "Member 'UDBDGameInstance::FriendManagerClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, AchievementsDataAsset) == 0x000278, "Member 'UDBDGameInstance::AchievementsDataAsset' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, GameEventTracker) == 0x000280, "Member 'UDBDGameInstance::GameEventTracker' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, KeyDisplayInfo) == 0x000288, "Member 'UDBDGameInstance::KeyDisplayInfo' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, LeaveGameRequested) == 0x000290, "Member 'UDBDGameInstance::LeaveGameRequested' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, PlayerProfileDAL) == 0x000298, "Member 'UDBDGameInstance::PlayerProfileDAL' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, GenerationSeed) == 0x0002A0, "Member 'UDBDGameInstance::GenerationSeed' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, PaperTileAssetName) == 0x0002A8, "Member 'UDBDGameInstance::PaperTileAssetName' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, GenerationPlayerCount) == 0x0002B8, "Member 'UDBDGameInstance::GenerationPlayerCount' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, PremadeMap) == 0x0002C0, "Member 'UDBDGameInstance::PremadeMap' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ForceSpawnTileData) == 0x0002D0, "Member 'UDBDGameInstance::ForceSpawnTileData' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, OfferingSequence) == 0x000300, "Member 'UDBDGameInstance::OfferingSequence' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ParadiseData) == 0x000308, "Member 'UDBDGameInstance::ParadiseData' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, PlayerProfileLoadFailed) == 0x000318, "Member 'UDBDGameInstance::PlayerProfileLoadFailed' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, NewsContentManager) == 0x000320, "Member 'UDBDGameInstance::NewsContentManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ContentScheduleManager) == 0x000328, "Member 'UDBDGameInstance::ContentScheduleManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, CDNPatchManager) == 0x000330, "Member 'UDBDGameInstance::CDNPatchManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, CharacterProgressionManager) == 0x000338, "Member 'UDBDGameInstance::CharacterProgressionManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, CharacterXPManager) == 0x000340, "Member 'UDBDGameInstance::CharacterXPManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, AtlRitualsManager) == 0x000348, "Member 'UDBDGameInstance::AtlRitualsManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, AuthOrEACErrorAdditionalInfo) == 0x000350, "Member 'UDBDGameInstance::AuthOrEACErrorAdditionalInfo' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, HasServerLeftMatch) == 0x000360, "Member 'UDBDGameInstance::HasServerLeftMatch' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, HasWrittenGameEndStats) == 0x000361, "Member 'UDBDGameInstance::HasWrittenGameEndStats' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, FearMarketManager) == 0x000368, "Member 'UDBDGameInstance::FearMarketManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ShopManager) == 0x000370, "Member 'UDBDGameInstance::ShopManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, FriendManager) == 0x000378, "Member 'UDBDGameInstance::FriendManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, WalletHandler) == 0x000380, "Member 'UDBDGameInstance::WalletHandler' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, TutorialRequesterName) == 0x000388, "Member 'UDBDGameInstance::TutorialRequesterName' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ControllerPairingManager) == 0x000398, "Member 'UDBDGameInstance::ControllerPairingManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, ChunkingManager) == 0x000488, "Member 'UDBDGameInstance::ChunkingManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, OnPlayerDisconnect) == 0x000490, "Member 'UDBDGameInstance::OnPlayerDisconnect' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _assetLibraryManager) == 0x0005C8, "Member 'UDBDGameInstance::_assetLibraryManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _bloodwebManagerClass) == 0x0005D0, "Member 'UDBDGameInstance::_bloodwebManagerClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _onlineTransactionService) == 0x000600, "Member 'UDBDGameInstance::_onlineTransactionService' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _sharedAuthenticationManagerClass) == 0x000608, "Member 'UDBDGameInstance::_sharedAuthenticationManagerClass' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _persistentData) == 0x000768, "Member 'UDBDGameInstance::_persistentData' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _playerDataFacade) == 0x000770, "Member 'UDBDGameInstance::_playerDataFacade' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _rankManager) == 0x000778, "Member 'UDBDGameInstance::_rankManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _playerLevelManager) == 0x000780, "Member 'UDBDGameInstance::_playerLevelManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _playerNameRegistration) == 0x000788, "Member 'UDBDGameInstance::_playerNameRegistration' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _specialEventManager) == 0x000790, "Member 'UDBDGameInstance::_specialEventManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _bonusPointEventsManager) == 0x000798, "Member 'UDBDGameInstance::_bonusPointEventsManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _timeTravelManager) == 0x0007A0, "Member 'UDBDGameInstance::_timeTravelManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _toastManager) == 0x0007A8, "Member 'UDBDGameInstance::_toastManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _socialNotificationFactory) == 0x0007B0, "Member 'UDBDGameInstance::_socialNotificationFactory' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _partyFacade) == 0x0007B8, "Member 'UDBDGameInstance::_partyFacade' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _penaltyTracker) == 0x0007C0, "Member 'UDBDGameInstance::_penaltyTracker' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _ligthingHelper) == 0x0007F0, "Member 'UDBDGameInstance::_ligthingHelper' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _offeringHandler) == 0x0007F8, "Member 'UDBDGameInstance::_offeringHandler' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _actorKnowledgeCollections) == 0x000808, "Member 'UDBDGameInstance::_actorKnowledgeCollections' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _mapActorDB) == 0x000818, "Member 'UDBDGameInstance::_mapActorDB' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _interactionProficiencies) == 0x000820, "Member 'UDBDGameInstance::_interactionProficiencies' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _theHud) == 0x000830, "Member 'UDBDGameInstance::_theHud' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _bloodwebManager) == 0x000860, "Member 'UDBDGameInstance::_bloodwebManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _sharedAuthenticationManager) == 0x000868, "Member 'UDBDGameInstance::_sharedAuthenticationManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _popupSequencer) == 0x000870, "Member 'UDBDGameInstance::_popupSequencer' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _popupFactory) == 0x000878, "Member 'UDBDGameInstance::_popupFactory' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _auth) == 0x000880, "Member 'UDBDGameInstance::_auth' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _eac) == 0x000888, "Member 'UDBDGameInstance::_eac' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _execObjects) == 0x000928, "Member 'UDBDGameInstance::_execObjects' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _networkFailureDetected) == 0x000938, "Member 'UDBDGameInstance::_networkFailureDetected' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _networkConnectionMonitoringOnly) == 0x000939, "Member 'UDBDGameInstance::_networkConnectionMonitoringOnly' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _achievementStatsUploadEnabled) == 0x00093A, "Member 'UDBDGameInstance::_achievementStatsUploadEnabled' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isDisconnected) == 0x00093B, "Member 'UDBDGameInstance::_isDisconnected' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isGamepadReconnected) == 0x00093C, "Member 'UDBDGameInstance::_isGamepadReconnected' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isProfileOffline) == 0x00093D, "Member 'UDBDGameInstance::_isProfileOffline' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isAppSuspended) == 0x00093E, "Member 'UDBDGameInstance::_isAppSuspended' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isAppResumed) == 0x00093F, "Member 'UDBDGameInstance::_isAppResumed' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isInvitationRejected) == 0x000940, "Member 'UDBDGameInstance::_isInvitationRejected' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isAdditionalContentInstalled) == 0x000941, "Member 'UDBDGameInstance::_isAdditionalContentInstalled' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _isCloudInventoryInitialized) == 0x000942, "Member 'UDBDGameInstance::_isCloudInventoryInitialized' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _resultOfferingAndPerkEffects) == 0x000970, "Member 'UDBDGameInstance::_resultOfferingAndPerkEffects' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _inventoryHandler) == 0x000978, "Member 'UDBDGameInstance::_inventoryHandler' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _cinematicManager) == 0x000980, "Member 'UDBDGameInstance::_cinematicManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _softBanManager) == 0x000988, "Member 'UDBDGameInstance::_softBanManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _consentManager) == 0x000990, "Member 'UDBDGameInstance::_consentManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _onlineSystemHandler) == 0x000998, "Member 'UDBDGameInstance::_onlineSystemHandler' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _regionFinder) == 0x0009A0, "Member 'UDBDGameInstance::_regionFinder' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _decalSpawnerCollection) == 0x0009A8, "Member 'UDBDGameInstance::_decalSpawnerCollection' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _characterClippingPrimitiveCollection) == 0x0009B0, "Member 'UDBDGameInstance::_characterClippingPrimitiveCollection' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _atlantaTooltipManager) == 0x0009B8, "Member 'UDBDGameInstance::_atlantaTooltipManager' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, LastProviderErrorCode) == 0x0009C0, "Member 'UDBDGameInstance::LastProviderErrorCode' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _disconnectError) == 0x0009C4, "Member 'UDBDGameInstance::_disconnectError' has a wrong offset!");
static_assert(offsetof(UDBDGameInstance, _dateTimerUpdater) == 0x0009C8, "Member 'UDBDGameInstance::_dateTimerUpdater' has a wrong offset!");

// Class DeadByDaylight.DBDGameSession
// 0x0060 (0x02B0 - 0x0250)
class ADBDGameSession final : public AGameSession
{
public:
	uint8                                         Pad_250[0x60];                                     // 0x0250(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameSession">();
	}
	static class ADBDGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGameSession>();
	}
};
static_assert(alignof(ADBDGameSession) == 0x000008, "Wrong alignment on ADBDGameSession");
static_assert(sizeof(ADBDGameSession) == 0x0002B0, "Wrong size on ADBDGameSession");

// Class DeadByDaylight.UMGDragWidget
// 0x0020 (0x02B8 - 0x0298)
class UUMGDragWidget : public UUserWidget
{
public:
	uint8                                         Pad_298[0x10];                                     // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCustomWidgetWrapper_HudEditor*> _allEditableWidgets;                               // 0x02A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void SetClampToViewportDirty();

	const TArray<class UCustomWidgetWrapper_HudEditor*> GetAllEditableWidgets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGDragWidget">();
	}
	static class UUMGDragWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGDragWidget>();
	}
};
static_assert(alignof(UUMGDragWidget) == 0x000008, "Wrong alignment on UUMGDragWidget");
static_assert(sizeof(UUMGDragWidget) == 0x0002B8, "Wrong size on UUMGDragWidget");
static_assert(offsetof(UUMGDragWidget, _allEditableWidgets) == 0x0002A8, "Member 'UUMGDragWidget::_allEditableWidgets' has a wrong offset!");

// Class DeadByDaylight.UMGDragWidget_HudEditor
// 0x0060 (0x0318 - 0x02B8)
class UUMGDragWidget_HudEditor final : public UUMGDragWidget
{
public:
	uint8                                         Pad_2B8[0x20];                                     // 0x02B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UUserWidget>                OnSelectionWidgetClass;                            // 0x02D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUMGHudEditorDragConstraintWidget> DragLinkWidgetClass;                        // 0x02E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomWidgetWrapper_HudEditor*         _customWrapper;                                    // 0x02E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            _selectionWidget;                                  // 0x02F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGHudEditorDragConstraintWidget*      _dragLinkWidget;                                   // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGDragWidget_HudEditor*               _parentLinkWidget;                                 // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGDragWidget_HudEditor*               _childLinkWidget;                                  // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOnSelection(bool isSelected);

	class UCustomWidgetWrapper_HudEditor* GetCustomWrapper() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGDragWidget_HudEditor">();
	}
	static class UUMGDragWidget_HudEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGDragWidget_HudEditor>();
	}
};
static_assert(alignof(UUMGDragWidget_HudEditor) == 0x000008, "Wrong alignment on UUMGDragWidget_HudEditor");
static_assert(sizeof(UUMGDragWidget_HudEditor) == 0x000318, "Wrong size on UUMGDragWidget_HudEditor");
static_assert(offsetof(UUMGDragWidget_HudEditor, OnSelectionWidgetClass) == 0x0002D8, "Member 'UUMGDragWidget_HudEditor::OnSelectionWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, DragLinkWidgetClass) == 0x0002E0, "Member 'UUMGDragWidget_HudEditor::DragLinkWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, _customWrapper) == 0x0002E8, "Member 'UUMGDragWidget_HudEditor::_customWrapper' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, _selectionWidget) == 0x0002F0, "Member 'UUMGDragWidget_HudEditor::_selectionWidget' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, _dragLinkWidget) == 0x0002F8, "Member 'UUMGDragWidget_HudEditor::_dragLinkWidget' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, _parentLinkWidget) == 0x000300, "Member 'UUMGDragWidget_HudEditor::_parentLinkWidget' has a wrong offset!");
static_assert(offsetof(UUMGDragWidget_HudEditor, _childLinkWidget) == 0x000308, "Member 'UUMGDragWidget_HudEditor::_childLinkWidget' has a wrong offset!");

// Class DeadByDaylight.DBDGameUserSettings
// 0x02F8 (0x0420 - 0x0128)
class UDBDGameUserSettings final : public UGameUserSettings
{
public:
	TArray<struct FInputActionKeyMapping>         ActionMappings;                                    // 0x0128(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FInputAxisKeyMapping>           AxisMappings;                                      // 0x0138(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSetCustomizedHudsTimestamp;                      // 0x0148(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x18];                                     // 0x0158(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DeviceLoginTokenID;                                // 0x0170(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ScalabilityLevel;                                  // 0x0180(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AutoScalabilitySet;                                // 0x0184(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AutoAdjust;                                        // 0x0185(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_186[0x2];                                      // 0x0186(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScreenResolution;                                  // 0x0188(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          FullScreen;                                        // 0x018C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HUDConstrainedAspectRatio;                         // 0x018D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_18E[0x2];                                      // 0x018E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MenuScaleFactor;                                   // 0x0190(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         HudScaleFactor;                                    // 0x0194(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SkillCheckScaleFactor;                             // 0x0198(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LargeText;                                         // 0x019C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BloodwebInteractionBehaviour;                      // 0x019D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          TerrorRadiusVisualFeedback;                        // 0x019E(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HUDPlayerNamesVisibility;                          // 0x019F(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HUDKillerHookCountVisibility;                      // 0x01A0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HUDScoreEventsVisibility;                          // 0x01A1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LegacyPrestigePortraits;                           // 0x01A2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ChallengeProgression;                              // 0x01A3(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ChallengeCompletion;                               // 0x01A4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A5[0x3];                                      // 0x01A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        FPSLimit;                                          // 0x01A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MainVolume;                                        // 0x01AC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MainVolumeOn;                                      // 0x01B0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B1[0x3];                                      // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MenuMusicVolume;                                   // 0x01B4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MenuMusicVolumeOn;                                 // 0x01B8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseHeadphones;                                     // 0x01B9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MuteOnFocusLost;                                   // 0x01BA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HapticsVibrationPS5;                               // 0x01BB(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         KillerCameraSensitivity;                           // 0x01BC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SurvivorCameraSensitivity;                         // 0x01C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         KillerMouseSensitivity;                            // 0x01C4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SurvivorMouseSensitivity;                          // 0x01C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         KillerControllerSensitivity;                       // 0x01CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SurvivorControllerSensitivity;                     // 0x01D0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          AimAssist;                                         // 0x01D4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ControlType;                                       // 0x01D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          InvertY;                                           // 0x01DC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SurvivorInvertY;                                   // 0x01DD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          KillerToggleInteractions;                          // 0x01DE(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SurvivorToggleInteractions;                        // 0x01DF(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          SprintToCancel;                                    // 0x01E0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E1[0x7];                                      // 0x01E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Language;                                          // 0x01E8(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          LanguageIsDefinedByPlayer;                         // 0x01F8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F9[0x3];                                      // 0x01F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HighestWeightSeenNews;                             // 0x01FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSharedAuthenticationTokenInformation  SharedLoginInformation;                            // 0x0200(0x0030)(Config, NativeAccessSpecifierPrivate)
	uint32                                        LastPanelContextId;                                // 0x0230(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ArchivesAutoPlayVoiceOver;                         // 0x0234(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ArchivesFullscreenTextVisibility;                  // 0x0235(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasAcceptedCrossplayPopup;                         // 0x0236(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasAcceptedProgressionSystemInfoPopup;             // 0x0237(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasAcceptedHapticsVibrationPopup;                  // 0x0238(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HasAcceptedCrossProgressionPopup;                  // 0x0239(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23A[0x6];                                      // 0x023A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBonusTierTooltipVisibility            BonusTierTooltipVisibility;                        // 0x0240(0x0018)(Config, NativeAccessSpecifierPrivate)
	bool                                          UseAtlantaCustomizedHuds;                          // 0x0258(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseAtlantaSurvivorQuickTurn;                       // 0x0259(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseAtlantaKillerQuickTurn;                         // 0x025A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25B[0x5];                                      // 0x025B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAtlantaCustomizedHudSettings>  AtlantaCustomizedHuds;                             // 0x0260(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          ShowPortraitBorder;                                // 0x0278(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PartyPrivacyState;                                 // 0x0280(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0xD8];                                     // 0x0290(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ColorBlindMode;                                    // 0x0368(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ColorBlindModeIntensity;                           // 0x036C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          BeginnerMode;                                      // 0x0370(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Subtitles;                                         // 0x0371(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_372[0x2];                                      // 0x0372(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubtitlesBackgroundOpacity;                        // 0x0374(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x48];                                     // 0x0378(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SubtitlesSize;                                     // 0x03C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsAnonymousMode;                                   // 0x03C4(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HideYourName;                                      // 0x03C5(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HideOtherNames;                                    // 0x03C6(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          HiddenMatchmakingDelay;                            // 0x03C7(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x58];                                     // 0x03C8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UDBDGameUserSettings* GetDBDGameUserSettings();

	bool GetBloodwebInteractionBehaviour() const;
	bool GetChallengeCompletion() const;
	bool GetChallengeProgression() const;
	EColorVisionDeficiency GetColorBlindMode() const;
	int32 GetColorBlindModeIntensity() const;
	bool GetHUDKillerHookCountVisibility() const;
	bool GetHUDPlayerNamesVisibility() const;
	int32 GetHudScaleFactor() const;
	bool GetHUDScoreEventsVisibility() const;
	bool GetLargeText() const;
	bool GetLegacyPrestigePortraits() const;
	int32 GetMenuScaleFactor() const;
	int32 GetSkillCheckScaleFactor() const;
	bool GetTerrorRadiusVisualFeedback() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGameUserSettings">();
	}
	static class UDBDGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDGameUserSettings>();
	}
};
static_assert(alignof(UDBDGameUserSettings) == 0x000008, "Wrong alignment on UDBDGameUserSettings");
static_assert(sizeof(UDBDGameUserSettings) == 0x000420, "Wrong size on UDBDGameUserSettings");
static_assert(offsetof(UDBDGameUserSettings, ActionMappings) == 0x000128, "Member 'UDBDGameUserSettings::ActionMappings' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AxisMappings) == 0x000138, "Member 'UDBDGameUserSettings::AxisMappings' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, OnSetCustomizedHudsTimestamp) == 0x000148, "Member 'UDBDGameUserSettings::OnSetCustomizedHudsTimestamp' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, DeviceLoginTokenID) == 0x000170, "Member 'UDBDGameUserSettings::DeviceLoginTokenID' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ScalabilityLevel) == 0x000180, "Member 'UDBDGameUserSettings::ScalabilityLevel' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AutoScalabilitySet) == 0x000184, "Member 'UDBDGameUserSettings::AutoScalabilitySet' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AutoAdjust) == 0x000185, "Member 'UDBDGameUserSettings::AutoAdjust' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ScreenResolution) == 0x000188, "Member 'UDBDGameUserSettings::ScreenResolution' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, FullScreen) == 0x00018C, "Member 'UDBDGameUserSettings::FullScreen' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HUDConstrainedAspectRatio) == 0x00018D, "Member 'UDBDGameUserSettings::HUDConstrainedAspectRatio' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MenuScaleFactor) == 0x000190, "Member 'UDBDGameUserSettings::MenuScaleFactor' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HudScaleFactor) == 0x000194, "Member 'UDBDGameUserSettings::HudScaleFactor' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SkillCheckScaleFactor) == 0x000198, "Member 'UDBDGameUserSettings::SkillCheckScaleFactor' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, LargeText) == 0x00019C, "Member 'UDBDGameUserSettings::LargeText' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, BloodwebInteractionBehaviour) == 0x00019D, "Member 'UDBDGameUserSettings::BloodwebInteractionBehaviour' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, TerrorRadiusVisualFeedback) == 0x00019E, "Member 'UDBDGameUserSettings::TerrorRadiusVisualFeedback' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HUDPlayerNamesVisibility) == 0x00019F, "Member 'UDBDGameUserSettings::HUDPlayerNamesVisibility' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HUDKillerHookCountVisibility) == 0x0001A0, "Member 'UDBDGameUserSettings::HUDKillerHookCountVisibility' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HUDScoreEventsVisibility) == 0x0001A1, "Member 'UDBDGameUserSettings::HUDScoreEventsVisibility' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, LegacyPrestigePortraits) == 0x0001A2, "Member 'UDBDGameUserSettings::LegacyPrestigePortraits' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ChallengeProgression) == 0x0001A3, "Member 'UDBDGameUserSettings::ChallengeProgression' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ChallengeCompletion) == 0x0001A4, "Member 'UDBDGameUserSettings::ChallengeCompletion' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, FPSLimit) == 0x0001A8, "Member 'UDBDGameUserSettings::FPSLimit' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MainVolume) == 0x0001AC, "Member 'UDBDGameUserSettings::MainVolume' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MainVolumeOn) == 0x0001B0, "Member 'UDBDGameUserSettings::MainVolumeOn' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MenuMusicVolume) == 0x0001B4, "Member 'UDBDGameUserSettings::MenuMusicVolume' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MenuMusicVolumeOn) == 0x0001B8, "Member 'UDBDGameUserSettings::MenuMusicVolumeOn' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, UseHeadphones) == 0x0001B9, "Member 'UDBDGameUserSettings::UseHeadphones' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, MuteOnFocusLost) == 0x0001BA, "Member 'UDBDGameUserSettings::MuteOnFocusLost' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HapticsVibrationPS5) == 0x0001BB, "Member 'UDBDGameUserSettings::HapticsVibrationPS5' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, KillerCameraSensitivity) == 0x0001BC, "Member 'UDBDGameUserSettings::KillerCameraSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SurvivorCameraSensitivity) == 0x0001C0, "Member 'UDBDGameUserSettings::SurvivorCameraSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, KillerMouseSensitivity) == 0x0001C4, "Member 'UDBDGameUserSettings::KillerMouseSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SurvivorMouseSensitivity) == 0x0001C8, "Member 'UDBDGameUserSettings::SurvivorMouseSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, KillerControllerSensitivity) == 0x0001CC, "Member 'UDBDGameUserSettings::KillerControllerSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SurvivorControllerSensitivity) == 0x0001D0, "Member 'UDBDGameUserSettings::SurvivorControllerSensitivity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AimAssist) == 0x0001D4, "Member 'UDBDGameUserSettings::AimAssist' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ControlType) == 0x0001D8, "Member 'UDBDGameUserSettings::ControlType' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, InvertY) == 0x0001DC, "Member 'UDBDGameUserSettings::InvertY' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SurvivorInvertY) == 0x0001DD, "Member 'UDBDGameUserSettings::SurvivorInvertY' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, KillerToggleInteractions) == 0x0001DE, "Member 'UDBDGameUserSettings::KillerToggleInteractions' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SurvivorToggleInteractions) == 0x0001DF, "Member 'UDBDGameUserSettings::SurvivorToggleInteractions' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SprintToCancel) == 0x0001E0, "Member 'UDBDGameUserSettings::SprintToCancel' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, Language) == 0x0001E8, "Member 'UDBDGameUserSettings::Language' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, LanguageIsDefinedByPlayer) == 0x0001F8, "Member 'UDBDGameUserSettings::LanguageIsDefinedByPlayer' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HighestWeightSeenNews) == 0x0001FC, "Member 'UDBDGameUserSettings::HighestWeightSeenNews' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SharedLoginInformation) == 0x000200, "Member 'UDBDGameUserSettings::SharedLoginInformation' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, LastPanelContextId) == 0x000230, "Member 'UDBDGameUserSettings::LastPanelContextId' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ArchivesAutoPlayVoiceOver) == 0x000234, "Member 'UDBDGameUserSettings::ArchivesAutoPlayVoiceOver' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ArchivesFullscreenTextVisibility) == 0x000235, "Member 'UDBDGameUserSettings::ArchivesFullscreenTextVisibility' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HasAcceptedCrossplayPopup) == 0x000236, "Member 'UDBDGameUserSettings::HasAcceptedCrossplayPopup' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HasAcceptedProgressionSystemInfoPopup) == 0x000237, "Member 'UDBDGameUserSettings::HasAcceptedProgressionSystemInfoPopup' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HasAcceptedHapticsVibrationPopup) == 0x000238, "Member 'UDBDGameUserSettings::HasAcceptedHapticsVibrationPopup' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HasAcceptedCrossProgressionPopup) == 0x000239, "Member 'UDBDGameUserSettings::HasAcceptedCrossProgressionPopup' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, BonusTierTooltipVisibility) == 0x000240, "Member 'UDBDGameUserSettings::BonusTierTooltipVisibility' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, UseAtlantaCustomizedHuds) == 0x000258, "Member 'UDBDGameUserSettings::UseAtlantaCustomizedHuds' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, UseAtlantaSurvivorQuickTurn) == 0x000259, "Member 'UDBDGameUserSettings::UseAtlantaSurvivorQuickTurn' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, UseAtlantaKillerQuickTurn) == 0x00025A, "Member 'UDBDGameUserSettings::UseAtlantaKillerQuickTurn' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, AtlantaCustomizedHuds) == 0x000260, "Member 'UDBDGameUserSettings::AtlantaCustomizedHuds' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ShowPortraitBorder) == 0x000278, "Member 'UDBDGameUserSettings::ShowPortraitBorder' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, PartyPrivacyState) == 0x000280, "Member 'UDBDGameUserSettings::PartyPrivacyState' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ColorBlindMode) == 0x000368, "Member 'UDBDGameUserSettings::ColorBlindMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, ColorBlindModeIntensity) == 0x00036C, "Member 'UDBDGameUserSettings::ColorBlindModeIntensity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, BeginnerMode) == 0x000370, "Member 'UDBDGameUserSettings::BeginnerMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, Subtitles) == 0x000371, "Member 'UDBDGameUserSettings::Subtitles' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SubtitlesBackgroundOpacity) == 0x000374, "Member 'UDBDGameUserSettings::SubtitlesBackgroundOpacity' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, SubtitlesSize) == 0x0003C0, "Member 'UDBDGameUserSettings::SubtitlesSize' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, IsAnonymousMode) == 0x0003C4, "Member 'UDBDGameUserSettings::IsAnonymousMode' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HideYourName) == 0x0003C5, "Member 'UDBDGameUserSettings::HideYourName' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HideOtherNames) == 0x0003C6, "Member 'UDBDGameUserSettings::HideOtherNames' has a wrong offset!");
static_assert(offsetof(UDBDGameUserSettings, HiddenMatchmakingDelay) == 0x0003C7, "Member 'UDBDGameUserSettings::HiddenMatchmakingDelay' has a wrong offset!");

// Class DeadByDaylight.UMGDownloadProgressionWidget
// 0x0018 (0x0350 - 0x0338)
class UUMGDownloadProgressionWidget final : public UMobileBaseUserWidget
{
public:
	class UProgressBar*                           ProgressBar;                                       // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DownloadPercentage;                                // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DownloadDescription;                               // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateProgression(const struct FDownloadProgression& downloadProgression);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGDownloadProgressionWidget">();
	}
	static class UUMGDownloadProgressionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGDownloadProgressionWidget>();
	}
};
static_assert(alignof(UUMGDownloadProgressionWidget) == 0x000008, "Wrong alignment on UUMGDownloadProgressionWidget");
static_assert(sizeof(UUMGDownloadProgressionWidget) == 0x000350, "Wrong size on UUMGDownloadProgressionWidget");
static_assert(offsetof(UUMGDownloadProgressionWidget, ProgressBar) == 0x000338, "Member 'UUMGDownloadProgressionWidget::ProgressBar' has a wrong offset!");
static_assert(offsetof(UUMGDownloadProgressionWidget, DownloadPercentage) == 0x000340, "Member 'UUMGDownloadProgressionWidget::DownloadPercentage' has a wrong offset!");
static_assert(offsetof(UUMGDownloadProgressionWidget, DownloadDescription) == 0x000348, "Member 'UUMGDownloadProgressionWidget::DownloadDescription' has a wrong offset!");

// Class DeadByDaylight.DBDHud
// 0x0050 (0x0080 - 0x0030)
class UDBDHud final : public UObject
{
public:
	TMap<class FName, class AStatusView*>         _statusViews;                                      // 0x0030(0x0050)(NativeAccessSpecifierPrivate)

public:
	void RemoveStatusViewOnDestroy(class AActor* actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHud">();
	}
	static class UDBDHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHud>();
	}
};
static_assert(alignof(UDBDHud) == 0x000008, "Wrong alignment on UDBDHud");
static_assert(sizeof(UDBDHud) == 0x000080, "Wrong size on UDBDHud");
static_assert(offsetof(UDBDHud, _statusViews) == 0x000030, "Member 'UDBDHud::_statusViews' has a wrong offset!");

// Class DeadByDaylight.DBDInGameHud
// 0x0028 (0x0358 - 0x0330)
class ADBDInGameHud final : public ADBDBaseHud
{
public:
	class UFont*                                  _debugFontObj;                                     // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_338[0x18];                                     // 0x0338(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCompetenceDebugger*                    _competenceDebugger;                               // 0x0350(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInGameHud">();
	}
	static class ADBDInGameHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDInGameHud>();
	}
};
static_assert(alignof(ADBDInGameHud) == 0x000008, "Wrong alignment on ADBDInGameHud");
static_assert(sizeof(ADBDInGameHud) == 0x000358, "Wrong size on ADBDInGameHud");
static_assert(offsetof(ADBDInGameHud, _debugFontObj) == 0x000330, "Member 'ADBDInGameHud::_debugFontObj' has a wrong offset!");
static_assert(offsetof(ADBDInGameHud, _competenceDebugger) == 0x000350, "Member 'ADBDInGameHud::_competenceDebugger' has a wrong offset!");

// Class DeadByDaylight.UMGHudEditorDragConstraintWidget
// 0x0040 (0x02D8 - 0x0298)
class UUMGHudEditorDragConstraintWidget final : public UUserWidget
{
public:
	class USizeBox*                               LinkSizeBox;                                       // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            _childWidget;                                      // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            _parentWidget;                                     // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x28];                                     // 0x02B0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHudEditorDragConstraintWidget">();
	}
	static class UUMGHudEditorDragConstraintWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHudEditorDragConstraintWidget>();
	}
};
static_assert(alignof(UUMGHudEditorDragConstraintWidget) == 0x000008, "Wrong alignment on UUMGHudEditorDragConstraintWidget");
static_assert(sizeof(UUMGHudEditorDragConstraintWidget) == 0x0002D8, "Wrong size on UUMGHudEditorDragConstraintWidget");
static_assert(offsetof(UUMGHudEditorDragConstraintWidget, LinkSizeBox) == 0x000298, "Member 'UUMGHudEditorDragConstraintWidget::LinkSizeBox' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorDragConstraintWidget, _childWidget) == 0x0002A0, "Member 'UUMGHudEditorDragConstraintWidget::_childWidget' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorDragConstraintWidget, _parentWidget) == 0x0002A8, "Member 'UUMGHudEditorDragConstraintWidget::_parentWidget' has a wrong offset!");

// Class DeadByDaylight.DBDInitPlayerQuery
// 0x0000 (0x0030 - 0x0030)
class UDBDInitPlayerQuery : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInitPlayerQuery">();
	}
	static class UDBDInitPlayerQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDInitPlayerQuery>();
	}
};
static_assert(alignof(UDBDInitPlayerQuery) == 0x000008, "Wrong alignment on UDBDInitPlayerQuery");
static_assert(sizeof(UDBDInitPlayerQuery) == 0x000030, "Wrong size on UDBDInitPlayerQuery");

// Class DeadByDaylight.DBDInitPlayerQueryYesNo
// 0x0080 (0x00B0 - 0x0030)
class UDBDInitPlayerQueryYesNo : public UDBDInitPlayerQuery
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInitPlayerQueryYesNo">();
	}
	static class UDBDInitPlayerQueryYesNo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDInitPlayerQueryYesNo>();
	}
};
static_assert(alignof(UDBDInitPlayerQueryYesNo) == 0x000008, "Wrong alignment on UDBDInitPlayerQueryYesNo");
static_assert(sizeof(UDBDInitPlayerQueryYesNo) == 0x0000B0, "Wrong size on UDBDInitPlayerQueryYesNo");

// Class DeadByDaylight.HangDiagnosticSubsystem
// 0x0040 (0x0078 - 0x0038)
class UHangDiagnosticSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x40];                                      // 0x0038(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HangDiagnosticSubsystem">();
	}
	static class UHangDiagnosticSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHangDiagnosticSubsystem>();
	}
};
static_assert(alignof(UHangDiagnosticSubsystem) == 0x000008, "Wrong alignment on UHangDiagnosticSubsystem");
static_assert(sizeof(UHangDiagnosticSubsystem) == 0x000078, "Wrong size on UHangDiagnosticSubsystem");

// Class DeadByDaylight.DBDInitPlayerQueryYesNoSizeWifi
// 0x0010 (0x00C0 - 0x00B0)
class UDBDInitPlayerQueryYesNoSizeWifi final : public UDBDInitPlayerQueryYesNo
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDInitPlayerQueryYesNoSizeWifi">();
	}
	static class UDBDInitPlayerQueryYesNoSizeWifi* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDInitPlayerQueryYesNoSizeWifi>();
	}
};
static_assert(alignof(UDBDInitPlayerQueryYesNoSizeWifi) == 0x000008, "Wrong alignment on UDBDInitPlayerQueryYesNoSizeWifi");
static_assert(sizeof(UDBDInitPlayerQueryYesNoSizeWifi) == 0x0000C0, "Wrong size on UDBDInitPlayerQueryYesNoSizeWifi");

// Class DeadByDaylight.NotExhaustedActivationTimerElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UNotExhaustedActivationTimerElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NotExhaustedActivationTimerElapsedIconStrategy">();
	}
	static class UNotExhaustedActivationTimerElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNotExhaustedActivationTimerElapsedIconStrategy>();
	}
};
static_assert(alignof(UNotExhaustedActivationTimerElapsedIconStrategy) == 0x000008, "Wrong alignment on UNotExhaustedActivationTimerElapsedIconStrategy");
static_assert(sizeof(UNotExhaustedActivationTimerElapsedIconStrategy) == 0x000038, "Wrong size on UNotExhaustedActivationTimerElapsedIconStrategy");

// Class DeadByDaylight.DBDKeyDisplayInfo
// 0x0140 (0x0170 - 0x0030)
class UDBDKeyDisplayInfo final : public UObject
{
public:
	TMap<class FName, struct FKeyDisplayInfo>     _keyDisplayInfoMap;                                // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_80[0x50];                                      // 0x0080(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EInputInteractionType, class FName>      _interactionTypeToActionMap_Camper;                // 0x00D0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<EInputInteractionType, class FName>      _interactionTypeToActionMap_Slasher;               // 0x0120(0x0050)(NativeAccessSpecifierPrivate)

public:
	const class FName GetActionForInteractionType(EPlayerRole playerRole, EInputInteractionType inputInteractionType, bool useGamePad, bool ignoreInteractMash);
	const struct FKey GetFirstKeyForAction(class UPlayerInput* playerInput, class FName actionName, bool useGamePad);
	const struct FKeyDisplayInfo GetKeyDisplayInfo(const struct FKey& key);
	const struct FKeyDisplayInfo GetKeyDisplayInfoForInteractionType(class UPlayerInput* playerInput, EPlayerRole playerRole, EInputInteractionType interactionType, bool useGamePad);
	const bool IsExcludedKey(const struct FKey& key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDKeyDisplayInfo">();
	}
	static class UDBDKeyDisplayInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDKeyDisplayInfo>();
	}
};
static_assert(alignof(UDBDKeyDisplayInfo) == 0x000008, "Wrong alignment on UDBDKeyDisplayInfo");
static_assert(sizeof(UDBDKeyDisplayInfo) == 0x000170, "Wrong size on UDBDKeyDisplayInfo");
static_assert(offsetof(UDBDKeyDisplayInfo, _keyDisplayInfoMap) == 0x000030, "Member 'UDBDKeyDisplayInfo::_keyDisplayInfoMap' has a wrong offset!");
static_assert(offsetof(UDBDKeyDisplayInfo, _interactionTypeToActionMap_Camper) == 0x0000D0, "Member 'UDBDKeyDisplayInfo::_interactionTypeToActionMap_Camper' has a wrong offset!");
static_assert(offsetof(UDBDKeyDisplayInfo, _interactionTypeToActionMap_Slasher) == 0x000120, "Member 'UDBDKeyDisplayInfo::_interactionTypeToActionMap_Slasher' has a wrong offset!");

// Class DeadByDaylight.DBDLobbyHud
// 0x0000 (0x0330 - 0x0330)
class ADBDLobbyHud final : public ADBDBaseHud
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDLobbyHud">();
	}
	static class ADBDLobbyHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDLobbyHud>();
	}
};
static_assert(alignof(ADBDLobbyHud) == 0x000008, "Wrong alignment on ADBDLobbyHud");
static_assert(sizeof(ADBDLobbyHud) == 0x000330, "Wrong size on ADBDLobbyHud");

// Class DeadByDaylight.DBDMapFoliageDensityTunables
// 0x0010 (0x0040 - 0x0030)
class UDBDMapFoliageDensityTunables final : public UObject
{
public:
	TArray<struct FTypeFoliageToAutomateDensity>  FoliageToAutomateDensity;                          // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMapFoliageDensityTunables">();
	}
	static class UDBDMapFoliageDensityTunables* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDMapFoliageDensityTunables>();
	}
};
static_assert(alignof(UDBDMapFoliageDensityTunables) == 0x000008, "Wrong alignment on UDBDMapFoliageDensityTunables");
static_assert(sizeof(UDBDMapFoliageDensityTunables) == 0x000040, "Wrong size on UDBDMapFoliageDensityTunables");
static_assert(offsetof(UDBDMapFoliageDensityTunables, FoliageToAutomateDensity) == 0x000030, "Member 'UDBDMapFoliageDensityTunables::FoliageToAutomateDensity' has a wrong offset!");

// Class DeadByDaylight.DBDMathBlueprintLibrary
// 0x0000 (0x0030 - 0x0030)
class UDBDMathBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<struct FLinearColor> TransformToMatrix(const struct FTransform& A);
	static struct FVector VectorAbsoluteValue(const struct FVector& A);
	static bool VectorIntersect(const struct FVector& OriginA, const struct FVector& ExtentA, const struct FVector& OriginB, const struct FVector& ExtentB);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMathBlueprintLibrary">();
	}
	static class UDBDMathBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDMathBlueprintLibrary>();
	}
};
static_assert(alignof(UDBDMathBlueprintLibrary) == 0x000008, "Wrong alignment on UDBDMathBlueprintLibrary");
static_assert(sizeof(UDBDMathBlueprintLibrary) == 0x000030, "Wrong size on UDBDMathBlueprintLibrary");

// Class DeadByDaylight.LobbyPositionsSubsystem
// 0x00B8 (0x00F0 - 0x0038)
class ULobbyPositionsSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xB8];                                      // 0x0038(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyPositionsSubsystem">();
	}
	static class ULobbyPositionsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyPositionsSubsystem>();
	}
};
static_assert(alignof(ULobbyPositionsSubsystem) == 0x000008, "Wrong alignment on ULobbyPositionsSubsystem");
static_assert(sizeof(ULobbyPositionsSubsystem) == 0x0000F0, "Wrong size on ULobbyPositionsSubsystem");

// Class DeadByDaylight.DBDMenuGameState
// 0x0008 (0x0870 - 0x0868)
class ADBDMenuGameState final : public ADBDGameState
{
public:
	class UMenuForcedLODHandler*                  _menuForcedLODHandler;                             // 0x0868(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMenuGameState">();
	}
	static class ADBDMenuGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDMenuGameState>();
	}
};
static_assert(alignof(ADBDMenuGameState) == 0x000008, "Wrong alignment on ADBDMenuGameState");
static_assert(sizeof(ADBDMenuGameState) == 0x000870, "Wrong size on ADBDMenuGameState");
static_assert(offsetof(ADBDMenuGameState, _menuForcedLODHandler) == 0x000868, "Member 'ADBDMenuGameState::_menuForcedLODHandler' has a wrong offset!");

// Class DeadByDaylight.PhaseWalkingInterface
// 0x0000 (0x0000 - 0x0000)
class IPhaseWalkingInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PhaseWalkingInterface">();
	}
	static class IPhaseWalkingInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPhaseWalkingInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPhaseWalkingInterface) == 0x000001, "Wrong alignment on IPhaseWalkingInterface");
static_assert(sizeof(IPhaseWalkingInterface) == 0x000001, "Wrong size on IPhaseWalkingInterface");

// Class DeadByDaylight.DBDMenuSilhouette
// 0x0000 (0x0230 - 0x0230)
class ADBDMenuSilhouette final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDMenuSilhouette">();
	}
	static class ADBDMenuSilhouette* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDMenuSilhouette>();
	}
};
static_assert(alignof(ADBDMenuSilhouette) == 0x000008, "Wrong alignment on ADBDMenuSilhouette");
static_assert(sizeof(ADBDMenuSilhouette) == 0x000230, "Wrong size on ADBDMenuSilhouette");

// Class DeadByDaylight.NewContentPopupScreen
// 0x0000 (0x0140 - 0x0140)
class UNewContentPopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NewContentPopupScreen">();
	}
	static class UNewContentPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNewContentPopupScreen>();
	}
};
static_assert(alignof(UNewContentPopupScreen) == 0x000008, "Wrong alignment on UNewContentPopupScreen");
static_assert(sizeof(UNewContentPopupScreen) == 0x000140, "Wrong size on UNewContentPopupScreen");

// Class DeadByDaylight.DBDOnlineSessionClient
// 0x0028 (0x0228 - 0x0200)
class UDBDOnlineSessionClient final : public UOnlineSessionClient
{
public:
	uint8                                         Pad_200[0x28];                                     // 0x0200(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOnlineSessionClient">();
	}
	static class UDBDOnlineSessionClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOnlineSessionClient>();
	}
};
static_assert(alignof(UDBDOnlineSessionClient) == 0x000008, "Wrong alignment on UDBDOnlineSessionClient");
static_assert(sizeof(UDBDOnlineSessionClient) == 0x000228, "Wrong size on UDBDOnlineSessionClient");

// Class DeadByDaylight.OpenSupplyCrateInteraction
// 0x0020 (0x0760 - 0x0740)
class UOpenSupplyCrateInteraction final : public UChargeableInteractionDefinition
{
public:
	class ASupplyCrateInteractable*               _owningSupplyCrate;                                // 0x0740(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _interactionWasComplete;                           // 0x0748(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_749[0x7];                                      // 0x0749(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          _successExitTimeAnimSequenceReference;             // 0x0750(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_758[0x8];                                      // 0x0758(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpenSupplyCrateInteraction">();
	}
	static class UOpenSupplyCrateInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpenSupplyCrateInteraction>();
	}
};
static_assert(alignof(UOpenSupplyCrateInteraction) == 0x000010, "Wrong alignment on UOpenSupplyCrateInteraction");
static_assert(sizeof(UOpenSupplyCrateInteraction) == 0x000760, "Wrong size on UOpenSupplyCrateInteraction");
static_assert(offsetof(UOpenSupplyCrateInteraction, _owningSupplyCrate) == 0x000740, "Member 'UOpenSupplyCrateInteraction::_owningSupplyCrate' has a wrong offset!");
static_assert(offsetof(UOpenSupplyCrateInteraction, _interactionWasComplete) == 0x000748, "Member 'UOpenSupplyCrateInteraction::_interactionWasComplete' has a wrong offset!");
static_assert(offsetof(UOpenSupplyCrateInteraction, _successExitTimeAnimSequenceReference) == 0x000750, "Member 'UOpenSupplyCrateInteraction::_successExitTimeAnimSequenceReference' has a wrong offset!");

// Class DeadByDaylight.DBDOutlineComponentStencilConfiguration
// 0x0000 (0x00E8 - 0x00E8)
class UDBDOutlineComponentStencilConfiguration final : public UDBDOutlineComponentConfiguration
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDOutlineComponentStencilConfiguration">();
	}
	static class UDBDOutlineComponentStencilConfiguration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDOutlineComponentStencilConfiguration>();
	}
};
static_assert(alignof(UDBDOutlineComponentStencilConfiguration) == 0x000008, "Wrong alignment on UDBDOutlineComponentStencilConfiguration");
static_assert(sizeof(UDBDOutlineComponentStencilConfiguration) == 0x0000E8, "Wrong size on UDBDOutlineComponentStencilConfiguration");

// Class DeadByDaylight.ObjectPlacementUpdateStrategy
// 0x0020 (0x0050 - 0x0030)
class UObjectPlacementUpdateStrategy : public UObject
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPlacementUpdateStrategy">();
	}
	static class UObjectPlacementUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectPlacementUpdateStrategy>();
	}
};
static_assert(alignof(UObjectPlacementUpdateStrategy) == 0x000008, "Wrong alignment on UObjectPlacementUpdateStrategy");
static_assert(sizeof(UObjectPlacementUpdateStrategy) == 0x000050, "Wrong size on UObjectPlacementUpdateStrategy");

// Class DeadByDaylight.BufferLastValidLocationObjectPlacementStrategy
// 0x0008 (0x0058 - 0x0050)
class UBufferLastValidLocationObjectPlacementStrategy final : public UObjectPlacementUpdateStrategy
{
public:
	float                                         _maxDistanceToOwner;                               // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BufferLastValidLocationObjectPlacementStrategy">();
	}
	static class UBufferLastValidLocationObjectPlacementStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBufferLastValidLocationObjectPlacementStrategy>();
	}
};
static_assert(alignof(UBufferLastValidLocationObjectPlacementStrategy) == 0x000008, "Wrong alignment on UBufferLastValidLocationObjectPlacementStrategy");
static_assert(sizeof(UBufferLastValidLocationObjectPlacementStrategy) == 0x000058, "Wrong size on UBufferLastValidLocationObjectPlacementStrategy");
static_assert(offsetof(UBufferLastValidLocationObjectPlacementStrategy, _maxDistanceToOwner) == 0x000050, "Member 'UBufferLastValidLocationObjectPlacementStrategy::_maxDistanceToOwner' has a wrong offset!");

// Class DeadByDaylight.DBDParadiseGameMode
// 0x0000 (0x0360 - 0x0360)
class ADBDParadiseGameMode final : public ADBDBaseGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDParadiseGameMode">();
	}
	static class ADBDParadiseGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDParadiseGameMode>();
	}
};
static_assert(alignof(ADBDParadiseGameMode) == 0x000008, "Wrong alignment on ADBDParadiseGameMode");
static_assert(sizeof(ADBDParadiseGameMode) == 0x000360, "Wrong size on ADBDParadiseGameMode");

// Class DeadByDaylight.DBDPawnSensingComponent
// 0x0008 (0x0108 - 0x0100)
class UDBDPawnSensingComponent final : public UPawnSensingComponent
{
public:
	bool                                          bSenseEverywhere;                                  // 0x0100(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PartiallyHiddenSensingDistance;                    // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPawnSensingComponent">();
	}
	static class UDBDPawnSensingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPawnSensingComponent>();
	}
};
static_assert(alignof(UDBDPawnSensingComponent) == 0x000008, "Wrong alignment on UDBDPawnSensingComponent");
static_assert(sizeof(UDBDPawnSensingComponent) == 0x000108, "Wrong size on UDBDPawnSensingComponent");
static_assert(offsetof(UDBDPawnSensingComponent, bSenseEverywhere) == 0x000100, "Member 'UDBDPawnSensingComponent::bSenseEverywhere' has a wrong offset!");
static_assert(offsetof(UDBDPawnSensingComponent, PartiallyHiddenSensingDistance) == 0x000104, "Member 'UDBDPawnSensingComponent::PartiallyHiddenSensingDistance' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerCameraManager
// 0x0020 (0x2840 - 0x2820)
class ADBDPlayerCameraManager final : public APlayerCameraManager
{
public:
	float                                         NormalFOV;                                         // 0x2820(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetingFOV;                                      // 0x2824(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IViewRotationStrategy> _viewRotationStrategy;                             // 0x2828(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2838[0x8];                                     // 0x2838(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartFadeInTimeline(float duration);
	void StartFadeOutTimeline(float duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerCameraManager">();
	}
	static class ADBDPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerCameraManager>();
	}
};
static_assert(alignof(ADBDPlayerCameraManager) == 0x000010, "Wrong alignment on ADBDPlayerCameraManager");
static_assert(sizeof(ADBDPlayerCameraManager) == 0x002840, "Wrong size on ADBDPlayerCameraManager");
static_assert(offsetof(ADBDPlayerCameraManager, NormalFOV) == 0x002820, "Member 'ADBDPlayerCameraManager::NormalFOV' has a wrong offset!");
static_assert(offsetof(ADBDPlayerCameraManager, TargetingFOV) == 0x002824, "Member 'ADBDPlayerCameraManager::TargetingFOV' has a wrong offset!");
static_assert(offsetof(ADBDPlayerCameraManager, _viewRotationStrategy) == 0x002828, "Member 'ADBDPlayerCameraManager::_viewRotationStrategy' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerController
// 0x0218 (0x0888 - 0x0670)
class ADBDPlayerController final : public ADBDPlayerControllerBase
{
public:
	TMulticastInlineDelegate<void(class ADBDPlayer* leavingPlayer)> OnPawnLeavingGame;               // 0x0670(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnLocallyObservedChanged;                          // 0x0680(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_690[0x98];                                     // 0x0690(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class ANetworkFenceActor*                     _theFence;                                         // 0x0728(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_730[0x8];                                      // 0x0730(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDBaseInputHandler*                   _inputHandler;                                     // 0x0738(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_740[0x130];                                    // 0x0740(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  _aiPawn;                                           // 0x0870(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_878[0x8];                                      // 0x0878(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EPlayerRole                                   _controllerGameRole;                               // 0x0880(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_881[0x7];                                      // 0x0881(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateAI(bool activate, int32 playerRank);
	void Client_SetPlayerFinishStats(const struct FPlayerFinishStats& stats);
	void Client_SetSpectatorMode(bool on);
	void Client_SetSpectatorModeInEditor(bool on, class ADBDPlayerState* spectatingPlayerState);
	void Client_SpectateAI(class APawn* aiPawn);
	void ImplementRunLockMechanic();
	void OnRep_Fence();
	void Server_ActivateAI(bool activate, int32 playerRank);
	void Server_ActivateAIAll(bool activate, int32 playerRank, int8 playerRole);
	void Server_ClientTimeSinceLastLoadingProgress(float lastProgression);
	void Server_DebugSend(const class FString& data);
	void Server_LeaveGame(bool joiningLobby);
	void Server_RequestEndGame();
	void Server_SetHasMoveInputThisFrame(bool hasMoveInputThisFrame);
	void Server_SetReadyToTravel();
	void Server_SetSpectatorMode(bool on);
	void Server_SetSpectatorModeInEditor(bool on, class ADBDPlayerState* spectatingPlayerState);
	void ServerViewPlayer(const class FString& playerName);
	void SetShouldMoveInputReplicateToServer(bool shouldReplicate);

	class APawn* GetAIPawn() const;
	class ADBDPlayer* GetControlledPlayer() const;
	class ADBDPlayer* GetSpectatedPlayer() const;
	class ADBDPlayerState* GetSpectatedPlayerState() const;
	bool IsSpectating() const;
	bool MobileJoystickInput_Pressed(int32 joystickIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerController">();
	}
	static class ADBDPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerController>();
	}
};
static_assert(alignof(ADBDPlayerController) == 0x000008, "Wrong alignment on ADBDPlayerController");
static_assert(sizeof(ADBDPlayerController) == 0x000888, "Wrong size on ADBDPlayerController");
static_assert(offsetof(ADBDPlayerController, OnPawnLeavingGame) == 0x000670, "Member 'ADBDPlayerController::OnPawnLeavingGame' has a wrong offset!");
static_assert(offsetof(ADBDPlayerController, OnLocallyObservedChanged) == 0x000680, "Member 'ADBDPlayerController::OnLocallyObservedChanged' has a wrong offset!");
static_assert(offsetof(ADBDPlayerController, _theFence) == 0x000728, "Member 'ADBDPlayerController::_theFence' has a wrong offset!");
static_assert(offsetof(ADBDPlayerController, _inputHandler) == 0x000738, "Member 'ADBDPlayerController::_inputHandler' has a wrong offset!");
static_assert(offsetof(ADBDPlayerController, _aiPawn) == 0x000870, "Member 'ADBDPlayerController::_aiPawn' has a wrong offset!");
static_assert(offsetof(ADBDPlayerController, _controllerGameRole) == 0x000880, "Member 'ADBDPlayerController::_controllerGameRole' has a wrong offset!");

// Class DeadByDaylight.CoopRepairTracker
// 0x0010 (0x0040 - 0x0030)
class UCoopRepairTracker final : public UObject
{
public:
	TArray<class ADBDPlayer*>                     _coopRepairerHistory;                              // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void SetHasEverCoopRepaired(const class ADBDPlayer* player);

	bool HasEverCoopRepaired(const class ADBDPlayer* player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoopRepairTracker">();
	}
	static class UCoopRepairTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoopRepairTracker>();
	}
};
static_assert(alignof(UCoopRepairTracker) == 0x000008, "Wrong alignment on UCoopRepairTracker");
static_assert(sizeof(UCoopRepairTracker) == 0x000040, "Wrong size on UCoopRepairTracker");
static_assert(offsetof(UCoopRepairTracker, _coopRepairerHistory) == 0x000030, "Member 'UCoopRepairTracker::_coopRepairerHistory' has a wrong offset!");

// Class DeadByDaylight.DBDPlayerLevelManager
// 0x0168 (0x0198 - 0x0030)
class UDBDPlayerLevelManager final : public UObject
{
public:
	uint8                                         Pad_30[0x168];                                     // 0x0030(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerLevelManager">();
	}
	static class UDBDPlayerLevelManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDPlayerLevelManager>();
	}
};
static_assert(alignof(UDBDPlayerLevelManager) == 0x000008, "Wrong alignment on UDBDPlayerLevelManager");
static_assert(sizeof(UDBDPlayerLevelManager) == 0x000198, "Wrong size on UDBDPlayerLevelManager");

// Class DeadByDaylight.DBDPlayerStart
// 0x0008 (0x0270 - 0x0268)
class ADBDPlayerStart final : public APlayerStart
{
public:
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerStart">();
	}
	static class ADBDPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerStart>();
	}
};
static_assert(alignof(ADBDPlayerStart) == 0x000008, "Wrong alignment on ADBDPlayerStart");
static_assert(sizeof(ADBDPlayerStart) == 0x000270, "Wrong size on ADBDPlayerStart");

// Class DeadByDaylight.GeneratorTrapIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UGeneratorTrapIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorTrapIconStrategy">();
	}
	static class UGeneratorTrapIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorTrapIconStrategy>();
	}
};
static_assert(alignof(UGeneratorTrapIconStrategy) == 0x000008, "Wrong alignment on UGeneratorTrapIconStrategy");
static_assert(sizeof(UGeneratorTrapIconStrategy) == 0x000038, "Wrong size on UGeneratorTrapIconStrategy");

// Class DeadByDaylight.DBDPlayerState_Lobby
// 0x0008 (0x0730 - 0x0728)
class ADBDPlayerState_Lobby final : public ADBDPlayerState_Menu
{
public:
	bool                                          IsOwnershipValidated;                              // 0x0728(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_729[0x7];                                      // 0x0729(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDPlayerState_Lobby">();
	}
	static class ADBDPlayerState_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDPlayerState_Lobby>();
	}
};
static_assert(alignof(ADBDPlayerState_Lobby) == 0x000008, "Wrong alignment on ADBDPlayerState_Lobby");
static_assert(sizeof(ADBDPlayerState_Lobby) == 0x000730, "Wrong size on ADBDPlayerState_Lobby");
static_assert(offsetof(ADBDPlayerState_Lobby, IsOwnershipValidated) == 0x000728, "Member 'ADBDPlayerState_Lobby::IsOwnershipValidated' has a wrong offset!");

// Class DeadByDaylight.HookableComponent
// 0x00A0 (0x0158 - 0x00B8)
class UHookableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xA0];                                      // 0x00B8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_DebugSetHookDrainStage(int32 drainStage);
	void Authority_DebugSetHookEscapeAutoFail(const bool fail);
	void Authority_DebugSetHookEscapeAutoSuccess(const bool success);
	void Authority_SetDrainTimerPercentLeft(float percentTime);
	void Multicast_DebugSetHookDrainStage(int32 drainStage);
	void Multicast_SetDrainTimerPercentLeft(float percentTime);

	float GetDrainTimerPercentLeft() const;
	int32 GetHookedCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HookableComponent">();
	}
	static class UHookableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHookableComponent>();
	}
};
static_assert(alignof(UHookableComponent) == 0x000008, "Wrong alignment on UHookableComponent");
static_assert(sizeof(UHookableComponent) == 0x000158, "Wrong size on UHookableComponent");

// Class DeadByDaylight.DBDProjectileUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDProjectileUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UAuthoritativePoolProjectileProviderAdapter* CreateProjectilePoolAdapter(class UObject* outer, class UAuthoritativeActorPoolComponent* pool);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDProjectileUtilities">();
	}
	static class UDBDProjectileUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDProjectileUtilities>();
	}
};
static_assert(alignof(UDBDProjectileUtilities) == 0x000008, "Wrong alignment on UDBDProjectileUtilities");
static_assert(sizeof(UDBDProjectileUtilities) == 0x000030, "Wrong size on UDBDProjectileUtilities");

// Class DeadByDaylight.DBDRemotePlayer
// 0x0000 (0x1C68 - 0x1C68)
class UDBDRemotePlayer final : public UIpConnection
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDRemotePlayer">();
	}
	static class UDBDRemotePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDRemotePlayer>();
	}
};
static_assert(alignof(UDBDRemotePlayer) == 0x000008, "Wrong alignment on UDBDRemotePlayer");
static_assert(sizeof(UDBDRemotePlayer) == 0x001C68, "Wrong size on UDBDRemotePlayer");

// Class DeadByDaylight.K31UIDataInterface
// 0x0000 (0x0000 - 0x0000)
class IK31UIDataInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K31UIDataInterface">();
	}
	static class IK31UIDataInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IK31UIDataInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IK31UIDataInterface) == 0x000001, "Wrong alignment on IK31UIDataInterface");
static_assert(sizeof(IK31UIDataInterface) == 0x000001, "Wrong size on IK31UIDataInterface");

// Class DeadByDaylight.DBDHostSettingsParamsJoinabilityPreset
// 0x0008 (0x0048 - 0x0040)
class UDBDHostSettingsParamsJoinabilityPreset final : public UDBDHostSettingsParamsBase
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDHostSettingsParamsJoinabilityPreset">();
	}
	static class UDBDHostSettingsParamsJoinabilityPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDHostSettingsParamsJoinabilityPreset>();
	}
};
static_assert(alignof(UDBDHostSettingsParamsJoinabilityPreset) == 0x000008, "Wrong alignment on UDBDHostSettingsParamsJoinabilityPreset");
static_assert(sizeof(UDBDHostSettingsParamsJoinabilityPreset) == 0x000048, "Wrong size on UDBDHostSettingsParamsJoinabilityPreset");

// Class DeadByDaylight.ChainLinkable
// 0x0000 (0x0000 - 0x0000)
class IChainLinkable final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChainLinkable">();
	}
	static class IChainLinkable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChainLinkable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IChainLinkable) == 0x000001, "Wrong alignment on IChainLinkable");
static_assert(sizeof(IChainLinkable) == 0x000001, "Wrong size on IChainLinkable");

// Class DeadByDaylight.DBDServerInstance
// 0x0080 (0x00B0 - 0x0030)
class UDBDServerInstance final : public UObject
{
public:
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDBDHostSettingsParamsBase*>     _pendingSessionUpdates;                            // 0x0098(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x00A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDServerInstance">();
	}
	static class UDBDServerInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDServerInstance>();
	}
};
static_assert(alignof(UDBDServerInstance) == 0x000008, "Wrong alignment on UDBDServerInstance");
static_assert(sizeof(UDBDServerInstance) == 0x0000B0, "Wrong size on UDBDServerInstance");
static_assert(offsetof(UDBDServerInstance, _pendingSessionUpdates) == 0x000098, "Member 'UDBDServerInstance::_pendingSessionUpdates' has a wrong offset!");
static_assert(offsetof(UDBDServerInstance, _gameInstance) == 0x0000A8, "Member 'UDBDServerInstance::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.DBDSlasherData
// 0x0008 (0x0150 - 0x0148)
class UDBDSlasherData final : public UDBDPlayerData
{
public:
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSlasherData">();
	}
	static class UDBDSlasherData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSlasherData>();
	}
};
static_assert(alignof(UDBDSlasherData) == 0x000008, "Wrong alignment on UDBDSlasherData");
static_assert(sizeof(UDBDSlasherData) == 0x000150, "Wrong size on UDBDSlasherData");

// Class DeadByDaylight.DBDSpecialEventUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDSpecialEventUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool DoesPlayerHasEventOffering(class ADBDPlayer* player, EOfferingEffectType offeringEffectType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSpecialEventUtilities">();
	}
	static class UDBDSpecialEventUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSpecialEventUtilities>();
	}
};
static_assert(alignof(UDBDSpecialEventUtilities) == 0x000008, "Wrong alignment on UDBDSpecialEventUtilities");
static_assert(sizeof(UDBDSpecialEventUtilities) == 0x000030, "Wrong size on UDBDSpecialEventUtilities");

// Class DeadByDaylight.DBDSpringArmComponent
// 0x0080 (0x0320 - 0x02A0)
class UDBDSpringArmComponent final : public USpringArmComponent
{
public:
	uint8                                         bEnableComponentwiseCameraLag : 1;                 // 0x02A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ComponenwiseCameraLagSpeed;                        // 0x02A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetArmMinLength;                                // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnableDistanceCameraLag : 1;                      // 0x02B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2B5[0x3];                                      // 0x02B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraDistanceLagSpeed;                            // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDrawDebugTraceMarkers : 1;                        // 0x02C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          IgnoreActors;                                      // 0x02C8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x48];                                     // 0x02D8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearIgnoreActors();
	void IgnoreActor(class AActor* Actor, bool bShouldIgnore);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSpringArmComponent">();
	}
	static class UDBDSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSpringArmComponent>();
	}
};
static_assert(alignof(UDBDSpringArmComponent) == 0x000010, "Wrong alignment on UDBDSpringArmComponent");
static_assert(sizeof(UDBDSpringArmComponent) == 0x000320, "Wrong size on UDBDSpringArmComponent");
static_assert(offsetof(UDBDSpringArmComponent, ComponenwiseCameraLagSpeed) == 0x0002A4, "Member 'UDBDSpringArmComponent::ComponenwiseCameraLagSpeed' has a wrong offset!");
static_assert(offsetof(UDBDSpringArmComponent, TargetArmMinLength) == 0x0002B0, "Member 'UDBDSpringArmComponent::TargetArmMinLength' has a wrong offset!");
static_assert(offsetof(UDBDSpringArmComponent, CameraDistanceLagSpeed) == 0x0002B8, "Member 'UDBDSpringArmComponent::CameraDistanceLagSpeed' has a wrong offset!");
static_assert(offsetof(UDBDSpringArmComponent, IgnoreActors) == 0x0002C8, "Member 'UDBDSpringArmComponent::IgnoreActors' has a wrong offset!");

// Class DeadByDaylight.DBDSurfaceTypeName
// 0x0000 (0x0030 - 0x0030)
class UDBDSurfaceTypeName final : public UBlueprintFunctionLibrary
{
public:
	static class FName Convert(const EPhysicalSurface surfaceType);
	static class FName ConvertFromPhysicalMaterial(const class UPhysicalMaterial* material);
	static class FString GetSurfaceName(const class UPhysicalMaterial* physicalMaterial);
	static EPhysicalSurface GetSurfaceType(const class UPhysicalMaterial* physicalMaterial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDSurfaceTypeName">();
	}
	static class UDBDSurfaceTypeName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDSurfaceTypeName>();
	}
};
static_assert(alignof(UDBDSurfaceTypeName) == 0x000008, "Wrong alignment on UDBDSurfaceTypeName");
static_assert(sizeof(UDBDSurfaceTypeName) == 0x000030, "Wrong size on UDBDSurfaceTypeName");

// Class DeadByDaylight.PlayerOverlapHISMComponent
// 0x0010 (0x0720 - 0x0710)
class UPlayerOverlapHISMComponent final : public UHISMMaterialHelperComponent
{
public:
	int32                                         _playerInfluenceRadius;                            // 0x0708(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70C[0x4];                                      // 0x070C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             _playerOverlapOverrides;                           // 0x0710(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerOverlapHISMComponent">();
	}
	static class UPlayerOverlapHISMComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerOverlapHISMComponent>();
	}
};
static_assert(alignof(UPlayerOverlapHISMComponent) == 0x000010, "Wrong alignment on UPlayerOverlapHISMComponent");
static_assert(sizeof(UPlayerOverlapHISMComponent) == 0x000720, "Wrong size on UPlayerOverlapHISMComponent");
static_assert(offsetof(UPlayerOverlapHISMComponent, _playerInfluenceRadius) == 0x000708, "Member 'UPlayerOverlapHISMComponent::_playerInfluenceRadius' has a wrong offset!");
static_assert(offsetof(UPlayerOverlapHISMComponent, _playerOverlapOverrides) == 0x000710, "Member 'UPlayerOverlapHISMComponent::_playerOverlapOverrides' has a wrong offset!");

// Class DeadByDaylight.DBDTimerComponent
// 0x0030 (0x00E8 - 0x00B8)
class UDBDTimerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Pause();
	void Reset();
	void ResetTo(float time);
	void Stop();
	void Unpause();
	void Update(float deltaTime);

	float GetPercentTimeElapsed() const;
	float GetPercentTimeLeft() const;
	float GetStartTime() const;
	float GetTimeElapsed() const;
	float GetTimeLeft() const;
	bool IsDone() const;
	bool IsOnPause() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTimerComponent">();
	}
	static class UDBDTimerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTimerComponent>();
	}
};
static_assert(alignof(UDBDTimerComponent) == 0x000008, "Wrong alignment on UDBDTimerComponent");
static_assert(sizeof(UDBDTimerComponent) == 0x0000E8, "Wrong size on UDBDTimerComponent");

// Class DeadByDaylight.DBDTunableUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDTunableUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float GetEndGameTunableValue(class UObject* worldContextObject, class FName valueName);
	static float GetSlasherTunableValue(class UObject* worldContextObject, class FName valueName);
	static float GetTunableRowHandleValue(const struct FDBDTunableRowHandle& rowHandle);
	static float GetTunableValue(const class UObject* worldContextObject, class FName valueName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTunableUtilities">();
	}
	static class UDBDTunableUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTunableUtilities>();
	}
};
static_assert(alignof(UDBDTunableUtilities) == 0x000008, "Wrong alignment on UDBDTunableUtilities");
static_assert(sizeof(UDBDTunableUtilities) == 0x000030, "Wrong size on UDBDTunableUtilities");

// Class DeadByDaylight.DBDUtilities
// 0x0000 (0x0030 - 0x0030)
class UDBDUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UActorComponent* AddComponentToActor(class UClass* compClass, class FName compName, class AActor* actor);
	static bool BoxTraceAgainstActor(const struct FVector& start, const struct FVector& end, const class UBoxComponent* box, const class AActor* actor, struct FHitResult* outHitResult);
	static void CrashGameCausingInterrupt();
	static bool DBDCapsuleTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, ECollisionChannel TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf);
	static void DBDLoadAudioBank(class UAkAudioBank* bank, class AActor* caller);
	static void DBDLoadAudioBankAsync(class UAkAudioBank* bank, class AActor* caller);
	static class UObject* DBDLoadAudioBankByAssetPtr(TSoftObjectPtr<class UAkAudioBank> bank, class AActor* caller);
	static float DistanceFromPointToPane(const struct FVector& point, const struct FPlane& plane);
	static bool FindFloorSingle(class UObject* WorldContextObject, const struct FVector& location, float raycastLength, struct FHitResult* outHit);
	static class AActor* FindParentOfClass(class AActor* InChild, class UClass* InClass);
	static EShadowSystem GetActiveShadowSystem();
	static class FString GetActorOwnerName(class AActor* actor);
	static void GetActorSpawners(TArray<class UActorSpawner*>* actorSpawners);
	static float GetAnimSequenceLength(const class UAnimSequence* sequence);
	static class AProceduralLevelBuilder* GetBuilder(const class UObject* WorldContextObject);
	static struct FVector GetClosestPointOnOrbit(const struct FVector& centerPoint, const struct FVector& orbitterPosition, const float distance);
	static struct FTransform GetClosestSnapTransformOnOrbit(const struct FVector& centerPoint, const struct FVector& orbitterPosition, const float distance);
	static class FString GetComponentOwnerName(class UActorComponent* actorComponent);
	static class ADBDAIPlayerController* GetDBDAIPlayerController(class ADBDPlayer* player);
	static class UDBDGameInstance* GetDBDGameInstance(const class UObject* WorldContextObject);
	static class ADBDGameMode* GetDBDGameMode(const class UObject* worldContextObject);
	static class ADBDGameState* GetDBDGameState(const class UObject* worldContextObject);
	static float GetDistanceToNearestHookedSurvivor(const class ADBDPlayer* player);
	static float GetEndGameTunableValue(class UObject* worldContextObject, class FName valueName);
	static class AActor* GetFirstActorWithTag(class FName tag, const TArray<class AActor*>& actorsArray);
	static struct FVector GetFloorLocationAt(class UObject* WorldContextObject, const struct FVector& location, float raycastStartHeight, float raycastEndHeight, bool useComplex);
	static class FString GetFormattedNumberString(float value, int32 maxDecimals, int32 minDecimals, bool leadingZero);
	static class FText GetFormattedNumberText(float value, int32 maxDecimals, int32 minDecimals, bool leadingZero);
	static ECollisionChannel GetImpactCollisionObjectType(const class UPrimitiveComponent* primitive);
	static struct FCollisionResponseContainer GetImpactCollisionResponseContainer(const class UPrimitiveComponent* primitive);
	static int32 GetInventoryCount(class UObject* worldContextObject, int32 characterIndex, class FName itemID);
	static int32 GetInventoryCountForMultipleCharacters(class UObject* worldContextObject, const TArray<int32>& characterIndexes, class FName itemID);
	static class ADBDPlayerCameraManager* GetLocalDBDCameraManager(class UObject* WorldContextObject);
	static class ADBDPlayerControllerBase* GetLocalDBDPlayerController(const class UObject* WorldContextObject);
	static class ADBDPlayer* GetLocallyControlledCharacter(const class UObject* WorldContextObject);
	static EPlayerRole GetLocallyControlledCharacterRole(const class UObject* WorldContextObject);
	static class ASlasherPlayer* GetLocallyControlledKiller(const class UObject* WorldContextObject);
	static class ACamperPlayer* GetLocallyControlledSurvivor(const class UObject* WorldContextObject);
	static class ADBDPlayer* GetLocallyObservedCharacter(const class UObject* WorldContextObject);
	static EPlayerRole GetLocallyObservedCharacterRole(const class UObject* WorldContextObject);
	static class FString GetLogStringMaterialInfo(const class FString& inStr, const class UMaterialInterface* root);
	static TArray<class UMaterialHelper*> GetMaterialHelpersAttachedToPlayerMesh(const class ADBDPlayer* player);
	static float GetMontageLength(class UAnimMontage* montage);
	static bool GetNearbyActorsOfType(class UWorld* world, const struct FVector& center, float radius, TArray<class AActor*>* outNearbyActors, class UClass* actorClassType, ECollisionChannel collisionChannel, class AActor* ignoreActor);
	static void GetNearbyCampers(class UWorld* world, const struct FVector& center, float radius, TArray<class ACamperPlayer*>* outNearbyCampers, const TArray<class AActor*>& ignoredCampers);
	static class AActor* GetOuterMostActor(const class UAnimInstance* animInstance);
	static class ACamperPlayer* GetOwningCamper(const class UAnimInstance* animInstance);
	static class ADBDBasePlayer* GetOwningDBDBasePlayer(const class UAnimInstance* animInstance);
	static class ASlasherPlayer* GetOwningSlasher(const class UAnimInstance* animInstance);
	static float GetPercentOfRange(const float val, const float min_0, const float max_0);
	static float GetPlayRateForMontage(class UAnimMontage* montage, float time);
	static struct FVector GetSimilarVector(const struct FVector& vector, float maximumDeviation);
	static float GetSlasherTunableValue(class UObject* WorldContextObject, class FName valueName);
	static float GetSquaredDistanceToKiller(const class AActor* survivor);
	static TArray<class AGenerator*> GetThreeClosestGenerators(const TArray<class AGenerator*>& unrevealedGenerators);
	static void GetTileSpawnPoints(TArray<class UTileSpawnPoint*>* tileSpawnPoints);
	static struct FTimespan GetTotalPlaytime(const class UObject* worldContextObject, bool update);
	static float GetVelocityXYAngleDegrees(const class AActor* actor);
	static struct FVector GetXYVector(const struct FVector& vector);
	static struct FRotator GetYawOnly(const struct FRotator& rotation);
	static bool HasFloorForward(class UObject* WorldContextObject, const struct FVector& location, const struct FVector& fowardVector, float distance, float raycastStartHeight, float raycastEndHeight, TArray<struct FHitResult>* outHits, struct FVector* raycastStart);
	static bool HasLineOfSightToTarget(class UObject* WorldContextObject, const struct FVector& startPosition, const struct FVector& targetPosition, const class AActor* ignoredActor, const bool useComplex, const bool useDebugLogs);
	static bool HasWalkableSurfaceForward(class UObject* WorldContextObject, const struct FVector& location, const struct FVector& fowardVector, float distance, float raycastStartHeight, float raycastEndHeight, TArray<struct FHitResult>* outHits, struct FVector* raycastStart);
	static bool IsInKillerTeam(const class UObject* WorldContextObject);
	static bool IsInSurvivorTeam(const class UObject* WorldContextObject);
	static bool IsInTutorialLevel();
	static bool IsLocallyObservingAKiller(const class UObject* WorldContextObject);
	static bool IsLocallyObservingASurvivor(const class UObject* WorldContextObject);
	static bool IsNonViolent();
	static bool IsReplaceDisconnectedPlayersWithBotsActive();
	static bool IsServer(const class UObject* worldContextObject);
	static bool IsSteamPIEGame(const class UObject* contextObject);
	static void LogMeshMaterialInfo(const class FString& inStr, const class UMeshComponent* root);
	static void LogString(const class FString& inStr);
	static bool NormalizeXY(struct FVector* vector, float tolerance);
	static int64 PointerToInt(class UObject* obj);
	static void PrintStringEmbiggened(class UObject* WorldContextObject, const class FString& InString, const struct FLinearColor& TextColor, float Duration, int32 Key, float Scale);
	static int32 ResolveCharacterIdFromPlayerState(const class ADBDPlayerState* playerState);
	static void SetComponentCastHiddenShadow(class UPrimitiveComponent* component, bool castShadow);
	static bool SphereTraceAgainstActor(const struct FVector& start, const struct FVector& end, const class USphereComponent* sphere, const class AActor* actor, struct FHitResult* outHitResult);
	static bool SphereTraceSingle(const struct FVector& start, const struct FVector& end, const class USphereComponent* sphere, struct FHitResult* outHitResult, const TArray<class AActor*>& ignoredActors);
	static float ToAngle_negative180to180(float angle);
	static bool WithinRange(float min_0, float max_0, float value);
	static bool WithinRangeExclusive(float min_0, float max_0, float value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDUtilities">();
	}
	static class UDBDUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDUtilities>();
	}
};
static_assert(alignof(UDBDUtilities) == 0x000008, "Wrong alignment on UDBDUtilities");
static_assert(sizeof(UDBDUtilities) == 0x000030, "Wrong size on UDBDUtilities");

// Class DeadByDaylight.UMGInboxScreen
// 0x00A8 (0x03E0 - 0x0338)
class UUMGInboxScreen final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0xA8];                                     // 0x0338(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ButtonClickEvent(EInboxScreenButton buttonid);
	void ClaimAllMessagesEvent(EInboxMessageUIType messageType);
	void ClaimMessageEvent(const class FString& messageId);
	void CleanAllMessagesEvent(EInboxMessageUIType messageType);
	void CleanMessageEvent(const class FString& messageId);
	class UUMGInboxMessageEntryWidget* FindMessageWidgetById(class UPanelWidget* containingPanel, const class FString& messageId);
	int32 FindWidgetIndexByMessageId(class UPanelWidget* containingPanel, const class FString& messageId);
	void ReadAllMessagesEvent(EInboxMessageUIType messageType);
	void ReadMessageEvent(const class FString& messageId);
	void RemoveMessage(const class FString& messageId);
	bool RemoveMessageFromPanel(class UPanelWidget* containingPanel, const class FString& messageId, bool hasSeparator);
	void SetNewsMessages(const TArray<struct FInboxMessageUIData>& messages, int32 unreadCount, int32 totalCount);
	void SetRewardsMessages(const TArray<struct FInboxMessageUIData>& messages, int32 unclaimedCount, int32 unreadCount, int32 totalCount);
	void SetSocialMessages(const TArray<struct FInboxMessageUIData>& messages, int32 unreadCount, int32 totalCount);
	void UpdateMessage(const struct FInboxMessageUIData& message);
	void UpdateMessagesCount(EInboxMessageUIType messageType, int32 unclaimedCount, int32 unreadCount, int32 totalCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGInboxScreen">();
	}
	static class UUMGInboxScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGInboxScreen>();
	}
};
static_assert(alignof(UUMGInboxScreen) == 0x000008, "Wrong alignment on UUMGInboxScreen");
static_assert(sizeof(UUMGInboxScreen) == 0x0003E0, "Wrong size on UUMGInboxScreen");

// Class DeadByDaylight.DBDUtilTimer
// 0x0000 (0x0030 - 0x0030)
class UDBDUtilTimer final : public UBlueprintFunctionLibrary
{
public:
	static float GetPercentTimeElapsed(const struct FDBDTimer& Timer);
	static float GetPercentTimeLeft(const struct FDBDTimer& Timer);
	static float GetStartTime(const struct FDBDTimer& Timer);
	static float GetTimeElapsed(const struct FDBDTimer& Timer);
	static float GetTimeLeft(const struct FDBDTimer& Timer);
	static bool IsDone(const struct FDBDTimer& Timer);
	static void Reset(struct FDBDTimer& Timer);
	static void ResetTo(struct FDBDTimer& Timer, float time);
	static void Stop(struct FDBDTimer& Timer);
	static void Update(struct FDBDTimer& Timer, float deltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDUtilTimer">();
	}
	static class UDBDUtilTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDUtilTimer>();
	}
};
static_assert(alignof(UDBDUtilTimer) == 0x000008, "Wrong alignment on UDBDUtilTimer");
static_assert(sizeof(UDBDUtilTimer) == 0x000030, "Wrong size on UDBDUtilTimer");

// Class DeadByDaylight.DeadByDaylightGameMode
// 0x0000 (0x0328 - 0x0328)
class ADeadByDaylightGameMode final : public AGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeadByDaylightGameMode">();
	}
	static class ADeadByDaylightGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeadByDaylightGameMode>();
	}
};
static_assert(alignof(ADeadByDaylightGameMode) == 0x000008, "Wrong alignment on ADeadByDaylightGameMode");
static_assert(sizeof(ADeadByDaylightGameMode) == 0x000328, "Wrong size on ADeadByDaylightGameMode");

// Class DeadByDaylight.DecalCollection
// 0x0120 (0x0150 - 0x0030)
class UDecalCollection final : public UObject
{
public:
	TArray<class UDBDDecalComponent*>             _decalComponentsArray;                             // 0x0030(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UDBDDecalComponent*>               _activeDecalComponents;                            // 0x0040(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class UDBDDecalComponent*>               _inactiveDecalComponents;                          // 0x0090(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<bool>                                  _DeltaZPool;                                       // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class UStaticMeshComponent*, int32>      _deltaZMultipliers;                                // 0x00F0(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x8];                                      // 0x0140(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalMaskedMaterialsList*              _decalProperties;                                  // 0x0148(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecalCollection">();
	}
	static class UDecalCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecalCollection>();
	}
};
static_assert(alignof(UDecalCollection) == 0x000008, "Wrong alignment on UDecalCollection");
static_assert(sizeof(UDecalCollection) == 0x000150, "Wrong size on UDecalCollection");
static_assert(offsetof(UDecalCollection, _decalComponentsArray) == 0x000030, "Member 'UDecalCollection::_decalComponentsArray' has a wrong offset!");
static_assert(offsetof(UDecalCollection, _activeDecalComponents) == 0x000040, "Member 'UDecalCollection::_activeDecalComponents' has a wrong offset!");
static_assert(offsetof(UDecalCollection, _inactiveDecalComponents) == 0x000090, "Member 'UDecalCollection::_inactiveDecalComponents' has a wrong offset!");
static_assert(offsetof(UDecalCollection, _DeltaZPool) == 0x0000E0, "Member 'UDecalCollection::_DeltaZPool' has a wrong offset!");
static_assert(offsetof(UDecalCollection, _deltaZMultipliers) == 0x0000F0, "Member 'UDecalCollection::_deltaZMultipliers' has a wrong offset!");
static_assert(offsetof(UDecalCollection, _decalProperties) == 0x000148, "Member 'UDecalCollection::_decalProperties' has a wrong offset!");

// Class DeadByDaylight.HudScreen
// 0x05C8 (0x06E8 - 0x0120)
class UHudScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0xD8];                                     // 0x0120(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UCoreHudRootWidget*                     _rootWidget;                                       // 0x01F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0xE0];                                     // 0x0200(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	class ATutorialsUtilities*                    _tutorialsUtilities;                               // 0x02E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TScriptInterface<class IPlayerStatusViewInterface>> _playerStatusInterfaces;              // 0x02E8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FInteractionProgressViewData           _interactionProgressViewData;                      // 0x02F8(0x0068)(Transient, NativeAccessSpecifierPrivate)
	struct FItemBundleViewData                    _itemBundleViewData;                               // 0x0360(0x0160)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x50];                                     // 0x04C0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPowerBundleViewData                   _powerBundleViewData;                              // 0x0510(0x0158)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FPlayerStatusViewData>          _playerStatusViewData;                             // 0x0668(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_678[0x70];                                     // 0x0678(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHemorrhageAnimationComplete();
	void OnHideStartSequenceCompleted();
	void OnHUDWidgetFadeOutCompleted();
	void OnTutorialHudFadeInTriggered();
	void OnTutorialHudFadeOutTriggered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudScreen">();
	}
	static class UHudScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHudScreen>();
	}
};
static_assert(alignof(UHudScreen) == 0x000008, "Wrong alignment on UHudScreen");
static_assert(sizeof(UHudScreen) == 0x0006E8, "Wrong size on UHudScreen");
static_assert(offsetof(UHudScreen, _rootWidget) == 0x0001F8, "Member 'UHudScreen::_rootWidget' has a wrong offset!");
static_assert(offsetof(UHudScreen, _tutorialsUtilities) == 0x0002E0, "Member 'UHudScreen::_tutorialsUtilities' has a wrong offset!");
static_assert(offsetof(UHudScreen, _playerStatusInterfaces) == 0x0002E8, "Member 'UHudScreen::_playerStatusInterfaces' has a wrong offset!");
static_assert(offsetof(UHudScreen, _interactionProgressViewData) == 0x0002F8, "Member 'UHudScreen::_interactionProgressViewData' has a wrong offset!");
static_assert(offsetof(UHudScreen, _itemBundleViewData) == 0x000360, "Member 'UHudScreen::_itemBundleViewData' has a wrong offset!");
static_assert(offsetof(UHudScreen, _powerBundleViewData) == 0x000510, "Member 'UHudScreen::_powerBundleViewData' has a wrong offset!");
static_assert(offsetof(UHudScreen, _playerStatusViewData) == 0x000668, "Member 'UHudScreen::_playerStatusViewData' has a wrong offset!");

// Class DeadByDaylight.DecalSpawnerCollection
// 0x0050 (0x0080 - 0x0030)
class UDecalSpawnerCollection final : public UObject
{
public:
	TMap<class FName, class UDecalSpawner*>       _decalSpawners;                                    // 0x0030(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	class UDecalSpawner* CreateDecalSpawner(const class UObject* worldContextObject, class FName decalSpawnerName, class UMaterialInterface* decalMaterial, int32 poolSize, ESpawnerStrategyType spawnerStrateryType);
	void ReleaseDecalSpawner(class FName decalSpawnerName);
	class UDBDDecalComponent* SpawnDecalAtLocation(class FName decalSpawnerName, const struct FVector& decalSize, const struct FVector& location, const struct FRotator& rotation, float lifeSpan, class FName decalType, const int32 sortOrder);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecalSpawnerCollection">();
	}
	static class UDecalSpawnerCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecalSpawnerCollection>();
	}
};
static_assert(alignof(UDecalSpawnerCollection) == 0x000008, "Wrong alignment on UDecalSpawnerCollection");
static_assert(sizeof(UDecalSpawnerCollection) == 0x000080, "Wrong size on UDecalSpawnerCollection");
static_assert(offsetof(UDecalSpawnerCollection, _decalSpawners) == 0x000030, "Member 'UDecalSpawnerCollection::_decalSpawners' has a wrong offset!");

// Class DeadByDaylight.DedicatedServerManager
// 0x0038 (0x0070 - 0x0038)
class UDedicatedServerManager final : public UGameInstanceSubsystem
{
public:
	TScriptInterface<class IDedicatedServerStartupInitializerInterface> _startupInitializer;         // 0x0038(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UOnlineSystemHandler*                   _onlineSystemHandler;                              // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerManager">();
	}
	static class UDedicatedServerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDedicatedServerManager>();
	}
};
static_assert(alignof(UDedicatedServerManager) == 0x000008, "Wrong alignment on UDedicatedServerManager");
static_assert(sizeof(UDedicatedServerManager) == 0x000070, "Wrong size on UDedicatedServerManager");
static_assert(offsetof(UDedicatedServerManager, _startupInitializer) == 0x000038, "Member 'UDedicatedServerManager::_startupInitializer' has a wrong offset!");
static_assert(offsetof(UDedicatedServerManager, _onlineSystemHandler) == 0x000048, "Member 'UDedicatedServerManager::_onlineSystemHandler' has a wrong offset!");

// Class DeadByDaylight.DemogorgonAnimProxy
// 0x0000 (0x0000 - 0x0000)
class IDemogorgonAnimProxy final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DemogorgonAnimProxy">();
	}
	static class IDemogorgonAnimProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDemogorgonAnimProxy>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDemogorgonAnimProxy) == 0x000001, "Wrong alignment on IDemogorgonAnimProxy");
static_assert(sizeof(IDemogorgonAnimProxy) == 0x000001, "Wrong size on IDemogorgonAnimProxy");

// Class DeadByDaylight.DetectionZoneUtilities
// 0x0000 (0x0030 - 0x0030)
class UDetectionZoneUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool DetectObstruction(const class ADBDPlayer* player, EDetectionZone detectionZoneID, class UPhysicalMaterial** physicalMaterialOut, struct FVector* positionOut, struct FVector* normalOut);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DetectionZoneUtilities">();
	}
	static class UDetectionZoneUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDetectionZoneUtilities>();
	}
};
static_assert(alignof(UDetectionZoneUtilities) == 0x000008, "Wrong alignment on UDetectionZoneUtilities");
static_assert(sizeof(UDetectionZoneUtilities) == 0x000030, "Wrong size on UDetectionZoneUtilities");

// Class DeadByDaylight.FriendManager
// 0x0238 (0x0268 - 0x0030)
class UFriendManager final : public UObject
{
public:
	uint8                                         Pad_30[0x238];                                     // 0x0030(0x0238)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendManager">();
	}
	static class UFriendManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendManager>();
	}
};
static_assert(alignof(UFriendManager) == 0x000008, "Wrong alignment on UFriendManager");
static_assert(sizeof(UFriendManager) == 0x000268, "Wrong size on UFriendManager");

// Class DeadByDaylight.DialogHandlerCondition
// 0x0000 (0x0030 - 0x0030)
class UDialogHandlerCondition final : public UObject
{
public:
	bool IsTrue(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogHandlerCondition">();
	}
	static class UDialogHandlerCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogHandlerCondition>();
	}
};
static_assert(alignof(UDialogHandlerCondition) == 0x000008, "Wrong alignment on UDialogHandlerCondition");
static_assert(sizeof(UDialogHandlerCondition) == 0x000030, "Wrong size on UDialogHandlerCondition");

// Class DeadByDaylight.DisplayStandCharmRequesterComponent
// 0x0028 (0x00E0 - 0x00B8)
class UDisplayStandCharmRequesterComponent final : public UActorComponent
{
public:
	TSubclassOf<class ACharm>                     _menuCharmClass;                                   // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x20];                                      // 0x00C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharmDisplayed(class AActor* actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandCharmRequesterComponent">();
	}
	static class UDisplayStandCharmRequesterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayStandCharmRequesterComponent>();
	}
};
static_assert(alignof(UDisplayStandCharmRequesterComponent) == 0x000008, "Wrong alignment on UDisplayStandCharmRequesterComponent");
static_assert(sizeof(UDisplayStandCharmRequesterComponent) == 0x0000E0, "Wrong size on UDisplayStandCharmRequesterComponent");
static_assert(offsetof(UDisplayStandCharmRequesterComponent, _menuCharmClass) == 0x0000B8, "Member 'UDisplayStandCharmRequesterComponent::_menuCharmClass' has a wrong offset!");

// Class DeadByDaylight.DisplayStandCurrencyRequesterComponent
// 0x0010 (0x00C8 - 0x00B8)
class UDisplayStandCurrencyRequesterComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 _menuCurrencyDisplayableClass;                     // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandCurrencyRequesterComponent">();
	}
	static class UDisplayStandCurrencyRequesterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayStandCurrencyRequesterComponent>();
	}
};
static_assert(alignof(UDisplayStandCurrencyRequesterComponent) == 0x000008, "Wrong alignment on UDisplayStandCurrencyRequesterComponent");
static_assert(sizeof(UDisplayStandCurrencyRequesterComponent) == 0x0000C8, "Wrong size on UDisplayStandCurrencyRequesterComponent");
static_assert(offsetof(UDisplayStandCurrencyRequesterComponent, _menuCurrencyDisplayableClass) == 0x0000C0, "Member 'UDisplayStandCurrencyRequesterComponent::_menuCurrencyDisplayableClass' has a wrong offset!");

// Class DeadByDaylight.GameEventTracker
// 0x0038 (0x0068 - 0x0030)
class UGameEventTracker final : public UObject
{
public:
	TMulticastInlineDelegate<void(EDBDScoreTypes playerGameplayEventType, float amount, class AActor* effector, class AActor* target)> OnGameplayEvent; // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EDBDScoreTypes playerGameplayEventType, float amount, const class ADBDPlayerState* effector)> OnGameflowEvent; // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FireGameEvent(EDBDScoreTypes eventType, float amount, class AActor* instigator, class AActor* target);
	void FireGameflowEvent(EDBDScoreTypes eventType, float amount, const class ADBDPlayerState* instigator, class FName data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEventTracker">();
	}
	static class UGameEventTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEventTracker>();
	}
};
static_assert(alignof(UGameEventTracker) == 0x000008, "Wrong alignment on UGameEventTracker");
static_assert(sizeof(UGameEventTracker) == 0x000068, "Wrong size on UGameEventTracker");
static_assert(offsetof(UGameEventTracker, OnGameplayEvent) == 0x000030, "Member 'UGameEventTracker::OnGameplayEvent' has a wrong offset!");
static_assert(offsetof(UGameEventTracker, OnGameflowEvent) == 0x000040, "Member 'UGameEventTracker::OnGameflowEvent' has a wrong offset!");

// Class DeadByDaylight.DisplayStandMeatHookRequesterComponent
// 0x0018 (0x00D0 - 0x00B8)
class UDisplayStandMeatHookRequesterComponent final : public UActorComponent
{
public:
	TSubclassOf<class AMenuMeatHook>              _meatHookClass;                                    // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DisplayStandMeatHookRequesterComponent">();
	}
	static class UDisplayStandMeatHookRequesterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDisplayStandMeatHookRequesterComponent>();
	}
};
static_assert(alignof(UDisplayStandMeatHookRequesterComponent) == 0x000008, "Wrong alignment on UDisplayStandMeatHookRequesterComponent");
static_assert(sizeof(UDisplayStandMeatHookRequesterComponent) == 0x0000D0, "Wrong size on UDisplayStandMeatHookRequesterComponent");
static_assert(offsetof(UDisplayStandMeatHookRequesterComponent, _meatHookClass) == 0x0000B8, "Member 'UDisplayStandMeatHookRequesterComponent::_meatHookClass' has a wrong offset!");

// Class DeadByDaylight.DragDropOperation_Widget
// 0x00B8 (0x0148 - 0x0090)
class UDragDropOperation_Widget final : public UDragDropOperation
{
public:
	class UUMGDragWidget*                         Widget;                                            // 0x0090(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           WidgetParent;                                      // 0x0098(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StartPosition;                                     // 0x00A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WidgetLocalScale;                                  // 0x00A8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WidgetLocalOpacity;                                // 0x00C8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OnDropOffset;                                      // 0x00CC(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OnDragOffset;                                      // 0x00D4(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnchors                               WidgetSlotAnchors;                                 // 0x00DC(0x0010)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FMargin                                WidgetSlotOffsets;                                 // 0x00EC(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              WidgetSlotPosition;                                // 0x00FC(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WidgetSlotSize;                                    // 0x0104(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WidgetSlotAutoSize;                                // 0x010C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              WidgetSlotAlignment;                               // 0x0110(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WidgetSlotZOrder;                                  // 0x0118(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGDragWidget*                         ChildLinkWidget;                                   // 0x0120(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x20];                                     // 0x0128(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DragDropOperation_Widget">();
	}
	static class UDragDropOperation_Widget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDragDropOperation_Widget>();
	}
};
static_assert(alignof(UDragDropOperation_Widget) == 0x000008, "Wrong alignment on UDragDropOperation_Widget");
static_assert(sizeof(UDragDropOperation_Widget) == 0x000148, "Wrong size on UDragDropOperation_Widget");
static_assert(offsetof(UDragDropOperation_Widget, Widget) == 0x000090, "Member 'UDragDropOperation_Widget::Widget' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetParent) == 0x000098, "Member 'UDragDropOperation_Widget::WidgetParent' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, StartPosition) == 0x0000A0, "Member 'UDragDropOperation_Widget::StartPosition' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetLocalScale) == 0x0000A8, "Member 'UDragDropOperation_Widget::WidgetLocalScale' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetLocalOpacity) == 0x0000C8, "Member 'UDragDropOperation_Widget::WidgetLocalOpacity' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, OnDropOffset) == 0x0000CC, "Member 'UDragDropOperation_Widget::OnDropOffset' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, OnDragOffset) == 0x0000D4, "Member 'UDragDropOperation_Widget::OnDragOffset' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotAnchors) == 0x0000DC, "Member 'UDragDropOperation_Widget::WidgetSlotAnchors' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotOffsets) == 0x0000EC, "Member 'UDragDropOperation_Widget::WidgetSlotOffsets' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotPosition) == 0x0000FC, "Member 'UDragDropOperation_Widget::WidgetSlotPosition' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotSize) == 0x000104, "Member 'UDragDropOperation_Widget::WidgetSlotSize' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotAutoSize) == 0x00010C, "Member 'UDragDropOperation_Widget::WidgetSlotAutoSize' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotAlignment) == 0x000110, "Member 'UDragDropOperation_Widget::WidgetSlotAlignment' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, WidgetSlotZOrder) == 0x000118, "Member 'UDragDropOperation_Widget::WidgetSlotZOrder' has a wrong offset!");
static_assert(offsetof(UDragDropOperation_Widget, ChildLinkWidget) == 0x000120, "Member 'UDragDropOperation_Widget::ChildLinkWidget' has a wrong offset!");

// Class DeadByDaylight.PromoPackPurchaseUIDataUtility
// 0x0000 (0x0030 - 0x0030)
class UPromoPackPurchaseUIDataUtility final : public UBlueprintFunctionLibrary
{
public:
	static void SetRemainingTimeFromHours(struct FPromoPackPurchaseUIData& data, int32 remainHours);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PromoPackPurchaseUIDataUtility">();
	}
	static class UPromoPackPurchaseUIDataUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPromoPackPurchaseUIDataUtility>();
	}
};
static_assert(alignof(UPromoPackPurchaseUIDataUtility) == 0x000008, "Wrong alignment on UPromoPackPurchaseUIDataUtility");
static_assert(sizeof(UPromoPackPurchaseUIDataUtility) == 0x000030, "Wrong size on UPromoPackPurchaseUIDataUtility");

// Class DeadByDaylight.Interactor
// 0x0070 (0x0290 - 0x0220)
class UInteractor final : public USceneComponent
{
public:
	class FString                                 InteractorName;                                    // 0x0218(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x30];                                     // 0x0228(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsUsable;                                          // 0x0258(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FObjectLock                            _lock;                                             // 0x025C(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	struct FObjectLock                            _reservation;                                      // 0x0264(0x0008)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _currentInteraction;                               // 0x0270(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UInteractionDefinition*>         _interactionDefinitions;                           // 0x0278(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x8];                                      // 0x0288(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BPPostInitializeComponents();
	void Multicast_LockStatus(class ADBDPlayer* player, class UInteractionDefinition* currentInteraction, bool lock);
	void Multicast_ReservationStatus(class ADBDPlayer* player, bool lock);
	void SetIsUsable(bool isUsableParam);

	class ADBDPlayer* Authority_GetInteractingPlayer() const;
	bool CanPerformInteraction(const class ADBDPlayer* player, const class UInteractionDefinition* definition) const;
	class UInteractionDefinition* GetCurrentInteraction() const;
	class AInteractable* GetInteractable() const;
	class ADBDPlayer* GetInteractingPlayerRaw() const;
	TArray<class UInteractionDefinition*> GetInteractionDefinitions() const;
	bool GetIsUsable() const;
	bool IsInteracting() const;
	bool IsInterruptionPossible(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee, const class UInteractionDefinition* definition, const class UInterruptionDefinition* interruption) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interactor">();
	}
	static class UInteractor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractor>();
	}
};
static_assert(alignof(UInteractor) == 0x000010, "Wrong alignment on UInteractor");
static_assert(sizeof(UInteractor) == 0x000290, "Wrong size on UInteractor");
static_assert(offsetof(UInteractor, InteractorName) == 0x000218, "Member 'UInteractor::InteractorName' has a wrong offset!");
static_assert(offsetof(UInteractor, IsUsable) == 0x000258, "Member 'UInteractor::IsUsable' has a wrong offset!");
static_assert(offsetof(UInteractor, _lock) == 0x00025C, "Member 'UInteractor::_lock' has a wrong offset!");
static_assert(offsetof(UInteractor, _reservation) == 0x000264, "Member 'UInteractor::_reservation' has a wrong offset!");
static_assert(offsetof(UInteractor, _currentInteraction) == 0x000270, "Member 'UInteractor::_currentInteraction' has a wrong offset!");
static_assert(offsetof(UInteractor, _interactionDefinitions) == 0x000278, "Member 'UInteractor::_interactionDefinitions' has a wrong offset!");

// Class DeadByDaylight.NoiseIndicatorWidget
// 0x0000 (0x0380 - 0x0380)
class UNoiseIndicatorWidget : public UBaseIndicatorWidget
{
public:
	void SetIndicatorPanel(class UCanvasPanel* panel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NoiseIndicatorWidget">();
	}
	static class UNoiseIndicatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNoiseIndicatorWidget>();
	}
};
static_assert(alignof(UNoiseIndicatorWidget) == 0x000008, "Wrong alignment on UNoiseIndicatorWidget");
static_assert(sizeof(UNoiseIndicatorWidget) == 0x000380, "Wrong size on UNoiseIndicatorWidget");

// Class DeadByDaylight.DreamworldOnlyComponent
// 0x0010 (0x0230 - 0x0220)
class UDreamworldOnlyComponent final : public USceneComponent
{
public:
	uint8                                         Pad_218[0x18];                                     // 0x0218(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DreamworldOnlyComponent">();
	}
	static class UDreamworldOnlyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDreamworldOnlyComponent>();
	}
};
static_assert(alignof(UDreamworldOnlyComponent) == 0x000010, "Wrong alignment on UDreamworldOnlyComponent");
static_assert(sizeof(UDreamworldOnlyComponent) == 0x000230, "Wrong size on UDreamworldOnlyComponent");

// Class DeadByDaylight.RankManager
// 0x00A8 (0x00D8 - 0x0030)
class URankManager final : public UObject
{
public:
	uint8                                         Pad_30[0xA8];                                      // 0x0030(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RankManager">();
	}
	static class URankManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URankManager>();
	}
};
static_assert(alignof(URankManager) == 0x000008, "Wrong alignment on URankManager");
static_assert(sizeof(URankManager) == 0x0000D8, "Wrong size on URankManager");

// Class DeadByDaylight.DynamicGrassEffectorInterface
// 0x0000 (0x0000 - 0x0000)
class IDynamicGrassEffectorInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicGrassEffectorInterface">();
	}
	static class IDynamicGrassEffectorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDynamicGrassEffectorInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IDynamicGrassEffectorInterface) == 0x000001, "Wrong alignment on IDynamicGrassEffectorInterface");
static_assert(sizeof(IDynamicGrassEffectorInterface) == 0x000001, "Wrong size on IDynamicGrassEffectorInterface");

// Class DeadByDaylight.GameplayModifierContainerDataAsset
// 0x0040 (0x0088 - 0x0048)
class UGameplayModifierContainerDataAsset : public UDBDPrimaryDataAsset
{
public:
	TSoftClassPtr<class UClass>                   ModifierContainerComponent;                        // 0x0048(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UGameplayModifierContainerDataAsset>> RequiredModifierContainers;    // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayModifierContainerDataAsset">();
	}
	static class UGameplayModifierContainerDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModifierContainerDataAsset>();
	}
};
static_assert(alignof(UGameplayModifierContainerDataAsset) == 0x000008, "Wrong alignment on UGameplayModifierContainerDataAsset");
static_assert(sizeof(UGameplayModifierContainerDataAsset) == 0x000088, "Wrong size on UGameplayModifierContainerDataAsset");
static_assert(offsetof(UGameplayModifierContainerDataAsset, ModifierContainerComponent) == 0x000048, "Member 'UGameplayModifierContainerDataAsset::ModifierContainerComponent' has a wrong offset!");
static_assert(offsetof(UGameplayModifierContainerDataAsset, RequiredModifierContainers) == 0x000078, "Member 'UGameplayModifierContainerDataAsset::RequiredModifierContainers' has a wrong offset!");

// Class DeadByDaylight.ItemAddonDataAsset
// 0x0000 (0x0088 - 0x0088)
class UItemAddonDataAsset final : public UGameplayModifierContainerDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAddonDataAsset">();
	}
	static class UItemAddonDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAddonDataAsset>();
	}
};
static_assert(alignof(UItemAddonDataAsset) == 0x000008, "Wrong alignment on UItemAddonDataAsset");
static_assert(sizeof(UItemAddonDataAsset) == 0x000088, "Wrong size on UItemAddonDataAsset");

// Class DeadByDaylight.EditorActorVisualization
// 0x0060 (0x0280 - 0x0220)
class UEditorActorVisualization final : public USceneComponent
{
public:
	TSoftClassPtr<class UClass>                   ActorVisualization;                                // 0x0218(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0250(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorActorVisualization">();
	}
	static class UEditorActorVisualization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorActorVisualization>();
	}
};
static_assert(alignof(UEditorActorVisualization) == 0x000010, "Wrong alignment on UEditorActorVisualization");
static_assert(sizeof(UEditorActorVisualization) == 0x000280, "Wrong size on UEditorActorVisualization");
static_assert(offsetof(UEditorActorVisualization, ActorVisualization) == 0x000218, "Member 'UEditorActorVisualization::ActorVisualization' has a wrong offset!");
static_assert(offsetof(UEditorActorVisualization, RelativeTransform) == 0x000250, "Member 'UEditorActorVisualization::RelativeTransform' has a wrong offset!");

// Class DeadByDaylight.EditorMeshVisualization
// 0x0060 (0x0280 - 0x0220)
class UEditorMeshVisualization final : public USceneComponent
{
public:
	TSoftObjectPtr<class USkeletalMesh>           MeshVisualization;                                 // 0x0218(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0250(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorMeshVisualization">();
	}
	static class UEditorMeshVisualization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorMeshVisualization>();
	}
};
static_assert(alignof(UEditorMeshVisualization) == 0x000010, "Wrong alignment on UEditorMeshVisualization");
static_assert(sizeof(UEditorMeshVisualization) == 0x000280, "Wrong size on UEditorMeshVisualization");
static_assert(offsetof(UEditorMeshVisualization, MeshVisualization) == 0x000218, "Member 'UEditorMeshVisualization::MeshVisualization' has a wrong offset!");
static_assert(offsetof(UEditorMeshVisualization, RelativeTransform) == 0x000250, "Member 'UEditorMeshVisualization::RelativeTransform' has a wrong offset!");

// Class DeadByDaylight.KillInteractionDefinition
// 0x0090 (0x07D0 - 0x0740)
class UKillInteractionDefinition : public UChargeableInteractionDefinition
{
public:
	bool                                          _disableFOVSystemDuringInteraction;                // 0x0740(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _overrideSlasherFieldOfViewDuringInteraction;      // 0x0741(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _overrideCamperFieldOfViewDuringInteraction;       // 0x0742(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _camperCopySlasherFOVCurve;                        // 0x0743(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _cameraFOVCurveName;                               // 0x0744(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         _nonOverrideableTargetInteractions;                // 0x0750(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          _chargeCompleted;                                  // 0x0760(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isKillShownInThirdPerson;                         // 0x0761(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _manuallyManageMeshHiding;                         // 0x0762(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _survivorAnimationLastAfterInteractionEnds;        // 0x0763(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_764[0x34];                                     // 0x0764(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maximumDelayBeforeSurvivorDeath;                  // 0x0798(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79C[0x4];                                      // 0x079C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            _exitMontage;                                      // 0x07A0(0x0020)(Edit, NativeAccessSpecifierPrivate)
	float                                         _slasherFacingTolerance;                           // 0x07C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C4[0xC];                                      // 0x07C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKillAudioActivation(const bool active, class ADBDPlayer* interactingPlayer);
	void OnMoriCancelled();

	bool GetChargeCompleted() const;
	struct FAnimationMontageDescriptor GetExitAnimationMontage() const;
	const class ACamperPlayer* GetOwningSurvivor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillInteractionDefinition">();
	}
	static class UKillInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillInteractionDefinition>();
	}
};
static_assert(alignof(UKillInteractionDefinition) == 0x000010, "Wrong alignment on UKillInteractionDefinition");
static_assert(sizeof(UKillInteractionDefinition) == 0x0007D0, "Wrong size on UKillInteractionDefinition");
static_assert(offsetof(UKillInteractionDefinition, _disableFOVSystemDuringInteraction) == 0x000740, "Member 'UKillInteractionDefinition::_disableFOVSystemDuringInteraction' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _overrideSlasherFieldOfViewDuringInteraction) == 0x000741, "Member 'UKillInteractionDefinition::_overrideSlasherFieldOfViewDuringInteraction' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _overrideCamperFieldOfViewDuringInteraction) == 0x000742, "Member 'UKillInteractionDefinition::_overrideCamperFieldOfViewDuringInteraction' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _camperCopySlasherFOVCurve) == 0x000743, "Member 'UKillInteractionDefinition::_camperCopySlasherFOVCurve' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _cameraFOVCurveName) == 0x000744, "Member 'UKillInteractionDefinition::_cameraFOVCurveName' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _nonOverrideableTargetInteractions) == 0x000750, "Member 'UKillInteractionDefinition::_nonOverrideableTargetInteractions' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _chargeCompleted) == 0x000760, "Member 'UKillInteractionDefinition::_chargeCompleted' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _isKillShownInThirdPerson) == 0x000761, "Member 'UKillInteractionDefinition::_isKillShownInThirdPerson' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _manuallyManageMeshHiding) == 0x000762, "Member 'UKillInteractionDefinition::_manuallyManageMeshHiding' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _survivorAnimationLastAfterInteractionEnds) == 0x000763, "Member 'UKillInteractionDefinition::_survivorAnimationLastAfterInteractionEnds' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _maximumDelayBeforeSurvivorDeath) == 0x000798, "Member 'UKillInteractionDefinition::_maximumDelayBeforeSurvivorDeath' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _exitMontage) == 0x0007A0, "Member 'UKillInteractionDefinition::_exitMontage' has a wrong offset!");
static_assert(offsetof(UKillInteractionDefinition, _slasherFacingTolerance) == 0x0007C0, "Member 'UKillInteractionDefinition::_slasherFacingTolerance' has a wrong offset!");

// Class DeadByDaylight.EffectsLocator
// 0x0068 (0x0298 - 0x0230)
class AEffectsLocator final : public AActor
{
public:
	TArray<struct FEffectsLocatorTargets>         AffectedActors;                                    // 0x0230(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ActorCaptureRadius;                                // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           _encountered;                                      // 0x0248(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnActorTick(class UMaterialInstanceDynamic* actorMaterialInstanceDynamic);
	void OnEnterCollisionArea(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnFoundActor(class AActor* foundActor);
	void OnLeaveCollisionArea(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnLostActor(class AActor* lostActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EffectsLocator">();
	}
	static class AEffectsLocator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEffectsLocator>();
	}
};
static_assert(alignof(AEffectsLocator) == 0x000008, "Wrong alignment on AEffectsLocator");
static_assert(sizeof(AEffectsLocator) == 0x000298, "Wrong size on AEffectsLocator");
static_assert(offsetof(AEffectsLocator, AffectedActors) == 0x000230, "Member 'AEffectsLocator::AffectedActors' has a wrong offset!");
static_assert(offsetof(AEffectsLocator, ActorCaptureRadius) == 0x000240, "Member 'AEffectsLocator::ActorCaptureRadius' has a wrong offset!");
static_assert(offsetof(AEffectsLocator, _encountered) == 0x000248, "Member 'AEffectsLocator::_encountered' has a wrong offset!");

// Class DeadByDaylight.EmblemRankUtilities
// 0x0000 (0x0030 - 0x0030)
class UEmblemRankUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmblemRankUtilities">();
	}
	static class UEmblemRankUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmblemRankUtilities>();
	}
};
static_assert(alignof(UEmblemRankUtilities) == 0x000008, "Wrong alignment on UEmblemRankUtilities");
static_assert(sizeof(UEmblemRankUtilities) == 0x000030, "Wrong size on UEmblemRankUtilities");

// Class DeadByDaylight.EndGameComponent
// 0x00A0 (0x0158 - 0x00B8)
class UEndGameComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xA0];                                      // 0x00B8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableEndGameScenario();
	void FireEndGameSacrificeScoreEvent(const struct FGameEventData& gameEventData);
	void PauseEndGameTimer();
	void StartEndGame_Cheat();
	void UnpauseEndGameTimer();

	bool GetHasEndGameBegun() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndGameComponent">();
	}
	static class UEndGameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndGameComponent>();
	}
};
static_assert(alignof(UEndGameComponent) == 0x000008, "Wrong alignment on UEndGameComponent");
static_assert(sizeof(UEndGameComponent) == 0x000158, "Wrong size on UEndGameComponent");

// Class DeadByDaylight.MapActorComponent
// 0x0030 (0x00E8 - 0x00B8)
class UMapActorComponent final : public UActorComponent
{
public:
	EMapActorCategory                             Category;                                          // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    _mapActorCollider;                                 // 0x00C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _detectionEnabled;                                 // 0x00E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_SetDetectionEnabled(bool enabled);

	bool GetDetectionEnabled() const;
	bool IsKnownBy(const class ADBDPlayer* character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorComponent">();
	}
	static class UMapActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActorComponent>();
	}
};
static_assert(alignof(UMapActorComponent) == 0x000008, "Wrong alignment on UMapActorComponent");
static_assert(sizeof(UMapActorComponent) == 0x0000E8, "Wrong size on UMapActorComponent");
static_assert(offsetof(UMapActorComponent, Category) == 0x0000B8, "Member 'UMapActorComponent::Category' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, _mapActorCollider) == 0x0000C0, "Member 'UMapActorComponent::_mapActorCollider' has a wrong offset!");
static_assert(offsetof(UMapActorComponent, _detectionEnabled) == 0x0000E0, "Member 'UMapActorComponent::_detectionEnabled' has a wrong offset!");

// Class DeadByDaylight.LevelCrowWRMeshComponent
// 0x0000 (0x1020 - 0x1020)
class ULevelCrowWRMeshComponent final : public UWorldRunawayMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelCrowWRMeshComponent">();
	}
	static class ULevelCrowWRMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelCrowWRMeshComponent>();
	}
};
static_assert(alignof(ULevelCrowWRMeshComponent) == 0x000010, "Wrong alignment on ULevelCrowWRMeshComponent");
static_assert(sizeof(ULevelCrowWRMeshComponent) == 0x001020, "Wrong size on ULevelCrowWRMeshComponent");

// Class DeadByDaylight.EnduranceVFXComponent
// 0x0020 (0x00D8 - 0x00B8)
class UEnduranceVFXComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShowHighlight(class UGameplayModifierContainer* preventKOSource);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnduranceVFXComponent">();
	}
	static class UEnduranceVFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnduranceVFXComponent>();
	}
};
static_assert(alignof(UEnduranceVFXComponent) == 0x000008, "Wrong alignment on UEnduranceVFXComponent");
static_assert(sizeof(UEnduranceVFXComponent) == 0x0000D8, "Wrong size on UEnduranceVFXComponent");

// Class DeadByDaylight.EnsureLoggingSubsystem
// 0x0038 (0x0070 - 0x0038)
class UEnsureLoggingSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnsureLoggingSubsystem">();
	}
	static class UEnsureLoggingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnsureLoggingSubsystem>();
	}
};
static_assert(alignof(UEnsureLoggingSubsystem) == 0x000008, "Wrong alignment on UEnsureLoggingSubsystem");
static_assert(sizeof(UEnsureLoggingSubsystem) == 0x000070, "Wrong size on UEnsureLoggingSubsystem");

// Class DeadByDaylight.ReverseBearTrapRemover
// 0x0030 (0x0358 - 0x0328)
class AReverseBearTrapRemover final : public AInteractable
{
public:
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 _keys;                                             // 0x0330(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 _keysSearched;                                     // 0x0340(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UMapActorComponent*                     _mapActor;                                         // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddKey(int32 keyId);
	void AddSearchedKey(int32 keyId);
	void PlayRemoveFailMontage();

	class AReverseBearTrap* GetAttachedRBT(class AActor* player) const;
	class UPrimitiveComponent* GetInteractorPrimitiveComponent() const;
	class UMapActorComponent* GetMapActor() const;
	bool HasKey(int32 keyId) const;
	bool HasSearchedForKey(int32 keyId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReverseBearTrapRemover">();
	}
	static class AReverseBearTrapRemover* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReverseBearTrapRemover>();
	}
};
static_assert(alignof(AReverseBearTrapRemover) == 0x000008, "Wrong alignment on AReverseBearTrapRemover");
static_assert(sizeof(AReverseBearTrapRemover) == 0x000358, "Wrong size on AReverseBearTrapRemover");
static_assert(offsetof(AReverseBearTrapRemover, _keys) == 0x000330, "Member 'AReverseBearTrapRemover::_keys' has a wrong offset!");
static_assert(offsetof(AReverseBearTrapRemover, _keysSearched) == 0x000340, "Member 'AReverseBearTrapRemover::_keysSearched' has a wrong offset!");
static_assert(offsetof(AReverseBearTrapRemover, _mapActor) == 0x000350, "Member 'AReverseBearTrapRemover::_mapActor' has a wrong offset!");

// Class DeadByDaylight.EnvironmentAnimatedObject
// 0x0000 (0x02B8 - 0x02B8)
class AEnvironmentAnimatedObject final : public ASkeletalMeshActorBudgeted
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentAnimatedObject">();
	}
	static class AEnvironmentAnimatedObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnvironmentAnimatedObject>();
	}
};
static_assert(alignof(AEnvironmentAnimatedObject) == 0x000008, "Wrong alignment on AEnvironmentAnimatedObject");
static_assert(sizeof(AEnvironmentAnimatedObject) == 0x0002B8, "Wrong size on AEnvironmentAnimatedObject");

// Class DeadByDaylight.MatchManagementScreen
// 0x00C0 (0x01E0 - 0x0120)
class UMatchManagementScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0xC0];                                     // 0x0120(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAddMap(const class FString& mapId);
	void OnAllowDlcSettingsClick();
	void OnApplyChangesClicked();
	void OnBackButtonClick();
	void OnItemsAndAddonsSettingsChange(int32 value);
	void OnOfferingsSettingsChange(int32 value);
	void OnPerksSettingsChange(int32 value);
	void OnRemoveMap(const class FString& mapId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchManagementScreen">();
	}
	static class UMatchManagementScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchManagementScreen>();
	}
};
static_assert(alignof(UMatchManagementScreen) == 0x000008, "Wrong alignment on UMatchManagementScreen");
static_assert(sizeof(UMatchManagementScreen) == 0x0001E0, "Wrong size on UMatchManagementScreen");

// Class DeadByDaylight.EpicProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UEpicProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EpicProfileDAL">();
	}
	static class UEpicProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEpicProfileDAL>();
	}
};
static_assert(alignof(UEpicProfileDAL) == 0x000008, "Wrong alignment on UEpicProfileDAL");
static_assert(sizeof(UEpicProfileDAL) == 0x000088, "Wrong size on UEpicProfileDAL");

// Class DeadByDaylight.EscapeBlocker
// 0x0038 (0x0268 - 0x0230)
class AEscapeBlocker final : public AActor
{
public:
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          _camperBlocker;                                    // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _playerDetectionZone;                              // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x20];                                     // 0x0248(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivatePlayerBlockerFX();
	void DeactivatePlayerBlockerFX();
	void OnPlayerDetectionZoneBeginOverlap(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult);
	void OnPlayerDetectionZoneEndOverlap(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex);
	void SetCamperBlocker(class UBoxComponent* camperBlocker);
	void SetPlayerDetectionZone(class UBoxComponent* playerDetectionZone);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeBlocker">();
	}
	static class AEscapeBlocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEscapeBlocker>();
	}
};
static_assert(alignof(AEscapeBlocker) == 0x000008, "Wrong alignment on AEscapeBlocker");
static_assert(sizeof(AEscapeBlocker) == 0x000268, "Wrong size on AEscapeBlocker");
static_assert(offsetof(AEscapeBlocker, _camperBlocker) == 0x000238, "Member 'AEscapeBlocker::_camperBlocker' has a wrong offset!");
static_assert(offsetof(AEscapeBlocker, _playerDetectionZone) == 0x000240, "Member 'AEscapeBlocker::_playerDetectionZone' has a wrong offset!");

// Class DeadByDaylight.InactiveCooldownTimerPerkIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UInactiveCooldownTimerPerkIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InactiveCooldownTimerPerkIconStrategy">();
	}
	static class UInactiveCooldownTimerPerkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInactiveCooldownTimerPerkIconStrategy>();
	}
};
static_assert(alignof(UInactiveCooldownTimerPerkIconStrategy) == 0x000008, "Wrong alignment on UInactiveCooldownTimerPerkIconStrategy");
static_assert(sizeof(UInactiveCooldownTimerPerkIconStrategy) == 0x000038, "Wrong size on UInactiveCooldownTimerPerkIconStrategy");

// Class DeadByDaylight.EscapeDoor
// 0x00F0 (0x0418 - 0x0328)
class AEscapeDoor final : public AInteractable
{
public:
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        EscapePositions;                                   // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        EscapeFire;                                        // 0x0340(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UChargeableComponent*                   _killerOpenChargeable;                             // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChargeableComponent*                   _openChargeable;                                   // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _ak_audio_escape;                                  // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEscapeDoorAnimInstance*                _escapeDoorAnimInstance;                           // 0x0368(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootComponent;                                    // 0x0370(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _activated;                                        // 0x0378(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USpotLightComponent*                    _spotlight;                                        // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x48];                                     // 0x0388(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ACamperPlayer>>   _localOverlappingSurvivors;                        // 0x03D0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x03E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlockableComponent*                    _doorSwitchBlockableComponent;                     // 0x03F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x20];                                     // 0x03F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UChargeableInteractionDefinition* GetOpenEscapeInteraction();
	void LightAllLights();
	void OnBlockDoorSwitchCosmetic();
	void OnCamperStartOpeningExitGate(class ACamperPlayer* player);
	void OnEscapeZoneBeginOverlap(class AActor* overlappingActor);
	void OnEscapeZoneEndOverlap(class AActor* overlappingActor);
	void OnExitActivationChanged(bool activated);
	void OnExitGateOpened(class ADBDPlayer* player);
	void OnExitOpenChanged(bool opened);
	void OnPlayerEnterExitArea(class ADBDPlayer* player);
	void OnPlayerExitExitArea(class ADBDPlayer* player);
	void OnRep_Activated(bool oldActivated);
	void OnUnblockDoorSwitchCosmetic();
	void SetIsActivated(bool isActivated);
	void StartAtlantaDoorBeepingSound();
	void StartAtlantaDoorOpeningSound();

	bool GetAtlantaExitOpeningIndicatorVisibility() const;
	class USkeletalMeshComponent* GetDoorSkeletalMeshComponent() const;
	struct FVector GetEscapeSwitchFloorLocation() const;
	class UBoxComponent* GetExitArea() const;
	bool GetIsOpen() const;
	float GetOpenTime() const;
	struct FVector GetParadiseServerLocation() const;
	class USceneComponent* GetSwitchSceneComponent() const;
	bool IsActivated() const;
	bool IsDoorSwitchBlocked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeDoor">();
	}
	static class AEscapeDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEscapeDoor>();
	}
};
static_assert(alignof(AEscapeDoor) == 0x000008, "Wrong alignment on AEscapeDoor");
static_assert(sizeof(AEscapeDoor) == 0x000418, "Wrong size on AEscapeDoor");
static_assert(offsetof(AEscapeDoor, EscapePositions) == 0x000330, "Member 'AEscapeDoor::EscapePositions' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, EscapeFire) == 0x000340, "Member 'AEscapeDoor::EscapeFire' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _killerOpenChargeable) == 0x000350, "Member 'AEscapeDoor::_killerOpenChargeable' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _openChargeable) == 0x000358, "Member 'AEscapeDoor::_openChargeable' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _ak_audio_escape) == 0x000360, "Member 'AEscapeDoor::_ak_audio_escape' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _escapeDoorAnimInstance) == 0x000368, "Member 'AEscapeDoor::_escapeDoorAnimInstance' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _rootComponent) == 0x000370, "Member 'AEscapeDoor::_rootComponent' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _activated) == 0x000378, "Member 'AEscapeDoor::_activated' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _spotlight) == 0x000380, "Member 'AEscapeDoor::_spotlight' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _localOverlappingSurvivors) == 0x0003D0, "Member 'AEscapeDoor::_localOverlappingSurvivors' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _perceptionStimuliComponent) == 0x0003E8, "Member 'AEscapeDoor::_perceptionStimuliComponent' has a wrong offset!");
static_assert(offsetof(AEscapeDoor, _doorSwitchBlockableComponent) == 0x0003F0, "Member 'AEscapeDoor::_doorSwitchBlockableComponent' has a wrong offset!");

// Class DeadByDaylight.EscapeOutlineUpdateStrategy
// 0x0020 (0x00E0 - 0x00C0)
class UEscapeOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _doorOpenColorForSurvivor;                         // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _doorOpenColorForKiller;                           // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeOutlineUpdateStrategy">();
	}
	static class UEscapeOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEscapeOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UEscapeOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UEscapeOutlineUpdateStrategy");
static_assert(sizeof(UEscapeOutlineUpdateStrategy) == 0x0000E0, "Wrong size on UEscapeOutlineUpdateStrategy");
static_assert(offsetof(UEscapeOutlineUpdateStrategy, _doorOpenColorForSurvivor) == 0x0000C0, "Member 'UEscapeOutlineUpdateStrategy::_doorOpenColorForSurvivor' has a wrong offset!");
static_assert(offsetof(UEscapeOutlineUpdateStrategy, _doorOpenColorForKiller) == 0x0000D0, "Member 'UEscapeOutlineUpdateStrategy::_doorOpenColorForKiller' has a wrong offset!");

// Class DeadByDaylight.EscapeThroughHatch
// 0x0000 (0x0620 - 0x0620)
class UEscapeThroughHatch final : public UBaseEscapeThroughHatch
{
public:
	void OnCamperEscapeThroughHatch(class ACamperPlayer* player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EscapeThroughHatch">();
	}
	static class UEscapeThroughHatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEscapeThroughHatch>();
	}
};
static_assert(alignof(UEscapeThroughHatch) == 0x000010, "Wrong alignment on UEscapeThroughHatch");
static_assert(sizeof(UEscapeThroughHatch) == 0x000620, "Wrong size on UEscapeThroughHatch");

// Class DeadByDaylight.EventEntryPopupScreen
// 0x0000 (0x0140 - 0x0140)
class UEventEntryPopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventEntryPopupScreen">();
	}
	static class UEventEntryPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventEntryPopupScreen>();
	}
};
static_assert(alignof(UEventEntryPopupScreen) == 0x000008, "Wrong alignment on UEventEntryPopupScreen");
static_assert(sizeof(UEventEntryPopupScreen) == 0x000140, "Wrong size on UEventEntryPopupScreen");

// Class DeadByDaylight.GameplayModifierFunctionLibraryStatusEffect
// 0x0000 (0x0350 - 0x0350)
class UGameplayModifierFunctionLibraryStatusEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayModifierFunctionLibraryStatusEffect">();
	}
	static class UGameplayModifierFunctionLibraryStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModifierFunctionLibraryStatusEffect>();
	}
};
static_assert(alignof(UGameplayModifierFunctionLibraryStatusEffect) == 0x000008, "Wrong alignment on UGameplayModifierFunctionLibraryStatusEffect");
static_assert(sizeof(UGameplayModifierFunctionLibraryStatusEffect) == 0x000350, "Wrong size on UGameplayModifierFunctionLibraryStatusEffect");

// Class DeadByDaylight.EventGeneratorComponent
// 0x0020 (0x00E8 - 0x00C8)
class UEventGeneratorComponent final : public UEventObjectComponent
{
public:
	struct FGameplayTag                           _genCompletedScoreEvent;                           // 0x00C8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _genCompletedNoOfferingScoreEvent;                 // 0x00D4(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOfferingEffectType                           _offeringEffectTypeNeeded;                         // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _updateOutlineForSurvivor;                         // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _updateOutlineForSlasher;                          // 0x00E2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E3[0x5];                                       // 0x00E3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_FireGenCompletedEventScore(bool isAutoCompleted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventGeneratorComponent">();
	}
	static class UEventGeneratorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventGeneratorComponent>();
	}
};
static_assert(alignof(UEventGeneratorComponent) == 0x000008, "Wrong alignment on UEventGeneratorComponent");
static_assert(sizeof(UEventGeneratorComponent) == 0x0000E8, "Wrong size on UEventGeneratorComponent");
static_assert(offsetof(UEventGeneratorComponent, _genCompletedScoreEvent) == 0x0000C8, "Member 'UEventGeneratorComponent::_genCompletedScoreEvent' has a wrong offset!");
static_assert(offsetof(UEventGeneratorComponent, _genCompletedNoOfferingScoreEvent) == 0x0000D4, "Member 'UEventGeneratorComponent::_genCompletedNoOfferingScoreEvent' has a wrong offset!");
static_assert(offsetof(UEventGeneratorComponent, _offeringEffectTypeNeeded) == 0x0000E0, "Member 'UEventGeneratorComponent::_offeringEffectTypeNeeded' has a wrong offset!");
static_assert(offsetof(UEventGeneratorComponent, _updateOutlineForSurvivor) == 0x0000E1, "Member 'UEventGeneratorComponent::_updateOutlineForSurvivor' has a wrong offset!");
static_assert(offsetof(UEventGeneratorComponent, _updateOutlineForSlasher) == 0x0000E2, "Member 'UEventGeneratorComponent::_updateOutlineForSlasher' has a wrong offset!");

// Class DeadByDaylight.EventsFactory
// 0x0000 (0x0038 - 0x0038)
class UEventsFactory final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventsFactory">();
	}
	static class UEventsFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventsFactory>();
	}
};
static_assert(alignof(UEventsFactory) == 0x000008, "Wrong alignment on UEventsFactory");
static_assert(sizeof(UEventsFactory) == 0x000038, "Wrong size on UEventsFactory");

// Class DeadByDaylight.LanternLightCollectable
// 0x0008 (0x04B8 - 0x04B0)
class ALanternLightCollectable final : public ACollectable
{
public:
	class ALanternInteractable*                   _parentLantern;                                    // 0x04B0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetParentLantern(class ALanternInteractable* parentLantern);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LanternLightCollectable">();
	}
	static class ALanternLightCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALanternLightCollectable>();
	}
};
static_assert(alignof(ALanternLightCollectable) == 0x000008, "Wrong alignment on ALanternLightCollectable");
static_assert(sizeof(ALanternLightCollectable) == 0x0004B8, "Wrong size on ALanternLightCollectable");
static_assert(offsetof(ALanternLightCollectable, _parentLantern) == 0x0004B0, "Member 'ALanternLightCollectable::_parentLantern' has a wrong offset!");

// Class DeadByDaylight.ExitOpenedIndicatorWidget
// 0x0000 (0x0380 - 0x0380)
class UExitOpenedIndicatorWidget final : public UBaseIndicatorWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExitOpenedIndicatorWidget">();
	}
	static class UExitOpenedIndicatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExitOpenedIndicatorWidget>();
	}
};
static_assert(alignof(UExitOpenedIndicatorWidget) == 0x000008, "Wrong alignment on UExitOpenedIndicatorWidget");
static_assert(sizeof(UExitOpenedIndicatorWidget) == 0x000380, "Wrong size on UExitOpenedIndicatorWidget");

// Class DeadByDaylight.GeneratorEntityAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class UGeneratorEntityAnimInstance final : public UAnimInstance
{
public:
	bool                                          IsCorrupted;                                       // 0x02C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsCorrupted_End;                                   // 0x02C1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUncorrupted;                                     // 0x02C2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsUncorrupted_End;                                 // 0x02C3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0xC];                                      // 0x02C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorEntityAnimInstance">();
	}
	static class UGeneratorEntityAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorEntityAnimInstance>();
	}
};
static_assert(alignof(UGeneratorEntityAnimInstance) == 0x000010, "Wrong alignment on UGeneratorEntityAnimInstance");
static_assert(sizeof(UGeneratorEntityAnimInstance) == 0x0002D0, "Wrong size on UGeneratorEntityAnimInstance");
static_assert(offsetof(UGeneratorEntityAnimInstance, IsCorrupted) == 0x0002C0, "Member 'UGeneratorEntityAnimInstance::IsCorrupted' has a wrong offset!");
static_assert(offsetof(UGeneratorEntityAnimInstance, IsCorrupted_End) == 0x0002C1, "Member 'UGeneratorEntityAnimInstance::IsCorrupted_End' has a wrong offset!");
static_assert(offsetof(UGeneratorEntityAnimInstance, IsUncorrupted) == 0x0002C2, "Member 'UGeneratorEntityAnimInstance::IsUncorrupted' has a wrong offset!");
static_assert(offsetof(UGeneratorEntityAnimInstance, IsUncorrupted_End) == 0x0002C3, "Member 'UGeneratorEntityAnimInstance::IsUncorrupted_End' has a wrong offset!");

// Class DeadByDaylight.ExposerInteriorZoneComponent
// 0x0010 (0x04C0 - 0x04B0)
class UExposerInteriorZoneComponent final : public UBoxComponent
{
public:
	TArray<class USceneComponent*>                ExposerSpawnPoints;                                // 0x04A8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddExposerSpawnPoint(class USceneComponent* point);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExposerInteriorZoneComponent">();
	}
	static class UExposerInteriorZoneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExposerInteriorZoneComponent>();
	}
};
static_assert(alignof(UExposerInteriorZoneComponent) == 0x000010, "Wrong alignment on UExposerInteriorZoneComponent");
static_assert(sizeof(UExposerInteriorZoneComponent) == 0x0004C0, "Wrong size on UExposerInteriorZoneComponent");
static_assert(offsetof(UExposerInteriorZoneComponent, ExposerSpawnPoints) == 0x0004A8, "Member 'UExposerInteriorZoneComponent::ExposerSpawnPoints' has a wrong offset!");

// Class DeadByDaylight.UmgSpectatorHud
// 0x0020 (0x0580 - 0x0560)
class UUmgSpectatorHud final : public UUmgPlayerHud
{
public:
	TMulticastInlineDelegate<void()>              OnLeaveSpectateClicked;                            // 0x0560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& playerName)> OnPlayerSpectate;                // 0x0570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void HandleLeaveSpectateClicked();
	void OnPlayerStatusSelected(const class FString& playerName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UmgSpectatorHud">();
	}
	static class UUmgSpectatorHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUmgSpectatorHud>();
	}
};
static_assert(alignof(UUmgSpectatorHud) == 0x000008, "Wrong alignment on UUmgSpectatorHud");
static_assert(sizeof(UUmgSpectatorHud) == 0x000580, "Wrong size on UUmgSpectatorHud");
static_assert(offsetof(UUmgSpectatorHud, OnLeaveSpectateClicked) == 0x000560, "Member 'UUmgSpectatorHud::OnLeaveSpectateClicked' has a wrong offset!");
static_assert(offsetof(UUmgSpectatorHud, OnPlayerSpectate) == 0x000570, "Member 'UUmgSpectatorHud::OnPlayerSpectate' has a wrong offset!");

// Class DeadByDaylight.Fadeable
// 0x0000 (0x0000 - 0x0000)
class IFadeable final
{
public:
	void OnAlphaChanged(float newAlpha, class AActor* other);
	void OnFadeBegin(class AActor* other);
	void OnFadeEnd(class AActor* other);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Fadeable">();
	}
	static class IFadeable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFadeable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IFadeable) == 0x000001, "Wrong alignment on IFadeable");
static_assert(sizeof(IFadeable) == 0x000001, "Wrong size on IFadeable");

// Class DeadByDaylight.FakeKillerHuskInterface
// 0x0000 (0x0000 - 0x0000)
class IFakeKillerHuskInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FakeKillerHuskInterface">();
	}
	static class IFakeKillerHuskInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFakeKillerHuskInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IFakeKillerHuskInterface) == 0x000001, "Wrong alignment on IFakeKillerHuskInterface");
static_assert(sizeof(IFakeKillerHuskInterface) == 0x000001, "Wrong size on IFakeKillerHuskInterface");

// Class DeadByDaylight.UMGLoginPopup
// 0x0018 (0x0438 - 0x0420)
class UUMGLoginPopup final : public UUMGGenericPopup
{
public:
	class UUMGAuthentificationProviderListWidget* AuthenticationProviderList;                        // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_428[0x10];                                     // 0x0428(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChooseProvider(const uint8 provider);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLoginPopup">();
	}
	static class UUMGLoginPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLoginPopup>();
	}
};
static_assert(alignof(UUMGLoginPopup) == 0x000008, "Wrong alignment on UUMGLoginPopup");
static_assert(sizeof(UUMGLoginPopup) == 0x000438, "Wrong size on UUMGLoginPopup");
static_assert(offsetof(UUMGLoginPopup, AuthenticationProviderList) == 0x000420, "Member 'UUMGLoginPopup::AuthenticationProviderList' has a wrong offset!");

// Class DeadByDaylight.FasterChestSearch
// 0x0000 (0x0350 - 0x0350)
class UFasterChestSearch final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FasterChestSearch">();
	}
	static class UFasterChestSearch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFasterChestSearch>();
	}
};
static_assert(alignof(UFasterChestSearch) == 0x000008, "Wrong alignment on UFasterChestSearch");
static_assert(sizeof(UFasterChestSearch) == 0x000350, "Wrong size on UFasterChestSearch");

// Class DeadByDaylight.FearMarketManager
// 0x00E0 (0x0110 - 0x0030)
class UFearMarketManager final : public UObject
{
public:
	struct FFearMarketItemInstance                PendingPurchaseFearMarketItem;                     // 0x0030(0x0030)(NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x48];                                      // 0x0060(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFearMarketOfferingInstance            _existingFearMarket;                               // 0x00A8(0x0020)(NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x40];                                      // 0x00D0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceivedFearMarketData(bool success);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FearMarketManager">();
	}
	static class UFearMarketManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFearMarketManager>();
	}
};
static_assert(alignof(UFearMarketManager) == 0x000008, "Wrong alignment on UFearMarketManager");
static_assert(sizeof(UFearMarketManager) == 0x000110, "Wrong size on UFearMarketManager");
static_assert(offsetof(UFearMarketManager, PendingPurchaseFearMarketItem) == 0x000030, "Member 'UFearMarketManager::PendingPurchaseFearMarketItem' has a wrong offset!");
static_assert(offsetof(UFearMarketManager, _existingFearMarket) == 0x0000A8, "Member 'UFearMarketManager::_existingFearMarket' has a wrong offset!");
static_assert(offsetof(UFearMarketManager, _gameInstance) == 0x0000C8, "Member 'UFearMarketManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.IgnorePlayersCollisionsComponent
// 0x0068 (0x0120 - 0x00B8)
class UIgnorePlayersCollisionsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x68];                                      // 0x00B8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IgnorePlayersCollisionsComponent">();
	}
	static class UIgnorePlayersCollisionsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIgnorePlayersCollisionsComponent>();
	}
};
static_assert(alignof(UIgnorePlayersCollisionsComponent) == 0x000008, "Wrong alignment on UIgnorePlayersCollisionsComponent");
static_assert(sizeof(UIgnorePlayersCollisionsComponent) == 0x000120, "Wrong size on UIgnorePlayersCollisionsComponent");

// Class DeadByDaylight.FearMarketPopupScreen
// 0x0000 (0x0140 - 0x0140)
class UFearMarketPopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FearMarketPopupScreen">();
	}
	static class UFearMarketPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFearMarketPopupScreen>();
	}
};
static_assert(alignof(UFearMarketPopupScreen) == 0x000008, "Wrong alignment on UFearMarketPopupScreen");
static_assert(sizeof(UFearMarketPopupScreen) == 0x000140, "Wrong size on UFearMarketPopupScreen");

// Class DeadByDaylight.FinisherMoriTrackerComponent
// 0x0030 (0x00E8 - 0x00B8)
class UFinisherMoriTrackerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACamperPlayer*>                  _survivorsDowned;                                  // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FinisherMoriTrackerComponent">();
	}
	static class UFinisherMoriTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFinisherMoriTrackerComponent>();
	}
};
static_assert(alignof(UFinisherMoriTrackerComponent) == 0x000008, "Wrong alignment on UFinisherMoriTrackerComponent");
static_assert(sizeof(UFinisherMoriTrackerComponent) == 0x0000E8, "Wrong size on UFinisherMoriTrackerComponent");
static_assert(offsetof(UFinisherMoriTrackerComponent, _survivorsDowned) == 0x0000D0, "Member 'UFinisherMoriTrackerComponent::_survivorsDowned' has a wrong offset!");

// Class DeadByDaylight.Firecracker
// 0x0058 (0x0380 - 0x0328)
class AFirecracker : public AInteractable
{
public:
	uint8                                         Pad_328[0x18];                                     // 0x0328(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       _effectArea;                                       // 0x0340(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DebugDisplayEnabled;                               // 0x0348(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UGameplayModifierContainer*>     _effectModifiers;                                  // 0x0350(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ADBDPlayer*                             _playerOwner;                                      // 0x0360(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isExploding;                                      // 0x0368(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_369[0x7];                                      // 0x0369(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _actorsInRange;                                    // 0x0370(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Multicast_InitFromSpawner(class ACollectable* spawner);
	void OnEffectsInitialized();
	void OnExplode();
	void OnFuseBurnEnter();
	void OnFuseBurnExit();
	void OnFuseBurnUpdate(float deltaSeconds, float fuseTimeLeftPercent);

	float GetBlindnessEffectDuration(const class AActor* player) const;
	float GetDeafnessEffectDuration(const class ADBDPlayer* player) const;
	const TArray<class UGameplayModifierContainer*> GetEffects() const;
	bool GetExploded() const;
	float GetExplosionDelay() const;
	float GetExplosionEffectDuration() const;
	float GetExplosionRange() const;
	float GetModifierValue(const struct FGameplayTag& type) const;
	bool HasFlag(const struct FGameplayTag& flag) const;
	bool HasModifierOfType(const struct FGameplayTag& type) const;
	bool ShouldBlind(const class ADBDPlayer* player, float* outDuration) const;
	bool ShouldDeafen(const class ADBDPlayer* player, float* outDuration) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Firecracker">();
	}
	static class AFirecracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFirecracker>();
	}
};
static_assert(alignof(AFirecracker) == 0x000008, "Wrong alignment on AFirecracker");
static_assert(sizeof(AFirecracker) == 0x000380, "Wrong size on AFirecracker");
static_assert(offsetof(AFirecracker, _effectArea) == 0x000340, "Member 'AFirecracker::_effectArea' has a wrong offset!");
static_assert(offsetof(AFirecracker, DebugDisplayEnabled) == 0x000348, "Member 'AFirecracker::DebugDisplayEnabled' has a wrong offset!");
static_assert(offsetof(AFirecracker, _effectModifiers) == 0x000350, "Member 'AFirecracker::_effectModifiers' has a wrong offset!");
static_assert(offsetof(AFirecracker, _playerOwner) == 0x000360, "Member 'AFirecracker::_playerOwner' has a wrong offset!");
static_assert(offsetof(AFirecracker, _isExploding) == 0x000368, "Member 'AFirecracker::_isExploding' has a wrong offset!");
static_assert(offsetof(AFirecracker, _actorsInRange) == 0x000370, "Member 'AFirecracker::_actorsInRange' has a wrong offset!");

// Class DeadByDaylight.GenericTextInputPopupScreen
// 0x0018 (0x0158 - 0x0140)
class UGenericTextInputPopupScreen final : public UGenericPopupScreen
{
public:
	uint8                                         Pad_140[0x18];                                     // 0x0140(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTextInputChoiceSelected(int32 selectedButtonType, const class FString& inputText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericTextInputPopupScreen">();
	}
	static class UGenericTextInputPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericTextInputPopupScreen>();
	}
};
static_assert(alignof(UGenericTextInputPopupScreen) == 0x000008, "Wrong alignment on UGenericTextInputPopupScreen");
static_assert(sizeof(UGenericTextInputPopupScreen) == 0x000158, "Wrong size on UGenericTextInputPopupScreen");

// Class DeadByDaylight.FirecrackerEffectHandlerComponent
// 0x0070 (0x0128 - 0x00B8)
class UFirecrackerEffectHandlerComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const struct FFirecrackerEffectData& effectData)> OnFirecrackerInRangeBegin; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FFirecrackerEffectData& effectData)> OnFirecrackerInRangeEnd; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSet<class AFirecracker*>                     _inRangeFirecrackers;                              // 0x00D8(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void OnFirecrackerDestroyed(class AActor* destroyedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirecrackerEffectHandlerComponent">();
	}
	static class UFirecrackerEffectHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirecrackerEffectHandlerComponent>();
	}
};
static_assert(alignof(UFirecrackerEffectHandlerComponent) == 0x000008, "Wrong alignment on UFirecrackerEffectHandlerComponent");
static_assert(sizeof(UFirecrackerEffectHandlerComponent) == 0x000128, "Wrong size on UFirecrackerEffectHandlerComponent");
static_assert(offsetof(UFirecrackerEffectHandlerComponent, OnFirecrackerInRangeBegin) == 0x0000B8, "Member 'UFirecrackerEffectHandlerComponent::OnFirecrackerInRangeBegin' has a wrong offset!");
static_assert(offsetof(UFirecrackerEffectHandlerComponent, OnFirecrackerInRangeEnd) == 0x0000C8, "Member 'UFirecrackerEffectHandlerComponent::OnFirecrackerInRangeEnd' has a wrong offset!");
static_assert(offsetof(UFirecrackerEffectHandlerComponent, _inRangeFirecrackers) == 0x0000D8, "Member 'UFirecrackerEffectHandlerComponent::_inRangeFirecrackers' has a wrong offset!");

// Class DeadByDaylight.UMGLobbyScreen
// 0x0048 (0x0380 - 0x0338)
class UUMGLobbyScreen final : public UMobileBaseUserWidget
{
public:
	class UUMGLobbySearchingWidget*               LobbySearchingWidget;                              // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnJoinedLobbyLeaved;                               // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSearchingLobbyCancelled;                         // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        LobbySwitcher;                                     // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGLobbyJoinedWidget*                  LobbyJoinedWidget;                                 // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGLobbyOfferingWidget*                OfferingWidget;                                    // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGFogWidget*                          FogWidget;                                         // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleJoinedLobbyLeave();
	void HandleSearchingLobbyCancel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLobbyScreen">();
	}
	static class UUMGLobbyScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLobbyScreen>();
	}
};
static_assert(alignof(UUMGLobbyScreen) == 0x000008, "Wrong alignment on UUMGLobbyScreen");
static_assert(sizeof(UUMGLobbyScreen) == 0x000380, "Wrong size on UUMGLobbyScreen");
static_assert(offsetof(UUMGLobbyScreen, LobbySearchingWidget) == 0x000338, "Member 'UUMGLobbyScreen::LobbySearchingWidget' has a wrong offset!");
static_assert(offsetof(UUMGLobbyScreen, OnJoinedLobbyLeaved) == 0x000340, "Member 'UUMGLobbyScreen::OnJoinedLobbyLeaved' has a wrong offset!");
static_assert(offsetof(UUMGLobbyScreen, OnSearchingLobbyCancelled) == 0x000350, "Member 'UUMGLobbyScreen::OnSearchingLobbyCancelled' has a wrong offset!");
static_assert(offsetof(UUMGLobbyScreen, LobbySwitcher) == 0x000360, "Member 'UUMGLobbyScreen::LobbySwitcher' has a wrong offset!");
static_assert(offsetof(UUMGLobbyScreen, LobbyJoinedWidget) == 0x000368, "Member 'UUMGLobbyScreen::LobbyJoinedWidget' has a wrong offset!");
static_assert(offsetof(UUMGLobbyScreen, OfferingWidget) == 0x000370, "Member 'UUMGLobbyScreen::OfferingWidget' has a wrong offset!");
static_assert(offsetof(UUMGLobbyScreen, FogWidget) == 0x000378, "Member 'UUMGLobbyScreen::FogWidget' has a wrong offset!");

// Class DeadByDaylight.FirecrackerScoreComponent
// 0x0000 (0x00B8 - 0x00B8)
class UFirecrackerScoreComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirecrackerScoreComponent">();
	}
	static class UFirecrackerScoreComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirecrackerScoreComponent>();
	}
};
static_assert(alignof(UFirecrackerScoreComponent) == 0x000008, "Wrong alignment on UFirecrackerScoreComponent");
static_assert(sizeof(UFirecrackerScoreComponent) == 0x0000B8, "Wrong size on UFirecrackerScoreComponent");

// Class DeadByDaylight.FirecrackerStateMachine
// 0x0000 (0x0130 - 0x0130)
class UFirecrackerStateMachine final : public UStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirecrackerStateMachine">();
	}
	static class UFirecrackerStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirecrackerStateMachine>();
	}
};
static_assert(alignof(UFirecrackerStateMachine) == 0x000010, "Wrong alignment on UFirecrackerStateMachine");
static_assert(sizeof(UFirecrackerStateMachine) == 0x000130, "Wrong size on UFirecrackerStateMachine");

// Class DeadByDaylight.UMGMonthlyPassRewardItemWidget
// 0x0058 (0x0390 - 0x0338)
class UUMGMonthlyPassRewardItemWidget : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             ItemAmount;                                        // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemName;                                          // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemIcon;                                          // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CheckIcon;                                         // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemFrame;                                         // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemRarityBackground;                              // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ItemPaintPanel;                                    // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ActiveItemFrameColor;                              // 0x0370(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NonActiveItemFrameColor;                           // 0x0380(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGMonthlyPassRewardItemWidget">();
	}
	static class UUMGMonthlyPassRewardItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGMonthlyPassRewardItemWidget>();
	}
};
static_assert(alignof(UUMGMonthlyPassRewardItemWidget) == 0x000008, "Wrong alignment on UUMGMonthlyPassRewardItemWidget");
static_assert(sizeof(UUMGMonthlyPassRewardItemWidget) == 0x000390, "Wrong size on UUMGMonthlyPassRewardItemWidget");
static_assert(offsetof(UUMGMonthlyPassRewardItemWidget, ItemAmount) == 0x000338, "Member 'UUMGMonthlyPassRewardItemWidget::ItemAmount' has a wrong offset!");
static_assert(offsetof(UUMGMonthlyPassRewardItemWidget, ItemName) == 0x000340, "Member 'UUMGMonthlyPassRewardItemWidget::ItemName' has a wrong offset!");
static_assert(offsetof(UUMGMonthlyPassRewardItemWidget, ItemIcon) == 0x000348, "Member 'UUMGMonthlyPassRewardItemWidget::ItemIcon' has a wrong offset!");
static_assert(offsetof(UUMGMonthlyPassRewardItemWidget, CheckIcon) == 0x000350, "Member 'UUMGMonthlyPassRewardItemWidget::CheckIcon' has a wrong offset!");
static_assert(offsetof(UUMGMonthlyPassRewardItemWidget, ItemFrame) == 0x000358, "Member 'UUMGMonthlyPassRewardItemWidget::ItemFrame' has a wrong offset!");
static_assert(offsetof(UUMGMonthlyPassRewardItemWidget, ItemRarityBackground) == 0x000360, "Member 'UUMGMonthlyPassRewardItemWidget::ItemRarityBackground' has a wrong offset!");
static_assert(offsetof(UUMGMonthlyPassRewardItemWidget, ItemPaintPanel) == 0x000368, "Member 'UUMGMonthlyPassRewardItemWidget::ItemPaintPanel' has a wrong offset!");
static_assert(offsetof(UUMGMonthlyPassRewardItemWidget, ActiveItemFrameColor) == 0x000370, "Member 'UUMGMonthlyPassRewardItemWidget::ActiveItemFrameColor' has a wrong offset!");
static_assert(offsetof(UUMGMonthlyPassRewardItemWidget, NonActiveItemFrameColor) == 0x000380, "Member 'UUMGMonthlyPassRewardItemWidget::NonActiveItemFrameColor' has a wrong offset!");

// Class DeadByDaylight.UMGMonthlyPassFreeTicketWidget
// 0x0000 (0x0390 - 0x0390)
class UUMGMonthlyPassFreeTicketWidget final : public UUMGMonthlyPassRewardItemWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGMonthlyPassFreeTicketWidget">();
	}
	static class UUMGMonthlyPassFreeTicketWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGMonthlyPassFreeTicketWidget>();
	}
};
static_assert(alignof(UUMGMonthlyPassFreeTicketWidget) == 0x000008, "Wrong alignment on UUMGMonthlyPassFreeTicketWidget");
static_assert(sizeof(UUMGMonthlyPassFreeTicketWidget) == 0x000390, "Wrong size on UUMGMonthlyPassFreeTicketWidget");

// Class DeadByDaylight.FirstPersonViewComponent
// 0x0010 (0x00C8 - 0x00B8)
class UFirstPersonViewComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FirstPersonViewComponent">();
	}
	static class UFirstPersonViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFirstPersonViewComponent>();
	}
};
static_assert(alignof(UFirstPersonViewComponent) == 0x000008, "Wrong alignment on UFirstPersonViewComponent");
static_assert(sizeof(UFirstPersonViewComponent) == 0x0000C8, "Wrong size on UFirstPersonViewComponent");

// Class DeadByDaylight.FleeComponent
// 0x0020 (0x00D8 - 0x00B8)
class UFleeComponent final : public UActorComponent
{
public:
	class AActor*                                 _threat;                                           // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FleeComponent">();
	}
	static class UFleeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFleeComponent>();
	}
};
static_assert(alignof(UFleeComponent) == 0x000008, "Wrong alignment on UFleeComponent");
static_assert(sizeof(UFleeComponent) == 0x0000D8, "Wrong size on UFleeComponent");
static_assert(offsetof(UFleeComponent, _threat) == 0x0000B8, "Member 'UFleeComponent::_threat' has a wrong offset!");

// Class DeadByDaylight.InGameAssetPreloaderComponent
// 0x01A8 (0x0260 - 0x00B8)
class UInGameAssetPreloaderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FPrimaryAssetId>                  _generalPrimaryAssetIds;                           // 0x00D0(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSet<TSoftClassPtr<class UClass>>             _generalRegularAssets;                             // 0x0120(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UInGameAssetPreloaderGatherer>> _assetGathererClasses;                  // 0x0170(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UInGameAssetPreloaderGatherer*>  _assetGatherers;                                   // 0x0180(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0xD0];                                     // 0x0190(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameAssetPreloaderComponent">();
	}
	static class UInGameAssetPreloaderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameAssetPreloaderComponent>();
	}
};
static_assert(alignof(UInGameAssetPreloaderComponent) == 0x000008, "Wrong alignment on UInGameAssetPreloaderComponent");
static_assert(sizeof(UInGameAssetPreloaderComponent) == 0x000260, "Wrong size on UInGameAssetPreloaderComponent");
static_assert(offsetof(UInGameAssetPreloaderComponent, _generalPrimaryAssetIds) == 0x0000D0, "Member 'UInGameAssetPreloaderComponent::_generalPrimaryAssetIds' has a wrong offset!");
static_assert(offsetof(UInGameAssetPreloaderComponent, _generalRegularAssets) == 0x000120, "Member 'UInGameAssetPreloaderComponent::_generalRegularAssets' has a wrong offset!");
static_assert(offsetof(UInGameAssetPreloaderComponent, _assetGathererClasses) == 0x000170, "Member 'UInGameAssetPreloaderComponent::_assetGathererClasses' has a wrong offset!");
static_assert(offsetof(UInGameAssetPreloaderComponent, _assetGatherers) == 0x000180, "Member 'UInGameAssetPreloaderComponent::_assetGatherers' has a wrong offset!");

// Class DeadByDaylight.FlickeringLight
// 0x03A8 (0x0600 - 0x0258)
class AFlickeringLight final : public AGeneratorDrivenActor
{
public:
	EFlickeringLightType                          _lightComponentType;                               // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EDetailMode                                   _detailLevelBeforeCastShadows;                     // 0x025C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPerPlatformBool                       _castShadow;                                       // 0x025D(0x0001)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25E[0x2];                                      // 0x025E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBHVRPerDetailModeBool                 _isCastingShadow;                                  // 0x0260(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _maxDrawDistance;                                  // 0x0300(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeFloat                _maxDistanceFadeRange;                             // 0x03A0(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeBool                 _castCinematicShadowsOnly;                         // 0x0440(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	float                                         _innerConneAngle;                                  // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _outerConneAngle;                                  // 0x04E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sourceLength;                                     // 0x04E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sourceRadius;                                     // 0x04EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _intensity;                                        // 0x04F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _generatorActivated;                               // 0x04F4(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isTimelineSpeedRandom;                            // 0x04F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F6[0x2];                                      // 0x04F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maximumTimelimeSpeed;                             // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumTimelimeSpeed;                             // 0x04FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBHVRPerDetailModeBool                 _secondaryLightVisibility;                         // 0x0500(0x00A0)(Edit, NativeAccessSpecifierPrivate)
	float                                         _secondaryLightIntensity;                          // 0x05A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _secondaryLightTransform;                          // 0x05A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               _secondaryLightRotation;                           // 0x05B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         _secondaryLightAttenuationRadius;                  // 0x05BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _secondaryLightColor;                              // 0x05C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _secondaryLightSpecularScale;                      // 0x05D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         _isAlwaysCapturedAsON : 1;                         // 0x05D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_5D5[0x3];                                      // 0x05D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ULightIntensityTimelineComponent*       _lightIntensityTimeline;                           // 0x05D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPointLightComponent*                   _pointLightComponent;                              // 0x05E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPointLightComponent*                   _secondaryPointLightComponent;                     // 0x05E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URectLightComponent*                    _rectLightComponent;                               // 0x05F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpotLightComponent*                    _spotLightComponent;                               // 0x05F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class ULocalLightComponent* GetActiveLightComponent();
	class ULocalLightComponent* GetSecondaryLightComponent();
	bool GetSecondaryLightVisibilty();
	void Init();
	void StartFlickering();
	void StopFlickering();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlickeringLight">();
	}
	static class AFlickeringLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlickeringLight>();
	}
};
static_assert(alignof(AFlickeringLight) == 0x000008, "Wrong alignment on AFlickeringLight");
static_assert(sizeof(AFlickeringLight) == 0x000600, "Wrong size on AFlickeringLight");
static_assert(offsetof(AFlickeringLight, _lightComponentType) == 0x000258, "Member 'AFlickeringLight::_lightComponentType' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _detailLevelBeforeCastShadows) == 0x00025C, "Member 'AFlickeringLight::_detailLevelBeforeCastShadows' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _castShadow) == 0x00025D, "Member 'AFlickeringLight::_castShadow' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _isCastingShadow) == 0x000260, "Member 'AFlickeringLight::_isCastingShadow' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _maxDrawDistance) == 0x000300, "Member 'AFlickeringLight::_maxDrawDistance' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _maxDistanceFadeRange) == 0x0003A0, "Member 'AFlickeringLight::_maxDistanceFadeRange' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _castCinematicShadowsOnly) == 0x000440, "Member 'AFlickeringLight::_castCinematicShadowsOnly' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _innerConneAngle) == 0x0004E0, "Member 'AFlickeringLight::_innerConneAngle' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _outerConneAngle) == 0x0004E4, "Member 'AFlickeringLight::_outerConneAngle' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _sourceLength) == 0x0004E8, "Member 'AFlickeringLight::_sourceLength' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _sourceRadius) == 0x0004EC, "Member 'AFlickeringLight::_sourceRadius' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _intensity) == 0x0004F0, "Member 'AFlickeringLight::_intensity' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _generatorActivated) == 0x0004F4, "Member 'AFlickeringLight::_generatorActivated' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _isTimelineSpeedRandom) == 0x0004F5, "Member 'AFlickeringLight::_isTimelineSpeedRandom' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _maximumTimelimeSpeed) == 0x0004F8, "Member 'AFlickeringLight::_maximumTimelimeSpeed' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _minimumTimelimeSpeed) == 0x0004FC, "Member 'AFlickeringLight::_minimumTimelimeSpeed' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightVisibility) == 0x000500, "Member 'AFlickeringLight::_secondaryLightVisibility' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightIntensity) == 0x0005A0, "Member 'AFlickeringLight::_secondaryLightIntensity' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightTransform) == 0x0005A4, "Member 'AFlickeringLight::_secondaryLightTransform' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightRotation) == 0x0005B0, "Member 'AFlickeringLight::_secondaryLightRotation' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightAttenuationRadius) == 0x0005BC, "Member 'AFlickeringLight::_secondaryLightAttenuationRadius' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightColor) == 0x0005C0, "Member 'AFlickeringLight::_secondaryLightColor' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryLightSpecularScale) == 0x0005D0, "Member 'AFlickeringLight::_secondaryLightSpecularScale' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _lightIntensityTimeline) == 0x0005D8, "Member 'AFlickeringLight::_lightIntensityTimeline' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _pointLightComponent) == 0x0005E0, "Member 'AFlickeringLight::_pointLightComponent' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _secondaryPointLightComponent) == 0x0005E8, "Member 'AFlickeringLight::_secondaryPointLightComponent' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _rectLightComponent) == 0x0005F0, "Member 'AFlickeringLight::_rectLightComponent' has a wrong offset!");
static_assert(offsetof(AFlickeringLight, _spotLightComponent) == 0x0005F8, "Member 'AFlickeringLight::_spotLightComponent' has a wrong offset!");

// Class DeadByDaylight.FoliageActor
// 0x0008 (0x0238 - 0x0230)
class AFoliageActor final : public AActor
{
public:
	class UFoliageDensityHISM*                    _foliageHISM;                                      // 0x0230(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageActor">();
	}
	static class AFoliageActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFoliageActor>();
	}
};
static_assert(alignof(AFoliageActor) == 0x000008, "Wrong alignment on AFoliageActor");
static_assert(sizeof(AFoliageActor) == 0x000238, "Wrong size on AFoliageActor");
static_assert(offsetof(AFoliageActor, _foliageHISM) == 0x000230, "Member 'AFoliageActor::_foliageHISM' has a wrong offset!");

// Class DeadByDaylight.FoliageDensityContainer
// 0x00F8 (0x0328 - 0x0230)
class AFoliageDensityContainer final : public AActor
{
public:
	TMap<class FName, class AFoliageActor*>       _foliageActors;                                    // 0x0230(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, class UFoliageDensityHISM*> _foliageHISMs;                                     // 0x0280(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D0[0x50];                                     // 0x02D0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDMapFoliageDensityTunables*          _mapFoliageDensityTunables;                        // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageDensityContainer">();
	}
	static class AFoliageDensityContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFoliageDensityContainer>();
	}
};
static_assert(alignof(AFoliageDensityContainer) == 0x000008, "Wrong alignment on AFoliageDensityContainer");
static_assert(sizeof(AFoliageDensityContainer) == 0x000328, "Wrong size on AFoliageDensityContainer");
static_assert(offsetof(AFoliageDensityContainer, _foliageActors) == 0x000230, "Member 'AFoliageDensityContainer::_foliageActors' has a wrong offset!");
static_assert(offsetof(AFoliageDensityContainer, _foliageHISMs) == 0x000280, "Member 'AFoliageDensityContainer::_foliageHISMs' has a wrong offset!");
static_assert(offsetof(AFoliageDensityContainer, _mapFoliageDensityTunables) == 0x000320, "Member 'AFoliageDensityContainer::_mapFoliageDensityTunables' has a wrong offset!");

// Class DeadByDaylight.FoliageDensityHISM
// 0x0000 (0x06F0 - 0x06F0)
class UFoliageDensityHISM final : public UHierarchicalInstancedStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageDensityHISM">();
	}
	static class UFoliageDensityHISM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFoliageDensityHISM>();
	}
};
static_assert(alignof(UFoliageDensityHISM) == 0x000010, "Wrong alignment on UFoliageDensityHISM");
static_assert(sizeof(UFoliageDensityHISM) == 0x0006F0, "Wrong size on UFoliageDensityHISM");

// Class DeadByDaylight.FranklinsDemiseConsumedByEntityComponent
// 0x0078 (0x0130 - 0x00B8)
class UFranklinsDemiseConsumedByEntityComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimerObject*                           _consumeTimer;                                     // 0x00D0(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _camperStatus;                                     // 0x00E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _previousOwner;                                    // 0x00F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _originatingPerkOwner;                             // 0x00F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargerComponent*                      _itemChargerComponent;                             // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x28];                                     // 0x0108(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_StartConsume(float duration, class ADBDPlayer* previousOwner, class ADBDPlayer* slasher);
	void OnConsumedByEntity();
	void OnRep_ConsumeTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FranklinsDemiseConsumedByEntityComponent">();
	}
	static class UFranklinsDemiseConsumedByEntityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFranklinsDemiseConsumedByEntityComponent>();
	}
};
static_assert(alignof(UFranklinsDemiseConsumedByEntityComponent) == 0x000008, "Wrong alignment on UFranklinsDemiseConsumedByEntityComponent");
static_assert(sizeof(UFranklinsDemiseConsumedByEntityComponent) == 0x000130, "Wrong size on UFranklinsDemiseConsumedByEntityComponent");
static_assert(offsetof(UFranklinsDemiseConsumedByEntityComponent, _consumeTimer) == 0x0000D0, "Member 'UFranklinsDemiseConsumedByEntityComponent::_consumeTimer' has a wrong offset!");
static_assert(offsetof(UFranklinsDemiseConsumedByEntityComponent, _camperStatus) == 0x0000E8, "Member 'UFranklinsDemiseConsumedByEntityComponent::_camperStatus' has a wrong offset!");
static_assert(offsetof(UFranklinsDemiseConsumedByEntityComponent, _previousOwner) == 0x0000F0, "Member 'UFranklinsDemiseConsumedByEntityComponent::_previousOwner' has a wrong offset!");
static_assert(offsetof(UFranklinsDemiseConsumedByEntityComponent, _originatingPerkOwner) == 0x0000F8, "Member 'UFranklinsDemiseConsumedByEntityComponent::_originatingPerkOwner' has a wrong offset!");
static_assert(offsetof(UFranklinsDemiseConsumedByEntityComponent, _itemChargerComponent) == 0x000100, "Member 'UFranklinsDemiseConsumedByEntityComponent::_itemChargerComponent' has a wrong offset!");

// Class DeadByDaylight.FrenzyData
// 0x0000 (0x0000 - 0x0000)
class IFrenzyData final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrenzyData">();
	}
	static class IFrenzyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFrenzyData>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IFrenzyData) == 0x000001, "Wrong alignment on IFrenzyData");
static_assert(sizeof(IFrenzyData) == 0x000001, "Wrong size on IFrenzyData");

// Class DeadByDaylight.FriendSearchPopupScreen
// 0x0060 (0x01A0 - 0x0140)
class UFriendSearchPopupScreen final : public UGenericPopupScreen
{
public:
	uint8                                         Pad_140[0x60];                                     // 0x0140(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAcceptFriendInvite(const class FString& friendKrakenID);
	void OnFriendSearchStart(const class FString& searchText);
	void OnInviteFriend(const class FString& friendKrakenID, bool isOffNetwork);
	void OnUnblockPlayer(const class FString& friendKrakenID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendSearchPopupScreen">();
	}
	static class UFriendSearchPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendSearchPopupScreen>();
	}
};
static_assert(alignof(UFriendSearchPopupScreen) == 0x000008, "Wrong alignment on UFriendSearchPopupScreen");
static_assert(sizeof(UFriendSearchPopupScreen) == 0x0001A0, "Wrong size on UFriendSearchPopupScreen");

// Class DeadByDaylight.FriendsListScreen
// 0x0108 (0x0228 - 0x0120)
class UFriendsListScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0x108];                                    // 0x0120(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAcceptFriendInvite(const class FString& friendId);
	void OnBlockPlayer(const class FString& playerId);
	void OnCancelFriendInvite(const class FString& friendId);
	void OnDeclineFriendInvite(const class FString& friendId);
	void OnPartyJoinRequest(const class FString& friendId);
	void OnRemoveFriend(const class FString& friendId);
	void OnSearchForFriend();
	void OnSendPartyInvite(const class FString& friendId);
	void OnShowNameSelected(const class FString& playerId);
	void OnUnblockPlayer(const class FString& playerId);
	void OnViewProfile(const class FString& friendId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendsListScreen">();
	}
	static class UFriendsListScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendsListScreen>();
	}
};
static_assert(alignof(UFriendsListScreen) == 0x000008, "Wrong alignment on UFriendsListScreen");
static_assert(sizeof(UFriendsListScreen) == 0x000228, "Wrong size on UFriendsListScreen");

// Class DeadByDaylight.GachaCrateManager
// 0x00A0 (0x00D8 - 0x0038)
class UGachaCrateManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xA0];                                      // 0x0038(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GachaCrateManager">();
	}
	static class UGachaCrateManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGachaCrateManager>();
	}
};
static_assert(alignof(UGachaCrateManager) == 0x000008, "Wrong alignment on UGachaCrateManager");
static_assert(sizeof(UGachaCrateManager) == 0x0000D8, "Wrong size on UGachaCrateManager");

// Class DeadByDaylight.GameAssetLibrary
// 0x0018 (0x00C8 - 0x00B0)
class UGameAssetLibrary final : public UAssetLibrary
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x00B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameAssetLibrary">();
	}
	static class UGameAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameAssetLibrary>();
	}
};
static_assert(alignof(UGameAssetLibrary) == 0x000008, "Wrong alignment on UGameAssetLibrary");
static_assert(sizeof(UGameAssetLibrary) == 0x0000C8, "Wrong size on UGameAssetLibrary");
static_assert(offsetof(UGameAssetLibrary, _gameInstance) == 0x0000B0, "Member 'UGameAssetLibrary::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.OngoingGameEvent
// 0x0070 (0x00A0 - 0x0030)
class UOngoingGameEvent final : public UObject
{
public:
	struct FGameEventData                         _eventData;                                        // 0x0030(0x0028)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x48];                                      // 0x0058(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OngoingGameEvent">();
	}
	static class UOngoingGameEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOngoingGameEvent>();
	}
};
static_assert(alignof(UOngoingGameEvent) == 0x000008, "Wrong alignment on UOngoingGameEvent");
static_assert(sizeof(UOngoingGameEvent) == 0x0000A0, "Wrong size on UOngoingGameEvent");
static_assert(offsetof(UOngoingGameEvent, _eventData) == 0x000030, "Member 'UOngoingGameEvent::_eventData' has a wrong offset!");

// Class DeadByDaylight.GameEventDispatcher
// 0x00B0 (0x00E8 - 0x0038)
class UGameEventDispatcher final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOngoingGameEvent*>              _ongoingEvents;                                    // 0x0088(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x50];                                      // 0x0098(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AccumulateOngoingGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData, float ongoingWaitTime);
	void Authority_RemotelyDispatch(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void LocallyDispatch(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void RegisterListener(const struct FGameEventDispatcherHandleBP& gameEventDispatcherHandle);
	void RemotelyDispatch(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void UnregisterListener(const struct FGameEventDispatcherHandleBP& gameEventDispatcherHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEventDispatcher">();
	}
	static class UGameEventDispatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEventDispatcher>();
	}
};
static_assert(alignof(UGameEventDispatcher) == 0x000008, "Wrong alignment on UGameEventDispatcher");
static_assert(sizeof(UGameEventDispatcher) == 0x0000E8, "Wrong size on UGameEventDispatcher");
static_assert(offsetof(UGameEventDispatcher, _ongoingEvents) == 0x000088, "Member 'UGameEventDispatcher::_ongoingEvents' has a wrong offset!");

// Class DeadByDaylight.GameFlowContextSystem
// 0x00F0 (0x0128 - 0x0038)
class UGameFlowContextSystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xD8];                                      // 0x0038(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class URootMovie*                             m_RootMovie;                                       // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameFlowContextSystem">();
	}
	static class UGameFlowContextSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameFlowContextSystem>();
	}
};
static_assert(alignof(UGameFlowContextSystem) == 0x000008, "Wrong alignment on UGameFlowContextSystem");
static_assert(sizeof(UGameFlowContextSystem) == 0x000128, "Wrong size on UGameFlowContextSystem");
static_assert(offsetof(UGameFlowContextSystem, m_RootMovie) == 0x000110, "Member 'UGameFlowContextSystem::m_RootMovie' has a wrong offset!");

// Class DeadByDaylight.GameplayModifierFunctionLibrary
// 0x0000 (0x0030 - 0x0030)
class UGameplayModifierFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void Authority_ClearAllPlayerGameplayFlags(class ADBDPlayer* targetPlayer);
	static void Authority_ClearAllPlayerGameplayModifiers(class ADBDPlayer* targetPlayer);
	static void Authority_ClearPlayerGameplayFlag(class ADBDPlayer* targetPlayer, const struct FGameplayTag& flagType);
	static void Authority_ClearPlayerGameplayModifier(class ADBDPlayer* targetPlayer, const struct FGameplayTag& modifierType);
	static void Authority_SetPlayerGameplayFlag(class ADBDPlayer* targetPlayer, const struct FGameplayTag& flagType);
	static void Authority_SetPlayerGameplayModifier(class ADBDPlayer* targetPlayer, const struct FGameplayTag& modifierType, float modifierValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayModifierFunctionLibrary">();
	}
	static class UGameplayModifierFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayModifierFunctionLibrary>();
	}
};
static_assert(alignof(UGameplayModifierFunctionLibrary) == 0x000008, "Wrong alignment on UGameplayModifierFunctionLibrary");
static_assert(sizeof(UGameplayModifierFunctionLibrary) == 0x000030, "Wrong size on UGameplayModifierFunctionLibrary");

// Class DeadByDaylight.GameplayNotificationUtilities
// 0x0000 (0x0030 - 0x0030)
class UGameplayNotificationUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayNotificationUtilities">();
	}
	static class UGameplayNotificationUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayNotificationUtilities>();
	}
};
static_assert(alignof(UGameplayNotificationUtilities) == 0x000008, "Wrong alignment on UGameplayNotificationUtilities");
static_assert(sizeof(UGameplayNotificationUtilities) == 0x000030, "Wrong size on UGameplayNotificationUtilities");

// Class DeadByDaylight.Generator
// 0x02B0 (0x05D8 - 0x0328)
class AGenerator final : public AInteractable
{
public:
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Activated;                                         // 0x0338(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRepaired;                                        // 0x0339(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WasASMCachePreWarmTriggered;                       // 0x033A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlaySkillcheckAesthetic;                         // 0x033B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveLinearColor*                      KillerOutlineFadeCurve;                            // 0x0340(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NativePercentComplete;                             // 0x0348(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool isAutoCompleted)> OnGeneratorRepaired;                        // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* repairingSurvivor)> OnGeneratorRepairedBySurvivor; // 0x0360(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AGenerator* generator, class ADBDPlayer* player)> OnIsDamagedChanged; // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x30];                                     // 0x0380(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          FireLevelScoreEventOnFix;                          // 0x03B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FTransform>          _activatedTopLightsTransformMap;                   // 0x03B8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0408(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x24];                                     // 0x0410(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _repairSemanticTag;                                // 0x0434(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDamageData                            _damageData;                                       // 0x0440(0x0020)(Net, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_460[0x8];                                      // 0x0460(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isBlocked;                                        // 0x0468(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isBlockedFromCharging;                            // 0x0469(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46A[0x6];                                      // 0x046A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UObject*>                          _blockingSources;                                  // 0x0470(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x30];                                     // 0x04C0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _generatorCharge;                                  // 0x04F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPlayerFloatTuple>              _playerStartTimes;                                 // 0x04F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_508[0x18];                                     // 0x0508(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isAutoCompleted;                                  // 0x0520(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isOvercharged;                                    // 0x0521(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_522[0x6];                                      // 0x0522(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCoopRepairTracker*                     _coopRepairTracker;                                // 0x0528(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_530[0x10];                                     // 0x0530(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _VFX_LightDistanceDefault;                         // 0x0540(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_544[0x5C];                                     // 0x0544(0x005C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractionDefinition*>         _damagingInteractions;                             // 0x05A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _intenseImmediateDamageThreshold;                  // 0x05B0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddDamagingInteraction(class UInteractionDefinition* interaction);
	void AddPlayerStartTime(class ADBDPlayer* player, float startTime);
	void Authority_AddBlockingSource(const class UObject* source);
	void Authority_AddTimedBlockingSource(const class UObject* source, const float blockingTime);
	void Authority_CancelRepairInteractions();
	void Authority_Damage(class ADBDPlayer* damagedBy, const float immediateRegressionPercent, bool ignoreBlocked);
	void Authority_OnChargeApplied(float individualChargeAmount, float totalChargeAmount, class AActor* chargeInstigator, bool wasCoop, float deltaTime);
	void Authority_OnChargeChanged(class UChargeableComponent* chargeableComponent, float percentCompletionChange, float totalPercentComplete);
	void Authority_RemoveBlockingSource(const class UObject* source);
	void Authority_RepairDamage(class ADBDPlayer* repairedBy);
	void Authority_SetRepaired(const bool showGeneratorCloneLoudNoise, const bool isAutoCompleted);
	void BroadcastIsDamagedChangedEvent(class ADBDPlayer* player);
	void DisableInaccessibleInteractors();
	bool GetIsBlockedFromCharging();
	void Multicast_DamageCosmetic(bool intense);
	void Multicast_OnRepaired(const bool showGeneratorCloneLoudNoise, const bool isAutoCompleted, const int32 updatedRemainingGeneratorCount);
	void Multicast_PlayFailSparksFX(class ADBDPlayer* player, bool explode);
	void NotifyRepairFinish(const class ADBDPlayer* player, class UInteractor* interactor);
	void NotifyRepairStart(const class ADBDPlayer* player);
	void OnBlockingStatusChanged(const bool isBlocked);
	void OnCaptureProbeSecondState();
	void OnChargeApplied(float individualChargeAmount, float totalChargeAmount, class AActor* chargeInstigator, bool wasCoop, float deltaTime);
	void OnChargeChanged(class UChargeableComponent* chargeableComponent, float percent);
	void OnDamageCosmetic(bool intense);
	void OnEscapeDoorActivated();
	void OnPreWarmASMCache();
	void OnRep_DamageData();
	void OnRep_IsBlocked();
	void OnRepairedBP(const bool showGeneratorCloneLoudNoise, const bool isAutoCompleted);
	void OnResetGenerator();
	void OnUpdateChargeProgress(float newPercentComplete);
	void PlayFailSparksFX(class ADBDPlayer* interactingPlayer, bool explode);
	int32 PostAkEvent(class UAkAudioEvent* AkEvent, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, const TArray<struct FAkExternalSourceInfo>& ExternalSources, const class FString& in_EventName);
	void RemovePlayerStartTime(const class ADBDPlayer* player);
	void ResetGenerator();
	void SetComplete(bool complete);
	void SetIsAutoCompleted(const bool isAutoCompleted);
	void SetIsBlockedFromCharging(bool isBlockedFromCharging);
	void SetIsOvercharged(const bool overcharged);
	void SpawnBloodEffectToSocket(const class FName name);
	void TriggerSkillCheck(class ADBDPlayer* instigatingPlayer);
	void TriggerSkillCheckFailureLoudNoise(class ADBDPlayer* instigatingPlayer);
	void VFXClampTopActivationSingleLight(float distance, class FName parameterName);

	void ActivateTeleportGeneratorIndicator(bool activate) const;
	TArray<class ADBDPlayer*> Authority_GetRepairingCampers() const;
	bool Authority_HasRepairedDamage(const class ADBDPlayer* player) const;
	void BroadcastGeneratorRepairedBySurvivor(class ADBDPlayer* repairingSurvivor) const;
	bool CanSurvivorReactToBlockingEntity(const class ACamperPlayer* survivor) const;
	float GetChargePercentComplete() const;
	class UChargeableComponent* GetGeneratorChargeComponent() const;
	bool GetIsAutoCompleted() const;
	float GetPlayerStartTime(const class ADBDPlayer* player) const;
	const TArray<struct FPlayerFloatTuple> GetPlayerStartTimes() const;
	TArray<class ADBDPlayer*> GetRepairers() const;
	float GetRepairPercentComplete() const;
	class USkeletalMeshComponent* GetSkeletalMesh() const;
	bool IsBeingDamagedByKiller() const;
	bool IsBeingRepaired() const;
	bool IsBlocked() const;
	bool IsIntenseDamage() const;
	bool IsRegressing() const;
	bool ShouldDoOverchargeSkillcheck() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Generator">();
	}
	static class AGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGenerator>();
	}
};
static_assert(alignof(AGenerator) == 0x000008, "Wrong alignment on AGenerator");
static_assert(sizeof(AGenerator) == 0x0005D8, "Wrong size on AGenerator");
static_assert(offsetof(AGenerator, Activated) == 0x000338, "Member 'AGenerator::Activated' has a wrong offset!");
static_assert(offsetof(AGenerator, IsRepaired) == 0x000339, "Member 'AGenerator::IsRepaired' has a wrong offset!");
static_assert(offsetof(AGenerator, WasASMCachePreWarmTriggered) == 0x00033A, "Member 'AGenerator::WasASMCachePreWarmTriggered' has a wrong offset!");
static_assert(offsetof(AGenerator, IsPlaySkillcheckAesthetic) == 0x00033B, "Member 'AGenerator::IsPlaySkillcheckAesthetic' has a wrong offset!");
static_assert(offsetof(AGenerator, KillerOutlineFadeCurve) == 0x000340, "Member 'AGenerator::KillerOutlineFadeCurve' has a wrong offset!");
static_assert(offsetof(AGenerator, NativePercentComplete) == 0x000348, "Member 'AGenerator::NativePercentComplete' has a wrong offset!");
static_assert(offsetof(AGenerator, OnGeneratorRepaired) == 0x000350, "Member 'AGenerator::OnGeneratorRepaired' has a wrong offset!");
static_assert(offsetof(AGenerator, OnGeneratorRepairedBySurvivor) == 0x000360, "Member 'AGenerator::OnGeneratorRepairedBySurvivor' has a wrong offset!");
static_assert(offsetof(AGenerator, OnIsDamagedChanged) == 0x000370, "Member 'AGenerator::OnIsDamagedChanged' has a wrong offset!");
static_assert(offsetof(AGenerator, FireLevelScoreEventOnFix) == 0x0003B0, "Member 'AGenerator::FireLevelScoreEventOnFix' has a wrong offset!");
static_assert(offsetof(AGenerator, _activatedTopLightsTransformMap) == 0x0003B8, "Member 'AGenerator::_activatedTopLightsTransformMap' has a wrong offset!");
static_assert(offsetof(AGenerator, _perceptionStimuliComponent) == 0x000408, "Member 'AGenerator::_perceptionStimuliComponent' has a wrong offset!");
static_assert(offsetof(AGenerator, _repairSemanticTag) == 0x000434, "Member 'AGenerator::_repairSemanticTag' has a wrong offset!");
static_assert(offsetof(AGenerator, _damageData) == 0x000440, "Member 'AGenerator::_damageData' has a wrong offset!");
static_assert(offsetof(AGenerator, _isBlocked) == 0x000468, "Member 'AGenerator::_isBlocked' has a wrong offset!");
static_assert(offsetof(AGenerator, _isBlockedFromCharging) == 0x000469, "Member 'AGenerator::_isBlockedFromCharging' has a wrong offset!");
static_assert(offsetof(AGenerator, _blockingSources) == 0x000470, "Member 'AGenerator::_blockingSources' has a wrong offset!");
static_assert(offsetof(AGenerator, _generatorCharge) == 0x0004F0, "Member 'AGenerator::_generatorCharge' has a wrong offset!");
static_assert(offsetof(AGenerator, _playerStartTimes) == 0x0004F8, "Member 'AGenerator::_playerStartTimes' has a wrong offset!");
static_assert(offsetof(AGenerator, _isAutoCompleted) == 0x000520, "Member 'AGenerator::_isAutoCompleted' has a wrong offset!");
static_assert(offsetof(AGenerator, _isOvercharged) == 0x000521, "Member 'AGenerator::_isOvercharged' has a wrong offset!");
static_assert(offsetof(AGenerator, _coopRepairTracker) == 0x000528, "Member 'AGenerator::_coopRepairTracker' has a wrong offset!");
static_assert(offsetof(AGenerator, _VFX_LightDistanceDefault) == 0x000540, "Member 'AGenerator::_VFX_LightDistanceDefault' has a wrong offset!");
static_assert(offsetof(AGenerator, _damagingInteractions) == 0x0005A0, "Member 'AGenerator::_damagingInteractions' has a wrong offset!");
static_assert(offsetof(AGenerator, _intenseImmediateDamageThreshold) == 0x0005B0, "Member 'AGenerator::_intenseImmediateDamageThreshold' has a wrong offset!");

// Class DeadByDaylight.DBDGeneratorDrivenReflectionCaptureActor
// 0x0018 (0x0270 - 0x0258)
class ADBDGeneratorDrivenReflectionCaptureActor final : public AGeneratorDrivenActor
{
public:
	class UGenyReflectionCaptureComponent*        genyReflectionCapture;                             // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SwapToSecondState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDGeneratorDrivenReflectionCaptureActor">();
	}
	static class ADBDGeneratorDrivenReflectionCaptureActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDGeneratorDrivenReflectionCaptureActor>();
	}
};
static_assert(alignof(ADBDGeneratorDrivenReflectionCaptureActor) == 0x000008, "Wrong alignment on ADBDGeneratorDrivenReflectionCaptureActor");
static_assert(sizeof(ADBDGeneratorDrivenReflectionCaptureActor) == 0x000270, "Wrong size on ADBDGeneratorDrivenReflectionCaptureActor");
static_assert(offsetof(ADBDGeneratorDrivenReflectionCaptureActor, genyReflectionCapture) == 0x000258, "Member 'ADBDGeneratorDrivenReflectionCaptureActor::genyReflectionCapture' has a wrong offset!");

// Class DeadByDaylight.GeneratorEntity
// 0x0028 (0x0258 - 0x0230)
class AGeneratorEntity final : public AActor
{
public:
	class AGenerator*                             _associatedGenerator;                              // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x18];                                     // 0x0240(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayMontage(const struct FAnimationMontageDescriptor& animMontageID, float playRate, bool isFollower);
	void SetAssociatedGenerator(class AGenerator* generator);
	void SetSkeletalMeshActive(bool active);

	class UMontagePlayer* GetMontagePlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorEntity">();
	}
	static class AGeneratorEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGeneratorEntity>();
	}
};
static_assert(alignof(AGeneratorEntity) == 0x000008, "Wrong alignment on AGeneratorEntity");
static_assert(sizeof(AGeneratorEntity) == 0x000258, "Wrong size on AGeneratorEntity");
static_assert(offsetof(AGeneratorEntity, _associatedGenerator) == 0x000230, "Member 'AGeneratorEntity::_associatedGenerator' has a wrong offset!");
static_assert(offsetof(AGeneratorEntity, _montagePlayer) == 0x000238, "Member 'AGeneratorEntity::_montagePlayer' has a wrong offset!");

// Class DeadByDaylight.GeneratorOutlineUpdateStrategy
// 0x0038 (0x0170 - 0x0138)
class UGeneratorOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _unrepairedAuraColor;                              // 0x0138(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _fullyRepairedAuraColor;                           // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x18];                                     // 0x0158(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLinearColor GetWhiteColor() const;
	struct FLinearColor GetYellowColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorOutlineUpdateStrategy">();
	}
	static class UGeneratorOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UGeneratorOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UGeneratorOutlineUpdateStrategy");
static_assert(sizeof(UGeneratorOutlineUpdateStrategy) == 0x000170, "Wrong size on UGeneratorOutlineUpdateStrategy");
static_assert(offsetof(UGeneratorOutlineUpdateStrategy, _unrepairedAuraColor) == 0x000138, "Member 'UGeneratorOutlineUpdateStrategy::_unrepairedAuraColor' has a wrong offset!");
static_assert(offsetof(UGeneratorOutlineUpdateStrategy, _fullyRepairedAuraColor) == 0x000148, "Member 'UGeneratorOutlineUpdateStrategy::_fullyRepairedAuraColor' has a wrong offset!");

// Class DeadByDaylight.GeneratorTrappableComponent
// 0x0040 (0x00F8 - 0x00B8)
class UGeneratorTrappableComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const EGeneratorTrapType trapType)> OnTrapGenerator;               // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const EGeneratorTrapType trapType)> OnRemoveTrap;                  // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<EGeneratorTrapType>                    _trapsOnGenerator;                                 // 0x00D8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetHasAnyTrap();
	bool GetHasTrap(const EGeneratorTrapType trapType);
	void OnRep_TrapsOnGenerator();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorTrappableComponent">();
	}
	static class UGeneratorTrappableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorTrappableComponent>();
	}
};
static_assert(alignof(UGeneratorTrappableComponent) == 0x000008, "Wrong alignment on UGeneratorTrappableComponent");
static_assert(sizeof(UGeneratorTrappableComponent) == 0x0000F8, "Wrong size on UGeneratorTrappableComponent");
static_assert(offsetof(UGeneratorTrappableComponent, OnTrapGenerator) == 0x0000B8, "Member 'UGeneratorTrappableComponent::OnTrapGenerator' has a wrong offset!");
static_assert(offsetof(UGeneratorTrappableComponent, OnRemoveTrap) == 0x0000C8, "Member 'UGeneratorTrappableComponent::OnRemoveTrap' has a wrong offset!");
static_assert(offsetof(UGeneratorTrappableComponent, _trapsOnGenerator) == 0x0000D8, "Member 'UGeneratorTrappableComponent::_trapsOnGenerator' has a wrong offset!");

// Class DeadByDaylight.GeneratorTrapPerk
// 0x00F0 (0x04B8 - 0x03C8)
class UGeneratorTrapPerk : public UPerk
{
public:
	struct FSecondaryInteractionProperties        _secondaryActionProperties;                        // 0x03C8(0x0038)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _secondsToActivatePerk;                            // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _generatorTrapDurationLevels[0x3];                 // 0x0404(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _progressPercentRequirementLevels[0x3];            // 0x0410(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _onePerGenerator;                                  // 0x041C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41D[0x3];                                      // 0x041D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AGenerator*                             _generatorBeingRepaired;                           // 0x0420(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGenerator*                             _trappedGenerator;                                 // 0x0428(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _currentRepairInteractionWithAbility;              // 0x0440(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _progressPercent;                                  // 0x0448(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44C[0x6C];                                     // 0x044C(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnExitGatesPowered(const struct FGameplayTag& gameEventTag, const struct FGameEventData& gameEventData);
	void Authority_OnGeneratorCompleted(bool isAutoCompleted);
	void Authority_OnRepairProgress(float individualChargeAmount, float totalChargeAmount, class AActor* chargeInstigator, bool wasCoop, float deltaTime);
	void Authority_OnTrapDamaged(const struct FGameplayTag& gameEventTag, const struct FGameEventData& gameEventData);
	void Client_OnTrapActivated(const class AGenerator* generator);
	void Client_OnTrapDestroyed(const class AGenerator* generator, const ETrapRemovedReason reason);
	void Local_TrapActivated(const class AGenerator* generator);
	void Local_TrapDestroyed(const class AGenerator* generator, const ETrapRemovedReason reason);
	void OnRep_CurrentRepairInteractionWithAbility(class UInteractionDefinition* oldRepairInteraction);
	void OnRep_TrappedGenerator(class AGenerator* oldGenerator);
	void Server_TryTriggerAction();

	float GetGeneratorTrapDuration() const;
	float GetRepairProgressPercent() const;
	float GetRequiredRepairProgressForSettingTrap() const;
	float GetSecondsToActivatePerk() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorTrapPerk">();
	}
	static class UGeneratorTrapPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorTrapPerk>();
	}
};
static_assert(alignof(UGeneratorTrapPerk) == 0x000008, "Wrong alignment on UGeneratorTrapPerk");
static_assert(sizeof(UGeneratorTrapPerk) == 0x0004B8, "Wrong size on UGeneratorTrapPerk");
static_assert(offsetof(UGeneratorTrapPerk, _secondaryActionProperties) == 0x0003C8, "Member 'UGeneratorTrapPerk::_secondaryActionProperties' has a wrong offset!");
static_assert(offsetof(UGeneratorTrapPerk, _secondsToActivatePerk) == 0x000400, "Member 'UGeneratorTrapPerk::_secondsToActivatePerk' has a wrong offset!");
static_assert(offsetof(UGeneratorTrapPerk, _generatorTrapDurationLevels) == 0x000404, "Member 'UGeneratorTrapPerk::_generatorTrapDurationLevels' has a wrong offset!");
static_assert(offsetof(UGeneratorTrapPerk, _progressPercentRequirementLevels) == 0x000410, "Member 'UGeneratorTrapPerk::_progressPercentRequirementLevels' has a wrong offset!");
static_assert(offsetof(UGeneratorTrapPerk, _onePerGenerator) == 0x00041C, "Member 'UGeneratorTrapPerk::_onePerGenerator' has a wrong offset!");
static_assert(offsetof(UGeneratorTrapPerk, _generatorBeingRepaired) == 0x000420, "Member 'UGeneratorTrapPerk::_generatorBeingRepaired' has a wrong offset!");
static_assert(offsetof(UGeneratorTrapPerk, _trappedGenerator) == 0x000428, "Member 'UGeneratorTrapPerk::_trappedGenerator' has a wrong offset!");
static_assert(offsetof(UGeneratorTrapPerk, _currentRepairInteractionWithAbility) == 0x000440, "Member 'UGeneratorTrapPerk::_currentRepairInteractionWithAbility' has a wrong offset!");
static_assert(offsetof(UGeneratorTrapPerk, _progressPercent) == 0x000448, "Member 'UGeneratorTrapPerk::_progressPercent' has a wrong offset!");

// Class DeadByDaylight.GeneratorUtilities
// 0x0000 (0x0030 - 0x0030)
class UGeneratorUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneratorUtilities">();
	}
	static class UGeneratorUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneratorUtilities>();
	}
};
static_assert(alignof(UGeneratorUtilities) == 0x000008, "Wrong alignment on UGeneratorUtilities");
static_assert(sizeof(UGeneratorUtilities) == 0x000030, "Wrong size on UGeneratorUtilities");

// Class DeadByDaylight.GenyReflectionCaptureComponent
// 0x0010 (0x0230 - 0x0220)
class UGenyReflectionCaptureComponent final : public USceneComponent
{
public:
	TArray<struct FReflectionCaptureTwoStates>    generatorDrivenReflectionCapture;                  // 0x0218(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenyReflectionCaptureComponent">();
	}
	static class UGenyReflectionCaptureComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenyReflectionCaptureComponent>();
	}
};
static_assert(alignof(UGenyReflectionCaptureComponent) == 0x000010, "Wrong alignment on UGenyReflectionCaptureComponent");
static_assert(sizeof(UGenyReflectionCaptureComponent) == 0x000230, "Wrong size on UGenyReflectionCaptureComponent");
static_assert(offsetof(UGenyReflectionCaptureComponent, generatorDrivenReflectionCapture) == 0x000218, "Member 'UGenyReflectionCaptureComponent::generatorDrivenReflectionCapture' has a wrong offset!");

// Class DeadByDaylight.GestureInteractionDefinition
// 0x0000 (0x0620 - 0x0620)
class UGestureInteractionDefinition final : public UInteractionDefinition
{
public:
	EGestureID                                    _gestureID;                                        // 0x0618(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_619[0x7];                                      // 0x0619(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GestureInteractionDefinition">();
	}
	static class UGestureInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGestureInteractionDefinition>();
	}
};
static_assert(alignof(UGestureInteractionDefinition) == 0x000010, "Wrong alignment on UGestureInteractionDefinition");
static_assert(sizeof(UGestureInteractionDefinition) == 0x000620, "Wrong size on UGestureInteractionDefinition");
static_assert(offsetof(UGestureInteractionDefinition, _gestureID) == 0x000618, "Member 'UGestureInteractionDefinition::_gestureID' has a wrong offset!");

// Class DeadByDaylight.GhostStalkedUIData
// 0x0000 (0x0000 - 0x0000)
class IGhostStalkedUIData final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostStalkedUIData">();
	}
	static class IGhostStalkedUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGhostStalkedUIData>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGhostStalkedUIData) == 0x000001, "Wrong alignment on IGhostStalkedUIData");
static_assert(sizeof(IGhostStalkedUIData) == 0x000001, "Wrong size on IGhostStalkedUIData");

// Class DeadByDaylight.GhostStealthUIData
// 0x0000 (0x0000 - 0x0000)
class IGhostStealthUIData final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostStealthUIData">();
	}
	static class IGhostStealthUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGhostStealthUIData>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IGhostStealthUIData) == 0x000001, "Wrong alignment on IGhostStealthUIData");
static_assert(sizeof(IGhostStealthUIData) == 0x000001, "Wrong size on IGhostStealthUIData");

// Class DeadByDaylight.GiftManager
// 0x0038 (0x0070 - 0x0038)
class UGiftManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GiftManager">();
	}
	static class UGiftManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGiftManager>();
	}
};
static_assert(alignof(UGiftManager) == 0x000008, "Wrong alignment on UGiftManager");
static_assert(sizeof(UGiftManager) == 0x000070, "Wrong size on UGiftManager");

// Class DeadByDaylight.GRDKProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UGRDKProfileDAL final : public UPS4GRDKBaseProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GRDKProfileDAL">();
	}
	static class UGRDKProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGRDKProfileDAL>();
	}
};
static_assert(alignof(UGRDKProfileDAL) == 0x000008, "Wrong alignment on UGRDKProfileDAL");
static_assert(sizeof(UGRDKProfileDAL) == 0x000088, "Wrong size on UGRDKProfileDAL");

// Class DeadByDaylight.HalloweenEventComponent
// 0x0088 (0x0140 - 0x00B8)
class UHalloweenEventComponent final : public UActorComponent
{
public:
	class USectionnedChargeableComponent*         _toxinVialComponent;                               // 0x00B8(0x0008)(Edit, ExportObject, Net, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x80];                                      // 0x00C0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedPlaying(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void OnRep_Vial();
	void Server_SpawnVial(float initialCharge);

	class USectionnedChargeableComponent* GetVial() const;
	bool IsVialFull() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HalloweenEventComponent">();
	}
	static class UHalloweenEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHalloweenEventComponent>();
	}
};
static_assert(alignof(UHalloweenEventComponent) == 0x000008, "Wrong alignment on UHalloweenEventComponent");
static_assert(sizeof(UHalloweenEventComponent) == 0x000140, "Wrong size on UHalloweenEventComponent");
static_assert(offsetof(UHalloweenEventComponent, _toxinVialComponent) == 0x0000B8, "Member 'UHalloweenEventComponent::_toxinVialComponent' has a wrong offset!");

// Class DeadByDaylight.HasTokenOrActivationTimerElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UHasTokenOrActivationTimerElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasTokenOrActivationTimerElapsedIconStrategy">();
	}
	static class UHasTokenOrActivationTimerElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasTokenOrActivationTimerElapsedIconStrategy>();
	}
};
static_assert(alignof(UHasTokenOrActivationTimerElapsedIconStrategy) == 0x000008, "Wrong alignment on UHasTokenOrActivationTimerElapsedIconStrategy");
static_assert(sizeof(UHasTokenOrActivationTimerElapsedIconStrategy) == 0x000038, "Wrong size on UHasTokenOrActivationTimerElapsedIconStrategy");

// Class DeadByDaylight.Hatch
// 0x00B8 (0x03E0 - 0x0328)
class AHatch final : public AInteractable
{
public:
	uint8                                         Pad_328[0x50];                                     // 0x0328(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	EHatchState                                   _hatchState;                                       // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_379[0x1];                                      // 0x0379(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isEndGameOver;                                    // 0x037A(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isForceOpen;                                      // 0x037B(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _attemptToCloseHatchOnNextEscape;                  // 0x037C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_37D[0xB];                                      // 0x037D(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    _baseCollision;                                    // 0x0388(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x18];                                     // 0x0390(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _hatchOpenDuration;                                // 0x03A8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x10];                                     // 0x03D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_CheckedChangeActiveState();
	void Authority_CheckedCloseHatch();
	void Authority_CheckedOpenForceClosedHatch();
	void Authority_CheckedOpenHatch();
	void Authority_OnCloseTimerComplete();
	void Authority_OnEndGameOver(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Authority_OnHatchVisibilityChanged(bool isVisible);
	void Authority_OnSurvivorsLeftChanged(int32 survivorRemaining);
	void Authority_ResetTimer(float duration);
	void Authority_SetHatchState(EHatchState newState);
	void Authority_SetIsForceOpen(bool isForcedOpen);
	void FXCloseHatch();
	void FXEndSmoke();
	void FXOpenHatch();
	void OnHatchStateModified(EHatchState oldState, EHatchState newState);
	void OnHatchStateUnhidden();
	void OnRep_HatchState(EHatchState oldState);

	class UAnimationMontageSlave* GetAnimationMontageSlave() const;
	class USceneComponent* GetEscapeFocalPoint() const;
	class USceneComponent* GetHatchCenter() const;
	EHatchState GetHatchState() const;
	bool IsOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Hatch">();
	}
	static class AHatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHatch>();
	}
};
static_assert(alignof(AHatch) == 0x000008, "Wrong alignment on AHatch");
static_assert(sizeof(AHatch) == 0x0003E0, "Wrong size on AHatch");
static_assert(offsetof(AHatch, _hatchState) == 0x000378, "Member 'AHatch::_hatchState' has a wrong offset!");
static_assert(offsetof(AHatch, _isEndGameOver) == 0x00037A, "Member 'AHatch::_isEndGameOver' has a wrong offset!");
static_assert(offsetof(AHatch, _isForceOpen) == 0x00037B, "Member 'AHatch::_isForceOpen' has a wrong offset!");
static_assert(offsetof(AHatch, _attemptToCloseHatchOnNextEscape) == 0x00037C, "Member 'AHatch::_attemptToCloseHatchOnNextEscape' has a wrong offset!");
static_assert(offsetof(AHatch, _baseCollision) == 0x000388, "Member 'AHatch::_baseCollision' has a wrong offset!");
static_assert(offsetof(AHatch, _hatchOpenDuration) == 0x0003A8, "Member 'AHatch::_hatchOpenDuration' has a wrong offset!");

// Class DeadByDaylight.HatchOutlineUpdateStrategy
// 0x0000 (0x00E0 - 0x00E0)
class UHatchOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HatchOutlineUpdateStrategy">();
	}
	static class UHatchOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHatchOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UHatchOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UHatchOutlineUpdateStrategy");
static_assert(sizeof(UHatchOutlineUpdateStrategy) == 0x0000E0, "Wrong size on UHatchOutlineUpdateStrategy");

// Class DeadByDaylight.HeldInputInteractionStarter
// 0x00E0 (0x0198 - 0x00B8)
class UHeldInputInteractionStarter final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xE0];                                      // 0x00B8(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeldInputInteractionStarter">();
	}
	static class UHeldInputInteractionStarter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeldInputInteractionStarter>();
	}
};
static_assert(alignof(UHeldInputInteractionStarter) == 0x000008, "Wrong alignment on UHeldInputInteractionStarter");
static_assert(sizeof(UHeldInputInteractionStarter) == 0x000198, "Wrong size on UHeldInputInteractionStarter");

// Class DeadByDaylight.HitValidationConfigsComponent
// 0x0040 (0x00F8 - 0x00B8)
class UHitValidationConfigsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x40];                                      // 0x00B8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DBD_PrintInGameHitValidationConfigs();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitValidationConfigsComponent">();
	}
	static class UHitValidationConfigsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitValidationConfigsComponent>();
	}
};
static_assert(alignof(UHitValidationConfigsComponent) == 0x000008, "Wrong alignment on UHitValidationConfigsComponent");
static_assert(sizeof(UHitValidationConfigsComponent) == 0x0000F8, "Wrong size on UHitValidationConfigsComponent");

// Class DeadByDaylight.HookAntiCampingComponent
// 0x00D8 (0x0190 - 0x00B8)
class UHookAntiCampingComponent final : public UActorComponent
{
public:
	bool                                          IsAntiCampingFeatureEnabled;                       // 0x00B8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _detectionRange;                                   // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x4];                                       // 0x00C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _killerGracePeriodTime;                            // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x4];                                       // 0x00C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timeToActivate;                                   // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _enduranceEffectActiveTime;                        // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _chargeSpeedCurve;                                 // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x81];                                      // 0x00E0(0x0081)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _addEnduranceEffectAfterSelfUnhook;                // 0x0161(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_162[0x6];                                      // 0x0162(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _enduranceEffectClass;                             // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _selfUnhookAlwaysSucceedEffectClass;               // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _selfUnhookAlwaysSucceedEffect;                    // 0x0178(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _chargeSpeed;                                      // 0x0180(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timerPercent;                                     // 0x0184(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _unhookingSelfAllowedDuringStrugglePhase;          // 0x0188(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_189[0x7];                                      // 0x0189(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_UnhookingSelfAllowedDuringStrugglePhase();

	bool CanUnhookWithAutoSuccess() const;
	float GetCampTimerCompletionPercent() const;
	float GetCurrentChargeSpeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HookAntiCampingComponent">();
	}
	static class UHookAntiCampingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHookAntiCampingComponent>();
	}
};
static_assert(alignof(UHookAntiCampingComponent) == 0x000008, "Wrong alignment on UHookAntiCampingComponent");
static_assert(sizeof(UHookAntiCampingComponent) == 0x000190, "Wrong size on UHookAntiCampingComponent");
static_assert(offsetof(UHookAntiCampingComponent, IsAntiCampingFeatureEnabled) == 0x0000B8, "Member 'UHookAntiCampingComponent::IsAntiCampingFeatureEnabled' has a wrong offset!");
static_assert(offsetof(UHookAntiCampingComponent, _detectionRange) == 0x0000BC, "Member 'UHookAntiCampingComponent::_detectionRange' has a wrong offset!");
static_assert(offsetof(UHookAntiCampingComponent, _killerGracePeriodTime) == 0x0000C4, "Member 'UHookAntiCampingComponent::_killerGracePeriodTime' has a wrong offset!");
static_assert(offsetof(UHookAntiCampingComponent, _timeToActivate) == 0x0000CC, "Member 'UHookAntiCampingComponent::_timeToActivate' has a wrong offset!");
static_assert(offsetof(UHookAntiCampingComponent, _enduranceEffectActiveTime) == 0x0000D0, "Member 'UHookAntiCampingComponent::_enduranceEffectActiveTime' has a wrong offset!");
static_assert(offsetof(UHookAntiCampingComponent, _chargeSpeedCurve) == 0x0000D8, "Member 'UHookAntiCampingComponent::_chargeSpeedCurve' has a wrong offset!");
static_assert(offsetof(UHookAntiCampingComponent, _addEnduranceEffectAfterSelfUnhook) == 0x000161, "Member 'UHookAntiCampingComponent::_addEnduranceEffectAfterSelfUnhook' has a wrong offset!");
static_assert(offsetof(UHookAntiCampingComponent, _enduranceEffectClass) == 0x000168, "Member 'UHookAntiCampingComponent::_enduranceEffectClass' has a wrong offset!");
static_assert(offsetof(UHookAntiCampingComponent, _selfUnhookAlwaysSucceedEffectClass) == 0x000170, "Member 'UHookAntiCampingComponent::_selfUnhookAlwaysSucceedEffectClass' has a wrong offset!");
static_assert(offsetof(UHookAntiCampingComponent, _selfUnhookAlwaysSucceedEffect) == 0x000178, "Member 'UHookAntiCampingComponent::_selfUnhookAlwaysSucceedEffect' has a wrong offset!");
static_assert(offsetof(UHookAntiCampingComponent, _chargeSpeed) == 0x000180, "Member 'UHookAntiCampingComponent::_chargeSpeed' has a wrong offset!");
static_assert(offsetof(UHookAntiCampingComponent, _timerPercent) == 0x000184, "Member 'UHookAntiCampingComponent::_timerPercent' has a wrong offset!");
static_assert(offsetof(UHookAntiCampingComponent, _unhookingSelfAllowedDuringStrugglePhase) == 0x000188, "Member 'UHookAntiCampingComponent::_unhookingSelfAllowedDuringStrugglePhase' has a wrong offset!");

// Class DeadByDaylight.HookedIndicatorWidget
// 0x0010 (0x0390 - 0x0380)
class UHookedIndicatorWidget final : public UBaseIndicatorWidget
{
public:
	float                                         HookedIndicatorDuration;                           // 0x0380(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0xC];                                      // 0x0384(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HookedIndicatorWidget">();
	}
	static class UHookedIndicatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHookedIndicatorWidget>();
	}
};
static_assert(alignof(UHookedIndicatorWidget) == 0x000008, "Wrong alignment on UHookedIndicatorWidget");
static_assert(sizeof(UHookedIndicatorWidget) == 0x000390, "Wrong size on UHookedIndicatorWidget");
static_assert(offsetof(UHookedIndicatorWidget, HookedIndicatorDuration) == 0x000380, "Member 'UHookedIndicatorWidget::HookedIndicatorDuration' has a wrong offset!");

// Class DeadByDaylight.HooksWithSurvivorRestrictedPlacementAreaStrategy
// 0x0098 (0x0138 - 0x00A0)
class UHooksWithSurvivorRestrictedPlacementAreaStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	struct FDBDTunableRowHandle                   RestrictedSphericalRadius;                         // 0x00A0(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRestrictionLingeringEnabled;                    // 0x00C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _restrictionLingerTime;                            // 0x00D0(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x4];                                       // 0x00F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _useSphericalZoneForBasementHooks;                 // 0x00FC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD[0x1B];                                      // 0x00FD(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        RestrictedSphericalLocations;                      // 0x0118(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HooksWithSurvivorRestrictedPlacementAreaStrategy">();
	}
	static class UHooksWithSurvivorRestrictedPlacementAreaStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHooksWithSurvivorRestrictedPlacementAreaStrategy>();
	}
};
static_assert(alignof(UHooksWithSurvivorRestrictedPlacementAreaStrategy) == 0x000008, "Wrong alignment on UHooksWithSurvivorRestrictedPlacementAreaStrategy");
static_assert(sizeof(UHooksWithSurvivorRestrictedPlacementAreaStrategy) == 0x000138, "Wrong size on UHooksWithSurvivorRestrictedPlacementAreaStrategy");
static_assert(offsetof(UHooksWithSurvivorRestrictedPlacementAreaStrategy, RestrictedSphericalRadius) == 0x0000A0, "Member 'UHooksWithSurvivorRestrictedPlacementAreaStrategy::RestrictedSphericalRadius' has a wrong offset!");
static_assert(offsetof(UHooksWithSurvivorRestrictedPlacementAreaStrategy, _isRestrictionLingeringEnabled) == 0x0000C8, "Member 'UHooksWithSurvivorRestrictedPlacementAreaStrategy::_isRestrictionLingeringEnabled' has a wrong offset!");
static_assert(offsetof(UHooksWithSurvivorRestrictedPlacementAreaStrategy, _restrictionLingerTime) == 0x0000D0, "Member 'UHooksWithSurvivorRestrictedPlacementAreaStrategy::_restrictionLingerTime' has a wrong offset!");
static_assert(offsetof(UHooksWithSurvivorRestrictedPlacementAreaStrategy, _useSphericalZoneForBasementHooks) == 0x0000FC, "Member 'UHooksWithSurvivorRestrictedPlacementAreaStrategy::_useSphericalZoneForBasementHooks' has a wrong offset!");
static_assert(offsetof(UHooksWithSurvivorRestrictedPlacementAreaStrategy, RestrictedSphericalLocations) == 0x000118, "Member 'UHooksWithSurvivorRestrictedPlacementAreaStrategy::RestrictedSphericalLocations' has a wrong offset!");

// Class DeadByDaylight.HudUIUtilities
// 0x0000 (0x0030 - 0x0030)
class UHudUIUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HudUIUtilities">();
	}
	static class UHudUIUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHudUIUtilities>();
	}
};
static_assert(alignof(UHudUIUtilities) == 0x000008, "Wrong alignment on UHudUIUtilities");
static_assert(sizeof(UHudUIUtilities) == 0x000030, "Wrong size on UHudUIUtilities");

// Class DeadByDaylight.ChargeableProgressSource
// 0x0000 (0x0000 - 0x0000)
class IChargeableProgressSource final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeableProgressSource">();
	}
	static class IChargeableProgressSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChargeableProgressSource>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IChargeableProgressSource) == 0x000001, "Wrong alignment on IChargeableProgressSource");
static_assert(sizeof(IChargeableProgressSource) == 0x000001, "Wrong size on IChargeableProgressSource");

// Class DeadByDaylight.IdentityValidation
// 0x0000 (0x0030 - 0x0030)
class UIdentityValidation final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IdentityValidation">();
	}
	static class UIdentityValidation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIdentityValidation>();
	}
};
static_assert(alignof(UIdentityValidation) == 0x000008, "Wrong alignment on UIdentityValidation");
static_assert(sizeof(UIdentityValidation) == 0x000030, "Wrong size on UIdentityValidation");

// Class DeadByDaylight.Ethereal
// 0x0000 (0x0000 - 0x0000)
class IEthereal final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ethereal">();
	}
	static class IEthereal* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEthereal>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IEthereal) == 0x000001, "Wrong alignment on IEthereal");
static_assert(sizeof(IEthereal) == 0x000001, "Wrong size on IEthereal");

// Class DeadByDaylight.KillerControls
// 0x0000 (0x0000 - 0x0000)
class IKillerControls final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerControls">();
	}
	static class IKillerControls* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKillerControls>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKillerControls) == 0x000001, "Wrong alignment on IKillerControls");
static_assert(sizeof(IKillerControls) == 0x000001, "Wrong size on IKillerControls");

// Class DeadByDaylight.InboxScreen
// 0x00D0 (0x01F0 - 0x0120)
class UInboxScreen final : public UScreenBase
{
public:
	class UUMGInboxScreen*                        _umgScreen;                                        // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FInboxMessageUIData>            _newsMessages;                                     // 0x0128(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FInboxMessageUIData>            _rewardsMessages;                                  // 0x0138(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FInboxMessageUIData>            _socialMessages;                                   // 0x0148(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x98];                                     // 0x0158(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InboxScreen">();
	}
	static class UInboxScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInboxScreen>();
	}
};
static_assert(alignof(UInboxScreen) == 0x000008, "Wrong alignment on UInboxScreen");
static_assert(sizeof(UInboxScreen) == 0x0001F0, "Wrong size on UInboxScreen");
static_assert(offsetof(UInboxScreen, _umgScreen) == 0x000120, "Member 'UInboxScreen::_umgScreen' has a wrong offset!");
static_assert(offsetof(UInboxScreen, _newsMessages) == 0x000128, "Member 'UInboxScreen::_newsMessages' has a wrong offset!");
static_assert(offsetof(UInboxScreen, _rewardsMessages) == 0x000138, "Member 'UInboxScreen::_rewardsMessages' has a wrong offset!");
static_assert(offsetof(UInboxScreen, _socialMessages) == 0x000148, "Member 'UInboxScreen::_socialMessages' has a wrong offset!");

// Class DeadByDaylight.InboxUtilities
// 0x0000 (0x0030 - 0x0030)
class UInboxUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InboxUtilities">();
	}
	static class UInboxUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInboxUtilities>();
	}
};
static_assert(alignof(UInboxUtilities) == 0x000008, "Wrong alignment on UInboxUtilities");
static_assert(sizeof(UInboxUtilities) == 0x000030, "Wrong size on UInboxUtilities");

// Class DeadByDaylight.InfectedInteractableComponent
// 0x00F0 (0x01A8 - 0x00B8)
class UInfectedInteractableComponent final : public UActorComponent
{
public:
	class UCurveFloat*                            VomitAlphaCurve;                                   // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VomitAlphaParameterName;                           // 0x00C0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimelineComponent*                     _vomitAlphaTimeline;                               // 0x00D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0xD0];                                      // 0x00D8(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnHitWithVomit();
	void Authority_OnOwningInteractableBeginOrEndUse(bool inUse, class ADBDPlayer* interactingPlayer);
	void Multicast_DebugDisplayLifetime(float remainingLifetime);
	void Multicast_DestroyComponent();
	void Multicast_FadeInVomit();
	void Multicast_FadeOutVomit();
	void OnVomitAlphaUpdate(float alpha);
	void SetInteractableMeshAlpha(float alpha);

	class ACamperPlayer* Authority_GetEquippingPlayer() const;
	bool Authority_IsAMaxSicknessSurvivorInteracting() const;
	class AInteractable* GetOwningInteractable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InfectedInteractableComponent">();
	}
	static class UInfectedInteractableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInfectedInteractableComponent>();
	}
};
static_assert(alignof(UInfectedInteractableComponent) == 0x000008, "Wrong alignment on UInfectedInteractableComponent");
static_assert(sizeof(UInfectedInteractableComponent) == 0x0001A8, "Wrong size on UInfectedInteractableComponent");
static_assert(offsetof(UInfectedInteractableComponent, VomitAlphaCurve) == 0x0000B8, "Member 'UInfectedInteractableComponent::VomitAlphaCurve' has a wrong offset!");
static_assert(offsetof(UInfectedInteractableComponent, VomitAlphaParameterName) == 0x0000C0, "Member 'UInfectedInteractableComponent::VomitAlphaParameterName' has a wrong offset!");
static_assert(offsetof(UInfectedInteractableComponent, _vomitAlphaTimeline) == 0x0000D0, "Member 'UInfectedInteractableComponent::_vomitAlphaTimeline' has a wrong offset!");

// Class DeadByDaylight.InGameLoadoutAssetGatherer
// 0x0000 (0x0030 - 0x0030)
class UInGameLoadoutAssetGatherer final : public UInGameAssetPreloaderGatherer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameLoadoutAssetGatherer">();
	}
	static class UInGameLoadoutAssetGatherer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameLoadoutAssetGatherer>();
	}
};
static_assert(alignof(UInGameLoadoutAssetGatherer) == 0x000008, "Wrong alignment on UInGameLoadoutAssetGatherer");
static_assert(sizeof(UInGameLoadoutAssetGatherer) == 0x000030, "Wrong size on UInGameLoadoutAssetGatherer");

// Class DeadByDaylight.InteractableTransformOptimizer
// 0x0008 (0x00C0 - 0x00B8)
class UInteractableTransformOptimizer final : public UActorComponent
{
public:
	bool                                          _optimizeTransformUpdate;                          // 0x00B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractableTransformOptimizer">();
	}
	static class UInteractableTransformOptimizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractableTransformOptimizer>();
	}
};
static_assert(alignof(UInteractableTransformOptimizer) == 0x000008, "Wrong alignment on UInteractableTransformOptimizer");
static_assert(sizeof(UInteractableTransformOptimizer) == 0x0000C0, "Wrong size on UInteractableTransformOptimizer");
static_assert(offsetof(UInteractableTransformOptimizer, _optimizeTransformUpdate) == 0x0000B8, "Member 'UInteractableTransformOptimizer::_optimizeTransformUpdate' has a wrong offset!");

// Class DeadByDaylight.InteractionAnimNotify
// 0x0010 (0x0050 - 0x0040)
class UInteractionAnimNotify final : public UAnimNotify
{
public:
	class FName                                   NotifyID;                                          // 0x0040(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionAnimNotify">();
	}
	static class UInteractionAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionAnimNotify>();
	}
};
static_assert(alignof(UInteractionAnimNotify) == 0x000008, "Wrong alignment on UInteractionAnimNotify");
static_assert(sizeof(UInteractionAnimNotify) == 0x000050, "Wrong size on UInteractionAnimNotify");
static_assert(offsetof(UInteractionAnimNotify, NotifyID) == 0x000040, "Member 'UInteractionAnimNotify::NotifyID' has a wrong offset!");

// Class DeadByDaylight.InteractionDetectorComponent
// 0x00F8 (0x01B0 - 0x00B8)
class UInteractionDetectorComponent final : public UActorComponent
{
public:
	class UPrimitiveComponent*                    _detectionPrimitive;                               // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class AInteractable*>                    _overlappingInteractables;                         // 0x00C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class UPrimitiveComponent*>              _overlappingPrimitiveComponents;                   // 0x0110(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TSet<class AActor*>                           _ignoredActors;                                    // 0x0160(0x0050)(NativeAccessSpecifierPrivate)

public:
	void AddIgnoredActor(class AActor* ignored);
	void BeginOverlapCallback(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool fromSweep, const struct FHitResult& sweepResult);
	void EndOverlapCallback(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex);
	void OnLocallyObservedChanged(class ADBDPlayer* player);
	void SetDetectionPrimitive(class UPrimitiveComponent* detectionPrimitive);

	class UPrimitiveComponent* GetDetectionPrimitive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionDetectorComponent">();
	}
	static class UInteractionDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionDetectorComponent>();
	}
};
static_assert(alignof(UInteractionDetectorComponent) == 0x000008, "Wrong alignment on UInteractionDetectorComponent");
static_assert(sizeof(UInteractionDetectorComponent) == 0x0001B0, "Wrong size on UInteractionDetectorComponent");
static_assert(offsetof(UInteractionDetectorComponent, _detectionPrimitive) == 0x0000B8, "Member 'UInteractionDetectorComponent::_detectionPrimitive' has a wrong offset!");
static_assert(offsetof(UInteractionDetectorComponent, _overlappingInteractables) == 0x0000C0, "Member 'UInteractionDetectorComponent::_overlappingInteractables' has a wrong offset!");
static_assert(offsetof(UInteractionDetectorComponent, _overlappingPrimitiveComponents) == 0x000110, "Member 'UInteractionDetectorComponent::_overlappingPrimitiveComponents' has a wrong offset!");
static_assert(offsetof(UInteractionDetectorComponent, _ignoredActors) == 0x000160, "Member 'UInteractionDetectorComponent::_ignoredActors' has a wrong offset!");

// Class DeadByDaylight.InterruptionDefinition
// 0x00C0 (0x02E0 - 0x0220)
class UInterruptionDefinition final : public USceneComponent
{
public:
	class FName                                   InterruptionID;                                    // 0x0218(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _usesWorldCoordinates;                             // 0x0224(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _snapInterruptor;                                  // 0x0225(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_226[0xA];                                      // 0x0226(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             _interruptionSnapPointForInterruptor;              // 0x0230(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _animationMontageToPlayOnInterruptionEnterForInterruptor; // 0x0260(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _animationMontageToPlayOnInterruptionForInterruptorNew; // 0x0280(0x0020)(Edit, NativeAccessSpecifierPrivate)
	struct FAnimationMontageDescriptor            _animationMontageToPlayOnInterruptionForInterrupteeNew; // 0x02A0(0x0020)(Edit, NativeAccessSpecifierPrivate)
	bool                                          _pickUpOnInterrupt;                                // 0x02C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canInterruptWhileCarrying;                        // 0x02C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _useMontageFollower;                               // 0x02C2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C3[0x1];                                      // 0x02C3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _maxHeightDeltaBetweenCharacters;                  // 0x02C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _interruptionScoreEvent;                           // 0x02C8(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D4[0xC];                                      // 0x02D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInterruptionEnterStart(class ADBDPlayer* interruptor, class ADBDPlayer* interruptee);
	void OnInterruptionExitEnd(class ADBDPlayer* interruptor, class ADBDPlayer* interruptee);
	void OnInterruptionUpdateStart(class ADBDPlayer* interruptor, class ADBDPlayer* interruptee);
	void SetInterruptorSnapPoint(const struct FTransform& Point);

	bool CanInterruptWhileCarrying() const;
	class AInteractable* GetInteractable() const;
	class UInteractionDefinition* GetInteractionDefinition() const;
	struct FVector GetInterruptionSnapPointPositionForInterruptor(const class ADBDPlayer* Interruptor, const class ADBDPlayer* Interruptee) const;
	struct FRotator GetInterruptionSnapPointRotationForInterruptor(const class ADBDPlayer* Interruptor, const class ADBDPlayer* Interruptee) const;
	bool InteractionCheckHeightDelta(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee) const;
	bool IsInterruptionPossible(const class ADBDPlayer* interruptor, const class ADBDPlayer* interruptee) const;
	bool IsUsingAttack() const;
	bool IsUsingMontageFollower() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterruptionDefinition">();
	}
	static class UInterruptionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterruptionDefinition>();
	}
};
static_assert(alignof(UInterruptionDefinition) == 0x000010, "Wrong alignment on UInterruptionDefinition");
static_assert(sizeof(UInterruptionDefinition) == 0x0002E0, "Wrong size on UInterruptionDefinition");
static_assert(offsetof(UInterruptionDefinition, InterruptionID) == 0x000218, "Member 'UInterruptionDefinition::InterruptionID' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _usesWorldCoordinates) == 0x000224, "Member 'UInterruptionDefinition::_usesWorldCoordinates' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _snapInterruptor) == 0x000225, "Member 'UInterruptionDefinition::_snapInterruptor' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _interruptionSnapPointForInterruptor) == 0x000230, "Member 'UInterruptionDefinition::_interruptionSnapPointForInterruptor' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _animationMontageToPlayOnInterruptionEnterForInterruptor) == 0x000260, "Member 'UInterruptionDefinition::_animationMontageToPlayOnInterruptionEnterForInterruptor' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _animationMontageToPlayOnInterruptionForInterruptorNew) == 0x000280, "Member 'UInterruptionDefinition::_animationMontageToPlayOnInterruptionForInterruptorNew' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _animationMontageToPlayOnInterruptionForInterrupteeNew) == 0x0002A0, "Member 'UInterruptionDefinition::_animationMontageToPlayOnInterruptionForInterrupteeNew' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _pickUpOnInterrupt) == 0x0002C0, "Member 'UInterruptionDefinition::_pickUpOnInterrupt' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _canInterruptWhileCarrying) == 0x0002C1, "Member 'UInterruptionDefinition::_canInterruptWhileCarrying' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _useMontageFollower) == 0x0002C2, "Member 'UInterruptionDefinition::_useMontageFollower' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _maxHeightDeltaBetweenCharacters) == 0x0002C4, "Member 'UInterruptionDefinition::_maxHeightDeltaBetweenCharacters' has a wrong offset!");
static_assert(offsetof(UInterruptionDefinition, _interruptionScoreEvent) == 0x0002C8, "Member 'UInterruptionDefinition::_interruptionScoreEvent' has a wrong offset!");

// Class DeadByDaylight.InventoryHandler
// 0x0060 (0x0090 - 0x0030)
class UInventoryHandler final : public UObject
{
public:
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryHandler">();
	}
	static class UInventoryHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryHandler>();
	}
};
static_assert(alignof(UInventoryHandler) == 0x000008, "Wrong alignment on UInventoryHandler");
static_assert(sizeof(UInventoryHandler) == 0x000090, "Wrong size on UInventoryHandler");

// Class DeadByDaylight.PalletPulldownBlockable
// 0x0000 (0x0000 - 0x0000)
class IPalletPulldownBlockable final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletPulldownBlockable">();
	}
	static class IPalletPulldownBlockable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPalletPulldownBlockable>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPalletPulldownBlockable) == 0x000001, "Wrong alignment on IPalletPulldownBlockable");
static_assert(sizeof(IPalletPulldownBlockable) == 0x000001, "Wrong size on IPalletPulldownBlockable");

// Class DeadByDaylight.IsMaximumInfected
// 0x0000 (0x00D0 - 0x00D0)
class UIsMaximumInfected final : public UGameplayModifierCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsMaximumInfected">();
	}
	static class UIsMaximumInfected* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsMaximumInfected>();
	}
};
static_assert(alignof(UIsMaximumInfected) == 0x000008, "Wrong alignment on UIsMaximumInfected");
static_assert(sizeof(UIsMaximumInfected) == 0x0000D0, "Wrong size on UIsMaximumInfected");

// Class DeadByDaylight.IsNotSightedByAnyCharacter
// 0x0008 (0x00F0 - 0x00E8)
class UIsNotSightedByAnyCharacter final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsNotSightedByAnyCharacter">();
	}
	static class UIsNotSightedByAnyCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsNotSightedByAnyCharacter>();
	}
};
static_assert(alignof(UIsNotSightedByAnyCharacter) == 0x000008, "Wrong alignment on UIsNotSightedByAnyCharacter");
static_assert(sizeof(UIsNotSightedByAnyCharacter) == 0x0000F0, "Wrong size on UIsNotSightedByAnyCharacter");

// Class DeadByDaylight.SpectatingActorLinker
// 0x0000 (0x0000 - 0x0000)
class ISpectatingActorLinker final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatingActorLinker">();
	}
	static class ISpectatingActorLinker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpectatingActorLinker>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISpectatingActorLinker) == 0x000001, "Wrong alignment on ISpectatingActorLinker");
static_assert(sizeof(ISpectatingActorLinker) == 0x000001, "Wrong size on ISpectatingActorLinker");

// Class DeadByDaylight.ItemDataAsset
// 0x0040 (0x0088 - 0x0048)
class UItemDataAsset final : public UDBDPrimaryDataAsset
{
public:
	TSoftClassPtr<class UClass>                   ActorClass;                                        // 0x0048(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UGameplayModifierContainerDataAsset>> RequiredModifierContainers;    // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemDataAsset">();
	}
	static class UItemDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemDataAsset>();
	}
};
static_assert(alignof(UItemDataAsset) == 0x000008, "Wrong alignment on UItemDataAsset");
static_assert(sizeof(UItemDataAsset) == 0x000088, "Wrong size on UItemDataAsset");
static_assert(offsetof(UItemDataAsset, ActorClass) == 0x000048, "Member 'UItemDataAsset::ActorClass' has a wrong offset!");
static_assert(offsetof(UItemDataAsset, RequiredModifierContainers) == 0x000078, "Member 'UItemDataAsset::RequiredModifierContainers' has a wrong offset!");

// Class DeadByDaylight.ItemPerformedInteraction
// 0x0000 (0x0000 - 0x0000)
class IItemPerformedInteraction final
{
public:
	bool IsInteractionPerformedWithItem(class ADBDPlayer* instigator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPerformedInteraction">();
	}
	static class IItemPerformedInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemPerformedInteraction>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IItemPerformedInteraction) == 0x000001, "Wrong alignment on IItemPerformedInteraction");
static_assert(sizeof(IItemPerformedInteraction) == 0x000001, "Wrong size on IItemPerformedInteraction");

// Class DeadByDaylight.RecommendationsFilter
// 0x0008 (0x0038 - 0x0030)
class URecommendationsFilter : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecommendationsFilter">();
	}
	static class URecommendationsFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecommendationsFilter>();
	}
};
static_assert(alignof(URecommendationsFilter) == 0x000008, "Wrong alignment on URecommendationsFilter");
static_assert(sizeof(URecommendationsFilter) == 0x000038, "Wrong size on URecommendationsFilter");

// Class DeadByDaylight.ItemRecommendationsFilter
// 0x0028 (0x0060 - 0x0038)
class UItemRecommendationsFilter final : public URecommendationsFilter
{
public:
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemRecommendationsFilter">();
	}
	static class UItemRecommendationsFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemRecommendationsFilter>();
	}
};
static_assert(alignof(UItemRecommendationsFilter) == 0x000008, "Wrong alignment on UItemRecommendationsFilter");
static_assert(sizeof(UItemRecommendationsFilter) == 0x000060, "Wrong size on UItemRecommendationsFilter");

// Class DeadByDaylight.ItemVfx
// 0x0010 (0x0248 - 0x0238)
class AItemVfx final : public ABaseVFX
{
public:
	TArray<class UFXSystemComponent*>             _particleSystems;                                  // 0x0238(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddNiagaraComponent(class UNiagaraComponent* niagaraComponent);
	void AddParticleSystemComponent(class UParticleSystemComponent* particleSystemComponent);
	void AttachToSkeletalMesh(class USkeletalMeshComponent* SkeletonPart);
	void ClearParticleSystems();
	void OnAttackBegin();
	void OnAttackEnd();
	class UNiagaraComponent* SpawnNiagaraSystemAttached(class UNiagaraSystem* systemTemplate, class USceneComponent* attachToComponent, class FName attachPointName, EAttachLocation locationType, bool autoDestroy, ENCPoolMethod poolingMethod, const struct FVector& location, const struct FRotator& rotation, const struct FVector& scale, bool autoActivate, bool preCullCheck, bool absoluteRotation, bool hideInFPV);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemVfx">();
	}
	static class AItemVfx* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemVfx>();
	}
};
static_assert(alignof(AItemVfx) == 0x000008, "Wrong alignment on AItemVfx");
static_assert(sizeof(AItemVfx) == 0x000248, "Wrong size on AItemVfx");
static_assert(offsetof(AItemVfx, _particleSystems) == 0x000238, "Member 'AItemVfx::_particleSystems' has a wrong offset!");

// Class DeadByDaylight.ViewRotationStrategy
// 0x0000 (0x0000 - 0x0000)
class IViewRotationStrategy final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ViewRotationStrategy">();
	}
	static class IViewRotationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<IViewRotationStrategy>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IViewRotationStrategy) == 0x000001, "Wrong alignment on IViewRotationStrategy");
static_assert(sizeof(IViewRotationStrategy) == 0x000001, "Wrong size on IViewRotationStrategy");

// Class DeadByDaylight.KillerAtlantaTutorialLevel
// 0x0040 (0x0368 - 0x0328)
class AKillerAtlantaTutorialLevel final : public AAtlantaTutorialLevel
{
public:
	TWeakObjectPtr<class ASlasherPlayer>          LocallyControllerSlasherPlayer;                    // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ACamperPlayer>           ChaseCamper;                                       // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ACamperPlayer>           BearTrapCamper;                                    // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AGenerator>              KickGenerator;                                     // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AWindow>                 VaultWindow;                                       // 0x0348(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AEscapeDoor>             EscapeDoor;                                        // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AHatch>                  Hatch;                                             // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_360[0x8];                                      // 0x0360(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CompleteEscapeRequirements();
	void SetBearTrapSurvivor(class ACamperPlayer* camperPlayer);
	void SetChaseSurvivor(class ACamperPlayer* camperPlayer);
	void SetControlledSlasherPlayer(class ASlasherPlayer* slasherPlayer);
	void SetEscapeDoor(class AEscapeDoor* targetEscapeDoor);
	void SetGenerator(class AGenerator* generator);
	void SetHatch(class AHatch* targetHatch);
	void SetupEndGameTutorialPhase();
	void SetVaultWindow(class AWindow* window);
	void TriggerEndGameSequenceAnimation(EKillerTutorialEndGameType camperDeathType);
	void TriggerExitGameSetup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAtlantaTutorialLevel">();
	}
	static class AKillerAtlantaTutorialLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKillerAtlantaTutorialLevel>();
	}
};
static_assert(alignof(AKillerAtlantaTutorialLevel) == 0x000008, "Wrong alignment on AKillerAtlantaTutorialLevel");
static_assert(sizeof(AKillerAtlantaTutorialLevel) == 0x000368, "Wrong size on AKillerAtlantaTutorialLevel");
static_assert(offsetof(AKillerAtlantaTutorialLevel, LocallyControllerSlasherPlayer) == 0x000328, "Member 'AKillerAtlantaTutorialLevel::LocallyControllerSlasherPlayer' has a wrong offset!");
static_assert(offsetof(AKillerAtlantaTutorialLevel, ChaseCamper) == 0x000330, "Member 'AKillerAtlantaTutorialLevel::ChaseCamper' has a wrong offset!");
static_assert(offsetof(AKillerAtlantaTutorialLevel, BearTrapCamper) == 0x000338, "Member 'AKillerAtlantaTutorialLevel::BearTrapCamper' has a wrong offset!");
static_assert(offsetof(AKillerAtlantaTutorialLevel, KickGenerator) == 0x000340, "Member 'AKillerAtlantaTutorialLevel::KickGenerator' has a wrong offset!");
static_assert(offsetof(AKillerAtlantaTutorialLevel, VaultWindow) == 0x000348, "Member 'AKillerAtlantaTutorialLevel::VaultWindow' has a wrong offset!");
static_assert(offsetof(AKillerAtlantaTutorialLevel, EscapeDoor) == 0x000350, "Member 'AKillerAtlantaTutorialLevel::EscapeDoor' has a wrong offset!");
static_assert(offsetof(AKillerAtlantaTutorialLevel, Hatch) == 0x000358, "Member 'AKillerAtlantaTutorialLevel::Hatch' has a wrong offset!");

// Class DeadByDaylight.KillerAudioHandlerComponent
// 0x0080 (0x01B8 - 0x0138)
class UKillerAudioHandlerComponent final : public UDBDPlayerAudioHandlerComponent
{
public:
	struct FDBDTunableRowHandle                   _killerMovingShockTime;                            // 0x0138(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 _shockEvent;                                       // 0x0160(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagQuery                      _movingShockCondition;                             // 0x0170(0x0048)(Edit, NativeAccessSpecifierPrivate)

public:
	void ChaseTriggerKillerReactionSpecificSurvivorSFX(class ADBDPlayer* camper);
	void HitImpactOnSurvivorSFX(class ACamperPlayer* camper, EAttackType attackType, bool isWeaponHit);
	void OnChaseStart(class ADBDPlayer* chasedSurvivor);
	void TriggerKillerReactionSpecificSurvivorSFX(class ADBDPlayer* camper);
	void TriggerSurvivorDamageHitAudioSFX(class ACamperPlayer* camper, EAttackType attackType, bool causedKO, bool isWeaponHit, bool isLightHit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAudioHandlerComponent">();
	}
	static class UKillerAudioHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerAudioHandlerComponent>();
	}
};
static_assert(alignof(UKillerAudioHandlerComponent) == 0x000008, "Wrong alignment on UKillerAudioHandlerComponent");
static_assert(sizeof(UKillerAudioHandlerComponent) == 0x0001B8, "Wrong size on UKillerAudioHandlerComponent");
static_assert(offsetof(UKillerAudioHandlerComponent, _killerMovingShockTime) == 0x000138, "Member 'UKillerAudioHandlerComponent::_killerMovingShockTime' has a wrong offset!");
static_assert(offsetof(UKillerAudioHandlerComponent, _shockEvent) == 0x000160, "Member 'UKillerAudioHandlerComponent::_shockEvent' has a wrong offset!");
static_assert(offsetof(UKillerAudioHandlerComponent, _movingShockCondition) == 0x000170, "Member 'UKillerAudioHandlerComponent::_movingShockCondition' has a wrong offset!");

// Class DeadByDaylight.KillerAudioMenuReactionComponent
// 0x0010 (0x00C8 - 0x00B8)
class UKillerAudioMenuReactionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LobbyKillerReactionSpecificSurvivorSFX(const TArray<class ADBDMenuPlayer*>& menuPlayers);
	void OnLobbyTimeChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerAudioMenuReactionComponent">();
	}
	static class UKillerAudioMenuReactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerAudioMenuReactionComponent>();
	}
};
static_assert(alignof(UKillerAudioMenuReactionComponent) == 0x000008, "Wrong alignment on UKillerAudioMenuReactionComponent");
static_assert(sizeof(UKillerAudioMenuReactionComponent) == 0x0000C8, "Wrong size on UKillerAudioMenuReactionComponent");

// Class DeadByDaylight.KillerBlindingFXComponent
// 0x0048 (0x0150 - 0x0108)
class UKillerBlindingFXComponent : public UBlindingFXComponent
{
public:
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          _blindedSound;                                     // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x28];                                     // 0x0128(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_OnBlindedByPlayersCosmetic(const TArray<class ADBDPlayer*>& players);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerBlindingFXComponent">();
	}
	static class UKillerBlindingFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerBlindingFXComponent>();
	}
};
static_assert(alignof(UKillerBlindingFXComponent) == 0x000008, "Wrong alignment on UKillerBlindingFXComponent");
static_assert(sizeof(UKillerBlindingFXComponent) == 0x000150, "Wrong size on UKillerBlindingFXComponent");
static_assert(offsetof(UKillerBlindingFXComponent, _blindedSound) == 0x000120, "Member 'UKillerBlindingFXComponent::_blindedSound' has a wrong offset!");

// Class DeadByDaylight.KillerBloodFXComponent
// 0x0018 (0x00D0 - 0x00B8)
class UKillerBloodFXComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayBloodSplatter();
	void StopBloodSplatter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerBloodFXComponent">();
	}
	static class UKillerBloodFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerBloodFXComponent>();
	}
};
static_assert(alignof(UKillerBloodFXComponent) == 0x000008, "Wrong alignment on UKillerBloodFXComponent");
static_assert(sizeof(UKillerBloodFXComponent) == 0x0000D0, "Wrong size on UKillerBloodFXComponent");

// Class DeadByDaylight.KillerBloodFXInterface
// 0x0000 (0x0000 - 0x0000)
class IKillerBloodFXInterface final
{
public:
	void PlayBloodSplatter();
	void StopBloodSplatter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerBloodFXInterface">();
	}
	static class IKillerBloodFXInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKillerBloodFXInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKillerBloodFXInterface) == 0x000001, "Wrong alignment on IKillerBloodFXInterface");
static_assert(sizeof(IKillerBloodFXInterface) == 0x000001, "Wrong size on IKillerBloodFXInterface");

// Class DeadByDaylight.KillerHitCosmeticHandler
// 0x0018 (0x0048 - 0x0030)
class UKillerHitCosmeticHandler final : public UBaseReversibleInstantActionHandler
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerHitCosmeticHandler">();
	}
	static class UKillerHitCosmeticHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerHitCosmeticHandler>();
	}
};
static_assert(alignof(UKillerHitCosmeticHandler) == 0x000008, "Wrong alignment on UKillerHitCosmeticHandler");
static_assert(sizeof(UKillerHitCosmeticHandler) == 0x000048, "Wrong size on UKillerHitCosmeticHandler");

// Class DeadByDaylight.KillerInstinctInterface
// 0x0000 (0x0000 - 0x0000)
class IKillerInstinctInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerInstinctInterface">();
	}
	static class IKillerInstinctInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IKillerInstinctInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IKillerInstinctInterface) == 0x000001, "Wrong alignment on IKillerInstinctInterface");
static_assert(sizeof(IKillerInstinctInterface) == 0x000001, "Wrong size on IKillerInstinctInterface");

// Class DeadByDaylight.KillerIntroComponent
// 0x0030 (0x00E8 - 0x00B8)
class UKillerIntroComponent final : public UActorComponent
{
public:
	float                                         _percentOfCameraPanInProgressRequiredToHideKiller; // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cameraPanInAmountToSquish;                        // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFPVTransitionStrategy                        _cameraPanInHidingStrategy;                        // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _startKillerIntroDelay;                            // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x20];                                      // 0x00C8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void KillerCameraPanInUpdateNative(const float killerIntroCompletedPercent);
	void OnIntroCompleted();
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerIntroComponent">();
	}
	static class UKillerIntroComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerIntroComponent>();
	}
};
static_assert(alignof(UKillerIntroComponent) == 0x000008, "Wrong alignment on UKillerIntroComponent");
static_assert(sizeof(UKillerIntroComponent) == 0x0000E8, "Wrong size on UKillerIntroComponent");
static_assert(offsetof(UKillerIntroComponent, _percentOfCameraPanInProgressRequiredToHideKiller) == 0x0000B8, "Member 'UKillerIntroComponent::_percentOfCameraPanInProgressRequiredToHideKiller' has a wrong offset!");
static_assert(offsetof(UKillerIntroComponent, _cameraPanInAmountToSquish) == 0x0000BC, "Member 'UKillerIntroComponent::_cameraPanInAmountToSquish' has a wrong offset!");
static_assert(offsetof(UKillerIntroComponent, _cameraPanInHidingStrategy) == 0x0000C0, "Member 'UKillerIntroComponent::_cameraPanInHidingStrategy' has a wrong offset!");
static_assert(offsetof(UKillerIntroComponent, _startKillerIntroDelay) == 0x0000C4, "Member 'UKillerIntroComponent::_startKillerIntroDelay' has a wrong offset!");

// Class DeadByDaylight.KillerNoiseIndicatorWidget
// 0x0000 (0x0380 - 0x0380)
class UKillerNoiseIndicatorWidget final : public UNoiseIndicatorWidget
{
public:
	void SetSoundDistancePercentage(float distancePercentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerNoiseIndicatorWidget">();
	}
	static class UKillerNoiseIndicatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerNoiseIndicatorWidget>();
	}
};
static_assert(alignof(UKillerNoiseIndicatorWidget) == 0x000008, "Wrong alignment on UKillerNoiseIndicatorWidget");
static_assert(sizeof(UKillerNoiseIndicatorWidget) == 0x000380, "Wrong size on UKillerNoiseIndicatorWidget");

// Class DeadByDaylight.KillerOpenGate
// 0x0050 (0x0790 - 0x0740)
class UKillerOpenGate final : public UChargeableInteractionDefinition
{
public:
	struct FAnimationMontageDescriptor            _openGateMontage;                                  // 0x0740(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_760[0x30];                                     // 0x0760(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateSwitch() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerOpenGate">();
	}
	static class UKillerOpenGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerOpenGate>();
	}
};
static_assert(alignof(UKillerOpenGate) == 0x000010, "Wrong alignment on UKillerOpenGate");
static_assert(sizeof(UKillerOpenGate) == 0x000790, "Wrong size on UKillerOpenGate");
static_assert(offsetof(UKillerOpenGate, _openGateMontage) == 0x000740, "Member 'UKillerOpenGate::_openGateMontage' has a wrong offset!");

// Class DeadByDaylight.KillerProjectileDodgeComponent
// 0x0038 (0x00F0 - 0x00B8)
class UKillerProjectileDodgeComponent final : public UActorComponent
{
public:
	class AKillerProjectile*                      _killerProjectile;                                 // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACamperPlayer*>                  _proximitySurvivors;                               // 0x00C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x20];                                      // 0x00D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKillerProjectileFinished(class AActor* survivorHit);
	void OnKillerProjectileFinishedWithoutCollision();
	void OnKillerProjectileLaunched();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectileDodgeComponent">();
	}
	static class UKillerProjectileDodgeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerProjectileDodgeComponent>();
	}
};
static_assert(alignof(UKillerProjectileDodgeComponent) == 0x000008, "Wrong alignment on UKillerProjectileDodgeComponent");
static_assert(sizeof(UKillerProjectileDodgeComponent) == 0x0000F0, "Wrong size on UKillerProjectileDodgeComponent");
static_assert(offsetof(UKillerProjectileDodgeComponent, _killerProjectile) == 0x0000B8, "Member 'UKillerProjectileDodgeComponent::_killerProjectile' has a wrong offset!");
static_assert(offsetof(UKillerProjectileDodgeComponent, _proximitySurvivors) == 0x0000C0, "Member 'UKillerProjectileDodgeComponent::_proximitySurvivors' has a wrong offset!");

// Class DeadByDaylight.KillerProjectileLauncher
// 0x0000 (0x0180 - 0x0180)
class UKillerProjectileLauncher : public UBaseProjectileLauncher
{
public:
	class ASlasherPlayer* GetOwningKiller() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerProjectileLauncher">();
	}
	static class UKillerProjectileLauncher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerProjectileLauncher>();
	}
};
static_assert(alignof(UKillerProjectileLauncher) == 0x000008, "Wrong alignment on UKillerProjectileLauncher");
static_assert(sizeof(UKillerProjectileLauncher) == 0x000180, "Wrong size on UKillerProjectileLauncher");

// Class DeadByDaylight.KillerRedStainUpdateStrategy
// 0x0038 (0x00F0 - 0x00B8)
class UKillerRedStainUpdateStrategy final : public UActorComponent
{
public:
	class UCurveFloat*                            _stealthRatioToRedStainIntensityCurve;             // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _hideRedStainStateTags;                            // 0x00C0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHeadHiddenChanged(bool isHidden);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerRedStainUpdateStrategy">();
	}
	static class UKillerRedStainUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerRedStainUpdateStrategy>();
	}
};
static_assert(alignof(UKillerRedStainUpdateStrategy) == 0x000008, "Wrong alignment on UKillerRedStainUpdateStrategy");
static_assert(sizeof(UKillerRedStainUpdateStrategy) == 0x0000F0, "Wrong size on UKillerRedStainUpdateStrategy");
static_assert(offsetof(UKillerRedStainUpdateStrategy, _stealthRatioToRedStainIntensityCurve) == 0x0000B8, "Member 'UKillerRedStainUpdateStrategy::_stealthRatioToRedStainIntensityCurve' has a wrong offset!");
static_assert(offsetof(UKillerRedStainUpdateStrategy, _hideRedStainStateTags) == 0x0000C0, "Member 'UKillerRedStainUpdateStrategy::_hideRedStainStateTags' has a wrong offset!");

// Class DeadByDaylight.KillerSoundCuesComponent
// 0x0010 (0x00C8 - 0x00B8)
class UKillerSoundCuesComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartTrackingActor(class AActor* actorToStartTracking, class FName distanceDataID);
	void StartTrackingActorWithLifetime(class AActor* actorToStartTracking, class FName distanceDataID, float trackerLifetime);
	void StopTrackingActor(class AActor* actorToStopTracking);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerSoundCuesComponent">();
	}
	static class UKillerSoundCuesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerSoundCuesComponent>();
	}
};
static_assert(alignof(UKillerSoundCuesComponent) == 0x000008, "Wrong alignment on UKillerSoundCuesComponent");
static_assert(sizeof(UKillerSoundCuesComponent) == 0x0000C8, "Wrong size on UKillerSoundCuesComponent");

// Class DeadByDaylight.LacerationUIData
// 0x0000 (0x0000 - 0x0000)
class ILacerationUIData final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LacerationUIData">();
	}
	static class ILacerationUIData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILacerationUIData>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ILacerationUIData) == 0x000001, "Wrong alignment on ILacerationUIData");
static_assert(sizeof(ILacerationUIData) == 0x000001, "Wrong size on ILacerationUIData");

// Class DeadByDaylight.LanternInteractable
// 0x0058 (0x0380 - 0x0328)
class ALanternInteractable final : public AInteractable
{
public:
	TMulticastInlineDelegate<void(ELanternState lanternState, ELanternState previousLanternState)> OnLanternStateChanged; // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* player)> OnLanternCollectedByPlayerCosmetic;     // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x20];                                     // 0x0348(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ALanternLightCollectable>   _collectableClass;                                 // 0x0368(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0x10];                                     // 0x0370(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeLanternState(ELanternState newLanternState);
	void CollectLight(class ADBDPlayer* player);
	void OnBackToCollectableTimerEnd();
	void OnCamperLeavingHook(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void OnCamperWasHooked(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void OnSlasherDestroyedLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void SlasherDestroyLantern(class ADBDPlayer* player);

	bool CanBeCollected() const;
	bool CanBeDestroyed() const;
	ELanternState GetLanternState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LanternInteractable">();
	}
	static class ALanternInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALanternInteractable>();
	}
};
static_assert(alignof(ALanternInteractable) == 0x000008, "Wrong alignment on ALanternInteractable");
static_assert(sizeof(ALanternInteractable) == 0x000380, "Wrong size on ALanternInteractable");
static_assert(offsetof(ALanternInteractable, OnLanternStateChanged) == 0x000328, "Member 'ALanternInteractable::OnLanternStateChanged' has a wrong offset!");
static_assert(offsetof(ALanternInteractable, OnLanternCollectedByPlayerCosmetic) == 0x000338, "Member 'ALanternInteractable::OnLanternCollectedByPlayerCosmetic' has a wrong offset!");
static_assert(offsetof(ALanternInteractable, _collectableClass) == 0x000368, "Member 'ALanternInteractable::_collectableClass' has a wrong offset!");

// Class DeadByDaylight.LevelAISetupComponent
// 0x0000 (0x00B8 - 0x00B8)
class ULevelAISetupComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelAISetupComponent">();
	}
	static class ULevelAISetupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelAISetupComponent>();
	}
};
static_assert(alignof(ULevelAISetupComponent) == 0x000008, "Wrong alignment on ULevelAISetupComponent");
static_assert(sizeof(ULevelAISetupComponent) == 0x0000B8, "Wrong size on ULevelAISetupComponent");

// Class DeadByDaylight.LevelReadyToPlayPlayerComponent
// 0x0050 (0x0108 - 0x00B8)
class ULevelReadyToPlayPlayerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLevelReadyToPlayRequirements>  _levelReadyToPlayRequirementsTarget;               // 0x00D8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FLevelReadyToPlayRequirements>  _levelReadyToPlayRequirementState;                 // 0x00E8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_LevelReadyToPlayRequirementsTarget();
	void Server_SetIsReadyToPlay(uint32 readyToPlay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelReadyToPlayPlayerComponent">();
	}
	static class ULevelReadyToPlayPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelReadyToPlayPlayerComponent>();
	}
};
static_assert(alignof(ULevelReadyToPlayPlayerComponent) == 0x000008, "Wrong alignment on ULevelReadyToPlayPlayerComponent");
static_assert(sizeof(ULevelReadyToPlayPlayerComponent) == 0x000108, "Wrong size on ULevelReadyToPlayPlayerComponent");
static_assert(offsetof(ULevelReadyToPlayPlayerComponent, _levelReadyToPlayRequirementsTarget) == 0x0000D8, "Member 'ULevelReadyToPlayPlayerComponent::_levelReadyToPlayRequirementsTarget' has a wrong offset!");
static_assert(offsetof(ULevelReadyToPlayPlayerComponent, _levelReadyToPlayRequirementState) == 0x0000E8, "Member 'ULevelReadyToPlayPlayerComponent::_levelReadyToPlayRequirementState' has a wrong offset!");

// Class DeadByDaylight.LightFunctionActorSpawner
// 0x0010 (0x02E0 - 0x02D0)
class ULightFunctionActorSpawner final : public UActorSpawner
{
public:
	class UTexture*                               LightFunctionTexture;                              // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightFunctionActorSpawner">();
	}
	static class ULightFunctionActorSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightFunctionActorSpawner>();
	}
};
static_assert(alignof(ULightFunctionActorSpawner) == 0x000010, "Wrong alignment on ULightFunctionActorSpawner");
static_assert(sizeof(ULightFunctionActorSpawner) == 0x0002E0, "Wrong size on ULightFunctionActorSpawner");
static_assert(offsetof(ULightFunctionActorSpawner, LightFunctionTexture) == 0x0002D0, "Member 'ULightFunctionActorSpawner::LightFunctionTexture' has a wrong offset!");

// Class DeadByDaylight.LightingData
// 0x00A0 (0x00D8 - 0x0038)
class ULightingData final : public UDataAsset
{
public:
	TSoftClassPtr<class UClass>                   DefaultLighting;                                   // 0x0038(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   DefaultAtlantaLighting;                            // 0x0068(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSceneLightingDescription>      Descriptions;                                      // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   AdaptiveShadowMapControllersActor;                 // 0x00A8(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingData">();
	}
	static class ULightingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingData>();
	}
};
static_assert(alignof(ULightingData) == 0x000008, "Wrong alignment on ULightingData");
static_assert(sizeof(ULightingData) == 0x0000D8, "Wrong size on ULightingData");
static_assert(offsetof(ULightingData, DefaultLighting) == 0x000038, "Member 'ULightingData::DefaultLighting' has a wrong offset!");
static_assert(offsetof(ULightingData, DefaultAtlantaLighting) == 0x000068, "Member 'ULightingData::DefaultAtlantaLighting' has a wrong offset!");
static_assert(offsetof(ULightingData, Descriptions) == 0x000098, "Member 'ULightingData::Descriptions' has a wrong offset!");
static_assert(offsetof(ULightingData, AdaptiveShadowMapControllersActor) == 0x0000A8, "Member 'ULightingData::AdaptiveShadowMapControllersActor' has a wrong offset!");

// Class DeadByDaylight.LightingFactory
// 0x0008 (0x0038 - 0x0030)
class ULightingFactory final : public UObject
{
public:
	class ULightingData*                          _data;                                             // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingFactory">();
	}
	static class ULightingFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingFactory>();
	}
};
static_assert(alignof(ULightingFactory) == 0x000008, "Wrong alignment on ULightingFactory");
static_assert(sizeof(ULightingFactory) == 0x000038, "Wrong size on ULightingFactory");
static_assert(offsetof(ULightingFactory, _data) == 0x000030, "Member 'ULightingFactory::_data' has a wrong offset!");

// Class DeadByDaylight.LightingInterpolator
// 0x0050 (0x0080 - 0x0030)
class ULightingInterpolator final : public UObject
{
public:
	TMulticastInlineDelegate<void()>              OnInterpolationDone;                               // 0x0030(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x38];                                      // 0x0040(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class ABaseSky*                               _targetLighting;                                   // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static void LerpHeightFog(class UExponentialHeightFogComponent* Target, const class UExponentialHeightFogComponent* A, const class UExponentialHeightFogComponent* B, float alpha, float thresholdBeforeSwitchingtoB);
	static void LerpLight(class ULightComponent* Target, class ULightComponent* A, class ULightComponent* B, float alpha);
	static void LerpSkylight(class USkyLightComponent* Target, class USkyLightComponent* A, class USkyLightComponent* B, float alpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LightingInterpolator">();
	}
	static class ULightingInterpolator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULightingInterpolator>();
	}
};
static_assert(alignof(ULightingInterpolator) == 0x000008, "Wrong alignment on ULightingInterpolator");
static_assert(sizeof(ULightingInterpolator) == 0x000080, "Wrong size on ULightingInterpolator");
static_assert(offsetof(ULightingInterpolator, OnInterpolationDone) == 0x000030, "Member 'ULightingInterpolator::OnInterpolationDone' has a wrong offset!");
static_assert(offsetof(ULightingInterpolator, _targetLighting) == 0x000078, "Member 'ULightingInterpolator::_targetLighting' has a wrong offset!");

// Class DeadByDaylight.LimitAccumulationSpawnerStrategy
// 0x0010 (0x0040 - 0x0030)
class ULimitAccumulationSpawnerStrategy final : public USpawnerStrategy
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMaxOverlapping(int32 maxOverlapping);
	void SetRecycleDistancePercentage(float recycleDistancePercentage);
	void SetRecycleThresholdPercentage(float recycleThresholdPercentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LimitAccumulationSpawnerStrategy">();
	}
	static class ULimitAccumulationSpawnerStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULimitAccumulationSpawnerStrategy>();
	}
};
static_assert(alignof(ULimitAccumulationSpawnerStrategy) == 0x000008, "Wrong alignment on ULimitAccumulationSpawnerStrategy");
static_assert(sizeof(ULimitAccumulationSpawnerStrategy) == 0x000040, "Wrong size on ULimitAccumulationSpawnerStrategy");

// Class DeadByDaylight.LoadingUtilities
// 0x0000 (0x0030 - 0x0030)
class ULoadingUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadingUtilities">();
	}
	static class ULoadingUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadingUtilities>();
	}
};
static_assert(alignof(ULoadingUtilities) == 0x000008, "Wrong alignment on ULoadingUtilities");
static_assert(sizeof(ULoadingUtilities) == 0x000030, "Wrong size on ULoadingUtilities");

// Class DeadByDaylight.LoadoutControllerSubsystem
// 0x0000 (0x0038 - 0x0038)
class ULoadoutControllerSubsystem final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutControllerSubsystem">();
	}
	static class ULoadoutControllerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutControllerSubsystem>();
	}
};
static_assert(alignof(ULoadoutControllerSubsystem) == 0x000008, "Wrong alignment on ULoadoutControllerSubsystem");
static_assert(sizeof(ULoadoutControllerSubsystem) == 0x000038, "Wrong size on ULoadoutControllerSubsystem");

// Class DeadByDaylight.LoadoutPresetController
// 0x0000 (0x0030 - 0x0030)
class ULoadoutPresetController final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutPresetController">();
	}
	static class ULoadoutPresetController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutPresetController>();
	}
};
static_assert(alignof(ULoadoutPresetController) == 0x000008, "Wrong alignment on ULoadoutPresetController");
static_assert(sizeof(ULoadoutPresetController) == 0x000030, "Wrong size on ULoadoutPresetController");

// Class DeadByDaylight.LobbyControllerSubsystem
// 0x0078 (0x00B0 - 0x0038)
class ULobbyControllerSubsystem final : public UGameInstanceSubsystem
{
public:
	TWeakObjectPtr<class ULobbyDisplayStandController> _localPlayerDisplayStandController;           // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, class ULobbyDisplayStandController*> _displayStandControllers;               // 0x0040(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x20];                                      // 0x0090(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyControllerSubsystem">();
	}
	static class ULobbyControllerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyControllerSubsystem>();
	}
};
static_assert(alignof(ULobbyControllerSubsystem) == 0x000008, "Wrong alignment on ULobbyControllerSubsystem");
static_assert(sizeof(ULobbyControllerSubsystem) == 0x0000B0, "Wrong size on ULobbyControllerSubsystem");
static_assert(offsetof(ULobbyControllerSubsystem, _localPlayerDisplayStandController) == 0x000038, "Member 'ULobbyControllerSubsystem::_localPlayerDisplayStandController' has a wrong offset!");
static_assert(offsetof(ULobbyControllerSubsystem, _displayStandControllers) == 0x000040, "Member 'ULobbyControllerSubsystem::_displayStandControllers' has a wrong offset!");

// Class DeadByDaylight.LobbyDialogueSubsystem
// 0x0058 (0x0090 - 0x0038)
class ULobbyDialogueSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CountGuestLobbyMembersWithAudioSwitch(EAudioCustomizationCategory switchCategory, const TArray<class FString>& audioSwitches, int32* numMatching, int32* numNotMatching);
	static TArray<class ADBDMenuPlayer*> GetGuestLobbyMembers();
	static bool HasCharacterPlayedDialogueForThisLobby(const class FString& characterName, int32 dialogueId);
	static bool IsLobbyFullForRole(EPlayerRole role);
	static void NotifyCharacterPlayedDialogueForThisLobby(const class FString& characterName, int32 dialogueId);
	static void NotifyDialogueInterrupted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyDialogueSubsystem">();
	}
	static class ULobbyDialogueSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyDialogueSubsystem>();
	}
};
static_assert(alignof(ULobbyDialogueSubsystem) == 0x000008, "Wrong alignment on ULobbyDialogueSubsystem");
static_assert(sizeof(ULobbyDialogueSubsystem) == 0x000090, "Wrong size on ULobbyDialogueSubsystem");

// Class DeadByDaylight.LobbyDisplayStandController
// 0x00A8 (0x01C8 - 0x0120)
class ULobbyDisplayStandController final : public UDisplayStandController
{
public:
	uint8                                         Pad_120[0xA8];                                     // 0x0120(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyDisplayStandController">();
	}
	static class ULobbyDisplayStandController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyDisplayStandController>();
	}
};
static_assert(alignof(ULobbyDisplayStandController) == 0x000008, "Wrong alignment on ULobbyDisplayStandController");
static_assert(sizeof(ULobbyDisplayStandController) == 0x0001C8, "Wrong size on ULobbyDisplayStandController");

// Class DeadByDaylight.LocalEventManager
// 0x1758 (0x1790 - 0x0038)
class ULocalEventManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x1758];                                    // 0x0038(0x1758)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalEventManager">();
	}
	static class ULocalEventManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalEventManager>();
	}
};
static_assert(alignof(ULocalEventManager) == 0x000008, "Wrong alignment on ULocalEventManager");
static_assert(sizeof(ULocalEventManager) == 0x001790, "Wrong size on ULocalEventManager");

// Class DeadByDaylight.LocalPlayerTrackerComponent
// 0x0010 (0x00C8 - 0x00B8)
class ULocalPlayerTrackerComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              TrackerOnLocallyObservedChanged;                   // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void TriggerOnLocallyObservedChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalPlayerTrackerComponent">();
	}
	static class ULocalPlayerTrackerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalPlayerTrackerComponent>();
	}
};
static_assert(alignof(ULocalPlayerTrackerComponent) == 0x000008, "Wrong alignment on ULocalPlayerTrackerComponent");
static_assert(sizeof(ULocalPlayerTrackerComponent) == 0x0000C8, "Wrong size on ULocalPlayerTrackerComponent");
static_assert(offsetof(ULocalPlayerTrackerComponent, TrackerOnLocallyObservedChanged) == 0x0000B8, "Member 'ULocalPlayerTrackerComponent::TrackerOnLocallyObservedChanged' has a wrong offset!");

// Class DeadByDaylight.LocalPlayerUtilities
// 0x0000 (0x0030 - 0x0030)
class ULocalPlayerUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class ADBDPlayerState* GetLocalHumanPlayerState(const class UObject* worldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalPlayerUtilities">();
	}
	static class ULocalPlayerUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalPlayerUtilities>();
	}
};
static_assert(alignof(ULocalPlayerUtilities) == 0x000008, "Wrong alignment on ULocalPlayerUtilities");
static_assert(sizeof(ULocalPlayerUtilities) == 0x000030, "Wrong size on ULocalPlayerUtilities");

// Class DeadByDaylight.LockerAmmoActorOutlineUpdateStrategy
// 0x0000 (0x00E0 - 0x00E0)
class ULockerAmmoActorOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerAmmoActorOutlineUpdateStrategy">();
	}
	static class ULockerAmmoActorOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerAmmoActorOutlineUpdateStrategy>();
	}
};
static_assert(alignof(ULockerAmmoActorOutlineUpdateStrategy) == 0x000008, "Wrong alignment on ULockerAmmoActorOutlineUpdateStrategy");
static_assert(sizeof(ULockerAmmoActorOutlineUpdateStrategy) == 0x0000E0, "Wrong size on ULockerAmmoActorOutlineUpdateStrategy");

// Class DeadByDaylight.LockerAnimInstance
// 0x0000 (0x02D0 - 0x02D0)
class ULockerAnimInstance final : public USleepingAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerAnimInstance">();
	}
	static class ULockerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerAnimInstance>();
	}
};
static_assert(alignof(ULockerAnimInstance) == 0x000010, "Wrong alignment on ULockerAnimInstance");
static_assert(sizeof(ULockerAnimInstance) == 0x0002D0, "Wrong size on ULockerAnimInstance");

// Class DeadByDaylight.LockerOutlineUpdateStrategy
// 0x0018 (0x0150 - 0x0138)
class ULockerOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	uint8                                         Pad_138[0x18];                                     // 0x0138(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FLinearColor GetRedColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockerOutlineUpdateStrategy">();
	}
	static class ULockerOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockerOutlineUpdateStrategy>();
	}
};
static_assert(alignof(ULockerOutlineUpdateStrategy) == 0x000008, "Wrong alignment on ULockerOutlineUpdateStrategy");
static_assert(sizeof(ULockerOutlineUpdateStrategy) == 0x000150, "Wrong size on ULockerOutlineUpdateStrategy");

// Class DeadByDaylight.LoudNoise
// 0x0070 (0x02A0 - 0x0230)
class ALoudNoise final : public AActor
{
public:
	class UDecalComponent*                        _toInfinityDecal;                                  // 0x0230(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               _distortionParticleSystem;                         // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           _ak_audio_loudNoise;                               // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootScene;                                        // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _loudNoiseMinDistance;                             // 0x0250(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0x34];                                     // 0x0254(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _loudNoiseLifetime;                                // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _heightToAddToLoudNoiseLocation;                   // 0x028C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _loudNoiseDecalDistance;                           // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cameraDecalDistance;                              // 0x0294(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudNoise">();
	}
	static class ALoudNoise* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALoudNoise>();
	}
};
static_assert(alignof(ALoudNoise) == 0x000008, "Wrong alignment on ALoudNoise");
static_assert(sizeof(ALoudNoise) == 0x0002A0, "Wrong size on ALoudNoise");
static_assert(offsetof(ALoudNoise, _toInfinityDecal) == 0x000230, "Member 'ALoudNoise::_toInfinityDecal' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _distortionParticleSystem) == 0x000238, "Member 'ALoudNoise::_distortionParticleSystem' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _ak_audio_loudNoise) == 0x000240, "Member 'ALoudNoise::_ak_audio_loudNoise' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _rootScene) == 0x000248, "Member 'ALoudNoise::_rootScene' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _loudNoiseMinDistance) == 0x000250, "Member 'ALoudNoise::_loudNoiseMinDistance' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _loudNoiseLifetime) == 0x000288, "Member 'ALoudNoise::_loudNoiseLifetime' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _heightToAddToLoudNoiseLocation) == 0x00028C, "Member 'ALoudNoise::_heightToAddToLoudNoiseLocation' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _loudNoiseDecalDistance) == 0x000290, "Member 'ALoudNoise::_loudNoiseDecalDistance' has a wrong offset!");
static_assert(offsetof(ALoudNoise, _cameraDecalDistance) == 0x000294, "Member 'ALoudNoise::_cameraDecalDistance' has a wrong offset!");

// Class DeadByDaylight.LoudNoiseEventSystem
// 0x0070 (0x0128 - 0x00B8)
class ULoudNoiseEventSystem final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x70];                                      // 0x00B8(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudNoiseEventSystem">();
	}
	static class ULoudNoiseEventSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoudNoiseEventSystem>();
	}
};
static_assert(alignof(ULoudNoiseEventSystem) == 0x000008, "Wrong alignment on ULoudNoiseEventSystem");
static_assert(sizeof(ULoudNoiseEventSystem) == 0x000128, "Wrong size on ULoudNoiseEventSystem");

// Class DeadByDaylight.LoudNoiseHUDIndicator
// 0x0070 (0x0290 - 0x0220)
class ULoudNoiseHUDIndicator final : public USceneComponent
{
public:
	class UStaticMesh*                            MaskMesh;                                          // 0x0218(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            DistortionMesh;                                    // 0x0220(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgePadding;                                       // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CornerRoundness;                                   // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenFadeOutDistance;                             // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              LoudNoiseAddedEvent;                               // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x38];                                     // 0x0248(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLoudNoiseIndicatorData>        _trackedNoises;                                    // 0x0280(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AddTrackedNoise(const struct FVector& location, float duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudNoiseHUDIndicator">();
	}
	static class ULoudNoiseHUDIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoudNoiseHUDIndicator>();
	}
};
static_assert(alignof(ULoudNoiseHUDIndicator) == 0x000010, "Wrong alignment on ULoudNoiseHUDIndicator");
static_assert(sizeof(ULoudNoiseHUDIndicator) == 0x000290, "Wrong size on ULoudNoiseHUDIndicator");
static_assert(offsetof(ULoudNoiseHUDIndicator, MaskMesh) == 0x000218, "Member 'ULoudNoiseHUDIndicator::MaskMesh' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, DistortionMesh) == 0x000220, "Member 'ULoudNoiseHUDIndicator::DistortionMesh' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, EdgePadding) == 0x000228, "Member 'ULoudNoiseHUDIndicator::EdgePadding' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, CornerRoundness) == 0x00022C, "Member 'ULoudNoiseHUDIndicator::CornerRoundness' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, ScreenFadeOutDistance) == 0x000230, "Member 'ULoudNoiseHUDIndicator::ScreenFadeOutDistance' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, LoudNoiseAddedEvent) == 0x000238, "Member 'ULoudNoiseHUDIndicator::LoudNoiseAddedEvent' has a wrong offset!");
static_assert(offsetof(ULoudNoiseHUDIndicator, _trackedNoises) == 0x000280, "Member 'ULoudNoiseHUDIndicator::_trackedNoises' has a wrong offset!");

// Class DeadByDaylight.LoudNoiseNotifier
// 0x0000 (0x0030 - 0x0030)
class ULoudNoiseNotifier final : public UBlueprintFunctionLibrary
{
public:
	static void Fire(const class UObject* worldContextObject, class AActor* instigator, const struct FVector& location, bool shouldTrack, float audibleRange, class ADBDPlayer* instigatingPlayer, bool isQuickAction, bool isDeceivingNoise);
	static void FireWithTimeBudgeter(const class UObject* worldContextObject, class AActor* instigator, const struct FVector& location, bool shouldTrack, float audibleRange, class ADBDPlayer* instigatingPlayer, bool isQuickAction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoudNoiseNotifier">();
	}
	static class ULoudNoiseNotifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoudNoiseNotifier>();
	}
};
static_assert(alignof(ULoudNoiseNotifier) == 0x000008, "Wrong alignment on ULoudNoiseNotifier");
static_assert(sizeof(ULoudNoiseNotifier) == 0x000030, "Wrong size on ULoudNoiseNotifier");

// Class DeadByDaylight.LunarEventComponent
// 0x0050 (0x0108 - 0x00B8)
class ULunarEventComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _lanternCollectedCount;                            // 0x00D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _additionalEventProgressCount;                     // 0x00D4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x30];                                      // 0x00D8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCamperEscape(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Authority_OnCamperLostLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Authority_OnDestroyCamperLightGameEvent(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Authority_OnFixGenerator(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Authority_OnPickupLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Authority_OnPlayerLeaveGame(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Authority_OnSlasherDestroysLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Local_OnCamperEscape(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Local_OnCamperLostLantern(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Multicast_ResetLanternLight(class ALanternInteractable* lanternInteractable);
	void OnFinishedPlaying(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void OnLanternHoldTimerEnd();
	void OnRep_lanternCollectedCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LunarEventComponent">();
	}
	static class ULunarEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULunarEventComponent>();
	}
};
static_assert(alignof(ULunarEventComponent) == 0x000008, "Wrong alignment on ULunarEventComponent");
static_assert(sizeof(ULunarEventComponent) == 0x000108, "Wrong size on ULunarEventComponent");
static_assert(offsetof(ULunarEventComponent, _lanternCollectedCount) == 0x0000D0, "Member 'ULunarEventComponent::_lanternCollectedCount' has a wrong offset!");
static_assert(offsetof(ULunarEventComponent, _additionalEventProgressCount) == 0x0000D4, "Member 'ULunarEventComponent::_additionalEventProgressCount' has a wrong offset!");

// Class DeadByDaylight.MagicFountain
// 0x0018 (0x0340 - 0x0328)
class AMagicFountain final : public AInteractable
{
public:
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AIInteractionOffset;                               // 0x0330(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsCorrupted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagicFountain">();
	}
	static class AMagicFountain* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMagicFountain>();
	}
};
static_assert(alignof(AMagicFountain) == 0x000008, "Wrong alignment on AMagicFountain");
static_assert(sizeof(AMagicFountain) == 0x000340, "Wrong size on AMagicFountain");
static_assert(offsetof(AMagicFountain, AIInteractionOffset) == 0x000330, "Member 'AMagicFountain::AIInteractionOffset' has a wrong offset!");

// Class DeadByDaylight.MagicFountainOutlineUpdateStrategy
// 0x0018 (0x00D8 - 0x00C0)
class UMagicFountainOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _outlineColor;                                     // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetFountainCorrupted(const bool corrupted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MagicFountainOutlineUpdateStrategy">();
	}
	static class UMagicFountainOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMagicFountainOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UMagicFountainOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UMagicFountainOutlineUpdateStrategy");
static_assert(sizeof(UMagicFountainOutlineUpdateStrategy) == 0x0000D8, "Wrong size on UMagicFountainOutlineUpdateStrategy");
static_assert(offsetof(UMagicFountainOutlineUpdateStrategy, _outlineColor) == 0x0000C0, "Member 'UMagicFountainOutlineUpdateStrategy::_outlineColor' has a wrong offset!");

// Class DeadByDaylight.MapActorDB
// 0x0050 (0x0080 - 0x0030)
class UMapActorDB final : public UObject
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<EMapActorCategory> CopyListMinusCategories(const TArray<EMapActorCategory>& Categories, const TArray<EMapActorCategory>& categoriesToRemove) const;
	class AActor* GetRandom(EMapActorCategory category) const;
	TArray<class AActor*> GetUniqueRandom(const TArray<EMapActorCategory>& categories, int32 count) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorDB">();
	}
	static class UMapActorDB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActorDB>();
	}
};
static_assert(alignof(UMapActorDB) == 0x000008, "Wrong alignment on UMapActorDB");
static_assert(sizeof(UMapActorDB) == 0x000080, "Wrong size on UMapActorDB");

// Class DeadByDaylight.MapActorDetectorComponent
// 0x0028 (0x00E0 - 0x00B8)
class UMapActorDetectorComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class AActor* actor)> OnActorDetected;                             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<EMapActorCategory>                     CollectedCategories;                               // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _primitive;                                        // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void SetDetectionPrimitive(class UPrimitiveComponent* primitive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapActorDetectorComponent">();
	}
	static class UMapActorDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapActorDetectorComponent>();
	}
};
static_assert(alignof(UMapActorDetectorComponent) == 0x000008, "Wrong alignment on UMapActorDetectorComponent");
static_assert(sizeof(UMapActorDetectorComponent) == 0x0000E0, "Wrong size on UMapActorDetectorComponent");
static_assert(offsetof(UMapActorDetectorComponent, OnActorDetected) == 0x0000B8, "Member 'UMapActorDetectorComponent::OnActorDetected' has a wrong offset!");
static_assert(offsetof(UMapActorDetectorComponent, CollectedCategories) == 0x0000C8, "Member 'UMapActorDetectorComponent::CollectedCategories' has a wrong offset!");
static_assert(offsetof(UMapActorDetectorComponent, _primitive) == 0x0000D8, "Member 'UMapActorDetectorComponent::_primitive' has a wrong offset!");

// Class DeadByDaylight.MapData
// 0x00B0 (0x00E8 - 0x0038)
class UMapData final : public UDataAsset
{
public:
	class FName                                   ThemeName;                                         // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThemeWeather;                                      // 0x0044(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioStateThemes;                                  // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioStateWeather;                                 // 0x005C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioThemeEvent;                                   // 0x0068(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AudioLimitPointEvent;                              // 0x0074(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioBank>            AudioThemeSoundBank;                               // 0x0080(0x0030)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapWidth;                                          // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapHeight;                                         // 0x00B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Draft;                                             // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTileProperties>                MapTileProperties;                                 // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UBlackboardData*                        Blackboard;                                        // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Gesture;                                           // 0x00D8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralGenerationData*              _proceduralGenerationData;                         // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapData">();
	}
	static class UMapData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapData>();
	}
};
static_assert(alignof(UMapData) == 0x000008, "Wrong alignment on UMapData");
static_assert(sizeof(UMapData) == 0x0000E8, "Wrong size on UMapData");
static_assert(offsetof(UMapData, ThemeName) == 0x000038, "Member 'UMapData::ThemeName' has a wrong offset!");
static_assert(offsetof(UMapData, ThemeWeather) == 0x000044, "Member 'UMapData::ThemeWeather' has a wrong offset!");
static_assert(offsetof(UMapData, AudioStateThemes) == 0x000050, "Member 'UMapData::AudioStateThemes' has a wrong offset!");
static_assert(offsetof(UMapData, AudioStateWeather) == 0x00005C, "Member 'UMapData::AudioStateWeather' has a wrong offset!");
static_assert(offsetof(UMapData, AudioThemeEvent) == 0x000068, "Member 'UMapData::AudioThemeEvent' has a wrong offset!");
static_assert(offsetof(UMapData, AudioLimitPointEvent) == 0x000074, "Member 'UMapData::AudioLimitPointEvent' has a wrong offset!");
static_assert(offsetof(UMapData, AudioThemeSoundBank) == 0x000080, "Member 'UMapData::AudioThemeSoundBank' has a wrong offset!");
static_assert(offsetof(UMapData, MapWidth) == 0x0000B0, "Member 'UMapData::MapWidth' has a wrong offset!");
static_assert(offsetof(UMapData, MapHeight) == 0x0000B4, "Member 'UMapData::MapHeight' has a wrong offset!");
static_assert(offsetof(UMapData, Draft) == 0x0000B8, "Member 'UMapData::Draft' has a wrong offset!");
static_assert(offsetof(UMapData, MapTileProperties) == 0x0000C0, "Member 'UMapData::MapTileProperties' has a wrong offset!");
static_assert(offsetof(UMapData, Blackboard) == 0x0000D0, "Member 'UMapData::Blackboard' has a wrong offset!");
static_assert(offsetof(UMapData, Gesture) == 0x0000D8, "Member 'UMapData::Gesture' has a wrong offset!");
static_assert(offsetof(UMapData, _proceduralGenerationData) == 0x0000E0, "Member 'UMapData::_proceduralGenerationData' has a wrong offset!");

// Class DeadByDaylight.MatchHandler
// 0x0000 (0x0030 - 0x0030)
class UMatchHandler final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchHandler">();
	}
	static class UMatchHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchHandler>();
	}
};
static_assert(alignof(UMatchHandler) == 0x000008, "Wrong alignment on UMatchHandler");
static_assert(sizeof(UMatchHandler) == 0x000030, "Wrong size on UMatchHandler");

// Class DeadByDaylight.MatchIncentivesManager
// 0x0040 (0x0078 - 0x0038)
class UMatchIncentivesManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x40];                                      // 0x0038(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchIncentivesManager">();
	}
	static class UMatchIncentivesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchIncentivesManager>();
	}
};
static_assert(alignof(UMatchIncentivesManager) == 0x000008, "Wrong alignment on UMatchIncentivesManager");
static_assert(sizeof(UMatchIncentivesManager) == 0x000078, "Wrong size on UMatchIncentivesManager");

// Class DeadByDaylight.MatchmakingFlowSubsystem
// 0x00D0 (0x0108 - 0x0038)
class UMatchmakingFlowSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0xD0];                                      // 0x0038(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakingFlowSubsystem">();
	}
	static class UMatchmakingFlowSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchmakingFlowSubsystem>();
	}
};
static_assert(alignof(UMatchmakingFlowSubsystem) == 0x000008, "Wrong alignment on UMatchmakingFlowSubsystem");
static_assert(sizeof(UMatchmakingFlowSubsystem) == 0x000108, "Wrong size on UMatchmakingFlowSubsystem");

// Class DeadByDaylight.MeatHook
// 0x02B8 (0x05E0 - 0x0328)
class AMeatHook final : public AInteractable
{
public:
	uint8                                         Pad_328[0x20];                                     // 0x0328(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          WasSurvivorStruggleCancelled;                      // 0x0348(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSacrificeEnabled;                                // 0x0349(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34A[0x2];                                      // 0x034A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AIInteractionOffset;                               // 0x034C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_358[0xA8];                                     // 0x0358(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDBDClipRegionComponent*>        ClipRegions;                                       // 0x0400(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          IsSurvivorStruggling;                              // 0x0410(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInBasement;                                      // 0x0411(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBreakable;                                       // 0x0412(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSabotageable;                                    // 0x0413(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           HookIdentityTag;                                   // 0x0414(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SnapHookedCharacter;                               // 0x0420(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FullyHooked;                                       // 0x0421(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_422[0x2];                                      // 0x0422(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _struggleThreshold;                                // 0x0424(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterPusherComponent*              _characterPusher;                                  // 0x0428(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      _slasherCollisionBlocker;                          // 0x0430(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      _conditionalSlasherCollisionBlocker;               // 0x0438(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _conditionalSlasherCollisionBlockerPresenceTags;   // 0x0440(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UPollableEventListener*                 _eventListener;                                    // 0x0460(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACamperPlayer*                          _hookedSurvivor;                                   // 0x0468(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _hookBreakerPlayer;                                // 0x0470(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x70];                                     // 0x0478(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ACamperPlayer*>                    _campersThatSabotagedMeatHook;                     // 0x04E8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UInteractor*                            _mainInteractor;                                   // 0x0538(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableInteractionDefinition*       _unhook;                                           // 0x0540(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _camperHookedSnapTransform;                        // 0x0548(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEntity*                                _entity;                                           // 0x0550(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_558[0x1C];                                     // 0x0558(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _preventDrainProgression;                          // 0x0574(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_575[0x3];                                      // 0x0575(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _interactingPlayer;                                // 0x0580(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMapActorComponent*                     _cachedMapActor;                                   // 0x0588(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_590[0x50];                                     // 0x0590(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_SetHookedSurvivor(class ACamperPlayer* survivor);
	void Authority_SetIsBrokenFromUnhook(bool isBrokenFromUnhook, class ADBDPlayer* hookBreaker, float overrideBaseHookRespawnDuration);
	void Authority_SetIsSabotaged(bool isSabotaged, class ADBDPlayer* saboteur, bool useCamperHookRespawnDurationModifiers, float overrideBaseHookRespawnDuration);
	void Authority_SetIsSacrificed(bool isSacrificed);
	void Authority_SignalSurvivorAttemptingEscape();
	void Authority_SignalSurvivorAttemptingEscapeAborted();
	void Authority_SignalUnhookingAborted();
	void Authority_SignalUnhookingCharged();
	void Authority_SignalUnhookingEnter();
	void BroadcastUnhook(class ADBDPlayer* rescuer);
	void Cosmetic_SetAsScourgeHookStart();
	void Local_MoveSurvivorToHook(class ACamperPlayer* survivor, const float duration);
	void Multicast_EscapeAttemptResult(class ADBDPlayer* player, bool result);
	void Multicast_RefreshCharmCustomization();
	void Multicast_SetHookedSurvivor(class ACamperPlayer* survivor);
	void Multicast_SetIsBrokenFromUnhook(bool setIsBrokendFromUnhook, class ADBDPlayer* hookBreaker, float overrideBaseHookRespawnDuration);
	void Multicast_SetIsSabotaged(bool setIsSabotaged, class ADBDPlayer* hookBreaker, bool useCamperHookRespawnDurationModifiers, float overrideBaseHookRespawnDuration);
	void Multicast_SetIsSacrificed(bool isSacrificed);
	void OnAutoRepair();
	void OnHookedEnter();
	void OnHookedExit();
	void OnHookedIdle();
	void OnHookedSurvivorAttacked();
	void OnHookedSurvivorChanged(class ACamperPlayer* before, class ACamperPlayer* after);
	void OnHookingEnter();
	void OnHookingExit();
	void OnOwnerReplicated();
	void OnReaction();
	void OnReactionIn();
	void OnSacrificeIn();
	void OnSacrificeOut();
	void OnStartPushingPlayer(class ACharacter* character);
	void OnStopPushingPlayer(class ACharacter* character);
	void OnStruggleEnter();
	void OnStruggleExit();
	void OnStruggleSkillCheckFailed_Cosmetic();
	void OnTickStruggle(float deltaTime);
	void SetEntity(class AEntity* entity);
	void SetInteractingPlayer(class ADBDPlayer* interactingPlayer);
	void SetIsBeingSabotaged(bool isBeingSabotaged);
	void SetMapActor(class UMapActorComponent* value);
	void UpdateSlasherBlockerCollision();

	bool CanBeSabotaged() const;
	bool CanHookSurvivor() const;
	bool CanSurvivorAttemptEscape(const class ACamperPlayer* survivor) const;
	bool CanSurvivorStruggle(class ACamperPlayer* survivor) const;
	bool CanUnhookSurvivor(const class ACamperPlayer* survivor) const;
	void DebugHookedSurvivor(class ACamperPlayer* expectedSurvivor) const;
	void FireHookSoundEvent(const class FName NoiseRangeTunable, const class ADBDPlayer* soundInstigator) const;
	class USceneComponent* GetCamperHookedSnapTransform() const;
	class USceneComponent* GetCamperUnkookFocalPointTransform() const;
	class UCharacterPusherComponent* GetCharacterPusher() const;
	class UChargeableInteractionDefinition* GetEscapeHookCID() const;
	class UHookableComponent* GetHookableComponentOfHookedActor() const;
	class ACamperPlayer* GetHookedSurvivor() const;
	struct FVector GetHookPosition() const;
	class ADBDPlayer* GetInteractingPlayer() const;
	class UPrimitiveComponent* GetInteractorPrimitiveComponent() const;
	class UBoxComponent* GetInteractorZoneComponent() const;
	bool GetIsBroken() const;
	bool GetIsInBasement() const;
	bool GetIsSabotaged() const;
	bool GetIsSacrificed() const;
	class USphereComponent* GetKickSlasherDetectionZone() const;
	class UInteractor* GetMainInteractor() const;
	class UAkComponent* GetMeatHookAkAudioComponent() const;
	class UMontagePlayer* GetMontagePlayer() const;
	float GetSabotageHookRespawnDuration() const;
	class ADBDPlayer* GetSaboteurPlayer() const;
	float GetStrugglePercent() const;
	float GetStruggleThreshold() const;
	class UChargeableInteractionDefinition* GetUnhookCID() const;
	struct FAnimationMontageDescriptor GetUnhookInMontageDescriptor() const;
	struct FAnimationMontageDescriptor GetUnhookOutMontageDescriptor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeatHook">();
	}
	static class AMeatHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMeatHook>();
	}
};
static_assert(alignof(AMeatHook) == 0x000008, "Wrong alignment on AMeatHook");
static_assert(sizeof(AMeatHook) == 0x0005E0, "Wrong size on AMeatHook");
static_assert(offsetof(AMeatHook, WasSurvivorStruggleCancelled) == 0x000348, "Member 'AMeatHook::WasSurvivorStruggleCancelled' has a wrong offset!");
static_assert(offsetof(AMeatHook, IsSacrificeEnabled) == 0x000349, "Member 'AMeatHook::IsSacrificeEnabled' has a wrong offset!");
static_assert(offsetof(AMeatHook, AIInteractionOffset) == 0x00034C, "Member 'AMeatHook::AIInteractionOffset' has a wrong offset!");
static_assert(offsetof(AMeatHook, ClipRegions) == 0x000400, "Member 'AMeatHook::ClipRegions' has a wrong offset!");
static_assert(offsetof(AMeatHook, IsSurvivorStruggling) == 0x000410, "Member 'AMeatHook::IsSurvivorStruggling' has a wrong offset!");
static_assert(offsetof(AMeatHook, IsInBasement) == 0x000411, "Member 'AMeatHook::IsInBasement' has a wrong offset!");
static_assert(offsetof(AMeatHook, IsBreakable) == 0x000412, "Member 'AMeatHook::IsBreakable' has a wrong offset!");
static_assert(offsetof(AMeatHook, IsSabotageable) == 0x000413, "Member 'AMeatHook::IsSabotageable' has a wrong offset!");
static_assert(offsetof(AMeatHook, HookIdentityTag) == 0x000414, "Member 'AMeatHook::HookIdentityTag' has a wrong offset!");
static_assert(offsetof(AMeatHook, SnapHookedCharacter) == 0x000420, "Member 'AMeatHook::SnapHookedCharacter' has a wrong offset!");
static_assert(offsetof(AMeatHook, FullyHooked) == 0x000421, "Member 'AMeatHook::FullyHooked' has a wrong offset!");
static_assert(offsetof(AMeatHook, _struggleThreshold) == 0x000424, "Member 'AMeatHook::_struggleThreshold' has a wrong offset!");
static_assert(offsetof(AMeatHook, _characterPusher) == 0x000428, "Member 'AMeatHook::_characterPusher' has a wrong offset!");
static_assert(offsetof(AMeatHook, _slasherCollisionBlocker) == 0x000430, "Member 'AMeatHook::_slasherCollisionBlocker' has a wrong offset!");
static_assert(offsetof(AMeatHook, _conditionalSlasherCollisionBlocker) == 0x000438, "Member 'AMeatHook::_conditionalSlasherCollisionBlocker' has a wrong offset!");
static_assert(offsetof(AMeatHook, _conditionalSlasherCollisionBlockerPresenceTags) == 0x000440, "Member 'AMeatHook::_conditionalSlasherCollisionBlockerPresenceTags' has a wrong offset!");
static_assert(offsetof(AMeatHook, _eventListener) == 0x000460, "Member 'AMeatHook::_eventListener' has a wrong offset!");
static_assert(offsetof(AMeatHook, _hookedSurvivor) == 0x000468, "Member 'AMeatHook::_hookedSurvivor' has a wrong offset!");
static_assert(offsetof(AMeatHook, _hookBreakerPlayer) == 0x000470, "Member 'AMeatHook::_hookBreakerPlayer' has a wrong offset!");
static_assert(offsetof(AMeatHook, _campersThatSabotagedMeatHook) == 0x0004E8, "Member 'AMeatHook::_campersThatSabotagedMeatHook' has a wrong offset!");
static_assert(offsetof(AMeatHook, _mainInteractor) == 0x000538, "Member 'AMeatHook::_mainInteractor' has a wrong offset!");
static_assert(offsetof(AMeatHook, _unhook) == 0x000540, "Member 'AMeatHook::_unhook' has a wrong offset!");
static_assert(offsetof(AMeatHook, _camperHookedSnapTransform) == 0x000548, "Member 'AMeatHook::_camperHookedSnapTransform' has a wrong offset!");
static_assert(offsetof(AMeatHook, _entity) == 0x000550, "Member 'AMeatHook::_entity' has a wrong offset!");
static_assert(offsetof(AMeatHook, _preventDrainProgression) == 0x000574, "Member 'AMeatHook::_preventDrainProgression' has a wrong offset!");
static_assert(offsetof(AMeatHook, _perceptionStimuliComponent) == 0x000578, "Member 'AMeatHook::_perceptionStimuliComponent' has a wrong offset!");
static_assert(offsetof(AMeatHook, _interactingPlayer) == 0x000580, "Member 'AMeatHook::_interactingPlayer' has a wrong offset!");
static_assert(offsetof(AMeatHook, _cachedMapActor) == 0x000588, "Member 'AMeatHook::_cachedMapActor' has a wrong offset!");

// Class DeadByDaylight.MeatHookAnimInstance
// 0x0010 (0x02D0 - 0x02C0)
class UMeatHookAnimInstance final : public UAnimInstance
{
public:
	bool                                          IsBroken;                                          // 0x02C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Yaw;                                               // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSurvivorStruggling;                              // 0x02C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeatHookAnimInstance">();
	}
	static class UMeatHookAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeatHookAnimInstance>();
	}
};
static_assert(alignof(UMeatHookAnimInstance) == 0x000010, "Wrong alignment on UMeatHookAnimInstance");
static_assert(sizeof(UMeatHookAnimInstance) == 0x0002D0, "Wrong size on UMeatHookAnimInstance");
static_assert(offsetof(UMeatHookAnimInstance, IsBroken) == 0x0002C0, "Member 'UMeatHookAnimInstance::IsBroken' has a wrong offset!");
static_assert(offsetof(UMeatHookAnimInstance, Yaw) == 0x0002C4, "Member 'UMeatHookAnimInstance::Yaw' has a wrong offset!");
static_assert(offsetof(UMeatHookAnimInstance, IsSurvivorStruggling) == 0x0002C8, "Member 'UMeatHookAnimInstance::IsSurvivorStruggling' has a wrong offset!");

// Class DeadByDaylight.MeatHookEntityVisibilityComponent
// 0x0030 (0x00E8 - 0x00B8)
class UMeatHookEntityVisibilityComponent final : public UActorComponent
{
public:
	class AEntity*                                _entity;                                           // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _entityReappearSpeed;                              // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _entityDisappearSpeed;                             // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeatHookEntityVisibilityComponent">();
	}
	static class UMeatHookEntityVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeatHookEntityVisibilityComponent>();
	}
};
static_assert(alignof(UMeatHookEntityVisibilityComponent) == 0x000008, "Wrong alignment on UMeatHookEntityVisibilityComponent");
static_assert(sizeof(UMeatHookEntityVisibilityComponent) == 0x0000E8, "Wrong size on UMeatHookEntityVisibilityComponent");
static_assert(offsetof(UMeatHookEntityVisibilityComponent, _entity) == 0x0000B8, "Member 'UMeatHookEntityVisibilityComponent::_entity' has a wrong offset!");
static_assert(offsetof(UMeatHookEntityVisibilityComponent, _entityReappearSpeed) == 0x0000D8, "Member 'UMeatHookEntityVisibilityComponent::_entityReappearSpeed' has a wrong offset!");
static_assert(offsetof(UMeatHookEntityVisibilityComponent, _entityDisappearSpeed) == 0x0000DC, "Member 'UMeatHookEntityVisibilityComponent::_entityDisappearSpeed' has a wrong offset!");

// Class DeadByDaylight.MeatHookOutlineUpdateStrategy
// 0x0040 (0x0178 - 0x0138)
class UMeatHookOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor                           HookedOutlineColorSlasher;                         // 0x0138(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           CarryingOutlineColorSlasher;                       // 0x0148(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           DefaultOutlineColorSlasher;                        // 0x0158(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           VisibleOutlineColorCamper;                         // 0x0168(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_AddBasementHookToPlayerMapItem();
	void Local_AddBasementOfferingReveal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeatHookOutlineUpdateStrategy">();
	}
	static class UMeatHookOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeatHookOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UMeatHookOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UMeatHookOutlineUpdateStrategy");
static_assert(sizeof(UMeatHookOutlineUpdateStrategy) == 0x000178, "Wrong size on UMeatHookOutlineUpdateStrategy");
static_assert(offsetof(UMeatHookOutlineUpdateStrategy, HookedOutlineColorSlasher) == 0x000138, "Member 'UMeatHookOutlineUpdateStrategy::HookedOutlineColorSlasher' has a wrong offset!");
static_assert(offsetof(UMeatHookOutlineUpdateStrategy, CarryingOutlineColorSlasher) == 0x000148, "Member 'UMeatHookOutlineUpdateStrategy::CarryingOutlineColorSlasher' has a wrong offset!");
static_assert(offsetof(UMeatHookOutlineUpdateStrategy, DefaultOutlineColorSlasher) == 0x000158, "Member 'UMeatHookOutlineUpdateStrategy::DefaultOutlineColorSlasher' has a wrong offset!");
static_assert(offsetof(UMeatHookOutlineUpdateStrategy, VisibleOutlineColorCamper) == 0x000168, "Member 'UMeatHookOutlineUpdateStrategy::VisibleOutlineColorCamper' has a wrong offset!");

// Class DeadByDaylight.MeatHookStateMachine
// 0x0000 (0x0130 - 0x0130)
class UMeatHookStateMachine final : public UStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeatHookStateMachine">();
	}
	static class UMeatHookStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeatHookStateMachine>();
	}
};
static_assert(alignof(UMeatHookStateMachine) == 0x000010, "Wrong alignment on UMeatHookStateMachine");
static_assert(sizeof(UMeatHookStateMachine) == 0x000130, "Wrong size on UMeatHookStateMachine");

// Class DeadByDaylight.MemoryTracker
// 0x0000 (0x0230 - 0x0230)
class AMemoryTracker final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MemoryTracker">();
	}
	static class AMemoryTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMemoryTracker>();
	}
};
static_assert(alignof(AMemoryTracker) == 0x000008, "Wrong alignment on AMemoryTracker");
static_assert(sizeof(AMemoryTracker) == 0x000230, "Wrong size on AMemoryTracker");

// Class DeadByDaylight.MenuForcedLODHandler
// 0x0070 (0x0128 - 0x00B8)
class UMenuForcedLODHandler final : public UActorComponent
{
public:
	TArray<EGameFlowStep>                         _forcedLOD0GameFlowSteps;                          // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x60];                                      // 0x00C8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCustomizationChanged(ECustomizationCategory category, const class FName& itemId, class ADBDMenuPlayer* menuPlayer);
	void OnMenuPlayerEndPlay(class AActor* menuPlayerActor, EEndPlayReason endPlayReason);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuForcedLODHandler">();
	}
	static class UMenuForcedLODHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuForcedLODHandler>();
	}
};
static_assert(alignof(UMenuForcedLODHandler) == 0x000008, "Wrong alignment on UMenuForcedLODHandler");
static_assert(sizeof(UMenuForcedLODHandler) == 0x000128, "Wrong size on UMenuForcedLODHandler");
static_assert(offsetof(UMenuForcedLODHandler, _forcedLOD0GameFlowSteps) == 0x0000B8, "Member 'UMenuForcedLODHandler::_forcedLOD0GameFlowSteps' has a wrong offset!");

// Class DeadByDaylight.MenuMeatHook
// 0x0028 (0x0258 - 0x0230)
class AMenuMeatHook final : public AActor
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharmSpawnerComponent*                 _charmSpawnerComponent;                            // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x10];                                     // 0x0248(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginDestroySequence_Internal();
	void OnCharmsUpdated(const TArray<struct FCharmIdSlot>& charmIDs);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuMeatHook">();
	}
	static class AMenuMeatHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMenuMeatHook>();
	}
};
static_assert(alignof(AMenuMeatHook) == 0x000008, "Wrong alignment on AMenuMeatHook");
static_assert(sizeof(AMenuMeatHook) == 0x000258, "Wrong size on AMenuMeatHook");
static_assert(offsetof(AMenuMeatHook, _charmSpawnerComponent) == 0x000240, "Member 'AMenuMeatHook::_charmSpawnerComponent' has a wrong offset!");

// Class DeadByDaylight.MenuUtilities
// 0x0000 (0x0030 - 0x0030)
class UMenuUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool AreAllGuestCharactersReady();
	static TArray<class ADBDMenuPlayer*> GetAllMenuCharacters();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuUtilities">();
	}
	static class UMenuUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuUtilities>();
	}
};
static_assert(alignof(UMenuUtilities) == 0x000008, "Wrong alignment on UMenuUtilities");
static_assert(sizeof(UMenuUtilities) == 0x000030, "Wrong size on UMenuUtilities");

// Class DeadByDaylight.MigrationSubsystem
// 0x0058 (0x0090 - 0x0038)
class UMigrationSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MigrationSubsystem">();
	}
	static class UMigrationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMigrationSubsystem>();
	}
};
static_assert(alignof(UMigrationSubsystem) == 0x000008, "Wrong alignment on UMigrationSubsystem");
static_assert(sizeof(UMigrationSubsystem) == 0x000090, "Wrong size on UMigrationSubsystem");

// Class DeadByDaylight.MobileProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UMobileProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MobileProfileDAL">();
	}
	static class UMobileProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMobileProfileDAL>();
	}
};
static_assert(alignof(UMobileProfileDAL) == 0x000008, "Wrong alignment on UMobileProfileDAL");
static_assert(sizeof(UMobileProfileDAL) == 0x000088, "Wrong size on UMobileProfileDAL");

// Class DeadByDaylight.MontagePlayer
// 0x01A8 (0x0260 - 0x00B8)
class UMontagePlayer final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(const struct FAnimationMontageDescriptor& animMontageID, const float PlayRate)> OnMontageStarted; // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x48];                                      // 0x00C8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FAnimationMontageDescriptor& animMontageID, bool interrupted)> OnMontageEnded; // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x30];                                     // 0x0120(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UAnimMontage* animMontage, bool interrupted)> BPOnMontageBlendingOut; // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_160[0x30];                                     // 0x0160(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             _animationMappingsTable;                           // 0x0190(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             _playerSpecificMappingsTable;                      // 0x0198(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           _currentlyPlayingMontage;                          // 0x01A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8[0x18];                                     // 0x01A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMontageInstanceInfo>           _activeMontagesInfo;                               // 0x01C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class FName                                   _outSectionName;                                   // 0x01D0(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timeBeforeOut;                                    // 0x01DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 _skeletalMeshComponent;                            // 0x01E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x28];                                     // 0x01E8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UAnimMontage*, class FName>        _montageToNameMap;                                 // 0x0210(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void JumpToSection(class FName sectionName);
	void JumpToSectionEnd(class FName sectionName);
	void OnMontageBlendingOutInternal(const struct FGuid& guid, class UAnimMontage* montage, bool interrupted);
	void OnMontageEndedInternal(const struct FGuid& guid, class UAnimMontage* montage, bool interrupted);
	class UAnimMontage* Play(const struct FAnimationMontageDescriptor& animMontageID, float playRate, bool isFollower);
	class UAnimMontage* PlayLoopForDuration(const struct FAnimationMontageDescriptor& animMontageID, float duration, float playRate, class FName out);
	void SetPlayRate(float playRate);
	void SetSkeletalMesh(class USkeletalMeshComponent* skeletalMeshComponent);
	void SignalAnimInstanceChanged();
	void Stop(float blendOutTime);

	class UAnimInstance* GetAnimInstance() const;
	bool IsPlaying(const struct FAnimationMontageDescriptor& montageDescriptor) const;
	bool IsPlayingAnyMontage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MontagePlayer">();
	}
	static class UMontagePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMontagePlayer>();
	}
};
static_assert(alignof(UMontagePlayer) == 0x000008, "Wrong alignment on UMontagePlayer");
static_assert(sizeof(UMontagePlayer) == 0x000260, "Wrong size on UMontagePlayer");
static_assert(offsetof(UMontagePlayer, OnMontageStarted) == 0x0000B8, "Member 'UMontagePlayer::OnMontageStarted' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, OnMontageEnded) == 0x000110, "Member 'UMontagePlayer::OnMontageEnded' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, BPOnMontageBlendingOut) == 0x000150, "Member 'UMontagePlayer::BPOnMontageBlendingOut' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _animationMappingsTable) == 0x000190, "Member 'UMontagePlayer::_animationMappingsTable' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _playerSpecificMappingsTable) == 0x000198, "Member 'UMontagePlayer::_playerSpecificMappingsTable' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _currentlyPlayingMontage) == 0x0001A0, "Member 'UMontagePlayer::_currentlyPlayingMontage' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _activeMontagesInfo) == 0x0001C0, "Member 'UMontagePlayer::_activeMontagesInfo' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _outSectionName) == 0x0001D0, "Member 'UMontagePlayer::_outSectionName' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _timeBeforeOut) == 0x0001DC, "Member 'UMontagePlayer::_timeBeforeOut' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _skeletalMeshComponent) == 0x0001E0, "Member 'UMontagePlayer::_skeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UMontagePlayer, _montageToNameMap) == 0x000210, "Member 'UMontagePlayer::_montageToNameMap' has a wrong offset!");

// Class DeadByDaylight.MoriableComponent
// 0x0028 (0x00E0 - 0x00B8)
class UMoriableComponent final : public UActorComponent
{
public:
	TArray<class UInteractionDefinition*>         _moriInteractions;                                 // 0x00B8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x18];                                      // 0x00C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoriFinished(bool hasBeenKilledByMori);
	void OnMoriUpdateStart();
	void OnRep_MoriInteractions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoriableComponent">();
	}
	static class UMoriableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoriableComponent>();
	}
};
static_assert(alignof(UMoriableComponent) == 0x000008, "Wrong alignment on UMoriableComponent");
static_assert(sizeof(UMoriableComponent) == 0x0000E0, "Wrong size on UMoriableComponent");
static_assert(offsetof(UMoriableComponent, _moriInteractions) == 0x0000B8, "Member 'UMoriableComponent::_moriInteractions' has a wrong offset!");

// Class DeadByDaylight.MovementModifierActor
// 0x0008 (0x0238 - 0x0230)
class AMovementModifierActor final : public AActor
{
public:
	float                                         MaxSpeedMultiplier;                                // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementModifierActor">();
	}
	static class AMovementModifierActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMovementModifierActor>();
	}
};
static_assert(alignof(AMovementModifierActor) == 0x000008, "Wrong alignment on AMovementModifierActor");
static_assert(sizeof(AMovementModifierActor) == 0x000238, "Wrong size on AMovementModifierActor");
static_assert(offsetof(AMovementModifierActor, MaxSpeedMultiplier) == 0x000230, "Member 'AMovementModifierActor::MaxSpeedMultiplier' has a wrong offset!");

// Class DeadByDaylight.MultipleLightsFader
// 0x0028 (0x0258 - 0x0230)
class AMultipleLightsFader final : public AActor
{
public:
	TArray<class ULightComponent*>                _affectedLights;                                   // 0x0230(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 _lightOriginalIntensities;                         // 0x0240(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         _timeMultiplier;                                   // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAffectedLights(const TArray<class ULightComponent*>& affectedLights);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MultipleLightsFader">();
	}
	static class AMultipleLightsFader* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMultipleLightsFader>();
	}
};
static_assert(alignof(AMultipleLightsFader) == 0x000008, "Wrong alignment on AMultipleLightsFader");
static_assert(sizeof(AMultipleLightsFader) == 0x000258, "Wrong size on AMultipleLightsFader");
static_assert(offsetof(AMultipleLightsFader, _affectedLights) == 0x000230, "Member 'AMultipleLightsFader::_affectedLights' has a wrong offset!");
static_assert(offsetof(AMultipleLightsFader, _lightOriginalIntensities) == 0x000240, "Member 'AMultipleLightsFader::_lightOriginalIntensities' has a wrong offset!");
static_assert(offsetof(AMultipleLightsFader, _timeMultiplier) == 0x000250, "Member 'AMultipleLightsFader::_timeMultiplier' has a wrong offset!");

// Class DeadByDaylight.NatAudioAmbienceBox
// 0x0010 (0x04C0 - 0x04B0)
class UNatAudioAmbienceBox final : public UAmbienceBoxComponent
{
public:
	class UAkAudioEvent*                          _onBeginOverlapAudioEvent;                         // 0x04A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          _onEndOverlapAudioEvent;                           // 0x04B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlapAudioAmbience(class UPrimitiveComponent* overlappedComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult);
	void OnEndOverlapAudioAmbience(class UPrimitiveComponent* overlappedComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NatAudioAmbienceBox">();
	}
	static class UNatAudioAmbienceBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNatAudioAmbienceBox>();
	}
};
static_assert(alignof(UNatAudioAmbienceBox) == 0x000010, "Wrong alignment on UNatAudioAmbienceBox");
static_assert(sizeof(UNatAudioAmbienceBox) == 0x0004C0, "Wrong size on UNatAudioAmbienceBox");
static_assert(offsetof(UNatAudioAmbienceBox, _onBeginOverlapAudioEvent) == 0x0004A8, "Member 'UNatAudioAmbienceBox::_onBeginOverlapAudioEvent' has a wrong offset!");
static_assert(offsetof(UNatAudioAmbienceBox, _onEndOverlapAudioEvent) == 0x0004B0, "Member 'UNatAudioAmbienceBox::_onEndOverlapAudioEvent' has a wrong offset!");

// Class DeadByDaylight.NavArea_BearTrap
// 0x0000 (0x0050 - 0x0050)
class UNavArea_BearTrap final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_BearTrap">();
	}
	static class UNavArea_BearTrap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_BearTrap>();
	}
};
static_assert(alignof(UNavArea_BearTrap) == 0x000008, "Wrong alignment on UNavArea_BearTrap");
static_assert(sizeof(UNavArea_BearTrap) == 0x000050, "Wrong size on UNavArea_BearTrap");

// Class DeadByDaylight.NavArea_Drone
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Drone final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Drone">();
	}
	static class UNavArea_Drone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Drone>();
	}
};
static_assert(alignof(UNavArea_Drone) == 0x000008, "Wrong alignment on UNavArea_Drone");
static_assert(sizeof(UNavArea_Drone) == 0x000050, "Wrong size on UNavArea_Drone");

// Class DeadByDaylight.NavArea_Slasher
// 0x0000 (0x0050 - 0x0050)
class UNavArea_Slasher final : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavArea_Slasher">();
	}
	static class UNavArea_Slasher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavArea_Slasher>();
	}
};
static_assert(alignof(UNavArea_Slasher) == 0x000008, "Wrong alignment on UNavArea_Slasher");
static_assert(sizeof(UNavArea_Slasher) == 0x000050, "Wrong size on UNavArea_Slasher");

// Class DeadByDaylight.NavigationQueryFilter_EvadeLoop
// 0x0238 (0x0288 - 0x0050)
class UNavigationQueryFilter_EvadeLoop final : public UNavigationQueryFilter
{
public:
	uint8                                         Pad_50[0x238];                                     // 0x0050(0x0238)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationQueryFilter_EvadeLoop">();
	}
	static class UNavigationQueryFilter_EvadeLoop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationQueryFilter_EvadeLoop>();
	}
};
static_assert(alignof(UNavigationQueryFilter_EvadeLoop) == 0x000008, "Wrong alignment on UNavigationQueryFilter_EvadeLoop");
static_assert(sizeof(UNavigationQueryFilter_EvadeLoop) == 0x000288, "Wrong size on UNavigationQueryFilter_EvadeLoop");

// Class DeadByDaylight.NavigationScreen
// 0x01A8 (0x02C8 - 0x0120)
class UNavigationScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0x1A8];                                    // 0x0120(0x01A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAddPlayerClick(int32 buttonId);
	void OnCancelButtonClick();
	void OnCharacterSwapArrowClick(bool isNext);
	void OnChatInputMouseOver(bool isMouseOver);
	void OnCrowdPlayButtonClick();
	void OnDailyRitualsClick();
	void OnFadeOutEnded();
	void OnInviteFriendClick();
	void OnMatchMakingBanTimeout();
	void OnMatchManagementButtonClick();
	void OnPlayerInfoClick(int32 playerId);
	void OnPlayerOptionSelected(const class FString& krakenId, const class FString& playerId, uint8 option);
	void OnReadyButtonClick();
	void OnSendChatMsgButtonClick(const class FString& message);
	void OnSettingsClick();
	void OnStartButtonClick();
	void OnToggleChatVisibility();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NavigationScreen">();
	}
	static class UNavigationScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNavigationScreen>();
	}
};
static_assert(alignof(UNavigationScreen) == 0x000008, "Wrong alignment on UNavigationScreen");
static_assert(sizeof(UNavigationScreen) == 0x0002C8, "Wrong size on UNavigationScreen");

// Class DeadByDaylight.NewChapterPopupScreen
// 0x0000 (0x0140 - 0x0140)
class UNewChapterPopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NewChapterPopupScreen">();
	}
	static class UNewChapterPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNewChapterPopupScreen>();
	}
};
static_assert(alignof(UNewChapterPopupScreen) == 0x000008, "Wrong alignment on UNewChapterPopupScreen");
static_assert(sizeof(UNewChapterPopupScreen) == 0x000140, "Wrong size on UNewChapterPopupScreen");

// Class DeadByDaylight.NoiseIndicatorEmitterInterface
// 0x0000 (0x0000 - 0x0000)
class INoiseIndicatorEmitterInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NoiseIndicatorEmitterInterface">();
	}
	static class INoiseIndicatorEmitterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INoiseIndicatorEmitterInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(INoiseIndicatorEmitterInterface) == 0x000001, "Wrong alignment on INoiseIndicatorEmitterInterface");
static_assert(sizeof(INoiseIndicatorEmitterInterface) == 0x000001, "Wrong size on INoiseIndicatorEmitterInterface");

// Class DeadByDaylight.ObjectiveScreenIndicatorWorldMarkerComponent
// 0x0010 (0x0240 - 0x0230)
class UObjectiveScreenIndicatorWorldMarkerComponent final : public UScreenIndicatorWorldMarkerComponent
{
public:
	class UTexture2D*                             IndicatorHudScreenIcon;                            // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveScreenIndicatorWorldMarkerComponent">();
	}
	static class UObjectiveScreenIndicatorWorldMarkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveScreenIndicatorWorldMarkerComponent>();
	}
};
static_assert(alignof(UObjectiveScreenIndicatorWorldMarkerComponent) == 0x000010, "Wrong alignment on UObjectiveScreenIndicatorWorldMarkerComponent");
static_assert(sizeof(UObjectiveScreenIndicatorWorldMarkerComponent) == 0x000240, "Wrong size on UObjectiveScreenIndicatorWorldMarkerComponent");
static_assert(offsetof(UObjectiveScreenIndicatorWorldMarkerComponent, IndicatorHudScreenIcon) == 0x000230, "Member 'UObjectiveScreenIndicatorWorldMarkerComponent::IndicatorHudScreenIcon' has a wrong offset!");

// Class DeadByDaylight.AlwaysUseCurrentLocationPlacementStrategy
// 0x0000 (0x0050 - 0x0050)
class UAlwaysUseCurrentLocationPlacementStrategy final : public UObjectPlacementUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlwaysUseCurrentLocationPlacementStrategy">();
	}
	static class UAlwaysUseCurrentLocationPlacementStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlwaysUseCurrentLocationPlacementStrategy>();
	}
};
static_assert(alignof(UAlwaysUseCurrentLocationPlacementStrategy) == 0x000008, "Wrong alignment on UAlwaysUseCurrentLocationPlacementStrategy");
static_assert(sizeof(UAlwaysUseCurrentLocationPlacementStrategy) == 0x000050, "Wrong size on UAlwaysUseCurrentLocationPlacementStrategy");

// Class DeadByDaylight.ObjectPlacerComponent
// 0x0050 (0x0270 - 0x0220)
class UObjectPlacerComponent : public USceneComponent
{
public:
	class UStaticMeshComponent*                   _objectMesh;                                       // 0x0218(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _socketName;                                       // 0x0220(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _indicatorOffsetY;                                 // 0x022C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _indicatorOffsetX;                                 // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _meshOffsetZ;                                      // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _itemObjectId;                                     // 0x0238(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _showIndicator;                                    // 0x0244(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _stayActiveWhileItemInUse;                         // 0x0245(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hideIndicatorDuringAttack;                        // 0x0246(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_247[0x11];                                     // 0x0247(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectPlacementUpdateStrategy*         _objectPlacementUpdateStrategy;                    // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoClear, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObjectPlacementValidationStrategy*     _objectPlacementValidationStrategy;                // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoClear, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateObjectPlacement(bool active);
	void SetHideIndicatorDuringAttack(bool enable);
	void SetIndicatorOffsetX(float x);
	void SetIndicatorOffsetY(float y);
	void SetMeshOffsetZ(float z);
	void SetObjectMesh(class UStaticMeshComponent* objectMesh);
	void SetShowIndicator(bool newValue);

	struct FVector GetObjectPlacementLocation() const;
	struct FRotator GetObjectPlacementRotation() const;
	bool IsPlacementValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPlacerComponent">();
	}
	static class UObjectPlacerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectPlacerComponent>();
	}
};
static_assert(alignof(UObjectPlacerComponent) == 0x000010, "Wrong alignment on UObjectPlacerComponent");
static_assert(sizeof(UObjectPlacerComponent) == 0x000270, "Wrong size on UObjectPlacerComponent");
static_assert(offsetof(UObjectPlacerComponent, _objectMesh) == 0x000218, "Member 'UObjectPlacerComponent::_objectMesh' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _socketName) == 0x000220, "Member 'UObjectPlacerComponent::_socketName' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _indicatorOffsetY) == 0x00022C, "Member 'UObjectPlacerComponent::_indicatorOffsetY' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _indicatorOffsetX) == 0x000230, "Member 'UObjectPlacerComponent::_indicatorOffsetX' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _meshOffsetZ) == 0x000234, "Member 'UObjectPlacerComponent::_meshOffsetZ' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _itemObjectId) == 0x000238, "Member 'UObjectPlacerComponent::_itemObjectId' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _showIndicator) == 0x000244, "Member 'UObjectPlacerComponent::_showIndicator' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _stayActiveWhileItemInUse) == 0x000245, "Member 'UObjectPlacerComponent::_stayActiveWhileItemInUse' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _hideIndicatorDuringAttack) == 0x000246, "Member 'UObjectPlacerComponent::_hideIndicatorDuringAttack' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _objectPlacementUpdateStrategy) == 0x000258, "Member 'UObjectPlacerComponent::_objectPlacementUpdateStrategy' has a wrong offset!");
static_assert(offsetof(UObjectPlacerComponent, _objectPlacementValidationStrategy) == 0x000260, "Member 'UObjectPlacerComponent::_objectPlacementValidationStrategy' has a wrong offset!");

// Class DeadByDaylight.OfferingCard
// 0x0020 (0x0250 - 0x0230)
class AOfferingCard final : public AActor
{
public:
	TArray<struct FRarityTexture>                 _rarityTextures;                                   // 0x0230(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FOfferingTypeTexture>           _offeringTypeTextures;                             // 0x0240(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void ChangeAnimationClass(const TSubclassOf<class UOfferingCardAnim>& animationClass);
	void ChangeState(EOfferingAnimState state);
	void HandleCardDissolved();
	void HandleStateChanged(EOfferingAnimState state);

	class UOfferingCardAnim* GetCardAnimation() const;
	EOfferingAnimState GetState() const;
	bool IsRevealed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingCard">();
	}
	static class AOfferingCard* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOfferingCard>();
	}
};
static_assert(alignof(AOfferingCard) == 0x000008, "Wrong alignment on AOfferingCard");
static_assert(sizeof(AOfferingCard) == 0x000250, "Wrong size on AOfferingCard");
static_assert(offsetof(AOfferingCard, _rarityTextures) == 0x000230, "Member 'AOfferingCard::_rarityTextures' has a wrong offset!");
static_assert(offsetof(AOfferingCard, _offeringTypeTextures) == 0x000240, "Member 'AOfferingCard::_offeringTypeTextures' has a wrong offset!");

// Class DeadByDaylight.OfferingEffectCollection
// 0x0050 (0x0088 - 0x0038)
class UOfferingEffectCollection final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool HasOfferingOfType(EOfferingEffectType type, int32 playerId, class FName tag) const;
	bool HasOfferingWithTag(int32 playerId, class FName tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingEffectCollection">();
	}
	static class UOfferingEffectCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOfferingEffectCollection>();
	}
};
static_assert(alignof(UOfferingEffectCollection) == 0x000008, "Wrong alignment on UOfferingEffectCollection");
static_assert(sizeof(UOfferingEffectCollection) == 0x000088, "Wrong size on UOfferingEffectCollection");

// Class DeadByDaylight.OfferingHandler
// 0x0018 (0x0048 - 0x0030)
class UOfferingHandler final : public UObject
{
public:
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _levelPerkIDs;                                     // 0x0038(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingHandler">();
	}
	static class UOfferingHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOfferingHandler>();
	}
};
static_assert(alignof(UOfferingHandler) == 0x000008, "Wrong alignment on UOfferingHandler");
static_assert(sizeof(UOfferingHandler) == 0x000048, "Wrong size on UOfferingHandler");
static_assert(offsetof(UOfferingHandler, _gameInstance) == 0x000030, "Member 'UOfferingHandler::_gameInstance' has a wrong offset!");
static_assert(offsetof(UOfferingHandler, _levelPerkIDs) == 0x000038, "Member 'UOfferingHandler::_levelPerkIDs' has a wrong offset!");

// Class DeadByDaylight.OfferingSequenceAssets
// 0x0030 (0x0260 - 0x0230)
class AOfferingSequenceAssets final : public AActor
{
public:
	float                                         SpaceBetweenCards;                                 // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AOfferingCard>              DefaultCardClass;                                  // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UOfferingCardAnim>          DefaultCardAnimation;                              // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOfferingRevealDelays>          OfferingRevealDelays;                              // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class AActor*                                 CardsParent;                                       // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void PlayFadeIn();
	void PlayFadeOut();
	void PlaySmoke();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfferingSequenceAssets">();
	}
	static class AOfferingSequenceAssets* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOfferingSequenceAssets>();
	}
};
static_assert(alignof(AOfferingSequenceAssets) == 0x000008, "Wrong alignment on AOfferingSequenceAssets");
static_assert(sizeof(AOfferingSequenceAssets) == 0x000260, "Wrong size on AOfferingSequenceAssets");
static_assert(offsetof(AOfferingSequenceAssets, SpaceBetweenCards) == 0x000230, "Member 'AOfferingSequenceAssets::SpaceBetweenCards' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceAssets, DefaultCardClass) == 0x000238, "Member 'AOfferingSequenceAssets::DefaultCardClass' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceAssets, DefaultCardAnimation) == 0x000240, "Member 'AOfferingSequenceAssets::DefaultCardAnimation' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceAssets, OfferingRevealDelays) == 0x000248, "Member 'AOfferingSequenceAssets::OfferingRevealDelays' has a wrong offset!");
static_assert(offsetof(AOfferingSequenceAssets, CardsParent) == 0x000258, "Member 'AOfferingSequenceAssets::CardsParent' has a wrong offset!");

// Class DeadByDaylight.OfflineLobbyLevel
// 0x01E8 (0x04A8 - 0x02C0)
class AOfflineLobbyLevel final : public ALobbyLevel
{
public:
	struct FVector                                _partyLobbyInviteButtonOffset;                     // 0x02C0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class APlayerStart>>    _roleSelectionCamperSpawns;                        // 0x02D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class APlayerStart>>    _roleSelectionSlasherSpawns;                       // 0x02E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ADisplayStand>           _offlineLobbyLocalSlasherSpawn;                    // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _partyLobbyEmptySlotFxOffset;                      // 0x02F8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ADisplayStand>           _offlineLobbyLocalCamperSpawn;                     // 0x0304(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        _partyLobbySlasherPOVTrackerOffsets;               // 0x0310(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _partyLobbyEmptySlotSilhouette;                    // 0x0320(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ADisplayStand>>   _partyLobbySlasherDisplayStands;                   // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ADisplayStand>>   _partyLobbyCamperDisplayStands;                    // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0x10];                                     // 0x0370(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _meatHookForCustomization;                         // 0x0380(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ATargetPoint>            _meatHookSpawn;                                    // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   _charmForCustomizationZoom;                        // 0x03B8(0x0030)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ATargetPoint>            _camperCharmSpawn;                                 // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ATargetPoint>            _slasherCharmSpawn;                                // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class ADisplayStand>, TWeakObjectPtr<class ADBDMenuSilhouette>> _partyLobbyEmptySlotPawns; // 0x03F8(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_448[0x48];                                     // 0x0448(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _destroyingPawns;                                  // 0x0490(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x8];                                      // 0x04A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckDestroyingPawns(class AActor* DestroyedActor);
	void OnStateChanged(EOfflineLobbyState lobbyState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OfflineLobbyLevel">();
	}
	static class AOfflineLobbyLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOfflineLobbyLevel>();
	}
};
static_assert(alignof(AOfflineLobbyLevel) == 0x000008, "Wrong alignment on AOfflineLobbyLevel");
static_assert(sizeof(AOfflineLobbyLevel) == 0x0004A8, "Wrong size on AOfflineLobbyLevel");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbyInviteButtonOffset) == 0x0002C0, "Member 'AOfflineLobbyLevel::_partyLobbyInviteButtonOffset' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _roleSelectionCamperSpawns) == 0x0002D0, "Member 'AOfflineLobbyLevel::_roleSelectionCamperSpawns' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _roleSelectionSlasherSpawns) == 0x0002E0, "Member 'AOfflineLobbyLevel::_roleSelectionSlasherSpawns' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _offlineLobbyLocalSlasherSpawn) == 0x0002F0, "Member 'AOfflineLobbyLevel::_offlineLobbyLocalSlasherSpawn' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbyEmptySlotFxOffset) == 0x0002F8, "Member 'AOfflineLobbyLevel::_partyLobbyEmptySlotFxOffset' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _offlineLobbyLocalCamperSpawn) == 0x000304, "Member 'AOfflineLobbyLevel::_offlineLobbyLocalCamperSpawn' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbySlasherPOVTrackerOffsets) == 0x000310, "Member 'AOfflineLobbyLevel::_partyLobbySlasherPOVTrackerOffsets' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbyEmptySlotSilhouette) == 0x000320, "Member 'AOfflineLobbyLevel::_partyLobbyEmptySlotSilhouette' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbySlasherDisplayStands) == 0x000350, "Member 'AOfflineLobbyLevel::_partyLobbySlasherDisplayStands' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbyCamperDisplayStands) == 0x000360, "Member 'AOfflineLobbyLevel::_partyLobbyCamperDisplayStands' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _meatHookForCustomization) == 0x000380, "Member 'AOfflineLobbyLevel::_meatHookForCustomization' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _meatHookSpawn) == 0x0003B0, "Member 'AOfflineLobbyLevel::_meatHookSpawn' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _charmForCustomizationZoom) == 0x0003B8, "Member 'AOfflineLobbyLevel::_charmForCustomizationZoom' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _camperCharmSpawn) == 0x0003E8, "Member 'AOfflineLobbyLevel::_camperCharmSpawn' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _slasherCharmSpawn) == 0x0003F0, "Member 'AOfflineLobbyLevel::_slasherCharmSpawn' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _partyLobbyEmptySlotPawns) == 0x0003F8, "Member 'AOfflineLobbyLevel::_partyLobbyEmptySlotPawns' has a wrong offset!");
static_assert(offsetof(AOfflineLobbyLevel, _destroyingPawns) == 0x000490, "Member 'AOfflineLobbyLevel::_destroyingPawns' has a wrong offset!");

// Class DeadByDaylight.OniBasicAttackComponent
// 0x0010 (0x00C8 - 0x00B8)
class UOniBasicAttackComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniBasicAttackComponent">();
	}
	static class UOniBasicAttackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniBasicAttackComponent>();
	}
};
static_assert(alignof(UOniBasicAttackComponent) == 0x000008, "Wrong alignment on UOniBasicAttackComponent");
static_assert(sizeof(UOniBasicAttackComponent) == 0x0000C8, "Wrong size on UOniBasicAttackComponent");

// Class DeadByDaylight.OniDemonModeAttackStateComponent
// 0x0018 (0x00D8 - 0x00C0)
class UOniDemonModeAttackStateComponent final : public UChargedAttackStateComponent
{
public:
	TMulticastInlineDelegate<void(bool bIsReady)> OnChargedAttackReadyChanged;                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_ClearChargingState();
	void Server_ClearChargingState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonModeAttackStateComponent">();
	}
	static class UOniDemonModeAttackStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonModeAttackStateComponent>();
	}
};
static_assert(alignof(UOniDemonModeAttackStateComponent) == 0x000008, "Wrong alignment on UOniDemonModeAttackStateComponent");
static_assert(sizeof(UOniDemonModeAttackStateComponent) == 0x0000D8, "Wrong size on UOniDemonModeAttackStateComponent");
static_assert(offsetof(UOniDemonModeAttackStateComponent, OnChargedAttackReadyChanged) == 0x0000C0, "Member 'UOniDemonModeAttackStateComponent::OnChargedAttackReadyChanged' has a wrong offset!");

// Class DeadByDaylight.OnlineLobbyLevel
// 0x0038 (0x02F8 - 0x02C0)
class AOnlineLobbyLevel final : public ALobbyLevel
{
public:
	class UProceduralGenerationData*              ProceduralGenerationData;                          // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        _onlineLobbySlasherPOVTrackerOffsets;              // 0x02C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ADisplayStand>>   _onlineLobbyCamperDisplayStands;                   // 0x02D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ADisplayStand>>   _onlineLobbySlasherDisplayStands;                  // 0x02E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineLobbyLevel">();
	}
	static class AOnlineLobbyLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOnlineLobbyLevel>();
	}
};
static_assert(alignof(AOnlineLobbyLevel) == 0x000008, "Wrong alignment on AOnlineLobbyLevel");
static_assert(sizeof(AOnlineLobbyLevel) == 0x0002F8, "Wrong size on AOnlineLobbyLevel");
static_assert(offsetof(AOnlineLobbyLevel, ProceduralGenerationData) == 0x0002C0, "Member 'AOnlineLobbyLevel::ProceduralGenerationData' has a wrong offset!");
static_assert(offsetof(AOnlineLobbyLevel, _onlineLobbySlasherPOVTrackerOffsets) == 0x0002C8, "Member 'AOnlineLobbyLevel::_onlineLobbySlasherPOVTrackerOffsets' has a wrong offset!");
static_assert(offsetof(AOnlineLobbyLevel, _onlineLobbyCamperDisplayStands) == 0x0002D8, "Member 'AOnlineLobbyLevel::_onlineLobbyCamperDisplayStands' has a wrong offset!");
static_assert(offsetof(AOnlineLobbyLevel, _onlineLobbySlasherDisplayStands) == 0x0002E8, "Member 'AOnlineLobbyLevel::_onlineLobbySlasherDisplayStands' has a wrong offset!");

// Class DeadByDaylight.OnlinePrivilegeManager
// 0x0008 (0x0040 - 0x0038)
class UOnlinePrivilegeManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlinePrivilegeManager">();
	}
	static class UOnlinePrivilegeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlinePrivilegeManager>();
	}
};
static_assert(alignof(UOnlinePrivilegeManager) == 0x000008, "Wrong alignment on UOnlinePrivilegeManager");
static_assert(sizeof(UOnlinePrivilegeManager) == 0x000040, "Wrong size on UOnlinePrivilegeManager");

// Class DeadByDaylight.OnScreenDebugComponent
// 0x0010 (0x00C8 - 0x00B8)
class UOnScreenDebugComponent final : public UActorComponent
{
public:
	TArray<struct FOnScreenDebugInfo>             _messages;                                         // 0x00B8(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnScreenDebugComponent">();
	}
	static class UOnScreenDebugComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnScreenDebugComponent>();
	}
};
static_assert(alignof(UOnScreenDebugComponent) == 0x000008, "Wrong alignment on UOnScreenDebugComponent");
static_assert(sizeof(UOnScreenDebugComponent) == 0x0000C8, "Wrong size on UOnScreenDebugComponent");
static_assert(offsetof(UOnScreenDebugComponent, _messages) == 0x0000B8, "Member 'UOnScreenDebugComponent::_messages' has a wrong offset!");

// Class DeadByDaylight.OpenHatch
// 0x0000 (0x0620 - 0x0620)
class UOpenHatch final : public UBaseEscapeThroughHatch
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpenHatch">();
	}
	static class UOpenHatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOpenHatch>();
	}
};
static_assert(alignof(UOpenHatch) == 0x000010, "Wrong alignment on UOpenHatch");
static_assert(sizeof(UOpenHatch) == 0x000620, "Wrong size on UOpenHatch");

// Class DeadByDaylight.OtherCharactersVerticalCollisionsHandler
// 0x0028 (0x00E0 - 0x00B8)
class UOtherCharactersVerticalCollisionsHandler final : public UActorComponent
{
public:
	TArray<class AActor*>                         _ignoreBelowActors;                                // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _overlappingActors;                                // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      _pawnDetector;                                     // 0x00D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitializeOverlapDetection();
	void OnPawnDetectorOverlapEnter(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult);
	void OnPawnDetectorOverlapExit(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex);
	void SetPawnDetector(class UCapsuleComponent* pawnDetector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OtherCharactersVerticalCollisionsHandler">();
	}
	static class UOtherCharactersVerticalCollisionsHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOtherCharactersVerticalCollisionsHandler>();
	}
};
static_assert(alignof(UOtherCharactersVerticalCollisionsHandler) == 0x000008, "Wrong alignment on UOtherCharactersVerticalCollisionsHandler");
static_assert(sizeof(UOtherCharactersVerticalCollisionsHandler) == 0x0000E0, "Wrong size on UOtherCharactersVerticalCollisionsHandler");
static_assert(offsetof(UOtherCharactersVerticalCollisionsHandler, _ignoreBelowActors) == 0x0000B8, "Member 'UOtherCharactersVerticalCollisionsHandler::_ignoreBelowActors' has a wrong offset!");
static_assert(offsetof(UOtherCharactersVerticalCollisionsHandler, _overlappingActors) == 0x0000C8, "Member 'UOtherCharactersVerticalCollisionsHandler::_overlappingActors' has a wrong offset!");
static_assert(offsetof(UOtherCharactersVerticalCollisionsHandler, _pawnDetector) == 0x0000D8, "Member 'UOtherCharactersVerticalCollisionsHandler::_pawnDetector' has a wrong offset!");

// Class DeadByDaylight.OutfitHelper
// 0x0000 (0x0030 - 0x0030)
class UOutfitHelper final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutfitHelper">();
	}
	static class UOutfitHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutfitHelper>();
	}
};
static_assert(alignof(UOutfitHelper) == 0x000008, "Wrong alignment on UOutfitHelper");
static_assert(sizeof(UOutfitHelper) == 0x000030, "Wrong size on UOutfitHelper");

// Class DeadByDaylight.OutfitRecommendationsFilter
// 0x0028 (0x0060 - 0x0038)
class UOutfitRecommendationsFilter final : public URecommendationsFilter
{
public:
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutfitRecommendationsFilter">();
	}
	static class UOutfitRecommendationsFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutfitRecommendationsFilter>();
	}
};
static_assert(alignof(UOutfitRecommendationsFilter) == 0x000008, "Wrong alignment on UOutfitRecommendationsFilter");
static_assert(sizeof(UOutfitRecommendationsFilter) == 0x000060, "Wrong size on UOutfitRecommendationsFilter");

// Class DeadByDaylight.OutOfSightMeshRotator
// 0x0028 (0x00E0 - 0x00B8)
class UOutOfSightMeshRotator final : public UActorComponent
{
public:
	float                                         _maxDistance;                                      // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _dotProductThreshold;                              // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADBDPlayer*                             _locallyObservedPlayer;                            // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMeshComponent*>                 _meshesToRotate;                                   // 0x00C8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	float                                         _rotationOffset;                                   // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMeshesToRotate(const TArray<class UMeshComponent*>& meshesToRotate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OutOfSightMeshRotator">();
	}
	static class UOutOfSightMeshRotator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOutOfSightMeshRotator>();
	}
};
static_assert(alignof(UOutOfSightMeshRotator) == 0x000008, "Wrong alignment on UOutOfSightMeshRotator");
static_assert(sizeof(UOutOfSightMeshRotator) == 0x0000E0, "Wrong size on UOutOfSightMeshRotator");
static_assert(offsetof(UOutOfSightMeshRotator, _maxDistance) == 0x0000B8, "Member 'UOutOfSightMeshRotator::_maxDistance' has a wrong offset!");
static_assert(offsetof(UOutOfSightMeshRotator, _dotProductThreshold) == 0x0000BC, "Member 'UOutOfSightMeshRotator::_dotProductThreshold' has a wrong offset!");
static_assert(offsetof(UOutOfSightMeshRotator, _locallyObservedPlayer) == 0x0000C0, "Member 'UOutOfSightMeshRotator::_locallyObservedPlayer' has a wrong offset!");
static_assert(offsetof(UOutOfSightMeshRotator, _meshesToRotate) == 0x0000C8, "Member 'UOutOfSightMeshRotator::_meshesToRotate' has a wrong offset!");
static_assert(offsetof(UOutOfSightMeshRotator, _rotationOffset) == 0x0000D8, "Member 'UOutOfSightMeshRotator::_rotationOffset' has a wrong offset!");

// Class DeadByDaylight.OverlayMenuScreen
// 0x01E0 (0x0300 - 0x0120)
class UOverlayMenuScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0x1E0];                                    // 0x0120(0x01E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAimAssistClick(bool value);
	void OnAtlantaSettingButtonClick(int32 buttonID);
	void OnBackButtonClick();
	void OnCustomerSupportButtonClick();
	void OnEULAButtonClick();
	void OnForumsButtonClick();
	void OnKillerCameraSensitivityChanged(int32 value);
	void OnLanguageChange(int32 value);
	void OnPlayerInfoClick(const class FString& playerId);
	void OnPrivacyPolicyButtonClick();
	void OnQuitButtonClick();
	void OnRequestKeyBindingInput(int32 id, const class FString& key);
	void OnResetDefaultKeybindings();
	void OnResetDefaultSettings();
	void OnSelectTab(int32 tabIndex);
	void OnSettingsOptionButtonClicked(int32 id);
	void OnSettingsOptionCheckboxSelected(int32 id, bool isSelected);
	void OnSettingsOptionIntValueChanged(int32 id, int32 value);
	void OnSurvivorCameraSensitivityChanged(int32 value);
	void SetGameType(EGameType gameType, bool isInCustomMatchManagerMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OverlayMenuScreen">();
	}
	static class UOverlayMenuScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOverlayMenuScreen>();
	}
};
static_assert(alignof(UOverlayMenuScreen) == 0x000008, "Wrong alignment on UOverlayMenuScreen");
static_assert(sizeof(UOverlayMenuScreen) == 0x000300, "Wrong size on UOverlayMenuScreen");

// Class DeadByDaylight.Pallet
// 0x0110 (0x0438 - 0x0328)
class APallet final : public AInteractable
{
public:
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PalletDownEvadeDoorFrontPointOffset;               // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x1C];                                     // 0x0334(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	EPalletState                                  _state;                                            // 0x0350(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPendingDestruction;                             // 0x0351(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIllusionaryPalletDown;                          // 0x0352(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDestroyedByEntity;                              // 0x0353(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _destroyLeft;                                      // 0x0358(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDefinition*                 _destroyRight;                                     // 0x0360(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _pushBox;                                          // 0x0368(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maxDotproductThresholdForPulldownAccross;         // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fallDuration;                                     // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _stunBoxLeft;                                      // 0x0378(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          _stunBoxRight;                                     // 0x0380(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSet<class AActor*>                           _stunnedActors;                                    // 0x0388(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _playerExecutingPulldown;                          // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPalletPushSettings                    _pushSettings;                                     // 0x03E0(0x0002)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E2[0x3E];                                     // 0x03E2(0x003E)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDNavEvadeLoopComponent*              _navEvadeLoopComponent;                            // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPalletPulldownBlockerComponent*        _palletPulldownBlockerComponent;                   // 0x0428(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isDreamPallet;                                    // 0x0430(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_431[0x7];                                      // 0x0431(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnOverlapPushBox(class UPrimitiveComponent* overlappedComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult);
	void Cosmetic_OnPalletPulldownBlockedByEntityHide();
	void Cosmetic_OnPalletPulldownBlockedByEntityShow();
	void Cosmetic_PalletPullDownFXImmediateHide();
	void EntityExplodePallet(class ADBDPlayer* player);
	void ExplodePallet(class ADBDPlayer* player);
	void ExplodeStunPallet(class ADBDPlayer* player);
	void Multicast_EntityExplodePallet(class ADBDPlayer* player);
	void Multicast_PulldownPallet();
	void Multicast_ResetPallet();
	void Multicast_StunActor(class AActor* actor, class ACamperPlayer* survivor, bool stunBreakPallet);
	void OnFallen();
	void OnPalletPulledUp_BP();
	void OnPalletStunHit();
	void OnStunOverlap(class UPrimitiveComponent* overlappedComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult);
	void PullDown(class ADBDPlayer* player, const struct FPalletPushSettings& pushSettings, const EPalletStunZoneSideStrategy stunZoneSideStrategy);
	void PulldownPallet();
	void ResetPallet();
	void SetPalletState(EPalletState state);
	void SetPendingDestruction(bool isPendingDestruction);

	bool CanPulldown(const class ADBDPlayer* player, const struct FVector& interactionAxis, const bool isStationary) const;
	void GetDestructibleAreaPrimitiveComponents(TArray<class UPrimitiveComponent*>* prims) const;
	float GetFallDuration() const;
	bool GetIsDreamPallet() const;
	bool GetIsPulledDown() const;
	class USkeletalMeshComponent* GetPalletSkeletalMeshComponent() const;
	class ADBDPlayer* GetPlayerDoingPulldown() const;
	bool IsDestroyedByEntity() const;
	bool IsPendingDestruction() const;
	bool IsPulldownBlockedByEntity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Pallet">();
	}
	static class APallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<APallet>();
	}
};
static_assert(alignof(APallet) == 0x000008, "Wrong alignment on APallet");
static_assert(sizeof(APallet) == 0x000438, "Wrong size on APallet");
static_assert(offsetof(APallet, PalletDownEvadeDoorFrontPointOffset) == 0x000330, "Member 'APallet::PalletDownEvadeDoorFrontPointOffset' has a wrong offset!");
static_assert(offsetof(APallet, _state) == 0x000350, "Member 'APallet::_state' has a wrong offset!");
static_assert(offsetof(APallet, _isPendingDestruction) == 0x000351, "Member 'APallet::_isPendingDestruction' has a wrong offset!");
static_assert(offsetof(APallet, _isIllusionaryPalletDown) == 0x000352, "Member 'APallet::_isIllusionaryPalletDown' has a wrong offset!");
static_assert(offsetof(APallet, _isDestroyedByEntity) == 0x000353, "Member 'APallet::_isDestroyedByEntity' has a wrong offset!");
static_assert(offsetof(APallet, _destroyLeft) == 0x000358, "Member 'APallet::_destroyLeft' has a wrong offset!");
static_assert(offsetof(APallet, _destroyRight) == 0x000360, "Member 'APallet::_destroyRight' has a wrong offset!");
static_assert(offsetof(APallet, _pushBox) == 0x000368, "Member 'APallet::_pushBox' has a wrong offset!");
static_assert(offsetof(APallet, _maxDotproductThresholdForPulldownAccross) == 0x000370, "Member 'APallet::_maxDotproductThresholdForPulldownAccross' has a wrong offset!");
static_assert(offsetof(APallet, _fallDuration) == 0x000374, "Member 'APallet::_fallDuration' has a wrong offset!");
static_assert(offsetof(APallet, _stunBoxLeft) == 0x000378, "Member 'APallet::_stunBoxLeft' has a wrong offset!");
static_assert(offsetof(APallet, _stunBoxRight) == 0x000380, "Member 'APallet::_stunBoxRight' has a wrong offset!");
static_assert(offsetof(APallet, _stunnedActors) == 0x000388, "Member 'APallet::_stunnedActors' has a wrong offset!");
static_assert(offsetof(APallet, _playerExecutingPulldown) == 0x0003D8, "Member 'APallet::_playerExecutingPulldown' has a wrong offset!");
static_assert(offsetof(APallet, _pushSettings) == 0x0003E0, "Member 'APallet::_pushSettings' has a wrong offset!");
static_assert(offsetof(APallet, _navEvadeLoopComponent) == 0x000420, "Member 'APallet::_navEvadeLoopComponent' has a wrong offset!");
static_assert(offsetof(APallet, _palletPulldownBlockerComponent) == 0x000428, "Member 'APallet::_palletPulldownBlockerComponent' has a wrong offset!");
static_assert(offsetof(APallet, _isDreamPallet) == 0x000430, "Member 'APallet::_isDreamPallet' has a wrong offset!");

// Class DeadByDaylight.PalletPulldownBlockerComponent
// 0x0078 (0x0130 - 0x00B8)
class UPalletPulldownBlockerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x60];                                      // 0x00B8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isPalletPulldownBlockedByEntity;                  // 0x0118(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                _palletToBlock;                                    // 0x0120(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _blockedDisappearFxTime;                           // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_PalletPulldownBlockedHideCosmetic(class UObject* palletToUnblock);
	void Multicast_PalletPulldownBlockedShowCosmetic(class UObject* palletToBlock);
	void OnRep_PalletToBlock(class UObject* oldPalletToBlock);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletPulldownBlockerComponent">();
	}
	static class UPalletPulldownBlockerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalletPulldownBlockerComponent>();
	}
};
static_assert(alignof(UPalletPulldownBlockerComponent) == 0x000008, "Wrong alignment on UPalletPulldownBlockerComponent");
static_assert(sizeof(UPalletPulldownBlockerComponent) == 0x000130, "Wrong size on UPalletPulldownBlockerComponent");
static_assert(offsetof(UPalletPulldownBlockerComponent, _isPalletPulldownBlockedByEntity) == 0x000118, "Member 'UPalletPulldownBlockerComponent::_isPalletPulldownBlockedByEntity' has a wrong offset!");
static_assert(offsetof(UPalletPulldownBlockerComponent, _palletToBlock) == 0x000120, "Member 'UPalletPulldownBlockerComponent::_palletToBlock' has a wrong offset!");
static_assert(offsetof(UPalletPulldownBlockerComponent, _blockedDisappearFxTime) == 0x000128, "Member 'UPalletPulldownBlockerComponent::_blockedDisappearFxTime' has a wrong offset!");

// Class DeadByDaylight.PalletTracker
// 0x0020 (0x0250 - 0x0230)
class APalletTracker final : public AActor
{
public:
	class APallet*                                _procedurallySpawnedPallet;                        // 0x0230(0x0008)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APallet*                                _dreamPallet;                                      // 0x0238(0x0008)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        _indicatorLocation;                                // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableSelectedEffectToLocalPlayer(bool activated);
	void InitializeTunableValues(class ASlasherPlayer* slasher);
	void RevealToLocalPlayerBP(bool shown);

	bool CanSpawnDreamPalletAtLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletTracker">();
	}
	static class APalletTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<APalletTracker>();
	}
};
static_assert(alignof(APalletTracker) == 0x000008, "Wrong alignment on APalletTracker");
static_assert(sizeof(APalletTracker) == 0x000250, "Wrong size on APalletTracker");
static_assert(offsetof(APalletTracker, _procedurallySpawnedPallet) == 0x000230, "Member 'APalletTracker::_procedurallySpawnedPallet' has a wrong offset!");
static_assert(offsetof(APalletTracker, _dreamPallet) == 0x000238, "Member 'APalletTracker::_dreamPallet' has a wrong offset!");
static_assert(offsetof(APalletTracker, _indicatorLocation) == 0x000240, "Member 'APalletTracker::_indicatorLocation' has a wrong offset!");

// Class DeadByDaylight.PalletUtilities
// 0x0000 (0x0030 - 0x0030)
class UPalletUtilities final : public UObject
{
public:
	static TSoftClassPtr<class UClass> GetDreamPalletBP(const class UObject* worldContextObject);
	static TSoftObjectPtr<class UStaticMesh> GetIllusionaryPalletStaticMesh(const class UObject* worldContextObjec);
	static TSoftClassPtr<class UClass> GetPalletTrackerBP(const class UObject* worldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PalletUtilities">();
	}
	static class UPalletUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPalletUtilities>();
	}
};
static_assert(alignof(UPalletUtilities) == 0x000008, "Wrong alignment on UPalletUtilities");
static_assert(sizeof(UPalletUtilities) == 0x000030, "Wrong size on UPalletUtilities");

// Class DeadByDaylight.PanelScreen
// 0x02D0 (0x03F0 - 0x0120)
class UPanelScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0x2D0];                                    // 0x0120(0x02D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAvailableItemClicked(int32 clickedItemIndex);
	void OnAvailableItemsSortingChange(int32 newSorting);
	void OnBloodwebCenterButtonSelected();
	void OnCharacterInfoClick();
	void OnCharacterSlotButtonClick(int32 characterIndex);
	void OnCharInfoClick();
	void OnConfirmCollectSelectedNode(int32 characterId);
	void OnCrowdChoiceCharacterClick();
	void OnCustomizationPresetClick(int32 index);
	void OnEquipableSlotClicked(int32 clickedSlotCategory, int32 clickedSlotIndex);
	void OnEventButtonClick();
	void OnItemSelected(int32 itemIndex);
	void OnItemUnselected(int32 itemIndex);
	void OnLoadoutPresetClick(int32 index);
	void OnLoadoutSlotButtonClick(int32 slotIndex);
	void OnNodeCollectionAnimDone();
	void OnNodeConsumptionAnimDone();
	void OnPanelsHidden();
	void OnPrestigeUp(int32 characterId);
	void OnRegenerateButtonClick(int32 characterId);
	void OnReservedBloodPoints(int32 characterId, int32 bloodPoints, bool fullCost);
	void OnRoleButtonClick();
	void OnRotateCharacter(float mouseDistanceChange);
	void OnSelectedEquipableSlotZoomChange(bool zoomIn);
	void OnSequenceStepCompleted(int32 characterId, int32 id);
	void OnSideTabButtonClick(int32 tabIndex);
	void OnStoreButtonClick();
	void OnWebBuilt(int32 characterId, bool isEmpty);
	void OnWebNodeHovered(int32 id);
	void OnWebNodeSelected(int32 characterId, int32 id, int32 nodeDepth);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PanelScreen">();
	}
	static class UPanelScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPanelScreen>();
	}
};
static_assert(alignof(UPanelScreen) == 0x000008, "Wrong alignment on UPanelScreen");
static_assert(sizeof(UPanelScreen) == 0x0003F0, "Wrong size on UPanelScreen");

// Class DeadByDaylight.PartyEventsManager
// 0x0010 (0x0048 - 0x0038)
class UPartyEventsManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyEventsManager">();
	}
	static class UPartyEventsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPartyEventsManager>();
	}
};
static_assert(alignof(UPartyEventsManager) == 0x000008, "Wrong alignment on UPartyEventsManager");
static_assert(sizeof(UPartyEventsManager) == 0x000048, "Wrong size on UPartyEventsManager");

// Class DeadByDaylight.PerkActionButton
// 0x0028 (0x06A0 - 0x0678)
class UPerkActionButton final : public UUMGLoadoutItemButton
{
public:
	class UTextBlock*                             TextUnlockLevelTitle;                              // 0x0678(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Activatable;                                       // 0x0680(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              SelectedImageVisibility;                           // 0x0681(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              ClickableButtonVisibility;                         // 0x0682(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              ClickableImageVisibility;                          // 0x0683(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              ProgressbarVisibility;                             // 0x0684(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_685[0x3];                                      // 0x0685(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IdleTime;                                          // 0x0688(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68C[0x14];                                     // 0x068C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallHidePerkLevel();
	void CallSetPerkLevel(const int32 level);
	void SetCanEverBeActivated();
	void SetIsActivatable(bool isClickable);
	void UpdateWidgetPercentage(float percentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkActionButton">();
	}
	static class UPerkActionButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkActionButton>();
	}
};
static_assert(alignof(UPerkActionButton) == 0x000008, "Wrong alignment on UPerkActionButton");
static_assert(sizeof(UPerkActionButton) == 0x0006A0, "Wrong size on UPerkActionButton");
static_assert(offsetof(UPerkActionButton, TextUnlockLevelTitle) == 0x000678, "Member 'UPerkActionButton::TextUnlockLevelTitle' has a wrong offset!");
static_assert(offsetof(UPerkActionButton, Activatable) == 0x000680, "Member 'UPerkActionButton::Activatable' has a wrong offset!");
static_assert(offsetof(UPerkActionButton, SelectedImageVisibility) == 0x000681, "Member 'UPerkActionButton::SelectedImageVisibility' has a wrong offset!");
static_assert(offsetof(UPerkActionButton, ClickableButtonVisibility) == 0x000682, "Member 'UPerkActionButton::ClickableButtonVisibility' has a wrong offset!");
static_assert(offsetof(UPerkActionButton, ClickableImageVisibility) == 0x000683, "Member 'UPerkActionButton::ClickableImageVisibility' has a wrong offset!");
static_assert(offsetof(UPerkActionButton, ProgressbarVisibility) == 0x000684, "Member 'UPerkActionButton::ProgressbarVisibility' has a wrong offset!");
static_assert(offsetof(UPerkActionButton, IdleTime) == 0x000688, "Member 'UPerkActionButton::IdleTime' has a wrong offset!");

// Class DeadByDaylight.PerkDataAsset
// 0x0000 (0x0088 - 0x0088)
class UPerkDataAsset final : public UGameplayModifierContainerDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkDataAsset">();
	}
	static class UPerkDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkDataAsset>();
	}
};
static_assert(alignof(UPerkDataAsset) == 0x000008, "Wrong alignment on UPerkDataAsset");
static_assert(sizeof(UPerkDataAsset) == 0x000088, "Wrong size on UPerkDataAsset");

// Class DeadByDaylight.PerkHudWidget
// 0x0138 (0x0470 - 0x0338)
class UPerkHudWidget final : public UMobileBaseUserWidget
{
public:
	class UCanvasPanel*                           PerksClickable;                                    // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           PerksExternal;                                     // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AtlantaPerkActionButtonClass;                      // 0x0348(0x0030)(Edit, BlueprintVisible, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UPerkActionButton*>   _clickablePerksMap;                                // 0x0378(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class FName, class UPerkActionButton*>   _externalPerksMap;                                 // 0x03C8(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x58];                                     // 0x0418(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPerkClickedHandler(class FName perkID);
	void RemoveExistingPerk(class FName perkID, bool isExternal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkHudWidget">();
	}
	static class UPerkHudWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkHudWidget>();
	}
};
static_assert(alignof(UPerkHudWidget) == 0x000008, "Wrong alignment on UPerkHudWidget");
static_assert(sizeof(UPerkHudWidget) == 0x000470, "Wrong size on UPerkHudWidget");
static_assert(offsetof(UPerkHudWidget, PerksClickable) == 0x000338, "Member 'UPerkHudWidget::PerksClickable' has a wrong offset!");
static_assert(offsetof(UPerkHudWidget, PerksExternal) == 0x000340, "Member 'UPerkHudWidget::PerksExternal' has a wrong offset!");
static_assert(offsetof(UPerkHudWidget, AtlantaPerkActionButtonClass) == 0x000348, "Member 'UPerkHudWidget::AtlantaPerkActionButtonClass' has a wrong offset!");
static_assert(offsetof(UPerkHudWidget, _clickablePerksMap) == 0x000378, "Member 'UPerkHudWidget::_clickablePerksMap' has a wrong offset!");
static_assert(offsetof(UPerkHudWidget, _externalPerksMap) == 0x0003C8, "Member 'UPerkHudWidget::_externalPerksMap' has a wrong offset!");

// Class DeadByDaylight.PerkManager
// 0x02B8 (0x0370 - 0x00B8)
class UPerkManager final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UPerkCollectionComponent*               _perks;                                            // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffectCollectionComponent*       _statusEffects;                                    // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x280];                                     // 0x00F0(0x0280)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_EndStatusEffectByID(class FName statusEffectId, bool bRemoveAllWithID);
	class UStatusEffect* Authority_ImposeDynamicStatusEffect_DEPRECATED(class FName statusEffectID, class ADBDPlayer* originatingPlayer, float customParam, class UGameplayModifierContainer* originatingEffect);
	class UStatusEffect* Authority_ImposeNewStatusEffectOfClassOrChangeLifeTime(TSubclassOf<class UStatusEffect> effectClass, class ADBDPlayer* originatingPlayer, float lifeTime, float customParam, class UGameplayModifierContainer* originatingEffect, bool shouldDisplay);
	class UStatusEffect* Authority_ImposeNewStatusEffectOrChangeLifeTime_DEPRECATED(class FName statusEffectID, class ADBDPlayer* originatingPlayer, float lifeTime, float customParam, class UGameplayModifierContainer* originatingEffect, bool shouldDisplay);
	class UStatusEffect* Authority_ImposeStatusEffect_DEPRECATED(class FName statusEffectID, class ADBDPlayer* originatingPlayer, float customParam, class UGameplayModifierContainer* originatingEffect, bool shouldDisplay, float lifetime);
	class UStatusEffect* Authority_ImposeStatusEffectOfClass(TSubclassOf<class UStatusEffect> effectClass, class ADBDPlayer* originatingPlayer, float customParam, class UGameplayModifierContainer* originatingEffect, bool shouldDisplay, float lifetime);
	void Authority_RemovePerks();
	void Authority_RemoveStatusEffect(class UStatusEffect* statusEffect);
	void Authority_RemoveStatusEffectByID(class FName statusEffectId, bool bRemoveAllWithID);
	void Authority_SpawnPerk(class FName perkID, int32 perkLevel);

	TArray<class UGameplayModifierContainer*> GetAllSourcesWithFlag(const struct FGameplayTag& flag) const;
	TArray<class UGameplayModifierContainer*> GetAllSourcesWithModifier(const struct FGameplayTag& type) const;
	TArray<class UStatusEffect*> GetAllStatusEffects() const;
	TArray<class UStatusEffect*> GetAllStatusEffectsByClass(const class UClass* type) const;
	TArray<class UStatusEffect*> GetAllStatusEffectsByID(const class FName& id) const;
	float GetCompoundedModifierValue(const struct FGameplayTag& type) const;
	float GetMultiplicativeModifierValue(const struct FGameplayTag& type) const;
	float GetMultiplicativeModifierValueOfContainerWithCompoundNegative(const struct FGameplayTagContainer& container) const;
	float GetMultiplicativeModifierValueWithCompoundNegative(const struct FGameplayTag& type) const;
	class UPerk* GetPerk(class FName id) const;
	float GetPerkModifier(const struct FGameplayTag& type) const;
	float GetPerkModifierAdditiveValue(const struct FGameplayTag& type, const float baseValue) const;
	float GetPerkModifierMaxValue(const struct FGameplayTag& type) const;
	float GetPerkModifierMaxValueAndSource(const struct FGameplayTag& type, class UGameplayModifierContainer** outSource) const;
	float GetPerkModifierMinValue(const struct FGameplayTag& type, float startValue) const;
	float GetPerkModifierMinValueAndSource(const struct FGameplayTag& type, float startValue, class UGameplayModifierContainer** outSource) const;
	const TArray<class UPerk*> GetPerks() const;
	class UGameplayModifierContainer* GetSourceWithFlag(const struct FGameplayTag& flag) const;
	class UGameplayModifierContainer* GetSourceWithModifier(const struct FGameplayTag& type) const;
	class UStatusEffect* GetStatusEffect(class FName id) const;
	bool HasAllCharacterPerksEquipped() const;
	bool HasAnyAddonWithTag(class FName tag) const;
	bool HasAnyEffectWithID(class FName id) const;
	bool HasPerkFlag(const struct FGameplayTag& flag) const;
	bool HasPerkFlagFromSource(const struct FGameplayTag& flag, EGameplayModifierSource modifierSource) const;
	bool HasPerkFlags(const TArray<struct FGameplayTag>& flags) const;
	bool HasPerkModifierOfType(const struct FGameplayTag& type) const;
	bool HasPerkSubFlag(const struct FGameplayTag& subFlag) const;
	bool HasStatusEffect(const class FName statusEffectID) const;
	bool HasStatusEffectOfClass(const class UClass* type) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkManager">();
	}
	static class UPerkManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkManager>();
	}
};
static_assert(alignof(UPerkManager) == 0x000008, "Wrong alignment on UPerkManager");
static_assert(sizeof(UPerkManager) == 0x000370, "Wrong size on UPerkManager");
static_assert(offsetof(UPerkManager, _perks) == 0x0000E0, "Member 'UPerkManager::_perks' has a wrong offset!");
static_assert(offsetof(UPerkManager, _statusEffects) == 0x0000E8, "Member 'UPerkManager::_statusEffects' has a wrong offset!");

// Class DeadByDaylight.PerkOwnerInterface
// 0x0000 (0x0000 - 0x0000)
class IPerkOwnerInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkOwnerInterface">();
	}
	static class IPerkOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPerkOwnerInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPerkOwnerInterface) == 0x000001, "Wrong alignment on IPerkOwnerInterface");
static_assert(sizeof(IPerkOwnerInterface) == 0x000001, "Wrong size on IPerkOwnerInterface");

// Class DeadByDaylight.PerkSelectionSlotWidget
// 0x0080 (0x03B8 - 0x0338)
class UPerkSelectionSlotWidget final : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             PerkName;                                          // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextChoose;                                        // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPerkActionButton*                      PerkActionButton;                                  // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SelectedIcon;                                      // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGHtmlRichText*                       DescriptionText;                                   // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PictureBackground;                                 // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PicturePerkBackground;                             // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PictureHighlightFrame;                             // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PictureTopRightBackground;                         // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PictureTopRightFrame;                              // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HighOpacity;                                       // 0x0388(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowOpacity;                                        // 0x038C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PerkBackgroundLowOpacity;                          // 0x0390(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DescriptionBackgroundLowOpacity;                   // 0x0394(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_398[0x20];                                     // 0x0398(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkSelectionSlotWidget">();
	}
	static class UPerkSelectionSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkSelectionSlotWidget>();
	}
};
static_assert(alignof(UPerkSelectionSlotWidget) == 0x000008, "Wrong alignment on UPerkSelectionSlotWidget");
static_assert(sizeof(UPerkSelectionSlotWidget) == 0x0003B8, "Wrong size on UPerkSelectionSlotWidget");
static_assert(offsetof(UPerkSelectionSlotWidget, PerkName) == 0x000338, "Member 'UPerkSelectionSlotWidget::PerkName' has a wrong offset!");
static_assert(offsetof(UPerkSelectionSlotWidget, TextChoose) == 0x000340, "Member 'UPerkSelectionSlotWidget::TextChoose' has a wrong offset!");
static_assert(offsetof(UPerkSelectionSlotWidget, PerkActionButton) == 0x000348, "Member 'UPerkSelectionSlotWidget::PerkActionButton' has a wrong offset!");
static_assert(offsetof(UPerkSelectionSlotWidget, SelectedIcon) == 0x000350, "Member 'UPerkSelectionSlotWidget::SelectedIcon' has a wrong offset!");
static_assert(offsetof(UPerkSelectionSlotWidget, DescriptionText) == 0x000358, "Member 'UPerkSelectionSlotWidget::DescriptionText' has a wrong offset!");
static_assert(offsetof(UPerkSelectionSlotWidget, PictureBackground) == 0x000360, "Member 'UPerkSelectionSlotWidget::PictureBackground' has a wrong offset!");
static_assert(offsetof(UPerkSelectionSlotWidget, PicturePerkBackground) == 0x000368, "Member 'UPerkSelectionSlotWidget::PicturePerkBackground' has a wrong offset!");
static_assert(offsetof(UPerkSelectionSlotWidget, PictureHighlightFrame) == 0x000370, "Member 'UPerkSelectionSlotWidget::PictureHighlightFrame' has a wrong offset!");
static_assert(offsetof(UPerkSelectionSlotWidget, PictureTopRightBackground) == 0x000378, "Member 'UPerkSelectionSlotWidget::PictureTopRightBackground' has a wrong offset!");
static_assert(offsetof(UPerkSelectionSlotWidget, PictureTopRightFrame) == 0x000380, "Member 'UPerkSelectionSlotWidget::PictureTopRightFrame' has a wrong offset!");
static_assert(offsetof(UPerkSelectionSlotWidget, HighOpacity) == 0x000388, "Member 'UPerkSelectionSlotWidget::HighOpacity' has a wrong offset!");
static_assert(offsetof(UPerkSelectionSlotWidget, LowOpacity) == 0x00038C, "Member 'UPerkSelectionSlotWidget::LowOpacity' has a wrong offset!");
static_assert(offsetof(UPerkSelectionSlotWidget, PerkBackgroundLowOpacity) == 0x000390, "Member 'UPerkSelectionSlotWidget::PerkBackgroundLowOpacity' has a wrong offset!");
static_assert(offsetof(UPerkSelectionSlotWidget, DescriptionBackgroundLowOpacity) == 0x000394, "Member 'UPerkSelectionSlotWidget::DescriptionBackgroundLowOpacity' has a wrong offset!");

// Class DeadByDaylight.PerkSoundHudWidget
// 0x0008 (0x0340 - 0x0338)
class UPerkSoundHudWidget final : public UMobileBaseUserWidget
{
public:
	class UHorizontalBox*                         PerkIcons;                                         // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkSoundHudWidget">();
	}
	static class UPerkSoundHudWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkSoundHudWidget>();
	}
};
static_assert(alignof(UPerkSoundHudWidget) == 0x000008, "Wrong alignment on UPerkSoundHudWidget");
static_assert(sizeof(UPerkSoundHudWidget) == 0x000340, "Wrong size on UPerkSoundHudWidget");
static_assert(offsetof(UPerkSoundHudWidget, PerkIcons) == 0x000338, "Member 'UPerkSoundHudWidget::PerkIcons' has a wrong offset!");

// Class DeadByDaylight.PerkUtilitiesInterface
// 0x0000 (0x0000 - 0x0000)
class IPerkUtilitiesInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkUtilitiesInterface">();
	}
	static class IPerkUtilitiesInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPerkUtilitiesInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPerkUtilitiesInterface) == 0x000001, "Wrong alignment on IPerkUtilitiesInterface");
static_assert(sizeof(IPerkUtilitiesInterface) == 0x000001, "Wrong size on IPerkUtilitiesInterface");

// Class DeadByDaylight.PerspectiveEffectActivator
// 0x0070 (0x0128 - 0x00B8)
class UPerspectiveEffectActivator final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FPerspectiveEffectData> _perspectiveEffects;                            // 0x00C8(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsEffectActive(class FName effectName);
	void RegisterEffect(class FName effectName, const struct FPerspectiveEffectData& effectData);
	void SetWantsActive(class FName effectName, bool wantsActive);
	void UnregisterEffect(class FName effectName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerspectiveEffectActivator">();
	}
	static class UPerspectiveEffectActivator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerspectiveEffectActivator>();
	}
};
static_assert(alignof(UPerspectiveEffectActivator) == 0x000008, "Wrong alignment on UPerspectiveEffectActivator");
static_assert(sizeof(UPerspectiveEffectActivator) == 0x000128, "Wrong size on UPerspectiveEffectActivator");
static_assert(offsetof(UPerspectiveEffectActivator, _perspectiveEffects) == 0x0000C8, "Member 'UPerspectiveEffectActivator::_perspectiveEffects' has a wrong offset!");

// Class DeadByDaylight.PlagueUtilities
// 0x0000 (0x0030 - 0x0030)
class UPlagueUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void Authority_AddSicknessToPlayer(class ADBDPlayer* player, float sicknessToAdd);
	static class USurvivorPlagueEffect* GetPlagueEffect(const class ADBDPlayer* player);
	static bool HasMaxLevelSickness(const class ADBDPlayer* player);
	static bool IsInfected(const class ADBDPlayer* player);
	static bool IsPlagueDebugModeActive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlagueUtilities">();
	}
	static class UPlagueUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlagueUtilities>();
	}
};
static_assert(alignof(UPlagueUtilities) == 0x000008, "Wrong alignment on UPlagueUtilities");
static_assert(sizeof(UPlagueUtilities) == 0x000030, "Wrong size on UPlagueUtilities");

// Class DeadByDaylight.PlayerDataStorageFacade
// 0x0068 (0x0098 - 0x0030)
class UPlayerDataStorageFacade final : public UObject
{
public:
	uint8                                         Pad_30[0x68];                                      // 0x0030(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDataStorageFacade">();
	}
	static class UPlayerDataStorageFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDataStorageFacade>();
	}
};
static_assert(alignof(UPlayerDataStorageFacade) == 0x000008, "Wrong alignment on UPlayerDataStorageFacade");
static_assert(sizeof(UPlayerDataStorageFacade) == 0x000098, "Wrong size on UPlayerDataStorageFacade");

// Class DeadByDaylight.Window
// 0x0108 (0x0430 - 0x0328)
class AWindow final : public AInteractable
{
public:
	struct FNativeBlockIndicatorData              NativeSmokeOtherIndicatorData;                     // 0x0328(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FNativeBlockIndicatorData              NativeEntityIndicatorData;                         // 0x0340(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FNativeBlockIndicatorData              NativeSmokeSelfIndicatorData;                      // 0x0358(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    _windowCollider;                                   // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBlockedByLevel;                                 // 0x0378(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UChildActorComponent*                   _entityAssets;                                     // 0x0380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialHelper*                        _materialHelper;                                   // 0x0388(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           _akAudioWindow;                                    // 0x0390(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          akAudioEventWindowsBlocStart;                      // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          akAudioEventWindowsBlocStop;                       // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ACamperPlayer*, struct FVaultData> _survivorVaultData;                                // 0x03A8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalPlayerTrackerComponent*           _localPlayerTracker;                               // 0x0400(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlockableComponent*                    _blockableComponent;                               // 0x0408(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x10];                                     // 0x0410(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDNavEvadeLoopComponent*              _navEvadeLoopComponent;                            // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnVaultInternal(class ADBDPlayer* player, bool canBlockVault);
	void Authority_SetBlockedByLevel(bool isBlockedByLevel);
	void ForceBlockLocalWindowInteraction(bool blockInteraction);
	void NotifyOnFastVault(class ADBDPlayer* player, class UInteractionDefinition* interaction);
	void OnFastVault(class ADBDPlayer* player, class UInteractionDefinition* interaction);
	void OnLocallyObservedChanged();
	void OnRep_blockedByLevel();

	class UAkComponent* GetAudioComponent() const;
	bool GetBlockedByLevel() const;
	class UChildActorComponent* GetEntityAssets() const;
	class UMaterialHelper* GetMaterialHelper() const;
	bool IsWindowVaultBlockedFor(const class ADBDPlayer* player) const;
	bool IsWindowVaultBlockedForAnyPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Window">();
	}
	static class AWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWindow>();
	}
};
static_assert(alignof(AWindow) == 0x000008, "Wrong alignment on AWindow");
static_assert(sizeof(AWindow) == 0x000430, "Wrong size on AWindow");
static_assert(offsetof(AWindow, NativeSmokeOtherIndicatorData) == 0x000328, "Member 'AWindow::NativeSmokeOtherIndicatorData' has a wrong offset!");
static_assert(offsetof(AWindow, NativeEntityIndicatorData) == 0x000340, "Member 'AWindow::NativeEntityIndicatorData' has a wrong offset!");
static_assert(offsetof(AWindow, NativeSmokeSelfIndicatorData) == 0x000358, "Member 'AWindow::NativeSmokeSelfIndicatorData' has a wrong offset!");
static_assert(offsetof(AWindow, _windowCollider) == 0x000370, "Member 'AWindow::_windowCollider' has a wrong offset!");
static_assert(offsetof(AWindow, _isBlockedByLevel) == 0x000378, "Member 'AWindow::_isBlockedByLevel' has a wrong offset!");
static_assert(offsetof(AWindow, _entityAssets) == 0x000380, "Member 'AWindow::_entityAssets' has a wrong offset!");
static_assert(offsetof(AWindow, _materialHelper) == 0x000388, "Member 'AWindow::_materialHelper' has a wrong offset!");
static_assert(offsetof(AWindow, _akAudioWindow) == 0x000390, "Member 'AWindow::_akAudioWindow' has a wrong offset!");
static_assert(offsetof(AWindow, akAudioEventWindowsBlocStart) == 0x000398, "Member 'AWindow::akAudioEventWindowsBlocStart' has a wrong offset!");
static_assert(offsetof(AWindow, akAudioEventWindowsBlocStop) == 0x0003A0, "Member 'AWindow::akAudioEventWindowsBlocStop' has a wrong offset!");
static_assert(offsetof(AWindow, _survivorVaultData) == 0x0003A8, "Member 'AWindow::_survivorVaultData' has a wrong offset!");
static_assert(offsetof(AWindow, _localPlayerTracker) == 0x000400, "Member 'AWindow::_localPlayerTracker' has a wrong offset!");
static_assert(offsetof(AWindow, _blockableComponent) == 0x000408, "Member 'AWindow::_blockableComponent' has a wrong offset!");
static_assert(offsetof(AWindow, _navEvadeLoopComponent) == 0x000420, "Member 'AWindow::_navEvadeLoopComponent' has a wrong offset!");

// Class DeadByDaylight.PlayerDebugComponent
// 0x0008 (0x00C0 - 0x00B8)
class UPlayerDebugComponent final : public UActorComponent
{
public:
	bool                                          _disableStartUpdateMontageDuringEnter;             // 0x00B8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _allowPalletPullUpInteraction;                     // 0x00B9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerDebugComponent">();
	}
	static class UPlayerDebugComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerDebugComponent>();
	}
};
static_assert(alignof(UPlayerDebugComponent) == 0x000008, "Wrong alignment on UPlayerDebugComponent");
static_assert(sizeof(UPlayerDebugComponent) == 0x0000C0, "Wrong size on UPlayerDebugComponent");
static_assert(offsetof(UPlayerDebugComponent, _disableStartUpdateMontageDuringEnter) == 0x0000B8, "Member 'UPlayerDebugComponent::_disableStartUpdateMontageDuringEnter' has a wrong offset!");
static_assert(offsetof(UPlayerDebugComponent, _allowPalletPullUpInteraction) == 0x0000B9, "Member 'UPlayerDebugComponent::_allowPalletPullUpInteraction' has a wrong offset!");

// Class DeadByDaylight.PlayerGameRelevancyComponent
// 0x0058 (0x0110 - 0x00B8)
class UPlayerGameRelevancyComponent final : public UActorComponent
{
public:
	struct FTagStateBool                          _isRelevantToGameplay;                             // 0x00B8(0x0030)(Net, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x28];                                      // 0x00E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerGameRelevancyComponent">();
	}
	static class UPlayerGameRelevancyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerGameRelevancyComponent>();
	}
};
static_assert(alignof(UPlayerGameRelevancyComponent) == 0x000008, "Wrong alignment on UPlayerGameRelevancyComponent");
static_assert(sizeof(UPlayerGameRelevancyComponent) == 0x000110, "Wrong size on UPlayerGameRelevancyComponent");
static_assert(offsetof(UPlayerGameRelevancyComponent, _isRelevantToGameplay) == 0x0000B8, "Member 'UPlayerGameRelevancyComponent::_isRelevantToGameplay' has a wrong offset!");

// Class DeadByDaylight.PlayerInteractionHandler
// 0x0598 (0x0650 - 0x00B8)
class alignas(0x10) UPlayerInteractionHandler final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x68];                                      // 0x00B8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PriorityConeAngle;                                 // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BotPriorityConeAngle;                              // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              Authority_SecondaryActionDoneDelegate;             // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              NewInteractionRequestedDelegate;                   // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              ServerValidatedInteractionStartedDelegate;         // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              ServerValidatedInteractionEndedDelegate;           // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EInteractionLayer                             InteractionLayer;                                  // 0x0178(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_179[0xF];                                      // 0x0179(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool HadInput, bool Success, bool Bonus, ESkillCheckCustomType type)> OnDeactivateSkillCheckDelegate; // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_198[0x68];                                     // 0x0198(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasInteractionRequest;                            // 0x0200(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasInteractionRequestInBuffer;                    // 0x0201(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_202[0x1E];                                     // 0x0202(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _interactionToSwapTo;                              // 0x0220(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_228[0x20];                                     // 0x0228(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionDefinition*                 _currentInteraction;                               // 0x0248(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0xA0];                                     // 0x0250(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _currentPlayerDependencies;                        // 0x02F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	EInputInteractionType                         _currentInteractionType;                           // 0x0300(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkillCheck*                            _skillCheck;                                       // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 _progressBasedSkillChecks;                         // 0x0318(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x60];                                     // 0x0328(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _requestedInterruptionOtherParty;                  // 0x0388(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterruptionDefinition*                _requestedInterruptionDefinition;                  // 0x0390(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _requestedInterruptionIsInterruptor;               // 0x0398(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _currentInterruptionOtherParty;                    // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInterruptionDefinition*                _currentInterruptionDefinition;                    // 0x03A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _currentInterruptionIsInterruptor;                 // 0x03B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _interactionInProgress;                            // 0x03B1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B2[0x36];                                     // 0x03B2(0x0036)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInteractionDefinition*>         _interactionsInZone;                               // 0x03E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x28];                                     // 0x03F8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAvailableInteractionCalculator        _availableInteractionCalculator;                   // 0x0420(0x01C0)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E0[0x18];                                     // 0x05E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UObject*, struct FGameplayTagContainer> _disableInteractionSourcesToExceptions;       // 0x05F8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddInteraction(class UInteractionDefinition* interaction);
	void AddSelfInteractions(const class AActor* interactionRoot);
	void Authority_ClearPlayerDependencies();
	void Authority_ClearPlayerDependency(class ADBDPlayer* playerDependency);
	void Authority_TriggerCustomSkillCheck(const ESkillCheckCustomType type, float warningSoundDelay);
	void Broadcast_Multicast_ConfirmChargedCompleted(bool chargeComplete);
	void CleanInteractionArray(class AActor* DestroyedActor);
	void Client_Cheat_SetInteractionScanInterval(float interval);
	void Client_NotifyChargeCompleted(const class UInteractionDefinition* interaction);
	void Client_StopSkillCheck();
	bool HasAvailableInteraction(EInputInteractionType interactionType);
	void IncrementSuccessiveSkillCheckCount();
	void Multicast_CancelCurrentInteractionByInput();
	void Multicast_InteractionPredictionValidationResult(class UInteractionDefinition* interaction, EInteractionValidationState state);
	void Multicast_InterruptionRequestResult_Interruptor(ERequestState state, bool grantInterruptScore);
	void Multicast_RequestInterruption_Interruptee(class ADBDPlayer* interruptionOtherParty, class UInterruptionDefinition* interruptionDefinition);
	void Multicast_SetInteractionToSwapTo(class UInteractionDefinition* interaction);
	void Multicast_StoreInteraction(const struct FStoredInteraction& interactionToStore);
	void Multicast_StoreInterruption_Interruptor(class ADBDPlayer* interruptionOtherParty, class UInterruptionDefinition* interruptionDefinition);
	void OnAttachedInteractorOwnerEndPlay(class AActor* actor, EEndPlayReason endPlayReason);
	void PauseSkillCheckTimer();
	void RemoveInteraction(class UInteractionDefinition* interaction);
	void ResetSuccessiveSkillCheckCount();
	void Server_AnswerInterruption_Interruptee(ERequestState state);
	void Server_Broadcast_ConfirmChargedCompleted(bool chargeComplete);
	void Server_Broadcast_StoreInteraction(const struct FStoredInteraction& interactionToStore);
	void Server_CancelCurrentInteractionByInput();
	void Server_Cheat_SetInteractionScanInterval(float interval);
	void Server_DebugRequestInteraction(const class FString& interactionName, const class FString& interactorName, const class FString& interactableName);
	void Server_RequestInterruption_Interruptor();
	void Server_SetInteractionToSwapTo(class UInteractionDefinition* interaction);
	void Server_StoreInterruption_Interruptor(class ADBDPlayer* interruptionOtherParty, class UInterruptionDefinition* interruptionDefinition);
	void SetScanForInteractionsEnabled(bool enabled);
	void UnPauseSkillCheckTimer();

	bool CanPerformInteraction(const class FString& interactionName) const;
	float GetAdditiveSkillCheckProbabilityModifier() const;
	class UInteractionDefinition* GetAvailableInteraction(EInputInteractionType interactionType) const;
	class UInteractionDefinition* GetAvailableInteractionByID(const class FString& interactionID) const;
	void GetAvailableInteractions(TArray<class UInteractionDefinition*>* result) const;
	class UInteractionDefinition* GetCurrentInteraction() const;
	class UInteractionDefinition* GetCurrentInteractionOfType(EInputInteractionType interactionInputType) const;
	float GetMultiplicativeSkillCheckProbabilityModifier() const;
	class USkillCheck* GetSkillCheck() const;
	bool HasActiveSkillCheck() const;
	int32 NumInteractionsInZone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInteractionHandler">();
	}
	static class UPlayerInteractionHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInteractionHandler>();
	}
};
static_assert(alignof(UPlayerInteractionHandler) == 0x000010, "Wrong alignment on UPlayerInteractionHandler");
static_assert(sizeof(UPlayerInteractionHandler) == 0x000650, "Wrong size on UPlayerInteractionHandler");
static_assert(offsetof(UPlayerInteractionHandler, PriorityConeAngle) == 0x000120, "Member 'UPlayerInteractionHandler::PriorityConeAngle' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, BotPriorityConeAngle) == 0x000124, "Member 'UPlayerInteractionHandler::BotPriorityConeAngle' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, Authority_SecondaryActionDoneDelegate) == 0x000138, "Member 'UPlayerInteractionHandler::Authority_SecondaryActionDoneDelegate' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, NewInteractionRequestedDelegate) == 0x000148, "Member 'UPlayerInteractionHandler::NewInteractionRequestedDelegate' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, ServerValidatedInteractionStartedDelegate) == 0x000158, "Member 'UPlayerInteractionHandler::ServerValidatedInteractionStartedDelegate' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, ServerValidatedInteractionEndedDelegate) == 0x000168, "Member 'UPlayerInteractionHandler::ServerValidatedInteractionEndedDelegate' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, InteractionLayer) == 0x000178, "Member 'UPlayerInteractionHandler::InteractionLayer' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, OnDeactivateSkillCheckDelegate) == 0x000188, "Member 'UPlayerInteractionHandler::OnDeactivateSkillCheckDelegate' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _hasInteractionRequest) == 0x000200, "Member 'UPlayerInteractionHandler::_hasInteractionRequest' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _hasInteractionRequestInBuffer) == 0x000201, "Member 'UPlayerInteractionHandler::_hasInteractionRequestInBuffer' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _interactionToSwapTo) == 0x000220, "Member 'UPlayerInteractionHandler::_interactionToSwapTo' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentInteraction) == 0x000248, "Member 'UPlayerInteractionHandler::_currentInteraction' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentPlayerDependencies) == 0x0002F0, "Member 'UPlayerInteractionHandler::_currentPlayerDependencies' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentInteractionType) == 0x000300, "Member 'UPlayerInteractionHandler::_currentInteractionType' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _skillCheck) == 0x000308, "Member 'UPlayerInteractionHandler::_skillCheck' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _progressBasedSkillChecks) == 0x000318, "Member 'UPlayerInteractionHandler::_progressBasedSkillChecks' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _requestedInterruptionOtherParty) == 0x000388, "Member 'UPlayerInteractionHandler::_requestedInterruptionOtherParty' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _requestedInterruptionDefinition) == 0x000390, "Member 'UPlayerInteractionHandler::_requestedInterruptionDefinition' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _requestedInterruptionIsInterruptor) == 0x000398, "Member 'UPlayerInteractionHandler::_requestedInterruptionIsInterruptor' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentInterruptionOtherParty) == 0x0003A0, "Member 'UPlayerInteractionHandler::_currentInterruptionOtherParty' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentInterruptionDefinition) == 0x0003A8, "Member 'UPlayerInteractionHandler::_currentInterruptionDefinition' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _currentInterruptionIsInterruptor) == 0x0003B0, "Member 'UPlayerInteractionHandler::_currentInterruptionIsInterruptor' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _interactionInProgress) == 0x0003B1, "Member 'UPlayerInteractionHandler::_interactionInProgress' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _interactionsInZone) == 0x0003E8, "Member 'UPlayerInteractionHandler::_interactionsInZone' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _availableInteractionCalculator) == 0x000420, "Member 'UPlayerInteractionHandler::_availableInteractionCalculator' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionHandler, _disableInteractionSourcesToExceptions) == 0x0005F8, "Member 'UPlayerInteractionHandler::_disableInteractionSourcesToExceptions' has a wrong offset!");

// Class DeadByDaylight.PlayerLevelTooltipWidget
// 0x0008 (0x0378 - 0x0370)
class UPlayerLevelTooltipWidget final : public UBaseTooltipWidget
{
public:
	class UUMGTooltipContentPlayerLevelWidget*    PlayerLevelContent;                                // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerLevelTooltipWidget">();
	}
	static class UPlayerLevelTooltipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerLevelTooltipWidget>();
	}
};
static_assert(alignof(UPlayerLevelTooltipWidget) == 0x000008, "Wrong alignment on UPlayerLevelTooltipWidget");
static_assert(sizeof(UPlayerLevelTooltipWidget) == 0x000378, "Wrong size on UPlayerLevelTooltipWidget");
static_assert(offsetof(UPlayerLevelTooltipWidget, PlayerLevelContent) == 0x000370, "Member 'UPlayerLevelTooltipWidget::PlayerLevelContent' has a wrong offset!");

// Class DeadByDaylight.PlayerMoveBackAndForthComponent
// 0x0048 (0x0100 - 0x00B8)
class UPlayerMoveBackAndForthComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x48];                                      // 0x00B8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMoveTimerDone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMoveBackAndForthComponent">();
	}
	static class UPlayerMoveBackAndForthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerMoveBackAndForthComponent>();
	}
};
static_assert(alignof(UPlayerMoveBackAndForthComponent) == 0x000008, "Wrong alignment on UPlayerMoveBackAndForthComponent");
static_assert(sizeof(UPlayerMoveBackAndForthComponent) == 0x000100, "Wrong size on UPlayerMoveBackAndForthComponent");

// Class DeadByDaylight.SpherePlayerOverlapComponent
// 0x0000 (0x04A0 - 0x04A0)
class USpherePlayerOverlapComponent final : public USphereComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpherePlayerOverlapComponent">();
	}
	static class USpherePlayerOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpherePlayerOverlapComponent>();
	}
};
static_assert(alignof(USpherePlayerOverlapComponent) == 0x000010, "Wrong alignment on USpherePlayerOverlapComponent");
static_assert(sizeof(USpherePlayerOverlapComponent) == 0x0004A0, "Wrong size on USpherePlayerOverlapComponent");

// Class DeadByDaylight.BoxPlayerOverlapComponent
// 0x0000 (0x04B0 - 0x04B0)
class UBoxPlayerOverlapComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoxPlayerOverlapComponent">();
	}
	static class UBoxPlayerOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoxPlayerOverlapComponent>();
	}
};
static_assert(alignof(UBoxPlayerOverlapComponent) == 0x000010, "Wrong alignment on UBoxPlayerOverlapComponent");
static_assert(sizeof(UBoxPlayerOverlapComponent) == 0x0004B0, "Wrong size on UBoxPlayerOverlapComponent");

// Class DeadByDaylight.PlayerPerspectiveComponent
// 0x0078 (0x0130 - 0x00B8)
class UPlayerPerspectiveComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x78];                                      // 0x00B8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPawnControllerChanged(class APawn* pawn, class AController* oldController, class AController* newController);
	void UpdateLocallyObserved();

	bool IsLocallyObserved() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerPerspectiveComponent">();
	}
	static class UPlayerPerspectiveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerPerspectiveComponent>();
	}
};
static_assert(alignof(UPlayerPerspectiveComponent) == 0x000008, "Wrong alignment on UPlayerPerspectiveComponent");
static_assert(sizeof(UPlayerPerspectiveComponent) == 0x000130, "Wrong size on UPlayerPerspectiveComponent");

// Class DeadByDaylight.PlayerReportManager
// 0x0060 (0x0098 - 0x0038)
class UPlayerReportManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x50];                                      // 0x0048(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerReportManager">();
	}
	static class UPlayerReportManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerReportManager>();
	}
};
static_assert(alignof(UPlayerReportManager) == 0x000008, "Wrong alignment on UPlayerReportManager");
static_assert(sizeof(UPlayerReportManager) == 0x000098, "Wrong size on UPlayerReportManager");
static_assert(offsetof(UPlayerReportManager, _gameInstance) == 0x000040, "Member 'UPlayerReportManager::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.PlayerScoreEmitter
// 0x0008 (0x0038 - 0x0030)
class UPlayerScoreEmitter : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerScoreEmitter">();
	}
	static class UPlayerScoreEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerScoreEmitter>();
	}
};
static_assert(alignof(UPlayerScoreEmitter) == 0x000008, "Wrong alignment on UPlayerScoreEmitter");
static_assert(sizeof(UPlayerScoreEmitter) == 0x000038, "Wrong size on UPlayerScoreEmitter");

// Class DeadByDaylight.UMGStatusEffectsWidget
// 0x0090 (0x03C8 - 0x0338)
class UUMGStatusEffectsWidget final : public UMobileBaseUserWidget
{
public:
	TSoftClassPtr<class UClass>                   AtlantaStatusEffectIconClass;                      // 0x0338(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         StatusEffectsBox;                                  // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UUMGStatusEffectIcon*> _statusEffectsMap;                                // 0x0370(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x8];                                      // 0x03C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RemoveExistingStatusEffect(const class FString& statusEffectID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGStatusEffectsWidget">();
	}
	static class UUMGStatusEffectsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGStatusEffectsWidget>();
	}
};
static_assert(alignof(UUMGStatusEffectsWidget) == 0x000008, "Wrong alignment on UUMGStatusEffectsWidget");
static_assert(sizeof(UUMGStatusEffectsWidget) == 0x0003C8, "Wrong size on UUMGStatusEffectsWidget");
static_assert(offsetof(UUMGStatusEffectsWidget, AtlantaStatusEffectIconClass) == 0x000338, "Member 'UUMGStatusEffectsWidget::AtlantaStatusEffectIconClass' has a wrong offset!");
static_assert(offsetof(UUMGStatusEffectsWidget, StatusEffectsBox) == 0x000368, "Member 'UUMGStatusEffectsWidget::StatusEffectsBox' has a wrong offset!");
static_assert(offsetof(UUMGStatusEffectsWidget, _statusEffectsMap) == 0x000370, "Member 'UUMGStatusEffectsWidget::_statusEffectsMap' has a wrong offset!");

// Class DeadByDaylight.PlayerSkeletalMeshComponentBudgeted
// 0x0000 (0x1000 - 0x1000)
class UPlayerSkeletalMeshComponentBudgeted final : public UDBDSkeletalMeshComponentBudgeted
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerSkeletalMeshComponentBudgeted">();
	}
	static class UPlayerSkeletalMeshComponentBudgeted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerSkeletalMeshComponentBudgeted>();
	}
};
static_assert(alignof(UPlayerSkeletalMeshComponentBudgeted) == 0x000010, "Wrong alignment on UPlayerSkeletalMeshComponentBudgeted");
static_assert(sizeof(UPlayerSkeletalMeshComponentBudgeted) == 0x001000, "Wrong size on UPlayerSkeletalMeshComponentBudgeted");

// Class DeadByDaylight.PlayerStateScoreEmitter
// 0x00B0 (0x00E8 - 0x0038)
class UPlayerStateScoreEmitter final : public UPlayerScoreEmitter
{
public:
	struct FGameplayTag                           _scoreTag;                                         // 0x0038(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _scoreUpdateInterval;                              // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagQuery                      _tagQuery;                                         // 0x0048(0x0048)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x58];                                      // 0x0090(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateScoreEmitter">();
	}
	static class UPlayerStateScoreEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStateScoreEmitter>();
	}
};
static_assert(alignof(UPlayerStateScoreEmitter) == 0x000008, "Wrong alignment on UPlayerStateScoreEmitter");
static_assert(sizeof(UPlayerStateScoreEmitter) == 0x0000E8, "Wrong size on UPlayerStateScoreEmitter");
static_assert(offsetof(UPlayerStateScoreEmitter, _scoreTag) == 0x000038, "Member 'UPlayerStateScoreEmitter::_scoreTag' has a wrong offset!");
static_assert(offsetof(UPlayerStateScoreEmitter, _scoreUpdateInterval) == 0x000044, "Member 'UPlayerStateScoreEmitter::_scoreUpdateInterval' has a wrong offset!");
static_assert(offsetof(UPlayerStateScoreEmitter, _tagQuery) == 0x000048, "Member 'UPlayerStateScoreEmitter::_tagQuery' has a wrong offset!");

// Class DeadByDaylight.PoolableProjectileComponent
// 0x0000 (0x00D8 - 0x00D8)
class UPoolableProjectileComponent final : public UAuthoritativePoolableActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolableProjectileComponent">();
	}
	static class UPoolableProjectileComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoolableProjectileComponent>();
	}
};
static_assert(alignof(UPoolableProjectileComponent) == 0x000008, "Wrong alignment on UPoolableProjectileComponent");
static_assert(sizeof(UPoolableProjectileComponent) == 0x0000D8, "Wrong size on UPoolableProjectileComponent");

// Class DeadByDaylight.PopupSequencer
// 0x0030 (0x0060 - 0x0030)
class alignas(0x10) UPopupSequencer final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDBDGameInstance*                       _gameInstance;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PopupSequencer">();
	}
	static class UPopupSequencer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopupSequencer>();
	}
};
static_assert(alignof(UPopupSequencer) == 0x000010, "Wrong alignment on UPopupSequencer");
static_assert(sizeof(UPopupSequencer) == 0x000060, "Wrong size on UPopupSequencer");
static_assert(offsetof(UPopupSequencer, _gameInstance) == 0x000038, "Member 'UPopupSequencer::_gameInstance' has a wrong offset!");

// Class DeadByDaylight.UMGSwitcherScreen
// 0x00B0 (0x03E8 - 0x0338)
class UUMGSwitcherScreen final : public UMobileBaseUserWidget
{
public:
	TMulticastInlineDelegate<void(int32 slotID)>  OnLoadoutWidgetSlotClicked;                        // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 itemIndex)> OnLoadoutWidgetInventoryItemSelected;            // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 itemIndex)> OnLoadoutWidgetInventoryItemUnselected;          // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_368[0x60];                                     // 0x0368(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSwitcher*                        ContainerWidgetSwitcher;                           // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBloodStoreWidget*                   BloodStoreWidget;                                  // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGLoadoutWidget*                      LoadoutWidget;                                     // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGCharacterSelectionWidget*           CharacterSelectionWidget;                          // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BroadcastBloodNodePurchase(int32 characterId);
	void BroadcastBloodNodeSelected(int32 characterId, int32 nodeId, int32 nodeDepth);
	void BroadcastBloodStoreRegenerate(int32 characterId);
	void BroadcastCharacterInfoButtonClickedEvent();
	void BroadcastCharacterRoleButtonClickedEvent();
	void BroadcastCharacterSelectedEvent(int32 characterIndex);
	void BroadcastItemSelectedEvent(int32 itemIndex);
	void BroadcastItemUnSelectedEvent(int32 itemIndex);
	void BroadcastSlotClickedEvent(int32 loadoutSlot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSwitcherScreen">();
	}
	static class UUMGSwitcherScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSwitcherScreen>();
	}
};
static_assert(alignof(UUMGSwitcherScreen) == 0x000008, "Wrong alignment on UUMGSwitcherScreen");
static_assert(sizeof(UUMGSwitcherScreen) == 0x0003E8, "Wrong size on UUMGSwitcherScreen");
static_assert(offsetof(UUMGSwitcherScreen, OnLoadoutWidgetSlotClicked) == 0x000338, "Member 'UUMGSwitcherScreen::OnLoadoutWidgetSlotClicked' has a wrong offset!");
static_assert(offsetof(UUMGSwitcherScreen, OnLoadoutWidgetInventoryItemSelected) == 0x000348, "Member 'UUMGSwitcherScreen::OnLoadoutWidgetInventoryItemSelected' has a wrong offset!");
static_assert(offsetof(UUMGSwitcherScreen, OnLoadoutWidgetInventoryItemUnselected) == 0x000358, "Member 'UUMGSwitcherScreen::OnLoadoutWidgetInventoryItemUnselected' has a wrong offset!");
static_assert(offsetof(UUMGSwitcherScreen, ContainerWidgetSwitcher) == 0x0003C8, "Member 'UUMGSwitcherScreen::ContainerWidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UUMGSwitcherScreen, BloodStoreWidget) == 0x0003D0, "Member 'UUMGSwitcherScreen::BloodStoreWidget' has a wrong offset!");
static_assert(offsetof(UUMGSwitcherScreen, LoadoutWidget) == 0x0003D8, "Member 'UUMGSwitcherScreen::LoadoutWidget' has a wrong offset!");
static_assert(offsetof(UUMGSwitcherScreen, CharacterSelectionWidget) == 0x0003E0, "Member 'UUMGSwitcherScreen::CharacterSelectionWidget' has a wrong offset!");

// Class DeadByDaylight.PostProcessUpdate
// 0x0000 (0x0230 - 0x0230)
class APostProcessUpdate final : public AActor
{
public:
	void PostProcessToggle(bool toggle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PostProcessUpdate">();
	}
	static class APostProcessUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<APostProcessUpdate>();
	}
};
static_assert(alignof(APostProcessUpdate) == 0x000008, "Wrong alignment on APostProcessUpdate");
static_assert(sizeof(APostProcessUpdate) == 0x000230, "Wrong size on APostProcessUpdate");

// Class DeadByDaylight.PowerButton
// 0x0060 (0x0398 - 0x0338)
class UPowerButton final : public UMobileBaseUserWidget
{
public:
	class UActionButton*                          Button;                                            // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           SwitchIcon;                                        // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CountContainer;                                    // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           RadialProgressBarContainer;                        // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CountLabel;                                        // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TierImage;                                         // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           AddonsContainer;                                   // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGInventoryItemButton*                FirstAddonSlot;                                    // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGInventoryItemButton*                SecondAddonSlot;                                   // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           FillPowerChargeProgression;                        // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisabledOpacity;                                   // 0x0388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnabledOpacity;                                    // 0x038C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EnabledLongPressed;                                // 0x0390(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_391[0x3];                                      // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _itemCount;                                        // 0x0394(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UActionButton* GetActionButton();
	bool IsRadialProgressBarActive();
	void OnTierChanged(int32 previousTier, int32 currentTier, bool isFirstTime);
	void SetFillProgressPercentage(const float chargeProgressionPercentage);
	void SetPowerIntensityOpacity(float opacity);
	void SetRadialProgressBarActice(bool active);
	void SetRadialProgressPercentage(const float progression, ERadialProgressBarType progressBarType);
	void SetState(EActionButtonState state);
	void SetSwitchIconActive(bool active);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerButton">();
	}
	static class UPowerButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerButton>();
	}
};
static_assert(alignof(UPowerButton) == 0x000008, "Wrong alignment on UPowerButton");
static_assert(sizeof(UPowerButton) == 0x000398, "Wrong size on UPowerButton");
static_assert(offsetof(UPowerButton, Button) == 0x000338, "Member 'UPowerButton::Button' has a wrong offset!");
static_assert(offsetof(UPowerButton, SwitchIcon) == 0x000340, "Member 'UPowerButton::SwitchIcon' has a wrong offset!");
static_assert(offsetof(UPowerButton, CountContainer) == 0x000348, "Member 'UPowerButton::CountContainer' has a wrong offset!");
static_assert(offsetof(UPowerButton, RadialProgressBarContainer) == 0x000350, "Member 'UPowerButton::RadialProgressBarContainer' has a wrong offset!");
static_assert(offsetof(UPowerButton, CountLabel) == 0x000358, "Member 'UPowerButton::CountLabel' has a wrong offset!");
static_assert(offsetof(UPowerButton, TierImage) == 0x000360, "Member 'UPowerButton::TierImage' has a wrong offset!");
static_assert(offsetof(UPowerButton, AddonsContainer) == 0x000368, "Member 'UPowerButton::AddonsContainer' has a wrong offset!");
static_assert(offsetof(UPowerButton, FirstAddonSlot) == 0x000370, "Member 'UPowerButton::FirstAddonSlot' has a wrong offset!");
static_assert(offsetof(UPowerButton, SecondAddonSlot) == 0x000378, "Member 'UPowerButton::SecondAddonSlot' has a wrong offset!");
static_assert(offsetof(UPowerButton, FillPowerChargeProgression) == 0x000380, "Member 'UPowerButton::FillPowerChargeProgression' has a wrong offset!");
static_assert(offsetof(UPowerButton, DisabledOpacity) == 0x000388, "Member 'UPowerButton::DisabledOpacity' has a wrong offset!");
static_assert(offsetof(UPowerButton, EnabledOpacity) == 0x00038C, "Member 'UPowerButton::EnabledOpacity' has a wrong offset!");
static_assert(offsetof(UPowerButton, EnabledLongPressed) == 0x000390, "Member 'UPowerButton::EnabledLongPressed' has a wrong offset!");
static_assert(offsetof(UPowerButton, _itemCount) == 0x000394, "Member 'UPowerButton::_itemCount' has a wrong offset!");

// Class DeadByDaylight.PresentationPowerFadeComponent
// 0x0000 (0x00B8 - 0x00B8)
class UPresentationPowerFadeComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresentationPowerFadeComponent">();
	}
	static class UPresentationPowerFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresentationPowerFadeComponent>();
	}
};
static_assert(alignof(UPresentationPowerFadeComponent) == 0x000008, "Wrong alignment on UPresentationPowerFadeComponent");
static_assert(sizeof(UPresentationPowerFadeComponent) == 0x0000B8, "Wrong size on UPresentationPowerFadeComponent");

// Class DeadByDaylight.UMGTallyBonusVisualWidget
// 0x0058 (0x0390 - 0x0338)
class UUMGTallyBonusVisualWidget final : public UMobileBaseUserWidget
{
public:
	TMap<int32, TSoftObjectPtr<class UTexture2D>> MultiplierTextureMap;                              // 0x0338(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UImage*                                 MultiplierImage;                                   // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyBonusVisualWidget">();
	}
	static class UUMGTallyBonusVisualWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyBonusVisualWidget>();
	}
};
static_assert(alignof(UUMGTallyBonusVisualWidget) == 0x000008, "Wrong alignment on UUMGTallyBonusVisualWidget");
static_assert(sizeof(UUMGTallyBonusVisualWidget) == 0x000390, "Wrong size on UUMGTallyBonusVisualWidget");
static_assert(offsetof(UUMGTallyBonusVisualWidget, MultiplierTextureMap) == 0x000338, "Member 'UUMGTallyBonusVisualWidget::MultiplierTextureMap' has a wrong offset!");
static_assert(offsetof(UUMGTallyBonusVisualWidget, MultiplierImage) == 0x000388, "Member 'UUMGTallyBonusVisualWidget::MultiplierImage' has a wrong offset!");

// Class DeadByDaylight.PresetControllerSubsystem
// 0x0010 (0x0048 - 0x0038)
class UPresetControllerSubsystem final : public UGameInstanceSubsystem
{
public:
	class ULoadoutPresetController*               _loadoutController;                                // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCustomizationPresetController*         _customizationController;                          // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PresetControllerSubsystem">();
	}
	static class UPresetControllerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPresetControllerSubsystem>();
	}
};
static_assert(alignof(UPresetControllerSubsystem) == 0x000008, "Wrong alignment on UPresetControllerSubsystem");
static_assert(sizeof(UPresetControllerSubsystem) == 0x000048, "Wrong size on UPresetControllerSubsystem");
static_assert(offsetof(UPresetControllerSubsystem, _loadoutController) == 0x000038, "Member 'UPresetControllerSubsystem::_loadoutController' has a wrong offset!");
static_assert(offsetof(UPresetControllerSubsystem, _customizationController) == 0x000040, "Member 'UPresetControllerSubsystem::_customizationController' has a wrong offset!");

// Class DeadByDaylight.IterativeWeightAdjustmentStrategy
// 0x0000 (0x0030 - 0x0030)
class UIterativeWeightAdjustmentStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IterativeWeightAdjustmentStrategy">();
	}
	static class UIterativeWeightAdjustmentStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIterativeWeightAdjustmentStrategy>();
	}
};
static_assert(alignof(UIterativeWeightAdjustmentStrategy) == 0x000008, "Wrong alignment on UIterativeWeightAdjustmentStrategy");
static_assert(sizeof(UIterativeWeightAdjustmentStrategy) == 0x000030, "Wrong size on UIterativeWeightAdjustmentStrategy");

// Class DeadByDaylight.ProceduralLevelBuilder
// 0x0DE0 (0x1010 - 0x0230)
class AProceduralLevelBuilder : public AActor
{
public:
	uint8                                         Pad_230[0x20];                                     // 0x0230(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PathToMapDirectory;                                // 0x0250(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathToTilesDirectory;                              // 0x0260(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KillerMinProximityFromCamper;                      // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivorMinProximityFromOtherCamper;               // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProximityBetweenGenerators;                     // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProximityBetweenChests;                         // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProximityBetweenTotems;                         // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivorMinProximityFromGenerator;                 // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivorMinProximityFromTotem;                     // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurvivorMaxLineOfSightFromTotem;                   // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinProximityBetweenSpecialBehaviourItems;          // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecialBehaviourItemMinProximityFromSurvivor;      // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecialBehaviourItemMinProximityFromKiller;        // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPaperTileMap>              DebugMap;                                          // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ATile>>              DebugTiles;                                        // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         SmallMeatLockerMinProximityFromKillerLair;         // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FactorToAdjustToWhenOutOfProximity;                // 0x02BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FactorToAdjustToWhenInLineOfSight;                 // 0x02C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightAmplifier;                                   // 0x02C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightAmplifierActivationHeight;                   // 0x02C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralGenerationData*              ProceduralGenerationData;                          // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileWeightRateOfDecay;                             // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         QuadTileWeightRateOfDecay;                         // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 _tileClass;                                        // 0x02F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x1C0];                                    // 0x0300(0x01C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UMapData*                               _mapData;                                          // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioBank*                           _ambientAudioBank;                                 // 0x04C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObjectLibrary*                         _availableTilesLibrary;                            // 0x04D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D8[0xE8];                                     // 0x04D8(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectLibrary*                         _availableDerivedTileLibrary;                      // 0x05C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDBDDesignTunables>         DesignTunableClass;                                // 0x05D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDDesignTunables*                     _designTunables;                                   // 0x05D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGeneratedLevelData                    _generatedData;                                    // 0x05E0(0x0310)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8F0[0x310];                                    // 0x08F0(0x0310)(Fixing Size After Last Property [ Dumper-7 ])
	class UTileMatrix*                            _tileMatrix;                                       // 0x0C00(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTileBank*                              _tileBank;                                         // 0x0C08(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C10[0x68];                                     // 0x0C10(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorSpawner*                          _killerLairSpawner;                                // 0x0C78(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C80[0x8];                                      // 0x0C80(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                _preloadAssetReferences;                           // 0x0C88(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AActor>>             _chestItemAssetReferences;                         // 0x0C98(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UClass*                                 _slasherPawn;                                      // 0x0CA8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CB0[0x18];                                     // 0x0CB0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATile*>                          _tilesThatHaveBeenSpawned;                         // 0x0CC8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CD8[0x10];                                     // 0x0CD8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AProceduralLevelData*                   _debugProceduralDatas;                             // 0x0CE8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDClientSyncer*                       _syncer;                                           // 0x0CF0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlackboardComponent*                   _blackboardComp;                                   // 0x0CF8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D00[0x50];                                     // 0x0D00(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UEdgeObjectHandlingStrategy*            _edgeObjectHandlingStrategy;                       // 0x0D50(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D58[0x238];                                    // 0x0D58(0x0238)(Fixing Size After Last Property [ Dumper-7 ])
	class ATile*                                  _backupKillerLairTile;                             // 0x0F90(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F98[0x78];                                     // 0x0F98(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyMist(float modifier);
	void BuildFromSeed();
	void Multicast_DebugShareGenerationData(const struct FGenerationParams& usedParams);
	void RemoveMist();
	class AActor* SpawnActor(class UClass* actorClass, ETileSpawnPointType spawnPointType);
	void StartGenerationOnSyncerReady();
	void SyncSeeds();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralLevelBuilder">();
	}
	static class AProceduralLevelBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProceduralLevelBuilder>();
	}
};
static_assert(alignof(AProceduralLevelBuilder) == 0x000008, "Wrong alignment on AProceduralLevelBuilder");
static_assert(sizeof(AProceduralLevelBuilder) == 0x001010, "Wrong size on AProceduralLevelBuilder");
static_assert(offsetof(AProceduralLevelBuilder, PathToMapDirectory) == 0x000250, "Member 'AProceduralLevelBuilder::PathToMapDirectory' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, PathToTilesDirectory) == 0x000260, "Member 'AProceduralLevelBuilder::PathToTilesDirectory' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, KillerMinProximityFromCamper) == 0x000270, "Member 'AProceduralLevelBuilder::KillerMinProximityFromCamper' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SurvivorMinProximityFromOtherCamper) == 0x000274, "Member 'AProceduralLevelBuilder::SurvivorMinProximityFromOtherCamper' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, MinProximityBetweenGenerators) == 0x000278, "Member 'AProceduralLevelBuilder::MinProximityBetweenGenerators' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, MinProximityBetweenChests) == 0x00027C, "Member 'AProceduralLevelBuilder::MinProximityBetweenChests' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, MinProximityBetweenTotems) == 0x000280, "Member 'AProceduralLevelBuilder::MinProximityBetweenTotems' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SurvivorMinProximityFromGenerator) == 0x000284, "Member 'AProceduralLevelBuilder::SurvivorMinProximityFromGenerator' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SurvivorMinProximityFromTotem) == 0x000288, "Member 'AProceduralLevelBuilder::SurvivorMinProximityFromTotem' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SurvivorMaxLineOfSightFromTotem) == 0x00028C, "Member 'AProceduralLevelBuilder::SurvivorMaxLineOfSightFromTotem' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, MinProximityBetweenSpecialBehaviourItems) == 0x000290, "Member 'AProceduralLevelBuilder::MinProximityBetweenSpecialBehaviourItems' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SpecialBehaviourItemMinProximityFromSurvivor) == 0x000294, "Member 'AProceduralLevelBuilder::SpecialBehaviourItemMinProximityFromSurvivor' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SpecialBehaviourItemMinProximityFromKiller) == 0x000298, "Member 'AProceduralLevelBuilder::SpecialBehaviourItemMinProximityFromKiller' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, DebugMap) == 0x0002A0, "Member 'AProceduralLevelBuilder::DebugMap' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, DebugTiles) == 0x0002A8, "Member 'AProceduralLevelBuilder::DebugTiles' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, SmallMeatLockerMinProximityFromKillerLair) == 0x0002B8, "Member 'AProceduralLevelBuilder::SmallMeatLockerMinProximityFromKillerLair' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, FactorToAdjustToWhenOutOfProximity) == 0x0002BC, "Member 'AProceduralLevelBuilder::FactorToAdjustToWhenOutOfProximity' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, FactorToAdjustToWhenInLineOfSight) == 0x0002C0, "Member 'AProceduralLevelBuilder::FactorToAdjustToWhenInLineOfSight' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, HeightAmplifier) == 0x0002C4, "Member 'AProceduralLevelBuilder::HeightAmplifier' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, HeightAmplifierActivationHeight) == 0x0002C8, "Member 'AProceduralLevelBuilder::HeightAmplifierActivationHeight' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, ProceduralGenerationData) == 0x0002D0, "Member 'AProceduralLevelBuilder::ProceduralGenerationData' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, TileWeightRateOfDecay) == 0x0002D8, "Member 'AProceduralLevelBuilder::TileWeightRateOfDecay' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, QuadTileWeightRateOfDecay) == 0x0002DC, "Member 'AProceduralLevelBuilder::QuadTileWeightRateOfDecay' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _tileClass) == 0x0002F8, "Member 'AProceduralLevelBuilder::_tileClass' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _mapData) == 0x0004C0, "Member 'AProceduralLevelBuilder::_mapData' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _ambientAudioBank) == 0x0004C8, "Member 'AProceduralLevelBuilder::_ambientAudioBank' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _availableTilesLibrary) == 0x0004D0, "Member 'AProceduralLevelBuilder::_availableTilesLibrary' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _availableDerivedTileLibrary) == 0x0005C0, "Member 'AProceduralLevelBuilder::_availableDerivedTileLibrary' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, DesignTunableClass) == 0x0005D0, "Member 'AProceduralLevelBuilder::DesignTunableClass' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _designTunables) == 0x0005D8, "Member 'AProceduralLevelBuilder::_designTunables' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _generatedData) == 0x0005E0, "Member 'AProceduralLevelBuilder::_generatedData' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _tileMatrix) == 0x000C00, "Member 'AProceduralLevelBuilder::_tileMatrix' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _tileBank) == 0x000C08, "Member 'AProceduralLevelBuilder::_tileBank' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _killerLairSpawner) == 0x000C78, "Member 'AProceduralLevelBuilder::_killerLairSpawner' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _preloadAssetReferences) == 0x000C88, "Member 'AProceduralLevelBuilder::_preloadAssetReferences' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _chestItemAssetReferences) == 0x000C98, "Member 'AProceduralLevelBuilder::_chestItemAssetReferences' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _slasherPawn) == 0x000CA8, "Member 'AProceduralLevelBuilder::_slasherPawn' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _tilesThatHaveBeenSpawned) == 0x000CC8, "Member 'AProceduralLevelBuilder::_tilesThatHaveBeenSpawned' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _debugProceduralDatas) == 0x000CE8, "Member 'AProceduralLevelBuilder::_debugProceduralDatas' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _syncer) == 0x000CF0, "Member 'AProceduralLevelBuilder::_syncer' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _blackboardComp) == 0x000CF8, "Member 'AProceduralLevelBuilder::_blackboardComp' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _edgeObjectHandlingStrategy) == 0x000D50, "Member 'AProceduralLevelBuilder::_edgeObjectHandlingStrategy' has a wrong offset!");
static_assert(offsetof(AProceduralLevelBuilder, _backupKillerLairTile) == 0x000F90, "Member 'AProceduralLevelBuilder::_backupKillerLairTile' has a wrong offset!");

// Class DeadByDaylight.UMGObjectivesWidget
// 0x0008 (0x0340 - 0x0338)
class UUMGObjectivesWidget final : public UMobileBaseUserWidget
{
public:
	ESlateVisibility                              PanelEscapeRequirementsVisibility;                 // 0x0338(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              PanelGeneratorVisibility;                          // 0x0339(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              PanelFindExitVisibility;                           // 0x033A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              PanelHatchVisibility;                              // 0x033B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateGeneratorCount(int32 count);
	void UpdateTextMessage(const class FText& textFind, const class FText& textExit, const class FText& textOr);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGObjectivesWidget">();
	}
	static class UUMGObjectivesWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGObjectivesWidget>();
	}
};
static_assert(alignof(UUMGObjectivesWidget) == 0x000008, "Wrong alignment on UUMGObjectivesWidget");
static_assert(sizeof(UUMGObjectivesWidget) == 0x000340, "Wrong size on UUMGObjectivesWidget");
static_assert(offsetof(UUMGObjectivesWidget, PanelEscapeRequirementsVisibility) == 0x000338, "Member 'UUMGObjectivesWidget::PanelEscapeRequirementsVisibility' has a wrong offset!");
static_assert(offsetof(UUMGObjectivesWidget, PanelGeneratorVisibility) == 0x000339, "Member 'UUMGObjectivesWidget::PanelGeneratorVisibility' has a wrong offset!");
static_assert(offsetof(UUMGObjectivesWidget, PanelFindExitVisibility) == 0x00033A, "Member 'UUMGObjectivesWidget::PanelFindExitVisibility' has a wrong offset!");
static_assert(offsetof(UUMGObjectivesWidget, PanelHatchVisibility) == 0x00033B, "Member 'UUMGObjectivesWidget::PanelHatchVisibility' has a wrong offset!");

// Class DeadByDaylight.ProceduralLevelData
// 0x0388 (0x05B8 - 0x0230)
class AProceduralLevelData final : public AActor
{
public:
	TSoftObjectPtr<class UPaperTileMap>           SelectedPaperMap;                                  // 0x0230(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GenerationSeed;                                    // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKillerMoodInfluence                          LevelMood;                                         // 0x0264(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_265[0x3];                                      // 0x0265(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGeneratedLevelData                    GeneratedData;                                     // 0x0268(0x0310)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class FName>                           Offerings;                                         // 0x0578(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         PerksLevel;                                        // 0x0588(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58C[0x4];                                      // 0x058C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Perks;                                             // 0x0590(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          SkipGameplayElementGeneration;                     // 0x05A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A1[0x7];                                      // 0x05A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _builder;                                          // 0x05A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _builderClassDef;                                  // 0x05B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralLevelData">();
	}
	static class AProceduralLevelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProceduralLevelData>();
	}
};
static_assert(alignof(AProceduralLevelData) == 0x000008, "Wrong alignment on AProceduralLevelData");
static_assert(sizeof(AProceduralLevelData) == 0x0005B8, "Wrong size on AProceduralLevelData");
static_assert(offsetof(AProceduralLevelData, SelectedPaperMap) == 0x000230, "Member 'AProceduralLevelData::SelectedPaperMap' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, GenerationSeed) == 0x000260, "Member 'AProceduralLevelData::GenerationSeed' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, LevelMood) == 0x000264, "Member 'AProceduralLevelData::LevelMood' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, GeneratedData) == 0x000268, "Member 'AProceduralLevelData::GeneratedData' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, Offerings) == 0x000578, "Member 'AProceduralLevelData::Offerings' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, PerksLevel) == 0x000588, "Member 'AProceduralLevelData::PerksLevel' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, Perks) == 0x000590, "Member 'AProceduralLevelData::Perks' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, SkipGameplayElementGeneration) == 0x0005A0, "Member 'AProceduralLevelData::SkipGameplayElementGeneration' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, _builder) == 0x0005A8, "Member 'AProceduralLevelData::_builder' has a wrong offset!");
static_assert(offsetof(AProceduralLevelData, _builderClassDef) == 0x0005B0, "Member 'AProceduralLevelData::_builderClassDef' has a wrong offset!");

// Class DeadByDaylight.ProcessingPopupScreen
// 0x0000 (0x0120 - 0x0120)
class UProcessingPopupScreen final : public UBasePopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProcessingPopupScreen">();
	}
	static class UProcessingPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProcessingPopupScreen>();
	}
};
static_assert(alignof(UProcessingPopupScreen) == 0x000008, "Wrong alignment on UProcessingPopupScreen");
static_assert(sizeof(UProcessingPopupScreen) == 0x000120, "Wrong size on UProcessingPopupScreen");

// Class DeadByDaylight.PromoCodeManager
// 0x0018 (0x0050 - 0x0038)
class UPromoCodeManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PromoCodeManager">();
	}
	static class UPromoCodeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPromoCodeManager>();
	}
};
static_assert(alignof(UPromoCodeManager) == 0x000008, "Wrong alignment on UPromoCodeManager");
static_assert(sizeof(UPromoCodeManager) == 0x000050, "Wrong size on UPromoCodeManager");

// Class DeadByDaylight.PromptManager
// 0x0048 (0x0078 - 0x0030)
class UPromptManager final : public UObject
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PromptManager">();
	}
	static class UPromptManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPromptManager>();
	}
};
static_assert(alignof(UPromptManager) == 0x000008, "Wrong alignment on UPromptManager");
static_assert(sizeof(UPromptManager) == 0x000078, "Wrong size on UPromptManager");

// Class DeadByDaylight.UMGPopupButton
// 0x0038 (0x04A0 - 0x0468)
class UUMGPopupButton final : public UUMGBaseButtonWidget
{
public:
	uint8                                         Pad_468[0x14];                                     // 0x0468(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisabledOpacity;                                   // 0x047C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnabledOpacity;                                    // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 VFXs;                                              // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Line;                                              // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FXSmoke;                                           // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnButtonClicked();
	void OnButtonPressed();
	void OnButtonReleased();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPopupButton">();
	}
	static class UUMGPopupButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPopupButton>();
	}
};
static_assert(alignof(UUMGPopupButton) == 0x000008, "Wrong alignment on UUMGPopupButton");
static_assert(sizeof(UUMGPopupButton) == 0x0004A0, "Wrong size on UUMGPopupButton");
static_assert(offsetof(UUMGPopupButton, DisabledOpacity) == 0x00047C, "Member 'UUMGPopupButton::DisabledOpacity' has a wrong offset!");
static_assert(offsetof(UUMGPopupButton, EnabledOpacity) == 0x000480, "Member 'UUMGPopupButton::EnabledOpacity' has a wrong offset!");
static_assert(offsetof(UUMGPopupButton, VFXs) == 0x000488, "Member 'UUMGPopupButton::VFXs' has a wrong offset!");
static_assert(offsetof(UUMGPopupButton, Line) == 0x000490, "Member 'UUMGPopupButton::Line' has a wrong offset!");
static_assert(offsetof(UUMGPopupButton, FXSmoke) == 0x000498, "Member 'UUMGPopupButton::FXSmoke' has a wrong offset!");

// Class DeadByDaylight.ProtectionHitComponent
// 0x0070 (0x0128 - 0x00B8)
class UProtectionHitComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACamperPlayer*>                  _nearbyInjuredSurvivors;                           // 0x0108(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_HandleProtectionScoringEvents();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProtectionHitComponent">();
	}
	static class UProtectionHitComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProtectionHitComponent>();
	}
};
static_assert(alignof(UProtectionHitComponent) == 0x000008, "Wrong alignment on UProtectionHitComponent");
static_assert(sizeof(UProtectionHitComponent) == 0x000128, "Wrong size on UProtectionHitComponent");
static_assert(offsetof(UProtectionHitComponent, _nearbyInjuredSurvivors) == 0x000108, "Member 'UProtectionHitComponent::_nearbyInjuredSurvivors' has a wrong offset!");

// Class DeadByDaylight.PS4ProfileDAL
// 0x0000 (0x0088 - 0x0088)
class UPS4ProfileDAL final : public UPS4GRDKBaseProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PS4ProfileDAL">();
	}
	static class UPS4ProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPS4ProfileDAL>();
	}
};
static_assert(alignof(UPS4ProfileDAL) == 0x000008, "Wrong alignment on UPS4ProfileDAL");
static_assert(sizeof(UPS4ProfileDAL) == 0x000088, "Wrong size on UPS4ProfileDAL");

// Class DeadByDaylight.PurpleGlyphBloodTrailComponent
// 0x0010 (0x0250 - 0x0240)
class UPurpleGlyphBloodTrailComponent final : public UBloodTrailComponent
{
public:
	uint8                                         Pad_240[0x10];                                     // 0x0240(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeactivateGlyphBloodTrail();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PurpleGlyphBloodTrailComponent">();
	}
	static class UPurpleGlyphBloodTrailComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPurpleGlyphBloodTrailComponent>();
	}
};
static_assert(alignof(UPurpleGlyphBloodTrailComponent) == 0x000010, "Wrong alignment on UPurpleGlyphBloodTrailComponent");
static_assert(sizeof(UPurpleGlyphBloodTrailComponent) == 0x000250, "Wrong size on UPurpleGlyphBloodTrailComponent");

// Class DeadByDaylight.RBTOutlineUpdateStrategy
// 0x0000 (0x00E0 - 0x00E0)
class URBTOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	bool IsRevealedToLocalPlayer_BP(const class ADBDPlayer* player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RBTOutlineUpdateStrategy">();
	}
	static class URBTOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URBTOutlineUpdateStrategy>();
	}
};
static_assert(alignof(URBTOutlineUpdateStrategy) == 0x000008, "Wrong alignment on URBTOutlineUpdateStrategy");
static_assert(sizeof(URBTOutlineUpdateStrategy) == 0x0000E0, "Wrong size on URBTOutlineUpdateStrategy");

// Class DeadByDaylight.RecommendationsGenerator
// 0x0090 (0x00C0 - 0x0030)
class URecommendationsGenerator final : public UObject
{
public:
	TWeakObjectPtr<class UShopManager>            _shopManager;                                      // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FString, class URecommendationsFilter*> _filters;                                     // 0x0040(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x30];                                      // 0x0090(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecommendationsGenerator">();
	}
	static class URecommendationsGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecommendationsGenerator>();
	}
};
static_assert(alignof(URecommendationsGenerator) == 0x000008, "Wrong alignment on URecommendationsGenerator");
static_assert(sizeof(URecommendationsGenerator) == 0x0000C0, "Wrong size on URecommendationsGenerator");
static_assert(offsetof(URecommendationsGenerator, _shopManager) == 0x000030, "Member 'URecommendationsGenerator::_shopManager' has a wrong offset!");
static_assert(offsetof(URecommendationsGenerator, _gameInstance) == 0x000038, "Member 'URecommendationsGenerator::_gameInstance' has a wrong offset!");
static_assert(offsetof(URecommendationsGenerator, _filters) == 0x000040, "Member 'URecommendationsGenerator::_filters' has a wrong offset!");

// Class DeadByDaylight.RedStainComponent
// 0x0010 (0x0440 - 0x0430)
class URedStainComponent final : public USpotLightComponent
{
public:
	struct FLinearColor                           _initialSpotLightColor;                            // 0x0430(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DBD_HideRedStain(const bool hideStain);
	void UpdateRedStain(bool shouldBeHidden, const float alpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RedStainComponent">();
	}
	static class URedStainComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URedStainComponent>();
	}
};
static_assert(alignof(URedStainComponent) == 0x000010, "Wrong alignment on URedStainComponent");
static_assert(sizeof(URedStainComponent) == 0x000440, "Wrong size on URedStainComponent");
static_assert(offsetof(URedStainComponent, _initialSpotLightColor) == 0x000430, "Member 'URedStainComponent::_initialSpotLightColor' has a wrong offset!");

// Class DeadByDaylight.VomitStateComponent
// 0x0038 (0x00F0 - 0x00B8)
class UVomitStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isCharging;                                       // 0x00C0(0x0030)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetObjectState(class UGameplayTagContainerComponent* objectState);
	void SetVomitState(ELinkedVomitState newVomitState);

	ELinkedVomitState getVomitState() const;
	bool IsVomiting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VomitStateComponent">();
	}
	static class UVomitStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVomitStateComponent>();
	}
};
static_assert(alignof(UVomitStateComponent) == 0x000008, "Wrong alignment on UVomitStateComponent");
static_assert(sizeof(UVomitStateComponent) == 0x0000F0, "Wrong size on UVomitStateComponent");
static_assert(offsetof(UVomitStateComponent, _isCharging) == 0x0000C0, "Member 'UVomitStateComponent::_isCharging' has a wrong offset!");

// Class DeadByDaylight.RegionFinder
// 0x0078 (0x00A8 - 0x0030)
class URegionFinder : public UObject
{
public:
	TArray<struct FRegion>                        Regions;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Timeout;                                           // 0x0040(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x64];                                      // 0x0044(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RegionFinder">();
	}
	static class URegionFinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<URegionFinder>();
	}
};
static_assert(alignof(URegionFinder) == 0x000008, "Wrong alignment on URegionFinder");
static_assert(sizeof(URegionFinder) == 0x0000A8, "Wrong size on URegionFinder");
static_assert(offsetof(URegionFinder, Regions) == 0x000030, "Member 'URegionFinder::Regions' has a wrong offset!");
static_assert(offsetof(URegionFinder, Timeout) == 0x000040, "Member 'URegionFinder::Timeout' has a wrong offset!");

// Class DeadByDaylight.RenderingFeaturesSequencer
// 0x0048 (0x0078 - 0x0030)
class URenderingFeaturesSequencer final : public UObject
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDAggregateCullDistanceVolumes*       _aggregateCullDistanceVolumes;                     // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 _world;                                            // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RenderingFeaturesSequencer">();
	}
	static class URenderingFeaturesSequencer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URenderingFeaturesSequencer>();
	}
};
static_assert(alignof(URenderingFeaturesSequencer) == 0x000008, "Wrong alignment on URenderingFeaturesSequencer");
static_assert(sizeof(URenderingFeaturesSequencer) == 0x000078, "Wrong size on URenderingFeaturesSequencer");
static_assert(offsetof(URenderingFeaturesSequencer, _aggregateCullDistanceVolumes) == 0x000040, "Member 'URenderingFeaturesSequencer::_aggregateCullDistanceVolumes' has a wrong offset!");
static_assert(offsetof(URenderingFeaturesSequencer, _world) == 0x000048, "Member 'URenderingFeaturesSequencer::_world' has a wrong offset!");

// Class DeadByDaylight.RestrictedPlacementAreaDefaultStrategy
// 0x0008 (0x00A8 - 0x00A0)
class URestrictedPlacementAreaDefaultStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	TSubclassOf<class AActor>                     RestrictedActor;                                   // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RestrictedPlacementAreaDefaultStrategy">();
	}
	static class URestrictedPlacementAreaDefaultStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<URestrictedPlacementAreaDefaultStrategy>();
	}
};
static_assert(alignof(URestrictedPlacementAreaDefaultStrategy) == 0x000008, "Wrong alignment on URestrictedPlacementAreaDefaultStrategy");
static_assert(sizeof(URestrictedPlacementAreaDefaultStrategy) == 0x0000A8, "Wrong size on URestrictedPlacementAreaDefaultStrategy");
static_assert(offsetof(URestrictedPlacementAreaDefaultStrategy, RestrictedActor) == 0x0000A0, "Member 'URestrictedPlacementAreaDefaultStrategy::RestrictedActor' has a wrong offset!");

// Class DeadByDaylight.RewardTrackContainer
// 0x01D0 (0x0200 - 0x0030)
class URewardTrackContainer final : public UObject
{
public:
	uint8                                         Pad_30[0x1D0];                                     // 0x0030(0x01D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardTrackContainer">();
	}
	static class URewardTrackContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<URewardTrackContainer>();
	}
};
static_assert(alignof(URewardTrackContainer) == 0x000008, "Wrong alignment on URewardTrackContainer");
static_assert(sizeof(URewardTrackContainer) == 0x000200, "Wrong size on URewardTrackContainer");

// Class DeadByDaylight.RewardUtilities
// 0x0000 (0x0030 - 0x0030)
class URewardUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardUtilities">();
	}
	static class URewardUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<URewardUtilities>();
	}
};
static_assert(alignof(URewardUtilities) == 0x000008, "Wrong alignment on URewardUtilities");
static_assert(sizeof(URewardUtilities) == 0x000030, "Wrong size on URewardUtilities");

// Class DeadByDaylight.RitualsManager
// 0x0238 (0x0270 - 0x0038)
class URitualsManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x90];                                      // 0x0038(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDailyRitualContainer                  _cachedRitualContainer;                            // 0x00C8(0x0028)(NativeAccessSpecifierPrivate)
	struct FDailyRitualInstance                   _cachedDismissalReplacement;                       // 0x00F0(0x0078)(NativeAccessSpecifierPrivate)
	struct FDailyRitualInstance                   _cachedClaimedReplacement;                         // 0x0168(0x0078)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E0[0x70];                                     // 0x01E0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCoreRitualsContent                    _s3Content;                                        // 0x0250(0x0018)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RitualsManager">();
	}
	static class URitualsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<URitualsManager>();
	}
};
static_assert(alignof(URitualsManager) == 0x000008, "Wrong alignment on URitualsManager");
static_assert(sizeof(URitualsManager) == 0x000270, "Wrong size on URitualsManager");
static_assert(offsetof(URitualsManager, _cachedRitualContainer) == 0x0000C8, "Member 'URitualsManager::_cachedRitualContainer' has a wrong offset!");
static_assert(offsetof(URitualsManager, _cachedDismissalReplacement) == 0x0000F0, "Member 'URitualsManager::_cachedDismissalReplacement' has a wrong offset!");
static_assert(offsetof(URitualsManager, _cachedClaimedReplacement) == 0x000168, "Member 'URitualsManager::_cachedClaimedReplacement' has a wrong offset!");
static_assert(offsetof(URitualsManager, _s3Content) == 0x000250, "Member 'URitualsManager::_s3Content' has a wrong offset!");

// Class DeadByDaylight.RootMovie
// 0x0068 (0x0098 - 0x0030)
class URootMovie final : public UObject
{
public:
	class FString                                 SwfAssetName;                                      // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGFxMoviePlayer*                        SwfMoviePlayer;                                    // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UScreenController*                      m_ScreenController;                                // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUIController*                          m_UIController;                                    // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameInstance*                          m_GameInstance;                                    // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDInputManager*                       _inputManager;                                     // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x20];                                      // 0x0078(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCursorBlockingWidget(const class FString& id, float x, float y, float width, float height);
	void OnAssert(int32 type, const class FString& message);
	void OnFlashReady();
	void OnMovieClosed();
	void OnScreenEnter(const class FString& screenId);
	void OnScreenLeave(const class FString& screenId);
	void OnScreenReady(const class FString& screenId);
	void OpenLinkInBrowser(const class FString& linkAddress);
	void PlaySound(const class FString& soundId);
	void RegisterScreenControl(class UGFxObject* flashObj);
	void RegisterUIControl(class UGFxObject* flashObj);
	void RegisterView(const class FString& screenId, class UGFxObject* screenObject);
	void RemoveCursorBlockingWidget(const class FString& id);
	void SetCursorAsSticky(bool isSticky, bool lockVertical, bool lockHorizontal, float stickinessOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RootMovie">();
	}
	static class URootMovie* GetDefaultObj()
	{
		return GetDefaultObjImpl<URootMovie>();
	}
};
static_assert(alignof(URootMovie) == 0x000008, "Wrong alignment on URootMovie");
static_assert(sizeof(URootMovie) == 0x000098, "Wrong size on URootMovie");
static_assert(offsetof(URootMovie, SwfAssetName) == 0x000030, "Member 'URootMovie::SwfAssetName' has a wrong offset!");
static_assert(offsetof(URootMovie, SwfMoviePlayer) == 0x000040, "Member 'URootMovie::SwfMoviePlayer' has a wrong offset!");
static_assert(offsetof(URootMovie, m_ScreenController) == 0x000058, "Member 'URootMovie::m_ScreenController' has a wrong offset!");
static_assert(offsetof(URootMovie, m_UIController) == 0x000060, "Member 'URootMovie::m_UIController' has a wrong offset!");
static_assert(offsetof(URootMovie, m_GameInstance) == 0x000068, "Member 'URootMovie::m_GameInstance' has a wrong offset!");
static_assert(offsetof(URootMovie, _inputManager) == 0x000070, "Member 'URootMovie::_inputManager' has a wrong offset!");

// Class DeadByDaylight.RPCMonitor
// 0x0050 (0x0088 - 0x0038)
class URPCMonitor final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RPCMonitor">();
	}
	static class URPCMonitor* GetDefaultObj()
	{
		return GetDefaultObjImpl<URPCMonitor>();
	}
};
static_assert(alignof(URPCMonitor) == 0x000008, "Wrong alignment on URPCMonitor");
static_assert(sizeof(URPCMonitor) == 0x000088, "Wrong size on URPCMonitor");

// Class DeadByDaylight.S3GameConfigs
// 0x0310 (0x0348 - 0x0038)
class US3GameConfigs final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x310];                                     // 0x0038(0x0310)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S3GameConfigs">();
	}
	static class US3GameConfigs* GetDefaultObj()
	{
		return GetDefaultObjImpl<US3GameConfigs>();
	}
};
static_assert(alignof(US3GameConfigs) == 0x000008, "Wrong alignment on US3GameConfigs");
static_assert(sizeof(US3GameConfigs) == 0x000348, "Wrong size on US3GameConfigs");

// Class DeadByDaylight.SafeZoneManagerWidget
// 0x0008 (0x0340 - 0x0338)
class USafeZoneManagerWidget final : public UMobileBaseUserWidget
{
public:
	class UCanvasPanel*                           SafeZonePanel;                                     // 0x0338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SafeZoneManagerWidget">();
	}
	static class USafeZoneManagerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USafeZoneManagerWidget>();
	}
};
static_assert(alignof(USafeZoneManagerWidget) == 0x000008, "Wrong alignment on USafeZoneManagerWidget");
static_assert(sizeof(USafeZoneManagerWidget) == 0x000340, "Wrong size on USafeZoneManagerWidget");
static_assert(offsetof(USafeZoneManagerWidget, SafeZonePanel) == 0x000338, "Member 'USafeZoneManagerWidget::SafeZonePanel' has a wrong offset!");

// Class DeadByDaylight.ScourgeHookManagerComponent
// 0x00A0 (0x0158 - 0x00B8)
class UScourgeHookManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x90];                                      // 0x00B8(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AMeatHook>>       _scourgeHooks;                                     // 0x0148(0x0010)(Net, ZeroConstructor, Transient, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void OnRep_ScourgeHooks();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScourgeHookManagerComponent">();
	}
	static class UScourgeHookManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScourgeHookManagerComponent>();
	}
};
static_assert(alignof(UScourgeHookManagerComponent) == 0x000008, "Wrong alignment on UScourgeHookManagerComponent");
static_assert(sizeof(UScourgeHookManagerComponent) == 0x000158, "Wrong size on UScourgeHookManagerComponent");
static_assert(offsetof(UScourgeHookManagerComponent, _scourgeHooks) == 0x000148, "Member 'UScourgeHookManagerComponent::_scourgeHooks' has a wrong offset!");

// Class DeadByDaylight.ScreamComponent
// 0x0020 (0x00D8 - 0x00B8)
class UScreamComponent final : public UActorComponent
{
public:
	class UPerkManager*                           _perkManager;                                      // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMontagePlayer*                         _montagePlayer;                                    // 0x00C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _tagsPreventingScream;                             // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	void OnDamageStateChanged(ECamperDamageState oldDamageState, ECamperDamageState newDamageState);
	bool TriggerScreamEventsAndAndAnimationIfPossible(bool fireLoudNoiseEvent, const struct FMontagePlaybackDefinition& montageDefinition, float audibleRange);
	bool TriggerScreamEventsIfPossible(bool fireLoudNoiseEvent, float audibleRange);

	bool CanScream() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreamComponent">();
	}
	static class UScreamComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreamComponent>();
	}
};
static_assert(alignof(UScreamComponent) == 0x000008, "Wrong alignment on UScreamComponent");
static_assert(sizeof(UScreamComponent) == 0x0000D8, "Wrong size on UScreamComponent");
static_assert(offsetof(UScreamComponent, _perkManager) == 0x0000B8, "Member 'UScreamComponent::_perkManager' has a wrong offset!");
static_assert(offsetof(UScreamComponent, _montagePlayer) == 0x0000C0, "Member 'UScreamComponent::_montagePlayer' has a wrong offset!");
static_assert(offsetof(UScreamComponent, _tagsPreventingScream) == 0x0000C8, "Member 'UScreamComponent::_tagsPreventingScream' has a wrong offset!");

// Class DeadByDaylight.ScreenshotOniHook
// 0x0020 (0x0050 - 0x0030)
class UScreenshotOniHook final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OniId;                                             // 0x0038(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DemonModeTag;                                      // 0x0044(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotOniHook">();
	}
	static class UScreenshotOniHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotOniHook>();
	}
};
static_assert(alignof(UScreenshotOniHook) == 0x000008, "Wrong alignment on UScreenshotOniHook");
static_assert(sizeof(UScreenshotOniHook) == 0x000050, "Wrong size on UScreenshotOniHook");
static_assert(offsetof(UScreenshotOniHook, OniId) == 0x000038, "Member 'UScreenshotOniHook::OniId' has a wrong offset!");
static_assert(offsetof(UScreenshotOniHook, DemonModeTag) == 0x000044, "Member 'UScreenshotOniHook::DemonModeTag' has a wrong offset!");

// Class DeadByDaylight.ScreenshotPhysicsWeaponHook
// 0x0018 (0x0048 - 0x0030)
class UScreenshotPhysicsWeaponHook final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           KillersId;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotPhysicsWeaponHook">();
	}
	static class UScreenshotPhysicsWeaponHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotPhysicsWeaponHook>();
	}
};
static_assert(alignof(UScreenshotPhysicsWeaponHook) == 0x000008, "Wrong alignment on UScreenshotPhysicsWeaponHook");
static_assert(sizeof(UScreenshotPhysicsWeaponHook) == 0x000048, "Wrong size on UScreenshotPhysicsWeaponHook");
static_assert(offsetof(UScreenshotPhysicsWeaponHook, KillersId) == 0x000038, "Member 'UScreenshotPhysicsWeaponHook::KillersId' has a wrong offset!");

// Class DeadByDaylight.ScreenshotPreviewWidget
// 0x0000 (0x0298 - 0x0298)
class UScreenshotPreviewWidget final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotPreviewWidget">();
	}
	static class UScreenshotPreviewWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotPreviewWidget>();
	}
};
static_assert(alignof(UScreenshotPreviewWidget) == 0x000008, "Wrong alignment on UScreenshotPreviewWidget");
static_assert(sizeof(UScreenshotPreviewWidget) == 0x000298, "Wrong size on UScreenshotPreviewWidget");

// Class DeadByDaylight.ScreenshotSpiritHook
// 0x0058 (0x0088 - 0x0030)
class UScreenshotSpiritHook final : public UObject
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpiritId;                                          // 0x0038(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterial>               MaterialToFind;                                    // 0x0048(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MaterialFieldName;                                 // 0x0078(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaterialFieldValue;                                // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotSpiritHook">();
	}
	static class UScreenshotSpiritHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotSpiritHook>();
	}
};
static_assert(alignof(UScreenshotSpiritHook) == 0x000008, "Wrong alignment on UScreenshotSpiritHook");
static_assert(sizeof(UScreenshotSpiritHook) == 0x000088, "Wrong size on UScreenshotSpiritHook");
static_assert(offsetof(UScreenshotSpiritHook, SpiritId) == 0x000038, "Member 'UScreenshotSpiritHook::SpiritId' has a wrong offset!");
static_assert(offsetof(UScreenshotSpiritHook, MaterialToFind) == 0x000048, "Member 'UScreenshotSpiritHook::MaterialToFind' has a wrong offset!");
static_assert(offsetof(UScreenshotSpiritHook, MaterialFieldName) == 0x000078, "Member 'UScreenshotSpiritHook::MaterialFieldName' has a wrong offset!");
static_assert(offsetof(UScreenshotSpiritHook, MaterialFieldValue) == 0x000084, "Member 'UScreenshotSpiritHook::MaterialFieldValue' has a wrong offset!");

// Class DeadByDaylight.UMGCustomizationTooltipContentWidget
// 0x0030 (0x0368 - 0x0338)
class UUMGCustomizationTooltipContentWidget final : public UMobileBaseUserWidget
{
public:
	class UUMGHtmlRichText*                       ItemDescription;                                   // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGCustomizationInfoWidget*            OutfitInformation;                                 // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGCustomizationInfoWidget*            RoleInformation;                                   // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGCustomizationInfoWidget*            ReplacementInformation;                            // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGCustomizationItemPriceWidget*       AuricCellsPrice;                                   // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGCustomizationItemPriceWidget*       IridescentShardsPrice;                             // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCustomizationTooltipContentWidget">();
	}
	static class UUMGCustomizationTooltipContentWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCustomizationTooltipContentWidget>();
	}
};
static_assert(alignof(UUMGCustomizationTooltipContentWidget) == 0x000008, "Wrong alignment on UUMGCustomizationTooltipContentWidget");
static_assert(sizeof(UUMGCustomizationTooltipContentWidget) == 0x000368, "Wrong size on UUMGCustomizationTooltipContentWidget");
static_assert(offsetof(UUMGCustomizationTooltipContentWidget, ItemDescription) == 0x000338, "Member 'UUMGCustomizationTooltipContentWidget::ItemDescription' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationTooltipContentWidget, OutfitInformation) == 0x000340, "Member 'UUMGCustomizationTooltipContentWidget::OutfitInformation' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationTooltipContentWidget, RoleInformation) == 0x000348, "Member 'UUMGCustomizationTooltipContentWidget::RoleInformation' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationTooltipContentWidget, ReplacementInformation) == 0x000350, "Member 'UUMGCustomizationTooltipContentWidget::ReplacementInformation' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationTooltipContentWidget, AuricCellsPrice) == 0x000358, "Member 'UUMGCustomizationTooltipContentWidget::AuricCellsPrice' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationTooltipContentWidget, IridescentShardsPrice) == 0x000360, "Member 'UUMGCustomizationTooltipContentWidget::IridescentShardsPrice' has a wrong offset!");

// Class DeadByDaylight.ScreenshotToolDataAsset
// 0x01D0 (0x0208 - 0x0038)
class UScreenshotToolDataAsset final : public UDataAsset
{
public:
	struct FNamedButton                           ReloadDBButton;                                    // 0x0038(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 SurvivorHeadView;                                  // 0x0050(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 SurvivorTorsoView;                                 // 0x0078(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 SurvivorLegsView;                                  // 0x00A0(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 KillerHeadView;                                    // 0x00C8(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 KillerBodyView;                                    // 0x00F0(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 KillerWeaponView;                                  // 0x0118(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FGenderViewSetting>             GenderViewOverrides;                               // 0x0140(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterItemCategoryViewSetting> CharacterViewOverrides;                         // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FItemViewSetting>               ItemViewOverrides;                                 // 0x0160(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRoleGenderViewSetting>         OutfitView;                                        // 0x0170(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterViewSetting>          OutfitCharacterOverrides;                          // 0x0180(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRoleGenderViewSetting>         OutfitTwoPartsView;                                // 0x0190(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOutfitViewSetting>             OutfitOverrides;                                   // 0x01A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharacterAnimation>            AnimationOverrides;                                // 0x01B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FScreenshotViewSetting                 CharmsView;                                        // 0x01C0(0x0028)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FCharmCategorySetting>          CharmsCategoryOverrides;                           // 0x01E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCharmViewSetting>              CharmOverrides;                                    // 0x01F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotToolDataAsset">();
	}
	static class UScreenshotToolDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScreenshotToolDataAsset>();
	}
};
static_assert(alignof(UScreenshotToolDataAsset) == 0x000008, "Wrong alignment on UScreenshotToolDataAsset");
static_assert(sizeof(UScreenshotToolDataAsset) == 0x000208, "Wrong size on UScreenshotToolDataAsset");
static_assert(offsetof(UScreenshotToolDataAsset, ReloadDBButton) == 0x000038, "Member 'UScreenshotToolDataAsset::ReloadDBButton' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, SurvivorHeadView) == 0x000050, "Member 'UScreenshotToolDataAsset::SurvivorHeadView' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, SurvivorTorsoView) == 0x000078, "Member 'UScreenshotToolDataAsset::SurvivorTorsoView' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, SurvivorLegsView) == 0x0000A0, "Member 'UScreenshotToolDataAsset::SurvivorLegsView' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, KillerHeadView) == 0x0000C8, "Member 'UScreenshotToolDataAsset::KillerHeadView' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, KillerBodyView) == 0x0000F0, "Member 'UScreenshotToolDataAsset::KillerBodyView' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, KillerWeaponView) == 0x000118, "Member 'UScreenshotToolDataAsset::KillerWeaponView' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, GenderViewOverrides) == 0x000140, "Member 'UScreenshotToolDataAsset::GenderViewOverrides' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, CharacterViewOverrides) == 0x000150, "Member 'UScreenshotToolDataAsset::CharacterViewOverrides' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, ItemViewOverrides) == 0x000160, "Member 'UScreenshotToolDataAsset::ItemViewOverrides' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, OutfitView) == 0x000170, "Member 'UScreenshotToolDataAsset::OutfitView' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, OutfitCharacterOverrides) == 0x000180, "Member 'UScreenshotToolDataAsset::OutfitCharacterOverrides' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, OutfitTwoPartsView) == 0x000190, "Member 'UScreenshotToolDataAsset::OutfitTwoPartsView' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, OutfitOverrides) == 0x0001A0, "Member 'UScreenshotToolDataAsset::OutfitOverrides' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, AnimationOverrides) == 0x0001B0, "Member 'UScreenshotToolDataAsset::AnimationOverrides' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, CharmsView) == 0x0001C0, "Member 'UScreenshotToolDataAsset::CharmsView' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, CharmsCategoryOverrides) == 0x0001E8, "Member 'UScreenshotToolDataAsset::CharmsCategoryOverrides' has a wrong offset!");
static_assert(offsetof(UScreenshotToolDataAsset, CharmOverrides) == 0x0001F8, "Member 'UScreenshotToolDataAsset::CharmOverrides' has a wrong offset!");

// Class DeadByDaylight.ScreenshotToolHook
// 0x0000 (0x0000 - 0x0000)
class IScreenshotToolHook final
{
public:
	void PostBatchItems(const TArray<struct FCharacterToolItemData>& items);
	void PostHookConstruction();
	void PostSpawnCharacter(class ADBDMenuPlayer* character);
	void PostSpawnCharm(class ACharm* charm);
	void PostStateChanged(EScreenshotToolState previousState, EScreenshotToolState currentState);
	void PostTakeItemScreenshot(const struct FCharacterToolItemData& item, bool success);
	void PostUpdateCharacter(class ADBDMenuPlayer* character);
	void PreBatchItems();
	void PreDestroyCharacter(class ADBDMenuPlayer* character);
	void PreDestroyCharm(class ACharm* charm);
	void PreHookDestruction();
	void PreSpawnCharacter(const struct FCharacterDescription& description, struct FCharacterToolSpawnParameters* spawnParams);
	void PreSpawnCharm(const struct FCustomizationItemData& item);
	void PreTakeItemScreenshot(const struct FCharacterToolItemData& item);
	void ScreenshotBeginPlay(bool isPIE);

	bool IsPIEOnly() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScreenshotToolHook">();
	}
	static class IScreenshotToolHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<IScreenshotToolHook>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IScreenshotToolHook) == 0x000001, "Wrong alignment on IScreenshotToolHook");
static_assert(sizeof(IScreenshotToolHook) == 0x000001, "Wrong size on IScreenshotToolHook");

// Class DeadByDaylight.Searchable
// 0x00D0 (0x03F8 - 0x0328)
class ASearchable final : public AInteractable
{
public:
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemRarity                                   ItemRarity;                                        // 0x033C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33D[0x3];                                      // 0x033D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool searched)> OnSearchedChanged;                                 // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsSecret;                                          // 0x0350(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USearchableSpawnPoint*                  _searchableSpawnPoint;                             // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _itemIdToSpawn;                                    // 0x0360(0x000C)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasBeenSearched;                                  // 0x036C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_36D[0x3];                                      // 0x036D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ACollectable*                           _spawnedItem;                                      // 0x0370(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACollectable*                           _itemInsideSearchable;                             // 0x0378(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ADBDPlayer*, uint8>                _numberOfSearchesWhileOpenPerPlayer;               // 0x0380(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x28];                                     // 0x03D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ACollectable* Authority_SpawnObject(class ADBDPlayer* player);
	void SetHasBeenSearched(bool newHasBeenSearched);

	bool ContainsSpawnedItem() const;
	class UPrimitiveComponent* GetInteractorPrimitiveComponent() const;
	bool HasBeenSearched() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Searchable">();
	}
	static class ASearchable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASearchable>();
	}
};
static_assert(alignof(ASearchable) == 0x000008, "Wrong alignment on ASearchable");
static_assert(sizeof(ASearchable) == 0x0003F8, "Wrong size on ASearchable");
static_assert(offsetof(ASearchable, Weight) == 0x000338, "Member 'ASearchable::Weight' has a wrong offset!");
static_assert(offsetof(ASearchable, ItemRarity) == 0x00033C, "Member 'ASearchable::ItemRarity' has a wrong offset!");
static_assert(offsetof(ASearchable, OnSearchedChanged) == 0x000340, "Member 'ASearchable::OnSearchedChanged' has a wrong offset!");
static_assert(offsetof(ASearchable, IsSecret) == 0x000350, "Member 'ASearchable::IsSecret' has a wrong offset!");
static_assert(offsetof(ASearchable, _searchableSpawnPoint) == 0x000358, "Member 'ASearchable::_searchableSpawnPoint' has a wrong offset!");
static_assert(offsetof(ASearchable, _itemIdToSpawn) == 0x000360, "Member 'ASearchable::_itemIdToSpawn' has a wrong offset!");
static_assert(offsetof(ASearchable, _hasBeenSearched) == 0x00036C, "Member 'ASearchable::_hasBeenSearched' has a wrong offset!");
static_assert(offsetof(ASearchable, _spawnedItem) == 0x000370, "Member 'ASearchable::_spawnedItem' has a wrong offset!");
static_assert(offsetof(ASearchable, _itemInsideSearchable) == 0x000378, "Member 'ASearchable::_itemInsideSearchable' has a wrong offset!");
static_assert(offsetof(ASearchable, _numberOfSearchesWhileOpenPerPlayer) == 0x000380, "Member 'ASearchable::_numberOfSearchesWhileOpenPerPlayer' has a wrong offset!");

// Class DeadByDaylight.SearchableOutlineUpdateStrategy
// 0x0000 (0x0138 - 0x0138)
class USearchableOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchableOutlineUpdateStrategy">();
	}
	static class USearchableOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchableOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USearchableOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USearchableOutlineUpdateStrategy");
static_assert(sizeof(USearchableOutlineUpdateStrategy) == 0x000138, "Wrong size on USearchableOutlineUpdateStrategy");

// Class DeadByDaylight.TileSpawnPoint
// 0x0070 (0x0290 - 0x0220)
#pragma pack(push, 0x1)
class alignas(0x10) UTileSpawnPoint : public USceneComponent
{
public:
	uint8                                         Pad_218[0x10];                                     // 0x0218(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ETileSpawnPointType                           TileSpawnPointType;                                // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_229[0x3];                                      // 0x0229(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Weight;                                            // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Visualization;                                     // 0x0230(0x0030)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _spawnedObject;                                    // 0x0268(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AActor>>             ObjectSpawnModifier;                               // 0x0270(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         _spawnPriorityTier;                                // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _weightInfluenceable;                              // 0x0284(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _weightInfluencer;                                 // 0x0285(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _activated;                                        // 0x0286(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_287[0x1];                                      // 0x0287(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_SpawnObject();
	void SetActivated(bool activated);

	class AActor* GetSpawnedObject() const;
	bool IsActivated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileSpawnPoint">();
	}
	static class UTileSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileSpawnPoint>();
	}
};
#pragma pack(pop)
static_assert(alignof(UTileSpawnPoint) == 0x000010, "Wrong alignment on UTileSpawnPoint");
static_assert(sizeof(UTileSpawnPoint) == 0x000290, "Wrong size on UTileSpawnPoint");
static_assert(offsetof(UTileSpawnPoint, TileSpawnPointType) == 0x000228, "Member 'UTileSpawnPoint::TileSpawnPointType' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, Weight) == 0x00022C, "Member 'UTileSpawnPoint::Weight' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, Visualization) == 0x000230, "Member 'UTileSpawnPoint::Visualization' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, _spawnedObject) == 0x000268, "Member 'UTileSpawnPoint::_spawnedObject' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, ObjectSpawnModifier) == 0x000270, "Member 'UTileSpawnPoint::ObjectSpawnModifier' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, _spawnPriorityTier) == 0x000280, "Member 'UTileSpawnPoint::_spawnPriorityTier' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, _weightInfluenceable) == 0x000284, "Member 'UTileSpawnPoint::_weightInfluenceable' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, _weightInfluencer) == 0x000285, "Member 'UTileSpawnPoint::_weightInfluencer' has a wrong offset!");
static_assert(offsetof(UTileSpawnPoint, _activated) == 0x000286, "Member 'UTileSpawnPoint::_activated' has a wrong offset!");

// Class DeadByDaylight.SearchableSpawnPoint
// 0x0000 (0x0290 - 0x0290)
class USearchableSpawnPoint final : public UTileSpawnPoint
{
public:
	TSubclassOf<class AActor>                     ActorToSpawn;                                      // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SearchableSpawnPoint">();
	}
	static class USearchableSpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<USearchableSpawnPoint>();
	}
};
static_assert(alignof(USearchableSpawnPoint) == 0x000010, "Wrong alignment on USearchableSpawnPoint");
static_assert(sizeof(USearchableSpawnPoint) == 0x000290, "Wrong size on USearchableSpawnPoint");
static_assert(offsetof(USearchableSpawnPoint, ActorToSpawn) == 0x000288, "Member 'USearchableSpawnPoint::ActorToSpawn' has a wrong offset!");

// Class DeadByDaylight.UMGFogWidget
// 0x0048 (0x0380 - 0x0338)
class UUMGFogWidget final : public UMobileBaseUserWidget
{
public:
	class UUMGBankAndPlayerInfoWidget*            BankAndPlayerInfoWidget;                           // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_340[0x40];                                     // 0x0340(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnSettingButtonClick();
	void OnCurrencyTooltipTriggered(const struct FTooltipPressedData& tooltipPressedData, const ECurrencyType currencyType);
	void OnLevelTooltipTriggered(const struct FTooltipPressedData& tooltipPressedData);
	void OnRankTooltipTriggered(const struct FTooltipPressedData& tooltipPressedData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGFogWidget">();
	}
	static class UUMGFogWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGFogWidget>();
	}
};
static_assert(alignof(UUMGFogWidget) == 0x000008, "Wrong alignment on UUMGFogWidget");
static_assert(sizeof(UUMGFogWidget) == 0x000380, "Wrong size on UUMGFogWidget");
static_assert(offsetof(UUMGFogWidget, BankAndPlayerInfoWidget) == 0x000338, "Member 'UUMGFogWidget::BankAndPlayerInfoWidget' has a wrong offset!");

// Class DeadByDaylight.SeasonEndPopupScreen
// 0x0000 (0x0140 - 0x0140)
class USeasonEndPopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonEndPopupScreen">();
	}
	static class USeasonEndPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonEndPopupScreen>();
	}
};
static_assert(alignof(USeasonEndPopupScreen) == 0x000008, "Wrong alignment on USeasonEndPopupScreen");
static_assert(sizeof(USeasonEndPopupScreen) == 0x000140, "Wrong size on USeasonEndPopupScreen");

// Class DeadByDaylight.SeasonEndRankRewardsPopupScreen
// 0x0000 (0x0140 - 0x0140)
class USeasonEndRankRewardsPopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonEndRankRewardsPopupScreen">();
	}
	static class USeasonEndRankRewardsPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonEndRankRewardsPopupScreen>();
	}
};
static_assert(alignof(USeasonEndRankRewardsPopupScreen) == 0x000008, "Wrong alignment on USeasonEndRankRewardsPopupScreen");
static_assert(sizeof(USeasonEndRankRewardsPopupScreen) == 0x000140, "Wrong size on USeasonEndRankRewardsPopupScreen");

// Class DeadByDaylight.UMGHtmlTextDecorator
// 0x0000 (0x0030 - 0x0030)
class UUMGHtmlTextDecorator final : public URichTextBlockDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHtmlTextDecorator">();
	}
	static class UUMGHtmlTextDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHtmlTextDecorator>();
	}
};
static_assert(alignof(UUMGHtmlTextDecorator) == 0x000008, "Wrong alignment on UUMGHtmlTextDecorator");
static_assert(sizeof(UUMGHtmlTextDecorator) == 0x000030, "Wrong size on UUMGHtmlTextDecorator");

// Class DeadByDaylight.ShopCameraManager
// 0x0048 (0x0278 - 0x0230)
class AShopCameraManager final : public AActor
{
public:
	struct FNamedButton                           ReloadDBBtn;                                       // 0x0230(0x0018)(Edit, NativeAccessSpecifierPrivate)
	TArray<struct FRoleGenderCharacterRotation>   CharacterRotation;                                 // 0x0248(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FCharacterCameraTag>            CatalogCharactersCamera;                           // 0x0258(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FCharacterCameraTag>            StoryCharactersCamera;                             // 0x0268(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopCameraManager">();
	}
	static class AShopCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AShopCameraManager>();
	}
};
static_assert(alignof(AShopCameraManager) == 0x000008, "Wrong alignment on AShopCameraManager");
static_assert(sizeof(AShopCameraManager) == 0x000278, "Wrong size on AShopCameraManager");
static_assert(offsetof(AShopCameraManager, ReloadDBBtn) == 0x000230, "Member 'AShopCameraManager::ReloadDBBtn' has a wrong offset!");
static_assert(offsetof(AShopCameraManager, CharacterRotation) == 0x000248, "Member 'AShopCameraManager::CharacterRotation' has a wrong offset!");
static_assert(offsetof(AShopCameraManager, CatalogCharactersCamera) == 0x000258, "Member 'AShopCameraManager::CatalogCharactersCamera' has a wrong offset!");
static_assert(offsetof(AShopCameraManager, StoryCharactersCamera) == 0x000268, "Member 'AShopCameraManager::StoryCharactersCamera' has a wrong offset!");

// Class DeadByDaylight.ShopManager
// 0x09B0 (0x09E0 - 0x0030)
class UShopManager : public UObject
{
public:
	uint8                                         Pad_30[0xA8];                                      // 0x0030(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UDBDGameInstance>        _gameInstance;                                     // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x6C0];                                     // 0x00E0(0x06C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UBannerDataProcessor*                   _bannerDataProcessor;                              // 0x07A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URecommendationsGenerator*              _recommendationsGenerator;                         // 0x07A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7B0[0x230];                                    // 0x07B0(0x0230)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopManager">();
	}
	static class UShopManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopManager>();
	}
};
static_assert(alignof(UShopManager) == 0x000008, "Wrong alignment on UShopManager");
static_assert(sizeof(UShopManager) == 0x0009E0, "Wrong size on UShopManager");
static_assert(offsetof(UShopManager, _gameInstance) == 0x0000D8, "Member 'UShopManager::_gameInstance' has a wrong offset!");
static_assert(offsetof(UShopManager, _bannerDataProcessor) == 0x0007A0, "Member 'UShopManager::_bannerDataProcessor' has a wrong offset!");
static_assert(offsetof(UShopManager, _recommendationsGenerator) == 0x0007A8, "Member 'UShopManager::_recommendationsGenerator' has a wrong offset!");

// Class DeadByDaylight.SkillCheck
// 0x01F8 (0x02B0 - 0x00B8)
class USkillCheck final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xC8];                                      // 0x00B8(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _owner;                                            // 0x0180(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableInteractionDefinition*       _currentInteraction;                               // 0x0188(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0x48];                                     // 0x0190(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ESkillCheckCustomType>                 _skillCheckTypesAffectedByWarningModifiers;        // 0x01D8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0xC8];                                     // 0x01E8(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CanSkillCheckTypeGrantScore(ESkillCheckCustomType type);

	void Authority_OnSkillCheckTimeout();
	void Multicast_ActivateSkillCheck(class UChargeableInteractionDefinition* interaction, ESkillCheckCustomType skillCheckCustomType, const struct FSkillCheckDefinition& definition, bool executeOnlyOnNotControlled);
	void Multicast_DeactivateSkillCheck();
	void Multicast_OnTriggerContinuousCustomSkillCheck(class UChargeableInteractionDefinition* currentInteraction, ESkillCheckCustomType skillCheckCustomType, const struct FSkillCheckDefinition& definition);
	void Multicast_OnTriggerCustomSkillCheck(class UChargeableInteractionDefinition* currentInteraction, ESkillCheckCustomType skillCheckCustomType, const class FString& id, const class FString& salt, const struct FSkillCheckDefinition& definition);
	void Multicast_SkillCheckResponse(const struct FSkillCheckResponse& skillCheckResponse, bool executeOnlyOnNotControlled);
	void OnSkillCheckFailureTrigger(const bool hadInput, const bool insane, ESkillCheckCustomType skillCheckCustomType);
	void OnSkillCheckSuccessTrigger(const bool bonus, const bool insane, ESkillCheckCustomType skillCheckCustomType, const bool failedCountedAsGood);
	void Server_ActivateSkillCheck(class UChargeableInteractionDefinition* interaction, ESkillCheckCustomType skillCheckCustomType, const struct FSkillCheckDefinition& definition);
	void Server_DeactivateSkillCheck();
	void Server_OnSkillCheckFailure(const struct FSkillCheckResponse& skillCheckResponse);
	void Server_OnSkillCheckSuccess(const struct FSkillCheckResponse& skillCheckResponse);
	bool ShouldShowWarning();

	bool IsDisplayed() const;
	bool IsHexSkillCheck(class ADBDPlayer* dbdPlayer) const;
	bool IsOffCenterSkillCheck() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillCheck">();
	}
	static class USkillCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillCheck>();
	}
};
static_assert(alignof(USkillCheck) == 0x000008, "Wrong alignment on USkillCheck");
static_assert(sizeof(USkillCheck) == 0x0002B0, "Wrong size on USkillCheck");
static_assert(offsetof(USkillCheck, _owner) == 0x000180, "Member 'USkillCheck::_owner' has a wrong offset!");
static_assert(offsetof(USkillCheck, _currentInteraction) == 0x000188, "Member 'USkillCheck::_currentInteraction' has a wrong offset!");
static_assert(offsetof(USkillCheck, _skillCheckTypesAffectedByWarningModifiers) == 0x0001D8, "Member 'USkillCheck::_skillCheckTypesAffectedByWarningModifiers' has a wrong offset!");

// Class DeadByDaylight.SlashableActivationSourceCollection
// 0x0040 (0x00F8 - 0x00B8)
class USlashableActivationSourceCollection final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x40];                                      // 0x00B8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void AddSource(class UObject* source);
	static void ForceActivate(const class UObject* worldContextObject);
	static void RemoveSource(class UObject* source);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlashableActivationSourceCollection">();
	}
	static class USlashableActivationSourceCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlashableActivationSourceCollection>();
	}
};
static_assert(alignof(USlashableActivationSourceCollection) == 0x000008, "Wrong alignment on USlashableActivationSourceCollection");
static_assert(sizeof(USlashableActivationSourceCollection) == 0x0000F8, "Wrong size on USlashableActivationSourceCollection");

// Class DeadByDaylight.SlashableInterface
// 0x0000 (0x0000 - 0x0000)
class ISlashableInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlashableInterface">();
	}
	static class ISlashableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISlashableInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISlashableInterface) == 0x000001, "Wrong alignment on ISlashableInterface");
static_assert(sizeof(ISlashableInterface) == 0x000001, "Wrong size on ISlashableInterface");

// Class DeadByDaylight.UMGTallyEmblemProgressBar
// 0x0098 (0x03D0 - 0x0338)
class UUMGTallyEmblemProgressBar final : public UMobileBaseUserWidget
{
public:
	class UProgressBar*                           ProgressBar;                                       // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           QualityContainer;                                  // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   EmblemQualityClass;                                // 0x0348(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _emblemQualityAlignment;                           // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EEmblemQuality, struct FSlateBrush>      _qualityFillImages;                                // 0x0380(0x0050)(Edit, DisableEditOnInstance, NoClear, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyEmblemProgressBar">();
	}
	static class UUMGTallyEmblemProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyEmblemProgressBar>();
	}
};
static_assert(alignof(UUMGTallyEmblemProgressBar) == 0x000008, "Wrong alignment on UUMGTallyEmblemProgressBar");
static_assert(sizeof(UUMGTallyEmblemProgressBar) == 0x0003D0, "Wrong size on UUMGTallyEmblemProgressBar");
static_assert(offsetof(UUMGTallyEmblemProgressBar, ProgressBar) == 0x000338, "Member 'UUMGTallyEmblemProgressBar::ProgressBar' has a wrong offset!");
static_assert(offsetof(UUMGTallyEmblemProgressBar, QualityContainer) == 0x000340, "Member 'UUMGTallyEmblemProgressBar::QualityContainer' has a wrong offset!");
static_assert(offsetof(UUMGTallyEmblemProgressBar, EmblemQualityClass) == 0x000348, "Member 'UUMGTallyEmblemProgressBar::EmblemQualityClass' has a wrong offset!");
static_assert(offsetof(UUMGTallyEmblemProgressBar, _emblemQualityAlignment) == 0x000378, "Member 'UUMGTallyEmblemProgressBar::_emblemQualityAlignment' has a wrong offset!");
static_assert(offsetof(UUMGTallyEmblemProgressBar, _qualityFillImages) == 0x000380, "Member 'UUMGTallyEmblemProgressBar::_qualityFillImages' has a wrong offset!");

// Class DeadByDaylight.SlasherAnimInstance
// 0x0190 (0x0450 - 0x02C0)
class USlasherAnimInstance final : public UAnimInstance
{
public:
	TMulticastInlineDelegate<void()>              OnFootTrapped;                                     // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EIntroState                                   _introState;                                       // 0x02D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x02D1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRevvingChainsaw;                                // 0x02D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttackSuccessMontagePlaying;                    // 0x02D3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCamOn;                                          // 0x02D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttacking;                                      // 0x02D5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAnyMontagePlaying;                              // 0x02D6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFrenzy;                                         // 0x02D7(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFrenzyCD;                                       // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInParadise;                                     // 0x02D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _enableArmOverrideTier3;                           // 0x02DA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRingingBell;                                    // 0x02DB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCarrying;                                       // 0x02DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DD[0x3];                                      // 0x02DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _firstPersonCarryOffset;                           // 0x02E0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _firstPersonCarryOffsetLookingDown;                // 0x02EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPassivePhaseWalking;                            // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isActivePhaseWalking;                             // 0x02F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInAir;                                          // 0x02FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isVaultingToFall;                                 // 0x02FB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isSpectator;                                      // 0x02FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _firstPersonView;                                  // 0x02FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x02FE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _validSlasher;                                     // 0x02FF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animDirection;                                    // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animSpeed;                                        // 0x0304(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animPitch;                                        // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animTurning;                                      // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animYaw;                                          // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _pelvisHeight;                                     // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _idleTime;                                         // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _directionSwitch;                                  // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftClearFrontSpaceVector;                        // 0x0320(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightClearFrontSpaceVector;                       // 0x032C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _velocity;                                         // 0x0338(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _rightFootEffectorLocation;                        // 0x0344(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _leftFootEffectorLocation;                         // 0x0350(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               _meshRotation;                                     // 0x035C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimMontage*>                   _attackSuccessAnimations;                          // 0x0368(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimMontage*>                   _camOnAnimations;                                  // 0x0378(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ASlasherPlayer*                         _mySlasher;                                        // 0x0388(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTagStateBool                          _isVaultingToFallState;                            // 0x0390(0x0030)(Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractionAnimation                         _interactionType;                                  // 0x03C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C1[0xF];                                      // 0x03C1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _demogorgonTeleportDuration;                       // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargedAttackStateComponent*           _demogorgonChargedAttackStateComponent;            // 0x03D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDemogorgonCharging;                             // 0x03E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _demogorgonChargingPercent;                        // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOniDemonModeAttackStateComponent*      _oniAttackState;                                   // 0x03E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOniCharging;                                    // 0x03F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOniAttackType                                _oniAttackType;                                    // 0x03F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F2[0x2];                                      // 0x03F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _oniChargeDuration;                                // 0x03F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackSubstate                               _previousAttackSubstate;                           // 0x03F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackSubstate                               _attackSubstate;                                   // 0x03F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3FA[0x6];                                      // 0x03FA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UEvilWithinComponent*                   _evilWithinComponent;                              // 0x0400(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_408[0x10];                                     // 0x0408(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmIKSensorComponent*                  _armIKSensorComponent;                             // 0x0418(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_420[0x10];                                     // 0x0420(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimEffectHandler*                     _animEffectHandlerForSFX;                          // 0x0430(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimEffectHandler*                     _animEffectHandlerForVFX;                          // 0x0438(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimEffectHandler>         _animEffectHandlerClassForSFX;                     // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimEffectHandler>         _animEffectHandlerClassForVFX;                     // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CallOnFootTrapped();
	void SetIsCrouched(const bool value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherAnimInstance">();
	}
	static class USlasherAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherAnimInstance>();
	}
};
static_assert(alignof(USlasherAnimInstance) == 0x000010, "Wrong alignment on USlasherAnimInstance");
static_assert(sizeof(USlasherAnimInstance) == 0x000450, "Wrong size on USlasherAnimInstance");
static_assert(offsetof(USlasherAnimInstance, OnFootTrapped) == 0x0002C0, "Member 'USlasherAnimInstance::OnFootTrapped' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _introState) == 0x0002D0, "Member 'USlasherAnimInstance::_introState' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isCrouched) == 0x0002D1, "Member 'USlasherAnimInstance::_isCrouched' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isRevvingChainsaw) == 0x0002D2, "Member 'USlasherAnimInstance::_isRevvingChainsaw' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isAttackSuccessMontagePlaying) == 0x0002D3, "Member 'USlasherAnimInstance::_isAttackSuccessMontagePlaying' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isCamOn) == 0x0002D4, "Member 'USlasherAnimInstance::_isCamOn' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isAttacking) == 0x0002D5, "Member 'USlasherAnimInstance::_isAttacking' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isAnyMontagePlaying) == 0x0002D6, "Member 'USlasherAnimInstance::_isAnyMontagePlaying' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isFrenzy) == 0x0002D7, "Member 'USlasherAnimInstance::_isFrenzy' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isFrenzyCD) == 0x0002D8, "Member 'USlasherAnimInstance::_isFrenzyCD' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isInParadise) == 0x0002D9, "Member 'USlasherAnimInstance::_isInParadise' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _enableArmOverrideTier3) == 0x0002DA, "Member 'USlasherAnimInstance::_enableArmOverrideTier3' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isRingingBell) == 0x0002DB, "Member 'USlasherAnimInstance::_isRingingBell' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isCarrying) == 0x0002DC, "Member 'USlasherAnimInstance::_isCarrying' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _firstPersonCarryOffset) == 0x0002E0, "Member 'USlasherAnimInstance::_firstPersonCarryOffset' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _firstPersonCarryOffsetLookingDown) == 0x0002EC, "Member 'USlasherAnimInstance::_firstPersonCarryOffsetLookingDown' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isPassivePhaseWalking) == 0x0002F8, "Member 'USlasherAnimInstance::_isPassivePhaseWalking' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isActivePhaseWalking) == 0x0002F9, "Member 'USlasherAnimInstance::_isActivePhaseWalking' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isInAir) == 0x0002FA, "Member 'USlasherAnimInstance::_isInAir' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isVaultingToFall) == 0x0002FB, "Member 'USlasherAnimInstance::_isVaultingToFall' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isSpectator) == 0x0002FC, "Member 'USlasherAnimInstance::_isSpectator' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _firstPersonView) == 0x0002FD, "Member 'USlasherAnimInstance::_firstPersonView' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isIdle) == 0x0002FE, "Member 'USlasherAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _validSlasher) == 0x0002FF, "Member 'USlasherAnimInstance::_validSlasher' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animDirection) == 0x000300, "Member 'USlasherAnimInstance::_animDirection' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animSpeed) == 0x000304, "Member 'USlasherAnimInstance::_animSpeed' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animPitch) == 0x000308, "Member 'USlasherAnimInstance::_animPitch' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animTurning) == 0x00030C, "Member 'USlasherAnimInstance::_animTurning' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animYaw) == 0x000310, "Member 'USlasherAnimInstance::_animYaw' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _pelvisHeight) == 0x000314, "Member 'USlasherAnimInstance::_pelvisHeight' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _idleTime) == 0x000318, "Member 'USlasherAnimInstance::_idleTime' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _directionSwitch) == 0x00031C, "Member 'USlasherAnimInstance::_directionSwitch' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _leftClearFrontSpaceVector) == 0x000320, "Member 'USlasherAnimInstance::_leftClearFrontSpaceVector' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _rightClearFrontSpaceVector) == 0x00032C, "Member 'USlasherAnimInstance::_rightClearFrontSpaceVector' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _velocity) == 0x000338, "Member 'USlasherAnimInstance::_velocity' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _rightFootEffectorLocation) == 0x000344, "Member 'USlasherAnimInstance::_rightFootEffectorLocation' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _leftFootEffectorLocation) == 0x000350, "Member 'USlasherAnimInstance::_leftFootEffectorLocation' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _meshRotation) == 0x00035C, "Member 'USlasherAnimInstance::_meshRotation' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _attackSuccessAnimations) == 0x000368, "Member 'USlasherAnimInstance::_attackSuccessAnimations' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _camOnAnimations) == 0x000378, "Member 'USlasherAnimInstance::_camOnAnimations' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _mySlasher) == 0x000388, "Member 'USlasherAnimInstance::_mySlasher' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isVaultingToFallState) == 0x000390, "Member 'USlasherAnimInstance::_isVaultingToFallState' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _interactionType) == 0x0003C0, "Member 'USlasherAnimInstance::_interactionType' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _demogorgonTeleportDuration) == 0x0003D0, "Member 'USlasherAnimInstance::_demogorgonTeleportDuration' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _demogorgonChargedAttackStateComponent) == 0x0003D8, "Member 'USlasherAnimInstance::_demogorgonChargedAttackStateComponent' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isDemogorgonCharging) == 0x0003E0, "Member 'USlasherAnimInstance::_isDemogorgonCharging' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _demogorgonChargingPercent) == 0x0003E4, "Member 'USlasherAnimInstance::_demogorgonChargingPercent' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _oniAttackState) == 0x0003E8, "Member 'USlasherAnimInstance::_oniAttackState' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _isOniCharging) == 0x0003F0, "Member 'USlasherAnimInstance::_isOniCharging' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _oniAttackType) == 0x0003F1, "Member 'USlasherAnimInstance::_oniAttackType' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _oniChargeDuration) == 0x0003F4, "Member 'USlasherAnimInstance::_oniChargeDuration' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _previousAttackSubstate) == 0x0003F8, "Member 'USlasherAnimInstance::_previousAttackSubstate' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _attackSubstate) == 0x0003F9, "Member 'USlasherAnimInstance::_attackSubstate' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _evilWithinComponent) == 0x000400, "Member 'USlasherAnimInstance::_evilWithinComponent' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _armIKSensorComponent) == 0x000418, "Member 'USlasherAnimInstance::_armIKSensorComponent' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animEffectHandlerForSFX) == 0x000430, "Member 'USlasherAnimInstance::_animEffectHandlerForSFX' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animEffectHandlerForVFX) == 0x000438, "Member 'USlasherAnimInstance::_animEffectHandlerForVFX' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animEffectHandlerClassForSFX) == 0x000440, "Member 'USlasherAnimInstance::_animEffectHandlerClassForSFX' has a wrong offset!");
static_assert(offsetof(USlasherAnimInstance, _animEffectHandlerClassForVFX) == 0x000448, "Member 'USlasherAnimInstance::_animEffectHandlerClassForVFX' has a wrong offset!");

// Class DeadByDaylight.SlasherAttackPickerComponent
// 0x0000 (0x00B8 - 0x00B8)
class USlasherAttackPickerComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherAttackPickerComponent">();
	}
	static class USlasherAttackPickerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherAttackPickerComponent>();
	}
};
static_assert(alignof(USlasherAttackPickerComponent) == 0x000008, "Wrong alignment on USlasherAttackPickerComponent");
static_assert(sizeof(USlasherAttackPickerComponent) == 0x0000B8, "Wrong size on USlasherAttackPickerComponent");

// Class DeadByDaylight.SlasherMovementComponent
// 0x0080 (0x0EE0 - 0x0E60)
class USlasherMovementComponent final : public UDBDCharacterMovementComponent
{
public:
	uint8                                         Pad_E60[0x10];                                     // 0x0E60(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnHitLedgeEvent;                                   // 0x0E70(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         OnHitLedgeEventCooldown;                           // 0x0E80(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E84[0x5C];                                     // 0x0E84(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_Debug_SetKillerMaxSpeedMultiplier(const float maxSpeedMultiplier);
	void DBD_KillerMaxSpeedMultiplier(const float maxSpeedMultiplier);
	void DBD_SimulateHack_LocalKillerMaxSpeedMultiplier(const float maxSpeedMultiplier);

	float GetBaseMaxSpeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherMovementComponent">();
	}
	static class USlasherMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherMovementComponent>();
	}
};
static_assert(alignof(USlasherMovementComponent) == 0x000010, "Wrong alignment on USlasherMovementComponent");
static_assert(sizeof(USlasherMovementComponent) == 0x000EE0, "Wrong size on USlasherMovementComponent");
static_assert(offsetof(USlasherMovementComponent, OnHitLedgeEvent) == 0x000E70, "Member 'USlasherMovementComponent::OnHitLedgeEvent' has a wrong offset!");
static_assert(offsetof(USlasherMovementComponent, OnHitLedgeEventCooldown) == 0x000E80, "Member 'USlasherMovementComponent::OnHitLedgeEventCooldown' has a wrong offset!");

// Class DeadByDaylight.UMGTallyListWidget
// 0x00F0 (0x0558 - 0x0468)
class UUMGTallyListWidget final : public UUMGPageScrollWidget
{
public:
	class FText                                   TopLeftText;                                       // 0x0468(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   TopRightText;                                      // 0x0480(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ListBGPanel;                                       // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerRole                                   _playerRole;                                       // 0x04A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A1[0x7];                                      // 0x04A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   _inAnimationPlayedPages;                           // 0x04A8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<ETallyListPageID, class UUMGTallyListElementWidget*> _listItemWidgets;                      // 0x04F8(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_548[0x10];                                     // 0x0548(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyListWidget">();
	}
	static class UUMGTallyListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyListWidget>();
	}
};
static_assert(alignof(UUMGTallyListWidget) == 0x000008, "Wrong alignment on UUMGTallyListWidget");
static_assert(sizeof(UUMGTallyListWidget) == 0x000558, "Wrong size on UUMGTallyListWidget");
static_assert(offsetof(UUMGTallyListWidget, TopLeftText) == 0x000468, "Member 'UUMGTallyListWidget::TopLeftText' has a wrong offset!");
static_assert(offsetof(UUMGTallyListWidget, TopRightText) == 0x000480, "Member 'UUMGTallyListWidget::TopRightText' has a wrong offset!");
static_assert(offsetof(UUMGTallyListWidget, ListBGPanel) == 0x000498, "Member 'UUMGTallyListWidget::ListBGPanel' has a wrong offset!");
static_assert(offsetof(UUMGTallyListWidget, _playerRole) == 0x0004A0, "Member 'UUMGTallyListWidget::_playerRole' has a wrong offset!");
static_assert(offsetof(UUMGTallyListWidget, _inAnimationPlayedPages) == 0x0004A8, "Member 'UUMGTallyListWidget::_inAnimationPlayedPages' has a wrong offset!");
static_assert(offsetof(UUMGTallyListWidget, _listItemWidgets) == 0x0004F8, "Member 'UUMGTallyListWidget::_listItemWidgets' has a wrong offset!");

// Class DeadByDaylight.SlasherOutlineUpdateStrategy
// 0x0048 (0x0108 - 0x00C0)
class USlasherOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	TMulticastInlineDelegate<void()>              OnRevealed;                                        // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FLinearColor                           _nonRevealedColor;                                 // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _revealedColor;                                    // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _revealedColorForKiller;                           // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherOutlineUpdateStrategy">();
	}
	static class USlasherOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USlasherOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USlasherOutlineUpdateStrategy");
static_assert(sizeof(USlasherOutlineUpdateStrategy) == 0x000108, "Wrong size on USlasherOutlineUpdateStrategy");
static_assert(offsetof(USlasherOutlineUpdateStrategy, OnRevealed) == 0x0000C0, "Member 'USlasherOutlineUpdateStrategy::OnRevealed' has a wrong offset!");
static_assert(offsetof(USlasherOutlineUpdateStrategy, _nonRevealedColor) == 0x0000D0, "Member 'USlasherOutlineUpdateStrategy::_nonRevealedColor' has a wrong offset!");
static_assert(offsetof(USlasherOutlineUpdateStrategy, _revealedColor) == 0x0000E0, "Member 'USlasherOutlineUpdateStrategy::_revealedColor' has a wrong offset!");
static_assert(offsetof(USlasherOutlineUpdateStrategy, _revealedColorForKiller) == 0x0000F0, "Member 'USlasherOutlineUpdateStrategy::_revealedColorForKiller' has a wrong offset!");

// Class DeadByDaylight.SlasherPlayer
// 0x04D0 (0x1630 - 0x1160)
class ASlasherPlayer final : public ADBDPlayer
{
public:
	uint8                                         Pad_1158[0x60];                                    // 0x1158(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnOffensiveAction;                                 // 0x11B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                PutDownTraceLocation;                              // 0x11C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultSlasherPower;                               // 0x11D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoudNoiseDisplayTime;                              // 0x11E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetPriorityFactor;                              // 0x11E4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShouldDisplayAttackZones;                          // 0x11F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11F1[0x7];                                     // 0x11F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACamperExposerInstance>     CamperExposer;                                     // 0x11F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKillerMoodInfluence                          KillerMoodInfluence;                               // 0x1200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1201[0x7];                                     // 0x1201(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EKillerAbilities>                      KillerAbilities;                                   // 0x1208(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UKillerSoundCuesComponent*              KillerSoundCuesComponent;                          // 0x1218(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowKillerPowerDebugInfo;                          // 0x1220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasDamagedGeneratorSinceHook;                      // 0x1221(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1222[0x6];                                     // 0x1222(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(bool isInStalkMode)> OnStalkModeChangedEvent;                      // 0x1228(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1238[0x18];                                    // 0x1238(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UAkComponent>            _audioComponent;                                   // 0x1250(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDNavModifierComponent*               _terrorNavModifierComponent;                       // 0x1258(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKillerBloodFXComponent*                _bloodFXComponent;                                 // 0x1260(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _slasherLightIntensity;                            // 0x1268(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _defaultAmountToSquish;                            // 0x126C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1270[0x8];                                     // 0x1270(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ADBDPlayer*, struct FTargetFocusTimer> _stalkTimers;                                  // 0x1278(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UStillnessTrackerComponent*             _stillnessTracker;                                 // 0x12C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAimAssistComponent*                    _aimAssistComponent;                               // 0x12D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTimer                              _recentlyCloakedTimer;                             // 0x12D8(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FDBDTimer                              _flashlightBlindEvasionScoreTimer;                 // 0x1300(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FDBDTimer                              _flashlightBurnoutEvasionScoreTimer;               // 0x1328(0x0028)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class ADBDPlayer*, struct FAnimationMontageDescriptor> _predictedCamperHitMontages;         // 0x1350(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_13A0[0x10];                                    // 0x13A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoudNoiseHUDIndicator*                 _loudNoiseIndicator;                               // 0x13B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USlasherHitsWhileCarryingTrackerComponent* _hitsWhileCarryingTracker;                      // 0x13B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _stealthIncreaseRate;                              // 0x13C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _stealthDecreaseRate;                              // 0x13C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDateTime                              _stillnessStartTime;                               // 0x13C8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13D0[0x68];                                    // 0x13D0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTagStateBool                          _isInStalkMode;                                    // 0x1438(0x0030)(Net, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1468[0xC0];                                    // 0x1468(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isKilling;                                        // 0x1528(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int8                                          _allowedKillCount;                                 // 0x1529(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int8                                          _allowedKillAfterStrugglePhase;                    // 0x152A(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _allowedKillLastSurvivor;                          // 0x152B(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_152C[0x8];                                     // 0x152C(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _cachedBloodlustTier;                              // 0x1534(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1538[0x4];                                     // 0x1538(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        _killerPowerDebugFlags;                            // 0x153C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _presenceTag;                                      // 0x1540(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_154C[0x4];                                     // 0x154C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _persistantStateTags;                              // 0x1550(0x0020)(Edit, NativeAccessSpecifierPrivate)
	bool                                          _enableKillerCrouchInput;                          // 0x1570(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canStartAttackWhileCrouched;                      // 0x1571(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1572[0x6];                                     // 0x1572(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          _carriedCamper;                                    // 0x1578(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMoriComponent*                         _moriComponent;                                    // 0x1580(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFinisherMoriTrackerComponent*          _finisherMoriTrackerComponent;                     // 0x1588(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitValidatorComponent*                 _hitValidator;                                     // 0x1590(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHitValidatorConfigurator*              _hitValidationConfigurator;                        // 0x1598(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDAttackerComponent*                  _attackerComponent;                                // 0x15A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15A8[0x10];                                    // 0x15A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EAttackType                                   _basicAttackType;                                  // 0x15B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15B9[0x7];                                     // 0x15B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UArmIKSensorComponent*                  _armIKSensorComponent;                             // 0x15C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACamperPlayer*                          _survivorBeingKilled;                              // 0x15C8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15D0[0x18];                                    // 0x15D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UFirstPersonViewComponent*              _firstPersonViewComponent;                         // 0x15E8(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKillerIntroComponent*                  _killerIntroComponent;                             // 0x15F0(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKillerBlindingFXComponent*             _blindingFXComponent;                              // 0x15F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1600[0x8];                                     // 0x1600(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UKillerRedStainUpdateStrategy*          _redStainUpdateStrategy;                           // 0x1608(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _squishFactorParameter;                            // 0x1610(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_161C[0x4];                                     // 0x161C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        _attackZonePivot;                                  // 0x1620(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USlasherStunnableComponent*             _slasherStunnableComponent;                        // 0x1628(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ActionKillerPressed();
	void ActionKillerReleased();
	void AttackInputPressed();
	void AttackInputReleased();
	void Authority_AllowKilling(int32 numKills);
	void Authority_AttemptEscapeCarry(class ACamperPlayer* player);
	void Authority_HandleKillerInterruptingSurvivor(class ADBDPlayer* target);
	void Authority_SetInStalkMode(bool stalkMode, bool forced);
	void BroadcastOnInstantTeleport();
	bool CancelAttackByInput();
	void Client_RequestStun(EStunType stunType, class ADBDPlayer* stunner);
	void Cosmetic_OnCancelCarry();
	void Cosmetic_OnDropCamperEnd();
	void Cosmetic_OnPickUpEnd();
	void DBD_AllowKilling();
	void DBD_DisplayAttackZones(bool display);
	void DBD_MergeLockOnDamageZones(bool enable);
	void DBD_SetAttackZones(EAttackZoneSet attackZoneSet);
	void DecrementInterruptBlock();
	void DisplayAttackZones(bool display);
	float GetCurrentRotationYaw();
	void IncrementInterruptBlock();
	bool IsCrouchAvailable_BP();
	bool IsIdling();
	bool IsWalkLocked();
	bool Local_CancelAttack();
	void MergeLockOnDamageZones(bool enable);
	void Multicast_Cheat_SetAttackDetectionZoneSet(EAttackZoneSet attackZoneSet);
	void Multicast_DisplayAttackZones(bool display);
	void Multicast_MergeLockOnDamageZones(bool enable);
	void Multicast_SetGuidedAction(ESlasherGuidedAction action);
	void OnAttackFinish(const EAttackType attackType);
	void OnAttackStart(const EAttackType attackType);
	void OnCamperHit(class ACamperPlayer* camper);
	void OnDropCamperEnd(class ADBDPlayer* camper);
	void OnIsKillingSurvivorWithMoriUpdated(bool isKillingSurvivorWithMori);
	void OnKillerAbilityBeginActivate(EKillerAbilities killerAbility);
	void OnKillerAbilityBeginDeactivate(EKillerAbilities killerAbility, bool forced);
	void OnKillerAbilityEndActivate(EKillerAbilities killerAbility);
	void OnKillerAbilityEndDeactivate(EKillerAbilities killerAbility, bool forced);
	void OnKillerAbilityUpdateActivate(EKillerAbilities killerAbility, float percent);
	void OnLoudNoiseIndicatorDestroyed();
	void OnLoudNoiseTriggered(class AActor* originator, class AActor* instigatingActor, const struct FVector& location, bool shouldTrack, float* audibleRange, bool isQuickAction, bool isDeceivingNoise);
	void OnPerformingChargableInteraction(float Progress);
	void OnStalkModeChanged(bool stalkMode);
	void OnStalkModeChangedCosmetic(bool stalkMode);
	void OnStealthChanged(bool stealth);
	void OnSuccessfulInterruption(class ACamperPlayer* interruptedSurvivor);
	void OnSurvivorKilled(class ACamperPlayer* playerToKill, bool consumeKill, bool delayedSurvivorDeath);
	void OnSurvivorsLeftChanged(int32 survivorRemaining);
	void PlayBloodHitsEffects();
	void Server_SendAttackInput(bool pressed);
	void SetAttackDetectionZoneSet(EAttackZoneSet attackZoneSet);
	void SetAttackZonePivot(class USceneComponent* attackZonePivot);
	void SetCarriedCamper(class ACamperPlayer* camper);
	void SetChainsawSprinting(bool chainsawSprinting);
	void SetGuidedAction(ESlasherGuidedAction action);
	void SetIsHookingSurvivor(const bool value);
	void SetIsKilling(bool isKilling);
	void SetLightIntensity(float intensity);
	void SetStalkTierWalkSpeedMultiplier(float stalkTierWalkSpeedMultiplier);
	void SetSurvivorBeingKilled(class ACamperPlayer* survivor);
	void SpawnSlasherPower();
	void TriggerPickUpAnimation();
	void TriggerPutDownAnimation();
	void UpdateRageTierEffect(int32 previousTier, int32 currentTier);

	void BroadcastOffensiveAction() const;
	bool CanAffectLocalPlayer() const;
	bool CanAttack(const EAttackType attackType) const;
	bool CanAttack_BP(const EAttackType attackType) const;
	bool CanEscapeCarry(class ACamperPlayer* player) const;
	bool CanGainRage() const;
	bool CanPerformKillerAbility(EKillerAbilities killerAbility) const;
	bool CanPickupSurvivor() const;
	bool CanSlashAttack_BP() const;
	float GetAnimDirection() const;
	float GetBlindedPercent() const;
	class ACamperPlayer* GetCarriedCamper() const;
	TArray<class FName> GetCharacterCustomAnimTags() const;
	class UChaserCharacterComponent* GetChaserCharacterComponent() const;
	ESlasherGuidedAction GetGuidedAction() const;
	bool GetIsAttacking() const;
	float GetLightIntensity() const;
	struct FRotator GetLookRotation() const;
	class ACamperPlayer* GetObsessionTarget() const;
	struct FVector GetPlayerDropOffPoint() const;
	struct FGameplayTag GetPresenceTag() const;
	int32 GetRageTier() const;
	class USlasherMovementComponent* GetSlasherMovement() const;
	float GetStalkTierWalkSpeedMultiplier() const;
	float GetStealthRatio() const;
	struct FDateTime GetStillnessStartTime() const;
	class ACamperPlayer* GetSurvivorBeingKilled() const;
	bool HasKillerAbility(EKillerAbilities killerAbility) const;
	bool HasPreLevelGenerationModifier(class FName modifierID) const;
	bool IsAllowedToKill(const class ACamperPlayer* camper) const;
	bool IsCarrying() const;
	bool IsChainsawSprinting() const;
	bool IsCloaking() const;
	bool IsHooking() const;
	bool IsImmuneToObservingPlayerDetection(const class ADBDPlayer* observingPlayer) const;
	bool IsInterruptBlocked() const;
	bool IsKilling() const;
	bool IsOfferingAllowingKill(const class ACamperPlayer* camper) const;
	bool IsStunned() const;
	bool IsUncloaking() const;
	bool ShouldApplyBloodlustSpeedModifier() const;
	bool WasRecentlyCloaked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherPlayer">();
	}
	static class ASlasherPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASlasherPlayer>();
	}
};
static_assert(alignof(ASlasherPlayer) == 0x000010, "Wrong alignment on ASlasherPlayer");
static_assert(sizeof(ASlasherPlayer) == 0x001630, "Wrong size on ASlasherPlayer");
static_assert(offsetof(ASlasherPlayer, OnOffensiveAction) == 0x0011B8, "Member 'ASlasherPlayer::OnOffensiveAction' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, PutDownTraceLocation) == 0x0011C8, "Member 'ASlasherPlayer::PutDownTraceLocation' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, DefaultSlasherPower) == 0x0011D4, "Member 'ASlasherPlayer::DefaultSlasherPower' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, LoudNoiseDisplayTime) == 0x0011E0, "Member 'ASlasherPlayer::LoudNoiseDisplayTime' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, TargetPriorityFactor) == 0x0011E4, "Member 'ASlasherPlayer::TargetPriorityFactor' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, ShouldDisplayAttackZones) == 0x0011F0, "Member 'ASlasherPlayer::ShouldDisplayAttackZones' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, CamperExposer) == 0x0011F8, "Member 'ASlasherPlayer::CamperExposer' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, KillerMoodInfluence) == 0x001200, "Member 'ASlasherPlayer::KillerMoodInfluence' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, KillerAbilities) == 0x001208, "Member 'ASlasherPlayer::KillerAbilities' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, KillerSoundCuesComponent) == 0x001218, "Member 'ASlasherPlayer::KillerSoundCuesComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, ShowKillerPowerDebugInfo) == 0x001220, "Member 'ASlasherPlayer::ShowKillerPowerDebugInfo' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, HasDamagedGeneratorSinceHook) == 0x001221, "Member 'ASlasherPlayer::HasDamagedGeneratorSinceHook' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, OnStalkModeChangedEvent) == 0x001228, "Member 'ASlasherPlayer::OnStalkModeChangedEvent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _audioComponent) == 0x001250, "Member 'ASlasherPlayer::_audioComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _terrorNavModifierComponent) == 0x001258, "Member 'ASlasherPlayer::_terrorNavModifierComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _bloodFXComponent) == 0x001260, "Member 'ASlasherPlayer::_bloodFXComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _slasherLightIntensity) == 0x001268, "Member 'ASlasherPlayer::_slasherLightIntensity' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _defaultAmountToSquish) == 0x00126C, "Member 'ASlasherPlayer::_defaultAmountToSquish' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _stalkTimers) == 0x001278, "Member 'ASlasherPlayer::_stalkTimers' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _stillnessTracker) == 0x0012C8, "Member 'ASlasherPlayer::_stillnessTracker' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _aimAssistComponent) == 0x0012D0, "Member 'ASlasherPlayer::_aimAssistComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _recentlyCloakedTimer) == 0x0012D8, "Member 'ASlasherPlayer::_recentlyCloakedTimer' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _flashlightBlindEvasionScoreTimer) == 0x001300, "Member 'ASlasherPlayer::_flashlightBlindEvasionScoreTimer' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _flashlightBurnoutEvasionScoreTimer) == 0x001328, "Member 'ASlasherPlayer::_flashlightBurnoutEvasionScoreTimer' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _predictedCamperHitMontages) == 0x001350, "Member 'ASlasherPlayer::_predictedCamperHitMontages' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _loudNoiseIndicator) == 0x0013B0, "Member 'ASlasherPlayer::_loudNoiseIndicator' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _hitsWhileCarryingTracker) == 0x0013B8, "Member 'ASlasherPlayer::_hitsWhileCarryingTracker' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _stealthIncreaseRate) == 0x0013C0, "Member 'ASlasherPlayer::_stealthIncreaseRate' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _stealthDecreaseRate) == 0x0013C4, "Member 'ASlasherPlayer::_stealthDecreaseRate' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _stillnessStartTime) == 0x0013C8, "Member 'ASlasherPlayer::_stillnessStartTime' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _isInStalkMode) == 0x001438, "Member 'ASlasherPlayer::_isInStalkMode' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _isKilling) == 0x001528, "Member 'ASlasherPlayer::_isKilling' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _allowedKillCount) == 0x001529, "Member 'ASlasherPlayer::_allowedKillCount' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _allowedKillAfterStrugglePhase) == 0x00152A, "Member 'ASlasherPlayer::_allowedKillAfterStrugglePhase' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _allowedKillLastSurvivor) == 0x00152B, "Member 'ASlasherPlayer::_allowedKillLastSurvivor' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _cachedBloodlustTier) == 0x001534, "Member 'ASlasherPlayer::_cachedBloodlustTier' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _killerPowerDebugFlags) == 0x00153C, "Member 'ASlasherPlayer::_killerPowerDebugFlags' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _presenceTag) == 0x001540, "Member 'ASlasherPlayer::_presenceTag' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _persistantStateTags) == 0x001550, "Member 'ASlasherPlayer::_persistantStateTags' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _enableKillerCrouchInput) == 0x001570, "Member 'ASlasherPlayer::_enableKillerCrouchInput' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _canStartAttackWhileCrouched) == 0x001571, "Member 'ASlasherPlayer::_canStartAttackWhileCrouched' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _carriedCamper) == 0x001578, "Member 'ASlasherPlayer::_carriedCamper' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _moriComponent) == 0x001580, "Member 'ASlasherPlayer::_moriComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _finisherMoriTrackerComponent) == 0x001588, "Member 'ASlasherPlayer::_finisherMoriTrackerComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _hitValidator) == 0x001590, "Member 'ASlasherPlayer::_hitValidator' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _hitValidationConfigurator) == 0x001598, "Member 'ASlasherPlayer::_hitValidationConfigurator' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _attackerComponent) == 0x0015A0, "Member 'ASlasherPlayer::_attackerComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _basicAttackType) == 0x0015B8, "Member 'ASlasherPlayer::_basicAttackType' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _armIKSensorComponent) == 0x0015C0, "Member 'ASlasherPlayer::_armIKSensorComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _survivorBeingKilled) == 0x0015C8, "Member 'ASlasherPlayer::_survivorBeingKilled' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _firstPersonViewComponent) == 0x0015E8, "Member 'ASlasherPlayer::_firstPersonViewComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _killerIntroComponent) == 0x0015F0, "Member 'ASlasherPlayer::_killerIntroComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _blindingFXComponent) == 0x0015F8, "Member 'ASlasherPlayer::_blindingFXComponent' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _redStainUpdateStrategy) == 0x001608, "Member 'ASlasherPlayer::_redStainUpdateStrategy' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _squishFactorParameter) == 0x001610, "Member 'ASlasherPlayer::_squishFactorParameter' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _attackZonePivot) == 0x001620, "Member 'ASlasherPlayer::_attackZonePivot' has a wrong offset!");
static_assert(offsetof(ASlasherPlayer, _slasherStunnableComponent) == 0x001628, "Member 'ASlasherPlayer::_slasherStunnableComponent' has a wrong offset!");

// Class DeadByDaylight.SlasherStunnableComponent
// 0x0040 (0x00F8 - 0x00B8)
class USlasherStunnableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x40];                                      // 0x00B8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_NotifyStunHasBeenProcessed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherStunnableComponent">();
	}
	static class USlasherStunnableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherStunnableComponent>();
	}
};
static_assert(alignof(USlasherStunnableComponent) == 0x000008, "Wrong alignment on USlasherStunnableComponent");
static_assert(sizeof(USlasherStunnableComponent) == 0x0000F8, "Wrong size on USlasherStunnableComponent");

// Class DeadByDaylight.UMGTallyProgressBar
// 0x0028 (0x0360 - 0x0338)
class UUMGTallyProgressBar final : public UMobileBaseUserWidget
{
public:
	class UProgressBar*                           ProgressBar;                                       // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           PipsContainer;                                     // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           _pipsClasses;                                      // 0x0348(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FVector2D                              _pipsAlignment;                                    // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetPercent(float value);

	const int32 GetPipsCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyProgressBar">();
	}
	static class UUMGTallyProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyProgressBar>();
	}
};
static_assert(alignof(UUMGTallyProgressBar) == 0x000008, "Wrong alignment on UUMGTallyProgressBar");
static_assert(sizeof(UUMGTallyProgressBar) == 0x000360, "Wrong size on UUMGTallyProgressBar");
static_assert(offsetof(UUMGTallyProgressBar, ProgressBar) == 0x000338, "Member 'UUMGTallyProgressBar::ProgressBar' has a wrong offset!");
static_assert(offsetof(UUMGTallyProgressBar, PipsContainer) == 0x000340, "Member 'UUMGTallyProgressBar::PipsContainer' has a wrong offset!");
static_assert(offsetof(UUMGTallyProgressBar, _pipsClasses) == 0x000348, "Member 'UUMGTallyProgressBar::_pipsClasses' has a wrong offset!");
static_assert(offsetof(UUMGTallyProgressBar, _pipsAlignment) == 0x000358, "Member 'UUMGTallyProgressBar::_pipsAlignment' has a wrong offset!");

// Class DeadByDaylight.VaultDefinition
// 0x0040 (0x0660 - 0x0620)
#pragma pack(push, 0x1)
class alignas(0x10) UVaultDefinition : public UInteractionDefinition
{
public:
	struct FGameplayTag                           _vaultGameEvent;                                   // 0x0618(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _feetOffGroundID;                                  // 0x0624(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _feetOnGroundID;                                   // 0x0630(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _allowedHeightDelta;                               // 0x063C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _animationPlayRate;                                // 0x0640(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _scaledElapsedTime;                                // 0x0644(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _vaultSpeedCurve;                                  // 0x0648(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isFall;                                           // 0x0650(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_651[0x7];                                      // 0x0651(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UCurveFloat* GetSpeedCurveToUse() const;
	bool IsWindowVaultable() const;
	bool IsWithinHeightDelta(const class ADBDPlayer* player) const;
	bool ShouldLaunchCharacter(const class ADBDPlayer* player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultDefinition">();
	}
	static class UVaultDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultDefinition>();
	}
};
#pragma pack(pop)
static_assert(alignof(UVaultDefinition) == 0x000010, "Wrong alignment on UVaultDefinition");
static_assert(sizeof(UVaultDefinition) == 0x000660, "Wrong size on UVaultDefinition");
static_assert(offsetof(UVaultDefinition, _vaultGameEvent) == 0x000618, "Member 'UVaultDefinition::_vaultGameEvent' has a wrong offset!");
static_assert(offsetof(UVaultDefinition, _feetOffGroundID) == 0x000624, "Member 'UVaultDefinition::_feetOffGroundID' has a wrong offset!");
static_assert(offsetof(UVaultDefinition, _feetOnGroundID) == 0x000630, "Member 'UVaultDefinition::_feetOnGroundID' has a wrong offset!");
static_assert(offsetof(UVaultDefinition, _allowedHeightDelta) == 0x00063C, "Member 'UVaultDefinition::_allowedHeightDelta' has a wrong offset!");
static_assert(offsetof(UVaultDefinition, _animationPlayRate) == 0x000640, "Member 'UVaultDefinition::_animationPlayRate' has a wrong offset!");
static_assert(offsetof(UVaultDefinition, _scaledElapsedTime) == 0x000644, "Member 'UVaultDefinition::_scaledElapsedTime' has a wrong offset!");
static_assert(offsetof(UVaultDefinition, _vaultSpeedCurve) == 0x000648, "Member 'UVaultDefinition::_vaultSpeedCurve' has a wrong offset!");
static_assert(offsetof(UVaultDefinition, _isFall) == 0x000650, "Member 'UVaultDefinition::_isFall' has a wrong offset!");

// Class DeadByDaylight.SlasherVaultDefinition
// 0x0060 (0x06C0 - 0x0660)
class USlasherVaultDefinition : public UVaultDefinition
{
public:
	struct FAnimationMontageDescriptor            _fallMontageID;                                    // 0x0658(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FAnimationMontageDescriptor            _crouchMontageID;                                  // 0x0678(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FAnimationMontageDescriptor            _defaultMontageID;                                 // 0x0698(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B8[0x8];                                      // 0x06B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMontageBlendingOut(class UAnimMontage* montage, bool interrupted);
	void OnMovementModeChanged(class ACharacter* character, EMovementMode prevMovementMode, uint8 previousCustomMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlasherVaultDefinition">();
	}
	static class USlasherVaultDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USlasherVaultDefinition>();
	}
};
static_assert(alignof(USlasherVaultDefinition) == 0x000010, "Wrong alignment on USlasherVaultDefinition");
static_assert(sizeof(USlasherVaultDefinition) == 0x0006C0, "Wrong size on USlasherVaultDefinition");
static_assert(offsetof(USlasherVaultDefinition, _fallMontageID) == 0x000658, "Member 'USlasherVaultDefinition::_fallMontageID' has a wrong offset!");
static_assert(offsetof(USlasherVaultDefinition, _crouchMontageID) == 0x000678, "Member 'USlasherVaultDefinition::_crouchMontageID' has a wrong offset!");
static_assert(offsetof(USlasherVaultDefinition, _defaultMontageID) == 0x000698, "Member 'USlasherVaultDefinition::_defaultMontageID' has a wrong offset!");

// Class DeadByDaylight.SpawnElement
// 0x0000 (0x0000 - 0x0000)
class ISpawnElement final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnElement">();
	}
	static class ISpawnElement* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpawnElement>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISpawnElement) == 0x000001, "Wrong alignment on ISpawnElement");
static_assert(sizeof(ISpawnElement) == 0x000001, "Wrong size on ISpawnElement");

// Class DeadByDaylight.UMGTallyScoreboardPlayerInfoWidget
// 0x0320 (0x06B0 - 0x0390)
class UUMGTallyScoreboardPlayerInfoWidget final : public UUMGLoadoutBaseWidget
{
public:
	TMulticastInlineDelegate<void(const class FString& playerID)> OnTallyScoreboardAddFriendEvent;   // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& playerID)> OnTallyScoreboardReportEvent;      // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UImage*                                 ImageHorizontalSeparation;                         // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTallyPlayerResultData                 PlayerResultData;                                  // 0x03B8(0x02F0)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          LoadoutIsBlocked;                                  // 0x06A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A9[0x7];                                      // 0x06A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAddFriendEvent(class FName buttonID);
	void HandleReportEvent(class FName buttonID);
	void SetPlayerLoadoutBlocked(bool isBlock);
	void SetPlayerReported(bool isReport);
	void SetPlayerScoreData(const struct FTallyPlayerResultData& resultData);
	void UpdateLoadout();
	void UpdateReported();
	void UpdateWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyScoreboardPlayerInfoWidget">();
	}
	static class UUMGTallyScoreboardPlayerInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyScoreboardPlayerInfoWidget>();
	}
};
static_assert(alignof(UUMGTallyScoreboardPlayerInfoWidget) == 0x000008, "Wrong alignment on UUMGTallyScoreboardPlayerInfoWidget");
static_assert(sizeof(UUMGTallyScoreboardPlayerInfoWidget) == 0x0006B0, "Wrong size on UUMGTallyScoreboardPlayerInfoWidget");
static_assert(offsetof(UUMGTallyScoreboardPlayerInfoWidget, OnTallyScoreboardAddFriendEvent) == 0x000390, "Member 'UUMGTallyScoreboardPlayerInfoWidget::OnTallyScoreboardAddFriendEvent' has a wrong offset!");
static_assert(offsetof(UUMGTallyScoreboardPlayerInfoWidget, OnTallyScoreboardReportEvent) == 0x0003A0, "Member 'UUMGTallyScoreboardPlayerInfoWidget::OnTallyScoreboardReportEvent' has a wrong offset!");
static_assert(offsetof(UUMGTallyScoreboardPlayerInfoWidget, ImageHorizontalSeparation) == 0x0003B0, "Member 'UUMGTallyScoreboardPlayerInfoWidget::ImageHorizontalSeparation' has a wrong offset!");
static_assert(offsetof(UUMGTallyScoreboardPlayerInfoWidget, PlayerResultData) == 0x0003B8, "Member 'UUMGTallyScoreboardPlayerInfoWidget::PlayerResultData' has a wrong offset!");
static_assert(offsetof(UUMGTallyScoreboardPlayerInfoWidget, LoadoutIsBlocked) == 0x0006A8, "Member 'UUMGTallyScoreboardPlayerInfoWidget::LoadoutIsBlocked' has a wrong offset!");

// Class DeadByDaylight.SpecialEventGameplaySpawnerComponent
// 0x0020 (0x00D8 - 0x00B8)
class USpecialEventGameplaySpawnerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_OnComponentSpawned();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventGameplaySpawnerComponent">();
	}
	static class USpecialEventGameplaySpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialEventGameplaySpawnerComponent>();
	}
};
static_assert(alignof(USpecialEventGameplaySpawnerComponent) == 0x000008, "Wrong alignment on USpecialEventGameplaySpawnerComponent");
static_assert(sizeof(USpecialEventGameplaySpawnerComponent) == 0x0000D8, "Wrong size on USpecialEventGameplaySpawnerComponent");

// Class DeadByDaylight.SpecialEventsContainer
// 0x0118 (0x0148 - 0x0030)
class USpecialEventsContainer final : public UObject
{
public:
	uint8                                         Pad_30[0x118];                                     // 0x0030(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecialEventsContainer">();
	}
	static class USpecialEventsContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecialEventsContainer>();
	}
};
static_assert(alignof(USpecialEventsContainer) == 0x000008, "Wrong alignment on USpecialEventsContainer");
static_assert(sizeof(USpecialEventsContainer) == 0x000148, "Wrong size on USpecialEventsContainer");

// Class DeadByDaylight.SplashScreen
// 0x0018 (0x0138 - 0x0120)
class USplashScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSaveGamePopupComplete();

	void HidePressKeyState() const;
	void SetVersionText(const class FString& versionText) const;
	void ShowLoadingState() const;
	void ShowPressKeyState() const;
	void ShowSaveGamePopup() const;
	void ShowSpecialEventVisual(const struct FSpecialEventUIInfo& eventInfo) const;
	void UpdateLoadingProgression(const class FString& loadingProgression) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplashScreen">();
	}
	static class USplashScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<USplashScreen>();
	}
};
static_assert(alignof(USplashScreen) == 0x000008, "Wrong alignment on USplashScreen");
static_assert(sizeof(USplashScreen) == 0x000138, "Wrong size on USplashScreen");

// Class DeadByDaylight.SpringArmCameraTargetingStrategy
// 0x0000 (0x0050 - 0x0050)
class USpringArmCameraTargetingStrategy final : public UBaseCameraTargetingStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpringArmCameraTargetingStrategy">();
	}
	static class USpringArmCameraTargetingStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpringArmCameraTargetingStrategy>();
	}
};
static_assert(alignof(USpringArmCameraTargetingStrategy) == 0x000008, "Wrong alignment on USpringArmCameraTargetingStrategy");
static_assert(sizeof(USpringArmCameraTargetingStrategy) == 0x000050, "Wrong size on USpringArmCameraTargetingStrategy");

// Class DeadByDaylight.StalkedComponent
// 0x0078 (0x0130 - 0x00B8)
class UStalkedComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(bool isBeingStalked)> OnBeingStalkedChanged;                       // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         _maxStalkPoints;                                   // 0x00C8(0x0004)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _stalkableWhileSightingStalker;                    // 0x00CC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isBeingStalked;                                   // 0x00CD(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CE[0x2];                                       // 0x00CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _stalkPointsChargeable;                            // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x58];                                      // 0x00D8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsBeingStalked();
	void OnRep_MaxStalkPoints();

	bool HasStalkPoints() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StalkedComponent">();
	}
	static class UStalkedComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStalkedComponent>();
	}
};
static_assert(alignof(UStalkedComponent) == 0x000008, "Wrong alignment on UStalkedComponent");
static_assert(sizeof(UStalkedComponent) == 0x000130, "Wrong size on UStalkedComponent");
static_assert(offsetof(UStalkedComponent, OnBeingStalkedChanged) == 0x0000B8, "Member 'UStalkedComponent::OnBeingStalkedChanged' has a wrong offset!");
static_assert(offsetof(UStalkedComponent, _maxStalkPoints) == 0x0000C8, "Member 'UStalkedComponent::_maxStalkPoints' has a wrong offset!");
static_assert(offsetof(UStalkedComponent, _stalkableWhileSightingStalker) == 0x0000CC, "Member 'UStalkedComponent::_stalkableWhileSightingStalker' has a wrong offset!");
static_assert(offsetof(UStalkedComponent, _isBeingStalked) == 0x0000CD, "Member 'UStalkedComponent::_isBeingStalked' has a wrong offset!");
static_assert(offsetof(UStalkedComponent, _stalkPointsChargeable) == 0x0000D0, "Member 'UStalkedComponent::_stalkPointsChargeable' has a wrong offset!");

// Class DeadByDaylight.StalkerComponent
// 0x0078 (0x0130 - 0x00B8)
class UStalkerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _distributeStalkRate;                              // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canStalkWhileInChase;                             // 0x00E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E2[0x6];                                       // 0x00E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStalkedComponent*>              _playerStalkedComponents;                          // 0x00E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _stalkPointsChargeable;                            // 0x0108(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x20];                                     // 0x0110(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerBeingStalkedChanged(bool isBeingStalked);

	bool CanStalk() const;
	float GetMaxStalkingPoints() const;
	float GetPercentStalkingPoints() const;
	float GetScoreMultiplier() const;
	float GetTotalStalkingPoints() const;
	bool HasMaxStalkPoints() const;
	bool IsStalkingSomeone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StalkerComponent">();
	}
	static class UStalkerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStalkerComponent>();
	}
};
static_assert(alignof(UStalkerComponent) == 0x000008, "Wrong alignment on UStalkerComponent");
static_assert(sizeof(UStalkerComponent) == 0x000130, "Wrong size on UStalkerComponent");
static_assert(offsetof(UStalkerComponent, _distributeStalkRate) == 0x0000E0, "Member 'UStalkerComponent::_distributeStalkRate' has a wrong offset!");
static_assert(offsetof(UStalkerComponent, _canStalkWhileInChase) == 0x0000E1, "Member 'UStalkerComponent::_canStalkWhileInChase' has a wrong offset!");
static_assert(offsetof(UStalkerComponent, _playerStalkedComponents) == 0x0000E8, "Member 'UStalkerComponent::_playerStalkedComponents' has a wrong offset!");
static_assert(offsetof(UStalkerComponent, _stalkPointsChargeable) == 0x000108, "Member 'UStalkerComponent::_stalkPointsChargeable' has a wrong offset!");

// Class DeadByDaylight.StartLitActivationTimerRemainingCooldownElapsedIconStrategy
// 0x0000 (0x0038 - 0x0038)
class UStartLitActivationTimerRemainingCooldownElapsedIconStrategy final : public UBasePerkIconStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartLitActivationTimerRemainingCooldownElapsedIconStrategy">();
	}
	static class UStartLitActivationTimerRemainingCooldownElapsedIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStartLitActivationTimerRemainingCooldownElapsedIconStrategy>();
	}
};
static_assert(alignof(UStartLitActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000008, "Wrong alignment on UStartLitActivationTimerRemainingCooldownElapsedIconStrategy");
static_assert(sizeof(UStartLitActivationTimerRemainingCooldownElapsedIconStrategy) == 0x000038, "Wrong size on UStartLitActivationTimerRemainingCooldownElapsedIconStrategy");

// Class DeadByDaylight.DBDLogo
// 0x0000 (0x0230 - 0x0230)
class ADBDLogo final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDLogo">();
	}
	static class ADBDLogo* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADBDLogo>();
	}
};
static_assert(alignof(ADBDLogo) == 0x000008, "Wrong alignment on ADBDLogo");
static_assert(sizeof(ADBDLogo) == 0x000230, "Wrong size on ADBDLogo");

// Class DeadByDaylight.StartScreenBase
// 0x0000 (0x0238 - 0x0238)
class AStartScreenBase final : public ALevelScriptActor
{
public:
	void BeginDestroyTravelSequence();
	void TravelToMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartScreenBase">();
	}
	static class AStartScreenBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStartScreenBase>();
	}
};
static_assert(alignof(AStartScreenBase) == 0x000008, "Wrong alignment on AStartScreenBase");
static_assert(sizeof(AStartScreenBase) == 0x000238, "Wrong size on AStartScreenBase");

// Class DeadByDaylight.StateSpeedCurveApplier
// 0x0100 (0x01B8 - 0x00B8)
class UStateSpeedCurveApplier final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x100];                                     // 0x00B8(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateSpeedCurveApplier">();
	}
	static class UStateSpeedCurveApplier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateSpeedCurveApplier>();
	}
};
static_assert(alignof(UStateSpeedCurveApplier) == 0x000008, "Wrong alignment on UStateSpeedCurveApplier");
static_assert(sizeof(UStateSpeedCurveApplier) == 0x0001B8, "Wrong size on UStateSpeedCurveApplier");

// Class DeadByDaylight.StateTagUtilities
// 0x0000 (0x0030 - 0x0030)
class UStateTagUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void AddStateTag(const TScriptInterface<class IObjectStateProvider> objectStateProvider, const struct FGameplayTag& tag);
	static void AddStateTagToPlayer(const class ADBDPlayer* player, const struct FGameplayTag& tag);
	static bool CurrentInteractionHasAnyStateTag(const class ADBDPlayer* player, const struct FGameplayTagContainer& tags);
	static bool CurrentInteractionHasStateTag(const class ADBDPlayer* player, const struct FGameplayTag& tag);
	static bool HasAnyStateTags(const TScriptInterface<class IObjectStateProvider> objectStateProvider, const struct FGameplayTagContainer& tags);
	static bool HasStateTag(const TScriptInterface<class IObjectStateProvider> objectStateProvider, const struct FGameplayTag& tag);
	static void RemoveStateTag(const TScriptInterface<class IObjectStateProvider> objectStateProvider, const struct FGameplayTag& tag);
	static void RemoveStateTagToPlayer(const class ADBDPlayer* player, const struct FGameplayTag& tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateTagUtilities">();
	}
	static class UStateTagUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateTagUtilities>();
	}
};
static_assert(alignof(UStateTagUtilities) == 0x000008, "Wrong alignment on UStateTagUtilities");
static_assert(sizeof(UStateTagUtilities) == 0x000030, "Wrong size on UStateTagUtilities");

// Class DeadByDaylight.StationaryPointLightComponent
// 0x0000 (0x0400 - 0x0400)
class UStationaryPointLightComponent final : public UPointLightComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StationaryPointLightComponent">();
	}
	static class UStationaryPointLightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStationaryPointLightComponent>();
	}
};
static_assert(alignof(UStationaryPointLightComponent) == 0x000010, "Wrong alignment on UStationaryPointLightComponent");
static_assert(sizeof(UStationaryPointLightComponent) == 0x000400, "Wrong size on UStationaryPointLightComponent");

// Class DeadByDaylight.UMGCharacterSelectionWidget
// 0x0058 (0x0390 - 0x0338)
class UUMGCharacterSelectionWidget final : public UMobileBaseUserWidget
{
public:
	TMulticastInlineDelegate<void(int32 charIndex)> OnCharacterSelected;                             // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCharacterRoleButtonClicked;                      // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCharacterInfoButtonClicked;                      // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UUMGCharacterPageScrollWidget*          CharacterPageScrollWidget;                         // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGCharacterSelectSubmenu*             CharacterSelectSubMenu;                            // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGCharacterInfoWidget*                CharacterInfoWidget;                               // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        CharacterSwitcher;                                 // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isKiller;                                         // 0x0388(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastRoleButtonClicked();
	void BroadcastSelectedCharacter(int32 characterIndex);
	void SwitchPanel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCharacterSelectionWidget">();
	}
	static class UUMGCharacterSelectionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCharacterSelectionWidget>();
	}
};
static_assert(alignof(UUMGCharacterSelectionWidget) == 0x000008, "Wrong alignment on UUMGCharacterSelectionWidget");
static_assert(sizeof(UUMGCharacterSelectionWidget) == 0x000390, "Wrong size on UUMGCharacterSelectionWidget");
static_assert(offsetof(UUMGCharacterSelectionWidget, OnCharacterSelected) == 0x000338, "Member 'UUMGCharacterSelectionWidget::OnCharacterSelected' has a wrong offset!");
static_assert(offsetof(UUMGCharacterSelectionWidget, OnCharacterRoleButtonClicked) == 0x000348, "Member 'UUMGCharacterSelectionWidget::OnCharacterRoleButtonClicked' has a wrong offset!");
static_assert(offsetof(UUMGCharacterSelectionWidget, OnCharacterInfoButtonClicked) == 0x000358, "Member 'UUMGCharacterSelectionWidget::OnCharacterInfoButtonClicked' has a wrong offset!");
static_assert(offsetof(UUMGCharacterSelectionWidget, CharacterPageScrollWidget) == 0x000368, "Member 'UUMGCharacterSelectionWidget::CharacterPageScrollWidget' has a wrong offset!");
static_assert(offsetof(UUMGCharacterSelectionWidget, CharacterSelectSubMenu) == 0x000370, "Member 'UUMGCharacterSelectionWidget::CharacterSelectSubMenu' has a wrong offset!");
static_assert(offsetof(UUMGCharacterSelectionWidget, CharacterInfoWidget) == 0x000378, "Member 'UUMGCharacterSelectionWidget::CharacterInfoWidget' has a wrong offset!");
static_assert(offsetof(UUMGCharacterSelectionWidget, CharacterSwitcher) == 0x000380, "Member 'UUMGCharacterSelectionWidget::CharacterSwitcher' has a wrong offset!");
static_assert(offsetof(UUMGCharacterSelectionWidget, _isKiller) == 0x000388, "Member 'UUMGCharacterSelectionWidget::_isKiller' has a wrong offset!");

// Class DeadByDaylight.StatusEffectCollectionComponent
// 0x0038 (0x00F0 - 0x00B8)
class UStatusEffectCollectionComponent final : public UActorComponent
{
public:
	TArray<class UStatusEffect*>                  _array;                                            // 0x00B8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  _local_oldArray;                                   // 0x00C8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x18];                                      // 0x00D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Array();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectCollectionComponent">();
	}
	static class UStatusEffectCollectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectCollectionComponent>();
	}
};
static_assert(alignof(UStatusEffectCollectionComponent) == 0x000008, "Wrong alignment on UStatusEffectCollectionComponent");
static_assert(sizeof(UStatusEffectCollectionComponent) == 0x0000F0, "Wrong size on UStatusEffectCollectionComponent");
static_assert(offsetof(UStatusEffectCollectionComponent, _array) == 0x0000B8, "Member 'UStatusEffectCollectionComponent::_array' has a wrong offset!");
static_assert(offsetof(UStatusEffectCollectionComponent, _local_oldArray) == 0x0000C8, "Member 'UStatusEffectCollectionComponent::_local_oldArray' has a wrong offset!");

// Class DeadByDaylight.StatusEffectDataAsset
// 0x0000 (0x0088 - 0x0088)
class UStatusEffectDataAsset final : public UGameplayModifierContainerDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectDataAsset">();
	}
	static class UStatusEffectDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectDataAsset>();
	}
};
static_assert(alignof(UStatusEffectDataAsset) == 0x000008, "Wrong alignment on UStatusEffectDataAsset");
static_assert(sizeof(UStatusEffectDataAsset) == 0x000088, "Wrong size on UStatusEffectDataAsset");

// Class DeadByDaylight.SteamProfileDAL
// 0x0000 (0x0088 - 0x0088)
class USteamProfileDAL final : public UPlayerProfileDAL
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamProfileDAL">();
	}
	static class USteamProfileDAL* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamProfileDAL>();
	}
};
static_assert(alignof(USteamProfileDAL) == 0x000008, "Wrong alignment on USteamProfileDAL");
static_assert(sizeof(USteamProfileDAL) == 0x000088, "Wrong size on USteamProfileDAL");

// Class DeadByDaylight.UMGChargeableInteractionWidget
// 0x0028 (0x0360 - 0x0338)
class UUMGChargeableInteractionWidget final : public UMobileBaseUserWidget
{
public:
	class UImage*                                 ItemIcon;                                          // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              InteractionIconVisibility;                         // 0x0340(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              ItemChargeVisibility;                              // 0x0341(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              InteractionHudVisibility;                          // 0x0342(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_343[0x1D];                                     // 0x0343(0x001D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearProficienciesData();
	void SetItemChargeColor(const EBarColor barColor);
	void SetItemChargeValue(float value);
	void SetMessage(const class FString& message);
	void SetOpacity(float opacity);
	void SetProficiencyData(int32 index, const struct FStatusEffectSlotData& proficiencyData);
	void SetProgressBarColor(const EBarColor barColor);
	void SetProgressbarValue(float value);
	void SetSecondaryMessage(const class FString& secondMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGChargeableInteractionWidget">();
	}
	static class UUMGChargeableInteractionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGChargeableInteractionWidget>();
	}
};
static_assert(alignof(UUMGChargeableInteractionWidget) == 0x000008, "Wrong alignment on UUMGChargeableInteractionWidget");
static_assert(sizeof(UUMGChargeableInteractionWidget) == 0x000360, "Wrong size on UUMGChargeableInteractionWidget");
static_assert(offsetof(UUMGChargeableInteractionWidget, ItemIcon) == 0x000338, "Member 'UUMGChargeableInteractionWidget::ItemIcon' has a wrong offset!");
static_assert(offsetof(UUMGChargeableInteractionWidget, InteractionIconVisibility) == 0x000340, "Member 'UUMGChargeableInteractionWidget::InteractionIconVisibility' has a wrong offset!");
static_assert(offsetof(UUMGChargeableInteractionWidget, ItemChargeVisibility) == 0x000341, "Member 'UUMGChargeableInteractionWidget::ItemChargeVisibility' has a wrong offset!");
static_assert(offsetof(UUMGChargeableInteractionWidget, InteractionHudVisibility) == 0x000342, "Member 'UUMGChargeableInteractionWidget::InteractionHudVisibility' has a wrong offset!");

// Class DeadByDaylight.StoreControllerSubsystem
// 0x0008 (0x0040 - 0x0038)
class UStoreControllerSubsystem final : public UGameInstanceSubsystem
{
public:
	class UStoreDisplayStandController*           _displayStandController;                           // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreControllerSubsystem">();
	}
	static class UStoreControllerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreControllerSubsystem>();
	}
};
static_assert(alignof(UStoreControllerSubsystem) == 0x000008, "Wrong alignment on UStoreControllerSubsystem");
static_assert(sizeof(UStoreControllerSubsystem) == 0x000040, "Wrong size on UStoreControllerSubsystem");
static_assert(offsetof(UStoreControllerSubsystem, _displayStandController) == 0x000038, "Member 'UStoreControllerSubsystem::_displayStandController' has a wrong offset!");

// Class DeadByDaylight.StoreDisplayStandController
// 0x0000 (0x0120 - 0x0120)
class UStoreDisplayStandController final : public UDisplayStandController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreDisplayStandController">();
	}
	static class UStoreDisplayStandController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreDisplayStandController>();
	}
};
static_assert(alignof(UStoreDisplayStandController) == 0x000008, "Wrong alignment on UStoreDisplayStandController");
static_assert(sizeof(UStoreDisplayStandController) == 0x000120, "Wrong size on UStoreDisplayStandController");

// Class DeadByDaylight.StoreScreen
// 0x0218 (0x0338 - 0x0120)
class UStoreScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0x218];                                    // 0x0120(0x0218)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBuyCurrencyBundle(int32 index);
	void OnEquipItem(const class FString& itemId);
	void OnFeaturedBannerDlcSelected(const class FString& dlcId);
	void OnFeaturedBannerItemSelected(const class FString& itemId, bool isOutfit);
	void OnFeaturedButtonSelected(int32 linkIndex);
	void OnFeaturedCharacterSelected(int32 characterIndex);
	void OnFeaturedStoreItemSelected(const class FString& itemId, bool isOutfit);
	void OnFiltersUpdated(bool all, bool rarityCommon, bool rarityUncommon, bool rarityRare, bool rarityVeryRare, bool rarityUltraRare, bool rarityArtifact, bool rarityLegendary, bool raritySpecialEvent, bool includeAllOwnedItems);
	void OnMarketSlotButtonClick(int32 slotIndex);
	void OnNotEnoughTokens();
	void OnPromoCodeButtonClicked();
	void OnRotateCharacter(float mouseDistanceChange);
	void OnSearchInputChanged(const class FString& searchInput);
	void OnStoreCatalogCategorySelected(int32 categoryIndex);
	void OnStoreCharacterSelected(int32 characterIndex);
	void OnStoreItemLinkSelected(const class FString& itemId);
	void OnStoreItemSelected(const class FString& itemId);
	void OnTabSelected(int32 index);
	void OnUnlockWithCurrency(int32 currencyId, const class FString& combinedItem);

	void OnCatalogSelected() const;
	void OnStorySelected() const;
	void OnUnlockDlc(const class FString& dlcId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StoreScreen">();
	}
	static class UStoreScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStoreScreen>();
	}
};
static_assert(alignof(UStoreScreen) == 0x000008, "Wrong alignment on UStoreScreen");
static_assert(sizeof(UStoreScreen) == 0x000338, "Wrong size on UStoreScreen");

// Class DeadByDaylight.UMGControlTypeWidget
// 0x0040 (0x0378 - 0x0338)
class UUMGControlTypeWidget final : public UMobileBaseUserWidget
{
public:
	class UUMGBaseButtonWidget*                   Button;                                            // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             MoveTextHalfScreenCanvas;                          // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             AimTextHalfScreenCanvas;                           // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             MoveTextFullScreenCanvas;                          // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             AimTextFullScreenCanvas;                           // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_360[0x18];                                     // 0x0360(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleButtonClicked();
	void InitializeDefaultLayout(EAtlantaControlTypeSetting controlType);
	const bool IsChecked();
	void SetOptionChecked(bool isChecked);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGControlTypeWidget">();
	}
	static class UUMGControlTypeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGControlTypeWidget>();
	}
};
static_assert(alignof(UUMGControlTypeWidget) == 0x000008, "Wrong alignment on UUMGControlTypeWidget");
static_assert(sizeof(UUMGControlTypeWidget) == 0x000378, "Wrong size on UUMGControlTypeWidget");
static_assert(offsetof(UUMGControlTypeWidget, Button) == 0x000338, "Member 'UUMGControlTypeWidget::Button' has a wrong offset!");
static_assert(offsetof(UUMGControlTypeWidget, MoveTextHalfScreenCanvas) == 0x000340, "Member 'UUMGControlTypeWidget::MoveTextHalfScreenCanvas' has a wrong offset!");
static_assert(offsetof(UUMGControlTypeWidget, AimTextHalfScreenCanvas) == 0x000348, "Member 'UUMGControlTypeWidget::AimTextHalfScreenCanvas' has a wrong offset!");
static_assert(offsetof(UUMGControlTypeWidget, MoveTextFullScreenCanvas) == 0x000350, "Member 'UUMGControlTypeWidget::MoveTextFullScreenCanvas' has a wrong offset!");
static_assert(offsetof(UUMGControlTypeWidget, AimTextFullScreenCanvas) == 0x000358, "Member 'UUMGControlTypeWidget::AimTextFullScreenCanvas' has a wrong offset!");

// Class DeadByDaylight.StreamVideoFactory
// 0x0000 (0x0030 - 0x0030)
class UStreamVideoFactory final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamVideoFactory">();
	}
	static class UStreamVideoFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStreamVideoFactory>();
	}
};
static_assert(alignof(UStreamVideoFactory) == 0x000008, "Wrong alignment on UStreamVideoFactory");
static_assert(sizeof(UStreamVideoFactory) == 0x000030, "Wrong size on UStreamVideoFactory");

// Class DeadByDaylight.StreamVideoManager
// 0x00C0 (0x00F0 - 0x0030)
class UStreamVideoManager final : public UObject
{
public:
	uint8                                         Pad_30[0xC0];                                      // 0x0030(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStreamVideoDone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamVideoManager">();
	}
	static class UStreamVideoManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStreamVideoManager>();
	}
};
static_assert(alignof(UStreamVideoManager) == 0x000008, "Wrong alignment on UStreamVideoManager");
static_assert(sizeof(UStreamVideoManager) == 0x0000F0, "Wrong size on UStreamVideoManager");

// Class DeadByDaylight.StreamVideoScreenUMG
// 0x0020 (0x0140 - 0x0120)
class UStreamVideoScreenUMG final : public UScreenBase
{
public:
	class UStreamVideoManager*                    _streamVideoManager;                               // 0x0120(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x18];                                     // 0x0128(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCloseTriggered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamVideoScreenUMG">();
	}
	static class UStreamVideoScreenUMG* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStreamVideoScreenUMG>();
	}
};
static_assert(alignof(UStreamVideoScreenUMG) == 0x000008, "Wrong alignment on UStreamVideoScreenUMG");
static_assert(sizeof(UStreamVideoScreenUMG) == 0x000140, "Wrong size on UStreamVideoScreenUMG");
static_assert(offsetof(UStreamVideoScreenUMG, _streamVideoManager) == 0x000120, "Member 'UStreamVideoScreenUMG::_streamVideoManager' has a wrong offset!");

// Class DeadByDaylight.UMGCustomizationItemBuyButton
// 0x0088 (0x04C0 - 0x0438)
class UUMGCustomizationItemBuyButton final : public UUMGCustomizationItemPriceWidget
{
public:
	uint8                                         Pad_438[0x10];                                     // 0x0438(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 CurrencyColorStripe;                               // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ECurrencyType, struct FColor>            _currencyStripeColors;                             // 0x0450(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           _disabledOpacity;                                  // 0x04A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _enabledOpacity;                                   // 0x04B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BroadcastUnlockWithCurrency();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCustomizationItemBuyButton">();
	}
	static class UUMGCustomizationItemBuyButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCustomizationItemBuyButton>();
	}
};
static_assert(alignof(UUMGCustomizationItemBuyButton) == 0x000008, "Wrong alignment on UUMGCustomizationItemBuyButton");
static_assert(sizeof(UUMGCustomizationItemBuyButton) == 0x0004C0, "Wrong size on UUMGCustomizationItemBuyButton");
static_assert(offsetof(UUMGCustomizationItemBuyButton, CurrencyColorStripe) == 0x000448, "Member 'UUMGCustomizationItemBuyButton::CurrencyColorStripe' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemBuyButton, _currencyStripeColors) == 0x000450, "Member 'UUMGCustomizationItemBuyButton::_currencyStripeColors' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemBuyButton, _disabledOpacity) == 0x0004A0, "Member 'UUMGCustomizationItemBuyButton::_disabledOpacity' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemBuyButton, _enabledOpacity) == 0x0004B0, "Member 'UUMGCustomizationItemBuyButton::_enabledOpacity' has a wrong offset!");

// Class DeadByDaylight.StreamVideoSubsystem
// 0x0010 (0x0048 - 0x0038)
class UStreamVideoSubsystem final : public UGameInstanceSubsystem
{
public:
	class UStreamVideoManager*                    StreamVideoManager;                                // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStreamVideoFactory*                    StreamVideoFactory;                                // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StreamVideoSubsystem">();
	}
	static class UStreamVideoSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStreamVideoSubsystem>();
	}
};
static_assert(alignof(UStreamVideoSubsystem) == 0x000008, "Wrong alignment on UStreamVideoSubsystem");
static_assert(sizeof(UStreamVideoSubsystem) == 0x000048, "Wrong size on UStreamVideoSubsystem");
static_assert(offsetof(UStreamVideoSubsystem, StreamVideoManager) == 0x000038, "Member 'UStreamVideoSubsystem::StreamVideoManager' has a wrong offset!");
static_assert(offsetof(UStreamVideoSubsystem, StreamVideoFactory) == 0x000040, "Member 'UStreamVideoSubsystem::StreamVideoFactory' has a wrong offset!");

// Class DeadByDaylight.StunnableInterface
// 0x0000 (0x0000 - 0x0000)
class IStunnableInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StunnableInterface">();
	}
	static class IStunnableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStunnableInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IStunnableInterface) == 0x000001, "Wrong alignment on IStunnableInterface");
static_assert(sizeof(IStunnableInterface) == 0x000001, "Wrong size on IStunnableInterface");

// Class DeadByDaylight.SubtitlesManager
// 0x0038 (0x0070 - 0x0038)
class USubtitlesManager final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsDebuggingSubtitles();
	static int32 PostAkEventWithSubtitles(class UAkGameObject* target, const TArray<struct FAkEventWithSubtitle>& akEventRandomizer, float maxSubtitleDistance, int32 callbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& postEventCallback, const TArray<struct FAkExternalSourceInfo>& externalSources, class UAkAudioEvent** akEventPlayed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitlesManager">();
	}
	static class USubtitlesManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitlesManager>();
	}
};
static_assert(alignof(USubtitlesManager) == 0x000008, "Wrong alignment on USubtitlesManager");
static_assert(sizeof(USubtitlesManager) == 0x000070, "Wrong size on USubtitlesManager");

// Class DeadByDaylight.UMGPurchaseCurrencyWidget
// 0x0088 (0x03C0 - 0x0338)
class UUMGPurchaseCurrencyWidget final : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             PercentageDiscountText;                            // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CurrencyIcon;                                      // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PriceText;                                         // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             UndiscountedPrice;                                 // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CurrencyColorImage;                                // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OriginalPriceOverlay;                              // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           DiscountCanvas;                                    // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            AffordableColor;                                   // 0x0370(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            NotAffordableColor;                                // 0x0398(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPurchaseCurrencyWidget">();
	}
	static class UUMGPurchaseCurrencyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPurchaseCurrencyWidget>();
	}
};
static_assert(alignof(UUMGPurchaseCurrencyWidget) == 0x000008, "Wrong alignment on UUMGPurchaseCurrencyWidget");
static_assert(sizeof(UUMGPurchaseCurrencyWidget) == 0x0003C0, "Wrong size on UUMGPurchaseCurrencyWidget");
static_assert(offsetof(UUMGPurchaseCurrencyWidget, PercentageDiscountText) == 0x000338, "Member 'UUMGPurchaseCurrencyWidget::PercentageDiscountText' has a wrong offset!");
static_assert(offsetof(UUMGPurchaseCurrencyWidget, CurrencyIcon) == 0x000340, "Member 'UUMGPurchaseCurrencyWidget::CurrencyIcon' has a wrong offset!");
static_assert(offsetof(UUMGPurchaseCurrencyWidget, PriceText) == 0x000348, "Member 'UUMGPurchaseCurrencyWidget::PriceText' has a wrong offset!");
static_assert(offsetof(UUMGPurchaseCurrencyWidget, UndiscountedPrice) == 0x000350, "Member 'UUMGPurchaseCurrencyWidget::UndiscountedPrice' has a wrong offset!");
static_assert(offsetof(UUMGPurchaseCurrencyWidget, CurrencyColorImage) == 0x000358, "Member 'UUMGPurchaseCurrencyWidget::CurrencyColorImage' has a wrong offset!");
static_assert(offsetof(UUMGPurchaseCurrencyWidget, OriginalPriceOverlay) == 0x000360, "Member 'UUMGPurchaseCurrencyWidget::OriginalPriceOverlay' has a wrong offset!");
static_assert(offsetof(UUMGPurchaseCurrencyWidget, DiscountCanvas) == 0x000368, "Member 'UUMGPurchaseCurrencyWidget::DiscountCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPurchaseCurrencyWidget, AffordableColor) == 0x000370, "Member 'UUMGPurchaseCurrencyWidget::AffordableColor' has a wrong offset!");
static_assert(offsetof(UUMGPurchaseCurrencyWidget, NotAffordableColor) == 0x000398, "Member 'UUMGPurchaseCurrencyWidget::NotAffordableColor' has a wrong offset!");

// Class DeadByDaylight.SupplyCrateAnimInstance
// 0x0010 (0x02E0 - 0x02D0)
class USupplyCrateAnimInstance final : public USleepingAnimInstance
{
public:
	class ASupplyCrateInteractable*               _owningSupplyCrate;                                // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOpen;                                           // 0x02D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingPriedOpen;                                 // 0x02D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAutoClosing;                                    // 0x02D2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D3[0xD];                                      // 0x02D3(0x000D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeingPriedOpenStarted(class ADBDPlayer* player);
	void OnBeingPriedOpenStopped();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyCrateAnimInstance">();
	}
	static class USupplyCrateAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USupplyCrateAnimInstance>();
	}
};
static_assert(alignof(USupplyCrateAnimInstance) == 0x000010, "Wrong alignment on USupplyCrateAnimInstance");
static_assert(sizeof(USupplyCrateAnimInstance) == 0x0002E0, "Wrong size on USupplyCrateAnimInstance");
static_assert(offsetof(USupplyCrateAnimInstance, _owningSupplyCrate) == 0x0002C8, "Member 'USupplyCrateAnimInstance::_owningSupplyCrate' has a wrong offset!");
static_assert(offsetof(USupplyCrateAnimInstance, _isOpen) == 0x0002D0, "Member 'USupplyCrateAnimInstance::_isOpen' has a wrong offset!");
static_assert(offsetof(USupplyCrateAnimInstance, _isBeingPriedOpen) == 0x0002D1, "Member 'USupplyCrateAnimInstance::_isBeingPriedOpen' has a wrong offset!");
static_assert(offsetof(USupplyCrateAnimInstance, _isAutoClosing) == 0x0002D2, "Member 'USupplyCrateAnimInstance::_isAutoClosing' has a wrong offset!");

// Class DeadByDaylight.SupplyCrateInteractable
// 0x0118 (0x0440 - 0x0328)
class ASupplyCrateInteractable final : public AInteractable
{
public:
	uint8                                         Pad_328[0x38];                                     // 0x0328(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _chargeableComponent;                              // 0x0360(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACollectable>               _containedCollectable;                             // 0x0368(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _openInteractionSecondsToCharge;                   // 0x0370(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACollectable*                           _itemInSupplyCrate;                                // 0x0398(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _containingItemSpawnPoint;                         // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _itemDropPoint;                                    // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isOpen;                                           // 0x03B0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isAutoClosing;                                    // 0x03B1(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B2[0x3E];                                     // 0x03B2(0x003E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _crateSelfClosingTime;                             // 0x03F0(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _crateAutoCloseAnimationTime;                      // 0x0418(0x0028)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnIsClosing();
	void OnIsOpened();
	void OnRep_IsAutoClosing();
	void OnRep_IsOpen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyCrateInteractable">();
	}
	static class ASupplyCrateInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASupplyCrateInteractable>();
	}
};
static_assert(alignof(ASupplyCrateInteractable) == 0x000008, "Wrong alignment on ASupplyCrateInteractable");
static_assert(sizeof(ASupplyCrateInteractable) == 0x000440, "Wrong size on ASupplyCrateInteractable");
static_assert(offsetof(ASupplyCrateInteractable, _chargeableComponent) == 0x000360, "Member 'ASupplyCrateInteractable::_chargeableComponent' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _containedCollectable) == 0x000368, "Member 'ASupplyCrateInteractable::_containedCollectable' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _openInteractionSecondsToCharge) == 0x000370, "Member 'ASupplyCrateInteractable::_openInteractionSecondsToCharge' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _itemInSupplyCrate) == 0x000398, "Member 'ASupplyCrateInteractable::_itemInSupplyCrate' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _containingItemSpawnPoint) == 0x0003A0, "Member 'ASupplyCrateInteractable::_containingItemSpawnPoint' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _itemDropPoint) == 0x0003A8, "Member 'ASupplyCrateInteractable::_itemDropPoint' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _isOpen) == 0x0003B0, "Member 'ASupplyCrateInteractable::_isOpen' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _isAutoClosing) == 0x0003B1, "Member 'ASupplyCrateInteractable::_isAutoClosing' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _crateSelfClosingTime) == 0x0003F0, "Member 'ASupplyCrateInteractable::_crateSelfClosingTime' has a wrong offset!");
static_assert(offsetof(ASupplyCrateInteractable, _crateAutoCloseAnimationTime) == 0x000418, "Member 'ASupplyCrateInteractable::_crateAutoCloseAnimationTime' has a wrong offset!");

// Class DeadByDaylight.SurviveTimerScoreEventComponent
// 0x0030 (0x00E8 - 0x00B8)
class USurviveTimerScoreEventComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnGameStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurviveTimerScoreEventComponent">();
	}
	static class USurviveTimerScoreEventComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurviveTimerScoreEventComponent>();
	}
};
static_assert(alignof(USurviveTimerScoreEventComponent) == 0x000008, "Wrong alignment on USurviveTimerScoreEventComponent");
static_assert(sizeof(USurviveTimerScoreEventComponent) == 0x0000E8, "Wrong size on USurviveTimerScoreEventComponent");

// Class DeadByDaylight.UMGRankBanner
// 0x0038 (0x0370 - 0x0338)
class UUMGRankBanner final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGTallyRankFrame*                     RankFrameWidget;                                   // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                TooltipButton;                                     // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HighlightImage;                                    // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          OnLongPressSound;                                  // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FTooltipPressedData& tooltipPressedData)> _onLongPressRankTooltipEvent; // 0x0360(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)

public:
	void HandleTooltipLongPressedEvent();
	void SetData(int32 rank, EPlayerRole playerRole);
	void StartHighlight();
	void StopHighlight();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGRankBanner">();
	}
	static class UUMGRankBanner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGRankBanner>();
	}
};
static_assert(alignof(UUMGRankBanner) == 0x000008, "Wrong alignment on UUMGRankBanner");
static_assert(sizeof(UUMGRankBanner) == 0x000370, "Wrong size on UUMGRankBanner");
static_assert(offsetof(UUMGRankBanner, RankFrameWidget) == 0x000340, "Member 'UUMGRankBanner::RankFrameWidget' has a wrong offset!");
static_assert(offsetof(UUMGRankBanner, TooltipButton) == 0x000348, "Member 'UUMGRankBanner::TooltipButton' has a wrong offset!");
static_assert(offsetof(UUMGRankBanner, HighlightImage) == 0x000350, "Member 'UUMGRankBanner::HighlightImage' has a wrong offset!");
static_assert(offsetof(UUMGRankBanner, OnLongPressSound) == 0x000358, "Member 'UUMGRankBanner::OnLongPressSound' has a wrong offset!");
static_assert(offsetof(UUMGRankBanner, _onLongPressRankTooltipEvent) == 0x000360, "Member 'UUMGRankBanner::_onLongPressRankTooltipEvent' has a wrong offset!");

// Class DeadByDaylight.SurvivorActivityData
// 0x0010 (0x0048 - 0x0038)
class USurvivorActivityData final : public UDataAsset
{
public:
	TArray<struct FSurvivorActivity>              _allPossibleActivities;                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorActivityData">();
	}
	static class USurvivorActivityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorActivityData>();
	}
};
static_assert(alignof(USurvivorActivityData) == 0x000008, "Wrong alignment on USurvivorActivityData");
static_assert(sizeof(USurvivorActivityData) == 0x000048, "Wrong size on USurvivorActivityData");
static_assert(offsetof(USurvivorActivityData, _allPossibleActivities) == 0x000038, "Member 'USurvivorActivityData::_allPossibleActivities' has a wrong offset!");

// Class DeadByDaylight.SurvivorActivityIndicatorComponent
// 0x0158 (0x0210 - 0x00B8)
class USurvivorActivityIndicatorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xB8];                                      // 0x00B8(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	class USurvivorActivityData*                  _activitiesDataAsset;                              // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x30];                                     // 0x0178(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _durationNeededToEnableUI;                         // 0x01A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AC[0x64];                                     // 0x01AC(0x0064)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCamperEscape(const struct FGameplayTag& gameplayTag, const struct FGameEventData& gameEventData);
	void HandleStartActivityIfStillInEffect(const struct FSurvivorActivity& activityViewInfo, const struct FGameplayTag& tag);
	void Multicast_OnCamperEscape();
	void OnChargeableProgressChanged(class UChargeableComponent* chargeableComponent, float totalPercentComplete);
	void OnDamageStateChanged(ECamperDamageState oldDamageState, ECamperDamageState currentDamageState);
	void OnPlayerDropped();
	void OnPlayerImmobilizeStateChanged(const ECamperImmobilizeState oldImmobilizeState, const ECamperImmobilizeState newImmobilizeState);
	void OnPlayerPickedUp(class ADBDPlayer* picker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorActivityIndicatorComponent">();
	}
	static class USurvivorActivityIndicatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorActivityIndicatorComponent>();
	}
};
static_assert(alignof(USurvivorActivityIndicatorComponent) == 0x000008, "Wrong alignment on USurvivorActivityIndicatorComponent");
static_assert(sizeof(USurvivorActivityIndicatorComponent) == 0x000210, "Wrong size on USurvivorActivityIndicatorComponent");
static_assert(offsetof(USurvivorActivityIndicatorComponent, _activitiesDataAsset) == 0x000170, "Member 'USurvivorActivityIndicatorComponent::_activitiesDataAsset' has a wrong offset!");
static_assert(offsetof(USurvivorActivityIndicatorComponent, _durationNeededToEnableUI) == 0x0001A8, "Member 'USurvivorActivityIndicatorComponent::_durationNeededToEnableUI' has a wrong offset!");

// Class DeadByDaylight.SurvivorAttackableComponent
// 0x0028 (0x00E0 - 0x00B8)
class USurvivorAttackableComponent final : public UAttackableComponent
{
public:
	uint8                                         Pad_B8[0x28];                                      // 0x00B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_HitCosmetic(const class AActor* attacker, EAttackType attackType, bool causeKO, bool isWeaponHit);
	void Multicast_HitCosmetic(const struct FPlayerHitCosmeticParams& params);
	void Multicast_HitCosmetic_NonLocal(const struct FPlayerHitCosmeticParams& params);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAttackableComponent">();
	}
	static class USurvivorAttackableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAttackableComponent>();
	}
};
static_assert(alignof(USurvivorAttackableComponent) == 0x000008, "Wrong alignment on USurvivorAttackableComponent");
static_assert(sizeof(USurvivorAttackableComponent) == 0x0000E0, "Wrong size on USurvivorAttackableComponent");

// Class DeadByDaylight.UMGRewardSlotTutorialPopupRewardWidget
// 0x0028 (0x0360 - 0x0338)
class UUMGRewardSlotTutorialPopupRewardWidget final : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             RewardText;                                        // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RewardPicture;                                     // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                UnlockedPanel;                                     // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                MissedRewardPanel;                                 // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RewardUnlockedTextOpacity;                         // 0x0358(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RewardToBeMissedTextOpacity;                       // 0x035C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGRewardSlotTutorialPopupRewardWidget">();
	}
	static class UUMGRewardSlotTutorialPopupRewardWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGRewardSlotTutorialPopupRewardWidget>();
	}
};
static_assert(alignof(UUMGRewardSlotTutorialPopupRewardWidget) == 0x000008, "Wrong alignment on UUMGRewardSlotTutorialPopupRewardWidget");
static_assert(sizeof(UUMGRewardSlotTutorialPopupRewardWidget) == 0x000360, "Wrong size on UUMGRewardSlotTutorialPopupRewardWidget");
static_assert(offsetof(UUMGRewardSlotTutorialPopupRewardWidget, RewardText) == 0x000338, "Member 'UUMGRewardSlotTutorialPopupRewardWidget::RewardText' has a wrong offset!");
static_assert(offsetof(UUMGRewardSlotTutorialPopupRewardWidget, RewardPicture) == 0x000340, "Member 'UUMGRewardSlotTutorialPopupRewardWidget::RewardPicture' has a wrong offset!");
static_assert(offsetof(UUMGRewardSlotTutorialPopupRewardWidget, UnlockedPanel) == 0x000348, "Member 'UUMGRewardSlotTutorialPopupRewardWidget::UnlockedPanel' has a wrong offset!");
static_assert(offsetof(UUMGRewardSlotTutorialPopupRewardWidget, MissedRewardPanel) == 0x000350, "Member 'UUMGRewardSlotTutorialPopupRewardWidget::MissedRewardPanel' has a wrong offset!");
static_assert(offsetof(UUMGRewardSlotTutorialPopupRewardWidget, RewardUnlockedTextOpacity) == 0x000358, "Member 'UUMGRewardSlotTutorialPopupRewardWidget::RewardUnlockedTextOpacity' has a wrong offset!");
static_assert(offsetof(UUMGRewardSlotTutorialPopupRewardWidget, RewardToBeMissedTextOpacity) == 0x00035C, "Member 'UUMGRewardSlotTutorialPopupRewardWidget::RewardToBeMissedTextOpacity' has a wrong offset!");

// Class DeadByDaylight.SurvivorAudioHandlerComponent
// 0x0020 (0x0158 - 0x0138)
class USurvivorAudioHandlerComponent final : public UDBDPlayerAudioHandlerComponent
{
public:
	uint8                                         Pad_138[0x20];                                     // 0x0138(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorAudioHandlerComponent">();
	}
	static class USurvivorAudioHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorAudioHandlerComponent>();
	}
};
static_assert(alignof(USurvivorAudioHandlerComponent) == 0x000008, "Wrong alignment on USurvivorAudioHandlerComponent");
static_assert(sizeof(USurvivorAudioHandlerComponent) == 0x000158, "Wrong size on USurvivorAudioHandlerComponent");

// Class DeadByDaylight.SurvivorBloodFXComponent
// 0x0000 (0x00B8 - 0x00B8)
class USurvivorBloodFXComponent final : public UActorComponent
{
public:
	class UNiagaraComponent* SpawnBloodSpurts();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorBloodFXComponent">();
	}
	static class USurvivorBloodFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorBloodFXComponent>();
	}
};
static_assert(alignof(USurvivorBloodFXComponent) == 0x000008, "Wrong alignment on USurvivorBloodFXComponent");
static_assert(sizeof(USurvivorBloodFXComponent) == 0x0000B8, "Wrong size on USurvivorBloodFXComponent");

// Class DeadByDaylight.SurvivorCollectableOutlineUpdateStrategy
// 0x0020 (0x00E0 - 0x00C0)
class USurvivorCollectableOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _outlineColor;                                     // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _nearlyConsumedColor;                              // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorCollectableOutlineUpdateStrategy">();
	}
	static class USurvivorCollectableOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorCollectableOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USurvivorCollectableOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USurvivorCollectableOutlineUpdateStrategy");
static_assert(sizeof(USurvivorCollectableOutlineUpdateStrategy) == 0x0000E0, "Wrong size on USurvivorCollectableOutlineUpdateStrategy");
static_assert(offsetof(USurvivorCollectableOutlineUpdateStrategy, _outlineColor) == 0x0000C0, "Member 'USurvivorCollectableOutlineUpdateStrategy::_outlineColor' has a wrong offset!");
static_assert(offsetof(USurvivorCollectableOutlineUpdateStrategy, _nearlyConsumedColor) == 0x0000D0, "Member 'USurvivorCollectableOutlineUpdateStrategy::_nearlyConsumedColor' has a wrong offset!");

// Class DeadByDaylight.UMGRitualRefreshButton
// 0x0010 (0x0478 - 0x0468)
class UUMGRitualRefreshButton final : public UUMGBaseButtonWidget
{
public:
	class UCanvasPanel*                           RefreshCanvas;                                     // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        RefreshSwitcher;                                   // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetRefreshButton(int32 currency, ECurrencyType currentyType, bool isAdsRefresh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGRitualRefreshButton">();
	}
	static class UUMGRitualRefreshButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGRitualRefreshButton>();
	}
};
static_assert(alignof(UUMGRitualRefreshButton) == 0x000008, "Wrong alignment on UUMGRitualRefreshButton");
static_assert(sizeof(UUMGRitualRefreshButton) == 0x000478, "Wrong size on UUMGRitualRefreshButton");
static_assert(offsetof(UUMGRitualRefreshButton, RefreshCanvas) == 0x000468, "Member 'UUMGRitualRefreshButton::RefreshCanvas' has a wrong offset!");
static_assert(offsetof(UUMGRitualRefreshButton, RefreshSwitcher) == 0x000470, "Member 'UUMGRitualRefreshButton::RefreshSwitcher' has a wrong offset!");

// Class DeadByDaylight.SurvivorDisconnectionComponent
// 0x0000 (0x00B8 - 0x00B8)
class USurvivorDisconnectionComponent final : public UActorComponent
{
public:
	void Authority_OnPlayerDisconnected(class ADBDPlayer* player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorDisconnectionComponent">();
	}
	static class USurvivorDisconnectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorDisconnectionComponent>();
	}
};
static_assert(alignof(USurvivorDisconnectionComponent) == 0x000008, "Wrong alignment on USurvivorDisconnectionComponent");
static_assert(sizeof(USurvivorDisconnectionComponent) == 0x0000B8, "Wrong size on USurvivorDisconnectionComponent");

// Class DeadByDaylight.SurvivorHitCosmeticHandler
// 0x0028 (0x0058 - 0x0030)
class USurvivorHitCosmeticHandler final : public UBaseReversibleInstantActionHandler
{
public:
	class UNiagaraComponent*                      _bloodSpurts;                                      // 0x0030(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMontageStarted(const struct FAnimationMontageDescriptor& animMontageID, const float playRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorHitCosmeticHandler">();
	}
	static class USurvivorHitCosmeticHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorHitCosmeticHandler>();
	}
};
static_assert(alignof(USurvivorHitCosmeticHandler) == 0x000008, "Wrong alignment on USurvivorHitCosmeticHandler");
static_assert(sizeof(USurvivorHitCosmeticHandler) == 0x000058, "Wrong size on USurvivorHitCosmeticHandler");
static_assert(offsetof(USurvivorHitCosmeticHandler, _bloodSpurts) == 0x000030, "Member 'USurvivorHitCosmeticHandler::_bloodSpurts' has a wrong offset!");

// Class DeadByDaylight.SurvivorOutlineUpdateStrategy
// 0x0078 (0x0138 - 0x00C0)
class USurvivorOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _inDangerColorForSurvivor;                         // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _noRecoveryDyingColor;                             // 0x00D0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _fullRecoveryDyingColor;                           // 0x00E0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _saviourColorForSurvivor;                          // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _colorForKiller;                                   // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               _revealedGradient;                                 // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture*                               _nonRevealedGradient;                              // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplayTag>                   _revealToKillerDurationTags;                       // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _revealToKillerLingerTimer;                        // 0x0130(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _trappedIconActive;                                // 0x0134(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class UGameplayModifierContainer*> GetEffectsProtectingFromKillerAuraReading(const class ACamperPlayer* subject, const class ASlasherPlayer* killer);
	static bool IsActivelyHidingAuraFromKiller(const class ACamperPlayer* subject, const class ASlasherPlayer* witness);

	void SetTrappedIconActive(bool value);

	bool IsBlockingAuraReadingFromKiller(const class ASlasherPlayer* killer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorOutlineUpdateStrategy">();
	}
	static class USurvivorOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorOutlineUpdateStrategy>();
	}
};
static_assert(alignof(USurvivorOutlineUpdateStrategy) == 0x000008, "Wrong alignment on USurvivorOutlineUpdateStrategy");
static_assert(sizeof(USurvivorOutlineUpdateStrategy) == 0x000138, "Wrong size on USurvivorOutlineUpdateStrategy");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _inDangerColorForSurvivor) == 0x0000C0, "Member 'USurvivorOutlineUpdateStrategy::_inDangerColorForSurvivor' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _noRecoveryDyingColor) == 0x0000D0, "Member 'USurvivorOutlineUpdateStrategy::_noRecoveryDyingColor' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _fullRecoveryDyingColor) == 0x0000E0, "Member 'USurvivorOutlineUpdateStrategy::_fullRecoveryDyingColor' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _saviourColorForSurvivor) == 0x0000F0, "Member 'USurvivorOutlineUpdateStrategy::_saviourColorForSurvivor' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _colorForKiller) == 0x000100, "Member 'USurvivorOutlineUpdateStrategy::_colorForKiller' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _revealedGradient) == 0x000110, "Member 'USurvivorOutlineUpdateStrategy::_revealedGradient' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _nonRevealedGradient) == 0x000118, "Member 'USurvivorOutlineUpdateStrategy::_nonRevealedGradient' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _revealToKillerDurationTags) == 0x000120, "Member 'USurvivorOutlineUpdateStrategy::_revealToKillerDurationTags' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _revealToKillerLingerTimer) == 0x000130, "Member 'USurvivorOutlineUpdateStrategy::_revealToKillerLingerTimer' has a wrong offset!");
static_assert(offsetof(USurvivorOutlineUpdateStrategy, _trappedIconActive) == 0x000134, "Member 'USurvivorOutlineUpdateStrategy::_trappedIconActive' has a wrong offset!");

// Class DeadByDaylight.UMGHudEditorScreen
// 0x0070 (0x0308 - 0x0298)
class UUMGHudEditorScreen final : public UUserWidget
{
public:
	class UUMGHudEditorLayoutWidget*              _hudEditorLayoutWidget;                            // 0x0298(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGHudEditorVersionWidget*             _versionSwapWidget;                                // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<EPlayerRole, class UUMGHudEditorLayoutScreen*> _storedLayoutScreens;                        // 0x02A8(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UUMGHudEditorLayoutScreen*              _currentLayoutScreen;                              // 0x02F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          _onDropOverlapSound;                               // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Quit();
	void RegisterEditorLayoutScreen(EPlayerRole role, class UUMGHudEditorLayoutScreen* screen);
	void SetEditorDropErrorOverlapSound(class UAkAudioEvent* onDropOverlapSound);
	void SetWidgets(class UUMGHudEditorLayoutWidget* hudEditorLayoutWidget, class UUMGHudEditorVersionWidget* versionSwapWidget);
	void ShowHudLayout(EPlayerRole role);

	class UUMGHudEditorVersionWidget* GetVersionSwapWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHudEditorScreen">();
	}
	static class UUMGHudEditorScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHudEditorScreen>();
	}
};
static_assert(alignof(UUMGHudEditorScreen) == 0x000008, "Wrong alignment on UUMGHudEditorScreen");
static_assert(sizeof(UUMGHudEditorScreen) == 0x000308, "Wrong size on UUMGHudEditorScreen");
static_assert(offsetof(UUMGHudEditorScreen, _hudEditorLayoutWidget) == 0x000298, "Member 'UUMGHudEditorScreen::_hudEditorLayoutWidget' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorScreen, _versionSwapWidget) == 0x0002A0, "Member 'UUMGHudEditorScreen::_versionSwapWidget' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorScreen, _storedLayoutScreens) == 0x0002A8, "Member 'UUMGHudEditorScreen::_storedLayoutScreens' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorScreen, _currentLayoutScreen) == 0x0002F8, "Member 'UUMGHudEditorScreen::_currentLayoutScreen' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorScreen, _onDropOverlapSound) == 0x000300, "Member 'UUMGHudEditorScreen::_onDropOverlapSound' has a wrong offset!");

// Class DeadByDaylight.SurvivorPlagueEffect
// 0x01F8 (0x0548 - 0x0350)
class USurvivorPlagueEffect final : public UStatusEffect
{
public:
	uint8                                         Pad_350[0x48];                                     // 0x0350(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _sicknessAmount;                                   // 0x0398(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sicknessCap;                                      // 0x039C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _vomitSlowDuration;                                // 0x03A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _vomitSlowAmount;                                  // 0x03A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<float>                                 _sicknessThresholds;                               // 0x03A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          _wasRecentlyHitByVomit;                            // 0x03B8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         _nonNauseatingInteractions;                        // 0x03C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x18];                                     // 0x03D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _sicknessGainPerSecondFromInfectedInteractable;    // 0x03E8(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x90];                                     // 0x0468(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _debugMode;                                        // 0x04F8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F9[0x3F];                                     // 0x04F9(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _exposeMaximumSickSurvivorEffect;                  // 0x0538(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _brokenMaximumSickSurvivorEffect;                  // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_AddSickness(float sicknessToAdd);
	void Authority_InfectInteractable(class AInteractable* interactable);
	void Authority_OnHitBySuperVomitProjectile();
	void Authority_OnHitByVomitProjectile(float sicknessToAdd);
	void Authority_OnHitByVomitProjectileAesthetic();
	void Authority_ResetSickness(float newSickness);
	void Multicast_AddOnScreenDebugMessage(uint64 key, float duration, const struct FColor& displayColor, const class FString& debugMessage);
	void Multicast_OnMaxSicknessReached();
	void Multicast_OnSicknessChanged(float newSickness);
	void Multicast_OnSicknessCured();
	void Multicast_OnSurvivorBecomesInfected();
	void Multicast_OnSurvivorVomit();
	void OnHitByVomit(bool isSuperVomit);
	void OnMaxSicknessReached_Aesthetic();
	void OnRep_SicknessAmount();
	void OnSicknessChanged_Aesthetic(float newSickness);
	void OnSicknessCured_Aesthetic();
	void OnSurvivorBecomesInfected_Aesthetic();
	void OnSurvivorVomit_Aesthetic();
	void RefreshSicknessGainValues();

	uint8 GetMaxSicknessLevel() const;
	float GetSicknessAmount() const;
	uint8 GetSicknessLevel() const;
	float GetSicknessPercentage() const;
	TArray<float> GetSicknessThresholds() const;
	bool HasMaxLevelSickness() const;
	bool IsDebugModeActive() const;
	bool IsInfected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorPlagueEffect">();
	}
	static class USurvivorPlagueEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorPlagueEffect>();
	}
};
static_assert(alignof(USurvivorPlagueEffect) == 0x000008, "Wrong alignment on USurvivorPlagueEffect");
static_assert(sizeof(USurvivorPlagueEffect) == 0x000548, "Wrong size on USurvivorPlagueEffect");
static_assert(offsetof(USurvivorPlagueEffect, _sicknessAmount) == 0x000398, "Member 'USurvivorPlagueEffect::_sicknessAmount' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _sicknessCap) == 0x00039C, "Member 'USurvivorPlagueEffect::_sicknessCap' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _vomitSlowDuration) == 0x0003A0, "Member 'USurvivorPlagueEffect::_vomitSlowDuration' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _vomitSlowAmount) == 0x0003A4, "Member 'USurvivorPlagueEffect::_vomitSlowAmount' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _sicknessThresholds) == 0x0003A8, "Member 'USurvivorPlagueEffect::_sicknessThresholds' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _wasRecentlyHitByVomit) == 0x0003B8, "Member 'USurvivorPlagueEffect::_wasRecentlyHitByVomit' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _nonNauseatingInteractions) == 0x0003C0, "Member 'USurvivorPlagueEffect::_nonNauseatingInteractions' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _sicknessGainPerSecondFromInfectedInteractable) == 0x0003E8, "Member 'USurvivorPlagueEffect::_sicknessGainPerSecondFromInfectedInteractable' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _debugMode) == 0x0004F8, "Member 'USurvivorPlagueEffect::_debugMode' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _exposeMaximumSickSurvivorEffect) == 0x000538, "Member 'USurvivorPlagueEffect::_exposeMaximumSickSurvivorEffect' has a wrong offset!");
static_assert(offsetof(USurvivorPlagueEffect, _brokenMaximumSickSurvivorEffect) == 0x000540, "Member 'USurvivorPlagueEffect::_brokenMaximumSickSurvivorEffect' has a wrong offset!");

// Class DeadByDaylight.SurvivorStatusInterface
// 0x0000 (0x0000 - 0x0000)
class ISurvivorStatusInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorStatusInterface">();
	}
	static class ISurvivorStatusInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISurvivorStatusInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ISurvivorStatusInterface) == 0x000001, "Wrong alignment on ISurvivorStatusInterface");
static_assert(sizeof(ISurvivorStatusInterface) == 0x000001, "Wrong size on ISurvivorStatusInterface");

// Class DeadByDaylight.TallyUIUtilities
// 0x0000 (0x0030 - 0x0030)
class UTallyUIUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TallyUIUtilities">();
	}
	static class UTallyUIUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTallyUIUtilities>();
	}
};
static_assert(alignof(UTallyUIUtilities) == 0x000008, "Wrong alignment on UTallyUIUtilities");
static_assert(sizeof(UTallyUIUtilities) == 0x000030, "Wrong size on UTallyUIUtilities");

// Class DeadByDaylight.TeamworkIconStrategy
// 0x0008 (0x0040 - 0x0038)
class UTeamworkIconStrategy final : public UBasePerkIconStrategy
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamworkIconStrategy">();
	}
	static class UTeamworkIconStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamworkIconStrategy>();
	}
};
static_assert(alignof(UTeamworkIconStrategy) == 0x000008, "Wrong alignment on UTeamworkIconStrategy");
static_assert(sizeof(UTeamworkIconStrategy) == 0x000040, "Wrong size on UTeamworkIconStrategy");

// Class DeadByDaylight.TerrorRadiusIndicatorWidget
// 0x0008 (0x0388 - 0x0380)
class UTerrorRadiusIndicatorWidget final : public UNoiseIndicatorWidget
{
public:
	float                                         _anchorY;                                          // 0x0380(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSoundDistancePercentage(float distancePercentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TerrorRadiusIndicatorWidget">();
	}
	static class UTerrorRadiusIndicatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTerrorRadiusIndicatorWidget>();
	}
};
static_assert(alignof(UTerrorRadiusIndicatorWidget) == 0x000008, "Wrong alignment on UTerrorRadiusIndicatorWidget");
static_assert(sizeof(UTerrorRadiusIndicatorWidget) == 0x000388, "Wrong size on UTerrorRadiusIndicatorWidget");
static_assert(offsetof(UTerrorRadiusIndicatorWidget, _anchorY) == 0x000380, "Member 'UTerrorRadiusIndicatorWidget::_anchorY' has a wrong offset!");

// Class DeadByDaylight.UMGLandingPageButtonWidget
// 0x0050 (0x04B8 - 0x0468)
class UUMGLandingPageButtonWidget final : public UUMGBaseButtonWidget
{
public:
	class UCanvasPanel*                           BigTag;                                            // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           SmallTag;                                          // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TagText;                                           // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         BannerTitleText;                                   // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BannerImage;                                       // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TitleColorBg;                                      // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BorderColor;                                       // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0x18];                                     // 0x04A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLandingPageButtonWidget">();
	}
	static class UUMGLandingPageButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLandingPageButtonWidget>();
	}
};
static_assert(alignof(UUMGLandingPageButtonWidget) == 0x000008, "Wrong alignment on UUMGLandingPageButtonWidget");
static_assert(sizeof(UUMGLandingPageButtonWidget) == 0x0004B8, "Wrong size on UUMGLandingPageButtonWidget");
static_assert(offsetof(UUMGLandingPageButtonWidget, BigTag) == 0x000468, "Member 'UUMGLandingPageButtonWidget::BigTag' has a wrong offset!");
static_assert(offsetof(UUMGLandingPageButtonWidget, SmallTag) == 0x000470, "Member 'UUMGLandingPageButtonWidget::SmallTag' has a wrong offset!");
static_assert(offsetof(UUMGLandingPageButtonWidget, TagText) == 0x000478, "Member 'UUMGLandingPageButtonWidget::TagText' has a wrong offset!");
static_assert(offsetof(UUMGLandingPageButtonWidget, BannerTitleText) == 0x000480, "Member 'UUMGLandingPageButtonWidget::BannerTitleText' has a wrong offset!");
static_assert(offsetof(UUMGLandingPageButtonWidget, BannerImage) == 0x000488, "Member 'UUMGLandingPageButtonWidget::BannerImage' has a wrong offset!");
static_assert(offsetof(UUMGLandingPageButtonWidget, TitleColorBg) == 0x000490, "Member 'UUMGLandingPageButtonWidget::TitleColorBg' has a wrong offset!");
static_assert(offsetof(UUMGLandingPageButtonWidget, BorderColor) == 0x000498, "Member 'UUMGLandingPageButtonWidget::BorderColor' has a wrong offset!");

// Class DeadByDaylight.TickInEditorSkeletalMesh
// 0x0000 (0x02B8 - 0x02B8)
class ATickInEditorSkeletalMesh final : public ASkeletalMeshActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TickInEditorSkeletalMesh">();
	}
	static class ATickInEditorSkeletalMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATickInEditorSkeletalMesh>();
	}
};
static_assert(alignof(ATickInEditorSkeletalMesh) == 0x000008, "Wrong alignment on ATickInEditorSkeletalMesh");
static_assert(sizeof(ATickInEditorSkeletalMesh) == 0x0002B8, "Wrong size on ATickInEditorSkeletalMesh");

// Class DeadByDaylight.TileBank
// 0x0100 (0x0130 - 0x0030)
class UTileBank final : public UObject
{
public:
	uint8                                         Pad_30[0xF0];                                      // 0x0030(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATile*>                          _allTileBlueprints;                                // 0x0120(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileBank">();
	}
	static class UTileBank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileBank>();
	}
};
static_assert(alignof(UTileBank) == 0x000008, "Wrong alignment on UTileBank");
static_assert(sizeof(UTileBank) == 0x000130, "Wrong size on UTileBank");
static_assert(offsetof(UTileBank, _allTileBlueprints) == 0x000120, "Member 'UTileBank::_allTileBlueprints' has a wrong offset!");

// Class DeadByDaylight.UMGLoadoutFilterButton
// 0x0028 (0x0360 - 0x0338)
class UUMGLoadoutFilterButton final : public UMobileBaseUserWidget
{
public:
	class UButton*                                ActionButton;                                      // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class FName filterName)> OnLoadoutFilterButtonClicked;             // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitFilterButton(const class FName& filterName, const TSoftObjectPtr<class UTexture2D> filterTexture);
	void OnActionButtonClick();
	void SetIcon(const TSoftObjectPtr<class UTexture2D>& icon);
	void SetIsSelected(bool isSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLoadoutFilterButton">();
	}
	static class UUMGLoadoutFilterButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLoadoutFilterButton>();
	}
};
static_assert(alignof(UUMGLoadoutFilterButton) == 0x000008, "Wrong alignment on UUMGLoadoutFilterButton");
static_assert(sizeof(UUMGLoadoutFilterButton) == 0x000360, "Wrong size on UUMGLoadoutFilterButton");
static_assert(offsetof(UUMGLoadoutFilterButton, ActionButton) == 0x000338, "Member 'UUMGLoadoutFilterButton::ActionButton' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutFilterButton, OnLoadoutFilterButtonClicked) == 0x000340, "Member 'UUMGLoadoutFilterButton::OnLoadoutFilterButtonClicked' has a wrong offset!");

// Class DeadByDaylight.TileSpawnPointSelector
// 0x0010 (0x0230 - 0x0220)
class UTileSpawnPointSelector final : public USceneComponent
{
public:
	TArray<struct FSelectableTileSpawnPoint>      _tileSpawnPoints;                                  // 0x0218(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileSpawnPointSelector">();
	}
	static class UTileSpawnPointSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileSpawnPointSelector>();
	}
};
static_assert(alignof(UTileSpawnPointSelector) == 0x000010, "Wrong alignment on UTileSpawnPointSelector");
static_assert(sizeof(UTileSpawnPointSelector) == 0x000230, "Wrong size on UTileSpawnPointSelector");
static_assert(offsetof(UTileSpawnPointSelector, _tileSpawnPoints) == 0x000218, "Member 'UTileSpawnPointSelector::_tileSpawnPoints' has a wrong offset!");

// Class DeadByDaylight.TileVisitedAnalyticsComponent
// 0x0050 (0x0108 - 0x00B8)
class UTileVisitedAnalyticsComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TileVisitedAnalyticsComponent">();
	}
	static class UTileVisitedAnalyticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTileVisitedAnalyticsComponent>();
	}
};
static_assert(alignof(UTileVisitedAnalyticsComponent) == 0x000008, "Wrong alignment on UTileVisitedAnalyticsComponent");
static_assert(sizeof(UTileVisitedAnalyticsComponent) == 0x000108, "Wrong size on UTileVisitedAnalyticsComponent");

// Class DeadByDaylight.TimerGate
// 0x0010 (0x0258 - 0x0248)
class ATimerGate final : public AGate
{
public:
	float                                         _currentTime;                                      // 0x0248(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24C[0xC];                                      // 0x024C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTime(float time);
	void RemoveTime(float time);
	void Reset();
	void Rushed(bool success);
	void SetValues(float TimerDuration, float RushGain, float RushBlockDuration);
	void Update(float deltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimerGate">();
	}
	static class ATimerGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimerGate>();
	}
};
static_assert(alignof(ATimerGate) == 0x000008, "Wrong alignment on ATimerGate");
static_assert(sizeof(ATimerGate) == 0x000258, "Wrong size on ATimerGate");
static_assert(offsetof(ATimerGate, _currentTime) == 0x000248, "Member 'ATimerGate::_currentTime' has a wrong offset!");

// Class DeadByDaylight.TimerGateDecrease
// 0x0008 (0x0238 - 0x0230)
class ATimerGateDecrease final : public AActor
{
public:
	class ATimerGate*                             TimerGate;                                         // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Update(float deltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimerGateDecrease">();
	}
	static class ATimerGateDecrease* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATimerGateDecrease>();
	}
};
static_assert(alignof(ATimerGateDecrease) == 0x000008, "Wrong alignment on ATimerGateDecrease");
static_assert(sizeof(ATimerGateDecrease) == 0x000238, "Wrong size on ATimerGateDecrease");
static_assert(offsetof(ATimerGateDecrease, TimerGate) == 0x000230, "Member 'ATimerGateDecrease::TimerGate' has a wrong offset!");

// Class DeadByDaylight.UMGBloodStoreRowWidget
// 0x0098 (0x03D0 - 0x0338)
class UUMGBloodStoreRowWidget final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UHorizontalBox*                         ItemContainer;                                     // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           LockStatusPanel;                                   // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           HardLockedStatusPanel;                             // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _purchasedItemsNbr;                                // 0x0360(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _requiredItemNbr;                                  // 0x0364(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBloodStoreRowStyle                           _rowStyle;                                         // 0x0368(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_369[0x3];                                      // 0x0369(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                _itemPadding;                                      // 0x036C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _itemWidgetClass;                                  // 0x0380(0x0030)(Edit, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _itemClass;                                        // 0x03B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B8[0x18];                                     // 0x03B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastBloodNodeSelected(const class FString& id);
	void BroadcastUnlockAnimationFinished();
	void LockRow(bool playAnim);
	void UnlockRow(bool playAnim);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBloodStoreRowWidget">();
	}
	static class UUMGBloodStoreRowWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBloodStoreRowWidget>();
	}
};
static_assert(alignof(UUMGBloodStoreRowWidget) == 0x000008, "Wrong alignment on UUMGBloodStoreRowWidget");
static_assert(sizeof(UUMGBloodStoreRowWidget) == 0x0003D0, "Wrong size on UUMGBloodStoreRowWidget");
static_assert(offsetof(UUMGBloodStoreRowWidget, ItemContainer) == 0x000348, "Member 'UUMGBloodStoreRowWidget::ItemContainer' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreRowWidget, LockStatusPanel) == 0x000350, "Member 'UUMGBloodStoreRowWidget::LockStatusPanel' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreRowWidget, HardLockedStatusPanel) == 0x000358, "Member 'UUMGBloodStoreRowWidget::HardLockedStatusPanel' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreRowWidget, _purchasedItemsNbr) == 0x000360, "Member 'UUMGBloodStoreRowWidget::_purchasedItemsNbr' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreRowWidget, _requiredItemNbr) == 0x000364, "Member 'UUMGBloodStoreRowWidget::_requiredItemNbr' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreRowWidget, _rowStyle) == 0x000368, "Member 'UUMGBloodStoreRowWidget::_rowStyle' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreRowWidget, _itemPadding) == 0x00036C, "Member 'UUMGBloodStoreRowWidget::_itemPadding' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreRowWidget, _itemWidgetClass) == 0x000380, "Member 'UUMGBloodStoreRowWidget::_itemWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreRowWidget, _itemClass) == 0x0003B0, "Member 'UUMGBloodStoreRowWidget::_itemClass' has a wrong offset!");

// Class DeadByDaylight.DBDTimeTravelManager
// 0x0070 (0x00A0 - 0x0030)
class UDBDTimeTravelManager final : public UObject
{
public:
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDTimeTravelManager">();
	}
	static class UDBDTimeTravelManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDTimeTravelManager>();
	}
};
static_assert(alignof(UDBDTimeTravelManager) == 0x000008, "Wrong alignment on UDBDTimeTravelManager");
static_assert(sizeof(UDBDTimeTravelManager) == 0x0000A0, "Wrong size on UDBDTimeTravelManager");

// Class DeadByDaylight.ToastNotificationScreen
// 0x0048 (0x0168 - 0x0120)
class UToastNotificationScreen final : public UScreenBase
{
public:
	uint8                                         Pad_120[0x48];                                     // 0x0120(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonSelected(int32 buttonId, int32 notificationId);
	void OnNotificationDisplayEnd(int32 notificationId);
	void OnPromptSelected(int32 notificationId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToastNotificationScreen">();
	}
	static class UToastNotificationScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UToastNotificationScreen>();
	}
};
static_assert(alignof(UToastNotificationScreen) == 0x000008, "Wrong alignment on UToastNotificationScreen");
static_assert(sizeof(UToastNotificationScreen) == 0x000168, "Wrong size on UToastNotificationScreen");

// Class DeadByDaylight.TokenProvider
// 0x0000 (0x0000 - 0x0000)
class ITokenProvider final
{
public:
	class UTokenCounter* GetTokenProvider() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TokenProvider">();
	}
	static class ITokenProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITokenProvider>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITokenProvider) == 0x000001, "Wrong alignment on ITokenProvider");
static_assert(sizeof(ITokenProvider) == 0x000001, "Wrong size on ITokenProvider");

// Class DeadByDaylight.UMGCharacterButton
// 0x01E0 (0x0518 - 0x0338)
class UUMGCharacterButton final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 PortraitIcon;                                      // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CharacterSelectedPanel;                            // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           LevelPanel;                                        // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CharacterLevelText;                                // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             OwnedCustomizationText;                            // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TotalCustomizationText;                            // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           PricePanel;                                        // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGCharacterPrice*                     CellPrice;                                         // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGCharacterPrice*                     ShardPrice;                                        // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCharacterSlotData                     CharacterSlotData;                                 // 0x0398(0x0180)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void BroadcastClickedEvent(int32 characterIndex);
	void SetCharacterData(const struct FCharacterSlotData& characterData);
	void SetIsSelected(bool isSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCharacterButton">();
	}
	static class UUMGCharacterButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCharacterButton>();
	}
};
static_assert(alignof(UUMGCharacterButton) == 0x000008, "Wrong alignment on UUMGCharacterButton");
static_assert(sizeof(UUMGCharacterButton) == 0x000518, "Wrong size on UUMGCharacterButton");
static_assert(offsetof(UUMGCharacterButton, PortraitIcon) == 0x000348, "Member 'UUMGCharacterButton::PortraitIcon' has a wrong offset!");
static_assert(offsetof(UUMGCharacterButton, CharacterSelectedPanel) == 0x000350, "Member 'UUMGCharacterButton::CharacterSelectedPanel' has a wrong offset!");
static_assert(offsetof(UUMGCharacterButton, LevelPanel) == 0x000360, "Member 'UUMGCharacterButton::LevelPanel' has a wrong offset!");
static_assert(offsetof(UUMGCharacterButton, CharacterLevelText) == 0x000368, "Member 'UUMGCharacterButton::CharacterLevelText' has a wrong offset!");
static_assert(offsetof(UUMGCharacterButton, OwnedCustomizationText) == 0x000370, "Member 'UUMGCharacterButton::OwnedCustomizationText' has a wrong offset!");
static_assert(offsetof(UUMGCharacterButton, TotalCustomizationText) == 0x000378, "Member 'UUMGCharacterButton::TotalCustomizationText' has a wrong offset!");
static_assert(offsetof(UUMGCharacterButton, PricePanel) == 0x000380, "Member 'UUMGCharacterButton::PricePanel' has a wrong offset!");
static_assert(offsetof(UUMGCharacterButton, CellPrice) == 0x000388, "Member 'UUMGCharacterButton::CellPrice' has a wrong offset!");
static_assert(offsetof(UUMGCharacterButton, ShardPrice) == 0x000390, "Member 'UUMGCharacterButton::ShardPrice' has a wrong offset!");
static_assert(offsetof(UUMGCharacterButton, CharacterSlotData) == 0x000398, "Member 'UUMGCharacterButton::CharacterSlotData' has a wrong offset!");

// Class DeadByDaylight.ToolBoxInterface
// 0x0000 (0x0000 - 0x0000)
class IToolBoxInterface final
{
public:
	class UChargerComponent* GetChargerComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToolBoxInterface">();
	}
	static class IToolBoxInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IToolBoxInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IToolBoxInterface) == 0x000001, "Wrong alignment on IToolBoxInterface");
static_assert(sizeof(IToolBoxInterface) == 0x000001, "Wrong size on IToolBoxInterface");

// Class DeadByDaylight.TooltipScreenUMG
// 0x0020 (0x0140 - 0x0120)
class UTooltipScreenUMG final : public UScreenBase
{
public:
	class UBaseTooltipWidget*                     _tooltipWidget;                                    // 0x0120(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x18];                                     // 0x0128(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCloseTriggered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TooltipScreenUMG">();
	}
	static class UTooltipScreenUMG* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTooltipScreenUMG>();
	}
};
static_assert(alignof(UTooltipScreenUMG) == 0x000008, "Wrong alignment on UTooltipScreenUMG");
static_assert(sizeof(UTooltipScreenUMG) == 0x000140, "Wrong size on UTooltipScreenUMG");
static_assert(offsetof(UTooltipScreenUMG, _tooltipWidget) == 0x000120, "Member 'UTooltipScreenUMG::_tooltipWidget' has a wrong offset!");

// Class DeadByDaylight.TormentAttackDamageCooldownInterface
// 0x0000 (0x0000 - 0x0000)
class ITormentAttackDamageCooldownInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TormentAttackDamageCooldownInterface">();
	}
	static class ITormentAttackDamageCooldownInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITormentAttackDamageCooldownInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITormentAttackDamageCooldownInterface) == 0x000001, "Wrong alignment on ITormentAttackDamageCooldownInterface");
static_assert(sizeof(ITormentAttackDamageCooldownInterface) == 0x000001, "Wrong size on ITormentAttackDamageCooldownInterface");

// Class DeadByDaylight.Totem
// 0x0138 (0x0460 - 0x0328)
class ATotem final : public AInteractable
{
public:
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnTotemBound;                                      // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_340[0x18];                                     // 0x0340(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _boonAuraRevealColor;                              // 0x0358(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTotemBoundPerk*>                _boundPerks;                                       // 0x0368(0x0010)(ExportObject, Net, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	ETotemState                                   _totemState;                                       // 0x0378(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _baseBoonTotemBlessingRange;                       // 0x0380(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _baseBoonTotemAuraRevealRange;                     // 0x03A8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D0[0x10];                                     // 0x03D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAIPerceptionStimuliSourceComponent*    _perceptionStimuliComponent;                       // 0x03E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlockableComponent*                    _totemBlockableComponent;                          // 0x03E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x10];                                     // 0x03F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalPlayerTrackerComponent*           _localPlayerTracker;                               // 0x0400(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActivatorComponent*                    _activatorComponent;                               // 0x0408(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGameplayTagContainerComponent*         _objectState;                                      // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _interactionsAttachPoint;                          // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTotemOutlineUpdateStrategy*            _totemOutlineUpdateStrategy;                       // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x30];                                     // 0x0428(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _canBeBoundToBoonPerk;                             // 0x0458(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_459[0x7];                                      // 0x0459(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_BindToPerk(class UTotemBoundPerk* perk);
	void Authority_Cleanse();
	void Authority_UnbindFromAllPerks();
	void Authority_UnbindFromPerk(class UTotemBoundPerk* perk);
	void OnBlockTotemCosmetic(class ADBDPlayer* player);
	void OnCleanseTotem(class ATotem* totem, const ETotemState oldTotemState);
	void OnLocallyObservedChanged();
	void OnRep_TotemState(const ETotemState oldTotemState);
	void OnTotemBlockChanged();
	void OnTotemStateChanged(const ETotemState oldTotemState, const ETotemState newTotemState);
	void OnUnblockTotemCosmetic(class ADBDPlayer* player);

	class UAkComponent* GetAkAudioComponent() const;
	class UChargeableInteractionDefinition* GetBlessTotemInteraction() const;
	struct FLinearColor GetBoonAuraRevealColor() const;
	float GetBoonTotemAuraRevealRange() const;
	float GetBoonTotemBlessingRange() const;
	class UChargeableInteractionDefinition* GetCleanseTotemInteraction() const;
	class UInteractor* GetMainInteractor() const;
	ETotemState GetTotemState() const;
	bool IsBoundToPerk() const;
	bool IsTotemBlockedForPlayer(const class ADBDPlayer* player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Totem">();
	}
	static class ATotem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATotem>();
	}
};
static_assert(alignof(ATotem) == 0x000008, "Wrong alignment on ATotem");
static_assert(sizeof(ATotem) == 0x000460, "Wrong size on ATotem");
static_assert(offsetof(ATotem, OnTotemBound) == 0x000330, "Member 'ATotem::OnTotemBound' has a wrong offset!");
static_assert(offsetof(ATotem, _boonAuraRevealColor) == 0x000358, "Member 'ATotem::_boonAuraRevealColor' has a wrong offset!");
static_assert(offsetof(ATotem, _boundPerks) == 0x000368, "Member 'ATotem::_boundPerks' has a wrong offset!");
static_assert(offsetof(ATotem, _totemState) == 0x000378, "Member 'ATotem::_totemState' has a wrong offset!");
static_assert(offsetof(ATotem, _baseBoonTotemBlessingRange) == 0x000380, "Member 'ATotem::_baseBoonTotemBlessingRange' has a wrong offset!");
static_assert(offsetof(ATotem, _baseBoonTotemAuraRevealRange) == 0x0003A8, "Member 'ATotem::_baseBoonTotemAuraRevealRange' has a wrong offset!");
static_assert(offsetof(ATotem, _perceptionStimuliComponent) == 0x0003E0, "Member 'ATotem::_perceptionStimuliComponent' has a wrong offset!");
static_assert(offsetof(ATotem, _totemBlockableComponent) == 0x0003E8, "Member 'ATotem::_totemBlockableComponent' has a wrong offset!");
static_assert(offsetof(ATotem, _localPlayerTracker) == 0x000400, "Member 'ATotem::_localPlayerTracker' has a wrong offset!");
static_assert(offsetof(ATotem, _activatorComponent) == 0x000408, "Member 'ATotem::_activatorComponent' has a wrong offset!");
static_assert(offsetof(ATotem, _objectState) == 0x000410, "Member 'ATotem::_objectState' has a wrong offset!");
static_assert(offsetof(ATotem, _interactionsAttachPoint) == 0x000418, "Member 'ATotem::_interactionsAttachPoint' has a wrong offset!");
static_assert(offsetof(ATotem, _totemOutlineUpdateStrategy) == 0x000420, "Member 'ATotem::_totemOutlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(ATotem, _canBeBoundToBoonPerk) == 0x000458, "Member 'ATotem::_canBeBoundToBoonPerk' has a wrong offset!");

// Class DeadByDaylight.UMGCharacterInfoScreen
// 0x00A0 (0x03D8 - 0x0338)
class UUMGCharacterInfoScreen final : public UMobileBaseUserWidget
{
public:
	class UCanvasPanel*                           ContentPanel;                                      // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SurvivorInfoWidgetClass;                           // 0x0340(0x0030)(Edit, DisableEditOnInstance, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   KillerInfoWidgetClass;                             // 0x0370(0x0030)(Edit, DisableEditOnInstance, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGPopupButton*                        ProgressionButton;                                 // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FTeachableData& teachableData, const struct FVector2D& position)> _onTeachableTooltipTriggeredLongPressEvent; // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(const struct FInventorySlotData& itemSlotData, const struct FVector2D& position)> _onPowerItemTooltipTriggeredLongPressEvent; // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void()>              _onProgressionButtonClickEvent;                    // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)

public:
	void HandlePowerItemTooltipLongPressedEvent(const struct FInventorySlotData& slotData, const struct FVector2D& position);
	void HandleProgressionButtonClickEvent();
	void HandleTeachablePerkTooltipLongPressedEvent(const struct FTeachableData& teachableData, const struct FVector2D& position);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCharacterInfoScreen">();
	}
	static class UUMGCharacterInfoScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCharacterInfoScreen>();
	}
};
static_assert(alignof(UUMGCharacterInfoScreen) == 0x000008, "Wrong alignment on UUMGCharacterInfoScreen");
static_assert(sizeof(UUMGCharacterInfoScreen) == 0x0003D8, "Wrong size on UUMGCharacterInfoScreen");
static_assert(offsetof(UUMGCharacterInfoScreen, ContentPanel) == 0x000338, "Member 'UUMGCharacterInfoScreen::ContentPanel' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoScreen, SurvivorInfoWidgetClass) == 0x000340, "Member 'UUMGCharacterInfoScreen::SurvivorInfoWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoScreen, KillerInfoWidgetClass) == 0x000370, "Member 'UUMGCharacterInfoScreen::KillerInfoWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoScreen, ProgressionButton) == 0x0003A0, "Member 'UUMGCharacterInfoScreen::ProgressionButton' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoScreen, _onTeachableTooltipTriggeredLongPressEvent) == 0x0003A8, "Member 'UUMGCharacterInfoScreen::_onTeachableTooltipTriggeredLongPressEvent' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoScreen, _onPowerItemTooltipTriggeredLongPressEvent) == 0x0003B8, "Member 'UUMGCharacterInfoScreen::_onPowerItemTooltipTriggeredLongPressEvent' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoScreen, _onProgressionButtonClickEvent) == 0x0003C8, "Member 'UUMGCharacterInfoScreen::_onProgressionButtonClickEvent' has a wrong offset!");

// Class DeadByDaylight.TotemOutlineUpdateStrategy
// 0x0028 (0x0160 - 0x0138)
class UTotemOutlineUpdateStrategy final : public USourceBasedOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _revealedColorToSurvivor;                          // 0x0138(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _boonTotemRevealedColorToSurvivor;                 // 0x0148(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveLinearColor*                      _revealedColorToKiller;                            // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	struct FLinearColor GetRevealColorToSurvivor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TotemOutlineUpdateStrategy">();
	}
	static class UTotemOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTotemOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UTotemOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UTotemOutlineUpdateStrategy");
static_assert(sizeof(UTotemOutlineUpdateStrategy) == 0x000160, "Wrong size on UTotemOutlineUpdateStrategy");
static_assert(offsetof(UTotemOutlineUpdateStrategy, _revealedColorToSurvivor) == 0x000138, "Member 'UTotemOutlineUpdateStrategy::_revealedColorToSurvivor' has a wrong offset!");
static_assert(offsetof(UTotemOutlineUpdateStrategy, _boonTotemRevealedColorToSurvivor) == 0x000148, "Member 'UTotemOutlineUpdateStrategy::_boonTotemRevealedColorToSurvivor' has a wrong offset!");
static_assert(offsetof(UTotemOutlineUpdateStrategy, _revealedColorToKiller) == 0x000158, "Member 'UTotemOutlineUpdateStrategy::_revealedColorToKiller' has a wrong offset!");

// Class DeadByDaylight.TriggerableActivatorComponent
// 0x0040 (0x00F8 - 0x00B8)
class UTriggerableActivatorComponent final : public UActorComponent
{
public:
	TSoftClassPtr<class UClass>                   _triggerableClass;                                 // 0x00B8(0x0030)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTriggerableWorldObjectComponent*> _triggerables;                                   // 0x00E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Authority_OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriggerableActivatorComponent">();
	}
	static class UTriggerableActivatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriggerableActivatorComponent>();
	}
};
static_assert(alignof(UTriggerableActivatorComponent) == 0x000008, "Wrong alignment on UTriggerableActivatorComponent");
static_assert(sizeof(UTriggerableActivatorComponent) == 0x0000F8, "Wrong size on UTriggerableActivatorComponent");
static_assert(offsetof(UTriggerableActivatorComponent, _triggerableClass) == 0x0000B8, "Member 'UTriggerableActivatorComponent::_triggerableClass' has a wrong offset!");
static_assert(offsetof(UTriggerableActivatorComponent, _triggerables) == 0x0000E8, "Member 'UTriggerableActivatorComponent::_triggerables' has a wrong offset!");

// Class DeadByDaylight.TriplanarDecalComponent
// 0x0040 (0x0260 - 0x0220)
class UTriplanarDecalComponent final : public USceneComponent
{
public:
	float                                         MinHeight;                                         // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaskIntensity;                                     // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             TopTexture;                                        // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             BottomTexture;                                     // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MaskTexture;                                       // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDetailMode                                   MinQualitySetting;                                 // 0x0240(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDecalComponent*                        _triPlanarDecal;                                   // 0x0248(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 _triPlanarDecalClass;                              // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              _decalMaterial;                                    // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void UpdateTriplanarDecal();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TriplanarDecalComponent">();
	}
	static class UTriplanarDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTriplanarDecalComponent>();
	}
};
static_assert(alignof(UTriplanarDecalComponent) == 0x000010, "Wrong alignment on UTriplanarDecalComponent");
static_assert(sizeof(UTriplanarDecalComponent) == 0x000260, "Wrong size on UTriplanarDecalComponent");
static_assert(offsetof(UTriplanarDecalComponent, MinHeight) == 0x000218, "Member 'UTriplanarDecalComponent::MinHeight' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, Height) == 0x00021C, "Member 'UTriplanarDecalComponent::Height' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, MaskIntensity) == 0x000220, "Member 'UTriplanarDecalComponent::MaskIntensity' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, TopTexture) == 0x000228, "Member 'UTriplanarDecalComponent::TopTexture' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, BottomTexture) == 0x000230, "Member 'UTriplanarDecalComponent::BottomTexture' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, MaskTexture) == 0x000238, "Member 'UTriplanarDecalComponent::MaskTexture' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, MinQualitySetting) == 0x000240, "Member 'UTriplanarDecalComponent::MinQualitySetting' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, _triPlanarDecal) == 0x000248, "Member 'UTriplanarDecalComponent::_triPlanarDecal' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, _triPlanarDecalClass) == 0x000250, "Member 'UTriplanarDecalComponent::_triPlanarDecalClass' has a wrong offset!");
static_assert(offsetof(UTriplanarDecalComponent, _decalMaterial) == 0x000258, "Member 'UTriplanarDecalComponent::_decalMaterial' has a wrong offset!");

// Class DeadByDaylight.UMGCharacterPrestigeIcon
// 0x0008 (0x0340 - 0x0338)
class UUMGCharacterPrestigeIcon : public UMobileBaseUserWidget
{
public:
	class UImage*                                 PrestigeImage;                                     // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCharacterPrestigeIcon">();
	}
	static class UUMGCharacterPrestigeIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCharacterPrestigeIcon>();
	}
};
static_assert(alignof(UUMGCharacterPrestigeIcon) == 0x000008, "Wrong alignment on UUMGCharacterPrestigeIcon");
static_assert(sizeof(UUMGCharacterPrestigeIcon) == 0x000340, "Wrong size on UUMGCharacterPrestigeIcon");
static_assert(offsetof(UUMGCharacterPrestigeIcon, PrestigeImage) == 0x000338, "Member 'UUMGCharacterPrestigeIcon::PrestigeImage' has a wrong offset!");

// Class DeadByDaylight.UMGCharacterPrestigeButton
// 0x0028 (0x0368 - 0x0340)
class UUMGCharacterPrestigeButton final : public UUMGCharacterPrestigeIcon
{
public:
	class UButton*                                PrestigeButton;                                    // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           PrestigeAnimationCanvas;                           // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x18];                                     // 0x0350(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPrestigeButtonClicked();
	void SetCharacterPrestigeData(bool canPrestige, const int32 prestigeLevel, const EPlayerRole role);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCharacterPrestigeButton">();
	}
	static class UUMGCharacterPrestigeButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCharacterPrestigeButton>();
	}
};
static_assert(alignof(UUMGCharacterPrestigeButton) == 0x000008, "Wrong alignment on UUMGCharacterPrestigeButton");
static_assert(sizeof(UUMGCharacterPrestigeButton) == 0x000368, "Wrong size on UUMGCharacterPrestigeButton");
static_assert(offsetof(UUMGCharacterPrestigeButton, PrestigeButton) == 0x000340, "Member 'UUMGCharacterPrestigeButton::PrestigeButton' has a wrong offset!");
static_assert(offsetof(UUMGCharacterPrestigeButton, PrestigeAnimationCanvas) == 0x000348, "Member 'UUMGCharacterPrestigeButton::PrestigeAnimationCanvas' has a wrong offset!");

// Class DeadByDaylight.TutorialAssetLibrary
// 0x0010 (0x00C0 - 0x00B0)
class UTutorialAssetLibrary final : public UAssetLibrary
{
public:
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialAssetLibrary">();
	}
	static class UTutorialAssetLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialAssetLibrary>();
	}
};
static_assert(alignof(UTutorialAssetLibrary) == 0x000008, "Wrong alignment on UTutorialAssetLibrary");
static_assert(sizeof(UTutorialAssetLibrary) == 0x0000C0, "Wrong size on UTutorialAssetLibrary");

// Class DeadByDaylight.TutorialEndGameComponent
// 0x0008 (0x0160 - 0x0158)
class UTutorialEndGameComponent final : public UEndGameComponent
{
public:
	float                                         _timerMaxCompletionPercentage;                     // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTimerMaxCompletionPercentage(const float& percentage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialEndGameComponent">();
	}
	static class UTutorialEndGameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialEndGameComponent>();
	}
};
static_assert(alignof(UTutorialEndGameComponent) == 0x000008, "Wrong alignment on UTutorialEndGameComponent");
static_assert(sizeof(UTutorialEndGameComponent) == 0x000160, "Wrong size on UTutorialEndGameComponent");
static_assert(offsetof(UTutorialEndGameComponent, _timerMaxCompletionPercentage) == 0x000158, "Member 'UTutorialEndGameComponent::_timerMaxCompletionPercentage' has a wrong offset!");

// Class DeadByDaylight.TutorialGameMode
// 0x0038 (0x03B0 - 0x0378)
class ATutorialGameMode final : public ADBDBaseMatchGameMode
{
public:
	uint8                                         Pad_378[0x10];                                     // 0x0378(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTutorialObjectiveController*           _tutorialObjectiveController;                      // 0x0388(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTutorialNotificationController*        _tutorialNotificationController;                   // 0x0390(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTutorialHighlightController*           _tutorialHighlightController;                      // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAtlantaTutorialPlayerHudController*    _atlantaTutorialPlayerHudController;               // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetEscapeActivated();
	void SetEscapeGenerators(const TArray<class AGenerator*>& escapeGenerators, int32 requiredActivationCount);

	class UAtlantaTutorialPlayerHudController* GetAtlantaTutorialPlayerHudController() const;
	class UTutorialHighlightController* GetTutorialHighlightController() const;
	class UTutorialNotificationController* GetTutorialNotificationController() const;
	class UTutorialObjectiveController* GetTutorialObjectiveController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialGameMode">();
	}
	static class ATutorialGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialGameMode>();
	}
};
static_assert(alignof(ATutorialGameMode) == 0x000008, "Wrong alignment on ATutorialGameMode");
static_assert(sizeof(ATutorialGameMode) == 0x0003B0, "Wrong size on ATutorialGameMode");
static_assert(offsetof(ATutorialGameMode, _tutorialObjectiveController) == 0x000388, "Member 'ATutorialGameMode::_tutorialObjectiveController' has a wrong offset!");
static_assert(offsetof(ATutorialGameMode, _tutorialNotificationController) == 0x000390, "Member 'ATutorialGameMode::_tutorialNotificationController' has a wrong offset!");
static_assert(offsetof(ATutorialGameMode, _tutorialHighlightController) == 0x000398, "Member 'ATutorialGameMode::_tutorialHighlightController' has a wrong offset!");
static_assert(offsetof(ATutorialGameMode, _atlantaTutorialPlayerHudController) == 0x0003A0, "Member 'ATutorialGameMode::_atlantaTutorialPlayerHudController' has a wrong offset!");

// Class DeadByDaylight.TutorialHighlightController
// 0x0018 (0x0048 - 0x0030)
class UTutorialHighlightController final : public UObject
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHudComponentHighlight(EHudComponent hudComponent, bool show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialHighlightController">();
	}
	static class UTutorialHighlightController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialHighlightController>();
	}
};
static_assert(alignof(UTutorialHighlightController) == 0x000008, "Wrong alignment on UTutorialHighlightController");
static_assert(sizeof(UTutorialHighlightController) == 0x000048, "Wrong size on UTutorialHighlightController");

// Class DeadByDaylight.TutorialObjectiveController
// 0x00B0 (0x00E0 - 0x0030)
class UTutorialObjectiveController final : public UObject
{
public:
	uint8                                         Pad_30[0xB0];                                      // 0x0030(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddObjective(class FName tutorialObjectiveId);
	void CompleteObjective(class FName tutorialObjectiveId, bool removeAfterCompletion);
	void RemoveAllObjectives();
	void RemoveObjective(class FName tutorialObjectiveId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialObjectiveController">();
	}
	static class UTutorialObjectiveController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialObjectiveController>();
	}
};
static_assert(alignof(UTutorialObjectiveController) == 0x000008, "Wrong alignment on UTutorialObjectiveController");
static_assert(sizeof(UTutorialObjectiveController) == 0x0000E0, "Wrong size on UTutorialObjectiveController");

// Class DeadByDaylight.UMGPlayerRankInfo
// 0x0060 (0x0398 - 0x0338)
class UUMGPlayerRankInfo final : public UMobileBaseUserWidget
{
public:
	class UUMGTallyPipsContainer*                 PipsContainerWidget;                               // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGTallyRankFrame*                     RankFrameWidget;                                   // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Background;                                        // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TitleLabel;                                        // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RankLabel;                                         // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PipLabel;                                          // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           HighlightContainer;                                // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _survivorColorBackground;                          // 0x0370(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _killerColorBackground;                            // 0x0380(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _disableOpacity;                                   // 0x0390(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetData(int32 rank, int32 pipsRequiredForNextRank, int32 filledPips, const class FText& titleLabel, const class FText& pipLabel, EPlayerRole playerRole, bool IsHighlight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPlayerRankInfo">();
	}
	static class UUMGPlayerRankInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPlayerRankInfo>();
	}
};
static_assert(alignof(UUMGPlayerRankInfo) == 0x000008, "Wrong alignment on UUMGPlayerRankInfo");
static_assert(sizeof(UUMGPlayerRankInfo) == 0x000398, "Wrong size on UUMGPlayerRankInfo");
static_assert(offsetof(UUMGPlayerRankInfo, PipsContainerWidget) == 0x000338, "Member 'UUMGPlayerRankInfo::PipsContainerWidget' has a wrong offset!");
static_assert(offsetof(UUMGPlayerRankInfo, RankFrameWidget) == 0x000340, "Member 'UUMGPlayerRankInfo::RankFrameWidget' has a wrong offset!");
static_assert(offsetof(UUMGPlayerRankInfo, Background) == 0x000348, "Member 'UUMGPlayerRankInfo::Background' has a wrong offset!");
static_assert(offsetof(UUMGPlayerRankInfo, TitleLabel) == 0x000350, "Member 'UUMGPlayerRankInfo::TitleLabel' has a wrong offset!");
static_assert(offsetof(UUMGPlayerRankInfo, RankLabel) == 0x000358, "Member 'UUMGPlayerRankInfo::RankLabel' has a wrong offset!");
static_assert(offsetof(UUMGPlayerRankInfo, PipLabel) == 0x000360, "Member 'UUMGPlayerRankInfo::PipLabel' has a wrong offset!");
static_assert(offsetof(UUMGPlayerRankInfo, HighlightContainer) == 0x000368, "Member 'UUMGPlayerRankInfo::HighlightContainer' has a wrong offset!");
static_assert(offsetof(UUMGPlayerRankInfo, _survivorColorBackground) == 0x000370, "Member 'UUMGPlayerRankInfo::_survivorColorBackground' has a wrong offset!");
static_assert(offsetof(UUMGPlayerRankInfo, _killerColorBackground) == 0x000380, "Member 'UUMGPlayerRankInfo::_killerColorBackground' has a wrong offset!");
static_assert(offsetof(UUMGPlayerRankInfo, _disableOpacity) == 0x000390, "Member 'UUMGPlayerRankInfo::_disableOpacity' has a wrong offset!");

// Class DeadByDaylight.TutorialsUtilities
// 0x0038 (0x0268 - 0x0230)
class ATutorialsUtilities final : public AActor
{
public:
	TMulticastInlineDelegate<void()>              OnTutorialUIReady;                                 // 0x0230(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x28];                                     // 0x0240(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void DestroyAI(class AAIController* aiController);
	static class ATutorialsUtilities* GetTutorialsUtilities(class UObject* WorldContextObject);

	void TriggerTutorialHudFadeIn();
	void TriggerTutorialHudFadeOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialsUtilities">();
	}
	static class ATutorialsUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATutorialsUtilities>();
	}
};
static_assert(alignof(ATutorialsUtilities) == 0x000008, "Wrong alignment on ATutorialsUtilities");
static_assert(sizeof(ATutorialsUtilities) == 0x000268, "Wrong size on ATutorialsUtilities");
static_assert(offsetof(ATutorialsUtilities, OnTutorialUIReady) == 0x000230, "Member 'ATutorialsUtilities::OnTutorialUIReady' has a wrong offset!");

// Class DeadByDaylight.AnimationWidget
// 0x0008 (0x02A0 - 0x0298)
class UAnimationWidget final : public UUserWidget
{
public:
	float                                         _playRate;                                         // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPlayRate(float rate);

	float GetPlayRate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationWidget">();
	}
	static class UAnimationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationWidget>();
	}
};
static_assert(alignof(UAnimationWidget) == 0x000008, "Wrong alignment on UAnimationWidget");
static_assert(sizeof(UAnimationWidget) == 0x0002A0, "Wrong size on UAnimationWidget");
static_assert(offsetof(UAnimationWidget, _playRate) == 0x000298, "Member 'UAnimationWidget::_playRate' has a wrong offset!");

// Class DeadByDaylight.UMGAddonButton
// 0x0000 (0x0678 - 0x0678)
class UUMGAddonButton final : public UUMGInventoryItemButton
{
public:
	void UpdateAddonButton(class UItemAddon* addon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAddonButton">();
	}
	static class UUMGAddonButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAddonButton>();
	}
};
static_assert(alignof(UUMGAddonButton) == 0x000008, "Wrong alignment on UUMGAddonButton");
static_assert(sizeof(UUMGAddonButton) == 0x000678, "Wrong size on UUMGAddonButton");

// Class DeadByDaylight.UMGAtlantaBaseEventsTemplate
// 0x0000 (0x0338 - 0x0338)
class UUMGAtlantaBaseEventsTemplate : public UMobileBaseUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaBaseEventsTemplate">();
	}
	static class UUMGAtlantaBaseEventsTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaBaseEventsTemplate>();
	}
};
static_assert(alignof(UUMGAtlantaBaseEventsTemplate) == 0x000008, "Wrong alignment on UUMGAtlantaBaseEventsTemplate");
static_assert(sizeof(UUMGAtlantaBaseEventsTemplate) == 0x000338, "Wrong size on UUMGAtlantaBaseEventsTemplate");

// Class DeadByDaylight.UMGBaseCurrencyButtonWidget
// 0x00A8 (0x0510 - 0x0468)
class UUMGBaseCurrencyButtonWidget : public UUMGBaseButtonWidget
{
public:
	class UImage*                                 FXImage;                                           // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CurrencyColorImage;                                // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CurrencyIcon;                                      // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PriceText;                                         // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            AffordableColor;                                   // 0x0488(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            NotAffordableColor;                                // 0x04B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           DisabledOpacity;                                   // 0x04D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           EnabledOpacity;                                    // 0x04E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F8[0x18];                                     // 0x04F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBaseCurrencyButtonWidget">();
	}
	static class UUMGBaseCurrencyButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBaseCurrencyButtonWidget>();
	}
};
static_assert(alignof(UUMGBaseCurrencyButtonWidget) == 0x000008, "Wrong alignment on UUMGBaseCurrencyButtonWidget");
static_assert(sizeof(UUMGBaseCurrencyButtonWidget) == 0x000510, "Wrong size on UUMGBaseCurrencyButtonWidget");
static_assert(offsetof(UUMGBaseCurrencyButtonWidget, FXImage) == 0x000468, "Member 'UUMGBaseCurrencyButtonWidget::FXImage' has a wrong offset!");
static_assert(offsetof(UUMGBaseCurrencyButtonWidget, CurrencyColorImage) == 0x000470, "Member 'UUMGBaseCurrencyButtonWidget::CurrencyColorImage' has a wrong offset!");
static_assert(offsetof(UUMGBaseCurrencyButtonWidget, CurrencyIcon) == 0x000478, "Member 'UUMGBaseCurrencyButtonWidget::CurrencyIcon' has a wrong offset!");
static_assert(offsetof(UUMGBaseCurrencyButtonWidget, PriceText) == 0x000480, "Member 'UUMGBaseCurrencyButtonWidget::PriceText' has a wrong offset!");
static_assert(offsetof(UUMGBaseCurrencyButtonWidget, AffordableColor) == 0x000488, "Member 'UUMGBaseCurrencyButtonWidget::AffordableColor' has a wrong offset!");
static_assert(offsetof(UUMGBaseCurrencyButtonWidget, NotAffordableColor) == 0x0004B0, "Member 'UUMGBaseCurrencyButtonWidget::NotAffordableColor' has a wrong offset!");
static_assert(offsetof(UUMGBaseCurrencyButtonWidget, DisabledOpacity) == 0x0004D8, "Member 'UUMGBaseCurrencyButtonWidget::DisabledOpacity' has a wrong offset!");
static_assert(offsetof(UUMGBaseCurrencyButtonWidget, EnabledOpacity) == 0x0004E8, "Member 'UUMGBaseCurrencyButtonWidget::EnabledOpacity' has a wrong offset!");

// Class DeadByDaylight.UMGPromoPackPurchaseCurrencyButtonWidget
// 0x0020 (0x0530 - 0x0510)
class UUMGPromoPackPurchaseCurrencyButtonWidget final : public UUMGBaseCurrencyButtonWidget
{
public:
	class UTextBlock*                             PercentageDiscountText;                            // 0x0510(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             UndiscountedPrice;                                 // 0x0518(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           PercentageDiscountCanvas;                          // 0x0520(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OverlayUndiscountedPrice;                          // 0x0528(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPromoPackPurchaseCurrencyButtonWidget">();
	}
	static class UUMGPromoPackPurchaseCurrencyButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPromoPackPurchaseCurrencyButtonWidget>();
	}
};
static_assert(alignof(UUMGPromoPackPurchaseCurrencyButtonWidget) == 0x000008, "Wrong alignment on UUMGPromoPackPurchaseCurrencyButtonWidget");
static_assert(sizeof(UUMGPromoPackPurchaseCurrencyButtonWidget) == 0x000530, "Wrong size on UUMGPromoPackPurchaseCurrencyButtonWidget");
static_assert(offsetof(UUMGPromoPackPurchaseCurrencyButtonWidget, PercentageDiscountText) == 0x000510, "Member 'UUMGPromoPackPurchaseCurrencyButtonWidget::PercentageDiscountText' has a wrong offset!");
static_assert(offsetof(UUMGPromoPackPurchaseCurrencyButtonWidget, UndiscountedPrice) == 0x000518, "Member 'UUMGPromoPackPurchaseCurrencyButtonWidget::UndiscountedPrice' has a wrong offset!");
static_assert(offsetof(UUMGPromoPackPurchaseCurrencyButtonWidget, PercentageDiscountCanvas) == 0x000520, "Member 'UUMGPromoPackPurchaseCurrencyButtonWidget::PercentageDiscountCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPromoPackPurchaseCurrencyButtonWidget, OverlayUndiscountedPrice) == 0x000528, "Member 'UUMGPromoPackPurchaseCurrencyButtonWidget::OverlayUndiscountedPrice' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaBonusACEventTemplate
// 0x0028 (0x0360 - 0x0338)
class UUMGAtlantaBonusACEventTemplate final : public UUMGAtlantaBaseEventsTemplate
{
public:
	class UUMGAtlCurrencyStorefrontWidget*        currencyStorefrontWidget;                          // 0x0338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 LastPackSmallIconPath;                             // 0x0340(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InitialSize;                                       // 0x0350(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AugmentedSize;                                     // 0x0354(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNumberOfPacksToShowBigger;                      // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaBonusACEventTemplate">();
	}
	static class UUMGAtlantaBonusACEventTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaBonusACEventTemplate>();
	}
};
static_assert(alignof(UUMGAtlantaBonusACEventTemplate) == 0x000008, "Wrong alignment on UUMGAtlantaBonusACEventTemplate");
static_assert(sizeof(UUMGAtlantaBonusACEventTemplate) == 0x000360, "Wrong size on UUMGAtlantaBonusACEventTemplate");
static_assert(offsetof(UUMGAtlantaBonusACEventTemplate, currencyStorefrontWidget) == 0x000338, "Member 'UUMGAtlantaBonusACEventTemplate::currencyStorefrontWidget' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaBonusACEventTemplate, LastPackSmallIconPath) == 0x000340, "Member 'UUMGAtlantaBonusACEventTemplate::LastPackSmallIconPath' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaBonusACEventTemplate, InitialSize) == 0x000350, "Member 'UUMGAtlantaBonusACEventTemplate::InitialSize' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaBonusACEventTemplate, AugmentedSize) == 0x000354, "Member 'UUMGAtlantaBonusACEventTemplate::AugmentedSize' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaBonusACEventTemplate, MaxNumberOfPacksToShowBigger) == 0x000358, "Member 'UUMGAtlantaBonusACEventTemplate::MaxNumberOfPacksToShowBigger' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaCalendarEventsTemplate
// 0x0008 (0x0340 - 0x0338)
class UUMGAtlantaCalendarEventsTemplate final : public UUMGAtlantaBaseEventsTemplate
{
public:
	class UUMGAtlantaDailyRewardsGrid*            DailyRewardGrid;                                   // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaCalendarEventsTemplate">();
	}
	static class UUMGAtlantaCalendarEventsTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaCalendarEventsTemplate>();
	}
};
static_assert(alignof(UUMGAtlantaCalendarEventsTemplate) == 0x000008, "Wrong alignment on UUMGAtlantaCalendarEventsTemplate");
static_assert(sizeof(UUMGAtlantaCalendarEventsTemplate) == 0x000340, "Wrong size on UUMGAtlantaCalendarEventsTemplate");
static_assert(offsetof(UUMGAtlantaCalendarEventsTemplate, DailyRewardGrid) == 0x000338, "Member 'UUMGAtlantaCalendarEventsTemplate::DailyRewardGrid' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaEventsDescription
// 0x0078 (0x03B0 - 0x0338)
class UUMGAtlantaEventsDescription final : public UMobileBaseUserWidget
{
public:
	class UAtlantaEventsTemplateDataAsset*        widgetData;                                        // 0x0338(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ItemsRewards;                                      // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Title;                                             // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Description;                                       // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TimePeriodTitle;                                   // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TimePeriodStart;                                   // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TimePeriodEnd;                                     // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBaseButtonWidget*                   DeepLinkButton;                                    // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           TimePeriodCanvas;                                  // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGAtlantaBaseEventsTemplate*          _eventTemplate;                                    // 0x0380(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x28];                                     // 0x0388(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaEventsDescription">();
	}
	static class UUMGAtlantaEventsDescription* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaEventsDescription>();
	}
};
static_assert(alignof(UUMGAtlantaEventsDescription) == 0x000008, "Wrong alignment on UUMGAtlantaEventsDescription");
static_assert(sizeof(UUMGAtlantaEventsDescription) == 0x0003B0, "Wrong size on UUMGAtlantaEventsDescription");
static_assert(offsetof(UUMGAtlantaEventsDescription, widgetData) == 0x000338, "Member 'UUMGAtlantaEventsDescription::widgetData' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsDescription, ItemsRewards) == 0x000340, "Member 'UUMGAtlantaEventsDescription::ItemsRewards' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsDescription, Title) == 0x000348, "Member 'UUMGAtlantaEventsDescription::Title' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsDescription, Description) == 0x000350, "Member 'UUMGAtlantaEventsDescription::Description' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsDescription, TimePeriodTitle) == 0x000358, "Member 'UUMGAtlantaEventsDescription::TimePeriodTitle' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsDescription, TimePeriodStart) == 0x000360, "Member 'UUMGAtlantaEventsDescription::TimePeriodStart' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsDescription, TimePeriodEnd) == 0x000368, "Member 'UUMGAtlantaEventsDescription::TimePeriodEnd' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsDescription, DeepLinkButton) == 0x000370, "Member 'UUMGAtlantaEventsDescription::DeepLinkButton' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsDescription, TimePeriodCanvas) == 0x000378, "Member 'UUMGAtlantaEventsDescription::TimePeriodCanvas' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsDescription, _eventTemplate) == 0x000380, "Member 'UUMGAtlantaEventsDescription::_eventTemplate' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaEventsScreen
// 0x0080 (0x03B8 - 0x0338)
class UUMGAtlantaEventsScreen final : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             PageTitle;                                         // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWrapBox*                               WrapBox;                                           // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGAtlantaEventsDescription*           DescriptionWidget;                                 // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUMGAtlantaEventsTab>       EventsTabWBPReference;                             // 0x0350(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUMGAtlantaEventsTab*>           _eventsArray;                                      // 0x0358(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_368[0x50];                                     // 0x0368(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastDeepLinkRequest(const class FString& id);
	void BroadcastOnCloseButtonClicked();
	void HandleEventTabClicked(const class FString& id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaEventsScreen">();
	}
	static class UUMGAtlantaEventsScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaEventsScreen>();
	}
};
static_assert(alignof(UUMGAtlantaEventsScreen) == 0x000008, "Wrong alignment on UUMGAtlantaEventsScreen");
static_assert(sizeof(UUMGAtlantaEventsScreen) == 0x0003B8, "Wrong size on UUMGAtlantaEventsScreen");
static_assert(offsetof(UUMGAtlantaEventsScreen, PageTitle) == 0x000338, "Member 'UUMGAtlantaEventsScreen::PageTitle' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsScreen, WrapBox) == 0x000340, "Member 'UUMGAtlantaEventsScreen::WrapBox' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsScreen, DescriptionWidget) == 0x000348, "Member 'UUMGAtlantaEventsScreen::DescriptionWidget' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsScreen, EventsTabWBPReference) == 0x000350, "Member 'UUMGAtlantaEventsScreen::EventsTabWBPReference' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsScreen, _eventsArray) == 0x000358, "Member 'UUMGAtlantaEventsScreen::_eventsArray' has a wrong offset!");

// Class DeadByDaylight.VaultFastDefintion
// 0x0000 (0x0660 - 0x0660)
class UVaultFastDefintion final : public UVaultDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultFastDefintion">();
	}
	static class UVaultFastDefintion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultFastDefintion>();
	}
};
static_assert(alignof(UVaultFastDefintion) == 0x000010, "Wrong alignment on UVaultFastDefintion");
static_assert(sizeof(UVaultFastDefintion) == 0x000660, "Wrong size on UVaultFastDefintion");

// Class DeadByDaylight.UMGAtlantaEventsTab
// 0x0040 (0x04A8 - 0x0468)
class UUMGAtlantaEventsTab final : public UUMGBaseButtonWidget
{
public:
	class FString                                 _eventId;                                          // 0x0468(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             HotTagText;                                        // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NewTagText;                                        // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_488[0x20];                                     // 0x0488(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetHotTag();
	void SetNewTag();
	void SetSelectionVisuals(bool isSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaEventsTab">();
	}
	static class UUMGAtlantaEventsTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaEventsTab>();
	}
};
static_assert(alignof(UUMGAtlantaEventsTab) == 0x000008, "Wrong alignment on UUMGAtlantaEventsTab");
static_assert(sizeof(UUMGAtlantaEventsTab) == 0x0004A8, "Wrong size on UUMGAtlantaEventsTab");
static_assert(offsetof(UUMGAtlantaEventsTab, _eventId) == 0x000468, "Member 'UUMGAtlantaEventsTab::_eventId' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsTab, HotTagText) == 0x000478, "Member 'UUMGAtlantaEventsTab::HotTagText' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaEventsTab, NewTagText) == 0x000480, "Member 'UUMGAtlantaEventsTab::NewTagText' has a wrong offset!");

// Class DeadByDaylight.UMGRichTextFreeTicketDecorator
// 0x0988 (0x09B8 - 0x0030)
class UUMGRichTextFreeTicketDecorator final : public URichTextBlockDecorator
{
public:
	struct FVector2D                              FreeTicketOverrideSize;                            // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRichTextFreeTicketImageInfo           FreeTicketIcon;                                    // 0x0038(0x00A0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRichTextFreeTicketImageInfo           FreeTicketBG;                                      // 0x00D8(0x00A0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRichTextFreeTicketTextInfo            FreeTicketDurationTitle;                           // 0x0178(0x02B0)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRichTextFreeTicketTextInfo            FreeTicketTitle;                                   // 0x0428(0x02B0)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FRichTextFreeTicketTextInfo            FreeTicketDurationInHours;                         // 0x06D8(0x02B0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UDataTable*                             TitleStyleSet;                                     // 0x0988(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_990[0x28];                                     // 0x0990(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGRichTextFreeTicketDecorator">();
	}
	static class UUMGRichTextFreeTicketDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGRichTextFreeTicketDecorator>();
	}
};
static_assert(alignof(UUMGRichTextFreeTicketDecorator) == 0x000008, "Wrong alignment on UUMGRichTextFreeTicketDecorator");
static_assert(sizeof(UUMGRichTextFreeTicketDecorator) == 0x0009B8, "Wrong size on UUMGRichTextFreeTicketDecorator");
static_assert(offsetof(UUMGRichTextFreeTicketDecorator, FreeTicketOverrideSize) == 0x000030, "Member 'UUMGRichTextFreeTicketDecorator::FreeTicketOverrideSize' has a wrong offset!");
static_assert(offsetof(UUMGRichTextFreeTicketDecorator, FreeTicketIcon) == 0x000038, "Member 'UUMGRichTextFreeTicketDecorator::FreeTicketIcon' has a wrong offset!");
static_assert(offsetof(UUMGRichTextFreeTicketDecorator, FreeTicketBG) == 0x0000D8, "Member 'UUMGRichTextFreeTicketDecorator::FreeTicketBG' has a wrong offset!");
static_assert(offsetof(UUMGRichTextFreeTicketDecorator, FreeTicketDurationTitle) == 0x000178, "Member 'UUMGRichTextFreeTicketDecorator::FreeTicketDurationTitle' has a wrong offset!");
static_assert(offsetof(UUMGRichTextFreeTicketDecorator, FreeTicketTitle) == 0x000428, "Member 'UUMGRichTextFreeTicketDecorator::FreeTicketTitle' has a wrong offset!");
static_assert(offsetof(UUMGRichTextFreeTicketDecorator, FreeTicketDurationInHours) == 0x0006D8, "Member 'UUMGRichTextFreeTicketDecorator::FreeTicketDurationInHours' has a wrong offset!");
static_assert(offsetof(UUMGRichTextFreeTicketDecorator, TitleStyleSet) == 0x000988, "Member 'UUMGRichTextFreeTicketDecorator::TitleStyleSet' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaFreeTicketConfirmToUsePopup
// 0x03F0 (0x0810 - 0x0420)
class alignas(0x10) UUMGAtlantaFreeTicketConfirmToUsePopup final : public UUMGGenericPopup
{
public:
	class UTexture2D*                             FreeTicketIcon;                                    // 0x0420(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   PopupTitleContent;                                 // 0x0428(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_440[0x3D0];                                    // 0x0440(0x03D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UUMGRichTextFreeTicketDecorator* GetDecorator();
	void SetFreeTicketIconTexture(bool isSlasher);
	void SetPopupTitle(const class FText& characterName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaFreeTicketConfirmToUsePopup">();
	}
	static class UUMGAtlantaFreeTicketConfirmToUsePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaFreeTicketConfirmToUsePopup>();
	}
};
static_assert(alignof(UUMGAtlantaFreeTicketConfirmToUsePopup) == 0x000010, "Wrong alignment on UUMGAtlantaFreeTicketConfirmToUsePopup");
static_assert(sizeof(UUMGAtlantaFreeTicketConfirmToUsePopup) == 0x000810, "Wrong size on UUMGAtlantaFreeTicketConfirmToUsePopup");
static_assert(offsetof(UUMGAtlantaFreeTicketConfirmToUsePopup, FreeTicketIcon) == 0x000420, "Member 'UUMGAtlantaFreeTicketConfirmToUsePopup::FreeTicketIcon' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaFreeTicketConfirmToUsePopup, PopupTitleContent) == 0x000428, "Member 'UUMGAtlantaFreeTicketConfirmToUsePopup::PopupTitleContent' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaGenericEventTemplate
// 0x0020 (0x0358 - 0x0338)
class UUMGAtlantaGenericEventTemplate final : public UUMGAtlantaBaseEventsTemplate
{
public:
	class UHorizontalBox*                         RelatedItemsBox;                                   // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUMGAtlantaEventsElement>   EventsElementWBPReference;                         // 0x0340(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUMGPromoPackItemWidget>    CustomizationWBPReference;                         // 0x0348(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUMGPromoPackItemWidget>    CharacterWBPReference;                             // 0x0350(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaGenericEventTemplate">();
	}
	static class UUMGAtlantaGenericEventTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaGenericEventTemplate>();
	}
};
static_assert(alignof(UUMGAtlantaGenericEventTemplate) == 0x000008, "Wrong alignment on UUMGAtlantaGenericEventTemplate");
static_assert(sizeof(UUMGAtlantaGenericEventTemplate) == 0x000358, "Wrong size on UUMGAtlantaGenericEventTemplate");
static_assert(offsetof(UUMGAtlantaGenericEventTemplate, RelatedItemsBox) == 0x000338, "Member 'UUMGAtlantaGenericEventTemplate::RelatedItemsBox' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaGenericEventTemplate, EventsElementWBPReference) == 0x000340, "Member 'UUMGAtlantaGenericEventTemplate::EventsElementWBPReference' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaGenericEventTemplate, CustomizationWBPReference) == 0x000348, "Member 'UUMGAtlantaGenericEventTemplate::CustomizationWBPReference' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaGenericEventTemplate, CharacterWBPReference) == 0x000350, "Member 'UUMGAtlantaGenericEventTemplate::CharacterWBPReference' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaLevelUpPopup
// 0x0000 (0x0420 - 0x0420)
class UUMGAtlantaLevelUpPopup final : public UUMGGenericPopup
{
public:
	void OnSetData(int32 level, int32 prestige, bool prestigeIncreased, const TArray<struct FRewardItemData>& rewards);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaLevelUpPopup">();
	}
	static class UUMGAtlantaLevelUpPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaLevelUpPopup>();
	}
};
static_assert(alignof(UUMGAtlantaLevelUpPopup) == 0x000008, "Wrong alignment on UUMGAtlantaLevelUpPopup");
static_assert(sizeof(UUMGAtlantaLevelUpPopup) == 0x000420, "Wrong size on UUMGAtlantaLevelUpPopup");

// Class DeadByDaylight.WalletHandler
// 0x0140 (0x0170 - 0x0030)
class UWalletHandler final : public UObject
{
public:
	uint8                                         Pad_30[0x140];                                     // 0x0030(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WalletHandler">();
	}
	static class UWalletHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWalletHandler>();
	}
};
static_assert(alignof(UWalletHandler) == 0x000008, "Wrong alignment on UWalletHandler");
static_assert(sizeof(UWalletHandler) == 0x000170, "Wrong size on UWalletHandler");

// Class DeadByDaylight.UMGAtlantaMonthlyPassEventTemplate
// 0x0008 (0x0340 - 0x0338)
class UUMGAtlantaMonthlyPassEventTemplate final : public UUMGAtlantaBaseEventsTemplate
{
public:
	class UUMGSubscriptionPackButtonWidget*       MonthlyPassWidget;                                 // 0x0338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaMonthlyPassEventTemplate">();
	}
	static class UUMGAtlantaMonthlyPassEventTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaMonthlyPassEventTemplate>();
	}
};
static_assert(alignof(UUMGAtlantaMonthlyPassEventTemplate) == 0x000008, "Wrong alignment on UUMGAtlantaMonthlyPassEventTemplate");
static_assert(sizeof(UUMGAtlantaMonthlyPassEventTemplate) == 0x000340, "Wrong size on UUMGAtlantaMonthlyPassEventTemplate");
static_assert(offsetof(UUMGAtlantaMonthlyPassEventTemplate, MonthlyPassWidget) == 0x000338, "Member 'UUMGAtlantaMonthlyPassEventTemplate::MonthlyPassWidget' has a wrong offset!");

// Class DeadByDaylight.UMGSelectedCharacterWidget
// 0x0048 (0x0380 - 0x0338)
class UUMGSelectedCharacterWidget final : public UMobileBaseUserWidget
{
public:
	class UUMGCharacterPrestigeButton*            PrestigeButton;                                    // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CharacterNameText;                                 // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CharacterLevelText;                                // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           CharacterLevelVerticalBox;                         // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LeaderIcon;                                        // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              _onCancelPartyButtonClick;                         // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)

public:
	void OnPrestigeButtonClicked();
	void SetVisualsForPartyState(const bool triggerPartyVisuals);
	void SetVisualsForReadyState(const bool isPlayerReady);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSelectedCharacterWidget">();
	}
	static class UUMGSelectedCharacterWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSelectedCharacterWidget>();
	}
};
static_assert(alignof(UUMGSelectedCharacterWidget) == 0x000008, "Wrong alignment on UUMGSelectedCharacterWidget");
static_assert(sizeof(UUMGSelectedCharacterWidget) == 0x000380, "Wrong size on UUMGSelectedCharacterWidget");
static_assert(offsetof(UUMGSelectedCharacterWidget, PrestigeButton) == 0x000338, "Member 'UUMGSelectedCharacterWidget::PrestigeButton' has a wrong offset!");
static_assert(offsetof(UUMGSelectedCharacterWidget, CharacterNameText) == 0x000340, "Member 'UUMGSelectedCharacterWidget::CharacterNameText' has a wrong offset!");
static_assert(offsetof(UUMGSelectedCharacterWidget, CharacterLevelText) == 0x000348, "Member 'UUMGSelectedCharacterWidget::CharacterLevelText' has a wrong offset!");
static_assert(offsetof(UUMGSelectedCharacterWidget, CharacterLevelVerticalBox) == 0x000350, "Member 'UUMGSelectedCharacterWidget::CharacterLevelVerticalBox' has a wrong offset!");
static_assert(offsetof(UUMGSelectedCharacterWidget, LeaderIcon) == 0x000358, "Member 'UUMGSelectedCharacterWidget::LeaderIcon' has a wrong offset!");
static_assert(offsetof(UUMGSelectedCharacterWidget, _onCancelPartyButtonClick) == 0x000370, "Member 'UUMGSelectedCharacterWidget::_onCancelPartyButtonClick' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaRankUpPopup
// 0x0048 (0x0468 - 0x0420)
class UUMGAtlantaRankUpPopup final : public UUMGGenericPopup
{
public:
	class UUMGTallyRankBanner*                    RankBanner;                                        // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         RewardsContainer;                                  // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           RewardsSection;                                    // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   RewardWidgetClass;                                 // 0x0438(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PlayRankUpBannerAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaRankUpPopup">();
	}
	static class UUMGAtlantaRankUpPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaRankUpPopup>();
	}
};
static_assert(alignof(UUMGAtlantaRankUpPopup) == 0x000008, "Wrong alignment on UUMGAtlantaRankUpPopup");
static_assert(sizeof(UUMGAtlantaRankUpPopup) == 0x000468, "Wrong size on UUMGAtlantaRankUpPopup");
static_assert(offsetof(UUMGAtlantaRankUpPopup, RankBanner) == 0x000420, "Member 'UUMGAtlantaRankUpPopup::RankBanner' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaRankUpPopup, RewardsContainer) == 0x000428, "Member 'UUMGAtlantaRankUpPopup::RewardsContainer' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaRankUpPopup, RewardsSection) == 0x000430, "Member 'UUMGAtlantaRankUpPopup::RewardsSection' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaRankUpPopup, RewardWidgetClass) == 0x000438, "Member 'UUMGAtlantaRankUpPopup::RewardWidgetClass' has a wrong offset!");

// Class DeadByDaylight.UMGAltantaRitual
// 0x0058 (0x0390 - 0x0338)
class UUMGAltantaRitual final : public UMobileBaseUserWidget
{
public:
	class FText                                   _claimText;                                        // 0x0338(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _claimedText;                                      // 0x0350(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _completedText;                                    // 0x0368(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_380[0x10];                                     // 0x0380(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastOnClaimRewardsButtonPressed(const int32 ritualId);
	void SetData(const struct FAtlantaRitualUIData& ritual);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAltantaRitual">();
	}
	static class UUMGAltantaRitual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAltantaRitual>();
	}
};
static_assert(alignof(UUMGAltantaRitual) == 0x000008, "Wrong alignment on UUMGAltantaRitual");
static_assert(sizeof(UUMGAltantaRitual) == 0x000390, "Wrong size on UUMGAltantaRitual");
static_assert(offsetof(UUMGAltantaRitual, _claimText) == 0x000338, "Member 'UUMGAltantaRitual::_claimText' has a wrong offset!");
static_assert(offsetof(UUMGAltantaRitual, _claimedText) == 0x000350, "Member 'UUMGAltantaRitual::_claimedText' has a wrong offset!");
static_assert(offsetof(UUMGAltantaRitual, _completedText) == 0x000368, "Member 'UUMGAltantaRitual::_completedText' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaRitualsScreen
// 0x00F0 (0x0428 - 0x0338)
class UUMGAtlantaRitualsScreen final : public UMobileBaseUserWidget
{
public:
	class UUMGAtlantaRitualTab*                   DailyTab;                                          // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGAtlantaRitualTab*                   WeeklyTab;                                         // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _atlantaRitualTitle;                               // 0x0348(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _endInLabel;                                       // 0x0360(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _dailyButtonLabel;                                 // 0x0378(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _weeklyButtonLabel;                                // 0x0390(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _dailyRemainingTime;                               // 0x03A8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _weeklyRemainingTime;                              // 0x03C0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x50];                                     // 0x03D8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastOnBackButtonPressed();
	void BroadcastOnClaimRewardButtonPressed(const int32 ritualId);
	void SetNewRitualNumbers(int32 newDailyRitualNumber, int32 newWeeklyRitualNumber);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaRitualsScreen">();
	}
	static class UUMGAtlantaRitualsScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaRitualsScreen>();
	}
};
static_assert(alignof(UUMGAtlantaRitualsScreen) == 0x000008, "Wrong alignment on UUMGAtlantaRitualsScreen");
static_assert(sizeof(UUMGAtlantaRitualsScreen) == 0x000428, "Wrong size on UUMGAtlantaRitualsScreen");
static_assert(offsetof(UUMGAtlantaRitualsScreen, DailyTab) == 0x000338, "Member 'UUMGAtlantaRitualsScreen::DailyTab' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaRitualsScreen, WeeklyTab) == 0x000340, "Member 'UUMGAtlantaRitualsScreen::WeeklyTab' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaRitualsScreen, _atlantaRitualTitle) == 0x000348, "Member 'UUMGAtlantaRitualsScreen::_atlantaRitualTitle' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaRitualsScreen, _endInLabel) == 0x000360, "Member 'UUMGAtlantaRitualsScreen::_endInLabel' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaRitualsScreen, _dailyButtonLabel) == 0x000378, "Member 'UUMGAtlantaRitualsScreen::_dailyButtonLabel' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaRitualsScreen, _weeklyButtonLabel) == 0x000390, "Member 'UUMGAtlantaRitualsScreen::_weeklyButtonLabel' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaRitualsScreen, _dailyRemainingTime) == 0x0003A8, "Member 'UUMGAtlantaRitualsScreen::_dailyRemainingTime' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaRitualsScreen, _weeklyRemainingTime) == 0x0003C0, "Member 'UUMGAtlantaRitualsScreen::_weeklyRemainingTime' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaRitualTab
// 0x0048 (0x0380 - 0x0338)
class UUMGAtlantaRitualTab final : public UMobileBaseUserWidget
{
public:
	class UVerticalBox*                           ContainerBox;                                      // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   _itemWidgetClass;                                  // 0x0340(0x0030)(Edit, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_370[0x10];                                     // 0x0370(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastOnClaimRewardsButtonPressed(const int32 ritualId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaRitualTab">();
	}
	static class UUMGAtlantaRitualTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaRitualTab>();
	}
};
static_assert(alignof(UUMGAtlantaRitualTab) == 0x000008, "Wrong alignment on UUMGAtlantaRitualTab");
static_assert(sizeof(UUMGAtlantaRitualTab) == 0x000380, "Wrong size on UUMGAtlantaRitualTab");
static_assert(offsetof(UUMGAtlantaRitualTab, ContainerBox) == 0x000338, "Member 'UUMGAtlantaRitualTab::ContainerBox' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaRitualTab, _itemWidgetClass) == 0x000340, "Member 'UUMGAtlantaRitualTab::_itemWidgetClass' has a wrong offset!");

// Class DeadByDaylight.UMGSettingControlsContextWidget
// 0x0090 (0x03E0 - 0x0350)
class UUMGSettingControlsContextWidget final : public UUMGSettingContextWidget
{
public:
	uint8                                         Pad_350[0x60];                                     // 0x0350(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          AimAssist;                                         // 0x03B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x3];                                      // 0x03B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HandSide;                                          // 0x03B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InteractionButton;                                 // 0x03B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          InvertY;                                           // 0x03BC(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BD[0x3];                                      // 0x03BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KillerCameraSensitivity;                           // 0x03C0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SurvivorCameraSensitivity;                         // 0x03C4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x18];                                     // 0x03C8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAimAssistToggleClick(bool toggleValue);
	void HandleHandSideToggleClick(int32 index);
	void HandleInteractionButtonToggleClick(int32 index);
	void HandleInvertYToggleClick(bool toggleValue);
	void HandleKillerCameraSensitivityChanged(float sliderValue);
	void HandleSurvivorCameraSensitivityChanged(float sliderValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSettingControlsContextWidget">();
	}
	static class UUMGSettingControlsContextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSettingControlsContextWidget>();
	}
};
static_assert(alignof(UUMGSettingControlsContextWidget) == 0x000008, "Wrong alignment on UUMGSettingControlsContextWidget");
static_assert(sizeof(UUMGSettingControlsContextWidget) == 0x0003E0, "Wrong size on UUMGSettingControlsContextWidget");
static_assert(offsetof(UUMGSettingControlsContextWidget, AimAssist) == 0x0003B0, "Member 'UUMGSettingControlsContextWidget::AimAssist' has a wrong offset!");
static_assert(offsetof(UUMGSettingControlsContextWidget, HandSide) == 0x0003B4, "Member 'UUMGSettingControlsContextWidget::HandSide' has a wrong offset!");
static_assert(offsetof(UUMGSettingControlsContextWidget, InteractionButton) == 0x0003B8, "Member 'UUMGSettingControlsContextWidget::InteractionButton' has a wrong offset!");
static_assert(offsetof(UUMGSettingControlsContextWidget, InvertY) == 0x0003BC, "Member 'UUMGSettingControlsContextWidget::InvertY' has a wrong offset!");
static_assert(offsetof(UUMGSettingControlsContextWidget, KillerCameraSensitivity) == 0x0003C0, "Member 'UUMGSettingControlsContextWidget::KillerCameraSensitivity' has a wrong offset!");
static_assert(offsetof(UUMGSettingControlsContextWidget, SurvivorCameraSensitivity) == 0x0003C4, "Member 'UUMGSettingControlsContextWidget::SurvivorCameraSensitivity' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaSeasonEndPopup
// 0x0040 (0x0460 - 0x0420)
class UUMGAtlantaSeasonEndPopup final : public UUMGGenericPopup
{
public:
	class UUMGTallyRankBanner*                    OldSurvivorRankBanner;                             // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGTallyRankBanner*                    NewSurvivorRankBanner;                             // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGTallyRankBanner*                    OldKillerRankBanner;                               // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGTallyRankBanner*                    NewKillerRankBanner;                               // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         NewRankHorizontalBox;                              // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         OldRankHorizontalBox;                              // 0x0448(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           _fadeOutTimerHandle;                               // 0x0450(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _timerBeforeFadeOutAnimation;                      // 0x0458(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayNewRankFadeInAnimation();
	void TriggerFadeOutAnimationTimer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaSeasonEndPopup">();
	}
	static class UUMGAtlantaSeasonEndPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaSeasonEndPopup>();
	}
};
static_assert(alignof(UUMGAtlantaSeasonEndPopup) == 0x000008, "Wrong alignment on UUMGAtlantaSeasonEndPopup");
static_assert(sizeof(UUMGAtlantaSeasonEndPopup) == 0x000460, "Wrong size on UUMGAtlantaSeasonEndPopup");
static_assert(offsetof(UUMGAtlantaSeasonEndPopup, OldSurvivorRankBanner) == 0x000420, "Member 'UUMGAtlantaSeasonEndPopup::OldSurvivorRankBanner' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaSeasonEndPopup, NewSurvivorRankBanner) == 0x000428, "Member 'UUMGAtlantaSeasonEndPopup::NewSurvivorRankBanner' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaSeasonEndPopup, OldKillerRankBanner) == 0x000430, "Member 'UUMGAtlantaSeasonEndPopup::OldKillerRankBanner' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaSeasonEndPopup, NewKillerRankBanner) == 0x000438, "Member 'UUMGAtlantaSeasonEndPopup::NewKillerRankBanner' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaSeasonEndPopup, NewRankHorizontalBox) == 0x000440, "Member 'UUMGAtlantaSeasonEndPopup::NewRankHorizontalBox' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaSeasonEndPopup, OldRankHorizontalBox) == 0x000448, "Member 'UUMGAtlantaSeasonEndPopup::OldRankHorizontalBox' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaSeasonEndPopup, _fadeOutTimerHandle) == 0x000450, "Member 'UUMGAtlantaSeasonEndPopup::_fadeOutTimerHandle' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaSeasonEndPopup, _timerBeforeFadeOutAnimation) == 0x000458, "Member 'UUMGAtlantaSeasonEndPopup::_timerBeforeFadeOutAnimation' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaSettingScreen
// 0x0200 (0x0538 - 0x0338)
class UUMGAtlantaSettingScreen final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0xB0];                                     // 0x0338(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSwitcher*                        SettingContextSwitcher;                            // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SettingTabBox;                                     // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         AlwaysDisplayButtonBox;                            // 0x03F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   _settingTabButtonClass;                            // 0x0400(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   _settingAlwaysDisplayButtonClass;                  // 0x0430(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              _buttonBoxDividerAsset;                            // 0x0460(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EOverlayTabs, TSoftClassPtr<class UClass>> _overlayContextWidgetMap;                        // 0x0490(0x0050)(Edit, Transient, NoClear, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<EOverlayTabs, class UUMGSettingContextWidget*> _contextWidgetMap;                           // 0x04E0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_530[0x8];                                      // 0x0530(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAimAssistToggleClick(bool toggleValue);
	void HandleAlwaysDisplayButtonClick(int32 tabIndex);
	void HandleContextButtonClickEvent(int32 index);
	void HandleHandSideToggleClick(int32 index);
	void HandleInteractionButtonToggleClick(int32 index);
	void HandleInvertYToggleClick(bool toggleValue);
	void HandleKillerCameraSensitivityChanged(int32 value);
	void HandleLanguageButtonClick(int32 index);
	void HandleLeaveButtonClick();
	void HandleSettingTabClick(int32 tabIndex);
	void HandleSurvivorCameraSensitivityChanged(int32 value);
	void SetRightTopTextInfo(const class FText& title, const class FString& content, ESlateVisibility textVisibility);
	void ShowCreditsOrConsentsPopup(const class FString& title, const class FString& content);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaSettingScreen">();
	}
	static class UUMGAtlantaSettingScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaSettingScreen>();
	}
};
static_assert(alignof(UUMGAtlantaSettingScreen) == 0x000008, "Wrong alignment on UUMGAtlantaSettingScreen");
static_assert(sizeof(UUMGAtlantaSettingScreen) == 0x000538, "Wrong size on UUMGAtlantaSettingScreen");
static_assert(offsetof(UUMGAtlantaSettingScreen, SettingContextSwitcher) == 0x0003E8, "Member 'UUMGAtlantaSettingScreen::SettingContextSwitcher' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaSettingScreen, SettingTabBox) == 0x0003F0, "Member 'UUMGAtlantaSettingScreen::SettingTabBox' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaSettingScreen, AlwaysDisplayButtonBox) == 0x0003F8, "Member 'UUMGAtlantaSettingScreen::AlwaysDisplayButtonBox' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaSettingScreen, _settingTabButtonClass) == 0x000400, "Member 'UUMGAtlantaSettingScreen::_settingTabButtonClass' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaSettingScreen, _settingAlwaysDisplayButtonClass) == 0x000430, "Member 'UUMGAtlantaSettingScreen::_settingAlwaysDisplayButtonClass' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaSettingScreen, _buttonBoxDividerAsset) == 0x000460, "Member 'UUMGAtlantaSettingScreen::_buttonBoxDividerAsset' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaSettingScreen, _overlayContextWidgetMap) == 0x000490, "Member 'UUMGAtlantaSettingScreen::_overlayContextWidgetMap' has a wrong offset!");
static_assert(offsetof(UUMGAtlantaSettingScreen, _contextWidgetMap) == 0x0004E0, "Member 'UUMGAtlantaSettingScreen::_contextWidgetMap' has a wrong offset!");

// Class DeadByDaylight.UMGAtlantaTutorialScreen
// 0x0000 (0x0338 - 0x0338)
class UUMGAtlantaTutorialScreen final : public UMobileBaseUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlantaTutorialScreen">();
	}
	static class UUMGAtlantaTutorialScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlantaTutorialScreen>();
	}
};
static_assert(alignof(UUMGAtlantaTutorialScreen) == 0x000008, "Wrong alignment on UUMGAtlantaTutorialScreen");
static_assert(sizeof(UUMGAtlantaTutorialScreen) == 0x000338, "Wrong size on UUMGAtlantaTutorialScreen");

// Class DeadByDaylight.UMGSettingSubscriptionStatus
// 0x00A8 (0x0340 - 0x0298)
class UUMGSettingSubscriptionStatus final : public UUserWidget
{
public:
	class FText                                   SubscriptionStatusText;                            // 0x0298(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   StatusText;                                        // 0x02B0(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   InactiveStatusText;                                // 0x02C8(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   EndText;                                           // 0x02E0(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        TypeSwitcher;                                      // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         ActiveWidget;                                      // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               InactiveWidget;                                    // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TitleText;                                         // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             DisplayName;                                       // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Status;                                            // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             StatusInactive;                                    // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             End;                                               // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             EndDate;                                           // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSettingSubscriptionStatus">();
	}
	static class UUMGSettingSubscriptionStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSettingSubscriptionStatus>();
	}
};
static_assert(alignof(UUMGSettingSubscriptionStatus) == 0x000008, "Wrong alignment on UUMGSettingSubscriptionStatus");
static_assert(sizeof(UUMGSettingSubscriptionStatus) == 0x000340, "Wrong size on UUMGSettingSubscriptionStatus");
static_assert(offsetof(UUMGSettingSubscriptionStatus, SubscriptionStatusText) == 0x000298, "Member 'UUMGSettingSubscriptionStatus::SubscriptionStatusText' has a wrong offset!");
static_assert(offsetof(UUMGSettingSubscriptionStatus, StatusText) == 0x0002B0, "Member 'UUMGSettingSubscriptionStatus::StatusText' has a wrong offset!");
static_assert(offsetof(UUMGSettingSubscriptionStatus, InactiveStatusText) == 0x0002C8, "Member 'UUMGSettingSubscriptionStatus::InactiveStatusText' has a wrong offset!");
static_assert(offsetof(UUMGSettingSubscriptionStatus, EndText) == 0x0002E0, "Member 'UUMGSettingSubscriptionStatus::EndText' has a wrong offset!");
static_assert(offsetof(UUMGSettingSubscriptionStatus, TypeSwitcher) == 0x0002F8, "Member 'UUMGSettingSubscriptionStatus::TypeSwitcher' has a wrong offset!");
static_assert(offsetof(UUMGSettingSubscriptionStatus, ActiveWidget) == 0x000300, "Member 'UUMGSettingSubscriptionStatus::ActiveWidget' has a wrong offset!");
static_assert(offsetof(UUMGSettingSubscriptionStatus, InactiveWidget) == 0x000308, "Member 'UUMGSettingSubscriptionStatus::InactiveWidget' has a wrong offset!");
static_assert(offsetof(UUMGSettingSubscriptionStatus, TitleText) == 0x000310, "Member 'UUMGSettingSubscriptionStatus::TitleText' has a wrong offset!");
static_assert(offsetof(UUMGSettingSubscriptionStatus, DisplayName) == 0x000318, "Member 'UUMGSettingSubscriptionStatus::DisplayName' has a wrong offset!");
static_assert(offsetof(UUMGSettingSubscriptionStatus, Status) == 0x000320, "Member 'UUMGSettingSubscriptionStatus::Status' has a wrong offset!");
static_assert(offsetof(UUMGSettingSubscriptionStatus, StatusInactive) == 0x000328, "Member 'UUMGSettingSubscriptionStatus::StatusInactive' has a wrong offset!");
static_assert(offsetof(UUMGSettingSubscriptionStatus, End) == 0x000330, "Member 'UUMGSettingSubscriptionStatus::End' has a wrong offset!");
static_assert(offsetof(UUMGSettingSubscriptionStatus, EndDate) == 0x000338, "Member 'UUMGSettingSubscriptionStatus::EndDate' has a wrong offset!");

// Class DeadByDaylight.UMGAtlEndDateTimerWidget
// 0x0040 (0x0378 - 0x0338)
class UUMGAtlEndDateTimerWidget final : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             TextEndIn;                                         // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_340[0x38];                                     // 0x0340(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlEndDateTimerWidget">();
	}
	static class UUMGAtlEndDateTimerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlEndDateTimerWidget>();
	}
};
static_assert(alignof(UUMGAtlEndDateTimerWidget) == 0x000008, "Wrong alignment on UUMGAtlEndDateTimerWidget");
static_assert(sizeof(UUMGAtlEndDateTimerWidget) == 0x000378, "Wrong size on UUMGAtlEndDateTimerWidget");
static_assert(offsetof(UUMGAtlEndDateTimerWidget, TextEndIn) == 0x000338, "Member 'UUMGAtlEndDateTimerWidget::TextEndIn' has a wrong offset!");

// Class DeadByDaylight.UMGSplashScreen
// 0x0070 (0x03A8 - 0x0338)
class UUMGSplashScreen final : public UMobileBaseUserWidget
{
public:
	TMulticastInlineDelegate<void()>              OnSaveGamePopupCompleteEvent;                      // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnScreenTouched;                                   // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           SavePopup;                                         // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             GameVersion;                                       // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             LoadingState;                                      // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             PressKey;                                          // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                TapButton;                                         // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             SaveGameTitle;                                     // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             SaveGameDescription;                               // 0x0388(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGDownloadProgressionWidget*          DownloadProgression;                               // 0x0390(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGCharacterSlideShowWidget*           CharacterSlideShow;                                // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTapButtonClicked();

	void OnSaveGamePopupComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSplashScreen">();
	}
	static class UUMGSplashScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSplashScreen>();
	}
};
static_assert(alignof(UUMGSplashScreen) == 0x000008, "Wrong alignment on UUMGSplashScreen");
static_assert(sizeof(UUMGSplashScreen) == 0x0003A8, "Wrong size on UUMGSplashScreen");
static_assert(offsetof(UUMGSplashScreen, OnSaveGamePopupCompleteEvent) == 0x000338, "Member 'UUMGSplashScreen::OnSaveGamePopupCompleteEvent' has a wrong offset!");
static_assert(offsetof(UUMGSplashScreen, OnScreenTouched) == 0x000348, "Member 'UUMGSplashScreen::OnScreenTouched' has a wrong offset!");
static_assert(offsetof(UUMGSplashScreen, SavePopup) == 0x000358, "Member 'UUMGSplashScreen::SavePopup' has a wrong offset!");
static_assert(offsetof(UUMGSplashScreen, GameVersion) == 0x000360, "Member 'UUMGSplashScreen::GameVersion' has a wrong offset!");
static_assert(offsetof(UUMGSplashScreen, LoadingState) == 0x000368, "Member 'UUMGSplashScreen::LoadingState' has a wrong offset!");
static_assert(offsetof(UUMGSplashScreen, PressKey) == 0x000370, "Member 'UUMGSplashScreen::PressKey' has a wrong offset!");
static_assert(offsetof(UUMGSplashScreen, TapButton) == 0x000378, "Member 'UUMGSplashScreen::TapButton' has a wrong offset!");
static_assert(offsetof(UUMGSplashScreen, SaveGameTitle) == 0x000380, "Member 'UUMGSplashScreen::SaveGameTitle' has a wrong offset!");
static_assert(offsetof(UUMGSplashScreen, SaveGameDescription) == 0x000388, "Member 'UUMGSplashScreen::SaveGameDescription' has a wrong offset!");
static_assert(offsetof(UUMGSplashScreen, DownloadProgression) == 0x000390, "Member 'UUMGSplashScreen::DownloadProgression' has a wrong offset!");
static_assert(offsetof(UUMGSplashScreen, CharacterSlideShow) == 0x000398, "Member 'UUMGSplashScreen::CharacterSlideShow' has a wrong offset!");

// Class DeadByDaylight.UMGAtlEventItemWidget
// 0x0060 (0x0398 - 0x0338)
class UUMGAtlEventItemWidget final : public UMobileBaseUserWidget
{
public:
	class UImage*                                 SquareImageBackground;                             // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SquareRarityBackground;                            // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 SquareIcon;                                        // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PortraitImageBackground;                           // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PortraitRarityBackground;                          // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PortraitIcon;                                      // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NameText;                                          // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             QuantityText;                                      // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           PortraitCanvas;                                    // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           SquareCanvas;                                      // 0x0380(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FEventItemsContentTypeUIData>   ContentTypeUIData;                                 // 0x0388(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlEventItemWidget">();
	}
	static class UUMGAtlEventItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlEventItemWidget>();
	}
};
static_assert(alignof(UUMGAtlEventItemWidget) == 0x000008, "Wrong alignment on UUMGAtlEventItemWidget");
static_assert(sizeof(UUMGAtlEventItemWidget) == 0x000398, "Wrong size on UUMGAtlEventItemWidget");
static_assert(offsetof(UUMGAtlEventItemWidget, SquareImageBackground) == 0x000338, "Member 'UUMGAtlEventItemWidget::SquareImageBackground' has a wrong offset!");
static_assert(offsetof(UUMGAtlEventItemWidget, SquareRarityBackground) == 0x000340, "Member 'UUMGAtlEventItemWidget::SquareRarityBackground' has a wrong offset!");
static_assert(offsetof(UUMGAtlEventItemWidget, SquareIcon) == 0x000348, "Member 'UUMGAtlEventItemWidget::SquareIcon' has a wrong offset!");
static_assert(offsetof(UUMGAtlEventItemWidget, PortraitImageBackground) == 0x000350, "Member 'UUMGAtlEventItemWidget::PortraitImageBackground' has a wrong offset!");
static_assert(offsetof(UUMGAtlEventItemWidget, PortraitRarityBackground) == 0x000358, "Member 'UUMGAtlEventItemWidget::PortraitRarityBackground' has a wrong offset!");
static_assert(offsetof(UUMGAtlEventItemWidget, PortraitIcon) == 0x000360, "Member 'UUMGAtlEventItemWidget::PortraitIcon' has a wrong offset!");
static_assert(offsetof(UUMGAtlEventItemWidget, NameText) == 0x000368, "Member 'UUMGAtlEventItemWidget::NameText' has a wrong offset!");
static_assert(offsetof(UUMGAtlEventItemWidget, QuantityText) == 0x000370, "Member 'UUMGAtlEventItemWidget::QuantityText' has a wrong offset!");
static_assert(offsetof(UUMGAtlEventItemWidget, PortraitCanvas) == 0x000378, "Member 'UUMGAtlEventItemWidget::PortraitCanvas' has a wrong offset!");
static_assert(offsetof(UUMGAtlEventItemWidget, SquareCanvas) == 0x000380, "Member 'UUMGAtlEventItemWidget::SquareCanvas' has a wrong offset!");
static_assert(offsetof(UUMGAtlEventItemWidget, ContentTypeUIData) == 0x000388, "Member 'UUMGAtlEventItemWidget::ContentTypeUIData' has a wrong offset!");

// Class DeadByDaylight.UMGBasePassStorefrontWidget
// 0x0038 (0x0370 - 0x0338)
class UUMGBasePassStorefrontWidget : public UUMGBaseStorefrontWidget
{
public:
	class UUMGSubscriptionsPageScrollWidget*      SubscriptionsPageScroll;                           // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x30];                                     // 0x0340(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleBuySubscriptionPackButtonClickedEvent(class FName subscriptionPackID);
	void HandleSubscriptionInfoButtonClickedEvent(const class FString& subscriptionDetails);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBasePassStorefrontWidget">();
	}
	static class UUMGBasePassStorefrontWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBasePassStorefrontWidget>();
	}
};
static_assert(alignof(UUMGBasePassStorefrontWidget) == 0x000008, "Wrong alignment on UUMGBasePassStorefrontWidget");
static_assert(sizeof(UUMGBasePassStorefrontWidget) == 0x000370, "Wrong size on UUMGBasePassStorefrontWidget");
static_assert(offsetof(UUMGBasePassStorefrontWidget, SubscriptionsPageScroll) == 0x000338, "Member 'UUMGBasePassStorefrontWidget::SubscriptionsPageScroll' has a wrong offset!");

// Class DeadByDaylight.UMGLobbyJoinedWidget
// 0x0080 (0x03B8 - 0x0338)
class UUMGLobbyJoinedWidget final : public UMobileBaseUserWidget
{
public:
	bool                                          LocalPlayerIsSlasher;                              // 0x0338(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TextLeaveLobby;                                    // 0x0340(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   TextPlayerNotReadyYet;                             // 0x0358(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   TextWaitingPlayers;                                // 0x0370(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   TextToBeReady;                                     // 0x0388(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         CommandButtonsContainer;                           // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x10];                                     // 0x03A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPlayerInfo(int32 playerId, const struct FPlayerInfoData& playerInfoData, bool isPlayerReady, const TArray<struct FInventorySlotData>& loadoutData);
	void HandleLeaveButtonClicked();
	void RemovePlayersInfo(int32 playerId);
	void SetLoadoutDataForLocalPlayer(const TArray<struct FInventorySlotData>& loadoutData, bool usingMatchRules, bool perkSlotsLockedByAdmin, bool isSlasher);
	void SetLobbyTimer(int32 seconds);
	void SetLocalPlayerInfo(const struct FPlayerInfoData& playerInfoData);
	void SetReadyStatus(const TArray<struct FPlayerReadyStatusData>& playersReadyStatusData);
	void SetWidgetsVisibility(const bool widgetsVisibilty);
	void UpdatePlayersLatency(const TMap<int32, float>& playersLatency, bool isHost);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLobbyJoinedWidget">();
	}
	static class UUMGLobbyJoinedWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLobbyJoinedWidget>();
	}
};
static_assert(alignof(UUMGLobbyJoinedWidget) == 0x000008, "Wrong alignment on UUMGLobbyJoinedWidget");
static_assert(sizeof(UUMGLobbyJoinedWidget) == 0x0003B8, "Wrong size on UUMGLobbyJoinedWidget");
static_assert(offsetof(UUMGLobbyJoinedWidget, LocalPlayerIsSlasher) == 0x000338, "Member 'UUMGLobbyJoinedWidget::LocalPlayerIsSlasher' has a wrong offset!");
static_assert(offsetof(UUMGLobbyJoinedWidget, TextLeaveLobby) == 0x000340, "Member 'UUMGLobbyJoinedWidget::TextLeaveLobby' has a wrong offset!");
static_assert(offsetof(UUMGLobbyJoinedWidget, TextPlayerNotReadyYet) == 0x000358, "Member 'UUMGLobbyJoinedWidget::TextPlayerNotReadyYet' has a wrong offset!");
static_assert(offsetof(UUMGLobbyJoinedWidget, TextWaitingPlayers) == 0x000370, "Member 'UUMGLobbyJoinedWidget::TextWaitingPlayers' has a wrong offset!");
static_assert(offsetof(UUMGLobbyJoinedWidget, TextToBeReady) == 0x000388, "Member 'UUMGLobbyJoinedWidget::TextToBeReady' has a wrong offset!");
static_assert(offsetof(UUMGLobbyJoinedWidget, CommandButtonsContainer) == 0x0003A0, "Member 'UUMGLobbyJoinedWidget::CommandButtonsContainer' has a wrong offset!");

// Class DeadByDaylight.UMGAtlPassStorefrontWidget
// 0x0000 (0x0370 - 0x0370)
class UUMGAtlPassStorefrontWidget final : public UUMGBasePassStorefrontWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlPassStorefrontWidget">();
	}
	static class UUMGAtlPassStorefrontWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlPassStorefrontWidget>();
	}
};
static_assert(alignof(UUMGAtlPassStorefrontWidget) == 0x000008, "Wrong alignment on UUMGAtlPassStorefrontWidget");
static_assert(sizeof(UUMGAtlPassStorefrontWidget) == 0x000370, "Wrong size on UUMGAtlPassStorefrontWidget");

// Class DeadByDaylight.UMGAtlStorePriceWidget
// 0x0008 (0x0340 - 0x0338)
class UUMGAtlStorePriceWidget final : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             PriceText;                                         // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAtlStorePriceWidget">();
	}
	static class UUMGAtlStorePriceWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAtlStorePriceWidget>();
	}
};
static_assert(alignof(UUMGAtlStorePriceWidget) == 0x000008, "Wrong alignment on UUMGAtlStorePriceWidget");
static_assert(sizeof(UUMGAtlStorePriceWidget) == 0x000340, "Wrong size on UUMGAtlStorePriceWidget");
static_assert(offsetof(UUMGAtlStorePriceWidget, PriceText) == 0x000338, "Member 'UUMGAtlStorePriceWidget::PriceText' has a wrong offset!");

// Class DeadByDaylight.UMGLobbySearchingWidget
// 0x00E8 (0x0478 - 0x0390)
class UUMGLobbySearchingWidget final : public UUMGLoadoutBaseWidget
{
public:
	class UUMGBankAndPlayerInfoWidget*            BankAndPlayerInfoWidget;                           // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ItemOrPowerText;                                   // 0x0398(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FText                                   AddonText;                                         // 0x03B0(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FText                                   OfferingText;                                      // 0x03C8(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FText                                   PerksText;                                         // 0x03E0(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FText                                   TextWaitingForPlayers;                             // 0x03F8(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FText                                   TextEstimatedTimeTitle;                            // 0x0410(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class UButton*                                ButtonCancelSearching;                             // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGPartySlotsWidget*                   PartySlots;                                        // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x40];                                     // 0x0438(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleLeaveButtonClicked();
	void OnCurrencyTooltipTriggered(const struct FTooltipPressedData& tooltipPressedData, ECurrencyType currencyType);
	void OnLevelTooltipTriggered(const struct FTooltipPressedData& tooltipPressedData);
	void OnRankTooltipTriggered(const struct FTooltipPressedData& tooltipPressedData);
	void SetEstimatedWaitingTimer(int32 seconds);
	void SetWaitingTimer(int32 seconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLobbySearchingWidget">();
	}
	static class UUMGLobbySearchingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLobbySearchingWidget>();
	}
};
static_assert(alignof(UUMGLobbySearchingWidget) == 0x000008, "Wrong alignment on UUMGLobbySearchingWidget");
static_assert(sizeof(UUMGLobbySearchingWidget) == 0x000478, "Wrong size on UUMGLobbySearchingWidget");
static_assert(offsetof(UUMGLobbySearchingWidget, BankAndPlayerInfoWidget) == 0x000390, "Member 'UUMGLobbySearchingWidget::BankAndPlayerInfoWidget' has a wrong offset!");
static_assert(offsetof(UUMGLobbySearchingWidget, ItemOrPowerText) == 0x000398, "Member 'UUMGLobbySearchingWidget::ItemOrPowerText' has a wrong offset!");
static_assert(offsetof(UUMGLobbySearchingWidget, AddonText) == 0x0003B0, "Member 'UUMGLobbySearchingWidget::AddonText' has a wrong offset!");
static_assert(offsetof(UUMGLobbySearchingWidget, OfferingText) == 0x0003C8, "Member 'UUMGLobbySearchingWidget::OfferingText' has a wrong offset!");
static_assert(offsetof(UUMGLobbySearchingWidget, PerksText) == 0x0003E0, "Member 'UUMGLobbySearchingWidget::PerksText' has a wrong offset!");
static_assert(offsetof(UUMGLobbySearchingWidget, TextWaitingForPlayers) == 0x0003F8, "Member 'UUMGLobbySearchingWidget::TextWaitingForPlayers' has a wrong offset!");
static_assert(offsetof(UUMGLobbySearchingWidget, TextEstimatedTimeTitle) == 0x000410, "Member 'UUMGLobbySearchingWidget::TextEstimatedTimeTitle' has a wrong offset!");
static_assert(offsetof(UUMGLobbySearchingWidget, ButtonCancelSearching) == 0x000428, "Member 'UUMGLobbySearchingWidget::ButtonCancelSearching' has a wrong offset!");
static_assert(offsetof(UUMGLobbySearchingWidget, PartySlots) == 0x000430, "Member 'UUMGLobbySearchingWidget::PartySlots' has a wrong offset!");

// Class DeadByDaylight.UMGCurrencyWidget
// 0x0018 (0x0480 - 0x0468)
class UUMGCurrencyWidget : public UUMGBaseButtonWidget
{
public:
	ECurrencyType                                 currencyType;                                      // 0x0468(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_469[0x17];                                     // 0x0469(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleTooltipLongPressEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCurrencyWidget">();
	}
	static class UUMGCurrencyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCurrencyWidget>();
	}
};
static_assert(alignof(UUMGCurrencyWidget) == 0x000008, "Wrong alignment on UUMGCurrencyWidget");
static_assert(sizeof(UUMGCurrencyWidget) == 0x000480, "Wrong size on UUMGCurrencyWidget");
static_assert(offsetof(UUMGCurrencyWidget, currencyType) == 0x000468, "Member 'UUMGCurrencyWidget::currencyType' has a wrong offset!");

// Class DeadByDaylight.UMGAuricCellsButton
// 0x0010 (0x0490 - 0x0480)
class UUMGAuricCellsButton final : public UUMGCurrencyWidget
{
public:
	class UImage*                                 PlusImage;                                         // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGAuricCellsButton">();
	}
	static class UUMGAuricCellsButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGAuricCellsButton>();
	}
};
static_assert(alignof(UUMGAuricCellsButton) == 0x000008, "Wrong alignment on UUMGAuricCellsButton");
static_assert(sizeof(UUMGAuricCellsButton) == 0x000490, "Wrong size on UUMGAuricCellsButton");
static_assert(offsetof(UUMGAuricCellsButton, PlusImage) == 0x000480, "Member 'UUMGAuricCellsButton::PlusImage' has a wrong offset!");

// Class DeadByDaylight.UMGBankAndPlayerInfoWidget
// 0x00A8 (0x03E0 - 0x0338)
class UUMGBankAndPlayerInfoWidget final : public UMobileBaseUserWidget
{
public:
	class UUMGBankWidget*                         BankWidget;                                        // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerNameText;                                    // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGSelectedCharacterWidget*            SelectedCharacterWidget;                           // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              RankWidgetVisibility;                              // 0x0350(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGLevelBannerWidget*                  LevelBanner;                                       // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGRankBanner*                         RankBanner;                                        // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGMainMenuMonthlyPassButton*          MonthlyPassButton;                                 // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x60];                                     // 0x0370(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              _onCancelPartyButtonClickedEvent;                  // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)

public:
	void OnCancelPartyButtonClicked();
	void OnMainMenuSubscriptionClicked();
	void OnPrestigeButtonClicked();
	void OnPurchaseAuricCellsButtonClicked();
	void OnTooltipTriggeredByCurrency(const struct FTooltipPressedData& tooltipPressedData, const ECurrencyType currencyType);
	void OnTooltipTriggeredByLevelBannerWidget(const struct FTooltipPressedData& tooltipPressedData);
	void OnTooltipTriggeredByRankBanner(const struct FTooltipPressedData& tooltipPressedData);
	void SetPlayerLevelBP(int32 level, int32 devotion, int32 currentLevelXp, int32 totalLevelXp, bool isSlasher, bool playUpdateAnim);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBankAndPlayerInfoWidget">();
	}
	static class UUMGBankAndPlayerInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBankAndPlayerInfoWidget>();
	}
};
static_assert(alignof(UUMGBankAndPlayerInfoWidget) == 0x000008, "Wrong alignment on UUMGBankAndPlayerInfoWidget");
static_assert(sizeof(UUMGBankAndPlayerInfoWidget) == 0x0003E0, "Wrong size on UUMGBankAndPlayerInfoWidget");
static_assert(offsetof(UUMGBankAndPlayerInfoWidget, BankWidget) == 0x000338, "Member 'UUMGBankAndPlayerInfoWidget::BankWidget' has a wrong offset!");
static_assert(offsetof(UUMGBankAndPlayerInfoWidget, PlayerNameText) == 0x000340, "Member 'UUMGBankAndPlayerInfoWidget::PlayerNameText' has a wrong offset!");
static_assert(offsetof(UUMGBankAndPlayerInfoWidget, SelectedCharacterWidget) == 0x000348, "Member 'UUMGBankAndPlayerInfoWidget::SelectedCharacterWidget' has a wrong offset!");
static_assert(offsetof(UUMGBankAndPlayerInfoWidget, RankWidgetVisibility) == 0x000350, "Member 'UUMGBankAndPlayerInfoWidget::RankWidgetVisibility' has a wrong offset!");
static_assert(offsetof(UUMGBankAndPlayerInfoWidget, LevelBanner) == 0x000358, "Member 'UUMGBankAndPlayerInfoWidget::LevelBanner' has a wrong offset!");
static_assert(offsetof(UUMGBankAndPlayerInfoWidget, RankBanner) == 0x000360, "Member 'UUMGBankAndPlayerInfoWidget::RankBanner' has a wrong offset!");
static_assert(offsetof(UUMGBankAndPlayerInfoWidget, MonthlyPassButton) == 0x000368, "Member 'UUMGBankAndPlayerInfoWidget::MonthlyPassButton' has a wrong offset!");
static_assert(offsetof(UUMGBankAndPlayerInfoWidget, _onCancelPartyButtonClickedEvent) == 0x0003D0, "Member 'UUMGBankAndPlayerInfoWidget::_onCancelPartyButtonClickedEvent' has a wrong offset!");

// Class DeadByDaylight.UMGBankWidget
// 0x0038 (0x0370 - 0x0338)
class UUMGBankWidget final : public UMobileBaseUserWidget
{
public:
	class UUMGCurrencyWidget*                     BloodPointsCurrency;                               // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGAuricCellsButton*                   CellsButton;                                       // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGCurrencyWidget*                     IridescentShardsCurrency;                          // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x20];                                     // 0x0350(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCurrencyTooltipRequested(const struct FTooltipPressedData& tooltipPressedData, const ECurrencyType currencyType);
	void OnPurchaseAuricCellsClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBankWidget">();
	}
	static class UUMGBankWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBankWidget>();
	}
};
static_assert(alignof(UUMGBankWidget) == 0x000008, "Wrong alignment on UUMGBankWidget");
static_assert(sizeof(UUMGBankWidget) == 0x000370, "Wrong size on UUMGBankWidget");
static_assert(offsetof(UUMGBankWidget, BloodPointsCurrency) == 0x000338, "Member 'UUMGBankWidget::BloodPointsCurrency' has a wrong offset!");
static_assert(offsetof(UUMGBankWidget, CellsButton) == 0x000340, "Member 'UUMGBankWidget::CellsButton' has a wrong offset!");
static_assert(offsetof(UUMGBankWidget, IridescentShardsCurrency) == 0x000348, "Member 'UUMGBankWidget::IridescentShardsCurrency' has a wrong offset!");

// Class DeadByDaylight.UMGBaseAlertWidget
// 0x0030 (0x02C8 - 0x0298)
class UUMGBaseAlertWidget : public UUserWidget
{
public:
	uint8                                         Pad_298[0x30];                                     // 0x0298(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBaseAlertWidget">();
	}
	static class UUMGBaseAlertWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBaseAlertWidget>();
	}
};
static_assert(alignof(UUMGBaseAlertWidget) == 0x000008, "Wrong alignment on UUMGBaseAlertWidget");
static_assert(sizeof(UUMGBaseAlertWidget) == 0x0002C8, "Wrong size on UUMGBaseAlertWidget");

// Class DeadByDaylight.UMGBaseCountdownWidget
// 0x0068 (0x03A0 - 0x0338)
class UUMGBaseCountdownWidget : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             TimerTextBlock;                                    // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _timerThreshold;                                   // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            _timerColorBelowThreshold;                         // 0x0348(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            _timerColorBeyondThreshold;                        // 0x0370(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBaseCountdownWidget">();
	}
	static class UUMGBaseCountdownWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBaseCountdownWidget>();
	}
};
static_assert(alignof(UUMGBaseCountdownWidget) == 0x000008, "Wrong alignment on UUMGBaseCountdownWidget");
static_assert(sizeof(UUMGBaseCountdownWidget) == 0x0003A0, "Wrong size on UUMGBaseCountdownWidget");
static_assert(offsetof(UUMGBaseCountdownWidget, TimerTextBlock) == 0x000338, "Member 'UUMGBaseCountdownWidget::TimerTextBlock' has a wrong offset!");
static_assert(offsetof(UUMGBaseCountdownWidget, _timerThreshold) == 0x000340, "Member 'UUMGBaseCountdownWidget::_timerThreshold' has a wrong offset!");
static_assert(offsetof(UUMGBaseCountdownWidget, _timerColorBelowThreshold) == 0x000348, "Member 'UUMGBaseCountdownWidget::_timerColorBelowThreshold' has a wrong offset!");
static_assert(offsetof(UUMGBaseCountdownWidget, _timerColorBeyondThreshold) == 0x000370, "Member 'UUMGBaseCountdownWidget::_timerColorBeyondThreshold' has a wrong offset!");

// Class DeadByDaylight.UMGMonthlyPassCurrencyWidget
// 0x0008 (0x0398 - 0x0390)
class UUMGMonthlyPassCurrencyWidget final : public UUMGMonthlyPassRewardItemWidget
{
public:
	class UImage*                                 CurrencyBackground;                                // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGMonthlyPassCurrencyWidget">();
	}
	static class UUMGMonthlyPassCurrencyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGMonthlyPassCurrencyWidget>();
	}
};
static_assert(alignof(UUMGMonthlyPassCurrencyWidget) == 0x000008, "Wrong alignment on UUMGMonthlyPassCurrencyWidget");
static_assert(sizeof(UUMGMonthlyPassCurrencyWidget) == 0x000398, "Wrong size on UUMGMonthlyPassCurrencyWidget");
static_assert(offsetof(UUMGMonthlyPassCurrencyWidget, CurrencyBackground) == 0x000390, "Member 'UUMGMonthlyPassCurrencyWidget::CurrencyBackground' has a wrong offset!");

// Class DeadByDaylight.UMGBaseToastWidget
// 0x0068 (0x03A0 - 0x0338)
class UUMGBaseToastWidget final : public UMobileBaseUserWidget
{
public:
	class UImage*                                 ToastIcon;                                         // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ToastText;                                         // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UProgressBar*                           TimeToastProgression;                              // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x50];                                     // 0x0350(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTimerFinished();
	void TriggerToastInput(int32 inputCode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBaseToastWidget">();
	}
	static class UUMGBaseToastWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBaseToastWidget>();
	}
};
static_assert(alignof(UUMGBaseToastWidget) == 0x000008, "Wrong alignment on UUMGBaseToastWidget");
static_assert(sizeof(UUMGBaseToastWidget) == 0x0003A0, "Wrong size on UUMGBaseToastWidget");
static_assert(offsetof(UUMGBaseToastWidget, ToastIcon) == 0x000338, "Member 'UUMGBaseToastWidget::ToastIcon' has a wrong offset!");
static_assert(offsetof(UUMGBaseToastWidget, ToastText) == 0x000340, "Member 'UUMGBaseToastWidget::ToastText' has a wrong offset!");
static_assert(offsetof(UUMGBaseToastWidget, TimeToastProgression) == 0x000348, "Member 'UUMGBaseToastWidget::TimeToastProgression' has a wrong offset!");

// Class DeadByDaylight.UMGBloodStoreArrayWidget
// 0x0070 (0x03A8 - 0x0338)
class UUMGBloodStoreArrayWidget final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGBloodStoreRowWidget*                FirstBloodStoreRowWidget;                          // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBloodStoreRowWidget*                SecondBloodStoreRowWidget;                         // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBloodStoreRowWidget*                ThirdBloodStoreRowWidget;                          // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBloodStoreRowWidget*                FourthBloodStoreRowWidget;                         // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBloodStoreRowWidget*                FifthBloodStoreRowWidget;                          // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUMGBloodStoreRowWidget*>        _bloodStoreRowArray;                               // 0x0370(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_380[0x28];                                     // 0x0380(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastBloodNodeSelected(const class FString& id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBloodStoreArrayWidget">();
	}
	static class UUMGBloodStoreArrayWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBloodStoreArrayWidget>();
	}
};
static_assert(alignof(UUMGBloodStoreArrayWidget) == 0x000008, "Wrong alignment on UUMGBloodStoreArrayWidget");
static_assert(sizeof(UUMGBloodStoreArrayWidget) == 0x0003A8, "Wrong size on UUMGBloodStoreArrayWidget");
static_assert(offsetof(UUMGBloodStoreArrayWidget, FirstBloodStoreRowWidget) == 0x000348, "Member 'UUMGBloodStoreArrayWidget::FirstBloodStoreRowWidget' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreArrayWidget, SecondBloodStoreRowWidget) == 0x000350, "Member 'UUMGBloodStoreArrayWidget::SecondBloodStoreRowWidget' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreArrayWidget, ThirdBloodStoreRowWidget) == 0x000358, "Member 'UUMGBloodStoreArrayWidget::ThirdBloodStoreRowWidget' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreArrayWidget, FourthBloodStoreRowWidget) == 0x000360, "Member 'UUMGBloodStoreArrayWidget::FourthBloodStoreRowWidget' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreArrayWidget, FifthBloodStoreRowWidget) == 0x000368, "Member 'UUMGBloodStoreArrayWidget::FifthBloodStoreRowWidget' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreArrayWidget, _bloodStoreRowArray) == 0x000370, "Member 'UUMGBloodStoreArrayWidget::_bloodStoreRowArray' has a wrong offset!");

// Class DeadByDaylight.UMGBloodStoreItemPreviewWidget
// 0x0108 (0x0440 - 0x0338)
class UUMGBloodStoreItemPreviewWidget final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x30];                                     // 0x0338(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   _itemName;                                         // 0x0368(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _itemDescription;                                  // 0x0380(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         _itemPrice;                                        // 0x0398(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   _refreshPrice;                                     // 0x03A0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _nodeStatusText;                                   // 0x03B8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _refreshTitle;                                     // 0x03D0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _itemSelectionTitle;                               // 0x03E8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _itemSelectionText;                                // 0x0400(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _purchaseTitle;                                    // 0x0418(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastPurchasePressed();
	void BroadcastRefreshPressed();
	void BroadcastUnselectPressed();
	void DisplayItem(bool isItemPurchaseable, bool isItemAffordable);
	void ShowPurchaseButton(bool showPurchaseButton);
	void ShowRefreshButton(bool showRefreshButton, bool isRefreshFree);
	void UnselectItem();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBloodStoreItemPreviewWidget">();
	}
	static class UUMGBloodStoreItemPreviewWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBloodStoreItemPreviewWidget>();
	}
};
static_assert(alignof(UUMGBloodStoreItemPreviewWidget) == 0x000008, "Wrong alignment on UUMGBloodStoreItemPreviewWidget");
static_assert(sizeof(UUMGBloodStoreItemPreviewWidget) == 0x000440, "Wrong size on UUMGBloodStoreItemPreviewWidget");
static_assert(offsetof(UUMGBloodStoreItemPreviewWidget, _itemName) == 0x000368, "Member 'UUMGBloodStoreItemPreviewWidget::_itemName' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemPreviewWidget, _itemDescription) == 0x000380, "Member 'UUMGBloodStoreItemPreviewWidget::_itemDescription' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemPreviewWidget, _itemPrice) == 0x000398, "Member 'UUMGBloodStoreItemPreviewWidget::_itemPrice' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemPreviewWidget, _refreshPrice) == 0x0003A0, "Member 'UUMGBloodStoreItemPreviewWidget::_refreshPrice' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemPreviewWidget, _nodeStatusText) == 0x0003B8, "Member 'UUMGBloodStoreItemPreviewWidget::_nodeStatusText' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemPreviewWidget, _refreshTitle) == 0x0003D0, "Member 'UUMGBloodStoreItemPreviewWidget::_refreshTitle' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemPreviewWidget, _itemSelectionTitle) == 0x0003E8, "Member 'UUMGBloodStoreItemPreviewWidget::_itemSelectionTitle' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemPreviewWidget, _itemSelectionText) == 0x000400, "Member 'UUMGBloodStoreItemPreviewWidget::_itemSelectionText' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemPreviewWidget, _purchaseTitle) == 0x000418, "Member 'UUMGBloodStoreItemPreviewWidget::_purchaseTitle' has a wrong offset!");

// Class DeadByDaylight.UMGBloodStoreItemWidget
// 0x0080 (0x03B8 - 0x0338)
class UUMGBloodStoreItemWidget final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 NodeImage;                                         // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BackgroundImage;                                   // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RarityBackground;                                  // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ItemPanel;                                         // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           MysteryBoxPanel;                                   // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 MysteryBoxRarityBackground;                        // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CollectedPanel;                                    // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ConsumedPanel;                                     // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBloodwebNodeContentType                      _contentType;                                      // 0x0388(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isMysteryBox;                                     // 0x0389(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38A[0x2];                                      // 0x038A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              _bigItemScale;                                     // 0x038C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _normalItemScale;                                  // 0x0394(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _consumedOpacity;                                  // 0x039C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x18];                                     // 0x03A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastBloodNodeSelected();
	void CollectNode();
	void ConsumeNode();
	void FocusNode();
	void PlayConsumedAnimation(const bool skipIntro);
	void SetBackgroundImages();
	void SetSelectedVisibilities(bool isSelected);
	void UnFocusNode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBloodStoreItemWidget">();
	}
	static class UUMGBloodStoreItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBloodStoreItemWidget>();
	}
};
static_assert(alignof(UUMGBloodStoreItemWidget) == 0x000008, "Wrong alignment on UUMGBloodStoreItemWidget");
static_assert(sizeof(UUMGBloodStoreItemWidget) == 0x0003B8, "Wrong size on UUMGBloodStoreItemWidget");
static_assert(offsetof(UUMGBloodStoreItemWidget, NodeImage) == 0x000348, "Member 'UUMGBloodStoreItemWidget::NodeImage' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemWidget, BackgroundImage) == 0x000350, "Member 'UUMGBloodStoreItemWidget::BackgroundImage' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemWidget, RarityBackground) == 0x000358, "Member 'UUMGBloodStoreItemWidget::RarityBackground' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemWidget, ItemPanel) == 0x000360, "Member 'UUMGBloodStoreItemWidget::ItemPanel' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemWidget, MysteryBoxPanel) == 0x000368, "Member 'UUMGBloodStoreItemWidget::MysteryBoxPanel' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemWidget, MysteryBoxRarityBackground) == 0x000370, "Member 'UUMGBloodStoreItemWidget::MysteryBoxRarityBackground' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemWidget, CollectedPanel) == 0x000378, "Member 'UUMGBloodStoreItemWidget::CollectedPanel' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemWidget, ConsumedPanel) == 0x000380, "Member 'UUMGBloodStoreItemWidget::ConsumedPanel' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemWidget, _contentType) == 0x000388, "Member 'UUMGBloodStoreItemWidget::_contentType' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemWidget, _isMysteryBox) == 0x000389, "Member 'UUMGBloodStoreItemWidget::_isMysteryBox' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemWidget, _bigItemScale) == 0x00038C, "Member 'UUMGBloodStoreItemWidget::_bigItemScale' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemWidget, _normalItemScale) == 0x000394, "Member 'UUMGBloodStoreItemWidget::_normalItemScale' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreItemWidget, _consumedOpacity) == 0x00039C, "Member 'UUMGBloodStoreItemWidget::_consumedOpacity' has a wrong offset!");

// Class DeadByDaylight.UMGBloodStoreSubMenu
// 0x0030 (0x0368 - 0x0338)
class UUMGBloodStoreSubMenu final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x20];                                     // 0x0338(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGBloodStoreTimer*                    SurvivorTimer;                                     // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBloodStoreTimer*                    KillerTimer;                                       // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BroadcastCharacterRoleButtonClicked();
	void BroadcastExpiredBloodWeb();
	void SetFaction(bool isKiller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBloodStoreSubMenu">();
	}
	static class UUMGBloodStoreSubMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBloodStoreSubMenu>();
	}
};
static_assert(alignof(UUMGBloodStoreSubMenu) == 0x000008, "Wrong alignment on UUMGBloodStoreSubMenu");
static_assert(sizeof(UUMGBloodStoreSubMenu) == 0x000368, "Wrong size on UUMGBloodStoreSubMenu");
static_assert(offsetof(UUMGBloodStoreSubMenu, SurvivorTimer) == 0x000358, "Member 'UUMGBloodStoreSubMenu::SurvivorTimer' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreSubMenu, KillerTimer) == 0x000360, "Member 'UUMGBloodStoreSubMenu::KillerTimer' has a wrong offset!");

// Class DeadByDaylight.UMGBloodStoreTimer
// 0x0088 (0x03C0 - 0x0338)
class UUMGBloodStoreTimer final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            _normalColor;                                      // 0x0348(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            _warningColor;                                     // 0x0370(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             RemainingTimeTextBlock;                            // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 RefreshImage;                                      // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGBloodStoreTimer">();
	}
	static class UUMGBloodStoreTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGBloodStoreTimer>();
	}
};
static_assert(alignof(UUMGBloodStoreTimer) == 0x000008, "Wrong alignment on UUMGBloodStoreTimer");
static_assert(sizeof(UUMGBloodStoreTimer) == 0x0003C0, "Wrong size on UUMGBloodStoreTimer");
static_assert(offsetof(UUMGBloodStoreTimer, _normalColor) == 0x000348, "Member 'UUMGBloodStoreTimer::_normalColor' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreTimer, _warningColor) == 0x000370, "Member 'UUMGBloodStoreTimer::_warningColor' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreTimer, RemainingTimeTextBlock) == 0x000398, "Member 'UUMGBloodStoreTimer::RemainingTimeTextBlock' has a wrong offset!");
static_assert(offsetof(UUMGBloodStoreTimer, RefreshImage) == 0x0003A0, "Member 'UUMGBloodStoreTimer::RefreshImage' has a wrong offset!");

// Class DeadByDaylight.UMGCharacterFreeTicketItemButton
// 0x0020 (0x0358 - 0x0338)
class UUMGCharacterFreeTicketItemButton final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x20];                                     // 0x0338(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastClickEvent();
	void UpdateWidget(const class FString& bgPath, bool isSlasher, int32 durationInHours, int32 itemCount, const struct FSlateColor& iconColor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCharacterFreeTicketItemButton">();
	}
	static class UUMGCharacterFreeTicketItemButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCharacterFreeTicketItemButton>();
	}
};
static_assert(alignof(UUMGCharacterFreeTicketItemButton) == 0x000008, "Wrong alignment on UUMGCharacterFreeTicketItemButton");
static_assert(sizeof(UUMGCharacterFreeTicketItemButton) == 0x000358, "Wrong size on UUMGCharacterFreeTicketItemButton");

// Class DeadByDaylight.UMGCharacterFreeTicketWidget
// 0x0060 (0x0398 - 0x0338)
class UUMGCharacterFreeTicketWidget final : public UMobileBaseUserWidget
{
public:
	TMulticastInlineDelegate<void(const class FString& ticketId, const class FString& characterName)> OnUseFreeTicketEvent; // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        PanelSwitcher;                                     // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           FreeTicketItemButtonBox;                           // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   _buttonClass;                                      // 0x0358(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleButtonClickEvent(const class FString& ticketID, const class FString& characterName);
	void UpdateBGColor(bool isSlasher);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCharacterFreeTicketWidget">();
	}
	static class UUMGCharacterFreeTicketWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCharacterFreeTicketWidget>();
	}
};
static_assert(alignof(UUMGCharacterFreeTicketWidget) == 0x000008, "Wrong alignment on UUMGCharacterFreeTicketWidget");
static_assert(sizeof(UUMGCharacterFreeTicketWidget) == 0x000398, "Wrong size on UUMGCharacterFreeTicketWidget");
static_assert(offsetof(UUMGCharacterFreeTicketWidget, OnUseFreeTicketEvent) == 0x000338, "Member 'UUMGCharacterFreeTicketWidget::OnUseFreeTicketEvent' has a wrong offset!");
static_assert(offsetof(UUMGCharacterFreeTicketWidget, PanelSwitcher) == 0x000348, "Member 'UUMGCharacterFreeTicketWidget::PanelSwitcher' has a wrong offset!");
static_assert(offsetof(UUMGCharacterFreeTicketWidget, FreeTicketItemButtonBox) == 0x000350, "Member 'UUMGCharacterFreeTicketWidget::FreeTicketItemButtonBox' has a wrong offset!");
static_assert(offsetof(UUMGCharacterFreeTicketWidget, _buttonClass) == 0x000358, "Member 'UUMGCharacterFreeTicketWidget::_buttonClass' has a wrong offset!");

// Class DeadByDaylight.UMGCharacterInfoWidget
// 0x0130 (0x0468 - 0x0338)
class UUMGCharacterInfoWidget final : public UMobileBaseUserWidget
{
public:
	class UScrollBox*                             CharacterInfoScrollBox;                            // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGCharacterScrollingInfoWidget*       CharacterScrollingInfoWidget;                      // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CharacterDLCPanel;                                 // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CharacterBackgroundImage;                          // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CharacterName;                                     // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _characterDifficultyText;                          // 0x0360(0x0018)(Edit, BlueprintVisible, NoClear, Protected, NativeAccessSpecifierProtected)
	class FString                                 _characterDLCText;                                 // 0x0378(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isKiller;                                         // 0x0388(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            _easyColor;                                        // 0x0390(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            _intermediaryColor;                                // 0x03B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            _hardColor;                                        // 0x03E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            _currentColor;                                     // 0x0408(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _characterDLCTitle;                                // 0x0430(0x0018)(Edit, BlueprintVisible, NoClear, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FTeachableData& teachableData, const struct FVector2D& position)> _onTeachableTooltipTriggeredLongPressEvent; // 0x0448(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(const struct FInventorySlotData& itemSlotData, const struct FVector2D& position)> _onPowerItemTooltipTriggeredLongPressEvent; // 0x0458(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)

public:
	void HandlePowerItemTooltipLongPressedEvent(const struct FInventorySlotData& slotData, const struct FVector2D& position);
	void HandleTooltipLongPressedEvent(const struct FTeachableData& teachableData, const struct FVector2D& position);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCharacterInfoWidget">();
	}
	static class UUMGCharacterInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCharacterInfoWidget>();
	}
};
static_assert(alignof(UUMGCharacterInfoWidget) == 0x000008, "Wrong alignment on UUMGCharacterInfoWidget");
static_assert(sizeof(UUMGCharacterInfoWidget) == 0x000468, "Wrong size on UUMGCharacterInfoWidget");
static_assert(offsetof(UUMGCharacterInfoWidget, CharacterInfoScrollBox) == 0x000338, "Member 'UUMGCharacterInfoWidget::CharacterInfoScrollBox' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoWidget, CharacterScrollingInfoWidget) == 0x000340, "Member 'UUMGCharacterInfoWidget::CharacterScrollingInfoWidget' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoWidget, CharacterDLCPanel) == 0x000348, "Member 'UUMGCharacterInfoWidget::CharacterDLCPanel' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoWidget, CharacterBackgroundImage) == 0x000350, "Member 'UUMGCharacterInfoWidget::CharacterBackgroundImage' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoWidget, CharacterName) == 0x000358, "Member 'UUMGCharacterInfoWidget::CharacterName' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoWidget, _characterDifficultyText) == 0x000360, "Member 'UUMGCharacterInfoWidget::_characterDifficultyText' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoWidget, _characterDLCText) == 0x000378, "Member 'UUMGCharacterInfoWidget::_characterDLCText' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoWidget, _isKiller) == 0x000388, "Member 'UUMGCharacterInfoWidget::_isKiller' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoWidget, _easyColor) == 0x000390, "Member 'UUMGCharacterInfoWidget::_easyColor' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoWidget, _intermediaryColor) == 0x0003B8, "Member 'UUMGCharacterInfoWidget::_intermediaryColor' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoWidget, _hardColor) == 0x0003E0, "Member 'UUMGCharacterInfoWidget::_hardColor' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoWidget, _currentColor) == 0x000408, "Member 'UUMGCharacterInfoWidget::_currentColor' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoWidget, _characterDLCTitle) == 0x000430, "Member 'UUMGCharacterInfoWidget::_characterDLCTitle' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoWidget, _onTeachableTooltipTriggeredLongPressEvent) == 0x000448, "Member 'UUMGCharacterInfoWidget::_onTeachableTooltipTriggeredLongPressEvent' has a wrong offset!");
static_assert(offsetof(UUMGCharacterInfoWidget, _onPowerItemTooltipTriggeredLongPressEvent) == 0x000458, "Member 'UUMGCharacterInfoWidget::_onPowerItemTooltipTriggeredLongPressEvent' has a wrong offset!");

// Class DeadByDaylight.UMGCharacterPageScrollWidget
// 0x00A8 (0x0518 - 0x0470)
class UUMGCharacterPageScrollWidget final : public UUMGGridPageScrollWidget
{
public:
	uint8                                         Pad_470[0x10];                                     // 0x0470(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _characterButtonWidgetClass;                       // 0x0480(0x0030)(Edit, BlueprintVisible, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FCharacterSlotData>             _charactersData;                                   // 0x04B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          _isKiller;                                         // 0x04C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C1[0x7];                                      // 0x04C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   _charactersTitleText;                              // 0x04C8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _killersTitleText;                                 // 0x04E0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _survivorsTitleText;                               // 0x04F8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_510[0x8];                                      // 0x0510(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleCharacterClicked(int32 characterIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCharacterPageScrollWidget">();
	}
	static class UUMGCharacterPageScrollWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCharacterPageScrollWidget>();
	}
};
static_assert(alignof(UUMGCharacterPageScrollWidget) == 0x000008, "Wrong alignment on UUMGCharacterPageScrollWidget");
static_assert(sizeof(UUMGCharacterPageScrollWidget) == 0x000518, "Wrong size on UUMGCharacterPageScrollWidget");
static_assert(offsetof(UUMGCharacterPageScrollWidget, _characterButtonWidgetClass) == 0x000480, "Member 'UUMGCharacterPageScrollWidget::_characterButtonWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGCharacterPageScrollWidget, _charactersData) == 0x0004B0, "Member 'UUMGCharacterPageScrollWidget::_charactersData' has a wrong offset!");
static_assert(offsetof(UUMGCharacterPageScrollWidget, _isKiller) == 0x0004C0, "Member 'UUMGCharacterPageScrollWidget::_isKiller' has a wrong offset!");
static_assert(offsetof(UUMGCharacterPageScrollWidget, _charactersTitleText) == 0x0004C8, "Member 'UUMGCharacterPageScrollWidget::_charactersTitleText' has a wrong offset!");
static_assert(offsetof(UUMGCharacterPageScrollWidget, _killersTitleText) == 0x0004E0, "Member 'UUMGCharacterPageScrollWidget::_killersTitleText' has a wrong offset!");
static_assert(offsetof(UUMGCharacterPageScrollWidget, _survivorsTitleText) == 0x0004F8, "Member 'UUMGCharacterPageScrollWidget::_survivorsTitleText' has a wrong offset!");

// Class DeadByDaylight.UMGCharacterRotationWidget
// 0x0038 (0x02D0 - 0x0298)
class UUMGCharacterRotationWidget final : public UUserWidget
{
public:
	uint8                                         Pad_298[0x38];                                     // 0x0298(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCharacterRotationWidget">();
	}
	static class UUMGCharacterRotationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCharacterRotationWidget>();
	}
};
static_assert(alignof(UUMGCharacterRotationWidget) == 0x000008, "Wrong alignment on UUMGCharacterRotationWidget");
static_assert(sizeof(UUMGCharacterRotationWidget) == 0x0002D0, "Wrong size on UUMGCharacterRotationWidget");

// Class DeadByDaylight.UMGCharacterScrollingInfoWidget
// 0x0160 (0x0498 - 0x0338)
class UUMGCharacterScrollingInfoWidget final : public UMobileBaseUserWidget
{
public:
	class UUMGTeachablePerkButton*                FirstTeachablePerk;                                // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGTeachablePerkButton*                SecondTeachablePerk;                               // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGTeachablePerkButton*                ThirdTeachablePerk;                                // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           KillerInfoPanel;                                   // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGInventoryItemButton*                KillerPower;                                       // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGHtmlRichText*                       CharacterBackstoryBox;                             // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _killerPowerName;                                  // 0x0368(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _killerSpeedText;                                  // 0x0380(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _killerTerrorRadiusText;                           // 0x0398(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _killerHeightText;                                 // 0x03B0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _perksTitle;                                       // 0x03C8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _teachablesTitle;                                  // 0x03E0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _powerTitle;                                       // 0x03F8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _attributesTitle;                                  // 0x0410(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             FirstTeachablePerkText;                            // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             SecondTeachablePerkText;                           // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ThirdTeachablePerkText;                            // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _backStoryTitle;                                   // 0x0440(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<class UUMGTeachablePerkButton*>        _teachablePerkArray;                               // 0x0458(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UTextBlock*>                     _teachablePerkNameArray;                           // 0x0468(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(const struct FTeachableData& teachableData, const struct FVector2D& position)> _onTeachableTooltipTriggeredEvent; // 0x0478(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)
	TMulticastInlineDelegate<void(const struct FInventorySlotData& itemSlotData, const struct FVector2D& position)> _onPowerButtonTooltipLongPressEvent; // 0x0488(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)

public:
	void HandleTooltipLongPressedEvent(const struct FTeachableData& teachableData, const struct FVector2D& position);
	void HandleTooltipLongPressedKillerPowerEvent(const struct FInventorySlotData& itemData, const struct FVector2D& position);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCharacterScrollingInfoWidget">();
	}
	static class UUMGCharacterScrollingInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCharacterScrollingInfoWidget>();
	}
};
static_assert(alignof(UUMGCharacterScrollingInfoWidget) == 0x000008, "Wrong alignment on UUMGCharacterScrollingInfoWidget");
static_assert(sizeof(UUMGCharacterScrollingInfoWidget) == 0x000498, "Wrong size on UUMGCharacterScrollingInfoWidget");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, FirstTeachablePerk) == 0x000338, "Member 'UUMGCharacterScrollingInfoWidget::FirstTeachablePerk' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, SecondTeachablePerk) == 0x000340, "Member 'UUMGCharacterScrollingInfoWidget::SecondTeachablePerk' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, ThirdTeachablePerk) == 0x000348, "Member 'UUMGCharacterScrollingInfoWidget::ThirdTeachablePerk' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, KillerInfoPanel) == 0x000350, "Member 'UUMGCharacterScrollingInfoWidget::KillerInfoPanel' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, KillerPower) == 0x000358, "Member 'UUMGCharacterScrollingInfoWidget::KillerPower' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, CharacterBackstoryBox) == 0x000360, "Member 'UUMGCharacterScrollingInfoWidget::CharacterBackstoryBox' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, _killerPowerName) == 0x000368, "Member 'UUMGCharacterScrollingInfoWidget::_killerPowerName' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, _killerSpeedText) == 0x000380, "Member 'UUMGCharacterScrollingInfoWidget::_killerSpeedText' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, _killerTerrorRadiusText) == 0x000398, "Member 'UUMGCharacterScrollingInfoWidget::_killerTerrorRadiusText' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, _killerHeightText) == 0x0003B0, "Member 'UUMGCharacterScrollingInfoWidget::_killerHeightText' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, _perksTitle) == 0x0003C8, "Member 'UUMGCharacterScrollingInfoWidget::_perksTitle' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, _teachablesTitle) == 0x0003E0, "Member 'UUMGCharacterScrollingInfoWidget::_teachablesTitle' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, _powerTitle) == 0x0003F8, "Member 'UUMGCharacterScrollingInfoWidget::_powerTitle' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, _attributesTitle) == 0x000410, "Member 'UUMGCharacterScrollingInfoWidget::_attributesTitle' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, FirstTeachablePerkText) == 0x000428, "Member 'UUMGCharacterScrollingInfoWidget::FirstTeachablePerkText' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, SecondTeachablePerkText) == 0x000430, "Member 'UUMGCharacterScrollingInfoWidget::SecondTeachablePerkText' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, ThirdTeachablePerkText) == 0x000438, "Member 'UUMGCharacterScrollingInfoWidget::ThirdTeachablePerkText' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, _backStoryTitle) == 0x000440, "Member 'UUMGCharacterScrollingInfoWidget::_backStoryTitle' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, _teachablePerkArray) == 0x000458, "Member 'UUMGCharacterScrollingInfoWidget::_teachablePerkArray' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, _teachablePerkNameArray) == 0x000468, "Member 'UUMGCharacterScrollingInfoWidget::_teachablePerkNameArray' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, _onTeachableTooltipTriggeredEvent) == 0x000478, "Member 'UUMGCharacterScrollingInfoWidget::_onTeachableTooltipTriggeredEvent' has a wrong offset!");
static_assert(offsetof(UUMGCharacterScrollingInfoWidget, _onPowerButtonTooltipLongPressEvent) == 0x000488, "Member 'UUMGCharacterScrollingInfoWidget::_onPowerButtonTooltipLongPressEvent' has a wrong offset!");

// Class DeadByDaylight.UMGCharacterSelectSubmenu
// 0x0020 (0x0358 - 0x0338)
class UUMGCharacterSelectSubmenu final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x20];                                     // 0x0338(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastInfoButtonClicked();
	void BroadcastRoleButtonClicked();
	void SetCurrentRole(bool isKiller);
	void SetInInfoPanelMode(bool isInInfoPanel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCharacterSelectSubmenu">();
	}
	static class UUMGCharacterSelectSubmenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCharacterSelectSubmenu>();
	}
};
static_assert(alignof(UUMGCharacterSelectSubmenu) == 0x000008, "Wrong alignment on UUMGCharacterSelectSubmenu");
static_assert(sizeof(UUMGCharacterSelectSubmenu) == 0x000358, "Wrong size on UUMGCharacterSelectSubmenu");

// Class DeadByDaylight.UMGCharacterSelectSubmenuButton
// 0x0008 (0x0470 - 0x0468)
class UUMGCharacterSelectSubmenuButton final : public UUMGBaseButtonWidget
{
public:
	class UCanvasPanel*                           NotificationPanel;                                 // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCharacterSelectSubmenuButton">();
	}
	static class UUMGCharacterSelectSubmenuButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCharacterSelectSubmenuButton>();
	}
};
static_assert(alignof(UUMGCharacterSelectSubmenuButton) == 0x000008, "Wrong alignment on UUMGCharacterSelectSubmenuButton");
static_assert(sizeof(UUMGCharacterSelectSubmenuButton) == 0x000470, "Wrong size on UUMGCharacterSelectSubmenuButton");
static_assert(offsetof(UUMGCharacterSelectSubmenuButton, NotificationPanel) == 0x000468, "Member 'UUMGCharacterSelectSubmenuButton::NotificationPanel' has a wrong offset!");

// Class DeadByDaylight.UMGCharacterSlideShowWidget
// 0x0070 (0x03A8 - 0x0338)
class UUMGCharacterSlideShowWidget final : public UMobileBaseUserWidget
{
public:
	TMap<class FName, TSoftObjectPtr<class UTexture2D>> _perkCategoriesIcons;                        // 0x0338(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         SecondsBeforeNextSlide;                            // 0x0388(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x1C];                                     // 0x038C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisplayCharacterSlide(const struct FCharacterSlideData& characterSlide);
	void FadeIn();
	void FadeOut();
	void SwitchCharacterSlide();
	void WaitAndFadeOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCharacterSlideShowWidget">();
	}
	static class UUMGCharacterSlideShowWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCharacterSlideShowWidget>();
	}
};
static_assert(alignof(UUMGCharacterSlideShowWidget) == 0x000008, "Wrong alignment on UUMGCharacterSlideShowWidget");
static_assert(sizeof(UUMGCharacterSlideShowWidget) == 0x0003A8, "Wrong size on UUMGCharacterSlideShowWidget");
static_assert(offsetof(UUMGCharacterSlideShowWidget, _perkCategoriesIcons) == 0x000338, "Member 'UUMGCharacterSlideShowWidget::_perkCategoriesIcons' has a wrong offset!");
static_assert(offsetof(UUMGCharacterSlideShowWidget, SecondsBeforeNextSlide) == 0x000388, "Member 'UUMGCharacterSlideShowWidget::SecondsBeforeNextSlide' has a wrong offset!");

// Class DeadByDaylight.UMGCommandDebugButton
// 0x0020 (0x0358 - 0x0338)
class UUMGCommandDebugButton final : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             CommandLabel;                                      // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UButton*                                CommandButton;                                     // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CommandName;                                       // 0x0348(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void TriggerCommand();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCommandDebugButton">();
	}
	static class UUMGCommandDebugButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCommandDebugButton>();
	}
};
static_assert(alignof(UUMGCommandDebugButton) == 0x000008, "Wrong alignment on UUMGCommandDebugButton");
static_assert(sizeof(UUMGCommandDebugButton) == 0x000358, "Wrong size on UUMGCommandDebugButton");
static_assert(offsetof(UUMGCommandDebugButton, CommandLabel) == 0x000338, "Member 'UUMGCommandDebugButton::CommandLabel' has a wrong offset!");
static_assert(offsetof(UUMGCommandDebugButton, CommandButton) == 0x000340, "Member 'UUMGCommandDebugButton::CommandButton' has a wrong offset!");
static_assert(offsetof(UUMGCommandDebugButton, CommandName) == 0x000348, "Member 'UUMGCommandDebugButton::CommandName' has a wrong offset!");

// Class DeadByDaylight.UMGControlTypeSelectionWidget
// 0x0040 (0x0378 - 0x0338)
class UUMGControlTypeSelectionWidget final : public UMobileBaseUserWidget
{
public:
	class UUMGControlTypeWidget*                  SnapOnJoystick;                                    // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGControlTypeWidget*                  CameraFullScreen;                                  // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TitleText;                                         // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_350[0x28];                                     // 0x0350(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateControlType(EAtlantaControlTypeSetting controlType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGControlTypeSelectionWidget">();
	}
	static class UUMGControlTypeSelectionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGControlTypeSelectionWidget>();
	}
};
static_assert(alignof(UUMGControlTypeSelectionWidget) == 0x000008, "Wrong alignment on UUMGControlTypeSelectionWidget");
static_assert(sizeof(UUMGControlTypeSelectionWidget) == 0x000378, "Wrong size on UUMGControlTypeSelectionWidget");
static_assert(offsetof(UUMGControlTypeSelectionWidget, SnapOnJoystick) == 0x000338, "Member 'UUMGControlTypeSelectionWidget::SnapOnJoystick' has a wrong offset!");
static_assert(offsetof(UUMGControlTypeSelectionWidget, CameraFullScreen) == 0x000340, "Member 'UUMGControlTypeSelectionWidget::CameraFullScreen' has a wrong offset!");
static_assert(offsetof(UUMGControlTypeSelectionWidget, TitleText) == 0x000348, "Member 'UUMGControlTypeSelectionWidget::TitleText' has a wrong offset!");

// Class DeadByDaylight.UMGCustomizationCategoriesBar
// 0x0010 (0x0348 - 0x0338)
class UUMGCustomizationCategoriesBar final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastCustomizationCategoryButtonPressed(ECustomizationCategory categoryIndex);
	void SetRole(const bool isKiller);
	void SetSelectedCategory(const ECustomizationCategory category);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCustomizationCategoriesBar">();
	}
	static class UUMGCustomizationCategoriesBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCustomizationCategoriesBar>();
	}
};
static_assert(alignof(UUMGCustomizationCategoriesBar) == 0x000008, "Wrong alignment on UUMGCustomizationCategoriesBar");
static_assert(sizeof(UUMGCustomizationCategoriesBar) == 0x000348, "Wrong size on UUMGCustomizationCategoriesBar");

// Class DeadByDaylight.UMGCustomizationInfoWidget
// 0x0180 (0x04B8 - 0x0338)
class UUMGCustomizationInfoWidget final : public UMobileBaseUserWidget
{
public:
	class UImage*                                 Icon;                                              // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Background;                                        // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         InformationText;                                   // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            BackgroundColor;                                   // 0x0350(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            TextColor;                                         // 0x0378(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            IconColor;                                         // 0x03A0(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              DefaultIcon;                                       // 0x03C8(0x0030)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              KillerIcon;                                        // 0x03F8(0x0030)(Edit, DisableEditOnInstance, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              SurvivorIcon;                                      // 0x0428(0x0030)(Edit, DisableEditOnInstance, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              BreakableIcon;                                     // 0x0458(0x0030)(Edit, DisableEditOnInstance, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              UnbreakableIcon;                                   // 0x0488(0x0030)(Edit, DisableEditOnInstance, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCustomizationInfoWidget">();
	}
	static class UUMGCustomizationInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCustomizationInfoWidget>();
	}
};
static_assert(alignof(UUMGCustomizationInfoWidget) == 0x000008, "Wrong alignment on UUMGCustomizationInfoWidget");
static_assert(sizeof(UUMGCustomizationInfoWidget) == 0x0004B8, "Wrong size on UUMGCustomizationInfoWidget");
static_assert(offsetof(UUMGCustomizationInfoWidget, Icon) == 0x000338, "Member 'UUMGCustomizationInfoWidget::Icon' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationInfoWidget, Background) == 0x000340, "Member 'UUMGCustomizationInfoWidget::Background' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationInfoWidget, InformationText) == 0x000348, "Member 'UUMGCustomizationInfoWidget::InformationText' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationInfoWidget, BackgroundColor) == 0x000350, "Member 'UUMGCustomizationInfoWidget::BackgroundColor' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationInfoWidget, TextColor) == 0x000378, "Member 'UUMGCustomizationInfoWidget::TextColor' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationInfoWidget, IconColor) == 0x0003A0, "Member 'UUMGCustomizationInfoWidget::IconColor' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationInfoWidget, DefaultIcon) == 0x0003C8, "Member 'UUMGCustomizationInfoWidget::DefaultIcon' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationInfoWidget, KillerIcon) == 0x0003F8, "Member 'UUMGCustomizationInfoWidget::KillerIcon' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationInfoWidget, SurvivorIcon) == 0x000428, "Member 'UUMGCustomizationInfoWidget::SurvivorIcon' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationInfoWidget, BreakableIcon) == 0x000458, "Member 'UUMGCustomizationInfoWidget::BreakableIcon' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationInfoWidget, UnbreakableIcon) == 0x000488, "Member 'UUMGCustomizationInfoWidget::UnbreakableIcon' has a wrong offset!");

// Class DeadByDaylight.UMGCustomizationItemWidget
// 0x00A0 (0x03D8 - 0x0338)
class UUMGCustomizationItemWidget final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 RarityBackground;                                  // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PaintOverlay;                                      // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Icon;                                              // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           NewIndicator;                                      // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           OutfitIndicator;                                   // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           PricesContainer;                                   // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ItemSelectedBorder;                                // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           EquippedContainer;                                 // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   _customizationItemPriceWidgetClass;                // 0x0388(0x0030)(Edit, DisableEditOnInstance, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUMGCustomizationItemPriceWidget*> _priceWidgets;                                   // 0x03B8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         _itemIndex;                                        // 0x03C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _itemId;                                           // 0x03CC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BroadcastAvailableItemSelected();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCustomizationItemWidget">();
	}
	static class UUMGCustomizationItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCustomizationItemWidget>();
	}
};
static_assert(alignof(UUMGCustomizationItemWidget) == 0x000008, "Wrong alignment on UUMGCustomizationItemWidget");
static_assert(sizeof(UUMGCustomizationItemWidget) == 0x0003D8, "Wrong size on UUMGCustomizationItemWidget");
static_assert(offsetof(UUMGCustomizationItemWidget, RarityBackground) == 0x000348, "Member 'UUMGCustomizationItemWidget::RarityBackground' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemWidget, PaintOverlay) == 0x000350, "Member 'UUMGCustomizationItemWidget::PaintOverlay' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemWidget, Icon) == 0x000358, "Member 'UUMGCustomizationItemWidget::Icon' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemWidget, NewIndicator) == 0x000360, "Member 'UUMGCustomizationItemWidget::NewIndicator' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemWidget, OutfitIndicator) == 0x000368, "Member 'UUMGCustomizationItemWidget::OutfitIndicator' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemWidget, PricesContainer) == 0x000370, "Member 'UUMGCustomizationItemWidget::PricesContainer' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemWidget, ItemSelectedBorder) == 0x000378, "Member 'UUMGCustomizationItemWidget::ItemSelectedBorder' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemWidget, EquippedContainer) == 0x000380, "Member 'UUMGCustomizationItemWidget::EquippedContainer' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemWidget, _customizationItemPriceWidgetClass) == 0x000388, "Member 'UUMGCustomizationItemWidget::_customizationItemPriceWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemWidget, _priceWidgets) == 0x0003B8, "Member 'UUMGCustomizationItemWidget::_priceWidgets' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemWidget, _itemIndex) == 0x0003C8, "Member 'UUMGCustomizationItemWidget::_itemIndex' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationItemWidget, _itemId) == 0x0003CC, "Member 'UUMGCustomizationItemWidget::_itemId' has a wrong offset!");

// Class DeadByDaylight.UMGCustomizationPageScrollWidget
// 0x0068 (0x04D8 - 0x0470)
class UUMGCustomizationPageScrollWidget final : public UUMGGridPageScrollWidget
{
public:
	uint8                                         Pad_470[0x10];                                     // 0x0470(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _customizationItemWidgetClass;                     // 0x0480(0x0030)(Edit, DisableEditOnInstance, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FStoreItemSlotData>             _availableItemsData;                               // 0x04B0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UUMGCustomizationItemWidget*>    _itemWidgets;                                      // 0x04C0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAvailableItemSelectedCallback(int32 itemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCustomizationPageScrollWidget">();
	}
	static class UUMGCustomizationPageScrollWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCustomizationPageScrollWidget>();
	}
};
static_assert(alignof(UUMGCustomizationPageScrollWidget) == 0x000008, "Wrong alignment on UUMGCustomizationPageScrollWidget");
static_assert(sizeof(UUMGCustomizationPageScrollWidget) == 0x0004D8, "Wrong size on UUMGCustomizationPageScrollWidget");
static_assert(offsetof(UUMGCustomizationPageScrollWidget, _customizationItemWidgetClass) == 0x000480, "Member 'UUMGCustomizationPageScrollWidget::_customizationItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationPageScrollWidget, _availableItemsData) == 0x0004B0, "Member 'UUMGCustomizationPageScrollWidget::_availableItemsData' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationPageScrollWidget, _itemWidgets) == 0x0004C0, "Member 'UUMGCustomizationPageScrollWidget::_itemWidgets' has a wrong offset!");

// Class DeadByDaylight.UMGCustomizationScreenWidget
// 0x00B0 (0x03E8 - 0x0338)
class UUMGCustomizationScreenWidget final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x30];                                     // 0x0338(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGCustomizationPageScrollWidget*      PageScrollWidget;                                  // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGCustomizationCategoriesBar*         CustomizationCategoriesBar;                        // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CategoryLabel;                                     // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentlyEquippedLabel;                            // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           AvailableInOutfitsContainer;                       // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           UnlockItemContainer;                               // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGCustomizationItemWidget*            OutfitItem;                                        // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           PriceContainer;                                    // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PriceButtonWidgetClass;                            // 0x03A8(0x0030)(Edit, DisableEditOnInstance, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x4];                                      // 0x03D8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _currentSelectedItem;                              // 0x03DC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BroadcastAvailableItemSelectedEvent(int32 itemIndex, const struct FStoreItemSlotData& selectedItem, const struct FStoreItemSlotData& parentItem);
	void BroadcastCustomizationCategoryButtonPressed(int32 categoryIndex);
	void BroadcastUnlockWithCurrencyEvent(int32 currencyId, const class FString& combinedItem);
	void SetCategoryLabel(const ECustomizationCategory category);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCustomizationScreenWidget">();
	}
	static class UUMGCustomizationScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCustomizationScreenWidget>();
	}
};
static_assert(alignof(UUMGCustomizationScreenWidget) == 0x000008, "Wrong alignment on UUMGCustomizationScreenWidget");
static_assert(sizeof(UUMGCustomizationScreenWidget) == 0x0003E8, "Wrong size on UUMGCustomizationScreenWidget");
static_assert(offsetof(UUMGCustomizationScreenWidget, PageScrollWidget) == 0x000368, "Member 'UUMGCustomizationScreenWidget::PageScrollWidget' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationScreenWidget, CustomizationCategoriesBar) == 0x000370, "Member 'UUMGCustomizationScreenWidget::CustomizationCategoriesBar' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationScreenWidget, CategoryLabel) == 0x000378, "Member 'UUMGCustomizationScreenWidget::CategoryLabel' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationScreenWidget, CurrentlyEquippedLabel) == 0x000380, "Member 'UUMGCustomizationScreenWidget::CurrentlyEquippedLabel' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationScreenWidget, AvailableInOutfitsContainer) == 0x000388, "Member 'UUMGCustomizationScreenWidget::AvailableInOutfitsContainer' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationScreenWidget, UnlockItemContainer) == 0x000390, "Member 'UUMGCustomizationScreenWidget::UnlockItemContainer' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationScreenWidget, OutfitItem) == 0x000398, "Member 'UUMGCustomizationScreenWidget::OutfitItem' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationScreenWidget, PriceContainer) == 0x0003A0, "Member 'UUMGCustomizationScreenWidget::PriceContainer' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationScreenWidget, PriceButtonWidgetClass) == 0x0003A8, "Member 'UUMGCustomizationScreenWidget::PriceButtonWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationScreenWidget, _currentSelectedItem) == 0x0003DC, "Member 'UUMGCustomizationScreenWidget::_currentSelectedItem' has a wrong offset!");

// Class DeadByDaylight.UMGCustomizationTooltipHeaderWidget
// 0x0018 (0x0350 - 0x0338)
class UUMGCustomizationTooltipHeaderWidget final : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             Title;                                             // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CollectionName;                                    // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CategoryAndRarityText;                             // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetOutfitComposition(const bool isUnbreakable, const TArray<ECustomizationCategory>& composition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGCustomizationTooltipHeaderWidget">();
	}
	static class UUMGCustomizationTooltipHeaderWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGCustomizationTooltipHeaderWidget>();
	}
};
static_assert(alignof(UUMGCustomizationTooltipHeaderWidget) == 0x000008, "Wrong alignment on UUMGCustomizationTooltipHeaderWidget");
static_assert(sizeof(UUMGCustomizationTooltipHeaderWidget) == 0x000350, "Wrong size on UUMGCustomizationTooltipHeaderWidget");
static_assert(offsetof(UUMGCustomizationTooltipHeaderWidget, Title) == 0x000338, "Member 'UUMGCustomizationTooltipHeaderWidget::Title' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationTooltipHeaderWidget, CollectionName) == 0x000340, "Member 'UUMGCustomizationTooltipHeaderWidget::CollectionName' has a wrong offset!");
static_assert(offsetof(UUMGCustomizationTooltipHeaderWidget, CategoryAndRarityText) == 0x000348, "Member 'UUMGCustomizationTooltipHeaderWidget::CategoryAndRarityText' has a wrong offset!");

// Class DeadByDaylight.UMGDailyRewardWidget
// 0x00A0 (0x0508 - 0x0468)
class UUMGDailyRewardWidget final : public UUMGBaseButtonWidget
{
public:
	TMulticastInlineDelegate<void(int32 param1, int32 param2)> OnDailyRewardStateChanged;            // 0x0468(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	bool                                          IsMarkedSpecial;                                   // 0x0478(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUMGDailyRewardWidgetState                    State;                                             // 0x0479(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_47A[0x6];                                      // 0x047A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             AmountText;                                        // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemNameText;                                      // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RewardNumberText;                                  // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        RewardTypeSwitcher;                                // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ItemInfoPanel;                                     // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           OfferingInfoPanel;                                 // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           GenericInfoPanel;                                  // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           FreeTicketInfoPanel;                               // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CrateKeyInfoPanel;                                 // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemIcon;                                          // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 OfferingIcon;                                      // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 GenericRewardIcon;                                 // 0x04D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FreeTicketRewardIcon;                              // 0x04E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ParentItemIcon;                                    // 0x04E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CrateKeyRewardIcon;                                // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ParentItemPanel;                                   // 0x04F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_500[0x8];                                      // 0x0500(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CollectReward();
	void DiscoverMysteryReward();
	void HandleCollectButtonClick();
	void HandleCollectRewardAnimationFinished();
	void HandleDiscoverRewardAnimationFinished();
	void HandleUnlockMysteryRewardAnimationFinished();
	void HandleUnlockRewardAnimationFinished();
	void PlayIdleAnimationForState(const EUMGDailyRewardWidgetState inState);
	void SetRarityColors(const struct FColor& backgroundColor, const struct FColor& tintColor);
	void SetStateVisuals(const EUMGDailyRewardWidgetState inState);
	void StopIdleAnimationForState(const EUMGDailyRewardWidgetState inState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGDailyRewardWidget">();
	}
	static class UUMGDailyRewardWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGDailyRewardWidget>();
	}
};
static_assert(alignof(UUMGDailyRewardWidget) == 0x000008, "Wrong alignment on UUMGDailyRewardWidget");
static_assert(sizeof(UUMGDailyRewardWidget) == 0x000508, "Wrong size on UUMGDailyRewardWidget");
static_assert(offsetof(UUMGDailyRewardWidget, OnDailyRewardStateChanged) == 0x000468, "Member 'UUMGDailyRewardWidget::OnDailyRewardStateChanged' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, IsMarkedSpecial) == 0x000478, "Member 'UUMGDailyRewardWidget::IsMarkedSpecial' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, State) == 0x000479, "Member 'UUMGDailyRewardWidget::State' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, AmountText) == 0x000480, "Member 'UUMGDailyRewardWidget::AmountText' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, ItemNameText) == 0x000488, "Member 'UUMGDailyRewardWidget::ItemNameText' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, RewardNumberText) == 0x000490, "Member 'UUMGDailyRewardWidget::RewardNumberText' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, RewardTypeSwitcher) == 0x000498, "Member 'UUMGDailyRewardWidget::RewardTypeSwitcher' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, ItemInfoPanel) == 0x0004A0, "Member 'UUMGDailyRewardWidget::ItemInfoPanel' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, OfferingInfoPanel) == 0x0004A8, "Member 'UUMGDailyRewardWidget::OfferingInfoPanel' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, GenericInfoPanel) == 0x0004B0, "Member 'UUMGDailyRewardWidget::GenericInfoPanel' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, FreeTicketInfoPanel) == 0x0004B8, "Member 'UUMGDailyRewardWidget::FreeTicketInfoPanel' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, CrateKeyInfoPanel) == 0x0004C0, "Member 'UUMGDailyRewardWidget::CrateKeyInfoPanel' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, ItemIcon) == 0x0004C8, "Member 'UUMGDailyRewardWidget::ItemIcon' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, OfferingIcon) == 0x0004D0, "Member 'UUMGDailyRewardWidget::OfferingIcon' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, GenericRewardIcon) == 0x0004D8, "Member 'UUMGDailyRewardWidget::GenericRewardIcon' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, FreeTicketRewardIcon) == 0x0004E0, "Member 'UUMGDailyRewardWidget::FreeTicketRewardIcon' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, ParentItemIcon) == 0x0004E8, "Member 'UUMGDailyRewardWidget::ParentItemIcon' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, CrateKeyRewardIcon) == 0x0004F0, "Member 'UUMGDailyRewardWidget::CrateKeyRewardIcon' has a wrong offset!");
static_assert(offsetof(UUMGDailyRewardWidget, ParentItemPanel) == 0x0004F8, "Member 'UUMGDailyRewardWidget::ParentItemPanel' has a wrong offset!");

// Class DeadByDaylight.UMGEndGameCollapseProgressWidget
// 0x0040 (0x0378 - 0x0338)
class UUMGEndGameCollapseProgressWidget final : public UMobileBaseUserWidget
{
public:
	class UProgressBar*                           ProgressBar;                                       // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           MarkerLeftCanvas;                                  // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           MarkerRightCanvas;                                 // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBoxSlot*                     _markerLeftBox;                                    // 0x0350(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBoxSlot*                     _markerRightBox;                                   // 0x0358(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_360[0x18];                                     // 0x0360(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGEndGameCollapseProgressWidget">();
	}
	static class UUMGEndGameCollapseProgressWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGEndGameCollapseProgressWidget>();
	}
};
static_assert(alignof(UUMGEndGameCollapseProgressWidget) == 0x000008, "Wrong alignment on UUMGEndGameCollapseProgressWidget");
static_assert(sizeof(UUMGEndGameCollapseProgressWidget) == 0x000378, "Wrong size on UUMGEndGameCollapseProgressWidget");
static_assert(offsetof(UUMGEndGameCollapseProgressWidget, ProgressBar) == 0x000338, "Member 'UUMGEndGameCollapseProgressWidget::ProgressBar' has a wrong offset!");
static_assert(offsetof(UUMGEndGameCollapseProgressWidget, MarkerLeftCanvas) == 0x000340, "Member 'UUMGEndGameCollapseProgressWidget::MarkerLeftCanvas' has a wrong offset!");
static_assert(offsetof(UUMGEndGameCollapseProgressWidget, MarkerRightCanvas) == 0x000348, "Member 'UUMGEndGameCollapseProgressWidget::MarkerRightCanvas' has a wrong offset!");
static_assert(offsetof(UUMGEndGameCollapseProgressWidget, _markerLeftBox) == 0x000350, "Member 'UUMGEndGameCollapseProgressWidget::_markerLeftBox' has a wrong offset!");
static_assert(offsetof(UUMGEndGameCollapseProgressWidget, _markerRightBox) == 0x000358, "Member 'UUMGEndGameCollapseProgressWidget::_markerRightBox' has a wrong offset!");

// Class DeadByDaylight.UMGEndGameCollapseWidget
// 0x0080 (0x03B8 - 0x0338)
class UUMGEndGameCollapseWidget final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _progressBarInterpSpeed;                           // 0x0340(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _slowMode;                                         // 0x0344(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_345[0x3];                                      // 0x0345(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           NormalBar;                                         // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           SlowBar;                                           // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGEndGameCollapseProgressWidget*      NormalProgressBar;                                 // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGEndGameCollapseProgressWidget*      SlowProgressBar;                                   // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x48];                                     // 0x0368(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGEndGameCollapseProgressWidget*      _topBar;                                           // 0x03B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PlayToZeroAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGEndGameCollapseWidget">();
	}
	static class UUMGEndGameCollapseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGEndGameCollapseWidget>();
	}
};
static_assert(alignof(UUMGEndGameCollapseWidget) == 0x000008, "Wrong alignment on UUMGEndGameCollapseWidget");
static_assert(sizeof(UUMGEndGameCollapseWidget) == 0x0003B8, "Wrong size on UUMGEndGameCollapseWidget");
static_assert(offsetof(UUMGEndGameCollapseWidget, _progressBarInterpSpeed) == 0x000340, "Member 'UUMGEndGameCollapseWidget::_progressBarInterpSpeed' has a wrong offset!");
static_assert(offsetof(UUMGEndGameCollapseWidget, _slowMode) == 0x000344, "Member 'UUMGEndGameCollapseWidget::_slowMode' has a wrong offset!");
static_assert(offsetof(UUMGEndGameCollapseWidget, NormalBar) == 0x000348, "Member 'UUMGEndGameCollapseWidget::NormalBar' has a wrong offset!");
static_assert(offsetof(UUMGEndGameCollapseWidget, SlowBar) == 0x000350, "Member 'UUMGEndGameCollapseWidget::SlowBar' has a wrong offset!");
static_assert(offsetof(UUMGEndGameCollapseWidget, NormalProgressBar) == 0x000358, "Member 'UUMGEndGameCollapseWidget::NormalProgressBar' has a wrong offset!");
static_assert(offsetof(UUMGEndGameCollapseWidget, SlowProgressBar) == 0x000360, "Member 'UUMGEndGameCollapseWidget::SlowProgressBar' has a wrong offset!");
static_assert(offsetof(UUMGEndGameCollapseWidget, _topBar) == 0x0003B0, "Member 'UUMGEndGameCollapseWidget::_topBar' has a wrong offset!");

// Class DeadByDaylight.UMGGameplayAlertWidget
// 0x0000 (0x02C8 - 0x02C8)
class UUMGGameplayAlertWidget final : public UUMGBaseAlertWidget
{
public:
	void UpdateWidget(const struct FStatusEffectSlotData& statusEffectData, const struct FInventorySlotData& originatorData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGGameplayAlertWidget">();
	}
	static class UUMGGameplayAlertWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGGameplayAlertWidget>();
	}
};
static_assert(alignof(UUMGGameplayAlertWidget) == 0x000008, "Wrong alignment on UUMGGameplayAlertWidget");
static_assert(sizeof(UUMGGameplayAlertWidget) == 0x0002C8, "Wrong size on UUMGGameplayAlertWidget");

// Class DeadByDaylight.UMGGhostfaceSpecific
// 0x0010 (0x0348 - 0x0338)
class UUMGGhostfaceSpecific final : public UMobileBaseUserWidget
{
public:
	class UImage*                                 LeftLeanImage;                                     // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 RightLeanImage;                                    // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGGhostfaceSpecific">();
	}
	static class UUMGGhostfaceSpecific* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGGhostfaceSpecific>();
	}
};
static_assert(alignof(UUMGGhostfaceSpecific) == 0x000008, "Wrong alignment on UUMGGhostfaceSpecific");
static_assert(sizeof(UUMGGhostfaceSpecific) == 0x000348, "Wrong size on UUMGGhostfaceSpecific");
static_assert(offsetof(UUMGGhostfaceSpecific, LeftLeanImage) == 0x000338, "Member 'UUMGGhostfaceSpecific::LeftLeanImage' has a wrong offset!");
static_assert(offsetof(UUMGGhostfaceSpecific, RightLeanImage) == 0x000340, "Member 'UUMGGhostfaceSpecific::RightLeanImage' has a wrong offset!");

// Class DeadByDaylight.UMGHtmlRichText
// 0x0000 (0x06D0 - 0x06D0)
class UUMGHtmlRichText final : public URichTextBlock
{
public:
	void SetHtmlText(const class FString& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHtmlRichText">();
	}
	static class UUMGHtmlRichText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHtmlRichText>();
	}
};
static_assert(alignof(UUMGHtmlRichText) == 0x000008, "Wrong alignment on UUMGHtmlRichText");
static_assert(sizeof(UUMGHtmlRichText) == 0x0006D0, "Wrong size on UUMGHtmlRichText");

// Class DeadByDaylight.UMGHudEditorLayoutScreen
// 0x0010 (0x02A8 - 0x0298)
class UUMGHudEditorLayoutScreen final : public UUserWidget
{
public:
	TArray<class UUMGDragWidget_HudEditor*>       _editableWidgets;                                  // 0x0298(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHudEditorLayoutScreen">();
	}
	static class UUMGHudEditorLayoutScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHudEditorLayoutScreen>();
	}
};
static_assert(alignof(UUMGHudEditorLayoutScreen) == 0x000008, "Wrong alignment on UUMGHudEditorLayoutScreen");
static_assert(sizeof(UUMGHudEditorLayoutScreen) == 0x0002A8, "Wrong size on UUMGHudEditorLayoutScreen");
static_assert(offsetof(UUMGHudEditorLayoutScreen, _editableWidgets) == 0x000298, "Member 'UUMGHudEditorLayoutScreen::_editableWidgets' has a wrong offset!");

// Class DeadByDaylight.UMGHudEditorLayoutWidget
// 0x0078 (0x0330 - 0x02B8)
class UUMGHudEditorLayoutWidget final : public UUMGDragWidget
{
public:
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UUMGHudEditorScreen*                    HudEditorScreen;                                   // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          _onSaveOverlapSound;                               // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGDragWidget_HudEditor*               _currentWidgetToEdit;                              // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UUMGHudEditorLayoutScreen*, bool>  _isSaveDirtyMap;                                   // 0x02E0(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void FlagSaveAsDirty();
	void FlipLayout();
	void OnSaveDirty(bool isDirty);
	void ResetLayout();
	void SaveLayout();
	void SetHudEditorScreen(class UUMGHudEditorScreen* hudEditorScreen);
	void SetSaveOverlapSound(class UAkAudioEvent* onSaveOverlapSound);
	void SetWidgetToEdit(class UUMGDragWidget_HudEditor* widget);
	void ShowKillerLayout();
	void ShowSurvivorLayout();

	class UUMGDragWidget_HudEditor* GetCurrentDragWidget() const;
	class UCustomWidgetWrapper_HudEditor* GetHudEditorWrapperToEdit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHudEditorLayoutWidget">();
	}
	static class UUMGHudEditorLayoutWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHudEditorLayoutWidget>();
	}
};
static_assert(alignof(UUMGHudEditorLayoutWidget) == 0x000008, "Wrong alignment on UUMGHudEditorLayoutWidget");
static_assert(sizeof(UUMGHudEditorLayoutWidget) == 0x000330, "Wrong size on UUMGHudEditorLayoutWidget");
static_assert(offsetof(UUMGHudEditorLayoutWidget, HudEditorScreen) == 0x0002C8, "Member 'UUMGHudEditorLayoutWidget::HudEditorScreen' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorLayoutWidget, _onSaveOverlapSound) == 0x0002D0, "Member 'UUMGHudEditorLayoutWidget::_onSaveOverlapSound' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorLayoutWidget, _currentWidgetToEdit) == 0x0002D8, "Member 'UUMGHudEditorLayoutWidget::_currentWidgetToEdit' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorLayoutWidget, _isSaveDirtyMap) == 0x0002E0, "Member 'UUMGHudEditorLayoutWidget::_isSaveDirtyMap' has a wrong offset!");

// Class DeadByDaylight.UMGHudEditorVersionWidget
// 0x0028 (0x02C0 - 0x0298)
class UUMGHudEditorVersionWidget final : public UUserWidget
{
public:
	class UButton*                                VersionButton;                                     // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGDragWidget_HudEditor*               _onEditWidget;                                     // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x18];                                     // 0x02A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Hide();
	void OnButtonClick();
	void Show();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGHudEditorVersionWidget">();
	}
	static class UUMGHudEditorVersionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGHudEditorVersionWidget>();
	}
};
static_assert(alignof(UUMGHudEditorVersionWidget) == 0x000008, "Wrong alignment on UUMGHudEditorVersionWidget");
static_assert(sizeof(UUMGHudEditorVersionWidget) == 0x0002C0, "Wrong size on UUMGHudEditorVersionWidget");
static_assert(offsetof(UUMGHudEditorVersionWidget, VersionButton) == 0x000298, "Member 'UUMGHudEditorVersionWidget::VersionButton' has a wrong offset!");
static_assert(offsetof(UUMGHudEditorVersionWidget, _onEditWidget) == 0x0002A0, "Member 'UUMGHudEditorVersionWidget::_onEditWidget' has a wrong offset!");

// Class DeadByDaylight.UMGInboxMessageEntryWidget
// 0x0068 (0x0300 - 0x0298)
class UUMGInboxMessageEntryWidget final : public UUserWidget
{
public:
	struct FInboxMessageUIData                    _messageData;                                      // 0x0298(0x0060)(BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          _isCurrentSelection;                               // 0x02F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FInboxMessageElapsedTime GetElapsedTime();
	void SetMessageData(const struct FInboxMessageUIData& messageData);
	void UpdateMessageData(const struct FInboxMessageUIData& messageData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGInboxMessageEntryWidget">();
	}
	static class UUMGInboxMessageEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGInboxMessageEntryWidget>();
	}
};
static_assert(alignof(UUMGInboxMessageEntryWidget) == 0x000008, "Wrong alignment on UUMGInboxMessageEntryWidget");
static_assert(sizeof(UUMGInboxMessageEntryWidget) == 0x000300, "Wrong size on UUMGInboxMessageEntryWidget");
static_assert(offsetof(UUMGInboxMessageEntryWidget, _messageData) == 0x000298, "Member 'UUMGInboxMessageEntryWidget::_messageData' has a wrong offset!");
static_assert(offsetof(UUMGInboxMessageEntryWidget, _isCurrentSelection) == 0x0002F8, "Member 'UUMGInboxMessageEntryWidget::_isCurrentSelection' has a wrong offset!");

// Class DeadByDaylight.UmgKillerHud
// 0x0288 (0x07E8 - 0x0560)
class UUmgKillerHud final : public UUmgPlayableHud
{
public:
	class UPowerButton*                           PowerButton;                                       // 0x0560(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           PowerButtonContainer;                              // 0x0568(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPowerButton*                           SecondAbilityButton;                               // 0x0570(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           SecondAbilityButtonContainer;                      // 0x0578(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActionButton*                          AttackButton;                                      // 0x0580(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           AttackButtonContainer;                             // 0x0588(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActionButton*                          DropSurvivorButton;                                // 0x0590(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           DropSurvivorButtonContainer;                       // 0x0598(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMobileBaseUserWidget*                  CancelButton;                                      // 0x05A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUMGGhostfaceSpecific*                  GhostfaceSpecific;                                 // 0x05A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           SecondAttackButtonContainer;                       // 0x05B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAtlantaHudPowerAttackJoystick*         HudPowerAttackJoystick;                            // 0x05B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASlasherPlayer*                         Killer;                                            // 0x05C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C8[0x8];                                      // 0x05C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isCancelButtonPressed;                            // 0x05D0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttackButtonPressed;                            // 0x05D1(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isAttackJoystickActivated;                        // 0x05D2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isPowerAttackJoystickActivated;                   // 0x05D3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D4[0x4];                                      // 0x05D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            _powerAttackJoystickBackgroundImage;               // 0x05D8(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            _DefaultAttackJoystickIconPressedImage;            // 0x0668(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            _DefaultAttackJoystickIconUnpressedImage;          // 0x06F8(0x0090)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              _powerAttackJoystickThumbPressedSize;              // 0x0788(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _powerAttackJoystickThumbUnpressedSize;            // 0x0790(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_798[0x50];                                     // 0x0798(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnAttackButtonPressed();
	void HandleOnAttackButtonReleased();
	void InitializePowerAttackJoystickPosition();
	void OnActionButtonPressed();
	void OnActionButtonReleased();
	void OnAttackButtonPressed();
	void OnAttackButtonReleased();
	void OnCancelButtonPressed();
	void OnCancelButtonReleased();
	void OnPowerButtonPressed();
	void OnPowerButtonReleased();
	void OnSecondAbilityButtonLongPressed();
	void OnSecondAbilityButtonPressed();
	void RespondToVirtualJoystickPressChanged(int32 controlIndex, bool pressed);
	void SetPowerAttackJoystickPosition(struct FVector2D& position);
	void SetPowerAttackJoystickThumbImage(bool pressed);
	void SetPowerIconFromItem(class ACollectable* item, EInventoryType inventoryType);
	void UpdatePowerButtonTier(int32 previousTier, int32 currentTier, bool isFirstTime);

	class UInteractionDefinition* GetCurrentPowerUseInteraction() const;
	bool IsAttackButtonVisible() const;
	bool IsCancelPowerButtonAvailable() const;
	bool IsPowerButtonAvailable() const;
	const bool ShouldShowInteractionHighlight(EInputInteractionType interactionType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UmgKillerHud">();
	}
	static class UUmgKillerHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUmgKillerHud>();
	}
};
static_assert(alignof(UUmgKillerHud) == 0x000008, "Wrong alignment on UUmgKillerHud");
static_assert(sizeof(UUmgKillerHud) == 0x0007E8, "Wrong size on UUmgKillerHud");
static_assert(offsetof(UUmgKillerHud, PowerButton) == 0x000560, "Member 'UUmgKillerHud::PowerButton' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, PowerButtonContainer) == 0x000568, "Member 'UUmgKillerHud::PowerButtonContainer' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, SecondAbilityButton) == 0x000570, "Member 'UUmgKillerHud::SecondAbilityButton' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, SecondAbilityButtonContainer) == 0x000578, "Member 'UUmgKillerHud::SecondAbilityButtonContainer' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, AttackButton) == 0x000580, "Member 'UUmgKillerHud::AttackButton' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, AttackButtonContainer) == 0x000588, "Member 'UUmgKillerHud::AttackButtonContainer' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, DropSurvivorButton) == 0x000590, "Member 'UUmgKillerHud::DropSurvivorButton' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, DropSurvivorButtonContainer) == 0x000598, "Member 'UUmgKillerHud::DropSurvivorButtonContainer' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, CancelButton) == 0x0005A0, "Member 'UUmgKillerHud::CancelButton' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, GhostfaceSpecific) == 0x0005A8, "Member 'UUmgKillerHud::GhostfaceSpecific' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, SecondAttackButtonContainer) == 0x0005B0, "Member 'UUmgKillerHud::SecondAttackButtonContainer' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, HudPowerAttackJoystick) == 0x0005B8, "Member 'UUmgKillerHud::HudPowerAttackJoystick' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, Killer) == 0x0005C0, "Member 'UUmgKillerHud::Killer' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, _isCancelButtonPressed) == 0x0005D0, "Member 'UUmgKillerHud::_isCancelButtonPressed' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, _isAttackButtonPressed) == 0x0005D1, "Member 'UUmgKillerHud::_isAttackButtonPressed' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, _isAttackJoystickActivated) == 0x0005D2, "Member 'UUmgKillerHud::_isAttackJoystickActivated' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, _isPowerAttackJoystickActivated) == 0x0005D3, "Member 'UUmgKillerHud::_isPowerAttackJoystickActivated' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, _powerAttackJoystickBackgroundImage) == 0x0005D8, "Member 'UUmgKillerHud::_powerAttackJoystickBackgroundImage' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, _DefaultAttackJoystickIconPressedImage) == 0x000668, "Member 'UUmgKillerHud::_DefaultAttackJoystickIconPressedImage' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, _DefaultAttackJoystickIconUnpressedImage) == 0x0006F8, "Member 'UUmgKillerHud::_DefaultAttackJoystickIconUnpressedImage' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, _powerAttackJoystickThumbPressedSize) == 0x000788, "Member 'UUmgKillerHud::_powerAttackJoystickThumbPressedSize' has a wrong offset!");
static_assert(offsetof(UUmgKillerHud, _powerAttackJoystickThumbUnpressedSize) == 0x000790, "Member 'UUmgKillerHud::_powerAttackJoystickThumbUnpressedSize' has a wrong offset!");

// Class DeadByDaylight.UMGLacerationStatusEffectUI
// 0x0080 (0x03B8 - 0x0338)
class UUMGLacerationStatusEffectUI final : public UMobileBaseUserWidget
{
public:
	class UImage*                                 LacerationDecoration;                              // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LacerationFill;                                    // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 _maximumLacerationDefinitions;                     // 0x0348(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UPaperSprite*>                   _lacerationDecorationImages;                       // 0x0358(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     _lacerationFillImages;                             // 0x0368(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           _lacerationDefaultColor;                           // 0x0378(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _lacerationFillFullColor;                          // 0x0388(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _glassShatterDisintigrateAnimationName;            // 0x0398(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               _lacerationFillFullMI;                             // 0x03A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFinishedBoomAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLacerationStatusEffectUI">();
	}
	static class UUMGLacerationStatusEffectUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLacerationStatusEffectUI>();
	}
};
static_assert(alignof(UUMGLacerationStatusEffectUI) == 0x000008, "Wrong alignment on UUMGLacerationStatusEffectUI");
static_assert(sizeof(UUMGLacerationStatusEffectUI) == 0x0003B8, "Wrong size on UUMGLacerationStatusEffectUI");
static_assert(offsetof(UUMGLacerationStatusEffectUI, LacerationDecoration) == 0x000338, "Member 'UUMGLacerationStatusEffectUI::LacerationDecoration' has a wrong offset!");
static_assert(offsetof(UUMGLacerationStatusEffectUI, LacerationFill) == 0x000340, "Member 'UUMGLacerationStatusEffectUI::LacerationFill' has a wrong offset!");
static_assert(offsetof(UUMGLacerationStatusEffectUI, _maximumLacerationDefinitions) == 0x000348, "Member 'UUMGLacerationStatusEffectUI::_maximumLacerationDefinitions' has a wrong offset!");
static_assert(offsetof(UUMGLacerationStatusEffectUI, _lacerationDecorationImages) == 0x000358, "Member 'UUMGLacerationStatusEffectUI::_lacerationDecorationImages' has a wrong offset!");
static_assert(offsetof(UUMGLacerationStatusEffectUI, _lacerationFillImages) == 0x000368, "Member 'UUMGLacerationStatusEffectUI::_lacerationFillImages' has a wrong offset!");
static_assert(offsetof(UUMGLacerationStatusEffectUI, _lacerationDefaultColor) == 0x000378, "Member 'UUMGLacerationStatusEffectUI::_lacerationDefaultColor' has a wrong offset!");
static_assert(offsetof(UUMGLacerationStatusEffectUI, _lacerationFillFullColor) == 0x000388, "Member 'UUMGLacerationStatusEffectUI::_lacerationFillFullColor' has a wrong offset!");
static_assert(offsetof(UUMGLacerationStatusEffectUI, _glassShatterDisintigrateAnimationName) == 0x000398, "Member 'UUMGLacerationStatusEffectUI::_glassShatterDisintigrateAnimationName' has a wrong offset!");
static_assert(offsetof(UUMGLacerationStatusEffectUI, _lacerationFillFullMI) == 0x0003A8, "Member 'UUMGLacerationStatusEffectUI::_lacerationFillFullMI' has a wrong offset!");

// Class DeadByDaylight.UMGLevelBannerWidget
// 0x0060 (0x0398 - 0x0338)
class UUMGLevelBannerWidget final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UButton*                                TooltipButton;                                     // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             PlayerLevelText;                                   // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerDevotionText;                                // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerCurrentExperienceText;                       // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PlayerNextLevelExperienceText;                     // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           XPProgressBar;                                     // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         XPTextContainer;                                   // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          OnLongPressSound;                                  // 0x0378(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TooltipHighlightPicture;                           // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTooltipButtonLongPressEvent();
	void SetExperienceVisibilityBP(const bool isExperienceVisible, const bool isBig);
	void SetInfo(const int32 playerLevel, const int32 playerPrestige, const int32 currentExperience, const int32 nextLevelExperience);
	void SetInfoBP(const int32 playerLevel, const int32 playerPrestige, const int32 currentExperience, const int32 nextLevelExperience);
	void SetProgressBarValue(const float progress);
	void StartHighlight();
	void StopHighlight();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLevelBannerWidget">();
	}
	static class UUMGLevelBannerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLevelBannerWidget>();
	}
};
static_assert(alignof(UUMGLevelBannerWidget) == 0x000008, "Wrong alignment on UUMGLevelBannerWidget");
static_assert(sizeof(UUMGLevelBannerWidget) == 0x000398, "Wrong size on UUMGLevelBannerWidget");
static_assert(offsetof(UUMGLevelBannerWidget, TooltipButton) == 0x000340, "Member 'UUMGLevelBannerWidget::TooltipButton' has a wrong offset!");
static_assert(offsetof(UUMGLevelBannerWidget, PlayerLevelText) == 0x000348, "Member 'UUMGLevelBannerWidget::PlayerLevelText' has a wrong offset!");
static_assert(offsetof(UUMGLevelBannerWidget, PlayerDevotionText) == 0x000350, "Member 'UUMGLevelBannerWidget::PlayerDevotionText' has a wrong offset!");
static_assert(offsetof(UUMGLevelBannerWidget, PlayerCurrentExperienceText) == 0x000358, "Member 'UUMGLevelBannerWidget::PlayerCurrentExperienceText' has a wrong offset!");
static_assert(offsetof(UUMGLevelBannerWidget, PlayerNextLevelExperienceText) == 0x000360, "Member 'UUMGLevelBannerWidget::PlayerNextLevelExperienceText' has a wrong offset!");
static_assert(offsetof(UUMGLevelBannerWidget, XPProgressBar) == 0x000368, "Member 'UUMGLevelBannerWidget::XPProgressBar' has a wrong offset!");
static_assert(offsetof(UUMGLevelBannerWidget, XPTextContainer) == 0x000370, "Member 'UUMGLevelBannerWidget::XPTextContainer' has a wrong offset!");
static_assert(offsetof(UUMGLevelBannerWidget, OnLongPressSound) == 0x000378, "Member 'UUMGLevelBannerWidget::OnLongPressSound' has a wrong offset!");
static_assert(offsetof(UUMGLevelBannerWidget, TooltipHighlightPicture) == 0x000380, "Member 'UUMGLevelBannerWidget::TooltipHighlightPicture' has a wrong offset!");

// Class DeadByDaylight.UMGLoadingScreenWidget
// 0x0030 (0x0368 - 0x0338)
class UUMGLoadingScreenWidget final : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             Description;                                       // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HintIcon;                                          // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           LoadingBar;                                        // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           KillerPanel;                                       // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           SurvivorPanel;                                     // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Title;                                             // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLoadingScreenWidget">();
	}
	static class UUMGLoadingScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLoadingScreenWidget>();
	}
};
static_assert(alignof(UUMGLoadingScreenWidget) == 0x000008, "Wrong alignment on UUMGLoadingScreenWidget");
static_assert(sizeof(UUMGLoadingScreenWidget) == 0x000368, "Wrong size on UUMGLoadingScreenWidget");
static_assert(offsetof(UUMGLoadingScreenWidget, Description) == 0x000338, "Member 'UUMGLoadingScreenWidget::Description' has a wrong offset!");
static_assert(offsetof(UUMGLoadingScreenWidget, HintIcon) == 0x000340, "Member 'UUMGLoadingScreenWidget::HintIcon' has a wrong offset!");
static_assert(offsetof(UUMGLoadingScreenWidget, LoadingBar) == 0x000348, "Member 'UUMGLoadingScreenWidget::LoadingBar' has a wrong offset!");
static_assert(offsetof(UUMGLoadingScreenWidget, KillerPanel) == 0x000350, "Member 'UUMGLoadingScreenWidget::KillerPanel' has a wrong offset!");
static_assert(offsetof(UUMGLoadingScreenWidget, SurvivorPanel) == 0x000358, "Member 'UUMGLoadingScreenWidget::SurvivorPanel' has a wrong offset!");
static_assert(offsetof(UUMGLoadingScreenWidget, Title) == 0x000360, "Member 'UUMGLoadingScreenWidget::Title' has a wrong offset!");

// Class DeadByDaylight.UMGLoadoutPageScrollWidget
// 0x0110 (0x0578 - 0x0468)
class UUMGLoadoutPageScrollWidget final : public UUMGPageScrollWidget
{
public:
	bool                                          ShouldResizeWidget;                                // 0x0468(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_469[0x7];                                      // 0x0469(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   _itemWidgetClass;                                  // 0x0470(0x0030)(Edit, BlueprintVisible, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInventoryGridFormat                          _gridFormat;                                       // 0x04A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A1[0x7];                                      // 0x04A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FInventorySlotData>             _inventoryData;                                    // 0x04A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 _inventorySelectedItemIndexes;                     // 0x04B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class FString                                 _subtitle;                                         // 0x04C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0xA0];                                     // 0x04D8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleItemClicked(class FName itemID);
	void SetInventoryData(EInventoryGridFormat gridFormat, const TArray<struct FInventorySlotData>& inventoryData, const TArray<int32>& selectedItemsIndexes, const class FString& trackingItemName, const class FString& subtitle);
	void SetItemIsSelected(int32 index, bool isSelected);
	void SetItemWidgetClass();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLoadoutPageScrollWidget">();
	}
	static class UUMGLoadoutPageScrollWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLoadoutPageScrollWidget>();
	}
};
static_assert(alignof(UUMGLoadoutPageScrollWidget) == 0x000008, "Wrong alignment on UUMGLoadoutPageScrollWidget");
static_assert(sizeof(UUMGLoadoutPageScrollWidget) == 0x000578, "Wrong size on UUMGLoadoutPageScrollWidget");
static_assert(offsetof(UUMGLoadoutPageScrollWidget, ShouldResizeWidget) == 0x000468, "Member 'UUMGLoadoutPageScrollWidget::ShouldResizeWidget' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutPageScrollWidget, _itemWidgetClass) == 0x000470, "Member 'UUMGLoadoutPageScrollWidget::_itemWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutPageScrollWidget, _gridFormat) == 0x0004A0, "Member 'UUMGLoadoutPageScrollWidget::_gridFormat' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutPageScrollWidget, _inventoryData) == 0x0004A8, "Member 'UUMGLoadoutPageScrollWidget::_inventoryData' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutPageScrollWidget, _inventorySelectedItemIndexes) == 0x0004B8, "Member 'UUMGLoadoutPageScrollWidget::_inventorySelectedItemIndexes' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutPageScrollWidget, _subtitle) == 0x0004C8, "Member 'UUMGLoadoutPageScrollWidget::_subtitle' has a wrong offset!");

// Class DeadByDaylight.UMGLoadoutWidget
// 0x0068 (0x03F8 - 0x0390)
class UUMGLoadoutWidget final : public UUMGLoadoutBaseWidget
{
public:
	class FText                                   InventoryItemTypeText;                             // 0x0390(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	class FText                                   InventoryFilterText;                               // 0x03A8(0x0018)(BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	class UUMGLoadoutPageScrollWidget*            PageScrollWidget;                                  // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   LoadoutTitleText;                                  // 0x03C8(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   InventoryPanelTitleText;                           // 0x03E0(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void SetInventoryData(EInventoryGridFormat gridFormat, const TArray<struct FInventorySlotData>& inventoryData, const TArray<int32>& selectedItemsIndexes, const class FString& trackingItemName, const class FString& subtitle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLoadoutWidget">();
	}
	static class UUMGLoadoutWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLoadoutWidget>();
	}
};
static_assert(alignof(UUMGLoadoutWidget) == 0x000008, "Wrong alignment on UUMGLoadoutWidget");
static_assert(sizeof(UUMGLoadoutWidget) == 0x0003F8, "Wrong size on UUMGLoadoutWidget");
static_assert(offsetof(UUMGLoadoutWidget, InventoryItemTypeText) == 0x000390, "Member 'UUMGLoadoutWidget::InventoryItemTypeText' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutWidget, InventoryFilterText) == 0x0003A8, "Member 'UUMGLoadoutWidget::InventoryFilterText' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutWidget, PageScrollWidget) == 0x0003C0, "Member 'UUMGLoadoutWidget::PageScrollWidget' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutWidget, LoadoutTitleText) == 0x0003C8, "Member 'UUMGLoadoutWidget::LoadoutTitleText' has a wrong offset!");
static_assert(offsetof(UUMGLoadoutWidget, InventoryPanelTitleText) == 0x0003E0, "Member 'UUMGLoadoutWidget::InventoryPanelTitleText' has a wrong offset!");

// Class DeadByDaylight.UMGLobbyOfferingItemWidget
// 0x0000 (0x0338 - 0x0338)
class UUMGLobbyOfferingItemWidget final : public UMobileBaseUserWidget
{
public:
	TMap<class FName, TSoftObjectPtr<class UTexture2D>> GetOfferingIcons();
	void HideOfferingItem();
	void SetOfferingData(const struct FInventorySlotData& data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGLobbyOfferingItemWidget">();
	}
	static class UUMGLobbyOfferingItemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGLobbyOfferingItemWidget>();
	}
};
static_assert(alignof(UUMGLobbyOfferingItemWidget) == 0x000008, "Wrong alignment on UUMGLobbyOfferingItemWidget");
static_assert(sizeof(UUMGLobbyOfferingItemWidget) == 0x000338, "Wrong size on UUMGLobbyOfferingItemWidget");

// Class DeadByDaylight.UMGMainMenuMonthlyPassButton
// 0x0050 (0x0388 - 0x0338)
class UUMGMainMenuMonthlyPassButton final : public UMobileBaseUserWidget
{
public:
	class UWidgetSwitcher*                        ButtonSwitcher;                                    // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ActiveButton;                                      // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                NonActiveButton;                                   // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   PlayerName;                                        // 0x0350(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          OnClickSound;                                      // 0x0368(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x18];                                     // 0x0370(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonClick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGMainMenuMonthlyPassButton">();
	}
	static class UUMGMainMenuMonthlyPassButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGMainMenuMonthlyPassButton>();
	}
};
static_assert(alignof(UUMGMainMenuMonthlyPassButton) == 0x000008, "Wrong alignment on UUMGMainMenuMonthlyPassButton");
static_assert(sizeof(UUMGMainMenuMonthlyPassButton) == 0x000388, "Wrong size on UUMGMainMenuMonthlyPassButton");
static_assert(offsetof(UUMGMainMenuMonthlyPassButton, ButtonSwitcher) == 0x000338, "Member 'UUMGMainMenuMonthlyPassButton::ButtonSwitcher' has a wrong offset!");
static_assert(offsetof(UUMGMainMenuMonthlyPassButton, ActiveButton) == 0x000340, "Member 'UUMGMainMenuMonthlyPassButton::ActiveButton' has a wrong offset!");
static_assert(offsetof(UUMGMainMenuMonthlyPassButton, NonActiveButton) == 0x000348, "Member 'UUMGMainMenuMonthlyPassButton::NonActiveButton' has a wrong offset!");
static_assert(offsetof(UUMGMainMenuMonthlyPassButton, PlayerName) == 0x000350, "Member 'UUMGMainMenuMonthlyPassButton::PlayerName' has a wrong offset!");
static_assert(offsetof(UUMGMainMenuMonthlyPassButton, OnClickSound) == 0x000368, "Member 'UUMGMainMenuMonthlyPassButton::OnClickSound' has a wrong offset!");

// Class DeadByDaylight.UMGMapThemeWidget
// 0x0000 (0x0338 - 0x0338)
class UUMGMapThemeWidget final : public UMobileBaseUserWidget
{
public:
	void SetMapName(const class FString& mapName);
	void SetThemeName(const class FString& themeName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGMapThemeWidget">();
	}
	static class UUMGMapThemeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGMapThemeWidget>();
	}
};
static_assert(alignof(UUMGMapThemeWidget) == 0x000008, "Wrong alignment on UUMGMapThemeWidget");
static_assert(sizeof(UUMGMapThemeWidget) == 0x000338, "Wrong size on UUMGMapThemeWidget");

// Class DeadByDaylight.UMGMenuEventsBanner
// 0x0018 (0x04C0 - 0x04A8)
class UUMGMenuEventsBanner final : public UUMGMenuBaseBanner
{
public:
	class UImage*                                 EventsIcon;                                        // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             FallbackTitle;                                     // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCustomWidgetLayout();
	void SetDefaultWidgetLayout();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGMenuEventsBanner">();
	}
	static class UUMGMenuEventsBanner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGMenuEventsBanner>();
	}
};
static_assert(alignof(UUMGMenuEventsBanner) == 0x000008, "Wrong alignment on UUMGMenuEventsBanner");
static_assert(sizeof(UUMGMenuEventsBanner) == 0x0004C0, "Wrong size on UUMGMenuEventsBanner");
static_assert(offsetof(UUMGMenuEventsBanner, EventsIcon) == 0x0004A8, "Member 'UUMGMenuEventsBanner::EventsIcon' has a wrong offset!");
static_assert(offsetof(UUMGMenuEventsBanner, FallbackTitle) == 0x0004B0, "Member 'UUMGMenuEventsBanner::FallbackTitle' has a wrong offset!");

// Class DeadByDaylight.UMGNavigationButtonWidget
// 0x0010 (0x0478 - 0x0468)
class UUMGNavigationButtonWidget final : public UUMGBaseButtonWidget
{
public:
	class UWidget*                                NotificationPanel;                                 // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIcon(class UTexture2D* Icon);
	void SetIsSelected(bool isSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGNavigationButtonWidget">();
	}
	static class UUMGNavigationButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGNavigationButtonWidget>();
	}
};
static_assert(alignof(UUMGNavigationButtonWidget) == 0x000008, "Wrong alignment on UUMGNavigationButtonWidget");
static_assert(sizeof(UUMGNavigationButtonWidget) == 0x000478, "Wrong size on UUMGNavigationButtonWidget");
static_assert(offsetof(UUMGNavigationButtonWidget, NotificationPanel) == 0x000468, "Member 'UUMGNavigationButtonWidget::NotificationPanel' has a wrong offset!");

// Class DeadByDaylight.UMGPartyCountdownWidget
// 0x0020 (0x03C0 - 0x03A0)
class UUMGPartyCountdownWidget final : public UUMGBaseCountdownWidget
{
public:
	class UButton*                                UnreadyButton;                                     // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           UnreadyButtonContainer;                            // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x10];                                     // 0x03B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUnreadyButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPartyCountdownWidget">();
	}
	static class UUMGPartyCountdownWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPartyCountdownWidget>();
	}
};
static_assert(alignof(UUMGPartyCountdownWidget) == 0x000008, "Wrong alignment on UUMGPartyCountdownWidget");
static_assert(sizeof(UUMGPartyCountdownWidget) == 0x0003C0, "Wrong size on UUMGPartyCountdownWidget");
static_assert(offsetof(UUMGPartyCountdownWidget, UnreadyButton) == 0x0003A0, "Member 'UUMGPartyCountdownWidget::UnreadyButton' has a wrong offset!");
static_assert(offsetof(UUMGPartyCountdownWidget, UnreadyButtonContainer) == 0x0003A8, "Member 'UUMGPartyCountdownWidget::UnreadyButtonContainer' has a wrong offset!");

// Class DeadByDaylight.UMGPartyPlayerSlotWidget
// 0x0288 (0x05C0 - 0x0338)
class UUMGPartyPlayerSlotWidget final : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             PlayerName;                                        // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             AdditionalInformationText;                         // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 FriendIcon;                                        // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBaseButtonWidget*                   KickPlayerButton;                                  // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         CharacterNameStyle;                                // 0x0358(0x0058)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         PlayerInMatchStyle;                                // 0x03B0(0x0058)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerInMatchOpacity;                              // 0x0408(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerInLobbyOpacity;                              // 0x040C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                PlayerInformationContainer;                        // 0x0410(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ReadyIconsCanvas;                                  // 0x0418(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           RequestRoleIconsCanvas;                            // 0x0420(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        RoleSwitcher;                                      // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LeaderIcon;                                        // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x188];                                    // 0x0438(0x0188)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleKickPlayerButtonEvent();
	void SetVisualsFromState(EPartyPlayerSlotWidgetState widgetState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPartyPlayerSlotWidget">();
	}
	static class UUMGPartyPlayerSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPartyPlayerSlotWidget>();
	}
};
static_assert(alignof(UUMGPartyPlayerSlotWidget) == 0x000008, "Wrong alignment on UUMGPartyPlayerSlotWidget");
static_assert(sizeof(UUMGPartyPlayerSlotWidget) == 0x0005C0, "Wrong size on UUMGPartyPlayerSlotWidget");
static_assert(offsetof(UUMGPartyPlayerSlotWidget, PlayerName) == 0x000338, "Member 'UUMGPartyPlayerSlotWidget::PlayerName' has a wrong offset!");
static_assert(offsetof(UUMGPartyPlayerSlotWidget, AdditionalInformationText) == 0x000340, "Member 'UUMGPartyPlayerSlotWidget::AdditionalInformationText' has a wrong offset!");
static_assert(offsetof(UUMGPartyPlayerSlotWidget, FriendIcon) == 0x000348, "Member 'UUMGPartyPlayerSlotWidget::FriendIcon' has a wrong offset!");
static_assert(offsetof(UUMGPartyPlayerSlotWidget, KickPlayerButton) == 0x000350, "Member 'UUMGPartyPlayerSlotWidget::KickPlayerButton' has a wrong offset!");
static_assert(offsetof(UUMGPartyPlayerSlotWidget, CharacterNameStyle) == 0x000358, "Member 'UUMGPartyPlayerSlotWidget::CharacterNameStyle' has a wrong offset!");
static_assert(offsetof(UUMGPartyPlayerSlotWidget, PlayerInMatchStyle) == 0x0003B0, "Member 'UUMGPartyPlayerSlotWidget::PlayerInMatchStyle' has a wrong offset!");
static_assert(offsetof(UUMGPartyPlayerSlotWidget, PlayerInMatchOpacity) == 0x000408, "Member 'UUMGPartyPlayerSlotWidget::PlayerInMatchOpacity' has a wrong offset!");
static_assert(offsetof(UUMGPartyPlayerSlotWidget, PlayerInLobbyOpacity) == 0x00040C, "Member 'UUMGPartyPlayerSlotWidget::PlayerInLobbyOpacity' has a wrong offset!");
static_assert(offsetof(UUMGPartyPlayerSlotWidget, PlayerInformationContainer) == 0x000410, "Member 'UUMGPartyPlayerSlotWidget::PlayerInformationContainer' has a wrong offset!");
static_assert(offsetof(UUMGPartyPlayerSlotWidget, ReadyIconsCanvas) == 0x000418, "Member 'UUMGPartyPlayerSlotWidget::ReadyIconsCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPartyPlayerSlotWidget, RequestRoleIconsCanvas) == 0x000420, "Member 'UUMGPartyPlayerSlotWidget::RequestRoleIconsCanvas' has a wrong offset!");
static_assert(offsetof(UUMGPartyPlayerSlotWidget, RoleSwitcher) == 0x000428, "Member 'UUMGPartyPlayerSlotWidget::RoleSwitcher' has a wrong offset!");
static_assert(offsetof(UUMGPartyPlayerSlotWidget, LeaderIcon) == 0x000430, "Member 'UUMGPartyPlayerSlotWidget::LeaderIcon' has a wrong offset!");

// Class DeadByDaylight.UMGPromoPackCharacterWidget
// 0x0008 (0x04A8 - 0x04A0)
class UUMGPromoPackCharacterWidget final : public UUMGPromoPackItemWidget
{
public:
	class UCanvasPanel*                           OwnedPanel;                                        // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPromoPackCharacterWidget">();
	}
	static class UUMGPromoPackCharacterWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPromoPackCharacterWidget>();
	}
};
static_assert(alignof(UUMGPromoPackCharacterWidget) == 0x000008, "Wrong alignment on UUMGPromoPackCharacterWidget");
static_assert(sizeof(UUMGPromoPackCharacterWidget) == 0x0004A8, "Wrong size on UUMGPromoPackCharacterWidget");
static_assert(offsetof(UUMGPromoPackCharacterWidget, OwnedPanel) == 0x0004A0, "Member 'UUMGPromoPackCharacterWidget::OwnedPanel' has a wrong offset!");

// Class DeadByDaylight.UMGPromoPackContentWidget
// 0x0028 (0x0360 - 0x0338)
class UUMGPromoPackContentWidget final : public UMobileBaseUserWidget
{
public:
	class UHorizontalBox*                         Content;                                           // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPromoPackContentDataAsset*             WidgetPerContentType;                              // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBox;                                         // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UVerticalBox>>    _itemsContainer;                                   // 0x0350(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPromoPackContentWidget">();
	}
	static class UUMGPromoPackContentWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPromoPackContentWidget>();
	}
};
static_assert(alignof(UUMGPromoPackContentWidget) == 0x000008, "Wrong alignment on UUMGPromoPackContentWidget");
static_assert(sizeof(UUMGPromoPackContentWidget) == 0x000360, "Wrong size on UUMGPromoPackContentWidget");
static_assert(offsetof(UUMGPromoPackContentWidget, Content) == 0x000338, "Member 'UUMGPromoPackContentWidget::Content' has a wrong offset!");
static_assert(offsetof(UUMGPromoPackContentWidget, WidgetPerContentType) == 0x000340, "Member 'UUMGPromoPackContentWidget::WidgetPerContentType' has a wrong offset!");
static_assert(offsetof(UUMGPromoPackContentWidget, ScrollBox) == 0x000348, "Member 'UUMGPromoPackContentWidget::ScrollBox' has a wrong offset!");
static_assert(offsetof(UUMGPromoPackContentWidget, _itemsContainer) == 0x000350, "Member 'UUMGPromoPackContentWidget::_itemsContainer' has a wrong offset!");

// Class DeadByDaylight.UMGPurchaseBuyButton
// 0x0008 (0x0470 - 0x0468)
class UUMGPurchaseBuyButton final : public UUMGBaseButtonWidget
{
public:
	class UTextBlock*                             PriceText;                                         // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPurchaseBuyButton">();
	}
	static class UUMGPurchaseBuyButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPurchaseBuyButton>();
	}
};
static_assert(alignof(UUMGPurchaseBuyButton) == 0x000008, "Wrong alignment on UUMGPurchaseBuyButton");
static_assert(sizeof(UUMGPurchaseBuyButton) == 0x000470, "Wrong size on UUMGPurchaseBuyButton");
static_assert(offsetof(UUMGPurchaseBuyButton, PriceText) == 0x000468, "Member 'UUMGPurchaseBuyButton::PriceText' has a wrong offset!");

// Class DeadByDaylight.UMGPurchaseItemsInfo
// 0x0018 (0x0350 - 0x0338)
class UUMGPurchaseItemsInfo final : public UMobileBaseUserWidget
{
public:
	class UImage*                                 Icon;                                              // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Quantity;                                          // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemName;                                          // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPurchaseItemsInfo">();
	}
	static class UUMGPurchaseItemsInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPurchaseItemsInfo>();
	}
};
static_assert(alignof(UUMGPurchaseItemsInfo) == 0x000008, "Wrong alignment on UUMGPurchaseItemsInfo");
static_assert(sizeof(UUMGPurchaseItemsInfo) == 0x000350, "Wrong size on UUMGPurchaseItemsInfo");
static_assert(offsetof(UUMGPurchaseItemsInfo, Icon) == 0x000338, "Member 'UUMGPurchaseItemsInfo::Icon' has a wrong offset!");
static_assert(offsetof(UUMGPurchaseItemsInfo, Quantity) == 0x000340, "Member 'UUMGPurchaseItemsInfo::Quantity' has a wrong offset!");
static_assert(offsetof(UUMGPurchaseItemsInfo, ItemName) == 0x000348, "Member 'UUMGPurchaseItemsInfo::ItemName' has a wrong offset!");

// Class DeadByDaylight.UMGPurchaseSticker
// 0x0008 (0x0340 - 0x0338)
class UUMGPurchaseSticker final : public UMobileBaseUserWidget
{
public:
	class UTextBlock*                             TextDiscount;                                      // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGPurchaseSticker">();
	}
	static class UUMGPurchaseSticker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGPurchaseSticker>();
	}
};
static_assert(alignof(UUMGPurchaseSticker) == 0x000008, "Wrong alignment on UUMGPurchaseSticker");
static_assert(sizeof(UUMGPurchaseSticker) == 0x000340, "Wrong size on UUMGPurchaseSticker");
static_assert(offsetof(UUMGPurchaseSticker, TextDiscount) == 0x000338, "Member 'UUMGPurchaseSticker::TextDiscount' has a wrong offset!");

// Class DeadByDaylight.UMGQueueStatusIconWidget
// 0x0038 (0x0370 - 0x0338)
class UUMGQueueStatusIconWidget final : public UMobileBaseUserWidget
{
public:
	class UImage*                                 StatusIndicator;                                   // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           AcceptableColor;                                   // 0x0340(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           ModerateColor;                                     // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           LongColor;                                         // 0x0360(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGQueueStatusIconWidget">();
	}
	static class UUMGQueueStatusIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGQueueStatusIconWidget>();
	}
};
static_assert(alignof(UUMGQueueStatusIconWidget) == 0x000008, "Wrong alignment on UUMGQueueStatusIconWidget");
static_assert(sizeof(UUMGQueueStatusIconWidget) == 0x000370, "Wrong size on UUMGQueueStatusIconWidget");
static_assert(offsetof(UUMGQueueStatusIconWidget, StatusIndicator) == 0x000338, "Member 'UUMGQueueStatusIconWidget::StatusIndicator' has a wrong offset!");
static_assert(offsetof(UUMGQueueStatusIconWidget, AcceptableColor) == 0x000340, "Member 'UUMGQueueStatusIconWidget::AcceptableColor' has a wrong offset!");
static_assert(offsetof(UUMGQueueStatusIconWidget, ModerateColor) == 0x000350, "Member 'UUMGQueueStatusIconWidget::ModerateColor' has a wrong offset!");
static_assert(offsetof(UUMGQueueStatusIconWidget, LongColor) == 0x000360, "Member 'UUMGQueueStatusIconWidget::LongColor' has a wrong offset!");

// Class DeadByDaylight.UMGRefundDataWidget
// 0x0000 (0x0338 - 0x0338)
class UUMGRefundDataWidget final : public UMobileBaseUserWidget
{
public:
	void SetDataAndUpdateWidget(const struct FRefundUIData& RefundUIData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGRefundDataWidget">();
	}
	static class UUMGRefundDataWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGRefundDataWidget>();
	}
};
static_assert(alignof(UUMGRefundDataWidget) == 0x000008, "Wrong alignment on UUMGRefundDataWidget");
static_assert(sizeof(UUMGRefundDataWidget) == 0x000338, "Wrong size on UUMGRefundDataWidget");

// Class DeadByDaylight.UMGRewardPopupLayout
// 0x0180 (0x04B8 - 0x0338)
class UUMGRewardPopupLayout final : public UMobileBaseUserWidget
{
public:
	class UHorizontalBox*                         TopHorizontalBox;                                  // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         BottomHorizontalBox;                               // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGRewardSlotTutorialPopupRewardWidget* FirstCharacter;                                   // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGRewardSlotTutorialPopupRewardWidget* SecondCharacter;                                  // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGRewardSlotTutorialPopupRewardWidget* ThirdCharacter;                                   // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGRewardSlotTutorialPopupRewardWidget* FourthCharacter;                                  // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGRewardSlotTutorialPopupRewardWidget* FifthCharacter;                                   // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGRewardSlotTutorialPopupRewardWidget* AuricCells;                                       // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGRewardSlotTutorialPopupRewardWidget* IridescentShards;                                 // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGRewardSlotTutorialPopupRewardWidget* Bloodpoints;                                      // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRewardLayoutWidgetToGenerate          TopWidgetToGenerate;                               // 0x0388(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRewardLayoutWidgetToGenerate          BottomWidgetToGenerate;                            // 0x0418(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x10];                                     // 0x04A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGRewardPopupLayout">();
	}
	static class UUMGRewardPopupLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGRewardPopupLayout>();
	}
};
static_assert(alignof(UUMGRewardPopupLayout) == 0x000008, "Wrong alignment on UUMGRewardPopupLayout");
static_assert(sizeof(UUMGRewardPopupLayout) == 0x0004B8, "Wrong size on UUMGRewardPopupLayout");
static_assert(offsetof(UUMGRewardPopupLayout, TopHorizontalBox) == 0x000338, "Member 'UUMGRewardPopupLayout::TopHorizontalBox' has a wrong offset!");
static_assert(offsetof(UUMGRewardPopupLayout, BottomHorizontalBox) == 0x000340, "Member 'UUMGRewardPopupLayout::BottomHorizontalBox' has a wrong offset!");
static_assert(offsetof(UUMGRewardPopupLayout, FirstCharacter) == 0x000348, "Member 'UUMGRewardPopupLayout::FirstCharacter' has a wrong offset!");
static_assert(offsetof(UUMGRewardPopupLayout, SecondCharacter) == 0x000350, "Member 'UUMGRewardPopupLayout::SecondCharacter' has a wrong offset!");
static_assert(offsetof(UUMGRewardPopupLayout, ThirdCharacter) == 0x000358, "Member 'UUMGRewardPopupLayout::ThirdCharacter' has a wrong offset!");
static_assert(offsetof(UUMGRewardPopupLayout, FourthCharacter) == 0x000360, "Member 'UUMGRewardPopupLayout::FourthCharacter' has a wrong offset!");
static_assert(offsetof(UUMGRewardPopupLayout, FifthCharacter) == 0x000368, "Member 'UUMGRewardPopupLayout::FifthCharacter' has a wrong offset!");
static_assert(offsetof(UUMGRewardPopupLayout, AuricCells) == 0x000370, "Member 'UUMGRewardPopupLayout::AuricCells' has a wrong offset!");
static_assert(offsetof(UUMGRewardPopupLayout, IridescentShards) == 0x000378, "Member 'UUMGRewardPopupLayout::IridescentShards' has a wrong offset!");
static_assert(offsetof(UUMGRewardPopupLayout, Bloodpoints) == 0x000380, "Member 'UUMGRewardPopupLayout::Bloodpoints' has a wrong offset!");
static_assert(offsetof(UUMGRewardPopupLayout, TopWidgetToGenerate) == 0x000388, "Member 'UUMGRewardPopupLayout::TopWidgetToGenerate' has a wrong offset!");
static_assert(offsetof(UUMGRewardPopupLayout, BottomWidgetToGenerate) == 0x000418, "Member 'UUMGRewardPopupLayout::BottomWidgetToGenerate' has a wrong offset!");

// Class DeadByDaylight.UMGRewardWidget
// 0x0008 (0x0340 - 0x0338)
class UUMGRewardWidget final : public UMobileBaseUserWidget
{
public:
	class UImage*                                 CheckIcon;                                         // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetData(const struct FRewardItemData& RewardData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGRewardWidget">();
	}
	static class UUMGRewardWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGRewardWidget>();
	}
};
static_assert(alignof(UUMGRewardWidget) == 0x000008, "Wrong alignment on UUMGRewardWidget");
static_assert(sizeof(UUMGRewardWidget) == 0x000340, "Wrong size on UUMGRewardWidget");
static_assert(offsetof(UUMGRewardWidget, CheckIcon) == 0x000338, "Member 'UUMGRewardWidget::CheckIcon' has a wrong offset!");

// Class DeadByDaylight.UMGRichTextRewardItemDecorator
// 0x0008 (0x0038 - 0x0030)
class UUMGRichTextRewardItemDecorator final : public URichTextBlockDecorator
{
public:
	class UDataTable*                             RewardSet;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGRichTextRewardItemDecorator">();
	}
	static class UUMGRichTextRewardItemDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGRichTextRewardItemDecorator>();
	}
};
static_assert(alignof(UUMGRichTextRewardItemDecorator) == 0x000008, "Wrong alignment on UUMGRichTextRewardItemDecorator");
static_assert(sizeof(UUMGRichTextRewardItemDecorator) == 0x000038, "Wrong size on UUMGRichTextRewardItemDecorator");
static_assert(offsetof(UUMGRichTextRewardItemDecorator, RewardSet) == 0x000030, "Member 'UUMGRichTextRewardItemDecorator::RewardSet' has a wrong offset!");

// Class DeadByDaylight.UMGRoleSwitcherWidget
// 0x0060 (0x02F8 - 0x0298)
class UUMGRoleSwitcherWidget final : public UUserWidget
{
public:
	bool                                          _isCurrentRoleRoleSwitcher;                        // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _touchDeltaTolerance;                              // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x58];                                     // 0x02A0(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGRoleSwitcherWidget">();
	}
	static class UUMGRoleSwitcherWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGRoleSwitcherWidget>();
	}
};
static_assert(alignof(UUMGRoleSwitcherWidget) == 0x000008, "Wrong alignment on UUMGRoleSwitcherWidget");
static_assert(sizeof(UUMGRoleSwitcherWidget) == 0x0002F8, "Wrong size on UUMGRoleSwitcherWidget");
static_assert(offsetof(UUMGRoleSwitcherWidget, _isCurrentRoleRoleSwitcher) == 0x000298, "Member 'UUMGRoleSwitcherWidget::_isCurrentRoleRoleSwitcher' has a wrong offset!");
static_assert(offsetof(UUMGRoleSwitcherWidget, _touchDeltaTolerance) == 0x00029C, "Member 'UUMGRoleSwitcherWidget::_touchDeltaTolerance' has a wrong offset!");

// Class DeadByDaylight.UMGScoreAlertWidget
// 0x0000 (0x02C8 - 0x02C8)
class UUMGScoreAlertWidget final : public UUMGBaseAlertWidget
{
public:
	void UpdateWidget(EDBDScoreCategory scoreType, const class FString& title, int32 scoreValue, float progress, const class FText& defaultScoreText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGScoreAlertWidget">();
	}
	static class UUMGScoreAlertWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGScoreAlertWidget>();
	}
};
static_assert(alignof(UUMGScoreAlertWidget) == 0x000008, "Wrong alignment on UUMGScoreAlertWidget");
static_assert(sizeof(UUMGScoreAlertWidget) == 0x0002C8, "Wrong size on UUMGScoreAlertWidget");

// Class DeadByDaylight.UMGSettingAboutContextWidget
// 0x0010 (0x0360 - 0x0350)
class UUMGSettingAboutContextWidget final : public UUMGSettingContextWidget
{
public:
	class UUMGSettingContextButton*               EULAButton;                                        // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGSettingContextButton*               CreditsButton;                                     // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetVersionNumber(const class FString& versionNumber);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSettingAboutContextWidget">();
	}
	static class UUMGSettingAboutContextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSettingAboutContextWidget>();
	}
};
static_assert(alignof(UUMGSettingAboutContextWidget) == 0x000008, "Wrong alignment on UUMGSettingAboutContextWidget");
static_assert(sizeof(UUMGSettingAboutContextWidget) == 0x000360, "Wrong size on UUMGSettingAboutContextWidget");
static_assert(offsetof(UUMGSettingAboutContextWidget, EULAButton) == 0x000350, "Member 'UUMGSettingAboutContextWidget::EULAButton' has a wrong offset!");
static_assert(offsetof(UUMGSettingAboutContextWidget, CreditsButton) == 0x000358, "Member 'UUMGSettingAboutContextWidget::CreditsButton' has a wrong offset!");

// Class DeadByDaylight.UMGSettingMenuButton
// 0x0018 (0x0350 - 0x0338)
class UUMGSettingMenuButton final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x18];                                     // 0x0338(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleSettingTabButtonClick();
	void SetIsSelected(bool isSelected);
	void SetTabButtonText(const class FText& buttonText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSettingMenuButton">();
	}
	static class UUMGSettingMenuButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSettingMenuButton>();
	}
};
static_assert(alignof(UUMGSettingMenuButton) == 0x000008, "Wrong alignment on UUMGSettingMenuButton");
static_assert(sizeof(UUMGSettingMenuButton) == 0x000350, "Wrong size on UUMGSettingMenuButton");

// Class DeadByDaylight.UMGSettingSettingsContextWidget
// 0x00C8 (0x0418 - 0x0350)
class UUMGSettingSettingsContextWidget final : public UUMGSettingContextWidget
{
public:
	uint8                                         Pad_350[0x90];                                     // 0x0350(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          MainVolumeOn;                                      // 0x03E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MainVolume;                                        // 0x03E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MenuVolumeOn;                                      // 0x03E8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x3];                                      // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MenuVolume;                                        // 0x03EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsLoggedIn;                                        // 0x03F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsEnableUserCenterWithLoggedOut;                   // 0x03F1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsLeaveTutorialButtonVisible;                      // 0x03F2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsAutoDeclineFriendRequestOn;                      // 0x03F3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F4[0x24];                                     // 0x03F4(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAutoDeclineFriendRequestToggleClick(bool toggleValue);
	void HandleLeaveTutorialButtonClick();
	void HandleLogInButtonClick();
	void HandleLogOutButtonClick();
	void HandleMainVolumeChanged(float sliderValue);
	void HandleMainVolumeToggleClick(bool toggleValue);
	void HandleMenuVolumeChanged(float sliderValue);
	void HandleMenuVolumeToggleClick(bool toggleValue);
	void HandleUserCenterButtonClick();
	void ShowLinkAccountRow(bool isShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSettingSettingsContextWidget">();
	}
	static class UUMGSettingSettingsContextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSettingSettingsContextWidget>();
	}
};
static_assert(alignof(UUMGSettingSettingsContextWidget) == 0x000008, "Wrong alignment on UUMGSettingSettingsContextWidget");
static_assert(sizeof(UUMGSettingSettingsContextWidget) == 0x000418, "Wrong size on UUMGSettingSettingsContextWidget");
static_assert(offsetof(UUMGSettingSettingsContextWidget, MainVolumeOn) == 0x0003E0, "Member 'UUMGSettingSettingsContextWidget::MainVolumeOn' has a wrong offset!");
static_assert(offsetof(UUMGSettingSettingsContextWidget, MainVolume) == 0x0003E4, "Member 'UUMGSettingSettingsContextWidget::MainVolume' has a wrong offset!");
static_assert(offsetof(UUMGSettingSettingsContextWidget, MenuVolumeOn) == 0x0003E8, "Member 'UUMGSettingSettingsContextWidget::MenuVolumeOn' has a wrong offset!");
static_assert(offsetof(UUMGSettingSettingsContextWidget, MenuVolume) == 0x0003EC, "Member 'UUMGSettingSettingsContextWidget::MenuVolume' has a wrong offset!");
static_assert(offsetof(UUMGSettingSettingsContextWidget, IsLoggedIn) == 0x0003F0, "Member 'UUMGSettingSettingsContextWidget::IsLoggedIn' has a wrong offset!");
static_assert(offsetof(UUMGSettingSettingsContextWidget, IsEnableUserCenterWithLoggedOut) == 0x0003F1, "Member 'UUMGSettingSettingsContextWidget::IsEnableUserCenterWithLoggedOut' has a wrong offset!");
static_assert(offsetof(UUMGSettingSettingsContextWidget, IsLeaveTutorialButtonVisible) == 0x0003F2, "Member 'UUMGSettingSettingsContextWidget::IsLeaveTutorialButtonVisible' has a wrong offset!");
static_assert(offsetof(UUMGSettingSettingsContextWidget, IsAutoDeclineFriendRequestOn) == 0x0003F3, "Member 'UUMGSettingSettingsContextWidget::IsAutoDeclineFriendRequestOn' has a wrong offset!");

// Class DeadByDaylight.UMGSettingTutorialContextWidget
// 0x0028 (0x0378 - 0x0350)
class UUMGSettingTutorialContextWidget final : public UUMGSettingContextWidget
{
public:
	class UUMGSettingContextButton*               SurvivorTutorialButton;                            // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGSettingContextButton*               KillerTutorialButton;                              // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGSettingContextButton*               SurvivorCinematicButton;                           // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGSettingContextButton*               KillerCinematicButton;                             // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGSettingContextButton*               LoreCinematicButton;                               // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSettingTutorialContextWidget">();
	}
	static class UUMGSettingTutorialContextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSettingTutorialContextWidget>();
	}
};
static_assert(alignof(UUMGSettingTutorialContextWidget) == 0x000008, "Wrong alignment on UUMGSettingTutorialContextWidget");
static_assert(sizeof(UUMGSettingTutorialContextWidget) == 0x000378, "Wrong size on UUMGSettingTutorialContextWidget");
static_assert(offsetof(UUMGSettingTutorialContextWidget, SurvivorTutorialButton) == 0x000350, "Member 'UUMGSettingTutorialContextWidget::SurvivorTutorialButton' has a wrong offset!");
static_assert(offsetof(UUMGSettingTutorialContextWidget, KillerTutorialButton) == 0x000358, "Member 'UUMGSettingTutorialContextWidget::KillerTutorialButton' has a wrong offset!");
static_assert(offsetof(UUMGSettingTutorialContextWidget, SurvivorCinematicButton) == 0x000360, "Member 'UUMGSettingTutorialContextWidget::SurvivorCinematicButton' has a wrong offset!");
static_assert(offsetof(UUMGSettingTutorialContextWidget, KillerCinematicButton) == 0x000368, "Member 'UUMGSettingTutorialContextWidget::KillerCinematicButton' has a wrong offset!");
static_assert(offsetof(UUMGSettingTutorialContextWidget, LoreCinematicButton) == 0x000370, "Member 'UUMGSettingTutorialContextWidget::LoreCinematicButton' has a wrong offset!");

// Class DeadByDaylight.UMGStatusEffectIcon
// 0x0048 (0x06C0 - 0x0678)
class UUMGStatusEffectIcon final : public UUMGLoadoutItemButton
{
public:
	struct FStatusEffectSlotData                  StatusEffectData;                                  // 0x0678(0x0048)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)

public:
	void UpdatePercentageFill(float percentage);
	void UpdateWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGStatusEffectIcon">();
	}
	static class UUMGStatusEffectIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGStatusEffectIcon>();
	}
};
static_assert(alignof(UUMGStatusEffectIcon) == 0x000008, "Wrong alignment on UUMGStatusEffectIcon");
static_assert(sizeof(UUMGStatusEffectIcon) == 0x0006C0, "Wrong size on UUMGStatusEffectIcon");
static_assert(offsetof(UUMGStatusEffectIcon, StatusEffectData) == 0x000678, "Member 'UUMGStatusEffectIcon::StatusEffectData' has a wrong offset!");

// Class DeadByDaylight.UMGStoreEventItemsPackButton
// 0x00B8 (0x03F0 - 0x0338)
class UUMGStoreEventItemsPackButton final : public UMobileBaseUserWidget
{
public:
	class UImage*                                 ImageIcon;                                         // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             TitleText;                                         // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             CurrencyAmountText;                                // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             CurrencyNameText;                                  // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUniformGridPanel*                      UniformGridPanel;                                  // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGBaseButtonWidget*                   BuyButton;                                         // 0x0360(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGAtlStorePriceWidget*                StorePriceWidget;                                  // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUMGAtlEndDateTimerWidget*              EndDateTimerWidget;                                // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCanvasPanel*                           SelectedImageBox;                                  // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   EventItemWidgetClassPtr;                           // 0x0380(0x0030)(Edit, DisableEditOnInstance, NoClear, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         nbColumns;                                         // 0x03B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B4[0x3C];                                     // 0x03B4(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleButtonClicked();
	void HandleEndDateTimerReached();
	void HideSelectedCanvas();
	void ShowSelectedCanvas();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGStoreEventItemsPackButton">();
	}
	static class UUMGStoreEventItemsPackButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGStoreEventItemsPackButton>();
	}
};
static_assert(alignof(UUMGStoreEventItemsPackButton) == 0x000008, "Wrong alignment on UUMGStoreEventItemsPackButton");
static_assert(sizeof(UUMGStoreEventItemsPackButton) == 0x0003F0, "Wrong size on UUMGStoreEventItemsPackButton");
static_assert(offsetof(UUMGStoreEventItemsPackButton, ImageIcon) == 0x000338, "Member 'UUMGStoreEventItemsPackButton::ImageIcon' has a wrong offset!");
static_assert(offsetof(UUMGStoreEventItemsPackButton, TitleText) == 0x000340, "Member 'UUMGStoreEventItemsPackButton::TitleText' has a wrong offset!");
static_assert(offsetof(UUMGStoreEventItemsPackButton, CurrencyAmountText) == 0x000348, "Member 'UUMGStoreEventItemsPackButton::CurrencyAmountText' has a wrong offset!");
static_assert(offsetof(UUMGStoreEventItemsPackButton, CurrencyNameText) == 0x000350, "Member 'UUMGStoreEventItemsPackButton::CurrencyNameText' has a wrong offset!");
static_assert(offsetof(UUMGStoreEventItemsPackButton, UniformGridPanel) == 0x000358, "Member 'UUMGStoreEventItemsPackButton::UniformGridPanel' has a wrong offset!");
static_assert(offsetof(UUMGStoreEventItemsPackButton, BuyButton) == 0x000360, "Member 'UUMGStoreEventItemsPackButton::BuyButton' has a wrong offset!");
static_assert(offsetof(UUMGStoreEventItemsPackButton, StorePriceWidget) == 0x000368, "Member 'UUMGStoreEventItemsPackButton::StorePriceWidget' has a wrong offset!");
static_assert(offsetof(UUMGStoreEventItemsPackButton, EndDateTimerWidget) == 0x000370, "Member 'UUMGStoreEventItemsPackButton::EndDateTimerWidget' has a wrong offset!");
static_assert(offsetof(UUMGStoreEventItemsPackButton, SelectedImageBox) == 0x000378, "Member 'UUMGStoreEventItemsPackButton::SelectedImageBox' has a wrong offset!");
static_assert(offsetof(UUMGStoreEventItemsPackButton, EventItemWidgetClassPtr) == 0x000380, "Member 'UUMGStoreEventItemsPackButton::EventItemWidgetClassPtr' has a wrong offset!");
static_assert(offsetof(UUMGStoreEventItemsPackButton, nbColumns) == 0x0003B0, "Member 'UUMGStoreEventItemsPackButton::nbColumns' has a wrong offset!");

// Class DeadByDaylight.UMGStorefrontCustomizationWidget
// 0x0010 (0x04B0 - 0x04A0)
class UUMGStorefrontCustomizationWidget final : public UUMGPromoPackItemWidget
{
public:
	class UTextBlock*                             CustomizationQuantityText;                         // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CustomizationQuantityPanel;                        // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGStorefrontCustomizationWidget">();
	}
	static class UUMGStorefrontCustomizationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGStorefrontCustomizationWidget>();
	}
};
static_assert(alignof(UUMGStorefrontCustomizationWidget) == 0x000008, "Wrong alignment on UUMGStorefrontCustomizationWidget");
static_assert(sizeof(UUMGStorefrontCustomizationWidget) == 0x0004B0, "Wrong size on UUMGStorefrontCustomizationWidget");
static_assert(offsetof(UUMGStorefrontCustomizationWidget, CustomizationQuantityText) == 0x0004A0, "Member 'UUMGStorefrontCustomizationWidget::CustomizationQuantityText' has a wrong offset!");
static_assert(offsetof(UUMGStorefrontCustomizationWidget, CustomizationQuantityPanel) == 0x0004A8, "Member 'UUMGStorefrontCustomizationWidget::CustomizationQuantityPanel' has a wrong offset!");

// Class DeadByDaylight.UMGStreamVideoWidget
// 0x0048 (0x0380 - 0x0338)
class UUMGStreamVideoWidget final : public UMobileBaseUserWidget
{
public:
	class UImage*                                 VideoImage;                                        // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                TapButton;                                         // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGBaseButtonWidget*                   SkipButton;                                        // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x10];                                     // 0x0350(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _timerShowSkipButton;                              // 0x0360(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x1C];                                     // 0x0364(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSkipButtonClicked();
	void OnTapButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGStreamVideoWidget">();
	}
	static class UUMGStreamVideoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGStreamVideoWidget>();
	}
};
static_assert(alignof(UUMGStreamVideoWidget) == 0x000008, "Wrong alignment on UUMGStreamVideoWidget");
static_assert(sizeof(UUMGStreamVideoWidget) == 0x000380, "Wrong size on UUMGStreamVideoWidget");
static_assert(offsetof(UUMGStreamVideoWidget, VideoImage) == 0x000338, "Member 'UUMGStreamVideoWidget::VideoImage' has a wrong offset!");
static_assert(offsetof(UUMGStreamVideoWidget, TapButton) == 0x000340, "Member 'UUMGStreamVideoWidget::TapButton' has a wrong offset!");
static_assert(offsetof(UUMGStreamVideoWidget, SkipButton) == 0x000348, "Member 'UUMGStreamVideoWidget::SkipButton' has a wrong offset!");
static_assert(offsetof(UUMGStreamVideoWidget, _timerShowSkipButton) == 0x000360, "Member 'UUMGStreamVideoWidget::_timerShowSkipButton' has a wrong offset!");

// Class DeadByDaylight.UMGSubscriptionPackButtonWidget
// 0x0158 (0x05C0 - 0x0468)
class UUMGSubscriptionPackButtonWidget final : public UUMGBaseButtonWidget
{
public:
	class USubscriptionRewardDataAsset*           WidgetPerRewardType;                               // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ButtonPressedVFX;                                  // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           PricePanel;                                        // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TitleIcon;                                         // 0x0480(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Title;                                             // 0x0488(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Price;                                             // 0x0490(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           RenewalDatePanel;                                  // 0x0498(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RenewalDateText;                                   // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      PurchaseRewardsGrid;                               // 0x04A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      DailyRewardsGrid;                                  // 0x04B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PortraitBorder;                                    // 0x04B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                InfoButton;                                        // 0x04C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ActiveBackgroundImage;                             // 0x04C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NonActiveBackgroundImage;                          // 0x04D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ActiveTextColor;                                   // 0x04D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NonActiveTextColor;                                // 0x04E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           TextColor;                                         // 0x04F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ActiveSmokeBackgroundTint;                         // 0x0508(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NonActiveSmokeBackgroundTint;                      // 0x0518(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PurchaseRewardsSmokeBackground;                    // 0x0528(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 DailyRewardsSmokeBackground;                       // 0x0530(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ActiveTitleBackgroundTint;                         // 0x0538(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           NonActiveTitleBackgroundTint;                      // 0x0548(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 TitleBackground;                                   // 0x0558(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ActiveFrame;                                       // 0x0560(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           NonActiveFrame;                                    // 0x0568(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_570[0x50];                                     // 0x0570(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInfoButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSubscriptionPackButtonWidget">();
	}
	static class UUMGSubscriptionPackButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSubscriptionPackButtonWidget>();
	}
};
static_assert(alignof(UUMGSubscriptionPackButtonWidget) == 0x000008, "Wrong alignment on UUMGSubscriptionPackButtonWidget");
static_assert(sizeof(UUMGSubscriptionPackButtonWidget) == 0x0005C0, "Wrong size on UUMGSubscriptionPackButtonWidget");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, WidgetPerRewardType) == 0x000468, "Member 'UUMGSubscriptionPackButtonWidget::WidgetPerRewardType' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, ButtonPressedVFX) == 0x000470, "Member 'UUMGSubscriptionPackButtonWidget::ButtonPressedVFX' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, PricePanel) == 0x000478, "Member 'UUMGSubscriptionPackButtonWidget::PricePanel' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, TitleIcon) == 0x000480, "Member 'UUMGSubscriptionPackButtonWidget::TitleIcon' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, Title) == 0x000488, "Member 'UUMGSubscriptionPackButtonWidget::Title' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, Price) == 0x000490, "Member 'UUMGSubscriptionPackButtonWidget::Price' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, RenewalDatePanel) == 0x000498, "Member 'UUMGSubscriptionPackButtonWidget::RenewalDatePanel' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, RenewalDateText) == 0x0004A0, "Member 'UUMGSubscriptionPackButtonWidget::RenewalDateText' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, PurchaseRewardsGrid) == 0x0004A8, "Member 'UUMGSubscriptionPackButtonWidget::PurchaseRewardsGrid' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, DailyRewardsGrid) == 0x0004B0, "Member 'UUMGSubscriptionPackButtonWidget::DailyRewardsGrid' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, PortraitBorder) == 0x0004B8, "Member 'UUMGSubscriptionPackButtonWidget::PortraitBorder' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, InfoButton) == 0x0004C0, "Member 'UUMGSubscriptionPackButtonWidget::InfoButton' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, ActiveBackgroundImage) == 0x0004C8, "Member 'UUMGSubscriptionPackButtonWidget::ActiveBackgroundImage' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, NonActiveBackgroundImage) == 0x0004D0, "Member 'UUMGSubscriptionPackButtonWidget::NonActiveBackgroundImage' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, ActiveTextColor) == 0x0004D8, "Member 'UUMGSubscriptionPackButtonWidget::ActiveTextColor' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, NonActiveTextColor) == 0x0004E8, "Member 'UUMGSubscriptionPackButtonWidget::NonActiveTextColor' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, TextColor) == 0x0004F8, "Member 'UUMGSubscriptionPackButtonWidget::TextColor' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, ActiveSmokeBackgroundTint) == 0x000508, "Member 'UUMGSubscriptionPackButtonWidget::ActiveSmokeBackgroundTint' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, NonActiveSmokeBackgroundTint) == 0x000518, "Member 'UUMGSubscriptionPackButtonWidget::NonActiveSmokeBackgroundTint' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, PurchaseRewardsSmokeBackground) == 0x000528, "Member 'UUMGSubscriptionPackButtonWidget::PurchaseRewardsSmokeBackground' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, DailyRewardsSmokeBackground) == 0x000530, "Member 'UUMGSubscriptionPackButtonWidget::DailyRewardsSmokeBackground' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, ActiveTitleBackgroundTint) == 0x000538, "Member 'UUMGSubscriptionPackButtonWidget::ActiveTitleBackgroundTint' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, NonActiveTitleBackgroundTint) == 0x000548, "Member 'UUMGSubscriptionPackButtonWidget::NonActiveTitleBackgroundTint' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, TitleBackground) == 0x000558, "Member 'UUMGSubscriptionPackButtonWidget::TitleBackground' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, ActiveFrame) == 0x000560, "Member 'UUMGSubscriptionPackButtonWidget::ActiveFrame' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionPackButtonWidget, NonActiveFrame) == 0x000568, "Member 'UUMGSubscriptionPackButtonWidget::NonActiveFrame' has a wrong offset!");

// Class DeadByDaylight.UMGSubscriptionsPageScrollWidget
// 0x0078 (0x04E8 - 0x0470)
class UUMGSubscriptionsPageScrollWidget final : public UUMGGridPageScrollWidget
{
public:
	TSoftClassPtr<class UClass>                   SubscriptionPackButtonClass;                       // 0x0470(0x0030)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ItemPadding;                                       // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A8[0x40];                                     // 0x04A8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleBuySubscriptionPackButtonClickedEvent(class FName subscriptionPackID);
	void HandleSubscriptionInfoButtonClickedEvent(const class FString& subscriptionDetails);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGSubscriptionsPageScrollWidget">();
	}
	static class UUMGSubscriptionsPageScrollWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGSubscriptionsPageScrollWidget>();
	}
};
static_assert(alignof(UUMGSubscriptionsPageScrollWidget) == 0x000008, "Wrong alignment on UUMGSubscriptionsPageScrollWidget");
static_assert(sizeof(UUMGSubscriptionsPageScrollWidget) == 0x0004E8, "Wrong size on UUMGSubscriptionsPageScrollWidget");
static_assert(offsetof(UUMGSubscriptionsPageScrollWidget, SubscriptionPackButtonClass) == 0x000470, "Member 'UUMGSubscriptionsPageScrollWidget::SubscriptionPackButtonClass' has a wrong offset!");
static_assert(offsetof(UUMGSubscriptionsPageScrollWidget, ItemPadding) == 0x0004A0, "Member 'UUMGSubscriptionsPageScrollWidget::ItemPadding' has a wrong offset!");

// Class DeadByDaylight.UMGTallyBloodpointsWidget
// 0x01A0 (0x04E8 - 0x0348)
class UUMGTallyBloodpointsWidget final : public UUMGTallyListElementWidget
{
public:
	ESlateVisibility                              _itemBoxVisibility;                                // 0x0348(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   _labelTotalScore;                                  // 0x0350(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   _labelItemTitle;                                   // 0x0368(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   _labelItemAddOnTitle;                              // 0x0380(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           _labelItemTitleColor;                              // 0x0398(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         BoxScoreCategory;                                  // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EDBDScoreCategory, struct FScoreCategoryUIExtraData> _scoreCategoryExtraDataMap;            // 0x03B0(0x0050)(Edit, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0xE8];                                     // 0x0400(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ShowTallyItemWidget(bool isShow);
	void UpdateTallyItemWidget(const struct FTallyItemChangedData& data);
	void UpdateTallyRewardWidget(const class FString& rewardName, int32 existReward, int32 addReward);
	void UpdateTallyTotalBloodpoints(int32 totalValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyBloodpointsWidget">();
	}
	static class UUMGTallyBloodpointsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyBloodpointsWidget>();
	}
};
static_assert(alignof(UUMGTallyBloodpointsWidget) == 0x000008, "Wrong alignment on UUMGTallyBloodpointsWidget");
static_assert(sizeof(UUMGTallyBloodpointsWidget) == 0x0004E8, "Wrong size on UUMGTallyBloodpointsWidget");
static_assert(offsetof(UUMGTallyBloodpointsWidget, _itemBoxVisibility) == 0x000348, "Member 'UUMGTallyBloodpointsWidget::_itemBoxVisibility' has a wrong offset!");
static_assert(offsetof(UUMGTallyBloodpointsWidget, _labelTotalScore) == 0x000350, "Member 'UUMGTallyBloodpointsWidget::_labelTotalScore' has a wrong offset!");
static_assert(offsetof(UUMGTallyBloodpointsWidget, _labelItemTitle) == 0x000368, "Member 'UUMGTallyBloodpointsWidget::_labelItemTitle' has a wrong offset!");
static_assert(offsetof(UUMGTallyBloodpointsWidget, _labelItemAddOnTitle) == 0x000380, "Member 'UUMGTallyBloodpointsWidget::_labelItemAddOnTitle' has a wrong offset!");
static_assert(offsetof(UUMGTallyBloodpointsWidget, _labelItemTitleColor) == 0x000398, "Member 'UUMGTallyBloodpointsWidget::_labelItemTitleColor' has a wrong offset!");
static_assert(offsetof(UUMGTallyBloodpointsWidget, BoxScoreCategory) == 0x0003A8, "Member 'UUMGTallyBloodpointsWidget::BoxScoreCategory' has a wrong offset!");
static_assert(offsetof(UUMGTallyBloodpointsWidget, _scoreCategoryExtraDataMap) == 0x0003B0, "Member 'UUMGTallyBloodpointsWidget::_scoreCategoryExtraDataMap' has a wrong offset!");

// Class DeadByDaylight.UMGTallyCharacterProgressionBar
// 0x0028 (0x0360 - 0x0338)
class UUMGTallyCharacterProgressionBar final : public UMobileBaseUserWidget
{
public:
	uint8                                         Pad_338[0x20];                                     // 0x0338(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UProgressBar*                           ProgressBar;                                       // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyCharacterProgressionBar">();
	}
	static class UUMGTallyCharacterProgressionBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyCharacterProgressionBar>();
	}
};
static_assert(alignof(UUMGTallyCharacterProgressionBar) == 0x000008, "Wrong alignment on UUMGTallyCharacterProgressionBar");
static_assert(sizeof(UUMGTallyCharacterProgressionBar) == 0x000360, "Wrong size on UUMGTallyCharacterProgressionBar");
static_assert(offsetof(UUMGTallyCharacterProgressionBar, ProgressBar) == 0x000358, "Member 'UUMGTallyCharacterProgressionBar::ProgressBar' has a wrong offset!");

// Class DeadByDaylight.UMGTallyCharacterProgressionWidget
// 0x0088 (0x03D0 - 0x0348)
class UUMGTallyCharacterProgressionWidget final : public UUMGTallyListElementWidget
{
public:
	class UUMGTallyCharacterProgressionBar*       CharacterProgressionBar;                           // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextCharacterCurrentExperience;                    // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextExperienceForNextLevel;                        // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextExperienceEarned;                              // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextCurrentLevel;                                  // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CharacterPicture;                                  // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PrestigeIcon;                                      // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextCharacterName;                                 // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExperiencePerSecond;                               // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38C[0x44];                                     // 0x038C(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFullBarIn();
	void OnFullBarOut();
	void SetWidgetToFinalState();
	void StartNewLevel();
	void StartSequence();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyCharacterProgressionWidget">();
	}
	static class UUMGTallyCharacterProgressionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyCharacterProgressionWidget>();
	}
};
static_assert(alignof(UUMGTallyCharacterProgressionWidget) == 0x000008, "Wrong alignment on UUMGTallyCharacterProgressionWidget");
static_assert(sizeof(UUMGTallyCharacterProgressionWidget) == 0x0003D0, "Wrong size on UUMGTallyCharacterProgressionWidget");
static_assert(offsetof(UUMGTallyCharacterProgressionWidget, CharacterProgressionBar) == 0x000348, "Member 'UUMGTallyCharacterProgressionWidget::CharacterProgressionBar' has a wrong offset!");
static_assert(offsetof(UUMGTallyCharacterProgressionWidget, TextCharacterCurrentExperience) == 0x000350, "Member 'UUMGTallyCharacterProgressionWidget::TextCharacterCurrentExperience' has a wrong offset!");
static_assert(offsetof(UUMGTallyCharacterProgressionWidget, TextExperienceForNextLevel) == 0x000358, "Member 'UUMGTallyCharacterProgressionWidget::TextExperienceForNextLevel' has a wrong offset!");
static_assert(offsetof(UUMGTallyCharacterProgressionWidget, TextExperienceEarned) == 0x000360, "Member 'UUMGTallyCharacterProgressionWidget::TextExperienceEarned' has a wrong offset!");
static_assert(offsetof(UUMGTallyCharacterProgressionWidget, TextCurrentLevel) == 0x000368, "Member 'UUMGTallyCharacterProgressionWidget::TextCurrentLevel' has a wrong offset!");
static_assert(offsetof(UUMGTallyCharacterProgressionWidget, CharacterPicture) == 0x000370, "Member 'UUMGTallyCharacterProgressionWidget::CharacterPicture' has a wrong offset!");
static_assert(offsetof(UUMGTallyCharacterProgressionWidget, PrestigeIcon) == 0x000378, "Member 'UUMGTallyCharacterProgressionWidget::PrestigeIcon' has a wrong offset!");
static_assert(offsetof(UUMGTallyCharacterProgressionWidget, TextCharacterName) == 0x000380, "Member 'UUMGTallyCharacterProgressionWidget::TextCharacterName' has a wrong offset!");
static_assert(offsetof(UUMGTallyCharacterProgressionWidget, ExperiencePerSecond) == 0x000388, "Member 'UUMGTallyCharacterProgressionWidget::ExperiencePerSecond' has a wrong offset!");

// Class DeadByDaylight.UMGTallyEmblemsWidget
// 0x0048 (0x0390 - 0x0348)
class UUMGTallyEmblemsWidget final : public UUMGTallyListElementWidget
{
public:
	TSoftClassPtr<class UClass>                   EmblemWidgetClass;                                 // 0x0348(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         EmblemsContainer;                                  // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUMGTallyEmblemWidget*>          _emblems;                                          // 0x0380(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	const TArray<class UUMGTallyEmblemWidget*> GetEmblems() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyEmblemsWidget">();
	}
	static class UUMGTallyEmblemsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyEmblemsWidget>();
	}
};
static_assert(alignof(UUMGTallyEmblemsWidget) == 0x000008, "Wrong alignment on UUMGTallyEmblemsWidget");
static_assert(sizeof(UUMGTallyEmblemsWidget) == 0x000390, "Wrong size on UUMGTallyEmblemsWidget");
static_assert(offsetof(UUMGTallyEmblemsWidget, EmblemWidgetClass) == 0x000348, "Member 'UUMGTallyEmblemsWidget::EmblemWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGTallyEmblemsWidget, EmblemsContainer) == 0x000378, "Member 'UUMGTallyEmblemsWidget::EmblemsContainer' has a wrong offset!");
static_assert(offsetof(UUMGTallyEmblemsWidget, _emblems) == 0x000380, "Member 'UUMGTallyEmblemsWidget::_emblems' has a wrong offset!");

// Class DeadByDaylight.UMGTallyEmblemWidget
// 0x0060 (0x0398 - 0x0338)
class UUMGTallyEmblemWidget final : public UMobileBaseUserWidget
{
public:
	TMap<EEmblemQuality, class UTexture2D*>       _emblemBackgrounds;                                // 0x0338(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 BackgroundImage;                                   // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IconImage;                                         // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PlayFadeInAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyEmblemWidget">();
	}
	static class UUMGTallyEmblemWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyEmblemWidget>();
	}
};
static_assert(alignof(UUMGTallyEmblemWidget) == 0x000008, "Wrong alignment on UUMGTallyEmblemWidget");
static_assert(sizeof(UUMGTallyEmblemWidget) == 0x000398, "Wrong size on UUMGTallyEmblemWidget");
static_assert(offsetof(UUMGTallyEmblemWidget, _emblemBackgrounds) == 0x000338, "Member 'UUMGTallyEmblemWidget::_emblemBackgrounds' has a wrong offset!");
static_assert(offsetof(UUMGTallyEmblemWidget, BackgroundImage) == 0x000388, "Member 'UUMGTallyEmblemWidget::BackgroundImage' has a wrong offset!");
static_assert(offsetof(UUMGTallyEmblemWidget, IconImage) == 0x000390, "Member 'UUMGTallyEmblemWidget::IconImage' has a wrong offset!");

// Class DeadByDaylight.UMGTallyPip
// 0x0010 (0x0348 - 0x0338)
class UUMGTallyPip final : public UMobileBaseUserWidget
{
public:
	class UImage*                                 Filling;                                           // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x8];                                      // 0x0340(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideFilling();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyPip">();
	}
	static class UUMGTallyPip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyPip>();
	}
};
static_assert(alignof(UUMGTallyPip) == 0x000008, "Wrong alignment on UUMGTallyPip");
static_assert(sizeof(UUMGTallyPip) == 0x000348, "Wrong size on UUMGTallyPip");
static_assert(offsetof(UUMGTallyPip, Filling) == 0x000338, "Member 'UUMGTallyPip::Filling' has a wrong offset!");

// Class DeadByDaylight.UMGTallyPipsContainer
// 0x0038 (0x0370 - 0x0338)
class UUMGTallyPipsContainer final : public UMobileBaseUserWidget
{
public:
	class UHorizontalBox*                         PipsContainer;                                     // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           _pipsClasses;                                      // 0x0340(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FMargin                                _pipsPadding;                                      // 0x0350(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UUMGTallyPip*>                   Pips;                                              // 0x0360(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void SetData(int32 rank, int32 pipsRequiredForNextRank, int32 filledPips);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyPipsContainer">();
	}
	static class UUMGTallyPipsContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyPipsContainer>();
	}
};
static_assert(alignof(UUMGTallyPipsContainer) == 0x000008, "Wrong alignment on UUMGTallyPipsContainer");
static_assert(sizeof(UUMGTallyPipsContainer) == 0x000370, "Wrong size on UUMGTallyPipsContainer");
static_assert(offsetof(UUMGTallyPipsContainer, PipsContainer) == 0x000338, "Member 'UUMGTallyPipsContainer::PipsContainer' has a wrong offset!");
static_assert(offsetof(UUMGTallyPipsContainer, _pipsClasses) == 0x000340, "Member 'UUMGTallyPipsContainer::_pipsClasses' has a wrong offset!");
static_assert(offsetof(UUMGTallyPipsContainer, _pipsPadding) == 0x000350, "Member 'UUMGTallyPipsContainer::_pipsPadding' has a wrong offset!");
static_assert(offsetof(UUMGTallyPipsContainer, Pips) == 0x000360, "Member 'UUMGTallyPipsContainer::Pips' has a wrong offset!");

// Class DeadByDaylight.UMGTallyRankFrame
// 0x0010 (0x0348 - 0x0338)
class UUMGTallyRankFrame final : public UMobileBaseUserWidget
{
public:
	class UImage*                                 Frame;                                             // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Label;                                             // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetData(int32 rank, EPlayerRole playerRole);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyRankFrame">();
	}
	static class UUMGTallyRankFrame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyRankFrame>();
	}
};
static_assert(alignof(UUMGTallyRankFrame) == 0x000008, "Wrong alignment on UUMGTallyRankFrame");
static_assert(sizeof(UUMGTallyRankFrame) == 0x000348, "Wrong size on UUMGTallyRankFrame");
static_assert(offsetof(UUMGTallyRankFrame, Frame) == 0x000338, "Member 'UUMGTallyRankFrame::Frame' has a wrong offset!");
static_assert(offsetof(UUMGTallyRankFrame, Label) == 0x000340, "Member 'UUMGTallyRankFrame::Label' has a wrong offset!");

// Class DeadByDaylight.UMGTallyRankWidget
// 0x00A0 (0x03E8 - 0x0348)
class UUMGTallyRankWidget final : public UUMGTallyListElementWidget
{
public:
	struct FMargin                                _emblemsPadding;                                   // 0x0348(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   EmblemWidgetClass;                                 // 0x0358(0x0030)(Edit, NoClear, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         EmblemsContainer;                                  // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGTallyProgressBar*                   ProgressBar;                                       // 0x0390(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGTallyRankBanner*                    RankBanner;                                        // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             RankProgressLabel;                                 // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUMGTallyEmblemWidget*>          _emblems;                                          // 0x03A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FTallyScorePipsData                    _scoreData;                                        // 0x03B8(0x0030)(Transient, NativeAccessSpecifierPrivate)

public:
	const TArray<class UUMGTallyEmblemWidget*> GetEmblems() const;
	const struct FTallyScorePipsData GetScoreData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyRankWidget">();
	}
	static class UUMGTallyRankWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyRankWidget>();
	}
};
static_assert(alignof(UUMGTallyRankWidget) == 0x000008, "Wrong alignment on UUMGTallyRankWidget");
static_assert(sizeof(UUMGTallyRankWidget) == 0x0003E8, "Wrong size on UUMGTallyRankWidget");
static_assert(offsetof(UUMGTallyRankWidget, _emblemsPadding) == 0x000348, "Member 'UUMGTallyRankWidget::_emblemsPadding' has a wrong offset!");
static_assert(offsetof(UUMGTallyRankWidget, EmblemWidgetClass) == 0x000358, "Member 'UUMGTallyRankWidget::EmblemWidgetClass' has a wrong offset!");
static_assert(offsetof(UUMGTallyRankWidget, EmblemsContainer) == 0x000388, "Member 'UUMGTallyRankWidget::EmblemsContainer' has a wrong offset!");
static_assert(offsetof(UUMGTallyRankWidget, ProgressBar) == 0x000390, "Member 'UUMGTallyRankWidget::ProgressBar' has a wrong offset!");
static_assert(offsetof(UUMGTallyRankWidget, RankBanner) == 0x000398, "Member 'UUMGTallyRankWidget::RankBanner' has a wrong offset!");
static_assert(offsetof(UUMGTallyRankWidget, RankProgressLabel) == 0x0003A0, "Member 'UUMGTallyRankWidget::RankProgressLabel' has a wrong offset!");
static_assert(offsetof(UUMGTallyRankWidget, _emblems) == 0x0003A8, "Member 'UUMGTallyRankWidget::_emblems' has a wrong offset!");
static_assert(offsetof(UUMGTallyRankWidget, _scoreData) == 0x0003B8, "Member 'UUMGTallyRankWidget::_scoreData' has a wrong offset!");

// Class DeadByDaylight.UMGTallyScoreboardWidget
// 0x00A0 (0x03E8 - 0x0348)
class UUMGTallyScoreboardWidget final : public UUMGTallyListElementWidget
{
public:
	TMulticastInlineDelegate<void(const class FString& playerID)> OnTallyScoreboardAddFriendEvent;   // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& playerID)> OnTallyScoreboardReportEvent;      // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   LabelTextRank;                                     // 0x0368(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   LabelTextScore;                                    // 0x0380(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   LabelTextStatus;                                   // 0x0398(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class UUMGTallyScoreboardPlayerInfoWidget*    KillerWidget;                                      // 0x03B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGTallyScoreboardPlayerInfoWidget*    FirstSurvivorWidget;                               // 0x03B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGTallyScoreboardPlayerInfoWidget*    SecondSurvivorWidget;                              // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGTallyScoreboardPlayerInfoWidget*    ThirdSurvivorWidget;                               // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUMGTallyScoreboardPlayerInfoWidget*    FourthSurvivorWidget;                              // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUMGTallyScoreboardPlayerInfoWidget*> SurvivorWidgets;                              // 0x03D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void HandleAddFriendEvent(const class FString& playerID);
	void HandleReportEvent(const class FString& playerID);
	void SetFadeOut();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTallyScoreboardWidget">();
	}
	static class UUMGTallyScoreboardWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTallyScoreboardWidget>();
	}
};
static_assert(alignof(UUMGTallyScoreboardWidget) == 0x000008, "Wrong alignment on UUMGTallyScoreboardWidget");
static_assert(sizeof(UUMGTallyScoreboardWidget) == 0x0003E8, "Wrong size on UUMGTallyScoreboardWidget");
static_assert(offsetof(UUMGTallyScoreboardWidget, OnTallyScoreboardAddFriendEvent) == 0x000348, "Member 'UUMGTallyScoreboardWidget::OnTallyScoreboardAddFriendEvent' has a wrong offset!");
static_assert(offsetof(UUMGTallyScoreboardWidget, OnTallyScoreboardReportEvent) == 0x000358, "Member 'UUMGTallyScoreboardWidget::OnTallyScoreboardReportEvent' has a wrong offset!");
static_assert(offsetof(UUMGTallyScoreboardWidget, LabelTextRank) == 0x000368, "Member 'UUMGTallyScoreboardWidget::LabelTextRank' has a wrong offset!");
static_assert(offsetof(UUMGTallyScoreboardWidget, LabelTextScore) == 0x000380, "Member 'UUMGTallyScoreboardWidget::LabelTextScore' has a wrong offset!");
static_assert(offsetof(UUMGTallyScoreboardWidget, LabelTextStatus) == 0x000398, "Member 'UUMGTallyScoreboardWidget::LabelTextStatus' has a wrong offset!");
static_assert(offsetof(UUMGTallyScoreboardWidget, KillerWidget) == 0x0003B0, "Member 'UUMGTallyScoreboardWidget::KillerWidget' has a wrong offset!");
static_assert(offsetof(UUMGTallyScoreboardWidget, FirstSurvivorWidget) == 0x0003B8, "Member 'UUMGTallyScoreboardWidget::FirstSurvivorWidget' has a wrong offset!");
static_assert(offsetof(UUMGTallyScoreboardWidget, SecondSurvivorWidget) == 0x0003C0, "Member 'UUMGTallyScoreboardWidget::SecondSurvivorWidget' has a wrong offset!");
static_assert(offsetof(UUMGTallyScoreboardWidget, ThirdSurvivorWidget) == 0x0003C8, "Member 'UUMGTallyScoreboardWidget::ThirdSurvivorWidget' has a wrong offset!");
static_assert(offsetof(UUMGTallyScoreboardWidget, FourthSurvivorWidget) == 0x0003D0, "Member 'UUMGTallyScoreboardWidget::FourthSurvivorWidget' has a wrong offset!");
static_assert(offsetof(UUMGTallyScoreboardWidget, SurvivorWidgets) == 0x0003D8, "Member 'UUMGTallyScoreboardWidget::SurvivorWidgets' has a wrong offset!");

// Class DeadByDaylight.UMGTeachablePerkButton
// 0x0160 (0x0498 - 0x0338)
class UUMGTeachablePerkButton final : public UMobileBaseUserWidget
{
public:
	class UPerkActionButton*                      TeachablePerkButton;                               // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 LockedStatusIcon;                                  // 0x0340(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTeachableData                         _teachableData;                                    // 0x0348(0x0140)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const struct FTeachableData& teachableData, const struct FVector2D& position)> _onTeachablePerkTooltipLongPressEvent; // 0x0488(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)

public:
	void HandleTooltipLongPressedEvent(const struct FInventorySlotData& itemData, const struct FVector2D& position);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UMGTeachablePerkButton">();
	}
	static class UUMGTeachablePerkButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUMGTeachablePerkButton>();
	}
};
static_assert(alignof(UUMGTeachablePerkButton) == 0x000008, "Wrong alignment on UUMGTeachablePerkButton");
static_assert(sizeof(UUMGTeachablePerkButton) == 0x000498, "Wrong size on UUMGTeachablePerkButton");
static_assert(offsetof(UUMGTeachablePerkButton, TeachablePerkButton) == 0x000338, "Member 'UUMGTeachablePerkButton::TeachablePerkButton' has a wrong offset!");
static_assert(offsetof(UUMGTeachablePerkButton, LockedStatusIcon) == 0x000340, "Member 'UUMGTeachablePerkButton::LockedStatusIcon' has a wrong offset!");
static_assert(offsetof(UUMGTeachablePerkButton, _teachableData) == 0x000348, "Member 'UUMGTeachablePerkButton::_teachableData' has a wrong offset!");
static_assert(offsetof(UUMGTeachablePerkButton, _onTeachablePerkTooltipLongPressEvent) == 0x000488, "Member 'UUMGTeachablePerkButton::_onTeachablePerkTooltipLongPressEvent' has a wrong offset!");

// Class DeadByDaylight.UnbrokenPalletsRestrictedPlacementAreaStrategy
// 0x0020 (0x00C0 - 0x00A0)
class UUnbrokenPalletsRestrictedPlacementAreaStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	TArray<class APallet*>                        _unbrokenPallets;                                  // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class FName                                   _palletCollisionBoxWhenDroppedTagName;             // 0x00B0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnbrokenPalletsRestrictedPlacementAreaStrategy">();
	}
	static class UUnbrokenPalletsRestrictedPlacementAreaStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnbrokenPalletsRestrictedPlacementAreaStrategy>();
	}
};
static_assert(alignof(UUnbrokenPalletsRestrictedPlacementAreaStrategy) == 0x000008, "Wrong alignment on UUnbrokenPalletsRestrictedPlacementAreaStrategy");
static_assert(sizeof(UUnbrokenPalletsRestrictedPlacementAreaStrategy) == 0x0000C0, "Wrong size on UUnbrokenPalletsRestrictedPlacementAreaStrategy");
static_assert(offsetof(UUnbrokenPalletsRestrictedPlacementAreaStrategy, _unbrokenPallets) == 0x0000A0, "Member 'UUnbrokenPalletsRestrictedPlacementAreaStrategy::_unbrokenPallets' has a wrong offset!");
static_assert(offsetof(UUnbrokenPalletsRestrictedPlacementAreaStrategy, _palletCollisionBoxWhenDroppedTagName) == 0x0000B0, "Member 'UUnbrokenPalletsRestrictedPlacementAreaStrategy::_palletCollisionBoxWhenDroppedTagName' has a wrong offset!");

// Class DeadByDaylight.UnlockPersonalPerksPopupScreen
// 0x0000 (0x0140 - 0x0140)
class UUnlockPersonalPerksPopupScreen final : public UGenericPopupScreen
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnlockPersonalPerksPopupScreen">();
	}
	static class UUnlockPersonalPerksPopupScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnlockPersonalPerksPopupScreen>();
	}
};
static_assert(alignof(UUnlockPersonalPerksPopupScreen) == 0x000008, "Wrong alignment on UUnlockPersonalPerksPopupScreen");
static_assert(sizeof(UUnlockPersonalPerksPopupScreen) == 0x000140, "Wrong size on UUnlockPersonalPerksPopupScreen");

// Class DeadByDaylight.VisibleHatchRestrictedPlacementAreaStrategy
// 0x0008 (0x00A8 - 0x00A0)
class UVisibleHatchRestrictedPlacementAreaStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisibleHatchRestrictedPlacementAreaStrategy">();
	}
	static class UVisibleHatchRestrictedPlacementAreaStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisibleHatchRestrictedPlacementAreaStrategy>();
	}
};
static_assert(alignof(UVisibleHatchRestrictedPlacementAreaStrategy) == 0x000008, "Wrong alignment on UVisibleHatchRestrictedPlacementAreaStrategy");
static_assert(sizeof(UVisibleHatchRestrictedPlacementAreaStrategy) == 0x0000A8, "Wrong size on UVisibleHatchRestrictedPlacementAreaStrategy");

// Class DeadByDaylight.ZoneDetectorComponent
// 0x0038 (0x00F0 - 0x00B8)
class UZoneDetectorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            _zones;                                            // 0x00D0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class FName>                           _tags;                                             // 0x00E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void OnOverlapEnter(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnOverlapExit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZoneDetectorComponent">();
	}
	static class UZoneDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZoneDetectorComponent>();
	}
};
static_assert(alignof(UZoneDetectorComponent) == 0x000008, "Wrong alignment on UZoneDetectorComponent");
static_assert(sizeof(UZoneDetectorComponent) == 0x0000F0, "Wrong size on UZoneDetectorComponent");
static_assert(offsetof(UZoneDetectorComponent, _zones) == 0x0000D0, "Member 'UZoneDetectorComponent::_zones' has a wrong offset!");
static_assert(offsetof(UZoneDetectorComponent, _tags) == 0x0000E0, "Member 'UZoneDetectorComponent::_tags' has a wrong offset!");

}

