#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheGunslinger

#include "Basic.hpp"

#include "TheGunslinger_classes.hpp"
#include "TheGunslinger_parameters.hpp"


namespace SDK
{

// Function TheGunslinger.ChainPlayerMovementStatusEffect.OnIsChainCollidingChanged
// (Final, Native, Private)
// Parameters:
// bool                                    isColliding                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChainPlayerMovementStatusEffect::OnIsChainCollidingChanged(bool isColliding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChainPlayerMovementStatusEffect", "OnIsChainCollidingChanged");

	Params::ChainPlayerMovementStatusEffect_OnIsChainCollidingChanged Parms{};

	Parms.isColliding = isColliding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.DeadMansSwitch.OnRep_BlockedGenerators
// (Final, Native, Private)

void UDeadMansSwitch::OnRep_BlockedGenerators()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeadMansSwitch", "OnRep_BlockedGenerators");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.FireHarpoonRifleInteraction.Server_HandleMissShotScores
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const TArray<class ADBDPlayer*>&        nearMissedPlayers                                      (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UFireHarpoonRifleInteraction::Server_HandleMissShotScores(const TArray<class ADBDPlayer*>& nearMissedPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireHarpoonRifleInteraction", "Server_HandleMissShotScores");

	Params::FireHarpoonRifleInteraction_Server_HandleMissShotScores Parms{};

	Parms.nearMissedPlayers = std::move(nearMissedPlayers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.FireHarpoonRifleInteraction.Server_SetAimingSubstate
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// EFireHarpoonRifleAimingInteractionSubStatenewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFireHarpoonRifleInteraction::Server_SetAimingSubstate(EFireHarpoonRifleAimingInteractionSubState newState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireHarpoonRifleInteraction", "Server_SetAimingSubstate");

	Params::FireHarpoonRifleInteraction_Server_SetAimingSubstate Parms{};

	Parms.newState = newState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.ForThePeople.Client_OnActionInputPressedEnded
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void UForThePeople::Client_OnActionInputPressedEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ForThePeople", "Client_OnActionInputPressedEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.ForThePeople.Multicast_OnHealAbilityUsed
// (Final, Net, Native, Event, NetMulticast, Private)
// Parameters:
// class ACamperPlayer*                    healer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACamperPlayer*                    healTarget                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   amountHealed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForThePeople::Multicast_OnHealAbilityUsed(class ACamperPlayer* healer, class ACamperPlayer* healTarget, float amountHealed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ForThePeople", "Multicast_OnHealAbilityUsed");

	Params::ForThePeople_Multicast_OnHealAbilityUsed Parms{};

	Parms.healer = healer;
	Parms.healTarget = healTarget;
	Parms.amountHealed = amountHealed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.ForThePeople.OnHealingAbilityUsed
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ACamperPlayer*                    healingSurvivor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACamperPlayer*                    healedSurvivor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UForThePeople::OnHealingAbilityUsed(class ACamperPlayer* healingSurvivor, class ACamperPlayer* healedSurvivor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ForThePeople", "OnHealingAbilityUsed");

	Params::ForThePeople_OnHealingAbilityUsed Parms{};

	Parms.healingSurvivor = healingSurvivor;
	Parms.healedSurvivor = healedSurvivor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheGunslinger.ForThePeople.Server_OnActionInputPressed
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UForThePeople::Server_OnActionInputPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ForThePeople", "Server_OnActionInputPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.ForThePeople.OnRep_SetIsHealStartedOnServer
// (Final, Native, Private, Const)

void UForThePeople::OnRep_SetIsHealStartedOnServer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ForThePeople", "OnRep_SetIsHealStartedOnServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.GunslingerEffectsComponent.Multicast_PlayOutOfAmmoSound
// (Final, Net, Native, Event, NetMulticast, Private)

void UGunslingerEffectsComponent::Multicast_PlayOutOfAmmoSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GunslingerEffectsComponent", "Multicast_PlayOutOfAmmoSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.GunslingerEffectsComponent.OnItemUsedStateChanged
// (Final, Native, Private)
// Parameters:
// bool                                    isPressed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGunslingerEffectsComponent::OnItemUsedStateChanged(bool isPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GunslingerEffectsComponent", "OnItemUsedStateChanged");

	Params::GunslingerEffectsComponent_OnItemUsedStateChanged Parms{};

	Parms.isPressed = isPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.GunslingerUtilities.GetHarpoonRifle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AHarpoonRifle*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AHarpoonRifle* UGunslingerUtilities::GetHarpoonRifle(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GunslingerUtilities", "GetHarpoonRifle");

	Params::GunslingerUtilities_GetHarpoonRifle Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.HarpoonChainPositioner.AttachToAnimSocket
// (Final, Native, Public, BlueprintCallable)

void UHarpoonChainPositioner::AttachToAnimSocket()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HarpoonChainPositioner", "AttachToAnimSocket");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.HarpoonChainPositioner.AttachToRifle
// (Final, Native, Public, BlueprintCallable)

void UHarpoonChainPositioner::AttachToRifle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HarpoonChainPositioner", "AttachToRifle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.HarpoonChainPositioner.OnCurrentHarpoonChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           currentHarpoon                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHarpoonChainPositioner::OnCurrentHarpoonChanged(class AActor* currentHarpoon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HarpoonChainPositioner", "OnCurrentHarpoonChanged");

	Params::HarpoonChainPositioner_OnCurrentHarpoonChanged Parms{};

	Parms.currentHarpoon = currentHarpoon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheGunslinger.HarpoonChainPositioner.OnHarpoonLoadedOnRifle
// (Event, Protected, BlueprintEvent)

void UHarpoonChainPositioner::OnHarpoonLoadedOnRifle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HarpoonChainPositioner", "OnHarpoonLoadedOnRifle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheGunslinger.HarpoonChainPositioner.OnHarpoonTravelingChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isTravelling                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHarpoonChainPositioner::OnHarpoonTravelingChanged(bool isTravelling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HarpoonChainPositioner", "OnHarpoonTravelingChanged");

	Params::HarpoonChainPositioner_OnHarpoonTravelingChanged Parms{};

	Parms.isTravelling = isTravelling;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheGunslinger.HarpoonChainPositioner.OnOwnerCollected
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       collector                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHarpoonChainPositioner::OnOwnerCollected(class ADBDPlayer* collector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HarpoonChainPositioner", "OnOwnerCollected");

	Params::HarpoonChainPositioner_OnOwnerCollected Parms{};

	Parms.collector = collector;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.HarpoonChainPositioner.GetCurrentHarpoon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UHarpoonChainPositioner::GetCurrentHarpoon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HarpoonChainPositioner", "GetCurrentHarpoon");

	Params::HarpoonChainPositioner_GetCurrentHarpoon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.HarpoonChainPositioner.GetHarpoonProp
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AHarpoonProp*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AHarpoonProp* UHarpoonChainPositioner::GetHarpoonProp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HarpoonChainPositioner", "GetHarpoonProp");

	Params::HarpoonChainPositioner_GetHarpoonProp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.HarpoonProjectile.OnHarpoonStop
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FHitResult&                result                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AHarpoonProjectile::OnHarpoonStop(const struct FHitResult& result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HarpoonProjectile", "OnHarpoonStop");

	Params::HarpoonProjectile_OnHarpoonStop Parms{};

	Parms.result = std::move(result);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.HarpoonRifle.Authority_OnFireHarpoon
// (Final, Native, Private)

void AHarpoonRifle::Authority_OnFireHarpoon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HarpoonRifle", "Authority_OnFireHarpoon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.HarpoonRifle.GetChain
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ARifleChain*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ARifleChain* AHarpoonRifle::GetChain() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HarpoonRifle", "GetChain");

	Params::HarpoonRifle_GetChain Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.OffTheRecord.GetActivationDurationAtLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOffTheRecord::GetActivationDurationAtLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OffTheRecord", "GetActivationDurationAtLevel");

	Params::OffTheRecord_GetActivationDurationAtLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.RedHerring.OnLoudNoiseTriggered
// (Event, Protected, BlueprintEvent)

void URedHerring::OnLoudNoiseTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RedHerring", "OnLoudNoiseTriggered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheGunslinger.RedHerring.OnRep_MarkedGenerator
// (Final, Native, Private)
// Parameters:
// class AGenerator*                       oldMarkedGenerator                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URedHerring::OnRep_MarkedGenerator(class AGenerator* oldMarkedGenerator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RedHerring", "OnRep_MarkedGenerator");

	Params::RedHerring_OnRep_MarkedGenerator Parms{};

	Parms.oldMarkedGenerator = oldMarkedGenerator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.RifleChain.OnAttachToPlayer
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARifleChain::OnAttachToPlayer(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChain", "OnAttachToPlayer");

	Params::RifleChain_OnAttachToPlayer Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheGunslinger.RifleChain.OnLaunch
// (Event, Public, BlueprintEvent)

void ARifleChain::OnLaunch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChain", "OnLaunch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheGunslinger.RifleChain.OnReelBackToRifle
// (Event, Public, BlueprintEvent)

void ARifleChain::OnReelBackToRifle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChain", "OnReelBackToRifle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TheGunslinger.RifleChain.OnUnattachFromPlayer
// (Event, Public, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARifleChain::OnUnattachFromPlayer(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChain", "OnUnattachFromPlayer");

	Params::RifleChain_OnUnattachFromPlayer Parms{};

	Parms.player = player;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TheGunslinger.RifleChain.SpawnChainPoints
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   stop                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      influenceCurve                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   pointYPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   pointZPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    useOffset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USplineComponent*                 spline                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ARifleChain::SpawnChainPoints(const struct FVector& start, const struct FVector& stop, class UCurveFloat* influenceCurve, float pointYPosition, float pointZPosition, bool useOffset, class USplineComponent* spline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChain", "SpawnChainPoints");

	Params::RifleChain_SpawnChainPoints Parms{};

	Parms.start = std::move(start);
	Parms.stop = std::move(stop);
	Parms.influenceCurve = influenceCurve;
	Parms.pointYPosition = pointYPosition;
	Parms.pointZPosition = pointZPosition;
	Parms.useOffset = useOffset;
	Parms.spline = spline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.RifleChain.UpdateChainMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInstancedStaticMeshComponent*    mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USplineComponent*                 spline                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARifleChain::UpdateChainMesh(class UInstancedStaticMeshComponent* mesh, class USplineComponent* spline, float alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChain", "UpdateChainMesh");

	Params::RifleChain_UpdateChainMesh Parms{};

	Parms.mesh = mesh;
	Parms.spline = spline;
	Parms.alpha = alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.RifleChain.GetChainEnd
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARifleChain::GetChainEnd() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChain", "GetChainEnd");

	Params::RifleChain_GetChainEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.RifleChain.GetChainStart
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ARifleChain::GetChainStart() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChain", "GetChainStart");

	Params::RifleChain_GetChainStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.RifleChain.GetChainTensionComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URifleChainTensionComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URifleChainTensionComponent* ARifleChain::GetChainTensionComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChain", "GetChainTensionComponent");

	Params::RifleChain_GetChainTensionComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.RifleChain.GetFirstAndLastCollisionHits
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FHitResult>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FHitResult> ARifleChain::GetFirstAndLastCollisionHits() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChain", "GetFirstAndLastCollisionHits");

	Params::RifleChain_GetFirstAndLastCollisionHits Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.RifleChain.GetRiflePlayerLinker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class URiflePlayerLinker*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URiflePlayerLinker* ARifleChain::GetRiflePlayerLinker() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChain", "GetRiflePlayerLinker");

	Params::RifleChain_GetRiflePlayerLinker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.RifleChain.GetUnwindingSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARifleChain::GetUnwindingSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChain", "GetUnwindingSpeed");

	Params::RifleChain_GetUnwindingSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.RifleChain.IsColliding
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARifleChain::IsColliding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChain", "IsColliding");

	Params::RifleChain_IsColliding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.RifleChainTensionComponent.OnRep_IsBuildingTension
// (Final, Native, Private)

void URifleChainTensionComponent::OnRep_IsBuildingTension()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChainTensionComponent", "OnRep_IsBuildingTension");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.RifleChainTensionComponent.OnTensionChargeableCompletionChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// bool                                    completed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            instigatorsForCompletion                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void URifleChainTensionComponent::OnTensionChargeableCompletionChanged(bool completed, const TArray<class AActor*>& instigatorsForCompletion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChainTensionComponent", "OnTensionChargeableCompletionChanged");

	Params::RifleChainTensionComponent_OnTensionChargeableCompletionChanged Parms{};

	Parms.completed = completed;
	Parms.instigatorsForCompletion = std::move(instigatorsForCompletion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.RifleChainTensionComponent.GetProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float URifleChainTensionComponent::GetProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChainTensionComponent", "GetProgress");

	Params::RifleChainTensionComponent_GetProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.RifleChainTensionComponent.IsBuildingTension
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URifleChainTensionComponent::IsBuildingTension() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RifleChainTensionComponent", "IsBuildingTension");

	Params::RifleChainTensionComponent_IsBuildingTension Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.RiflePlayerLinker.Client_OnAuthorityTensionBreakChain
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URiflePlayerLinker::Client_OnAuthorityTensionBreakChain(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiflePlayerLinker", "Client_OnAuthorityTensionBreakChain");

	Params::RiflePlayerLinker_Client_OnAuthorityTensionBreakChain Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.RiflePlayerLinker.Multicast_Link
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ADBDPlayer*                       linkedPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URiflePlayerLinker::Multicast_Link(class ADBDPlayer* linkedPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiflePlayerLinker", "Multicast_Link");

	Params::RiflePlayerLinker_Multicast_Link Parms{};

	Parms.linkedPlayer = linkedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.RiflePlayerLinker.Multicast_Unlink
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void URiflePlayerLinker::Multicast_Unlink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiflePlayerLinker", "Multicast_Unlink");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.RiflePlayerLinker.Server_OnClientConfirmTensionBreakChain
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URiflePlayerLinker::Server_OnClientConfirmTensionBreakChain(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiflePlayerLinker", "Server_OnClientConfirmTensionBreakChain");

	Params::RiflePlayerLinker_Server_OnClientConfirmTensionBreakChain Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.RiflePlayerLinker.GetLinkedPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* URiflePlayerLinker::GetLinkedPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiflePlayerLinker", "GetLinkedPlayer");

	Params::RiflePlayerLinker_GetLinkedPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.RiflePlayerLinker.GetLinkOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADBDPlayer* URiflePlayerLinker::GetLinkOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RiflePlayerLinker", "GetLinkOwner");

	Params::RiflePlayerLinker_GetLinkOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TheGunslinger.SurvivorChainLinkableComponent.OnRep_VelocityAdditiveStrategy
// (Final, Native, Private)

void USurvivorChainLinkableComponent::OnRep_VelocityAdditiveStrategy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorChainLinkableComponent", "OnRep_VelocityAdditiveStrategy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TheGunslinger.SurvivorReelVelocityAdditiveStrategy.OnKillerSet
// (Final, Native, Private)
// Parameters:
// class ASlasherPlayer*                   killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USurvivorReelVelocityAdditiveStrategy::OnKillerSet(class ASlasherPlayer* killer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SurvivorReelVelocityAdditiveStrategy", "OnKillerSet");

	Params::SurvivorReelVelocityAdditiveStrategy_OnKillerSet Parms{};

	Parms.killer = killer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

