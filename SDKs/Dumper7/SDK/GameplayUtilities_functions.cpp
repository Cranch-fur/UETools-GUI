#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameplayUtilities

#include "Basic.hpp"

#include "GameplayUtilities_classes.hpp"
#include "GameplayUtilities_parameters.hpp"


namespace SDK
{

// Function GameplayUtilities.CharacterPusherComponent.Construct
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCapsuleComponent*                characterDetector                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCapsuleComponent*                characterCollision                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBasePushStrategyComponent*       pushStrategy                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterPusherComponent::Construct(class UCapsuleComponent* characterDetector, class UCapsuleComponent* characterCollision, class UBasePushStrategyComponent* pushStrategy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterPusherComponent", "Construct");

	Params::CharacterPusherComponent_Construct Parms{};

	Parms.characterDetector = characterDetector;
	Parms.characterCollision = characterCollision;
	Parms.pushStrategy = pushStrategy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayUtilities.CharacterPusherComponent.OnCharacterDetectorOverlapExit
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              hitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           otherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              otherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   otherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterPusherComponent::OnCharacterDetectorOverlapExit(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterPusherComponent", "OnCharacterDetectorOverlapExit");

	Params::CharacterPusherComponent_OnCharacterDetectorOverlapExit Parms{};

	Parms.hitComponent = hitComponent;
	Parms.otherActor = otherActor;
	Parms.otherComp = otherComp;
	Parms.otherBodyIndex = otherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayUtilities.CharacterPusherComponent.SetIgnoredCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ignore                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterPusherComponent::SetIgnoredCharacter(class ACharacter* character, const bool ignore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterPusherComponent", "SetIgnoredCharacter");

	Params::CharacterPusherComponent_SetIgnoredCharacter Parms{};

	Parms.character = character;
	Parms.ignore = ignore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayUtilities.BasePoolableActorComponent.SetAcquired
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBasePoolableActorComponent::SetAcquired(bool active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePoolableActorComponent", "SetAcquired");

	Params::BasePoolableActorComponent_SetAcquired Parms{};

	Parms.active = active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayUtilities.BasePoolableActorComponent.IsAcquired
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBasePoolableActorComponent::IsAcquired() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePoolableActorComponent", "IsAcquired");

	Params::BasePoolableActorComponent_IsAcquired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayUtilities.AuthoritativePoolableActorComponent.OnRep_Acquired
// (Final, Native, Private)

void UAuthoritativePoolableActorComponent::OnRep_Acquired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthoritativePoolableActorComponent", "OnRep_Acquired");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameplayUtilities.AuthoritativeActorPoolComponent.Authority_OnActorDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           destroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuthoritativeActorPoolComponent::Authority_OnActorDestroyed(class AActor* destroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthoritativeActorPoolComponent", "Authority_OnActorDestroyed");

	Params::AuthoritativeActorPoolComponent_Authority_OnActorDestroyed Parms{};

	Parms.destroyedActor = destroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayUtilities.AuthoritativeActorPoolComponent.OnRep_Pool
// (Final, Native, Private)
// Parameters:
// const TArray<class AActor*>&            previousPool                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAuthoritativeActorPoolComponent::OnRep_Pool(const TArray<class AActor*>& previousPool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthoritativeActorPoolComponent", "OnRep_Pool");

	Params::AuthoritativeActorPoolComponent_OnRep_Pool Parms{};

	Parms.previousPool = std::move(previousPool);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayUtilities.BoxOcclusionQueryComponent.GetEstimatedRenderedPixelCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBoxOcclusionQueryComponent::GetEstimatedRenderedPixelCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoxOcclusionQueryComponent", "GetEstimatedRenderedPixelCount");

	Params::BoxOcclusionQueryComponent_GetEstimatedRenderedPixelCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayUtilities.BoxOcclusionQueryComponent.GetNumberOfVisiblePixels
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBoxOcclusionQueryComponent::GetNumberOfVisiblePixels() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoxOcclusionQueryComponent", "GetNumberOfVisiblePixels");

	Params::BoxOcclusionQueryComponent_GetNumberOfVisiblePixels Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayUtilities.BoxOcclusionQueryComponent.GetVisiblePercentOfScreen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBoxOcclusionQueryComponent::GetVisiblePercentOfScreen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoxOcclusionQueryComponent", "GetVisiblePercentOfScreen");

	Params::BoxOcclusionQueryComponent_GetVisiblePercentOfScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayUtilities.CharacterSightableComponent.GetHighestSightStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESightStatus                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESightStatus UCharacterSightableComponent::GetHighestSightStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSightableComponent", "GetHighestSightStatus");

	Params::CharacterSightableComponent_GetHighestSightStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayUtilities.CharacterSightComponent.OnRep_CanSee
// (Final, Native, Private)

void UCharacterSightComponent::OnRep_CanSee()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSightComponent", "OnRep_CanSee");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameplayUtilities.CharacterSightComponent.OnRep_DiscernibleCharacters
// (Final, Native, Private)

void UCharacterSightComponent::OnRep_DiscernibleCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSightComponent", "OnRep_DiscernibleCharacters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GameplayUtilities.CharacterSightComponent.Server_UpdateDiscernedCharacters
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const TArray<class ACharacter*>&        characters                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterSightComponent::Server_UpdateDiscernedCharacters(const TArray<class ACharacter*>& characters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSightComponent", "Server_UpdateDiscernedCharacters");

	Params::CharacterSightComponent_Server_UpdateDiscernedCharacters Parms{};

	Parms.characters = std::move(characters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayUtilities.CharacterSightComponent.SetMaximumSightDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterSightComponent::SetMaximumSightDistance(float value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSightComponent", "SetMaximumSightDistance");

	Params::CharacterSightComponent_SetMaximumSightDistance Parms{};

	Parms.value = value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayUtilities.CharacterSightComponent.SetMinimumCharacterScreenPercentInZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   trigger                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   untrigger                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterSightComponent::SetMinimumCharacterScreenPercentInZone(float trigger, float untrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSightComponent", "SetMinimumCharacterScreenPercentInZone");

	Params::CharacterSightComponent_SetMinimumCharacterScreenPercentInZone Parms{};

	Parms.trigger = trigger;
	Parms.untrigger = untrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayUtilities.CharacterSightComponent.SetMinimumCharacterScreenPercentNotInZone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   trigger                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   untrigger                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterSightComponent::SetMinimumCharacterScreenPercentNotInZone(float trigger, float untrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSightComponent", "SetMinimumCharacterScreenPercentNotInZone");

	Params::CharacterSightComponent_SetMinimumCharacterScreenPercentNotInZone Parms{};

	Parms.trigger = trigger;
	Parms.untrigger = untrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayUtilities.CharacterSightComponent.SetMinimumCharacterVisiblePixelsPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   trigger                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   untrigger                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterSightComponent::SetMinimumCharacterVisiblePixelsPercent(float trigger, float untrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSightComponent", "SetMinimumCharacterVisiblePixelsPercent");

	Params::CharacterSightComponent_SetMinimumCharacterVisiblePixelsPercent Parms{};

	Parms.trigger = trigger;
	Parms.untrigger = untrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayUtilities.CharacterSightComponent.SetScreenVisibilityZoneRadiusPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   valueX                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   valueY                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterSightComponent::SetScreenVisibilityZoneRadiusPercent(float valueX, float valueY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSightComponent", "SetScreenVisibilityZoneRadiusPercent");

	Params::CharacterSightComponent_SetScreenVisibilityZoneRadiusPercent Parms{};

	Parms.valueX = valueX;
	Parms.valueY = valueY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayUtilities.ChargeableUtilities.ConvertSecondsToAddToRateMultiplier
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   secondsToAdd                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   baseMaxSeconds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   baseRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UChargeableUtilities::ConvertSecondsToAddToRateMultiplier(float secondsToAdd, float baseMaxSeconds, float baseRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ChargeableUtilities", "ConvertSecondsToAddToRateMultiplier");

	Params::ChargeableUtilities_ConvertSecondsToAddToRateMultiplier Parms{};

	Parms.secondsToAdd = secondsToAdd;
	Parms.baseMaxSeconds = baseMaxSeconds;
	Parms.baseRate = baseRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayUtilities.MovementUtilities.Local_MoveActorTo
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const float                             duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementUtilities::Local_MoveActorTo(class AActor* actor, const struct FVector& location, const struct FRotator& rotation, const float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtilities", "Local_MoveActorTo");

	Params::MovementUtilities_Local_MoveActorTo Parms{};

	Parms.actor = actor;
	Parms.location = std::move(location);
	Parms.rotation = std::move(rotation);
	Parms.duration = duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GameplayUtilities.PawnUtilities.GetLocallyObservedPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    worldContext                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UPawnUtilities::GetLocallyObservedPawn(const class UObject* worldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PawnUtilities", "GetLocallyObservedPawn");

	Params::PawnUtilities_GetLocallyObservedPawn Parms{};

	Parms.worldContext = worldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GameplayUtilities.PawnUtilities.GetOwningPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     origin                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UPawnUtilities::GetOwningPawn(const class AActor* origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PawnUtilities", "GetOwningPawn");

	Params::PawnUtilities_GetOwningPawn Parms{};

	Parms.origin = origin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

