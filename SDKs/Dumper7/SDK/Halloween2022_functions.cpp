#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Halloween2022

#include "Basic.hpp"

#include "Halloween2022_classes.hpp"
#include "Halloween2022_parameters.hpp"


namespace SDK
{

// Function Halloween2022.VoidEnergyChangeQEEvaluator.ListenToOnComponentAddedEvent
// (Native, Protected)

void UVoidEnergyChangeQEEvaluator::ListenToOnComponentAddedEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyChangeQEEvaluator", "ListenToOnComponentAddedEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.DepositVoidEnergyTierQEEvaluator.OnVoidEnergyDeposited
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDepositVoidEnergyTierQEEvaluator::OnVoidEnergyDeposited(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DepositVoidEnergyTierQEEvaluator", "OnVoidEnergyDeposited");

	Params::DepositVoidEnergyTierQEEvaluator_OnVoidEnergyDeposited Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.HalloweenCentrifugeAnimInstance.OnBlendValueChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// const float                             blendValue                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHalloweenCentrifugeAnimInstance::OnBlendValueChanged(const float blendValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HalloweenCentrifugeAnimInstance", "OnBlendValueChanged");

	Params::HalloweenCentrifugeAnimInstance_OnBlendValueChanged Parms{};

	Parms.blendValue = blendValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Halloween2022.HalloweenCentrifugeAnimInstance.OnEnergySpawned
// (Final, Native, Protected)
// Parameters:
// int32                                   previousEnergy                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   currentEnergy                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHalloweenCentrifugeAnimInstance::OnEnergySpawned(int32 previousEnergy, int32 currentEnergy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HalloweenCentrifugeAnimInstance", "OnEnergySpawned");

	Params::HalloweenCentrifugeAnimInstance_OnEnergySpawned Parms{};

	Parms.previousEnergy = previousEnergy;
	Parms.currentEnergy = currentEnergy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.HalloweenCentrifugeAnimInstance.SetDesiredBlendValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const float                             blendValue                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHalloweenCentrifugeAnimInstance::SetDesiredBlendValue(const float blendValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HalloweenCentrifugeAnimInstance", "SetDesiredBlendValue");

	Params::HalloweenCentrifugeAnimInstance_SetDesiredBlendValue Parms{};

	Parms.blendValue = blendValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.GeneratorCentrifugeAnimInstance.OnStartRepair
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AGenerator*                       generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorCentrifugeAnimInstance::OnStartRepair(class AGenerator* generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorCentrifugeAnimInstance", "OnStartRepair");

	Params::GeneratorCentrifugeAnimInstance_OnStartRepair Parms{};

	Parms.generator = generator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Halloween2022.GeneratorCentrifugeAnimInstance.OnStopRepair
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AGenerator*                       generator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneratorCentrifugeAnimInstance::OnStopRepair(class AGenerator* generator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorCentrifugeAnimInstance", "OnStopRepair");

	Params::GeneratorCentrifugeAnimInstance_OnStopRepair Parms{};

	Parms.generator = generator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Halloween2022.GeneratorCentrifugeAnimInstance.StartRepairing
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGeneratorCentrifugeAnimInstance::StartRepairing(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorCentrifugeAnimInstance", "StartRepairing");

	Params::GeneratorCentrifugeAnimInstance_StartRepairing Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.GeneratorCentrifugeAnimInstance.StopRepairing
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UGeneratorCentrifugeAnimInstance::StopRepairing(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneratorCentrifugeAnimInstance", "StopRepairing");

	Params::GeneratorCentrifugeAnimInstance_StopRepairing Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.MeatHookCentrifugeAnimInstance.OnPlayerHooked
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AMeatHook*                        meatHook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeatHookCentrifugeAnimInstance::OnPlayerHooked(class AMeatHook* meatHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHookCentrifugeAnimInstance", "OnPlayerHooked");

	Params::MeatHookCentrifugeAnimInstance_OnPlayerHooked Parms{};

	Parms.meatHook = meatHook;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Halloween2022.MeatHookCentrifugeAnimInstance.OnPlayerNoLongerOnHook
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AMeatHook*                        meatHook                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMeatHookCentrifugeAnimInstance::OnPlayerNoLongerOnHook(class AMeatHook* meatHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHookCentrifugeAnimInstance", "OnPlayerNoLongerOnHook");

	Params::MeatHookCentrifugeAnimInstance_OnPlayerNoLongerOnHook Parms{};

	Parms.meatHook = meatHook;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Halloween2022.MeatHookCentrifugeAnimInstance.PlayerHooked
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMeatHookCentrifugeAnimInstance::PlayerHooked(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHookCentrifugeAnimInstance", "PlayerHooked");

	Params::MeatHookCentrifugeAnimInstance_PlayerHooked Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.MeatHookCentrifugeAnimInstance.PlayerNoLongerOnHook
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMeatHookCentrifugeAnimInstance::PlayerNoLongerOnHook(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeatHookCentrifugeAnimInstance", "PlayerNoLongerOnHook");

	Params::MeatHookCentrifugeAnimInstance_PlayerNoLongerOnHook Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.PlayerVoidEnergy.OnLocallyControlledChanged
// (Final, Native, Private)

void UPlayerVoidEnergy::OnLocallyControlledChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVoidEnergy", "OnLocallyControlledChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.PlayerVoidEnergy.OnLocallyObservedChanged
// (Final, Native, Private)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerVoidEnergy::OnLocallyObservedChanged(class ADBDPlayer* player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVoidEnergy", "OnLocallyObservedChanged");

	Params::PlayerVoidEnergy_OnLocallyObservedChanged Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.PlayerVoidEnergy.OnRep_CurrentVoidEnergy
// (Final, Native, Private)
// Parameters:
// int32                                   previousEnergyCount                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerVoidEnergy::OnRep_CurrentVoidEnergy(int32 previousEnergyCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVoidEnergy", "OnRep_CurrentVoidEnergy");

	Params::PlayerVoidEnergy_OnRep_CurrentVoidEnergy Parms{};

	Parms.previousEnergyCount = previousEnergyCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.PlayerVoidEnergy.OnRep_TotalVoidEnergySpent
// (Final, Native, Private)

void UPlayerVoidEnergy::OnRep_TotalVoidEnergySpent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVoidEnergy", "OnRep_TotalVoidEnergySpent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.PlayerVoidEnergy.OnVoidEnergyGained
// (Event, Protected, BlueprintEvent)

void UPlayerVoidEnergy::OnVoidEnergyGained()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVoidEnergy", "OnVoidEnergyGained");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Halloween2022.PlayerVoidEnergy.OnVoidEnergyLost
// (Event, Protected, BlueprintEvent)

void UPlayerVoidEnergy::OnVoidEnergyLost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVoidEnergy", "OnVoidEnergyLost");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Halloween2022.PlayerVoidEnergy.OnVoidEnergySpent
// (Event, Protected, BlueprintEvent)

void UPlayerVoidEnergy::OnVoidEnergySpent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVoidEnergy", "OnVoidEnergySpent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Halloween2022.PlayerVoidEnergy.GetCurrentBloodPointMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerVoidEnergy::GetCurrentBloodPointMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVoidEnergy", "GetCurrentBloodPointMultiplier");

	Params::PlayerVoidEnergy_GetCurrentBloodPointMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Halloween2022.PlayerVoidEnergy.GetCurrentVoidEnergyCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlayerVoidEnergy::GetCurrentVoidEnergyCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVoidEnergy", "GetCurrentVoidEnergyCount");

	Params::PlayerVoidEnergy_GetCurrentVoidEnergyCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Halloween2022.PlayerVoidEnergy.GetCurrentVoidEnergyRewardTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlayerVoidEnergy::GetCurrentVoidEnergyRewardTier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVoidEnergy", "GetCurrentVoidEnergyRewardTier");

	Params::PlayerVoidEnergy_GetCurrentVoidEnergyRewardTier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Halloween2022.PlayerVoidEnergy.GetMaxAmountOfVoidEnergyCanReceive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlayerVoidEnergy::GetMaxAmountOfVoidEnergyCanReceive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVoidEnergy", "GetMaxAmountOfVoidEnergyCanReceive");

	Params::PlayerVoidEnergy_GetMaxAmountOfVoidEnergyCanReceive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Halloween2022.PlayerVoidEnergy.GetTotalVoidEnergyDeposited
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlayerVoidEnergy::GetTotalVoidEnergyDeposited() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerVoidEnergy", "GetTotalVoidEnergyDeposited");

	Params::PlayerVoidEnergy_GetTotalVoidEnergyDeposited Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Halloween2022.UnstableRift.Cosmetic_ChangeUnstableVisibility
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    isVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnstableRift::Cosmetic_ChangeUnstableVisibility(bool isVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableRift", "Cosmetic_ChangeUnstableVisibility");

	Params::UnstableRift_Cosmetic_ChangeUnstableVisibility Parms{};

	Parms.isVisible = isVisible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Halloween2022.UnstableRift.Cosmetic_OnInteractionCompleted
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       interactingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnstableRift::Cosmetic_OnInteractionCompleted(class ADBDPlayer* interactingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableRift", "Cosmetic_OnInteractionCompleted");

	Params::UnstableRift_Cosmetic_OnInteractionCompleted Parms{};

	Parms.interactingPlayer = interactingPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Halloween2022.UnstableRift.Cosmetic_OnStartedInteracting
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       interactingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   interactionDuration                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnstableRift::Cosmetic_OnStartedInteracting(class ADBDPlayer* interactingPlayer, float interactionDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableRift", "Cosmetic_OnStartedInteracting");

	Params::UnstableRift_Cosmetic_OnStartedInteracting Parms{};

	Parms.interactingPlayer = interactingPlayer;
	Parms.interactionDuration = interactionDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Halloween2022.UnstableRift.Cosmetic_OnStoppedInteracting
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)

void AUnstableRift::Cosmetic_OnStoppedInteracting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableRift", "Cosmetic_OnStoppedInteracting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Halloween2022.UnstableRift.Cosmetic_OnTeleportDelayStarted
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void AUnstableRift::Cosmetic_OnTeleportDelayStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableRift", "Cosmetic_OnTeleportDelayStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Halloween2022.UnstableRift.Cosmetic_OnTeleportFinished
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void AUnstableRift::Cosmetic_OnTeleportFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableRift", "Cosmetic_OnTeleportFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Halloween2022.UnstableRift.Cosmetic_OnTeleportStart
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// const bool                              hadPlayerInteraction                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnstableRift::Cosmetic_OnTeleportStart(const bool hadPlayerInteraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableRift", "Cosmetic_OnTeleportStart");

	Params::UnstableRift_Cosmetic_OnTeleportStart Parms{};

	Parms.hadPlayerInteraction = hadPlayerInteraction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Halloween2022.UnstableRift.OnIntroCompleted
// (Final, Native, Private)

void AUnstableRift::OnIntroCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableRift", "OnIntroCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.UnstableRiftTeleportationComponent.Authority_OnLevelReadyToPlay
// (Final, Native, Private)

void UUnstableRiftTeleportationComponent::Authority_OnLevelReadyToPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableRiftTeleportationComponent", "Authority_OnLevelReadyToPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.UnstableRiftTeleportationComponent.Multicast_PreTeleportation
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// const struct FVector&                   teleportLocation                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              hadPlayerInteraction                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUnstableRiftTeleportationComponent::Multicast_PreTeleportation(const struct FVector& teleportLocation, const bool hadPlayerInteraction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableRiftTeleportationComponent", "Multicast_PreTeleportation");

	Params::UnstableRiftTeleportationComponent_Multicast_PreTeleportation Parms{};

	Parms.teleportLocation = std::move(teleportLocation);
	Parms.hadPlayerInteraction = hadPlayerInteraction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.UnstableRiftTeleportationComponent.Multicast_TeleportUnstableRift
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, HasDefaults)
// Parameters:
// const struct FVector&                   location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUnstableRiftTeleportationComponent::Multicast_TeleportUnstableRift(const struct FVector& location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnstableRiftTeleportationComponent", "Multicast_TeleportUnstableRift");

	Params::UnstableRiftTeleportationComponent_Multicast_TeleportUnstableRift Parms{};

	Parms.location = std::move(location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.VoidEnergyProducer.Cosmetic_OnVoidOrbsSpawned
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// const int32                             orbsSpawned                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoidEnergyProducer::Cosmetic_OnVoidOrbsSpawned(const int32 orbsSpawned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyProducer", "Cosmetic_OnVoidOrbsSpawned");

	Params::VoidEnergyProducer_Cosmetic_OnVoidOrbsSpawned Parms{};

	Parms.orbsSpawned = orbsSpawned;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Halloween2022.VoidEnergyProducer.OnRep_TotalEnergyGiven
// (Final, Native, Protected)
// Parameters:
// int32                                   lastTotalEnergyGivenValue                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoidEnergyProducer::OnRep_TotalEnergyGiven(int32 lastTotalEnergyGivenValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyProducer", "OnRep_TotalEnergyGiven");

	Params::VoidEnergyProducer_OnRep_TotalEnergyGiven Parms{};

	Parms.lastTotalEnergyGivenValue = lastTotalEnergyGivenValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.VoidEnergyProducer.GetRemainingEnergy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVoidEnergyProducer::GetRemainingEnergy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyProducer", "GetRemainingEnergy");

	Params::VoidEnergyProducer_GetRemainingEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Halloween2022.VoidEnergyProducer.HasEnergyLeftToGive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVoidEnergyProducer::HasEnergyLeftToGive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyProducer", "HasEnergyLeftToGive");

	Params::VoidEnergyProducer_HasEnergyLeftToGive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Halloween2022.VoidEnergyGeneratorComponent.GetCurrentTimeDoneOnGenerator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADBDPlayer*                       player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVoidEnergyGeneratorComponent::GetCurrentTimeDoneOnGenerator(class ADBDPlayer* player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyGeneratorComponent", "GetCurrentTimeDoneOnGenerator");

	Params::VoidEnergyGeneratorComponent_GetCurrentTimeDoneOnGenerator Parms{};

	Parms.player = player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Halloween2022.VoidEnergyOrb.Cosmetic_DelayBeforeCollection
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       playerGivingOrbTo                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoidEnergyOrb::Cosmetic_DelayBeforeCollection(class ADBDPlayer* playerGivingOrbTo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyOrb", "Cosmetic_DelayBeforeCollection");

	Params::VoidEnergyOrb_Cosmetic_DelayBeforeCollection Parms{};

	Parms.playerGivingOrbTo = playerGivingOrbTo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Halloween2022.VoidEnergyOrb.Cosmetic_OnOrbDisappearWithCollection
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       playerGivingOrbTo                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoidEnergyOrb::Cosmetic_OnOrbDisappearWithCollection(class ADBDPlayer* playerGivingOrbTo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyOrb", "Cosmetic_OnOrbDisappearWithCollection");

	Params::VoidEnergyOrb_Cosmetic_OnOrbDisappearWithCollection Parms{};

	Parms.playerGivingOrbTo = playerGivingOrbTo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Halloween2022.VoidEnergyOrb.Cosmetic_OnOrbDisappearWithoutCollection
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// const bool                              isLargeOrb                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoidEnergyOrb::Cosmetic_OnOrbDisappearWithoutCollection(const bool isLargeOrb)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyOrb", "Cosmetic_OnOrbDisappearWithoutCollection");

	Params::VoidEnergyOrb_Cosmetic_OnOrbDisappearWithoutCollection Parms{};

	Parms.isLargeOrb = isLargeOrb;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Halloween2022.VoidEnergyOrb.Cosmetic_OnOrbSpawned
// (BlueprintCosmetic, Event, Protected, BlueprintEvent)
// Parameters:
// class ADBDPlayer*                       playerGivingOrbTo                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              isLargeOrb                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AVoidEnergyOrb::Cosmetic_OnOrbSpawned(class ADBDPlayer* playerGivingOrbTo, const bool isLargeOrb)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyOrb", "Cosmetic_OnOrbSpawned");

	Params::VoidEnergyOrb_Cosmetic_OnOrbSpawned Parms{};

	Parms.playerGivingOrbTo = playerGivingOrbTo;
	Parms.isLargeOrb = isLargeOrb;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Halloween2022.VoidEnergyOrb.PlaceOrbInQueue
// (Final, Native, Private, BlueprintCallable)

void AVoidEnergyOrb::PlaceOrbInQueue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyOrb", "PlaceOrbInQueue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.VoidEnergyOrbSpawner.Authority_GiveVoidEnergyToPlayer
// (Final, Native, Private)
// Parameters:
// const EVoidEnergyType                   voidEnergyType                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             voidEnergyToAdd                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoidEnergyOrbSpawner::Authority_GiveVoidEnergyToPlayer(const EVoidEnergyType voidEnergyType, const int32 voidEnergyToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyOrbSpawner", "Authority_GiveVoidEnergyToPlayer");

	Params::VoidEnergyOrbSpawner_Authority_GiveVoidEnergyToPlayer Parms{};

	Parms.voidEnergyType = voidEnergyType;
	Parms.voidEnergyToAdd = voidEnergyToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.VoidEnergyOrbSpawner.Authority_KillerDownSurvivor
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UVoidEnergyOrbSpawner::Authority_KillerDownSurvivor(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyOrbSpawner", "Authority_KillerDownSurvivor");

	Params::VoidEnergyOrbSpawner_Authority_KillerDownSurvivor Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.VoidEnergyOrbSpawner.Authority_SpawnVoidEnergyOrbs
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FOrbProperties&            orbProperties                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const int32                             numberOfOrbsToSpawn                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             numberOfOrbsThatCanBeAbsorbed                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoidEnergyOrbSpawner::Authority_SpawnVoidEnergyOrbs(const struct FOrbProperties& orbProperties, const int32 numberOfOrbsToSpawn, const int32 numberOfOrbsThatCanBeAbsorbed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyOrbSpawner", "Authority_SpawnVoidEnergyOrbs");

	Params::VoidEnergyOrbSpawner_Authority_SpawnVoidEnergyOrbs Parms{};

	Parms.orbProperties = std::move(orbProperties);
	Parms.numberOfOrbsToSpawn = numberOfOrbsToSpawn;
	Parms.numberOfOrbsThatCanBeAbsorbed = numberOfOrbsThatCanBeAbsorbed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.VoidEnergyOrbSpawner.Authority_SurvivorStunKillerWithFlashLight
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UVoidEnergyOrbSpawner::Authority_SurvivorStunKillerWithFlashLight(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyOrbSpawner", "Authority_SurvivorStunKillerWithFlashLight");

	Params::VoidEnergyOrbSpawner_Authority_SurvivorStunKillerWithFlashLight Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.VoidEnergyOrbSpawner.Authority_SurvivorStunKillerWithHeadOn
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UVoidEnergyOrbSpawner::Authority_SurvivorStunKillerWithHeadOn(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyOrbSpawner", "Authority_SurvivorStunKillerWithHeadOn");

	Params::VoidEnergyOrbSpawner_Authority_SurvivorStunKillerWithHeadOn Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.VoidEnergyOrbSpawner.Authority_SurvivorStunKillerWithPallet
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UVoidEnergyOrbSpawner::Authority_SurvivorStunKillerWithPallet(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyOrbSpawner", "Authority_SurvivorStunKillerWithPallet");

	Params::VoidEnergyOrbSpawner_Authority_SurvivorStunKillerWithPallet Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.VoidEnergyOrbSpawner.Authority_SurvivorStunOnKiller
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FGameplayTag&              gameEventType                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameEventData&            gameEventData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UVoidEnergyOrbSpawner::Authority_SurvivorStunOnKiller(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyOrbSpawner", "Authority_SurvivorStunOnKiller");

	Params::VoidEnergyOrbSpawner_Authority_SurvivorStunOnKiller Parms{};

	Parms.gameEventType = std::move(gameEventType);
	Parms.gameEventData = std::move(gameEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.VoidEnergyOrbSpawner.Authority_TimerSpawnVoidEnergyOrb
// (Final, Native, Private)
// Parameters:
// const struct FOrbProperties&            orbProperties                                          (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const bool                              isLargeOrb                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoidEnergyOrbSpawner::Authority_TimerSpawnVoidEnergyOrb(const struct FOrbProperties& orbProperties, const bool isLargeOrb)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyOrbSpawner", "Authority_TimerSpawnVoidEnergyOrb");

	Params::VoidEnergyOrbSpawner_Authority_TimerSpawnVoidEnergyOrb Parms{};

	Parms.orbProperties = std::move(orbProperties);
	Parms.isLargeOrb = isLargeOrb;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Halloween2022.VoidEnergyOrbSpawner.Multicast_SpawnVoidEnergyOrb
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FOrbProperties&            orbProperties                                          (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const bool                              isLargeOrb                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVoidEnergyOrbSpawner::Multicast_SpawnVoidEnergyOrb(const struct FOrbProperties& orbProperties, const bool isLargeOrb)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VoidEnergyOrbSpawner", "Multicast_SpawnVoidEnergyOrb");

	Params::VoidEnergyOrbSpawner_Multicast_SpawnVoidEnergyOrb Parms{};

	Parms.orbProperties = std::move(orbProperties);
	Parms.isLargeOrb = isLargeOrb;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

