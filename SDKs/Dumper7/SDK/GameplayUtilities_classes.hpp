#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameplayUtilities

#include "Basic.hpp"

#include "CoreUtilities_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayUtilities_structs.hpp"
#include "Activation_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class GameplayUtilities.MockPoolableActor
// 0x0008 (0x0238 - 0x0230)
class AMockPoolableActor final : public AActor
{
public:
	class UPoolableActorComponent*                _poolable;                                         // 0x0230(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MockPoolableActor">();
	}
	static class AMockPoolableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMockPoolableActor>();
	}
};
static_assert(alignof(AMockPoolableActor) == 0x000008, "Wrong alignment on AMockPoolableActor");
static_assert(sizeof(AMockPoolableActor) == 0x000238, "Wrong size on AMockPoolableActor");
static_assert(offsetof(AMockPoolableActor, _poolable) == 0x000230, "Member 'AMockPoolableActor::_poolable' has a wrong offset!");

// Class GameplayUtilities.BaseCharacterRotationStrategy
// 0x0000 (0x00B8 - 0x00B8)
class UBaseCharacterRotationStrategy : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCharacterRotationStrategy">();
	}
	static class UBaseCharacterRotationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCharacterRotationStrategy>();
	}
};
static_assert(alignof(UBaseCharacterRotationStrategy) == 0x000008, "Wrong alignment on UBaseCharacterRotationStrategy");
static_assert(sizeof(UBaseCharacterRotationStrategy) == 0x0000B8, "Wrong size on UBaseCharacterRotationStrategy");

// Class GameplayUtilities.CharacterPusherComponent
// 0x00B8 (0x0170 - 0x00B8)
class UCharacterPusherComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACharacter*>                     _charactersToPush;                                 // 0x00E8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSet<class ACharacter*>                       _ignoredCharacters;                                // 0x00F8(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      _characterDetector;                                // 0x0148(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      _characterCollision;                               // 0x0150(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBasePushStrategyComponent*             _pushStrategy;                                     // 0x0158(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACharacter*>                     _ignoredByPushedCharacters;                        // 0x0160(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void Construct(class UCapsuleComponent* characterDetector, class UCapsuleComponent* characterCollision, class UBasePushStrategyComponent* pushStrategy);
	void OnCharacterDetectorOverlapExit(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex);
	void SetIgnoredCharacter(class ACharacter* character, const bool ignore);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPusherComponent">();
	}
	static class UCharacterPusherComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPusherComponent>();
	}
};
static_assert(alignof(UCharacterPusherComponent) == 0x000008, "Wrong alignment on UCharacterPusherComponent");
static_assert(sizeof(UCharacterPusherComponent) == 0x000170, "Wrong size on UCharacterPusherComponent");
static_assert(offsetof(UCharacterPusherComponent, _charactersToPush) == 0x0000E8, "Member 'UCharacterPusherComponent::_charactersToPush' has a wrong offset!");
static_assert(offsetof(UCharacterPusherComponent, _ignoredCharacters) == 0x0000F8, "Member 'UCharacterPusherComponent::_ignoredCharacters' has a wrong offset!");
static_assert(offsetof(UCharacterPusherComponent, _characterDetector) == 0x000148, "Member 'UCharacterPusherComponent::_characterDetector' has a wrong offset!");
static_assert(offsetof(UCharacterPusherComponent, _characterCollision) == 0x000150, "Member 'UCharacterPusherComponent::_characterCollision' has a wrong offset!");
static_assert(offsetof(UCharacterPusherComponent, _pushStrategy) == 0x000158, "Member 'UCharacterPusherComponent::_pushStrategy' has a wrong offset!");
static_assert(offsetof(UCharacterPusherComponent, _ignoredByPushedCharacters) == 0x000160, "Member 'UCharacterPusherComponent::_ignoredByPushedCharacters' has a wrong offset!");

// Class GameplayUtilities.BasePoolableActorComponent
// 0x0018 (0x00D0 - 0x00B8)
class UBasePoolableActorComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const bool acquired)> OnAcquiredChanged;                           // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void SetAcquired(bool active);

	bool IsAcquired() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePoolableActorComponent">();
	}
	static class UBasePoolableActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePoolableActorComponent>();
	}
};
static_assert(alignof(UBasePoolableActorComponent) == 0x000008, "Wrong alignment on UBasePoolableActorComponent");
static_assert(sizeof(UBasePoolableActorComponent) == 0x0000D0, "Wrong size on UBasePoolableActorComponent");
static_assert(offsetof(UBasePoolableActorComponent, OnAcquiredChanged) == 0x0000C0, "Member 'UBasePoolableActorComponent::OnAcquiredChanged' has a wrong offset!");

// Class GameplayUtilities.AuthoritativePoolableActorComponent
// 0x0008 (0x00D8 - 0x00D0)
class UAuthoritativePoolableActorComponent : public UBasePoolableActorComponent
{
public:
	bool                                          _acquired;                                         // 0x00D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Acquired();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthoritativePoolableActorComponent">();
	}
	static class UAuthoritativePoolableActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthoritativePoolableActorComponent>();
	}
};
static_assert(alignof(UAuthoritativePoolableActorComponent) == 0x000008, "Wrong alignment on UAuthoritativePoolableActorComponent");
static_assert(sizeof(UAuthoritativePoolableActorComponent) == 0x0000D8, "Wrong size on UAuthoritativePoolableActorComponent");
static_assert(offsetof(UAuthoritativePoolableActorComponent, _acquired) == 0x0000D0, "Member 'UAuthoritativePoolableActorComponent::_acquired' has a wrong offset!");

// Class GameplayUtilities.AuthoritativeActorPoolComponent
// 0x0038 (0x00F0 - 0x00B8)
class UAuthoritativeActorPoolComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     _actorClass;                                       // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _size;                                             // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _pool;                                             // 0x00E0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)

public:
	void Authority_OnActorDestroyed(class AActor* destroyedActor);
	void OnRep_Pool(const TArray<class AActor*>& previousPool);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthoritativeActorPoolComponent">();
	}
	static class UAuthoritativeActorPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthoritativeActorPoolComponent>();
	}
};
static_assert(alignof(UAuthoritativeActorPoolComponent) == 0x000008, "Wrong alignment on UAuthoritativeActorPoolComponent");
static_assert(sizeof(UAuthoritativeActorPoolComponent) == 0x0000F0, "Wrong size on UAuthoritativeActorPoolComponent");
static_assert(offsetof(UAuthoritativeActorPoolComponent, _actorClass) == 0x0000D0, "Member 'UAuthoritativeActorPoolComponent::_actorClass' has a wrong offset!");
static_assert(offsetof(UAuthoritativeActorPoolComponent, _size) == 0x0000D8, "Member 'UAuthoritativeActorPoolComponent::_size' has a wrong offset!");
static_assert(offsetof(UAuthoritativeActorPoolComponent, _pool) == 0x0000E0, "Member 'UAuthoritativeActorPoolComponent::_pool' has a wrong offset!");

// Class GameplayUtilities.BaseInputAccelerationConstraintStrategy
// 0x0000 (0x00B8 - 0x00B8)
class UBaseInputAccelerationConstraintStrategy : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseInputAccelerationConstraintStrategy">();
	}
	static class UBaseInputAccelerationConstraintStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseInputAccelerationConstraintStrategy>();
	}
};
static_assert(alignof(UBaseInputAccelerationConstraintStrategy) == 0x000008, "Wrong alignment on UBaseInputAccelerationConstraintStrategy");
static_assert(sizeof(UBaseInputAccelerationConstraintStrategy) == 0x0000B8, "Wrong size on UBaseInputAccelerationConstraintStrategy");

// Class GameplayUtilities.BasePushStrategyComponent
// 0x0000 (0x00B8 - 0x00B8)
class UBasePushStrategyComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePushStrategyComponent">();
	}
	static class UBasePushStrategyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePushStrategyComponent>();
	}
};
static_assert(alignof(UBasePushStrategyComponent) == 0x000008, "Wrong alignment on UBasePushStrategyComponent");
static_assert(sizeof(UBasePushStrategyComponent) == 0x0000B8, "Wrong size on UBasePushStrategyComponent");

// Class GameplayUtilities.BaseCharacterVelocityAdditiveStrategy
// 0x0000 (0x00B8 - 0x00B8)
class UBaseCharacterVelocityAdditiveStrategy : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCharacterVelocityAdditiveStrategy">();
	}
	static class UBaseCharacterVelocityAdditiveStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCharacterVelocityAdditiveStrategy>();
	}
};
static_assert(alignof(UBaseCharacterVelocityAdditiveStrategy) == 0x000008, "Wrong alignment on UBaseCharacterVelocityAdditiveStrategy");
static_assert(sizeof(UBaseCharacterVelocityAdditiveStrategy) == 0x0000B8, "Wrong size on UBaseCharacterVelocityAdditiveStrategy");

// Class GameplayUtilities.BoxOcclusionQueryComponent
// 0x0010 (0x04C0 - 0x04B0)
class UBoxOcclusionQueryComponent final : public UBoxComponent
{
public:
	float                                         TimeUntilOccluded;                                 // 0x04A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4AC[0x14];                                     // 0x04AC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetEstimatedRenderedPixelCount() const;
	float GetNumberOfVisiblePixels() const;
	float GetVisiblePercentOfScreen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoxOcclusionQueryComponent">();
	}
	static class UBoxOcclusionQueryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoxOcclusionQueryComponent>();
	}
};
static_assert(alignof(UBoxOcclusionQueryComponent) == 0x000010, "Wrong alignment on UBoxOcclusionQueryComponent");
static_assert(sizeof(UBoxOcclusionQueryComponent) == 0x0004C0, "Wrong size on UBoxOcclusionQueryComponent");
static_assert(offsetof(UBoxOcclusionQueryComponent, TimeUntilOccluded) == 0x0004A8, "Member 'UBoxOcclusionQueryComponent::TimeUntilOccluded' has a wrong offset!");

// Class GameplayUtilities.CameraUtilities
// 0x0000 (0x0030 - 0x0030)
class UCameraUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraUtilities">();
	}
	static class UCameraUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraUtilities>();
	}
};
static_assert(alignof(UCameraUtilities) == 0x000008, "Wrong alignment on UCameraUtilities");
static_assert(sizeof(UCameraUtilities) == 0x000030, "Wrong size on UCameraUtilities");

// Class GameplayUtilities.CharacterPositionRecorderComponent
// 0x0020 (0x00D8 - 0x00B8)
class UCharacterPositionRecorderComponent final : public UActorComponent
{
public:
	float                                         _cacheTimespan;                                    // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x1C];                                      // 0x00BC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPositionRecorderComponent">();
	}
	static class UCharacterPositionRecorderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPositionRecorderComponent>();
	}
};
static_assert(alignof(UCharacterPositionRecorderComponent) == 0x000008, "Wrong alignment on UCharacterPositionRecorderComponent");
static_assert(sizeof(UCharacterPositionRecorderComponent) == 0x0000D8, "Wrong size on UCharacterPositionRecorderComponent");
static_assert(offsetof(UCharacterPositionRecorderComponent, _cacheTimespan) == 0x0000B8, "Member 'UCharacterPositionRecorderComponent::_cacheTimespan' has a wrong offset!");

// Class GameplayUtilities.CharacterSightableComponent
// 0x00E8 (0x01A0 - 0x00B8)
class UCharacterSightableComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x30];                                      // 0x00B8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(ESightStatus status)> OnHighestSightStatusChangedBP;               // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<TWeakObjectPtr<class ACharacter>, struct FDelegateHandleWrapper> _sightDelegateHandles;     // 0x00F8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class ACharacter>, ESightStatus> _sightersStatus;                            // 0x0148(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x8];                                      // 0x0198(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	ESightStatus GetHighestSightStatus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSightableComponent">();
	}
	static class UCharacterSightableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSightableComponent>();
	}
};
static_assert(alignof(UCharacterSightableComponent) == 0x000008, "Wrong alignment on UCharacterSightableComponent");
static_assert(sizeof(UCharacterSightableComponent) == 0x0001A0, "Wrong size on UCharacterSightableComponent");
static_assert(offsetof(UCharacterSightableComponent, OnHighestSightStatusChangedBP) == 0x0000E8, "Member 'UCharacterSightableComponent::OnHighestSightStatusChangedBP' has a wrong offset!");
static_assert(offsetof(UCharacterSightableComponent, _sightDelegateHandles) == 0x0000F8, "Member 'UCharacterSightableComponent::_sightDelegateHandles' has a wrong offset!");
static_assert(offsetof(UCharacterSightableComponent, _sightersStatus) == 0x000148, "Member 'UCharacterSightableComponent::_sightersStatus' has a wrong offset!");

// Class GameplayUtilities.CharacterSightComponent
// 0x00D8 (0x0190 - 0x00B8)
class UCharacterSightComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x38];                                      // 0x00B8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _minimumCharacterScreenPercentInZoneTrigger;       // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumCharacterScreenPercentInZoneUntrigger;     // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumCharacterScreenPercentNotInZoneTrigger;    // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumCharacterScreenPercentNotInZoneUntrigger;  // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumCharacterVisiblePixelsPercentTrigger;      // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minimumCharacterVisiblePixelsPercentUntrigger;    // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _maximumSightDistance;                             // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _screenVisibilityZoneRadiusPercentX;               // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _screenVisibilityZoneRadiusPercentY;               // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _sightingDelay;                                    // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _discerningDelay;                                  // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _undiscerningDelay;                                // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACharacter>                 _sightableCharacterClass;                          // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FAuthorityDiscernedCharacter>   _discernedCharacters;                              // 0x0128(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FDiscernibleCharacter>          _localDiscernibleCharacters;                       // 0x0138(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x10];                                     // 0x0148(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _debugMode;                                        // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _canSee;                                           // 0x0159(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15A[0x6];                                      // 0x015A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FActivationDefinition                  _activationDefinition;                             // 0x0160(0x0028)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_188[0x8];                                      // 0x0188(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CanSee();
	void OnRep_DiscernibleCharacters();
	void Server_UpdateDiscernedCharacters(const TArray<class ACharacter*>& characters);
	void SetMaximumSightDistance(float value);
	void SetMinimumCharacterScreenPercentInZone(float trigger, float untrigger);
	void SetMinimumCharacterScreenPercentNotInZone(float trigger, float untrigger);
	void SetMinimumCharacterVisiblePixelsPercent(float trigger, float untrigger);
	void SetScreenVisibilityZoneRadiusPercent(float valueX, float valueY);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSightComponent">();
	}
	static class UCharacterSightComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSightComponent>();
	}
};
static_assert(alignof(UCharacterSightComponent) == 0x000008, "Wrong alignment on UCharacterSightComponent");
static_assert(sizeof(UCharacterSightComponent) == 0x000190, "Wrong size on UCharacterSightComponent");
static_assert(offsetof(UCharacterSightComponent, _minimumCharacterScreenPercentInZoneTrigger) == 0x0000F0, "Member 'UCharacterSightComponent::_minimumCharacterScreenPercentInZoneTrigger' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _minimumCharacterScreenPercentInZoneUntrigger) == 0x0000F4, "Member 'UCharacterSightComponent::_minimumCharacterScreenPercentInZoneUntrigger' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _minimumCharacterScreenPercentNotInZoneTrigger) == 0x0000F8, "Member 'UCharacterSightComponent::_minimumCharacterScreenPercentNotInZoneTrigger' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _minimumCharacterScreenPercentNotInZoneUntrigger) == 0x0000FC, "Member 'UCharacterSightComponent::_minimumCharacterScreenPercentNotInZoneUntrigger' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _minimumCharacterVisiblePixelsPercentTrigger) == 0x000100, "Member 'UCharacterSightComponent::_minimumCharacterVisiblePixelsPercentTrigger' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _minimumCharacterVisiblePixelsPercentUntrigger) == 0x000104, "Member 'UCharacterSightComponent::_minimumCharacterVisiblePixelsPercentUntrigger' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _maximumSightDistance) == 0x000108, "Member 'UCharacterSightComponent::_maximumSightDistance' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _screenVisibilityZoneRadiusPercentX) == 0x00010C, "Member 'UCharacterSightComponent::_screenVisibilityZoneRadiusPercentX' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _screenVisibilityZoneRadiusPercentY) == 0x000110, "Member 'UCharacterSightComponent::_screenVisibilityZoneRadiusPercentY' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _sightingDelay) == 0x000114, "Member 'UCharacterSightComponent::_sightingDelay' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _discerningDelay) == 0x000118, "Member 'UCharacterSightComponent::_discerningDelay' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _undiscerningDelay) == 0x00011C, "Member 'UCharacterSightComponent::_undiscerningDelay' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _sightableCharacterClass) == 0x000120, "Member 'UCharacterSightComponent::_sightableCharacterClass' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _discernedCharacters) == 0x000128, "Member 'UCharacterSightComponent::_discernedCharacters' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _localDiscernibleCharacters) == 0x000138, "Member 'UCharacterSightComponent::_localDiscernibleCharacters' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _debugMode) == 0x000158, "Member 'UCharacterSightComponent::_debugMode' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _canSee) == 0x000159, "Member 'UCharacterSightComponent::_canSee' has a wrong offset!");
static_assert(offsetof(UCharacterSightComponent, _activationDefinition) == 0x000160, "Member 'UCharacterSightComponent::_activationDefinition' has a wrong offset!");

// Class GameplayUtilities.ChargeableUtilities
// 0x0000 (0x0030 - 0x0030)
class UChargeableUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float ConvertSecondsToAddToRateMultiplier(float secondsToAdd, float baseMaxSeconds, float baseRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeableUtilities">();
	}
	static class UChargeableUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeableUtilities>();
	}
};
static_assert(alignof(UChargeableUtilities) == 0x000008, "Wrong alignment on UChargeableUtilities");
static_assert(sizeof(UChargeableUtilities) == 0x000030, "Wrong size on UChargeableUtilities");

// Class GameplayUtilities.CollectedObjectCollection
// 0x00A0 (0x0158 - 0x00B8)
class UCollectedObjectCollection final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xA0];                                      // 0x00B8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectedObjectCollection">();
	}
	static class UCollectedObjectCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectedObjectCollection>();
	}
};
static_assert(alignof(UCollectedObjectCollection) == 0x000008, "Wrong alignment on UCollectedObjectCollection");
static_assert(sizeof(UCollectedObjectCollection) == 0x000158, "Wrong size on UCollectedObjectCollection");

// Class GameplayUtilities.ContainerUtilities
// 0x0000 (0x0030 - 0x0030)
class UContainerUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContainerUtilities">();
	}
	static class UContainerUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContainerUtilities>();
	}
};
static_assert(alignof(UContainerUtilities) == 0x000008, "Wrong alignment on UContainerUtilities");
static_assert(sizeof(UContainerUtilities) == 0x000030, "Wrong size on UContainerUtilities");

// Class GameplayUtilities.PoolableActor
// 0x0000 (0x0000 - 0x0000)
class IPoolableActor final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolableActor">();
	}
	static class IPoolableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPoolableActor>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPoolableActor) == 0x000001, "Wrong alignment on IPoolableActor");
static_assert(sizeof(IPoolableActor) == 0x000001, "Wrong size on IPoolableActor");

// Class GameplayUtilities.PotentialAttack
// 0x0000 (0x0000 - 0x0000)
class IPotentialAttack final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PotentialAttack">();
	}
	static class IPotentialAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPotentialAttack>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IPotentialAttack) == 0x000001, "Wrong alignment on IPotentialAttack");
static_assert(sizeof(IPotentialAttack) == 0x000001, "Wrong size on IPotentialAttack");

// Class GameplayUtilities.IsLookingTowardsQueryComponent
// 0x0010 (0x00C8 - 0x00B8)
class UIsLookingTowardsQueryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsLookingTowardsQueryComponent">();
	}
	static class UIsLookingTowardsQueryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsLookingTowardsQueryComponent>();
	}
};
static_assert(alignof(UIsLookingTowardsQueryComponent) == 0x000008, "Wrong alignment on UIsLookingTowardsQueryComponent");
static_assert(sizeof(UIsLookingTowardsQueryComponent) == 0x0000C8, "Wrong size on UIsLookingTowardsQueryComponent");

// Class GameplayUtilities.MockAuthoritativeActorPoolComponent
// 0x0000 (0x00F0 - 0x00F0)
class UMockAuthoritativeActorPoolComponent final : public UAuthoritativeActorPoolComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MockAuthoritativeActorPoolComponent">();
	}
	static class UMockAuthoritativeActorPoolComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMockAuthoritativeActorPoolComponent>();
	}
};
static_assert(alignof(UMockAuthoritativeActorPoolComponent) == 0x000008, "Wrong alignment on UMockAuthoritativeActorPoolComponent");
static_assert(sizeof(UMockAuthoritativeActorPoolComponent) == 0x0000F0, "Wrong size on UMockAuthoritativeActorPoolComponent");

// Class GameplayUtilities.MovableCamera
// 0x0028 (0x02C0 - 0x0298)
class AMovableCamera final : public APawn
{
public:
	float                                         MovementSpeed;                                     // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RequiresShiftModifierForInput;                     // 0x029C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29D[0x1B];                                     // 0x029D(0x001B)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      _playerController;                                 // 0x02B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovableCamera">();
	}
	static class AMovableCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMovableCamera>();
	}
};
static_assert(alignof(AMovableCamera) == 0x000008, "Wrong alignment on AMovableCamera");
static_assert(sizeof(AMovableCamera) == 0x0002C0, "Wrong size on AMovableCamera");
static_assert(offsetof(AMovableCamera, MovementSpeed) == 0x000298, "Member 'AMovableCamera::MovementSpeed' has a wrong offset!");
static_assert(offsetof(AMovableCamera, RequiresShiftModifierForInput) == 0x00029C, "Member 'AMovableCamera::RequiresShiftModifierForInput' has a wrong offset!");
static_assert(offsetof(AMovableCamera, _playerController) == 0x0002B8, "Member 'AMovableCamera::_playerController' has a wrong offset!");

// Class GameplayUtilities.MoveActorToComponent
// 0x0038 (0x00F0 - 0x00B8)
class UMoveActorToComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x38];                                      // 0x00B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveActorToComponent">();
	}
	static class UMoveActorToComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveActorToComponent>();
	}
};
static_assert(alignof(UMoveActorToComponent) == 0x000008, "Wrong alignment on UMoveActorToComponent");
static_assert(sizeof(UMoveActorToComponent) == 0x0000F0, "Wrong size on UMoveActorToComponent");

// Class GameplayUtilities.MovementUtilities
// 0x0000 (0x0030 - 0x0030)
class UMovementUtilities final : public UBlueprintFunctionLibrary
{
public:
	static void Local_MoveActorTo(class AActor* actor, const struct FVector& location, const struct FRotator& rotation, const float duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementUtilities">();
	}
	static class UMovementUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementUtilities>();
	}
};
static_assert(alignof(UMovementUtilities) == 0x000008, "Wrong alignment on UMovementUtilities");
static_assert(sizeof(UMovementUtilities) == 0x000030, "Wrong size on UMovementUtilities");

// Class GameplayUtilities.PawnUtilities
// 0x0000 (0x0030 - 0x0030)
class UPawnUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class APawn* GetLocallyObservedPawn(const class UObject* worldContext);
	static class APawn* GetOwningPawn(const class AActor* origin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PawnUtilities">();
	}
	static class UPawnUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPawnUtilities>();
	}
};
static_assert(alignof(UPawnUtilities) == 0x000008, "Wrong alignment on UPawnUtilities");
static_assert(sizeof(UPawnUtilities) == 0x000030, "Wrong size on UPawnUtilities");

// Class GameplayUtilities.PlayerStateExt
// 0x0000 (0x0030 - 0x0030)
class UPlayerStateExt final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateExt">();
	}
	static class UPlayerStateExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStateExt>();
	}
};
static_assert(alignof(UPlayerStateExt) == 0x000008, "Wrong alignment on UPlayerStateExt");
static_assert(sizeof(UPlayerStateExt) == 0x000030, "Wrong size on UPlayerStateExt");

// Class GameplayUtilities.PoolableActorComponent
// 0x0008 (0x00D8 - 0x00D0)
class UPoolableActorComponent final : public UBasePoolableActorComponent
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolableActorComponent">();
	}
	static class UPoolableActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoolableActorComponent>();
	}
};
static_assert(alignof(UPoolableActorComponent) == 0x000008, "Wrong alignment on UPoolableActorComponent");
static_assert(sizeof(UPoolableActorComponent) == 0x0000D8, "Wrong size on UPoolableActorComponent");

// Class GameplayUtilities.SceneComponentExt
// 0x0000 (0x0030 - 0x0030)
class USceneComponentExt final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneComponentExt">();
	}
	static class USceneComponentExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneComponentExt>();
	}
};
static_assert(alignof(USceneComponentExt) == 0x000008, "Wrong alignment on USceneComponentExt");
static_assert(sizeof(USceneComponentExt) == 0x000030, "Wrong size on USceneComponentExt");

// Class GameplayUtilities.SidePushStrategyComponent
// 0x0010 (0x00C8 - 0x00B8)
class USidePushStrategyComponent final : public UBasePushStrategyComponent
{
public:
	float                                         _maxImpulseStrength;                               // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _minImpulseStrength;                               // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _detectorCapsuleInflation;                         // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SidePushStrategyComponent">();
	}
	static class USidePushStrategyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USidePushStrategyComponent>();
	}
};
static_assert(alignof(USidePushStrategyComponent) == 0x000008, "Wrong alignment on USidePushStrategyComponent");
static_assert(sizeof(USidePushStrategyComponent) == 0x0000C8, "Wrong size on USidePushStrategyComponent");
static_assert(offsetof(USidePushStrategyComponent, _maxImpulseStrength) == 0x0000B8, "Member 'USidePushStrategyComponent::_maxImpulseStrength' has a wrong offset!");
static_assert(offsetof(USidePushStrategyComponent, _minImpulseStrength) == 0x0000BC, "Member 'USidePushStrategyComponent::_minImpulseStrength' has a wrong offset!");
static_assert(offsetof(USidePushStrategyComponent, _detectorCapsuleInflation) == 0x0000C0, "Member 'USidePushStrategyComponent::_detectorCapsuleInflation' has a wrong offset!");

// Class GameplayUtilities.VisualLoggerExt
// 0x0000 (0x0030 - 0x0030)
class UVisualLoggerExt final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VisualLoggerExt">();
	}
	static class UVisualLoggerExt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVisualLoggerExt>();
	}
};
static_assert(alignof(UVisualLoggerExt) == 0x000008, "Wrong alignment on UVisualLoggerExt");
static_assert(sizeof(UVisualLoggerExt) == 0x000030, "Wrong size on UVisualLoggerExt");

}

