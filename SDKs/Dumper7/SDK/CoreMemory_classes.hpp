#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CoreMemory

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreMemory_structs.hpp"
#include "DeadByDaylight_classes.hpp"


namespace SDK
{

// Class CoreMemory.CoreMemoryBehaviourBase
// 0x0000 (0x0030 - 0x0030)
class UCoreMemoryBehaviourBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryBehaviourBase">();
	}
	static class UCoreMemoryBehaviourBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryBehaviourBase>();
	}
};
static_assert(alignof(UCoreMemoryBehaviourBase) == 0x000008, "Wrong alignment on UCoreMemoryBehaviourBase");
static_assert(sizeof(UCoreMemoryBehaviourBase) == 0x000030, "Wrong size on UCoreMemoryBehaviourBase");

// Class CoreMemory.CoreMemoryChallengePlayerSpecificController
// 0x00A8 (0x02D8 - 0x0230)
class ACoreMemoryChallengePlayerSpecificController final : public AInfo
{
public:
	uint8                                         Pad_230[0x78];                                     // 0x0230(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _owningPlayer;                                     // 0x02A8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCoreMemoryController*                  _controller;                                       // 0x02B0(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UCoreMemoryFragmentComponent*>   _fragments;                                        // 0x02B8(0x0010)(ExportObject, Net, ZeroConstructor, Transient, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	int32                                         _numFragmentsToCollect;                            // 0x02C8(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CC[0xC];                                      // 0x02CC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Controller();
	void OnRep_Fragments();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryChallengePlayerSpecificController">();
	}
	static class ACoreMemoryChallengePlayerSpecificController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoreMemoryChallengePlayerSpecificController>();
	}
};
static_assert(alignof(ACoreMemoryChallengePlayerSpecificController) == 0x000008, "Wrong alignment on ACoreMemoryChallengePlayerSpecificController");
static_assert(sizeof(ACoreMemoryChallengePlayerSpecificController) == 0x0002D8, "Wrong size on ACoreMemoryChallengePlayerSpecificController");
static_assert(offsetof(ACoreMemoryChallengePlayerSpecificController, _owningPlayer) == 0x0002A8, "Member 'ACoreMemoryChallengePlayerSpecificController::_owningPlayer' has a wrong offset!");
static_assert(offsetof(ACoreMemoryChallengePlayerSpecificController, _controller) == 0x0002B0, "Member 'ACoreMemoryChallengePlayerSpecificController::_controller' has a wrong offset!");
static_assert(offsetof(ACoreMemoryChallengePlayerSpecificController, _fragments) == 0x0002B8, "Member 'ACoreMemoryChallengePlayerSpecificController::_fragments' has a wrong offset!");
static_assert(offsetof(ACoreMemoryChallengePlayerSpecificController, _numFragmentsToCollect) == 0x0002C8, "Member 'ACoreMemoryChallengePlayerSpecificController::_numFragmentsToCollect' has a wrong offset!");

// Class CoreMemory.CoreMemoryController
// 0x0040 (0x00F8 - 0x00B8)
class UCoreMemoryController final : public UActorComponent
{
public:
	TArray<class UCoreMemoryBehaviourBase*>       _behaviours;                                       // 0x00B8(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class ACoreMemoryChallengePlayerSpecificController*> _playerSpecificControllers;          // 0x00C8(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _archiveSpecialBehaviourId;                        // 0x00E0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _coreMemorySpecialBehaviourKey;                    // 0x00EC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_CreatePlayerSpecificController(class ADBDPlayer* player);
	void Authority_OnCharacterAdded(class ADBDPlayer* player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryController">();
	}
	static class UCoreMemoryController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryController>();
	}
};
static_assert(alignof(UCoreMemoryController) == 0x000008, "Wrong alignment on UCoreMemoryController");
static_assert(sizeof(UCoreMemoryController) == 0x0000F8, "Wrong size on UCoreMemoryController");
static_assert(offsetof(UCoreMemoryController, _behaviours) == 0x0000B8, "Member 'UCoreMemoryController::_behaviours' has a wrong offset!");
static_assert(offsetof(UCoreMemoryController, _playerSpecificControllers) == 0x0000C8, "Member 'UCoreMemoryController::_playerSpecificControllers' has a wrong offset!");
static_assert(offsetof(UCoreMemoryController, _archiveSpecialBehaviourId) == 0x0000E0, "Member 'UCoreMemoryController::_archiveSpecialBehaviourId' has a wrong offset!");
static_assert(offsetof(UCoreMemoryController, _coreMemorySpecialBehaviourKey) == 0x0000EC, "Member 'UCoreMemoryController::_coreMemorySpecialBehaviourKey' has a wrong offset!");

// Class CoreMemory.CoreMemoryDebugSpawnBehaviour
// 0x0010 (0x0040 - 0x0030)
class UCoreMemoryDebugSpawnBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	TSubclassOf<class ACoreMemoryFragment>        _fragmentClass;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _numberOfFragmentsToSpawn;                         // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _fragmentSpawnOffset;                              // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryDebugSpawnBehaviour">();
	}
	static class UCoreMemoryDebugSpawnBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryDebugSpawnBehaviour>();
	}
};
static_assert(alignof(UCoreMemoryDebugSpawnBehaviour) == 0x000008, "Wrong alignment on UCoreMemoryDebugSpawnBehaviour");
static_assert(sizeof(UCoreMemoryDebugSpawnBehaviour) == 0x000040, "Wrong size on UCoreMemoryDebugSpawnBehaviour");
static_assert(offsetof(UCoreMemoryDebugSpawnBehaviour, _fragmentClass) == 0x000030, "Member 'UCoreMemoryDebugSpawnBehaviour::_fragmentClass' has a wrong offset!");
static_assert(offsetof(UCoreMemoryDebugSpawnBehaviour, _numberOfFragmentsToSpawn) == 0x000038, "Member 'UCoreMemoryDebugSpawnBehaviour::_numberOfFragmentsToSpawn' has a wrong offset!");
static_assert(offsetof(UCoreMemoryDebugSpawnBehaviour, _fragmentSpawnOffset) == 0x00003C, "Member 'UCoreMemoryDebugSpawnBehaviour::_fragmentSpawnOffset' has a wrong offset!");

// Class CoreMemory.CoreMemoryDefaultQuestProgressBehaviour
// 0x0048 (0x0078 - 0x0030)
class UCoreMemoryDefaultQuestProgressBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	struct FGameplayTag                           _onCamperEscapeScoreTag;                           // 0x0030(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _onFragmentCollectedScoreTag;                      // 0x003C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _onMemoryAcquiredScoreTag;                         // 0x0048(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _onMemorySynchronizedScoreTag;                     // 0x0054(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x18];                                      // 0x0060(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryDefaultQuestProgressBehaviour">();
	}
	static class UCoreMemoryDefaultQuestProgressBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryDefaultQuestProgressBehaviour>();
	}
};
static_assert(alignof(UCoreMemoryDefaultQuestProgressBehaviour) == 0x000008, "Wrong alignment on UCoreMemoryDefaultQuestProgressBehaviour");
static_assert(sizeof(UCoreMemoryDefaultQuestProgressBehaviour) == 0x000078, "Wrong size on UCoreMemoryDefaultQuestProgressBehaviour");
static_assert(offsetof(UCoreMemoryDefaultQuestProgressBehaviour, _onCamperEscapeScoreTag) == 0x000030, "Member 'UCoreMemoryDefaultQuestProgressBehaviour::_onCamperEscapeScoreTag' has a wrong offset!");
static_assert(offsetof(UCoreMemoryDefaultQuestProgressBehaviour, _onFragmentCollectedScoreTag) == 0x00003C, "Member 'UCoreMemoryDefaultQuestProgressBehaviour::_onFragmentCollectedScoreTag' has a wrong offset!");
static_assert(offsetof(UCoreMemoryDefaultQuestProgressBehaviour, _onMemoryAcquiredScoreTag) == 0x000048, "Member 'UCoreMemoryDefaultQuestProgressBehaviour::_onMemoryAcquiredScoreTag' has a wrong offset!");
static_assert(offsetof(UCoreMemoryDefaultQuestProgressBehaviour, _onMemorySynchronizedScoreTag) == 0x000054, "Member 'UCoreMemoryDefaultQuestProgressBehaviour::_onMemorySynchronizedScoreTag' has a wrong offset!");

// Class CoreMemory.CoreMemoryFragment
// 0x00B8 (0x02E8 - 0x0230)
class ACoreMemoryFragment final : public AActor
{
public:
	class UStaticMeshComponent*                   _coreMemoryFragmentStaticMesh;                     // 0x0230(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCoreMemoryFragmentComponent*           _coreMemoryFragmentComponent;                      // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCoreMemoryFragmentFXComponent*         _coreMemoryFragmentFXComponent;                    // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _coreMemoryFragmentTriggerZone;                    // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       _coreMemoryFragmentCollectionZone;                 // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                _spawnLocation;                                    // 0x0258(0x000C)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _heightOffset;                                     // 0x0268(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _triggerZoneRadius;                                // 0x0290(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _collectionZoneRadius;                             // 0x02B8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocallyObservedChanged(bool isLocallyObserved);
	void OnRep_SpawnLocation(const struct FVector& location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragment">();
	}
	static class ACoreMemoryFragment* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoreMemoryFragment>();
	}
};
static_assert(alignof(ACoreMemoryFragment) == 0x000008, "Wrong alignment on ACoreMemoryFragment");
static_assert(sizeof(ACoreMemoryFragment) == 0x0002E8, "Wrong size on ACoreMemoryFragment");
static_assert(offsetof(ACoreMemoryFragment, _coreMemoryFragmentStaticMesh) == 0x000230, "Member 'ACoreMemoryFragment::_coreMemoryFragmentStaticMesh' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _coreMemoryFragmentComponent) == 0x000238, "Member 'ACoreMemoryFragment::_coreMemoryFragmentComponent' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _coreMemoryFragmentFXComponent) == 0x000240, "Member 'ACoreMemoryFragment::_coreMemoryFragmentFXComponent' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _coreMemoryFragmentTriggerZone) == 0x000248, "Member 'ACoreMemoryFragment::_coreMemoryFragmentTriggerZone' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _coreMemoryFragmentCollectionZone) == 0x000250, "Member 'ACoreMemoryFragment::_coreMemoryFragmentCollectionZone' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _spawnLocation) == 0x000258, "Member 'ACoreMemoryFragment::_spawnLocation' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _heightOffset) == 0x000268, "Member 'ACoreMemoryFragment::_heightOffset' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _triggerZoneRadius) == 0x000290, "Member 'ACoreMemoryFragment::_triggerZoneRadius' has a wrong offset!");
static_assert(offsetof(ACoreMemoryFragment, _collectionZoneRadius) == 0x0002B8, "Member 'ACoreMemoryFragment::_collectionZoneRadius' has a wrong offset!");

// Class CoreMemory.CoreMemoryFragmentComponent
// 0x0070 (0x0128 - 0x00B8)
class UCoreMemoryFragmentComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x60];                                      // 0x00B8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class ADBDPlayer*                             _owner;                                            // 0x0118(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ACoreMemoryChallengePlayerSpecificController* _controller;                                 // 0x0120(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCollectZoneEntered(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult);
	void OnTriggerZoneEntered(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragmentComponent">();
	}
	static class UCoreMemoryFragmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryFragmentComponent>();
	}
};
static_assert(alignof(UCoreMemoryFragmentComponent) == 0x000008, "Wrong alignment on UCoreMemoryFragmentComponent");
static_assert(sizeof(UCoreMemoryFragmentComponent) == 0x000128, "Wrong size on UCoreMemoryFragmentComponent");
static_assert(offsetof(UCoreMemoryFragmentComponent, _owner) == 0x000118, "Member 'UCoreMemoryFragmentComponent::_owner' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentComponent, _controller) == 0x000120, "Member 'UCoreMemoryFragmentComponent::_controller' has a wrong offset!");

// Class CoreMemory.CoreMemoryFragmentFXComponent
// 0x0040 (0x00F8 - 0x00B8)
class UCoreMemoryFragmentFXComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class ADBDPlayer* player)> Cosmetic_FragmentTriggered;             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* player, float percentProgress)> Cosmetic_FragmentCollected; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              Cosmetic_FragmentSpawned;                          // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              Cosmetic_FragmentDespawn;                          // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragmentFXComponent">();
	}
	static class UCoreMemoryFragmentFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryFragmentFXComponent>();
	}
};
static_assert(alignof(UCoreMemoryFragmentFXComponent) == 0x000008, "Wrong alignment on UCoreMemoryFragmentFXComponent");
static_assert(sizeof(UCoreMemoryFragmentFXComponent) == 0x0000F8, "Wrong size on UCoreMemoryFragmentFXComponent");
static_assert(offsetof(UCoreMemoryFragmentFXComponent, Cosmetic_FragmentTriggered) == 0x0000B8, "Member 'UCoreMemoryFragmentFXComponent::Cosmetic_FragmentTriggered' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentFXComponent, Cosmetic_FragmentCollected) == 0x0000C8, "Member 'UCoreMemoryFragmentFXComponent::Cosmetic_FragmentCollected' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentFXComponent, Cosmetic_FragmentSpawned) == 0x0000D8, "Member 'UCoreMemoryFragmentFXComponent::Cosmetic_FragmentSpawned' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentFXComponent, Cosmetic_FragmentDespawn) == 0x0000E8, "Member 'UCoreMemoryFragmentFXComponent::Cosmetic_FragmentDespawn' has a wrong offset!");

// Class CoreMemory.CoreMemoryFragmentSimpleMovementComponent
// 0x0040 (0x00F8 - 0x00B8)
class UCoreMemoryFragmentSimpleMovementComponent final : public UActorComponent
{
public:
	class FName                                   _characterBoneName;                                // 0x00B8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0xC];                                       // 0x00C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _fragmentMoveSpeed;                                // 0x00D0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryFragmentSimpleMovementComponent">();
	}
	static class UCoreMemoryFragmentSimpleMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryFragmentSimpleMovementComponent>();
	}
};
static_assert(alignof(UCoreMemoryFragmentSimpleMovementComponent) == 0x000008, "Wrong alignment on UCoreMemoryFragmentSimpleMovementComponent");
static_assert(sizeof(UCoreMemoryFragmentSimpleMovementComponent) == 0x0000F8, "Wrong size on UCoreMemoryFragmentSimpleMovementComponent");
static_assert(offsetof(UCoreMemoryFragmentSimpleMovementComponent, _characterBoneName) == 0x0000B8, "Member 'UCoreMemoryFragmentSimpleMovementComponent::_characterBoneName' has a wrong offset!");
static_assert(offsetof(UCoreMemoryFragmentSimpleMovementComponent, _fragmentMoveSpeed) == 0x0000D0, "Member 'UCoreMemoryFragmentSimpleMovementComponent::_fragmentMoveSpeed' has a wrong offset!");

// Class CoreMemory.CoreMemoryImposeStatusEffectBehaviour
// 0x0040 (0x0070 - 0x0030)
class UCoreMemoryImposeStatusEffectBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	struct FCoreMemoryStatusEffectDetails         _statusEffectToImposeOnFragmentCollected;          // 0x0030(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FCoreMemoryStatusEffectDetails         _statusEffectToImposeOnMemoryAcquired;             // 0x0040(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FCoreMemoryStatusEffectDetails         _statusEffectToImposeOnStartedSynchronizingMemory; // 0x0050(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FCoreMemoryStatusEffectDetails         _statusEffectToImposeOnMemorySynchronized;         // 0x0060(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryImposeStatusEffectBehaviour">();
	}
	static class UCoreMemoryImposeStatusEffectBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryImposeStatusEffectBehaviour>();
	}
};
static_assert(alignof(UCoreMemoryImposeStatusEffectBehaviour) == 0x000008, "Wrong alignment on UCoreMemoryImposeStatusEffectBehaviour");
static_assert(sizeof(UCoreMemoryImposeStatusEffectBehaviour) == 0x000070, "Wrong size on UCoreMemoryImposeStatusEffectBehaviour");
static_assert(offsetof(UCoreMemoryImposeStatusEffectBehaviour, _statusEffectToImposeOnFragmentCollected) == 0x000030, "Member 'UCoreMemoryImposeStatusEffectBehaviour::_statusEffectToImposeOnFragmentCollected' has a wrong offset!");
static_assert(offsetof(UCoreMemoryImposeStatusEffectBehaviour, _statusEffectToImposeOnMemoryAcquired) == 0x000040, "Member 'UCoreMemoryImposeStatusEffectBehaviour::_statusEffectToImposeOnMemoryAcquired' has a wrong offset!");
static_assert(offsetof(UCoreMemoryImposeStatusEffectBehaviour, _statusEffectToImposeOnStartedSynchronizingMemory) == 0x000050, "Member 'UCoreMemoryImposeStatusEffectBehaviour::_statusEffectToImposeOnStartedSynchronizingMemory' has a wrong offset!");
static_assert(offsetof(UCoreMemoryImposeStatusEffectBehaviour, _statusEffectToImposeOnMemorySynchronized) == 0x000060, "Member 'UCoreMemoryImposeStatusEffectBehaviour::_statusEffectToImposeOnMemorySynchronized' has a wrong offset!");

// Class CoreMemory.CoreMemoryPortal
// 0x00A0 (0x0408 - 0x0368)
class ACoreMemoryPortal final : public ASpecialBehaviourInteractable
{
public:
	class UStaticMeshComponent*                   _coreMemoryPortalStaticMesh;                       // 0x0368(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCoreMemoryController*                  _coreMemoryController;                             // 0x0370(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCoreMemoryPortalComponent*             _coreMemoryPortalComponent;                        // 0x0378(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCoreMemoryPortalFXComponent*           _coreMemoryPortalFXComponent;                      // 0x0380(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractor*                            _synchronizeCoreMemoryInteractor;                  // 0x0388(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USynchronizeCoreMemoryInteraction*      _synchronizeCoreMemoryInteraction;                 // 0x0390(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USynchronizeCoreMemoryInteraction*      _synchronizeCoreMemoryInteractionKiller;           // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _synchronizeCoreMemoryInteractionChargeable;       // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _synchronizeCoreMemoryInteractionChargeableKiller; // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPrimitiveComponent*                    _synchronizeCoreMemoryInteractionZone;             // 0x03B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoClear, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _synchronizeCoreMemoryInteractionSecondsToCharge;  // 0x03B8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _synchronizeCoreMemoryInteractionSecondsToChargeKiller; // 0x03E0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryPortal">();
	}
	static class ACoreMemoryPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoreMemoryPortal>();
	}
};
static_assert(alignof(ACoreMemoryPortal) == 0x000008, "Wrong alignment on ACoreMemoryPortal");
static_assert(sizeof(ACoreMemoryPortal) == 0x000408, "Wrong size on ACoreMemoryPortal");
static_assert(offsetof(ACoreMemoryPortal, _coreMemoryPortalStaticMesh) == 0x000368, "Member 'ACoreMemoryPortal::_coreMemoryPortalStaticMesh' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _coreMemoryController) == 0x000370, "Member 'ACoreMemoryPortal::_coreMemoryController' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _coreMemoryPortalComponent) == 0x000378, "Member 'ACoreMemoryPortal::_coreMemoryPortalComponent' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _coreMemoryPortalFXComponent) == 0x000380, "Member 'ACoreMemoryPortal::_coreMemoryPortalFXComponent' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _synchronizeCoreMemoryInteractor) == 0x000388, "Member 'ACoreMemoryPortal::_synchronizeCoreMemoryInteractor' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _synchronizeCoreMemoryInteraction) == 0x000390, "Member 'ACoreMemoryPortal::_synchronizeCoreMemoryInteraction' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _synchronizeCoreMemoryInteractionKiller) == 0x000398, "Member 'ACoreMemoryPortal::_synchronizeCoreMemoryInteractionKiller' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _synchronizeCoreMemoryInteractionChargeable) == 0x0003A0, "Member 'ACoreMemoryPortal::_synchronizeCoreMemoryInteractionChargeable' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _synchronizeCoreMemoryInteractionChargeableKiller) == 0x0003A8, "Member 'ACoreMemoryPortal::_synchronizeCoreMemoryInteractionChargeableKiller' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _synchronizeCoreMemoryInteractionZone) == 0x0003B0, "Member 'ACoreMemoryPortal::_synchronizeCoreMemoryInteractionZone' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _synchronizeCoreMemoryInteractionSecondsToCharge) == 0x0003B8, "Member 'ACoreMemoryPortal::_synchronizeCoreMemoryInteractionSecondsToCharge' has a wrong offset!");
static_assert(offsetof(ACoreMemoryPortal, _synchronizeCoreMemoryInteractionSecondsToChargeKiller) == 0x0003E0, "Member 'ACoreMemoryPortal::_synchronizeCoreMemoryInteractionSecondsToChargeKiller' has a wrong offset!");

// Class CoreMemory.CoreMemoryPortalComponent
// 0x0088 (0x0140 - 0x00B8)
class UCoreMemoryPortalComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x78];                                      // 0x00B8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADBDPlayer*>                     _playersWithActivePortal;                          // 0x0130(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	const TArray<class ADBDPlayer*> GetPlayersWithActivePortal() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryPortalComponent">();
	}
	static class UCoreMemoryPortalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryPortalComponent>();
	}
};
static_assert(alignof(UCoreMemoryPortalComponent) == 0x000008, "Wrong alignment on UCoreMemoryPortalComponent");
static_assert(sizeof(UCoreMemoryPortalComponent) == 0x000140, "Wrong size on UCoreMemoryPortalComponent");
static_assert(offsetof(UCoreMemoryPortalComponent, _playersWithActivePortal) == 0x000130, "Member 'UCoreMemoryPortalComponent::_playersWithActivePortal' has a wrong offset!");

// Class CoreMemory.CoreMemoryPortalDefaultBehaviour
// 0x0000 (0x0030 - 0x0030)
class UCoreMemoryPortalDefaultBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryPortalDefaultBehaviour">();
	}
	static class UCoreMemoryPortalDefaultBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryPortalDefaultBehaviour>();
	}
};
static_assert(alignof(UCoreMemoryPortalDefaultBehaviour) == 0x000008, "Wrong alignment on UCoreMemoryPortalDefaultBehaviour");
static_assert(sizeof(UCoreMemoryPortalDefaultBehaviour) == 0x000030, "Wrong size on UCoreMemoryPortalDefaultBehaviour");

// Class CoreMemory.CoreMemoryPortalFXComponent
// 0x0050 (0x0108 - 0x00B8)
class UCoreMemoryPortalFXComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class ADBDPlayer* player)> Cosmetic_OnPortalSpawned;               // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* player)> Cosmetic_OnPlayerStartedInteractingWithPortal; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* player)> Cosmetic_OnPortalInteractionInterrupted; // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* player)> Cosmetic_OnPortalDeactivated;           // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ADBDPlayer* player)> Cosmetic_OnInteractionComplete;         // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryPortalFXComponent">();
	}
	static class UCoreMemoryPortalFXComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryPortalFXComponent>();
	}
};
static_assert(alignof(UCoreMemoryPortalFXComponent) == 0x000008, "Wrong alignment on UCoreMemoryPortalFXComponent");
static_assert(sizeof(UCoreMemoryPortalFXComponent) == 0x000108, "Wrong size on UCoreMemoryPortalFXComponent");
static_assert(offsetof(UCoreMemoryPortalFXComponent, Cosmetic_OnPortalSpawned) == 0x0000B8, "Member 'UCoreMemoryPortalFXComponent::Cosmetic_OnPortalSpawned' has a wrong offset!");
static_assert(offsetof(UCoreMemoryPortalFXComponent, Cosmetic_OnPlayerStartedInteractingWithPortal) == 0x0000C8, "Member 'UCoreMemoryPortalFXComponent::Cosmetic_OnPlayerStartedInteractingWithPortal' has a wrong offset!");
static_assert(offsetof(UCoreMemoryPortalFXComponent, Cosmetic_OnPortalInteractionInterrupted) == 0x0000D8, "Member 'UCoreMemoryPortalFXComponent::Cosmetic_OnPortalInteractionInterrupted' has a wrong offset!");
static_assert(offsetof(UCoreMemoryPortalFXComponent, Cosmetic_OnPortalDeactivated) == 0x0000E8, "Member 'UCoreMemoryPortalFXComponent::Cosmetic_OnPortalDeactivated' has a wrong offset!");
static_assert(offsetof(UCoreMemoryPortalFXComponent, Cosmetic_OnInteractionComplete) == 0x0000F8, "Member 'UCoreMemoryPortalFXComponent::Cosmetic_OnInteractionComplete' has a wrong offset!");

// Class CoreMemory.CoreMemoryPortalOutlineUpdateStrategy
// 0x0020 (0x0100 - 0x00E0)
class UCoreMemoryPortalOutlineUpdateStrategy final : public UDefaultOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _outlineColor;                                     // 0x00E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryPortalOutlineUpdateStrategy">();
	}
	static class UCoreMemoryPortalOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryPortalOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UCoreMemoryPortalOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UCoreMemoryPortalOutlineUpdateStrategy");
static_assert(sizeof(UCoreMemoryPortalOutlineUpdateStrategy) == 0x000100, "Wrong size on UCoreMemoryPortalOutlineUpdateStrategy");
static_assert(offsetof(UCoreMemoryPortalOutlineUpdateStrategy, _outlineColor) == 0x0000E0, "Member 'UCoreMemoryPortalOutlineUpdateStrategy::_outlineColor' has a wrong offset!");

// Class CoreMemory.CoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour
// 0x0008 (0x0038 - 0x0030)
class UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour final : public UCoreMemoryBehaviourBase
{
public:
	TSubclassOf<class ACoreMemoryFragment>        _fragmentClass;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour">();
	}
	static class UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour>();
	}
};
static_assert(alignof(UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour) == 0x000008, "Wrong alignment on UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour");
static_assert(sizeof(UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour) == 0x000038, "Wrong size on UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour");
static_assert(offsetof(UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour, _fragmentClass) == 0x000030, "Member 'UCoreMemorySpawnFragmentsOnRandPlayerSpawnBehaviour::_fragmentClass' has a wrong offset!");

// Class CoreMemory.CoreMemoryUtilities
// 0x0000 (0x0030 - 0x0030)
class UCoreMemoryUtilities final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoreMemoryUtilities">();
	}
	static class UCoreMemoryUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoreMemoryUtilities>();
	}
};
static_assert(alignof(UCoreMemoryUtilities) == 0x000008, "Wrong alignment on UCoreMemoryUtilities");
static_assert(sizeof(UCoreMemoryUtilities) == 0x000030, "Wrong size on UCoreMemoryUtilities");

// Class CoreMemory.SynchronizeCoreMemoryInteraction
// 0x0060 (0x07A0 - 0x0740)
class USynchronizeCoreMemoryInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_740[0x60];                                     // 0x0740(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SynchronizeCoreMemoryInteraction">();
	}
	static class USynchronizeCoreMemoryInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<USynchronizeCoreMemoryInteraction>();
	}
};
static_assert(alignof(USynchronizeCoreMemoryInteraction) == 0x000010, "Wrong alignment on USynchronizeCoreMemoryInteraction");
static_assert(sizeof(USynchronizeCoreMemoryInteraction) == 0x0007A0, "Wrong size on USynchronizeCoreMemoryInteraction");

}

