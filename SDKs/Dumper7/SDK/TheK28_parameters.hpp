#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK28

#include "Basic.hpp"

#include "TheK28_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK::Params
{

// Function TheK28.Addon_K28Power_18.Multicast_TriggerLockerAnimationOnAllLockers
// 0x0010 (0x0010 - 0x0000)
struct Addon_K28Power_18_Multicast_TriggerLockerAnimationOnAllLockers final
{
public:
	TArray<class ALocker*>                        lockers;                                           // 0x0000(0x0010)(ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(Addon_K28Power_18_Multicast_TriggerLockerAnimationOnAllLockers) == 0x000008, "Wrong alignment on Addon_K28Power_18_Multicast_TriggerLockerAnimationOnAllLockers");
static_assert(sizeof(Addon_K28Power_18_Multicast_TriggerLockerAnimationOnAllLockers) == 0x000010, "Wrong size on Addon_K28Power_18_Multicast_TriggerLockerAnimationOnAllLockers");
static_assert(offsetof(Addon_K28Power_18_Multicast_TriggerLockerAnimationOnAllLockers, lockers) == 0x000000, "Member 'Addon_K28Power_18_Multicast_TriggerLockerAnimationOnAllLockers::lockers' has a wrong offset!");

// Function TheK28.K28AnimInstance.BP_OnCustomizationAnimationMappingIDChanged
// 0x0004 (0x0004 - 0x0000)
struct K28AnimInstance_BP_OnCustomizationAnimationMappingIDChanged final
{
public:
	int32                                         animationMappingIndex;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28AnimInstance_BP_OnCustomizationAnimationMappingIDChanged) == 0x000004, "Wrong alignment on K28AnimInstance_BP_OnCustomizationAnimationMappingIDChanged");
static_assert(sizeof(K28AnimInstance_BP_OnCustomizationAnimationMappingIDChanged) == 0x000004, "Wrong size on K28AnimInstance_BP_OnCustomizationAnimationMappingIDChanged");
static_assert(offsetof(K28AnimInstance_BP_OnCustomizationAnimationMappingIDChanged, animationMappingIndex) == 0x000000, "Member 'K28AnimInstance_BP_OnCustomizationAnimationMappingIDChanged::animationMappingIndex' has a wrong offset!");

// Function TheK28.K28AnimInstance.GetAnimationMappingIndex
// 0x0004 (0x0004 - 0x0000)
struct K28AnimInstance_GetAnimationMappingIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28AnimInstance_GetAnimationMappingIndex) == 0x000004, "Wrong alignment on K28AnimInstance_GetAnimationMappingIndex");
static_assert(sizeof(K28AnimInstance_GetAnimationMappingIndex) == 0x000004, "Wrong size on K28AnimInstance_GetAnimationMappingIndex");
static_assert(offsetof(K28AnimInstance_GetAnimationMappingIndex, ReturnValue) == 0x000000, "Member 'K28AnimInstance_GetAnimationMappingIndex::ReturnValue' has a wrong offset!");

// Function TheK28.K28AnimInstance.GetCustomAnimationTags
// 0x0010 (0x0010 - 0x0000)
struct K28AnimInstance_GetCustomAnimationTags final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28AnimInstance_GetCustomAnimationTags) == 0x000008, "Wrong alignment on K28AnimInstance_GetCustomAnimationTags");
static_assert(sizeof(K28AnimInstance_GetCustomAnimationTags) == 0x000010, "Wrong size on K28AnimInstance_GetCustomAnimationTags");
static_assert(offsetof(K28AnimInstance_GetCustomAnimationTags, ReturnValue) == 0x000000, "Member 'K28AnimInstance_GetCustomAnimationTags::ReturnValue' has a wrong offset!");

// Function TheK28.K28CheatComponent.DBD_K28DebugCosmetics
// 0x0001 (0x0001 - 0x0000)
struct K28CheatComponent_DBD_K28DebugCosmetics final
{
public:
	bool                                          noCooldown;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28CheatComponent_DBD_K28DebugCosmetics) == 0x000001, "Wrong alignment on K28CheatComponent_DBD_K28DebugCosmetics");
static_assert(sizeof(K28CheatComponent_DBD_K28DebugCosmetics) == 0x000001, "Wrong size on K28CheatComponent_DBD_K28DebugCosmetics");
static_assert(offsetof(K28CheatComponent_DBD_K28DebugCosmetics, noCooldown) == 0x000000, "Member 'K28CheatComponent_DBD_K28DebugCosmetics::noCooldown' has a wrong offset!");

// Function TheK28.K28CheatComponent.DBD_K28DisplayLockerClusters
// 0x0004 (0x0004 - 0x0000)
struct K28CheatComponent_DBD_K28DisplayLockerClusters final
{
public:
	float                                         secondsToDisplayDebugElements;                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28CheatComponent_DBD_K28DisplayLockerClusters) == 0x000004, "Wrong alignment on K28CheatComponent_DBD_K28DisplayLockerClusters");
static_assert(sizeof(K28CheatComponent_DBD_K28DisplayLockerClusters) == 0x000004, "Wrong size on K28CheatComponent_DBD_K28DisplayLockerClusters");
static_assert(offsetof(K28CheatComponent_DBD_K28DisplayLockerClusters, secondsToDisplayDebugElements) == 0x000000, "Member 'K28CheatComponent_DBD_K28DisplayLockerClusters::secondsToDisplayDebugElements' has a wrong offset!");

// Function TheK28.K28CheatComponent.DBD_K28SetPowerNoCooldown
// 0x0001 (0x0001 - 0x0000)
struct K28CheatComponent_DBD_K28SetPowerNoCooldown final
{
public:
	bool                                          noCooldown;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28CheatComponent_DBD_K28SetPowerNoCooldown) == 0x000001, "Wrong alignment on K28CheatComponent_DBD_K28SetPowerNoCooldown");
static_assert(sizeof(K28CheatComponent_DBD_K28SetPowerNoCooldown) == 0x000001, "Wrong size on K28CheatComponent_DBD_K28SetPowerNoCooldown");
static_assert(offsetof(K28CheatComponent_DBD_K28SetPowerNoCooldown, noCooldown) == 0x000000, "Member 'K28CheatComponent_DBD_K28SetPowerNoCooldown::noCooldown' has a wrong offset!");

// Function TheK28.K28DayNightComponent.Authority_OnSurvivorDamageStateChanged
// 0x0002 (0x0002 - 0x0000)
struct K28DayNightComponent_Authority_OnSurvivorDamageStateChanged final
{
public:
	ECamperDamageState                            previousDamageState;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECamperDamageState                            newDamageState;                                    // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28DayNightComponent_Authority_OnSurvivorDamageStateChanged) == 0x000001, "Wrong alignment on K28DayNightComponent_Authority_OnSurvivorDamageStateChanged");
static_assert(sizeof(K28DayNightComponent_Authority_OnSurvivorDamageStateChanged) == 0x000002, "Wrong size on K28DayNightComponent_Authority_OnSurvivorDamageStateChanged");
static_assert(offsetof(K28DayNightComponent_Authority_OnSurvivorDamageStateChanged, previousDamageState) == 0x000000, "Member 'K28DayNightComponent_Authority_OnSurvivorDamageStateChanged::previousDamageState' has a wrong offset!");
static_assert(offsetof(K28DayNightComponent_Authority_OnSurvivorDamageStateChanged, newDamageState) == 0x000001, "Member 'K28DayNightComponent_Authority_OnSurvivorDamageStateChanged::newDamageState' has a wrong offset!");

// Function TheK28.K28DayNightComponent.Cosmetic_OnIsInLastTwentySecondsOfNightCycle
// 0x0008 (0x0008 - 0x0000)
struct K28DayNightComponent_Cosmetic_OnIsInLastTwentySecondsOfNightCycle final
{
public:
	class UAkComponent*                           akComponent;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28DayNightComponent_Cosmetic_OnIsInLastTwentySecondsOfNightCycle) == 0x000008, "Wrong alignment on K28DayNightComponent_Cosmetic_OnIsInLastTwentySecondsOfNightCycle");
static_assert(sizeof(K28DayNightComponent_Cosmetic_OnIsInLastTwentySecondsOfNightCycle) == 0x000008, "Wrong size on K28DayNightComponent_Cosmetic_OnIsInLastTwentySecondsOfNightCycle");
static_assert(offsetof(K28DayNightComponent_Cosmetic_OnIsInLastTwentySecondsOfNightCycle, akComponent) == 0x000000, "Member 'K28DayNightComponent_Cosmetic_OnIsInLastTwentySecondsOfNightCycle::akComponent' has a wrong offset!");

// Function TheK28.K28DayNightComponent.Cosmetic_OnNightCycleChanged
// 0x0010 (0x0010 - 0x0000)
struct K28DayNightComponent_Cosmetic_OnNightCycleChanged final
{
public:
	class UAkComponent*                           akComponent;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EK28NightCycleState                           newNightCycleState;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28DayNightComponent_Cosmetic_OnNightCycleChanged) == 0x000008, "Wrong alignment on K28DayNightComponent_Cosmetic_OnNightCycleChanged");
static_assert(sizeof(K28DayNightComponent_Cosmetic_OnNightCycleChanged) == 0x000010, "Wrong size on K28DayNightComponent_Cosmetic_OnNightCycleChanged");
static_assert(offsetof(K28DayNightComponent_Cosmetic_OnNightCycleChanged, akComponent) == 0x000000, "Member 'K28DayNightComponent_Cosmetic_OnNightCycleChanged::akComponent' has a wrong offset!");
static_assert(offsetof(K28DayNightComponent_Cosmetic_OnNightCycleChanged, newNightCycleState) == 0x000008, "Member 'K28DayNightComponent_Cosmetic_OnNightCycleChanged::newNightCycleState' has a wrong offset!");

// Function TheK28.K28FXInterface.Cosmetic_OnIsKillingSurvivorWithMoriStateChanged
// 0x0001 (0x0001 - 0x0000)
struct K28FXInterface_Cosmetic_OnIsKillingSurvivorWithMoriStateChanged final
{
public:
	bool                                          isKillingSurvivorWithMori;                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28FXInterface_Cosmetic_OnIsKillingSurvivorWithMoriStateChanged) == 0x000001, "Wrong alignment on K28FXInterface_Cosmetic_OnIsKillingSurvivorWithMoriStateChanged");
static_assert(sizeof(K28FXInterface_Cosmetic_OnIsKillingSurvivorWithMoriStateChanged) == 0x000001, "Wrong size on K28FXInterface_Cosmetic_OnIsKillingSurvivorWithMoriStateChanged");
static_assert(offsetof(K28FXInterface_Cosmetic_OnIsKillingSurvivorWithMoriStateChanged, isKillingSurvivorWithMori) == 0x000000, "Member 'K28FXInterface_Cosmetic_OnIsKillingSurvivorWithMoriStateChanged::isKillingSurvivorWithMori' has a wrong offset!");

// Function TheK28.K28FXInterface.Cosmetic_OnShowKiller
// 0x0001 (0x0001 - 0x0000)
struct K28FXInterface_Cosmetic_OnShowKiller final
{
public:
	bool                                          isInstantShow;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28FXInterface_Cosmetic_OnShowKiller) == 0x000001, "Wrong alignment on K28FXInterface_Cosmetic_OnShowKiller");
static_assert(sizeof(K28FXInterface_Cosmetic_OnShowKiller) == 0x000001, "Wrong size on K28FXInterface_Cosmetic_OnShowKiller");
static_assert(offsetof(K28FXInterface_Cosmetic_OnShowKiller, isInstantShow) == 0x000000, "Member 'K28FXInterface_Cosmetic_OnShowKiller::isInstantShow' has a wrong offset!");

// Function TheK28.K28FXInterface.Cosmetic_OnTeleportationToLockerStart
// 0x0008 (0x0008 - 0x0000)
struct K28FXInterface_Cosmetic_OnTeleportationToLockerStart final
{
public:
	float                                         teleportationDuration;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isKillerAlreadyHidingInLocker;                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28FXInterface_Cosmetic_OnTeleportationToLockerStart) == 0x000004, "Wrong alignment on K28FXInterface_Cosmetic_OnTeleportationToLockerStart");
static_assert(sizeof(K28FXInterface_Cosmetic_OnTeleportationToLockerStart) == 0x000008, "Wrong size on K28FXInterface_Cosmetic_OnTeleportationToLockerStart");
static_assert(offsetof(K28FXInterface_Cosmetic_OnTeleportationToLockerStart, teleportationDuration) == 0x000000, "Member 'K28FXInterface_Cosmetic_OnTeleportationToLockerStart::teleportationDuration' has a wrong offset!");
static_assert(offsetof(K28FXInterface_Cosmetic_OnTeleportationToLockerStart, isKillerAlreadyHidingInLocker) == 0x000004, "Member 'K28FXInterface_Cosmetic_OnTeleportationToLockerStart::isKillerAlreadyHidingInLocker' has a wrong offset!");

// Function TheK28.K28FXInterface.Cosmetic_SetBlackMaterialOnKiller
// 0x0001 (0x0001 - 0x0000)
struct K28FXInterface_Cosmetic_SetBlackMaterialOnKiller final
{
public:
	bool                                          blackMaterialApplied;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28FXInterface_Cosmetic_SetBlackMaterialOnKiller) == 0x000001, "Wrong alignment on K28FXInterface_Cosmetic_SetBlackMaterialOnKiller");
static_assert(sizeof(K28FXInterface_Cosmetic_SetBlackMaterialOnKiller) == 0x000001, "Wrong size on K28FXInterface_Cosmetic_SetBlackMaterialOnKiller");
static_assert(offsetof(K28FXInterface_Cosmetic_SetBlackMaterialOnKiller, blackMaterialApplied) == 0x000000, "Member 'K28FXInterface_Cosmetic_SetBlackMaterialOnKiller::blackMaterialApplied' has a wrong offset!");

// Function TheK28.K28FXInterface.Cosmetic_SetDebugCosmetics
// 0x0001 (0x0001 - 0x0000)
struct K28FXInterface_Cosmetic_SetDebugCosmetics final
{
public:
	bool                                          isDebugCosmeticsActive;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28FXInterface_Cosmetic_SetDebugCosmetics) == 0x000001, "Wrong alignment on K28FXInterface_Cosmetic_SetDebugCosmetics");
static_assert(sizeof(K28FXInterface_Cosmetic_SetDebugCosmetics) == 0x000001, "Wrong size on K28FXInterface_Cosmetic_SetDebugCosmetics");
static_assert(offsetof(K28FXInterface_Cosmetic_SetDebugCosmetics, isDebugCosmeticsActive) == 0x000000, "Member 'K28FXInterface_Cosmetic_SetDebugCosmetics::isDebugCosmeticsActive' has a wrong offset!");

// Function TheK28.K28PlayerComponent.OnSurvivorInRangeChanged
// 0x0010 (0x0010 - 0x0000)
struct K28PlayerComponent_OnSurvivorInRangeChanged final
{
public:
	bool                                          inRange;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          player;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28PlayerComponent_OnSurvivorInRangeChanged) == 0x000008, "Wrong alignment on K28PlayerComponent_OnSurvivorInRangeChanged");
static_assert(sizeof(K28PlayerComponent_OnSurvivorInRangeChanged) == 0x000010, "Wrong size on K28PlayerComponent_OnSurvivorInRangeChanged");
static_assert(offsetof(K28PlayerComponent_OnSurvivorInRangeChanged, inRange) == 0x000000, "Member 'K28PlayerComponent_OnSurvivorInRangeChanged::inRange' has a wrong offset!");
static_assert(offsetof(K28PlayerComponent_OnSurvivorInRangeChanged, player) == 0x000008, "Member 'K28PlayerComponent_OnSurvivorInRangeChanged::player' has a wrong offset!");

// Function TheK28.K28KillerComponent.Cosmetic_OnNightCycleStateChanged
// 0x0010 (0x0010 - 0x0000)
struct K28KillerComponent_Cosmetic_OnNightCycleStateChanged final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EK28NightCycleState                           dayNightCycleState;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28KillerComponent_Cosmetic_OnNightCycleStateChanged) == 0x000008, "Wrong alignment on K28KillerComponent_Cosmetic_OnNightCycleStateChanged");
static_assert(sizeof(K28KillerComponent_Cosmetic_OnNightCycleStateChanged) == 0x000010, "Wrong size on K28KillerComponent_Cosmetic_OnNightCycleStateChanged");
static_assert(offsetof(K28KillerComponent_Cosmetic_OnNightCycleStateChanged, killer) == 0x000000, "Member 'K28KillerComponent_Cosmetic_OnNightCycleStateChanged::killer' has a wrong offset!");
static_assert(offsetof(K28KillerComponent_Cosmetic_OnNightCycleStateChanged, dayNightCycleState) == 0x000008, "Member 'K28KillerComponent_Cosmetic_OnNightCycleStateChanged::dayNightCycleState' has a wrong offset!");

// Function TheK28.K28KillerComponent.Cosmetic_OnNighttimeNearingActivation
// 0x0008 (0x0008 - 0x0000)
struct K28KillerComponent_Cosmetic_OnNighttimeNearingActivation final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28KillerComponent_Cosmetic_OnNighttimeNearingActivation) == 0x000008, "Wrong alignment on K28KillerComponent_Cosmetic_OnNighttimeNearingActivation");
static_assert(sizeof(K28KillerComponent_Cosmetic_OnNighttimeNearingActivation) == 0x000008, "Wrong size on K28KillerComponent_Cosmetic_OnNighttimeNearingActivation");
static_assert(offsetof(K28KillerComponent_Cosmetic_OnNighttimeNearingActivation, killer) == 0x000000, "Member 'K28KillerComponent_Cosmetic_OnNighttimeNearingActivation::killer' has a wrong offset!");

// Function TheK28.K28KillerEnterLockerInteraction.IsKillerAllowedToEnterLocker
// 0x0010 (0x0010 - 0x0000)
struct K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker final
{
public:
	const class ADBDPlayer*                       player;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker) == 0x000008, "Wrong alignment on K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker");
static_assert(sizeof(K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker) == 0x000010, "Wrong size on K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker");
static_assert(offsetof(K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker, player) == 0x000000, "Member 'K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker::player' has a wrong offset!");
static_assert(offsetof(K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker, ReturnValue) == 0x000008, "Member 'K28KillerEnterLockerInteraction_IsKillerAllowedToEnterLocker::ReturnValue' has a wrong offset!");

// Function TheK28.K28KillerInstinctEffect.Authority_OnKillerInstinctApplicableChanged
// 0x0001 (0x0001 - 0x0000)
struct K28KillerInstinctEffect_Authority_OnKillerInstinctApplicableChanged final
{
public:
	bool                                          active;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28KillerInstinctEffect_Authority_OnKillerInstinctApplicableChanged) == 0x000001, "Wrong alignment on K28KillerInstinctEffect_Authority_OnKillerInstinctApplicableChanged");
static_assert(sizeof(K28KillerInstinctEffect_Authority_OnKillerInstinctApplicableChanged) == 0x000001, "Wrong size on K28KillerInstinctEffect_Authority_OnKillerInstinctApplicableChanged");
static_assert(offsetof(K28KillerInstinctEffect_Authority_OnKillerInstinctApplicableChanged, active) == 0x000000, "Member 'K28KillerInstinctEffect_Authority_OnKillerInstinctApplicableChanged::active' has a wrong offset!");

// Function TheK28.K28KillerLockerComponent.OnPlayerInLockerChanged
// 0x0010 (0x0010 - 0x0000)
struct K28KillerLockerComponent_OnPlayerInLockerChanged final
{
public:
	class ADBDPlayer*                             previousPlayerInLocker;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDPlayer*                             newPlayerInLocker;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28KillerLockerComponent_OnPlayerInLockerChanged) == 0x000008, "Wrong alignment on K28KillerLockerComponent_OnPlayerInLockerChanged");
static_assert(sizeof(K28KillerLockerComponent_OnPlayerInLockerChanged) == 0x000010, "Wrong size on K28KillerLockerComponent_OnPlayerInLockerChanged");
static_assert(offsetof(K28KillerLockerComponent_OnPlayerInLockerChanged, previousPlayerInLocker) == 0x000000, "Member 'K28KillerLockerComponent_OnPlayerInLockerChanged::previousPlayerInLocker' has a wrong offset!");
static_assert(offsetof(K28KillerLockerComponent_OnPlayerInLockerChanged, newPlayerInLocker) == 0x000008, "Member 'K28KillerLockerComponent_OnPlayerInLockerChanged::newPlayerInLocker' has a wrong offset!");

// Function TheK28.K28KillerTeleportationComponent.Local_OnTeleportCollisionOverlapBegin
// 0x00B0 (0x00B0 - 0x0000)
struct K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin final
{
public:
	class UPrimitiveComponent*                    overlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 otherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    otherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         otherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             sweepResult;                                       // 0x0020(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin) == 0x000008, "Wrong alignment on K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin");
static_assert(sizeof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin) == 0x0000B0, "Wrong size on K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin, overlappedComponent) == 0x000000, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin::overlappedComponent' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin, otherActor) == 0x000008, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin::otherActor' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin, otherComp) == 0x000010, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin::otherComp' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin, otherBodyIndex) == 0x000018, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin::otherBodyIndex' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin, bFromSweep) == 0x00001C, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin::bFromSweep' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin, sweepResult) == 0x000020, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapBegin::sweepResult' has a wrong offset!");

// Function TheK28.K28KillerTeleportationComponent.Local_OnTeleportCollisionOverlapEnd
// 0x0020 (0x0020 - 0x0000)
struct K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd final
{
public:
	class UPrimitiveComponent*                    overlappedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 otherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    otherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         otherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd) == 0x000008, "Wrong alignment on K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd");
static_assert(sizeof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd) == 0x000020, "Wrong size on K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd, overlappedComponent) == 0x000000, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd::overlappedComponent' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd, otherActor) == 0x000008, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd::otherActor' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd, otherComp) == 0x000010, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd::otherComp' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd, otherBodyIndex) == 0x000018, "Member 'K28KillerTeleportationComponent_Local_OnTeleportCollisionOverlapEnd::otherBodyIndex' has a wrong offset!");

// Function TheK28.K28KillerTeleportationComponent.Multicast_TeleportToLockerEnd
// 0x0010 (0x0010 - 0x0000)
struct K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd final
{
public:
	class UK28LockerComponent*                    lockerTeleportedTo;                                // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACamperPlayer*                          survivorInLocker;                                  // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd) == 0x000008, "Wrong alignment on K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd");
static_assert(sizeof(K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd) == 0x000010, "Wrong size on K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd");
static_assert(offsetof(K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd, lockerTeleportedTo) == 0x000000, "Member 'K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd::lockerTeleportedTo' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd, survivorInLocker) == 0x000008, "Member 'K28KillerTeleportationComponent_Multicast_TeleportToLockerEnd::survivorInLocker' has a wrong offset!");

// Function TheK28.K28KillerTeleportationComponent.Multicast_TeleportToLockerStart
// 0x0060 (0x0060 - 0x0000)
struct K28KillerTeleportationComponent_Multicast_TeleportToLockerStart final
{
public:
	struct FK28SecondaryCameraMovementData        cameraMovementData;                                // 0x0000(0x0050)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class UK28LockerComponent*                    lockerBeingTeleportedTo;                           // 0x0050(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ACamperPlayer*                          survivorToGrab;                                    // 0x0058(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28KillerTeleportationComponent_Multicast_TeleportToLockerStart) == 0x000008, "Wrong alignment on K28KillerTeleportationComponent_Multicast_TeleportToLockerStart");
static_assert(sizeof(K28KillerTeleportationComponent_Multicast_TeleportToLockerStart) == 0x000060, "Wrong size on K28KillerTeleportationComponent_Multicast_TeleportToLockerStart");
static_assert(offsetof(K28KillerTeleportationComponent_Multicast_TeleportToLockerStart, cameraMovementData) == 0x000000, "Member 'K28KillerTeleportationComponent_Multicast_TeleportToLockerStart::cameraMovementData' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Multicast_TeleportToLockerStart, lockerBeingTeleportedTo) == 0x000050, "Member 'K28KillerTeleportationComponent_Multicast_TeleportToLockerStart::lockerBeingTeleportedTo' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_Multicast_TeleportToLockerStart, survivorToGrab) == 0x000058, "Member 'K28KillerTeleportationComponent_Multicast_TeleportToLockerStart::survivorToGrab' has a wrong offset!");

// Function TheK28.K28KillerTeleportationComponent.OnPlayerFinishedEnteringLocker
// 0x0010 (0x0010 - 0x0000)
struct K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker final
{
public:
	class ADBDPlayer*                             playerThatWasInLocker;                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDPlayer*                             playerNowInLocker;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker) == 0x000008, "Wrong alignment on K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker");
static_assert(sizeof(K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker) == 0x000010, "Wrong size on K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker");
static_assert(offsetof(K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker, playerThatWasInLocker) == 0x000000, "Member 'K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker::playerThatWasInLocker' has a wrong offset!");
static_assert(offsetof(K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker, playerNowInLocker) == 0x000008, "Member 'K28KillerTeleportationComponent_OnPlayerFinishedEnteringLocker::playerNowInLocker' has a wrong offset!");

// Function TheK28.K28Lockbar.Cosmetic_OnStateChanged
// 0x0001 (0x0001 - 0x0000)
struct K28Lockbar_Cosmetic_OnStateChanged final
{
public:
	EK28LockbarState                              newState;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Lockbar_Cosmetic_OnStateChanged) == 0x000001, "Wrong alignment on K28Lockbar_Cosmetic_OnStateChanged");
static_assert(sizeof(K28Lockbar_Cosmetic_OnStateChanged) == 0x000001, "Wrong size on K28Lockbar_Cosmetic_OnStateChanged");
static_assert(offsetof(K28Lockbar_Cosmetic_OnStateChanged, newState) == 0x000000, "Member 'K28Lockbar_Cosmetic_OnStateChanged::newState' has a wrong offset!");

// Function TheK28.K28Lockbar.Cosmetic_SetLockbarHighlightActivationState
// 0x0001 (0x0001 - 0x0000)
struct K28Lockbar_Cosmetic_SetLockbarHighlightActivationState final
{
public:
	bool                                          isHightlightActive;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Lockbar_Cosmetic_SetLockbarHighlightActivationState) == 0x000001, "Wrong alignment on K28Lockbar_Cosmetic_SetLockbarHighlightActivationState");
static_assert(sizeof(K28Lockbar_Cosmetic_SetLockbarHighlightActivationState) == 0x000001, "Wrong size on K28Lockbar_Cosmetic_SetLockbarHighlightActivationState");
static_assert(offsetof(K28Lockbar_Cosmetic_SetLockbarHighlightActivationState, isHightlightActive) == 0x000000, "Member 'K28Lockbar_Cosmetic_SetLockbarHighlightActivationState::isHightlightActive' has a wrong offset!");

// Function TheK28.K28Lockbar.OnPlayerInLockerChanged
// 0x0010 (0x0010 - 0x0000)
struct K28Lockbar_OnPlayerInLockerChanged final
{
public:
	class ADBDPlayer*                             previousPlayerInLocker;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADBDPlayer*                             newPlayerInLocker;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Lockbar_OnPlayerInLockerChanged) == 0x000008, "Wrong alignment on K28Lockbar_OnPlayerInLockerChanged");
static_assert(sizeof(K28Lockbar_OnPlayerInLockerChanged) == 0x000010, "Wrong size on K28Lockbar_OnPlayerInLockerChanged");
static_assert(offsetof(K28Lockbar_OnPlayerInLockerChanged, previousPlayerInLocker) == 0x000000, "Member 'K28Lockbar_OnPlayerInLockerChanged::previousPlayerInLocker' has a wrong offset!");
static_assert(offsetof(K28Lockbar_OnPlayerInLockerChanged, newPlayerInLocker) == 0x000008, "Member 'K28Lockbar_OnPlayerInLockerChanged::newPlayerInLocker' has a wrong offset!");

// Function TheK28.K28Lockbar.GetMontagePlayer
// 0x0008 (0x0008 - 0x0000)
struct K28Lockbar_GetMontagePlayer final
{
public:
	class UMontagePlayer*                         ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Lockbar_GetMontagePlayer) == 0x000008, "Wrong alignment on K28Lockbar_GetMontagePlayer");
static_assert(sizeof(K28Lockbar_GetMontagePlayer) == 0x000008, "Wrong size on K28Lockbar_GetMontagePlayer");
static_assert(offsetof(K28Lockbar_GetMontagePlayer, ReturnValue) == 0x000000, "Member 'K28Lockbar_GetMontagePlayer::ReturnValue' has a wrong offset!");

// Function TheK28.K28LockerCosmeticHelperActor.Cosmetic_OnLockedStateChanged
// 0x0001 (0x0001 - 0x0000)
struct K28LockerCosmeticHelperActor_Cosmetic_OnLockedStateChanged final
{
public:
	bool                                          isLockerLocked;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28LockerCosmeticHelperActor_Cosmetic_OnLockedStateChanged) == 0x000001, "Wrong alignment on K28LockerCosmeticHelperActor_Cosmetic_OnLockedStateChanged");
static_assert(sizeof(K28LockerCosmeticHelperActor_Cosmetic_OnLockedStateChanged) == 0x000001, "Wrong size on K28LockerCosmeticHelperActor_Cosmetic_OnLockedStateChanged");
static_assert(offsetof(K28LockerCosmeticHelperActor_Cosmetic_OnLockedStateChanged, isLockerLocked) == 0x000000, "Member 'K28LockerCosmeticHelperActor_Cosmetic_OnLockedStateChanged::isLockerLocked' has a wrong offset!");

// Function TheK28.K28LockerCosmeticHelperActor.Cosmetic_OnLockerGrabStateChanged
// 0x0001 (0x0001 - 0x0000)
struct K28LockerCosmeticHelperActor_Cosmetic_OnLockerGrabStateChanged final
{
public:
	bool                                          isLockerGrabOngoing;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28LockerCosmeticHelperActor_Cosmetic_OnLockerGrabStateChanged) == 0x000001, "Wrong alignment on K28LockerCosmeticHelperActor_Cosmetic_OnLockerGrabStateChanged");
static_assert(sizeof(K28LockerCosmeticHelperActor_Cosmetic_OnLockerGrabStateChanged) == 0x000001, "Wrong size on K28LockerCosmeticHelperActor_Cosmetic_OnLockerGrabStateChanged");
static_assert(offsetof(K28LockerCosmeticHelperActor_Cosmetic_OnLockerGrabStateChanged, isLockerGrabOngoing) == 0x000000, "Member 'K28LockerCosmeticHelperActor_Cosmetic_OnLockerGrabStateChanged::isLockerGrabOngoing' has a wrong offset!");

// Function TheK28.K28LockerCosmeticHelperActor.GetLocker
// 0x0008 (0x0008 - 0x0000)
struct K28LockerCosmeticHelperActor_GetLocker final
{
public:
	class ALocker*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28LockerCosmeticHelperActor_GetLocker) == 0x000008, "Wrong alignment on K28LockerCosmeticHelperActor_GetLocker");
static_assert(sizeof(K28LockerCosmeticHelperActor_GetLocker) == 0x000008, "Wrong size on K28LockerCosmeticHelperActor_GetLocker");
static_assert(offsetof(K28LockerCosmeticHelperActor_GetLocker, ReturnValue) == 0x000000, "Member 'K28LockerCosmeticHelperActor_GetLocker::ReturnValue' has a wrong offset!");

// Function TheK28.K28LockerCosmeticHelperActor.GetMaterialHelper
// 0x0008 (0x0008 - 0x0000)
struct K28LockerCosmeticHelperActor_GetMaterialHelper final
{
public:
	class UMaterialHelper*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28LockerCosmeticHelperActor_GetMaterialHelper) == 0x000008, "Wrong alignment on K28LockerCosmeticHelperActor_GetMaterialHelper");
static_assert(sizeof(K28LockerCosmeticHelperActor_GetMaterialHelper) == 0x000008, "Wrong size on K28LockerCosmeticHelperActor_GetMaterialHelper");
static_assert(offsetof(K28LockerCosmeticHelperActor_GetMaterialHelper, ReturnValue) == 0x000000, "Member 'K28LockerCosmeticHelperActor_GetMaterialHelper::ReturnValue' has a wrong offset!");

// Function TheK28.K28LockerCosmeticHelperActor.GetSkeletalMesh
// 0x0008 (0x0008 - 0x0000)
struct K28LockerCosmeticHelperActor_GetSkeletalMesh final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28LockerCosmeticHelperActor_GetSkeletalMesh) == 0x000008, "Wrong alignment on K28LockerCosmeticHelperActor_GetSkeletalMesh");
static_assert(sizeof(K28LockerCosmeticHelperActor_GetSkeletalMesh) == 0x000008, "Wrong size on K28LockerCosmeticHelperActor_GetSkeletalMesh");
static_assert(offsetof(K28LockerCosmeticHelperActor_GetSkeletalMesh, ReturnValue) == 0x000000, "Member 'K28LockerCosmeticHelperActor_GetSkeletalMesh::ReturnValue' has a wrong offset!");

// Function TheK28.K28LockerTeleportSwapInteraction.Multicast_ConfirmTeleportationRequest
// 0x0010 (0x0010 - 0x0000)
struct K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        teleportTarget;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest) == 0x000008, "Wrong alignment on K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest");
static_assert(sizeof(K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest) == 0x000010, "Wrong size on K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest");
static_assert(offsetof(K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest, killer) == 0x000000, "Member 'K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest::killer' has a wrong offset!");
static_assert(offsetof(K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest, teleportTarget) == 0x000008, "Member 'K28LockerTeleportSwapInteraction_Multicast_ConfirmTeleportationRequest::teleportTarget' has a wrong offset!");

// Function TheK28.K28LockerTeleportSwapInteraction.Server_RequestTeleportToTarget
// 0x0010 (0x0010 - 0x0000)
struct K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        teleportTarget;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget) == 0x000008, "Wrong alignment on K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget");
static_assert(sizeof(K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget) == 0x000010, "Wrong size on K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget");
static_assert(offsetof(K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget, killer) == 0x000000, "Member 'K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget::killer' has a wrong offset!");
static_assert(offsetof(K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget, teleportTarget) == 0x000008, "Member 'K28LockerTeleportSwapInteraction_Server_RequestTeleportToTarget::teleportTarget' has a wrong offset!");

// Function TheK28.K28MenuAnimInstance.BP_OnCustomizationAnimationMappingIDChanged
// 0x0004 (0x0004 - 0x0000)
struct K28MenuAnimInstance_BP_OnCustomizationAnimationMappingIDChanged final
{
public:
	int32                                         animationMappingIndex;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28MenuAnimInstance_BP_OnCustomizationAnimationMappingIDChanged) == 0x000004, "Wrong alignment on K28MenuAnimInstance_BP_OnCustomizationAnimationMappingIDChanged");
static_assert(sizeof(K28MenuAnimInstance_BP_OnCustomizationAnimationMappingIDChanged) == 0x000004, "Wrong size on K28MenuAnimInstance_BP_OnCustomizationAnimationMappingIDChanged");
static_assert(offsetof(K28MenuAnimInstance_BP_OnCustomizationAnimationMappingIDChanged, animationMappingIndex) == 0x000000, "Member 'K28MenuAnimInstance_BP_OnCustomizationAnimationMappingIDChanged::animationMappingIndex' has a wrong offset!");

// Function TheK28.K28MenuAnimInstance.GetAnimationMappingIndex
// 0x0004 (0x0004 - 0x0000)
struct K28MenuAnimInstance_GetAnimationMappingIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28MenuAnimInstance_GetAnimationMappingIndex) == 0x000004, "Wrong alignment on K28MenuAnimInstance_GetAnimationMappingIndex");
static_assert(sizeof(K28MenuAnimInstance_GetAnimationMappingIndex) == 0x000004, "Wrong size on K28MenuAnimInstance_GetAnimationMappingIndex");
static_assert(offsetof(K28MenuAnimInstance_GetAnimationMappingIndex, ReturnValue) == 0x000000, "Member 'K28MenuAnimInstance_GetAnimationMappingIndex::ReturnValue' has a wrong offset!");

// Function TheK28.K28P02.GetLockerDetectionRadius
// 0x0004 (0x0004 - 0x0000)
struct K28P02_GetLockerDetectionRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28P02_GetLockerDetectionRadius) == 0x000004, "Wrong alignment on K28P02_GetLockerDetectionRadius");
static_assert(sizeof(K28P02_GetLockerDetectionRadius) == 0x000004, "Wrong size on K28P02_GetLockerDetectionRadius");
static_assert(offsetof(K28P02_GetLockerDetectionRadius, ReturnValue) == 0x000000, "Member 'K28P02_GetLockerDetectionRadius::ReturnValue' has a wrong offset!");

// Function TheK28.K28P02.GetPerkActivationTime
// 0x0004 (0x0004 - 0x0000)
struct K28P02_GetPerkActivationTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28P02_GetPerkActivationTime) == 0x000004, "Wrong alignment on K28P02_GetPerkActivationTime");
static_assert(sizeof(K28P02_GetPerkActivationTime) == 0x000004, "Wrong size on K28P02_GetPerkActivationTime");
static_assert(offsetof(K28P02_GetPerkActivationTime, ReturnValue) == 0x000000, "Member 'K28P02_GetPerkActivationTime::ReturnValue' has a wrong offset!");

// Function TheK28.K28Remnant.Authority_OnCollisionDetected
// 0x00B0 (0x00B0 - 0x0000)
struct K28Remnant_Authority_OnCollisionDetected final
{
public:
	class UPrimitiveComponent*                    hitComponent;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 otherActor;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    otherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         otherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             sweepResult;                                       // 0x0020(0x0090)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Remnant_Authority_OnCollisionDetected) == 0x000008, "Wrong alignment on K28Remnant_Authority_OnCollisionDetected");
static_assert(sizeof(K28Remnant_Authority_OnCollisionDetected) == 0x0000B0, "Wrong size on K28Remnant_Authority_OnCollisionDetected");
static_assert(offsetof(K28Remnant_Authority_OnCollisionDetected, hitComponent) == 0x000000, "Member 'K28Remnant_Authority_OnCollisionDetected::hitComponent' has a wrong offset!");
static_assert(offsetof(K28Remnant_Authority_OnCollisionDetected, otherActor) == 0x000008, "Member 'K28Remnant_Authority_OnCollisionDetected::otherActor' has a wrong offset!");
static_assert(offsetof(K28Remnant_Authority_OnCollisionDetected, otherComp) == 0x000010, "Member 'K28Remnant_Authority_OnCollisionDetected::otherComp' has a wrong offset!");
static_assert(offsetof(K28Remnant_Authority_OnCollisionDetected, otherBodyIndex) == 0x000018, "Member 'K28Remnant_Authority_OnCollisionDetected::otherBodyIndex' has a wrong offset!");
static_assert(offsetof(K28Remnant_Authority_OnCollisionDetected, bFromSweep) == 0x00001C, "Member 'K28Remnant_Authority_OnCollisionDetected::bFromSweep' has a wrong offset!");
static_assert(offsetof(K28Remnant_Authority_OnCollisionDetected, sweepResult) == 0x000020, "Member 'K28Remnant_Authority_OnCollisionDetected::sweepResult' has a wrong offset!");

// Function TheK28.K28Remnant.Cosmetic_OnRemnantStateChanged
// 0x0001 (0x0001 - 0x0000)
struct K28Remnant_Cosmetic_OnRemnantStateChanged final
{
public:
	EK28RemnantState                              remnantState;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Remnant_Cosmetic_OnRemnantStateChanged) == 0x000001, "Wrong alignment on K28Remnant_Cosmetic_OnRemnantStateChanged");
static_assert(sizeof(K28Remnant_Cosmetic_OnRemnantStateChanged) == 0x000001, "Wrong size on K28Remnant_Cosmetic_OnRemnantStateChanged");
static_assert(offsetof(K28Remnant_Cosmetic_OnRemnantStateChanged, remnantState) == 0x000000, "Member 'K28Remnant_Cosmetic_OnRemnantStateChanged::remnantState' has a wrong offset!");

// Function TheK28.K28Remnant.Cosmetic_OnTeleportationPerformedVFX
// 0x0010 (0x0010 - 0x0000)
struct K28Remnant_Cosmetic_OnTeleportationPerformedVFX final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          isSlowTeleportation;                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28Remnant_Cosmetic_OnTeleportationPerformedVFX) == 0x000008, "Wrong alignment on K28Remnant_Cosmetic_OnTeleportationPerformedVFX");
static_assert(sizeof(K28Remnant_Cosmetic_OnTeleportationPerformedVFX) == 0x000010, "Wrong size on K28Remnant_Cosmetic_OnTeleportationPerformedVFX");
static_assert(offsetof(K28Remnant_Cosmetic_OnTeleportationPerformedVFX, killer) == 0x000000, "Member 'K28Remnant_Cosmetic_OnTeleportationPerformedVFX::killer' has a wrong offset!");
static_assert(offsetof(K28Remnant_Cosmetic_OnTeleportationPerformedVFX, isSlowTeleportation) == 0x000008, "Member 'K28Remnant_Cosmetic_OnTeleportationPerformedVFX::isSlowTeleportation' has a wrong offset!");

// Function TheK28.K28Remnant.Cosmetic_OnTeleportationStartVFX
// 0x0008 (0x0008 - 0x0000)
struct K28Remnant_Cosmetic_OnTeleportationStartVFX final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Remnant_Cosmetic_OnTeleportationStartVFX) == 0x000008, "Wrong alignment on K28Remnant_Cosmetic_OnTeleportationStartVFX");
static_assert(sizeof(K28Remnant_Cosmetic_OnTeleportationStartVFX) == 0x000008, "Wrong size on K28Remnant_Cosmetic_OnTeleportationStartVFX");
static_assert(offsetof(K28Remnant_Cosmetic_OnTeleportationStartVFX, killer) == 0x000000, "Member 'K28Remnant_Cosmetic_OnTeleportationStartVFX::killer' has a wrong offset!");

// Function TheK28.K28Remnant.Cosmetic_SurvivorDestroyedRemnant
// 0x0008 (0x0008 - 0x0000)
struct K28Remnant_Cosmetic_SurvivorDestroyedRemnant final
{
public:
	class ACamperPlayer*                          survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Remnant_Cosmetic_SurvivorDestroyedRemnant) == 0x000008, "Wrong alignment on K28Remnant_Cosmetic_SurvivorDestroyedRemnant");
static_assert(sizeof(K28Remnant_Cosmetic_SurvivorDestroyedRemnant) == 0x000008, "Wrong size on K28Remnant_Cosmetic_SurvivorDestroyedRemnant");
static_assert(offsetof(K28Remnant_Cosmetic_SurvivorDestroyedRemnant, survivor) == 0x000000, "Member 'K28Remnant_Cosmetic_SurvivorDestroyedRemnant::survivor' has a wrong offset!");

// Function TheK28.K28Remnant.Multicast_ActivateRemnant
// 0x0018 (0x0018 - 0x0000)
struct K28Remnant_Multicast_ActivateRemnant final
{
public:
	struct FVector                                location;                                          // 0x0000(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               rotation;                                          // 0x000C(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Remnant_Multicast_ActivateRemnant) == 0x000004, "Wrong alignment on K28Remnant_Multicast_ActivateRemnant");
static_assert(sizeof(K28Remnant_Multicast_ActivateRemnant) == 0x000018, "Wrong size on K28Remnant_Multicast_ActivateRemnant");
static_assert(offsetof(K28Remnant_Multicast_ActivateRemnant, location) == 0x000000, "Member 'K28Remnant_Multicast_ActivateRemnant::location' has a wrong offset!");
static_assert(offsetof(K28Remnant_Multicast_ActivateRemnant, rotation) == 0x00000C, "Member 'K28Remnant_Multicast_ActivateRemnant::rotation' has a wrong offset!");

// Function TheK28.K28Remnant.Multicast_SurvivorDestroyedRemnant
// 0x0008 (0x0008 - 0x0000)
struct K28Remnant_Multicast_SurvivorDestroyedRemnant final
{
public:
	class ACamperPlayer*                          survivor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Remnant_Multicast_SurvivorDestroyedRemnant) == 0x000008, "Wrong alignment on K28Remnant_Multicast_SurvivorDestroyedRemnant");
static_assert(sizeof(K28Remnant_Multicast_SurvivorDestroyedRemnant) == 0x000008, "Wrong size on K28Remnant_Multicast_SurvivorDestroyedRemnant");
static_assert(offsetof(K28Remnant_Multicast_SurvivorDestroyedRemnant, survivor) == 0x000000, "Member 'K28Remnant_Multicast_SurvivorDestroyedRemnant::survivor' has a wrong offset!");

// Function TheK28.K28Remnant.Multicast_TeleportToRemnant
// 0x0018 (0x0018 - 0x0000)
struct K28Remnant_Multicast_TeleportToRemnant final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               teleportRotation;                                  // 0x0008(0x000C)(ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          isAnimationSlowed;                                 // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28Remnant_Multicast_TeleportToRemnant) == 0x000008, "Wrong alignment on K28Remnant_Multicast_TeleportToRemnant");
static_assert(sizeof(K28Remnant_Multicast_TeleportToRemnant) == 0x000018, "Wrong size on K28Remnant_Multicast_TeleportToRemnant");
static_assert(offsetof(K28Remnant_Multicast_TeleportToRemnant, killer) == 0x000000, "Member 'K28Remnant_Multicast_TeleportToRemnant::killer' has a wrong offset!");
static_assert(offsetof(K28Remnant_Multicast_TeleportToRemnant, teleportRotation) == 0x000008, "Member 'K28Remnant_Multicast_TeleportToRemnant::teleportRotation' has a wrong offset!");
static_assert(offsetof(K28Remnant_Multicast_TeleportToRemnant, isAnimationSlowed) == 0x000014, "Member 'K28Remnant_Multicast_TeleportToRemnant::isAnimationSlowed' has a wrong offset!");

// Function TheK28.K28Remnant.Multicast_TriggerTeleportStart
// 0x0008 (0x0008 - 0x0000)
struct K28Remnant_Multicast_TriggerTeleportStart final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Remnant_Multicast_TriggerTeleportStart) == 0x000008, "Wrong alignment on K28Remnant_Multicast_TriggerTeleportStart");
static_assert(sizeof(K28Remnant_Multicast_TriggerTeleportStart) == 0x000008, "Wrong size on K28Remnant_Multicast_TriggerTeleportStart");
static_assert(offsetof(K28Remnant_Multicast_TriggerTeleportStart, killer) == 0x000000, "Member 'K28Remnant_Multicast_TriggerTeleportStart::killer' has a wrong offset!");

// Function TheK28.K28RemnantAnimInstance.ConsumeSurvivorWhoDestroyedRemnant
// 0x0008 (0x0008 - 0x0000)
struct K28RemnantAnimInstance_ConsumeSurvivorWhoDestroyedRemnant final
{
public:
	class ACamperPlayer*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28RemnantAnimInstance_ConsumeSurvivorWhoDestroyedRemnant) == 0x000008, "Wrong alignment on K28RemnantAnimInstance_ConsumeSurvivorWhoDestroyedRemnant");
static_assert(sizeof(K28RemnantAnimInstance_ConsumeSurvivorWhoDestroyedRemnant) == 0x000008, "Wrong size on K28RemnantAnimInstance_ConsumeSurvivorWhoDestroyedRemnant");
static_assert(offsetof(K28RemnantAnimInstance_ConsumeSurvivorWhoDestroyedRemnant, ReturnValue) == 0x000000, "Member 'K28RemnantAnimInstance_ConsumeSurvivorWhoDestroyedRemnant::ReturnValue' has a wrong offset!");

// Function TheK28.K28SecondaryCamera.Cosmetic_OnIsLocallyObservingKillerChanged
// 0x0001 (0x0001 - 0x0000)
struct K28SecondaryCamera_Cosmetic_OnIsLocallyObservingKillerChanged final
{
public:
	bool                                          isLocallyObservingKiller;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SecondaryCamera_Cosmetic_OnIsLocallyObservingKillerChanged) == 0x000001, "Wrong alignment on K28SecondaryCamera_Cosmetic_OnIsLocallyObservingKillerChanged");
static_assert(sizeof(K28SecondaryCamera_Cosmetic_OnIsLocallyObservingKillerChanged) == 0x000001, "Wrong size on K28SecondaryCamera_Cosmetic_OnIsLocallyObservingKillerChanged");
static_assert(offsetof(K28SecondaryCamera_Cosmetic_OnIsLocallyObservingKillerChanged, isLocallyObservingKiller) == 0x000000, "Member 'K28SecondaryCamera_Cosmetic_OnIsLocallyObservingKillerChanged::isLocallyObservingKiller' has a wrong offset!");

// Function TheK28.K28SecondaryCamera.Cosmetic_OnNightCycleChanged
// 0x0001 (0x0001 - 0x0000)
struct K28SecondaryCamera_Cosmetic_OnNightCycleChanged final
{
public:
	EK28NightCycleState                           newNightCycleState;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SecondaryCamera_Cosmetic_OnNightCycleChanged) == 0x000001, "Wrong alignment on K28SecondaryCamera_Cosmetic_OnNightCycleChanged");
static_assert(sizeof(K28SecondaryCamera_Cosmetic_OnNightCycleChanged) == 0x000001, "Wrong size on K28SecondaryCamera_Cosmetic_OnNightCycleChanged");
static_assert(offsetof(K28SecondaryCamera_Cosmetic_OnNightCycleChanged, newNightCycleState) == 0x000000, "Member 'K28SecondaryCamera_Cosmetic_OnNightCycleChanged::newNightCycleState' has a wrong offset!");

// Function TheK28.K28SecondaryCamera.Cosmetic_UpdateDarknessPlaneVisibility
// 0x0001 (0x0001 - 0x0000)
struct K28SecondaryCamera_Cosmetic_UpdateDarknessPlaneVisibility final
{
public:
	bool                                          isVisible;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SecondaryCamera_Cosmetic_UpdateDarknessPlaneVisibility) == 0x000001, "Wrong alignment on K28SecondaryCamera_Cosmetic_UpdateDarknessPlaneVisibility");
static_assert(sizeof(K28SecondaryCamera_Cosmetic_UpdateDarknessPlaneVisibility) == 0x000001, "Wrong size on K28SecondaryCamera_Cosmetic_UpdateDarknessPlaneVisibility");
static_assert(offsetof(K28SecondaryCamera_Cosmetic_UpdateDarknessPlaneVisibility, isVisible) == 0x000000, "Member 'K28SecondaryCamera_Cosmetic_UpdateDarknessPlaneVisibility::isVisible' has a wrong offset!");

// Function TheK28.K28SecondaryCamera.Multicast_SetCameraOrientation
// 0x0010 (0x0010 - 0x0000)
struct K28SecondaryCamera_Multicast_SetCameraOrientation final
{
public:
	struct FRotator                               newOrientation;                                    // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          isRelativeRotation;                                // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28SecondaryCamera_Multicast_SetCameraOrientation) == 0x000004, "Wrong alignment on K28SecondaryCamera_Multicast_SetCameraOrientation");
static_assert(sizeof(K28SecondaryCamera_Multicast_SetCameraOrientation) == 0x000010, "Wrong size on K28SecondaryCamera_Multicast_SetCameraOrientation");
static_assert(offsetof(K28SecondaryCamera_Multicast_SetCameraOrientation, newOrientation) == 0x000000, "Member 'K28SecondaryCamera_Multicast_SetCameraOrientation::newOrientation' has a wrong offset!");
static_assert(offsetof(K28SecondaryCamera_Multicast_SetCameraOrientation, isRelativeRotation) == 0x00000C, "Member 'K28SecondaryCamera_Multicast_SetCameraOrientation::isRelativeRotation' has a wrong offset!");

// Function TheK28.K28SecondaryCamera.Server_SetCameraOrientation
// 0x000C (0x000C - 0x0000)
struct K28SecondaryCamera_Server_SetCameraOrientation final
{
public:
	struct FRotator                               newOrientation;                                    // 0x0000(0x000C)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SecondaryCamera_Server_SetCameraOrientation) == 0x000004, "Wrong alignment on K28SecondaryCamera_Server_SetCameraOrientation");
static_assert(sizeof(K28SecondaryCamera_Server_SetCameraOrientation) == 0x00000C, "Wrong size on K28SecondaryCamera_Server_SetCameraOrientation");
static_assert(offsetof(K28SecondaryCamera_Server_SetCameraOrientation, newOrientation) == 0x000000, "Member 'K28SecondaryCamera_Server_SetCameraOrientation::newOrientation' has a wrong offset!");

// Function TheK28.K28SecondaryCamera.Server_SetIsKillerPlayerViewTarget
// 0x0001 (0x0001 - 0x0000)
struct K28SecondaryCamera_Server_SetIsKillerPlayerViewTarget final
{
public:
	bool                                          isKillerPlayerViewTarget;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SecondaryCamera_Server_SetIsKillerPlayerViewTarget) == 0x000001, "Wrong alignment on K28SecondaryCamera_Server_SetIsKillerPlayerViewTarget");
static_assert(sizeof(K28SecondaryCamera_Server_SetIsKillerPlayerViewTarget) == 0x000001, "Wrong size on K28SecondaryCamera_Server_SetIsKillerPlayerViewTarget");
static_assert(offsetof(K28SecondaryCamera_Server_SetIsKillerPlayerViewTarget, isKillerPlayerViewTarget) == 0x000000, "Member 'K28SecondaryCamera_Server_SetIsKillerPlayerViewTarget::isKillerPlayerViewTarget' has a wrong offset!");

// Function TheK28.K28SecondaryCamera.GetCameraWorldRotation
// 0x000C (0x000C - 0x0000)
struct K28SecondaryCamera_GetCameraWorldRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SecondaryCamera_GetCameraWorldRotation) == 0x000004, "Wrong alignment on K28SecondaryCamera_GetCameraWorldRotation");
static_assert(sizeof(K28SecondaryCamera_GetCameraWorldRotation) == 0x00000C, "Wrong size on K28SecondaryCamera_GetCameraWorldRotation");
static_assert(offsetof(K28SecondaryCamera_GetCameraWorldRotation, ReturnValue) == 0x000000, "Member 'K28SecondaryCamera_GetCameraWorldRotation::ReturnValue' has a wrong offset!");

// Function TheK28.K28SecondaryCamera.GetIsKillerPlayerViewTarget
// 0x0001 (0x0001 - 0x0000)
struct K28SecondaryCamera_GetIsKillerPlayerViewTarget final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SecondaryCamera_GetIsKillerPlayerViewTarget) == 0x000001, "Wrong alignment on K28SecondaryCamera_GetIsKillerPlayerViewTarget");
static_assert(sizeof(K28SecondaryCamera_GetIsKillerPlayerViewTarget) == 0x000001, "Wrong size on K28SecondaryCamera_GetIsKillerPlayerViewTarget");
static_assert(offsetof(K28SecondaryCamera_GetIsKillerPlayerViewTarget, ReturnValue) == 0x000000, "Member 'K28SecondaryCamera_GetIsKillerPlayerViewTarget::ReturnValue' has a wrong offset!");

// Function TheK28.K28SurvivorComponent.OnKillerInRangeChanged
// 0x0001 (0x0001 - 0x0000)
struct K28SurvivorComponent_OnKillerInRangeChanged final
{
public:
	bool                                          inRange;                                           // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SurvivorComponent_OnKillerInRangeChanged) == 0x000001, "Wrong alignment on K28SurvivorComponent_OnKillerInRangeChanged");
static_assert(sizeof(K28SurvivorComponent_OnKillerInRangeChanged) == 0x000001, "Wrong size on K28SurvivorComponent_OnKillerInRangeChanged");
static_assert(offsetof(K28SurvivorComponent_OnKillerInRangeChanged, inRange) == 0x000000, "Member 'K28SurvivorComponent_OnKillerInRangeChanged::inRange' has a wrong offset!");

// Function TheK28.K28SurvivorCosmeticHelperActor.Cosmetic_OnNightCycleChanged
// 0x0001 (0x0001 - 0x0000)
struct K28SurvivorCosmeticHelperActor_Cosmetic_OnNightCycleChanged final
{
public:
	EK28NightCycleState                           nightCycleState;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SurvivorCosmeticHelperActor_Cosmetic_OnNightCycleChanged) == 0x000001, "Wrong alignment on K28SurvivorCosmeticHelperActor_Cosmetic_OnNightCycleChanged");
static_assert(sizeof(K28SurvivorCosmeticHelperActor_Cosmetic_OnNightCycleChanged) == 0x000001, "Wrong size on K28SurvivorCosmeticHelperActor_Cosmetic_OnNightCycleChanged");
static_assert(offsetof(K28SurvivorCosmeticHelperActor_Cosmetic_OnNightCycleChanged, nightCycleState) == 0x000000, "Member 'K28SurvivorCosmeticHelperActor_Cosmetic_OnNightCycleChanged::nightCycleState' has a wrong offset!");

// Function TheK28.K28SurvivorCosmeticHelperActor.GetDarknessPlaneMesh
// 0x0008 (0x0008 - 0x0000)
struct K28SurvivorCosmeticHelperActor_GetDarknessPlaneMesh final
{
public:
	class UStaticMeshComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28SurvivorCosmeticHelperActor_GetDarknessPlaneMesh) == 0x000008, "Wrong alignment on K28SurvivorCosmeticHelperActor_GetDarknessPlaneMesh");
static_assert(sizeof(K28SurvivorCosmeticHelperActor_GetDarknessPlaneMesh) == 0x000008, "Wrong size on K28SurvivorCosmeticHelperActor_GetDarknessPlaneMesh");
static_assert(offsetof(K28SurvivorCosmeticHelperActor_GetDarknessPlaneMesh, ReturnValue) == 0x000000, "Member 'K28SurvivorCosmeticHelperActor_GetDarknessPlaneMesh::ReturnValue' has a wrong offset!");

// Function TheK28.K28TeleportationStrategyComponent.Multicast_UpdateBestTeleportTarget
// 0x0004 (0x0004 - 0x0000)
struct K28TeleportationStrategyComponent_Multicast_UpdateBestTeleportTarget final
{
public:
	int32                                         bestTeleportTargetID;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28TeleportationStrategyComponent_Multicast_UpdateBestTeleportTarget) == 0x000004, "Wrong alignment on K28TeleportationStrategyComponent_Multicast_UpdateBestTeleportTarget");
static_assert(sizeof(K28TeleportationStrategyComponent_Multicast_UpdateBestTeleportTarget) == 0x000004, "Wrong size on K28TeleportationStrategyComponent_Multicast_UpdateBestTeleportTarget");
static_assert(offsetof(K28TeleportationStrategyComponent_Multicast_UpdateBestTeleportTarget, bestTeleportTargetID) == 0x000000, "Member 'K28TeleportationStrategyComponent_Multicast_UpdateBestTeleportTarget::bestTeleportTargetID' has a wrong offset!");

// Function TheK28.K28TeleportationStrategyComponent.Server_UpdateBestTeleportTarget
// 0x0004 (0x0004 - 0x0000)
struct K28TeleportationStrategyComponent_Server_UpdateBestTeleportTarget final
{
public:
	int32                                         bestTeleportTargetID;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28TeleportationStrategyComponent_Server_UpdateBestTeleportTarget) == 0x000004, "Wrong alignment on K28TeleportationStrategyComponent_Server_UpdateBestTeleportTarget");
static_assert(sizeof(K28TeleportationStrategyComponent_Server_UpdateBestTeleportTarget) == 0x000004, "Wrong size on K28TeleportationStrategyComponent_Server_UpdateBestTeleportTarget");
static_assert(offsetof(K28TeleportationStrategyComponent_Server_UpdateBestTeleportTarget, bestTeleportTargetID) == 0x000000, "Member 'K28TeleportationStrategyComponent_Server_UpdateBestTeleportTarget::bestTeleportTargetID' has a wrong offset!");

// Function TheK28.K28TeleportInteraction.Multicast_ConfirmTeleportationRequest
// 0x0010 (0x0010 - 0x0000)
struct K28TeleportInteraction_Multicast_ConfirmTeleportationRequest final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                teleportTarget;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28TeleportInteraction_Multicast_ConfirmTeleportationRequest) == 0x000008, "Wrong alignment on K28TeleportInteraction_Multicast_ConfirmTeleportationRequest");
static_assert(sizeof(K28TeleportInteraction_Multicast_ConfirmTeleportationRequest) == 0x000010, "Wrong size on K28TeleportInteraction_Multicast_ConfirmTeleportationRequest");
static_assert(offsetof(K28TeleportInteraction_Multicast_ConfirmTeleportationRequest, killer) == 0x000000, "Member 'K28TeleportInteraction_Multicast_ConfirmTeleportationRequest::killer' has a wrong offset!");
static_assert(offsetof(K28TeleportInteraction_Multicast_ConfirmTeleportationRequest, teleportTarget) == 0x000008, "Member 'K28TeleportInteraction_Multicast_ConfirmTeleportationRequest::teleportTarget' has a wrong offset!");

// Function TheK28.K28TeleportInteraction.Server_RequestTeleportToTarget
// 0x0010 (0x0010 - 0x0000)
struct K28TeleportInteraction_Server_RequestTeleportToTarget final
{
public:
	class ASlasherPlayer*                         killer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                teleportTarget;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28TeleportInteraction_Server_RequestTeleportToTarget) == 0x000008, "Wrong alignment on K28TeleportInteraction_Server_RequestTeleportToTarget");
static_assert(sizeof(K28TeleportInteraction_Server_RequestTeleportToTarget) == 0x000010, "Wrong size on K28TeleportInteraction_Server_RequestTeleportToTarget");
static_assert(offsetof(K28TeleportInteraction_Server_RequestTeleportToTarget, killer) == 0x000000, "Member 'K28TeleportInteraction_Server_RequestTeleportToTarget::killer' has a wrong offset!");
static_assert(offsetof(K28TeleportInteraction_Server_RequestTeleportToTarget, teleportTarget) == 0x000008, "Member 'K28TeleportInteraction_Server_RequestTeleportToTarget::teleportTarget' has a wrong offset!");

// Function TheK28.K28Utilities.GetDayNightComponent
// 0x0010 (0x0010 - 0x0000)
struct K28Utilities_GetDayNightComponent final
{
public:
	const class UObject*                          worldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UK28DayNightComponent*                  ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Utilities_GetDayNightComponent) == 0x000008, "Wrong alignment on K28Utilities_GetDayNightComponent");
static_assert(sizeof(K28Utilities_GetDayNightComponent) == 0x000010, "Wrong size on K28Utilities_GetDayNightComponent");
static_assert(offsetof(K28Utilities_GetDayNightComponent, worldContextObject) == 0x000000, "Member 'K28Utilities_GetDayNightComponent::worldContextObject' has a wrong offset!");
static_assert(offsetof(K28Utilities_GetDayNightComponent, ReturnValue) == 0x000008, "Member 'K28Utilities_GetDayNightComponent::ReturnValue' has a wrong offset!");

// Function TheK28.K28Utilities.GetK28Power
// 0x0010 (0x0010 - 0x0000)
struct K28Utilities_GetK28Power final
{
public:
	const class UObject*                          worldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK28Power*                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Utilities_GetK28Power) == 0x000008, "Wrong alignment on K28Utilities_GetK28Power");
static_assert(sizeof(K28Utilities_GetK28Power) == 0x000010, "Wrong size on K28Utilities_GetK28Power");
static_assert(offsetof(K28Utilities_GetK28Power, worldContextObject) == 0x000000, "Member 'K28Utilities_GetK28Power::worldContextObject' has a wrong offset!");
static_assert(offsetof(K28Utilities_GetK28Power, ReturnValue) == 0x000008, "Member 'K28Utilities_GetK28Power::ReturnValue' has a wrong offset!");

// Function TheK28.K28Utilities.GetRemnant
// 0x0010 (0x0010 - 0x0000)
struct K28Utilities_GetRemnant final
{
public:
	const class UObject*                          worldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK28Remnant*                            ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Utilities_GetRemnant) == 0x000008, "Wrong alignment on K28Utilities_GetRemnant");
static_assert(sizeof(K28Utilities_GetRemnant) == 0x000010, "Wrong size on K28Utilities_GetRemnant");
static_assert(offsetof(K28Utilities_GetRemnant, worldContextObject) == 0x000000, "Member 'K28Utilities_GetRemnant::worldContextObject' has a wrong offset!");
static_assert(offsetof(K28Utilities_GetRemnant, ReturnValue) == 0x000008, "Member 'K28Utilities_GetRemnant::ReturnValue' has a wrong offset!");

// Function TheK28.K28Utilities.GetSecondaryCamera
// 0x0010 (0x0010 - 0x0000)
struct K28Utilities_GetSecondaryCamera final
{
public:
	const class UObject*                          worldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AK28SecondaryCamera*                    ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Utilities_GetSecondaryCamera) == 0x000008, "Wrong alignment on K28Utilities_GetSecondaryCamera");
static_assert(sizeof(K28Utilities_GetSecondaryCamera) == 0x000010, "Wrong size on K28Utilities_GetSecondaryCamera");
static_assert(offsetof(K28Utilities_GetSecondaryCamera, worldContextObject) == 0x000000, "Member 'K28Utilities_GetSecondaryCamera::worldContextObject' has a wrong offset!");
static_assert(offsetof(K28Utilities_GetSecondaryCamera, ReturnValue) == 0x000008, "Member 'K28Utilities_GetSecondaryCamera::ReturnValue' has a wrong offset!");

// Function TheK28.K28Utilities.GetTeleportationStrategyComponent
// 0x0010 (0x0010 - 0x0000)
struct K28Utilities_GetTeleportationStrategyComponent final
{
public:
	const class UObject*                          worldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UK28TeleportationStrategyComponent*     ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(K28Utilities_GetTeleportationStrategyComponent) == 0x000008, "Wrong alignment on K28Utilities_GetTeleportationStrategyComponent");
static_assert(sizeof(K28Utilities_GetTeleportationStrategyComponent) == 0x000010, "Wrong size on K28Utilities_GetTeleportationStrategyComponent");
static_assert(offsetof(K28Utilities_GetTeleportationStrategyComponent, worldContextObject) == 0x000000, "Member 'K28Utilities_GetTeleportationStrategyComponent::worldContextObject' has a wrong offset!");
static_assert(offsetof(K28Utilities_GetTeleportationStrategyComponent, ReturnValue) == 0x000008, "Member 'K28Utilities_GetTeleportationStrategyComponent::ReturnValue' has a wrong offset!");

// Function TheK28.K28Utilities.IsLockerUsedByKillerLocked
// 0x0010 (0x0010 - 0x0000)
struct K28Utilities_IsLockerUsedByKillerLocked final
{
public:
	const class UObject*                          worldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(K28Utilities_IsLockerUsedByKillerLocked) == 0x000008, "Wrong alignment on K28Utilities_IsLockerUsedByKillerLocked");
static_assert(sizeof(K28Utilities_IsLockerUsedByKillerLocked) == 0x000010, "Wrong size on K28Utilities_IsLockerUsedByKillerLocked");
static_assert(offsetof(K28Utilities_IsLockerUsedByKillerLocked, worldContextObject) == 0x000000, "Member 'K28Utilities_IsLockerUsedByKillerLocked::worldContextObject' has a wrong offset!");
static_assert(offsetof(K28Utilities_IsLockerUsedByKillerLocked, ReturnValue) == 0x000008, "Member 'K28Utilities_IsLockerUsedByKillerLocked::ReturnValue' has a wrong offset!");

}

