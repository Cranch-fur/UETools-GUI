#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheOni

#include "Basic.hpp"

#include "DBDGameplay_classes.hpp"
#include "TheOni_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDBots_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_classes.hpp"
#include "DBDCompetence_classes.hpp"
#include "DBDAttack_classes.hpp"
#include "AnimationUtilities_structs.hpp"


namespace SDK
{

// Class TheOni.AbsorbBloodOrbsInteraction
// 0x0030 (0x0650 - 0x0620)
class UAbsorbBloodOrbsInteraction final : public UInteractionDefinition
{
public:
	uint8                                         Pad_618[0x38];                                     // 0x0618(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPlayerOwner(const class ADBDPlayer* player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbsorbBloodOrbsInteraction">();
	}
	static class UAbsorbBloodOrbsInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbsorbBloodOrbsInteraction>();
	}
};
static_assert(alignof(UAbsorbBloodOrbsInteraction) == 0x000010, "Wrong alignment on UAbsorbBloodOrbsInteraction");
static_assert(sizeof(UAbsorbBloodOrbsInteraction) == 0x000650, "Wrong size on UAbsorbBloodOrbsInteraction");

// Class TheOni.AISkill_FindOrb
// 0x0008 (0x0118 - 0x0110)
class UAISkill_FindOrb final : public UAISkill_Find
{
public:
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_FindOrb">();
	}
	static class UAISkill_FindOrb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_FindOrb>();
	}
};
static_assert(alignof(UAISkill_FindOrb) == 0x000008, "Wrong alignment on UAISkill_FindOrb");
static_assert(sizeof(UAISkill_FindOrb) == 0x000118, "Wrong size on UAISkill_FindOrb");

// Class TheOni.AISkill_Interaction_OrbAbsorb
// 0x0000 (0x0180 - 0x0180)
class UAISkill_Interaction_OrbAbsorb final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_OrbAbsorb">();
	}
	static class UAISkill_Interaction_OrbAbsorb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_OrbAbsorb>();
	}
};
static_assert(alignof(UAISkill_Interaction_OrbAbsorb) == 0x000008, "Wrong alignment on UAISkill_Interaction_OrbAbsorb");
static_assert(sizeof(UAISkill_Interaction_OrbAbsorb) == 0x000180, "Wrong size on UAISkill_Interaction_OrbAbsorb");

// Class TheOni.AISkill_InteractionTarget_DashOni
// 0x0000 (0x0230 - 0x0230)
class UAISkill_InteractionTarget_DashOni final : public UAISkill_InteractionTarget_Dash
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_DashOni">();
	}
	static class UAISkill_InteractionTarget_DashOni* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_DashOni>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_DashOni) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_DashOni");
static_assert(sizeof(UAISkill_InteractionTarget_DashOni) == 0x000230, "Wrong size on UAISkill_InteractionTarget_DashOni");

// Class TheOni.AISkill_InteractionTarget_DemonMode
// 0x0000 (0x0230 - 0x0230)
class UAISkill_InteractionTarget_DemonMode final : public UAISkill_InteractionTarget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_InteractionTarget_DemonMode">();
	}
	static class UAISkill_InteractionTarget_DemonMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_InteractionTarget_DemonMode>();
	}
};
static_assert(alignof(UAISkill_InteractionTarget_DemonMode) == 0x000008, "Wrong alignment on UAISkill_InteractionTarget_DemonMode");
static_assert(sizeof(UAISkill_InteractionTarget_DemonMode) == 0x000230, "Wrong size on UAISkill_InteractionTarget_DemonMode");

// Class TheOni.BloodOrb
// 0x0060 (0x0290 - 0x0230)
class ABloodOrb final : public AActor
{
public:
	struct FFloatInterval                         _randomMoveDelayInterval;                          // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _absorbReference;                                  // 0x0238(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x0240(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _despawnDelay;                                     // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24C[0x4];                                      // 0x024C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ADBDPlayer>              _droppingPlayer;                                   // 0x0250(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBloodOrbState                                _state;                                            // 0x0258(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBloodOrbFadeComponent*                 _fadeComponent;                                    // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_268[0x28];                                     // 0x0268(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_Despawn();
	void Authority_DestroyBloodOrb();
	void Authority_OnDropFinished();
	void Authority_OnDropped(const class ADBDPlayer* droppedBy, const float impulseFactor);
	void OnAbsorbedCosmetic();
	void OnDestroyedCosmetic();
	void OnIsAttractedChangedCosmetic(const bool isAttracted);
	void OnRep_State(const EBloodOrbState oldState);
	void UpdateAbsorbed_Cosmetic(const struct FVector& destination, class ADBDPlayer* absorber, const float deltaTime);
	void UpdateAttracted_Cosmetic(const struct FVector& destination, class ADBDPlayer* absorber, const float deltaTime);

	class ADBDPlayer* GetDroppingPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrb">();
	}
	static class ABloodOrb* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABloodOrb>();
	}
};
static_assert(alignof(ABloodOrb) == 0x000008, "Wrong alignment on ABloodOrb");
static_assert(sizeof(ABloodOrb) == 0x000290, "Wrong size on ABloodOrb");
static_assert(offsetof(ABloodOrb, _randomMoveDelayInterval) == 0x000230, "Member 'ABloodOrb::_randomMoveDelayInterval' has a wrong offset!");
static_assert(offsetof(ABloodOrb, _absorbReference) == 0x000238, "Member 'ABloodOrb::_absorbReference' has a wrong offset!");
static_assert(offsetof(ABloodOrb, _outlineComponent) == 0x000240, "Member 'ABloodOrb::_outlineComponent' has a wrong offset!");
static_assert(offsetof(ABloodOrb, _despawnDelay) == 0x000248, "Member 'ABloodOrb::_despawnDelay' has a wrong offset!");
static_assert(offsetof(ABloodOrb, _droppingPlayer) == 0x000250, "Member 'ABloodOrb::_droppingPlayer' has a wrong offset!");
static_assert(offsetof(ABloodOrb, _state) == 0x000258, "Member 'ABloodOrb::_state' has a wrong offset!");
static_assert(offsetof(ABloodOrb, _fadeComponent) == 0x000260, "Member 'ABloodOrb::_fadeComponent' has a wrong offset!");

// Class TheOni.BloodOrbAbsorberComponent
// 0x0058 (0x0110 - 0x00B8)
class UBloodOrbAbsorberComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class ABloodOrb* bloodOrb)> Authority_OnBloodOrbAbsorbed;          // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(bool isAbsorbing)> OnIsAbsorbingChanged;                           // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                AbsorbLocationOffset;                              // 0x00D8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x1C];                                      // 0x00E4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBloodOrbDropperComponent*>      _camperBloodOrbDropperComponents;                  // 0x0100(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void SetInAbsorbMode(const bool inAbsorptionMode);

	bool IsInAbsorbMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbAbsorberComponent">();
	}
	static class UBloodOrbAbsorberComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbAbsorberComponent>();
	}
};
static_assert(alignof(UBloodOrbAbsorberComponent) == 0x000008, "Wrong alignment on UBloodOrbAbsorberComponent");
static_assert(sizeof(UBloodOrbAbsorberComponent) == 0x000110, "Wrong size on UBloodOrbAbsorberComponent");
static_assert(offsetof(UBloodOrbAbsorberComponent, Authority_OnBloodOrbAbsorbed) == 0x0000B8, "Member 'UBloodOrbAbsorberComponent::Authority_OnBloodOrbAbsorbed' has a wrong offset!");
static_assert(offsetof(UBloodOrbAbsorberComponent, OnIsAbsorbingChanged) == 0x0000C8, "Member 'UBloodOrbAbsorberComponent::OnIsAbsorbingChanged' has a wrong offset!");
static_assert(offsetof(UBloodOrbAbsorberComponent, AbsorbLocationOffset) == 0x0000D8, "Member 'UBloodOrbAbsorberComponent::AbsorbLocationOffset' has a wrong offset!");
static_assert(offsetof(UBloodOrbAbsorberComponent, _camperBloodOrbDropperComponents) == 0x000100, "Member 'UBloodOrbAbsorberComponent::_camperBloodOrbDropperComponents' has a wrong offset!");

// Class TheOni.BloodOrbCollection
// 0x0048 (0x0100 - 0x00B8)
class UBloodOrbCollection final : public UActorComponent
{
public:
	TArray<class ABloodOrb*>                      _bloodOrbs;                                        // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x38];                                      // 0x00C8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbCollection">();
	}
	static class UBloodOrbCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbCollection>();
	}
};
static_assert(alignof(UBloodOrbCollection) == 0x000008, "Wrong alignment on UBloodOrbCollection");
static_assert(sizeof(UBloodOrbCollection) == 0x000100, "Wrong size on UBloodOrbCollection");
static_assert(offsetof(UBloodOrbCollection, _bloodOrbs) == 0x0000B8, "Member 'UBloodOrbCollection::_bloodOrbs' has a wrong offset!");

// Class TheOni.BloodOrbConfiguratorComponent
// 0x0070 (0x0128 - 0x00B8)
class UBloodOrbConfiguratorComponent final : public UActorComponent
{
public:
	TSubclassOf<class ABloodOrb>                  _bloodOrbClass;                                    // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGameEventBloodOrbDropParams>   _bloodOrbDropGameEvents;                           // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         _fadeDuration;                                     // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _initialFadeOutDelay;                              // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _bloodOrbAuraColor;                                // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _bloodOrbAttractedAuraColor;                       // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _bloodOrbVisibilityRangeInterpolationSpeed;        // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AMobileBloodOrbRenderer>    _mobileBloodOrbRendererClass;                      // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

	void Authority_UpdateSurvivorBloodOrbDropperOnCrouchModifier(const class ADBDPlayer* killer) const;
	void UpdateBloodOrbAttractSpeed(class UBloodOrbAbsorberComponent* bloodOrbAbsorberComponent, class ADBDPlayer* killer) const;
	void UpdateKillerBloodOrbVisiblityRanges(class UBloodOrbVisibilityComponent* bloodOrbVisibilityComponent, class ADBDPlayer* killer) const;
	void UpdateSurvivorBloodOrbVisibilityRange(class UBloodOrbVisibilityComponent* bloodOrbVisibilityComponent, const class ADBDPlayer* killer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbConfiguratorComponent">();
	}
	static class UBloodOrbConfiguratorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbConfiguratorComponent>();
	}
};
static_assert(alignof(UBloodOrbConfiguratorComponent) == 0x000008, "Wrong alignment on UBloodOrbConfiguratorComponent");
static_assert(sizeof(UBloodOrbConfiguratorComponent) == 0x000128, "Wrong size on UBloodOrbConfiguratorComponent");
static_assert(offsetof(UBloodOrbConfiguratorComponent, _bloodOrbClass) == 0x0000B8, "Member 'UBloodOrbConfiguratorComponent::_bloodOrbClass' has a wrong offset!");
static_assert(offsetof(UBloodOrbConfiguratorComponent, _bloodOrbDropGameEvents) == 0x0000C0, "Member 'UBloodOrbConfiguratorComponent::_bloodOrbDropGameEvents' has a wrong offset!");
static_assert(offsetof(UBloodOrbConfiguratorComponent, _fadeDuration) == 0x0000D0, "Member 'UBloodOrbConfiguratorComponent::_fadeDuration' has a wrong offset!");
static_assert(offsetof(UBloodOrbConfiguratorComponent, _initialFadeOutDelay) == 0x0000D4, "Member 'UBloodOrbConfiguratorComponent::_initialFadeOutDelay' has a wrong offset!");
static_assert(offsetof(UBloodOrbConfiguratorComponent, _bloodOrbAuraColor) == 0x0000D8, "Member 'UBloodOrbConfiguratorComponent::_bloodOrbAuraColor' has a wrong offset!");
static_assert(offsetof(UBloodOrbConfiguratorComponent, _bloodOrbAttractedAuraColor) == 0x0000E8, "Member 'UBloodOrbConfiguratorComponent::_bloodOrbAttractedAuraColor' has a wrong offset!");
static_assert(offsetof(UBloodOrbConfiguratorComponent, _bloodOrbVisibilityRangeInterpolationSpeed) == 0x0000F8, "Member 'UBloodOrbConfiguratorComponent::_bloodOrbVisibilityRangeInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UBloodOrbConfiguratorComponent, _mobileBloodOrbRendererClass) == 0x000100, "Member 'UBloodOrbConfiguratorComponent::_mobileBloodOrbRendererClass' has a wrong offset!");

// Class TheOni.BloodOrbDropperComponent
// 0x0080 (0x0138 - 0x00B8)
class UBloodOrbDropperComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x80];                                      // 0x00B8(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCamperCrouched(const struct FGameplayTag& gameEvent, const struct FGameEventData& gameEventData);
	void Authority_OnCamperUnhooked(const struct FGameplayTag& gameEvent, const struct FGameEventData& gameEventData);
	void Authority_OnOwningCamperDamageStateChanged(const ECamperDamageState oldState, const ECamperDamageState newState);
	void Authority_SetPaused(const bool paused);

	void Authority_OnCamperHooked(const struct FGameplayTag& gameEvent, const struct FGameEventData& gameEventData) const;
	void Authority_OnDropOrbsGameEvent(const struct FGameplayTag& gameEvent, const struct FGameEventData& gameEventData, const struct FBloodOrbDropParams& dropParams) const;
	void DBD_DropBloodOrbs(const int32 numOrbs) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbDropperComponent">();
	}
	static class UBloodOrbDropperComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbDropperComponent>();
	}
};
static_assert(alignof(UBloodOrbDropperComponent) == 0x000008, "Wrong alignment on UBloodOrbDropperComponent");
static_assert(sizeof(UBloodOrbDropperComponent) == 0x000138, "Wrong size on UBloodOrbDropperComponent");

// Class TheOni.BloodOrbFadeComponent
// 0x0008 (0x00E0 - 0x00D8)
class UBloodOrbFadeComponent final : public UFadeComponent
{
public:
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbFadeComponent">();
	}
	static class UBloodOrbFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbFadeComponent>();
	}
};
static_assert(alignof(UBloodOrbFadeComponent) == 0x000008, "Wrong alignment on UBloodOrbFadeComponent");
static_assert(sizeof(UBloodOrbFadeComponent) == 0x0000E0, "Wrong size on UBloodOrbFadeComponent");

// Class TheOni.BloodOrbOverlapComponent
// 0x0040 (0x00F8 - 0x00B8)
class UBloodOrbOverlapComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _currentOverlappingOrbs;                           // 0x00C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x34];                                      // 0x00C4(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnBloodOrbBeginOverlap(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult);
	void Authority_OnBloodOrbEndOverlap(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex);
	void Authority_OnBloodOrbVisibilityModeChanged(EBloodOrbVisibilityMode visibilityMode);
	void Authority_OnDestroyedBloodOrb(class AActor* destroyedActor);
	void OnRep_CurrentOverlappingOrbs(int32 previousOverlappingOrbs);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbOverlapComponent">();
	}
	static class UBloodOrbOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbOverlapComponent>();
	}
};
static_assert(alignof(UBloodOrbOverlapComponent) == 0x000008, "Wrong alignment on UBloodOrbOverlapComponent");
static_assert(sizeof(UBloodOrbOverlapComponent) == 0x0000F8, "Wrong size on UBloodOrbOverlapComponent");
static_assert(offsetof(UBloodOrbOverlapComponent, _currentOverlappingOrbs) == 0x0000C0, "Member 'UBloodOrbOverlapComponent::_currentOverlappingOrbs' has a wrong offset!");

// Class TheOni.BloodOrbOverlapRevealToKiller
// 0x0028 (0x0378 - 0x0350)
class UBloodOrbOverlapRevealToKiller final : public UStatusEffect
{
public:
	uint8                                         Pad_350[0x28];                                     // 0x0350(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbOverlapRevealToKiller">();
	}
	static class UBloodOrbOverlapRevealToKiller* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbOverlapRevealToKiller>();
	}
};
static_assert(alignof(UBloodOrbOverlapRevealToKiller) == 0x000008, "Wrong alignment on UBloodOrbOverlapRevealToKiller");
static_assert(sizeof(UBloodOrbOverlapRevealToKiller) == 0x000378, "Wrong size on UBloodOrbOverlapRevealToKiller");

// Class TheOni.BloodOrbStateMonitorComponent
// 0x0070 (0x0128 - 0x00B8)
class UBloodOrbStateMonitorComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class ABloodOrb* bloodOrb)> OnBloodOrbAbsorbedCosmetic;            // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x60];                                      // 0x00C8(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBloodOrbDestroyed(const class ABloodOrb* bloodOrb);
	void OnBloodOrbSpawned(const class ABloodOrb* bloodOrb);

	void OnBloodOrbStateChanged(const EBloodOrbState oldState, const EBloodOrbState newState, const class ABloodOrb* bloodOrb) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbStateMonitorComponent">();
	}
	static class UBloodOrbStateMonitorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbStateMonitorComponent>();
	}
};
static_assert(alignof(UBloodOrbStateMonitorComponent) == 0x000008, "Wrong alignment on UBloodOrbStateMonitorComponent");
static_assert(sizeof(UBloodOrbStateMonitorComponent) == 0x000128, "Wrong size on UBloodOrbStateMonitorComponent");
static_assert(offsetof(UBloodOrbStateMonitorComponent, OnBloodOrbAbsorbedCosmetic) == 0x0000B8, "Member 'UBloodOrbStateMonitorComponent::OnBloodOrbAbsorbedCosmetic' has a wrong offset!");

// Class TheOni.BloodOrbUtilities
// 0x0000 (0x0030 - 0x0030)
class UBloodOrbUtilities final : public UBlueprintFunctionLibrary
{
public:
	static const TArray<class ABloodOrb*> GetAllBloodOrbs(const class UObject* worldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbUtilities">();
	}
	static class UBloodOrbUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbUtilities>();
	}
};
static_assert(alignof(UBloodOrbUtilities) == 0x000008, "Wrong alignment on UBloodOrbUtilities");
static_assert(sizeof(UBloodOrbUtilities) == 0x000030, "Wrong size on UBloodOrbUtilities");

// Class TheOni.BloodOrbVisibilityComponent
// 0x0038 (0x00F0 - 0x00B8)
class UBloodOrbVisibilityComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x38];                                      // 0x00B8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAuraVisibilityRange(const float auraVisibilityRange);
	void SetShowAttractedBloodOrbsAuras(const bool show);
	void SetVisibilityMode(const EBloodOrbVisibilityMode visibilityMode);
	void SetVisibilityRange(const float visibilityRange);

	void OnBloodOrbSpawned(const class ABloodOrb* bloodOrb) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodOrbVisibilityComponent">();
	}
	static class UBloodOrbVisibilityComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodOrbVisibilityComponent>();
	}
};
static_assert(alignof(UBloodOrbVisibilityComponent) == 0x000008, "Wrong alignment on UBloodOrbVisibilityComponent");
static_assert(sizeof(UBloodOrbVisibilityComponent) == 0x0000F0, "Wrong size on UBloodOrbVisibilityComponent");

// Class TheOni.DemonModeComponent
// 0x0118 (0x01D0 - 0x00B8)
class UDemonModeComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnDemonModeReady;                                  // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDemonModeStarted;                                // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDemonModeEnded;                                  // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDemonModeInterruptedDuringStartup;               // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDemonModeInterruptedDuringEnding;                // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FVector& targetLocation)> OnChargeGainedAfterAttackCosmetic; // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ACamperPlayer* camperInLocker)> OnChargeGainedAfterLockerGrabCosmetic; // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPowerChargeComponent*                  _powerChargeComponent;                             // 0x0128(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPowerToggleComponent*                  _powerToggleComponent;                             // 0x0130(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionStarterComponent*           _authority_demonModeCooldownStarterComponent;      // 0x0138(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionDefinition*                 _demonModeCooldownInteraction;                     // 0x0140(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x34];                                     // 0x0148(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	EDemonModeState                               _demonModeState;                                   // 0x017C(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17D[0x53];                                     // 0x017D(0x0053)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AddCharge(const float chargeAmount);
	void Authority_InterruptedMontage(const struct FAnimationMontageDescriptor& montage, bool interrupted);
	void Authority_OnChargeChanged(const float currentChargePercent);
	void Authority_OnLevelReadyToPlay();
	void Authority_SetDemonModeCooldownInteraction(class UInteractionDefinition* interaction);
	void DBD_DemonModeForever(const bool forever);
	void Multicast_DemonModeInterruptedOnEnding();
	void Multicast_DemonModeInterruptedOnStartup();

	bool CanStartDemonMode() const;
	float GetChargePercent() const;
	float GetCurrentCharge() const;
	EDemonModeState GetDemonModeState() const;
	bool IsInDemonMode() const;
	void OnIsPowerChanged(const bool isInPower) const;
	void OnPowerChargeEmpty() const;
	void OnPowerChargeFull() const;
	bool ShouldLoseDemonModeOnStun() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DemonModeComponent">();
	}
	static class UDemonModeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDemonModeComponent>();
	}
};
static_assert(alignof(UDemonModeComponent) == 0x000008, "Wrong alignment on UDemonModeComponent");
static_assert(sizeof(UDemonModeComponent) == 0x0001D0, "Wrong size on UDemonModeComponent");
static_assert(offsetof(UDemonModeComponent, OnDemonModeReady) == 0x0000B8, "Member 'UDemonModeComponent::OnDemonModeReady' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, OnDemonModeStarted) == 0x0000C8, "Member 'UDemonModeComponent::OnDemonModeStarted' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, OnDemonModeEnded) == 0x0000D8, "Member 'UDemonModeComponent::OnDemonModeEnded' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, OnDemonModeInterruptedDuringStartup) == 0x0000E8, "Member 'UDemonModeComponent::OnDemonModeInterruptedDuringStartup' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, OnDemonModeInterruptedDuringEnding) == 0x0000F8, "Member 'UDemonModeComponent::OnDemonModeInterruptedDuringEnding' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, OnChargeGainedAfterAttackCosmetic) == 0x000108, "Member 'UDemonModeComponent::OnChargeGainedAfterAttackCosmetic' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, OnChargeGainedAfterLockerGrabCosmetic) == 0x000118, "Member 'UDemonModeComponent::OnChargeGainedAfterLockerGrabCosmetic' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, _powerChargeComponent) == 0x000128, "Member 'UDemonModeComponent::_powerChargeComponent' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, _powerToggleComponent) == 0x000130, "Member 'UDemonModeComponent::_powerToggleComponent' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, _authority_demonModeCooldownStarterComponent) == 0x000138, "Member 'UDemonModeComponent::_authority_demonModeCooldownStarterComponent' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, _demonModeCooldownInteraction) == 0x000140, "Member 'UDemonModeComponent::_demonModeCooldownInteraction' has a wrong offset!");
static_assert(offsetof(UDemonModeComponent, _demonModeState) == 0x00017C, "Member 'UDemonModeComponent::_demonModeState' has a wrong offset!");

// Class TheOni.DemonModeCooldownInteraction
// 0x0020 (0x0640 - 0x0620)
class UDemonModeCooldownInteraction final : public UInteractionDefinition
{
public:
	uint8                                         Pad_618[0x28];                                     // 0x0618(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();
	void SetPlayerOwner(const class ADBDPlayer* owner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DemonModeCooldownInteraction">();
	}
	static class UDemonModeCooldownInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDemonModeCooldownInteraction>();
	}
};
static_assert(alignof(UDemonModeCooldownInteraction) == 0x000010, "Wrong alignment on UDemonModeCooldownInteraction");
static_assert(sizeof(UDemonModeCooldownInteraction) == 0x000640, "Wrong size on UDemonModeCooldownInteraction");

// Class TheOni.DemonModeMenuComponent
// 0x0020 (0x00D8 - 0x00B8)
class UDemonModeMenuComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x20];                                      // 0x00B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetInMenuDemonMode(const bool inMenuDemonMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DemonModeMenuComponent">();
	}
	static class UDemonModeMenuComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDemonModeMenuComponent>();
	}
};
static_assert(alignof(UDemonModeMenuComponent) == 0x000008, "Wrong alignment on UDemonModeMenuComponent");
static_assert(sizeof(UDemonModeMenuComponent) == 0x0000D8, "Wrong size on UDemonModeMenuComponent");

// Class TheOni.IsPlayerAbsorbingBloodOrbsCondition
// 0x0000 (0x0128 - 0x0128)
class UIsPlayerAbsorbingBloodOrbsCondition final : public UIsPlayerPerformingInteraction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsPlayerAbsorbingBloodOrbsCondition">();
	}
	static class UIsPlayerAbsorbingBloodOrbsCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsPlayerAbsorbingBloodOrbsCondition>();
	}
};
static_assert(alignof(UIsPlayerAbsorbingBloodOrbsCondition) == 0x000008, "Wrong alignment on UIsPlayerAbsorbingBloodOrbsCondition");
static_assert(sizeof(UIsPlayerAbsorbingBloodOrbsCondition) == 0x000128, "Wrong size on UIsPlayerAbsorbingBloodOrbsCondition");

// Class TheOni.MobileBloodOrbRenderer
// 0x0090 (0x02C0 - 0x0230)
class AMobileBloodOrbRenderer final : public AActor
{
public:
	class UMaterialInstance*                      OrbMaterialInstance;                               // 0x0230(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      OutlineMaterialInstance;                           // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CullInterval;                                      // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInstancedStaticMeshComponent*          _ismComponent;                                     // 0x0248(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInstancedStaticMeshComponent*          _outlineIsmComponent;                              // 0x0250(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ABloodOrb*, struct FBloodOrbInfo>  _instanceMap;                                      // 0x0258(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _outlineMaterialInstanceDynamic;                   // 0x02A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _orbMaterialInstanceDynamic;                       // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBloodOrbVisibilityComponent*           _bloodOrbVisibilityComponent;                      // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MobileBloodOrbRenderer">();
	}
	static class AMobileBloodOrbRenderer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMobileBloodOrbRenderer>();
	}
};
static_assert(alignof(AMobileBloodOrbRenderer) == 0x000008, "Wrong alignment on AMobileBloodOrbRenderer");
static_assert(sizeof(AMobileBloodOrbRenderer) == 0x0002C0, "Wrong size on AMobileBloodOrbRenderer");
static_assert(offsetof(AMobileBloodOrbRenderer, OrbMaterialInstance) == 0x000230, "Member 'AMobileBloodOrbRenderer::OrbMaterialInstance' has a wrong offset!");
static_assert(offsetof(AMobileBloodOrbRenderer, OutlineMaterialInstance) == 0x000238, "Member 'AMobileBloodOrbRenderer::OutlineMaterialInstance' has a wrong offset!");
static_assert(offsetof(AMobileBloodOrbRenderer, CullInterval) == 0x000240, "Member 'AMobileBloodOrbRenderer::CullInterval' has a wrong offset!");
static_assert(offsetof(AMobileBloodOrbRenderer, _ismComponent) == 0x000248, "Member 'AMobileBloodOrbRenderer::_ismComponent' has a wrong offset!");
static_assert(offsetof(AMobileBloodOrbRenderer, _outlineIsmComponent) == 0x000250, "Member 'AMobileBloodOrbRenderer::_outlineIsmComponent' has a wrong offset!");
static_assert(offsetof(AMobileBloodOrbRenderer, _instanceMap) == 0x000258, "Member 'AMobileBloodOrbRenderer::_instanceMap' has a wrong offset!");
static_assert(offsetof(AMobileBloodOrbRenderer, _outlineMaterialInstanceDynamic) == 0x0002A8, "Member 'AMobileBloodOrbRenderer::_outlineMaterialInstanceDynamic' has a wrong offset!");
static_assert(offsetof(AMobileBloodOrbRenderer, _orbMaterialInstanceDynamic) == 0x0002B0, "Member 'AMobileBloodOrbRenderer::_orbMaterialInstanceDynamic' has a wrong offset!");
static_assert(offsetof(AMobileBloodOrbRenderer, _bloodOrbVisibilityComponent) == 0x0002B8, "Member 'AMobileBloodOrbRenderer::_bloodOrbVisibilityComponent' has a wrong offset!");

// Class TheOni.OniAttackPicker
// 0x0010 (0x00C8 - 0x00B8)
class UOniAttackPicker final : public USlasherAttackPickerComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniAttackPicker">();
	}
	static class UOniAttackPicker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniAttackPicker>();
	}
};
static_assert(alignof(UOniAttackPicker) == 0x000008, "Wrong alignment on UOniAttackPicker");
static_assert(sizeof(UOniAttackPicker) == 0x0000C8, "Wrong size on UOniAttackPicker");

// Class TheOni.OniBasicAttack
// 0x0010 (0x0390 - 0x0380)
class UOniBasicAttack final : public UPounceAttack
{
public:
	uint8                                         Pad_380[0x10];                                     // 0x0380(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniBasicAttack">();
	}
	static class UOniBasicAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniBasicAttack>();
	}
};
static_assert(alignof(UOniBasicAttack) == 0x000010, "Wrong alignment on UOniBasicAttack");
static_assert(sizeof(UOniBasicAttack) == 0x000390, "Wrong size on UOniBasicAttack");

// Class TheOni.OniBasicAttackSuccessSubstate
// 0x0000 (0x0118 - 0x0118)
class UOniBasicAttackSuccessSubstate final : public UPounceAttackSuccessSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniBasicAttackSuccessSubstate">();
	}
	static class UOniBasicAttackSuccessSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniBasicAttackSuccessSubstate>();
	}
};
static_assert(alignof(UOniBasicAttackSuccessSubstate) == 0x000008, "Wrong alignment on UOniBasicAttackSuccessSubstate");
static_assert(sizeof(UOniBasicAttackSuccessSubstate) == 0x000118, "Wrong size on UOniBasicAttackSuccessSubstate");

// Class TheOni.OniCustomizationItemAnimInstance
// 0x0020 (0x02E0 - 0x02C0)
class UOniCustomizationItemAnimInstance final : public UAnimInstance
{
public:
	bool                                          _isInDemonMode;                                    // 0x02C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C1[0x1F];                                     // 0x02C1(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIsInDemonMode(const bool isInDemonMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniCustomizationItemAnimInstance">();
	}
	static class UOniCustomizationItemAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniCustomizationItemAnimInstance>();
	}
};
static_assert(alignof(UOniCustomizationItemAnimInstance) == 0x000010, "Wrong alignment on UOniCustomizationItemAnimInstance");
static_assert(sizeof(UOniCustomizationItemAnimInstance) == 0x0002E0, "Wrong size on UOniCustomizationItemAnimInstance");
static_assert(offsetof(UOniCustomizationItemAnimInstance, _isInDemonMode) == 0x0002C0, "Member 'UOniCustomizationItemAnimInstance::_isInDemonMode' has a wrong offset!");

// Class TheOni.OniDashInteraction
// 0x0050 (0x0790 - 0x0740)
class UOniDashInteraction final : public UChargeableInteractionDefinition
{
public:
	class UCurveFloat*                            _chargingSpeedCurve;                               // 0x0740(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _dashingSpeedCurve;                                // 0x0748(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _yawAdjustTime;                                    // 0x0750(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_754[0x4];                                      // 0x0754(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _cooldownSpeedCurve;                               // 0x0758(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_760[0x30];                                     // 0x0760(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnChargeBegin(class ADBDPlayer* player);
	void OnChargeEnd(class ADBDPlayer* player, const bool chargeCompleted);
	void OnDashBegin(class ADBDPlayer* player);
	void OnDashEnd(class ADBDPlayer* player);
	void OnLevelReadyToPlay();
	void SetPlayerOwner(const class ADBDPlayer* player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDashInteraction">();
	}
	static class UOniDashInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDashInteraction>();
	}
};
static_assert(alignof(UOniDashInteraction) == 0x000010, "Wrong alignment on UOniDashInteraction");
static_assert(sizeof(UOniDashInteraction) == 0x000790, "Wrong size on UOniDashInteraction");
static_assert(offsetof(UOniDashInteraction, _chargingSpeedCurve) == 0x000740, "Member 'UOniDashInteraction::_chargingSpeedCurve' has a wrong offset!");
static_assert(offsetof(UOniDashInteraction, _dashingSpeedCurve) == 0x000748, "Member 'UOniDashInteraction::_dashingSpeedCurve' has a wrong offset!");
static_assert(offsetof(UOniDashInteraction, _yawAdjustTime) == 0x000750, "Member 'UOniDashInteraction::_yawAdjustTime' has a wrong offset!");
static_assert(offsetof(UOniDashInteraction, _cooldownSpeedCurve) == 0x000758, "Member 'UOniDashInteraction::_cooldownSpeedCurve' has a wrong offset!");

// Class TheOni.OniDemonBasicAttack
// 0x0000 (0x0380 - 0x0380)
class UOniDemonBasicAttack final : public UPounceAttack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonBasicAttack">();
	}
	static class UOniDemonBasicAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonBasicAttack>();
	}
};
static_assert(alignof(UOniDemonBasicAttack) == 0x000010, "Wrong alignment on UOniDemonBasicAttack");
static_assert(sizeof(UOniDemonBasicAttack) == 0x000380, "Wrong size on UOniDemonBasicAttack");

// Class TheOni.OniDemonPowerAttack
// 0x0020 (0x03A0 - 0x0380)
class UOniDemonPowerAttack : public UPounceAttack
{
public:
	uint8                                         Pad_380[0x20];                                     // 0x0380(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonPowerAttack">();
	}
	static class UOniDemonPowerAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonPowerAttack>();
	}
};
static_assert(alignof(UOniDemonPowerAttack) == 0x000010, "Wrong alignment on UOniDemonPowerAttack");
static_assert(sizeof(UOniDemonPowerAttack) == 0x0003A0, "Wrong size on UOniDemonPowerAttack");

// Class TheOni.OniDemonDashAttack
// 0x0000 (0x03A0 - 0x03A0)
class UOniDemonDashAttack final : public UOniDemonPowerAttack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonDashAttack">();
	}
	static class UOniDemonDashAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonDashAttack>();
	}
};
static_assert(alignof(UOniDemonDashAttack) == 0x000010, "Wrong alignment on UOniDemonDashAttack");
static_assert(sizeof(UOniDemonDashAttack) == 0x0003A0, "Wrong size on UOniDemonDashAttack");

// Class TheOni.OniDemonPowerAttackOpenSubstate
// 0x0010 (0x0140 - 0x0130)
class UOniDemonPowerAttackOpenSubstate : public UPounceAttackOpenSubstate
{
public:
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonPowerAttackOpenSubstate">();
	}
	static class UOniDemonPowerAttackOpenSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonPowerAttackOpenSubstate>();
	}
};
static_assert(alignof(UOniDemonPowerAttackOpenSubstate) == 0x000008, "Wrong alignment on UOniDemonPowerAttackOpenSubstate");
static_assert(sizeof(UOniDemonPowerAttackOpenSubstate) == 0x000140, "Wrong size on UOniDemonPowerAttackOpenSubstate");

// Class TheOni.OniDemonDashAttackOpenSubstate
// 0x0000 (0x0140 - 0x0140)
class UOniDemonDashAttackOpenSubstate final : public UOniDemonPowerAttackOpenSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonDashAttackOpenSubstate">();
	}
	static class UOniDemonDashAttackOpenSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonDashAttackOpenSubstate>();
	}
};
static_assert(alignof(UOniDemonDashAttackOpenSubstate) == 0x000008, "Wrong alignment on UOniDemonDashAttackOpenSubstate");
static_assert(sizeof(UOniDemonDashAttackOpenSubstate) == 0x000140, "Wrong size on UOniDemonDashAttackOpenSubstate");

// Class TheOni.OniDemonPowerAttackHittingSubstate
// 0x0000 (0x01A0 - 0x01A0)
class UOniDemonPowerAttackHittingSubstate final : public UPounceAttackHittingSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonPowerAttackHittingSubstate">();
	}
	static class UOniDemonPowerAttackHittingSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonPowerAttackHittingSubstate>();
	}
};
static_assert(alignof(UOniDemonPowerAttackHittingSubstate) == 0x000008, "Wrong alignment on UOniDemonPowerAttackHittingSubstate");
static_assert(sizeof(UOniDemonPowerAttackHittingSubstate) == 0x0001A0, "Wrong size on UOniDemonPowerAttackHittingSubstate");

// Class TheOni.OniDemonPowerAttackSuccessSubstate
// 0x0030 (0x0148 - 0x0118)
class UOniDemonPowerAttackSuccessSubstate final : public UPounceAttackSuccessSubstate
{
public:
	uint8                                         Pad_118[0x30];                                     // 0x0118(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonPowerAttackSuccessSubstate">();
	}
	static class UOniDemonPowerAttackSuccessSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonPowerAttackSuccessSubstate>();
	}
};
static_assert(alignof(UOniDemonPowerAttackSuccessSubstate) == 0x000008, "Wrong alignment on UOniDemonPowerAttackSuccessSubstate");
static_assert(sizeof(UOniDemonPowerAttackSuccessSubstate) == 0x000148, "Wrong size on UOniDemonPowerAttackSuccessSubstate");

// Class TheOni.OniDemonPowerAttackMissSubstate
// 0x0000 (0x0120 - 0x0120)
class UOniDemonPowerAttackMissSubstate final : public UPounceAttackMissSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonPowerAttackMissSubstate">();
	}
	static class UOniDemonPowerAttackMissSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonPowerAttackMissSubstate>();
	}
};
static_assert(alignof(UOniDemonPowerAttackMissSubstate) == 0x000008, "Wrong alignment on UOniDemonPowerAttackMissSubstate");
static_assert(sizeof(UOniDemonPowerAttackMissSubstate) == 0x000120, "Wrong size on UOniDemonPowerAttackMissSubstate");

// Class TheOni.OniDemonPowerAttackObstructSubstate
// 0x0000 (0x0128 - 0x0128)
class UOniDemonPowerAttackObstructSubstate final : public UPounceAttackObstructSubstate
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniDemonPowerAttackObstructSubstate">();
	}
	static class UOniDemonPowerAttackObstructSubstate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniDemonPowerAttackObstructSubstate>();
	}
};
static_assert(alignof(UOniDemonPowerAttackObstructSubstate) == 0x000008, "Wrong alignment on UOniDemonPowerAttackObstructSubstate");
static_assert(sizeof(UOniDemonPowerAttackObstructSubstate) == 0x000128, "Wrong size on UOniDemonPowerAttackObstructSubstate");

// Class TheOni.OniPounceInteraction
// 0x0030 (0x0770 - 0x0740)
class UOniPounceInteraction final : public UChargeableInteractionDefinition
{
public:
	uint8                                         Pad_740[0x10];                                     // 0x0740(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UOniDemonModeAttackStateComponent*      _chargedAttackState;                               // 0x0750(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDemonModeComponent*                    _demonModeComponent;                               // 0x0758(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ASlasherPlayer*                         _owningSlasher;                                    // 0x0760(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_768[0x8];                                      // 0x0768(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OniPounceInteraction">();
	}
	static class UOniPounceInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOniPounceInteraction>();
	}
};
static_assert(alignof(UOniPounceInteraction) == 0x000010, "Wrong alignment on UOniPounceInteraction");
static_assert(sizeof(UOniPounceInteraction) == 0x000770, "Wrong size on UOniPounceInteraction");
static_assert(offsetof(UOniPounceInteraction, _chargedAttackState) == 0x000750, "Member 'UOniPounceInteraction::_chargedAttackState' has a wrong offset!");
static_assert(offsetof(UOniPounceInteraction, _demonModeComponent) == 0x000758, "Member 'UOniPounceInteraction::_demonModeComponent' has a wrong offset!");
static_assert(offsetof(UOniPounceInteraction, _owningSlasher) == 0x000760, "Member 'UOniPounceInteraction::_owningSlasher' has a wrong offset!");

// Class TheOni.RenjirosBloodyGlove
// 0x00B0 (0x0368 - 0x02B8)
class URenjirosBloodyGlove final : public UItemAddon
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _revealTime;                                       // 0x02C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class ACamperPlayer*, class UBloodOrbOverlapRevealToKiller*> _revealEffectPerCamper;        // 0x02C8(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_318[0x50];                                     // 0x0318(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnBloodOrbOverlapBegin(const class AActor* overlappingActor, const class ABloodOrb* bloodOrb);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RenjirosBloodyGlove">();
	}
	static class URenjirosBloodyGlove* GetDefaultObj()
	{
		return GetDefaultObjImpl<URenjirosBloodyGlove>();
	}
};
static_assert(alignof(URenjirosBloodyGlove) == 0x000008, "Wrong alignment on URenjirosBloodyGlove");
static_assert(sizeof(URenjirosBloodyGlove) == 0x000368, "Wrong size on URenjirosBloodyGlove");
static_assert(offsetof(URenjirosBloodyGlove, _revealTime) == 0x0002C0, "Member 'URenjirosBloodyGlove::_revealTime' has a wrong offset!");
static_assert(offsetof(URenjirosBloodyGlove, _revealEffectPerCamper) == 0x0002C8, "Member 'URenjirosBloodyGlove::_revealEffectPerCamper' has a wrong offset!");

// Class TheOni.StartDemonModeInteraction
// 0x0050 (0x0790 - 0x0740)
class UStartDemonModeInteraction final : public UChargeableInteractionDefinition
{
public:
	float                                         YawAdjustTime;                                     // 0x0740(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_744[0x4];                                      // 0x0744(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAnimationMontageDescriptor            DemonModeActivationMontage;                        // 0x0748(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_768[0x28];                                     // 0x0768(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();
	void SetPlayerOwner(const class ADBDPlayer* owner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartDemonModeInteraction">();
	}
	static class UStartDemonModeInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStartDemonModeInteraction>();
	}
};
static_assert(alignof(UStartDemonModeInteraction) == 0x000010, "Wrong alignment on UStartDemonModeInteraction");
static_assert(sizeof(UStartDemonModeInteraction) == 0x000790, "Wrong size on UStartDemonModeInteraction");
static_assert(offsetof(UStartDemonModeInteraction, YawAdjustTime) == 0x000740, "Member 'UStartDemonModeInteraction::YawAdjustTime' has a wrong offset!");
static_assert(offsetof(UStartDemonModeInteraction, DemonModeActivationMontage) == 0x000748, "Member 'UStartDemonModeInteraction::DemonModeActivationMontage' has a wrong offset!");

}

