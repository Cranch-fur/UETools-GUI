#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDBots

#include "Basic.hpp"

#include "DeadByDaylight_structs.hpp"
#include "AIModule_structs.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum DBDBots.EInteractionCancelInputModes
// NumValues: 0x0003
enum class EInteractionCancelInputModes : uint8
{
	PressCancelInput                         = 0,
	InvertWithStopInputFlow                  = 1,
	EInteractionCancelInputModes_MAX         = 2,
};

// Enum DBDBots.EInteractionSkillInputModes
// NumValues: 0x0006
enum class EInteractionSkillInputModes : uint8
{
	Once                                     = 0,
	Hold                                     = 1,
	Toggle                                   = 2,
	ToggleHold                               = 3,
	OneClickHold                             = 4,
	EInteractionSkillInputModes_MAX          = 5,
};

// Enum DBDBots.EInteractionTargetInSightModes
// NumValues: 0x0005
enum class EInteractionTargetInSightModes : uint8
{
	None                                     = 0,
	MustBeInSight                            = 1,
	MustBeInSight_NoObstruction              = 2,
	ActivateIfOutOfSight                     = 3,
	EInteractionTargetInSightModes_MAX       = 4,
};

// Enum DBDBots.EInteractionTargetRequirements
// NumValues: 0x0006
enum class EInteractionTargetRequirements : uint8
{
	BestTargetMustBeValid                    = 0,
	AnyValidTarget                           = 1,
	AnyTarget                                = 2,
	NoTarget                                 = 3,
	None                                     = 4,
	EInteractionTargetRequirements_MAX       = 5,
};

// Enum DBDBots.EAIThrowProjectileModes
// NumValues: 0x0003
enum class EAIThrowProjectileModes : uint8
{
	OneShot                                  = 0,
	Continuous                               = 1,
	EAIThrowProjectileModes_MAX              = 2,
};

// Enum DBDBots.EAIThrowPredictionModes
// NumValues: 0x0003
enum class EAIThrowPredictionModes : uint8
{
	FindBestThrowPowerRatio                  = 0,
	FullThrowPowerRatio                      = 1,
	EAIThrowPredictionModes_MAX              = 2,
};

// Enum DBDBots.EPlayerFilter
// NumValues: 0x0004
enum class EPlayerFilter : uint8
{
	Self                                     = 0,
	AnyFriend                                = 1,
	AnyOpponent                              = 2,
	EPlayerFilter_MAX                        = 3,
};

// Enum DBDBots.EIsCamperStateOnFilter
// NumValues: 0x0003
enum class EIsCamperStateOnFilter : uint8
{
	OnBlackboardKey                          = 0,
	OnOthersThanSelf                         = 1,
	EIsCamperStateOnFilter_MAX               = 2,
};

// Enum DBDBots.EIsInteractionAvailableOnFilter
// NumValues: 0x0004
enum class EIsInteractionAvailableOnFilter : uint8
{
	Self                                     = 0,
	AnyFriend                                = 1,
	Interactor                               = 2,
	EIsInteractionAvailableOnFilter_MAX      = 3,
};

// Enum DBDBots.EDecoratorIsObjFocusedFilter
// NumValues: 0x0003
enum class EDecoratorIsObjFocusedFilter : uint8
{
	Self                                     = 0,
	SelfNearest                              = 1,
	EDecoratorIsObjFocusedFilter_MAX         = 2,
};

// Enum DBDBots.ETunableComparison
// NumValues: 0x0007
enum class ETunableComparison : uint8
{
	Equal                                    = 0,
	NotEqual                                 = 1,
	Less                                     = 2,
	LessOrEqual                              = 3,
	Greater                                  = 4,
	GreaterOrEqual                           = 5,
	ETunableComparison_MAX                   = 6,
};

// Enum DBDBots.EFindInteractableCamperFilter
// NumValues: 0x0006
enum class EFindInteractableCamperFilter : uint8
{
	Crawling                                 = 0,
	Standing                                 = 1,
	GiveHelp                                 = 2,
	RequestHelp                              = 3,
	RescuableBeingCarried                    = 4,
	EFindInteractableCamperFilter_MAX        = 5,
};

// Enum DBDBots.EFindInteractorOpenConditions
// NumValues: 0x0005
enum class EFindInteractorOpenConditions : uint8
{
	AllGate_OpenedHatch                      = 0,
	All                                      = 1,
	ClosedOnly                               = 2,
	OpenedOnly                               = 3,
	EFindInteractorOpenConditions_MAX        = 4,
};

// Enum DBDBots.EFindInteractorExitOptions
// NumValues: 0x0004
enum class EFindInteractorExitOptions : uint8
{
	All                                      = 0,
	HatchOnly                                = 1,
	GateOnly                                 = 2,
	EFindInteractorExitOptions_MAX           = 3,
};

// Enum DBDBots.EFindInteractableGeneratorStatusFilter
// NumValues: 0x0003
enum class EFindInteractableGeneratorStatusFilter : uint8
{
	NeedRepair                               = 0,
	CanBeDamaged                             = 1,
	EFindInteractableGeneratorStatusFilter_MAX = 2,
};

// Enum DBDBots.EFindInteractableLockerStatusFilter
// NumValues: 0x0004
enum class EFindInteractableLockerStatusFilter : uint8
{
	Empty                                    = 0,
	Occupied                                 = 1,
	Both                                     = 2,
	EFindInteractableLockerStatusFilter_MAX  = 3,
};

// Enum DBDBots.EFindInteractableMeatHookStatus
// NumValues: 0x0004
enum class EFindInteractableMeatHookStatus : uint8
{
	HookedSurvivor                           = 0,
	Available                                = 1,
	Sabotage                                 = 2,
	EFindInteractableMeatHookStatus_MAX      = 3,
};

// Enum DBDBots.EFindInteractablePalletIntentions
// NumValues: 0x0003
enum class EFindInteractablePalletIntentions : uint8
{
	Fall                                     = 0,
	Raise                                    = 1,
	EFindInteractablePalletIntentions_MAX    = 2,
};

// Enum DBDBots.EAINodeRelevancyOptions
// NumValues: 0x0005
enum class EAINodeRelevancyOptions : uint8
{
	OnEnter                                  = 0,
	OnExit                                   = 1,
	OnEnterAndExit                           = 2,
	OnTick                                   = 3,
	EAINodeRelevancyOptions_MAX              = 4,
};

// Enum DBDBots.EAIInvestigateSteps
// NumValues: 0x0004
enum class EAIInvestigateSteps : uint8
{
	None                                     = 0,
	ToInvestigation                          = 1,
	Investigating                            = 2,
	EAIInvestigateSteps_MAX                  = 3,
};

// Enum DBDBots.EExtMoveToStrafeFocusOptions
// NumValues: 0x0006
enum class EExtMoveToStrafeFocusOptions : uint8
{
	Never                                    = 0,
	NearFocus                                = 1,
	NearGoal                                 = 2,
	Always                                   = 3,
	Intermittent                             = 4,
	EExtMoveToStrafeFocusOptions_MAX         = 5,
};

// Enum DBDBots.ETaskInputPressModes
// NumValues: 0x0004
enum class ETaskInputPressModes : uint8
{
	Once                                     = 0,
	Loop                                     = 1,
	Hold                                     = 2,
	ETaskInputPressModes_MAX                 = 3,
};

// Enum DBDBots.EAIPressureZoneLevel
// NumValues: 0x0005
enum class EAIPressureZoneLevel : uint8
{
	LMin                                     = 0,
	L01                                      = 1,
	L02                                      = 2,
	LMax                                     = 3,
	EAIPressureZoneLevel_MAX                 = 4,
};

// Enum DBDBots.EAIGameState
// NumValues: 0x0007
enum class EAIGameState : uint8
{
	VeryEarly                                = 0,
	Early                                    = 1,
	Mid                                      = 2,
	Late                                     = 3,
	VeryLate                                 = 4,
	Max                                      = 5,
	EAIGameState_MAX                         = 6,
};

// Enum DBDBots.EAIObjectiveState
// NumValues: 0x0005
enum class EAIObjectiveState : uint8
{
	Early                                    = 0,
	Mid                                      = 1,
	Last                                     = 2,
	Completed                                = 3,
	EAIObjectiveState_MAX                    = 4,
};

// Enum DBDBots.EAIDangerState
// NumValues: 0x0004
enum class EAIDangerState : uint8
{
	Safe                                     = 0,
	Unsafe                                   = 1,
	Dire                                     = 2,
	EAIDangerState_MAX                       = 3,
};

// Enum DBDBots.ENavLinkPlayerStates
// NumValues: 0x0006
enum class ENavLinkPlayerStates : uint8
{
	RequestStart                             = 0,
	MoveStart                                = 1,
	Using                                    = 2,
	MoveEnd                                  = 3,
	Release                                  = 4,
	ENavLinkPlayerStates_MAX                 = 5,
};

// Enum DBDBots.EPathBuildResult
// NumValues: 0x0006
enum class EPathBuildResult : uint8
{
	None                                     = 0,
	Failed                                   = 1,
	Succeeded                                = 2,
	Partial                                  = 3,
	InProgress                               = 4,
	EPathBuildResult_MAX                     = 5,
};

// Enum DBDBots.EAIFleeLoopStrategy
// NumValues: 0x0003
enum class EAIFleeLoopStrategy : uint8
{
	LoseKiller                               = 0,
	WasteTime                                = 1,
	EAIFleeLoopStrategy_MAX                  = 2,
};

// Enum DBDBots.EAIFleePathStrategy
// NumValues: 0x0006
enum class EAIFleePathStrategy : uint8
{
	None                                     = 0,
	KeepGoal                                 = 1,
	Away                                     = 2,
	Loop                                     = 3,
	AwayLOS                                  = 4,
	EAIFleePathStrategy_MAX                  = 5,
};

// ScriptStruct DBDBots.KillerFilterItem
// 0x0008 (0x0008 - 0x0000)
struct FKillerFilterItem final
{
public:
	struct FCharacterDropdown                     Character;                                         // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKillerFilterItem) == 0x000004, "Wrong alignment on FKillerFilterItem");
static_assert(sizeof(FKillerFilterItem) == 0x000008, "Wrong size on FKillerFilterItem");
static_assert(offsetof(FKillerFilterItem, Character) == 0x000000, "Member 'FKillerFilterItem::Character' has a wrong offset!");

// ScriptStruct DBDBots.DreamPalletSpawnState
// 0x0024 (0x0024 - 0x0000)
struct alignas(0x04) FDreamPalletSpawnState final
{
public:
	uint8                                         Pad_0[0x24];                                       // 0x0000(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDreamPalletSpawnState) == 0x000004, "Wrong alignment on FDreamPalletSpawnState");
static_assert(sizeof(FDreamPalletSpawnState) == 0x000024, "Wrong size on FDreamPalletSpawnState");

// ScriptStruct DBDBots.TargetMoveAwayToFastInfo
// 0x0064 (0x0064 - 0x0000)
struct FTargetMoveAwayToFastInfo final
{
public:
	float                                         AccumulatedTime;                                   // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownUntilTime;                                 // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDetectedStimulus                    Stimulus;                                          // 0x0008(0x005C)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTargetMoveAwayToFastInfo) == 0x000004, "Wrong alignment on FTargetMoveAwayToFastInfo");
static_assert(sizeof(FTargetMoveAwayToFastInfo) == 0x000064, "Wrong size on FTargetMoveAwayToFastInfo");
static_assert(offsetof(FTargetMoveAwayToFastInfo, AccumulatedTime) == 0x000000, "Member 'FTargetMoveAwayToFastInfo::AccumulatedTime' has a wrong offset!");
static_assert(offsetof(FTargetMoveAwayToFastInfo, CooldownUntilTime) == 0x000004, "Member 'FTargetMoveAwayToFastInfo::CooldownUntilTime' has a wrong offset!");
static_assert(offsetof(FTargetMoveAwayToFastInfo, Stimulus) == 0x000008, "Member 'FTargetMoveAwayToFastInfo::Stimulus' has a wrong offset!");

// ScriptStruct DBDBots.AIHasItemAddonCondition
// 0x0030 (0x0030 - 0x0000)
struct FAIHasItemAddonCondition final
{
public:
	struct FDataTableDropdown                     ItemAddonID;                                       // 0x0000(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIHasItemAddonCondition) == 0x000008, "Wrong alignment on FAIHasItemAddonCondition");
static_assert(sizeof(FAIHasItemAddonCondition) == 0x000030, "Wrong size on FAIHasItemAddonCondition");
static_assert(offsetof(FAIHasItemAddonCondition, ItemAddonID) == 0x000000, "Member 'FAIHasItemAddonCondition::ItemAddonID' has a wrong offset!");

// ScriptStruct DBDBots.AIHasPerkCondition
// 0x0038 (0x0038 - 0x0000)
struct FAIHasPerkCondition final
{
public:
	struct FDataTableDropdown                     PerkID;                                            // 0x0000(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          CompareDisplayPercent;                             // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EArithmeticKeyOperation                       DisplayPercentQuery;                               // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisplayPercentValue;                               // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIHasPerkCondition) == 0x000008, "Wrong alignment on FAIHasPerkCondition");
static_assert(sizeof(FAIHasPerkCondition) == 0x000038, "Wrong size on FAIHasPerkCondition");
static_assert(offsetof(FAIHasPerkCondition, PerkID) == 0x000000, "Member 'FAIHasPerkCondition::PerkID' has a wrong offset!");
static_assert(offsetof(FAIHasPerkCondition, CompareDisplayPercent) == 0x000030, "Member 'FAIHasPerkCondition::CompareDisplayPercent' has a wrong offset!");
static_assert(offsetof(FAIHasPerkCondition, DisplayPercentQuery) == 0x000031, "Member 'FAIHasPerkCondition::DisplayPercentQuery' has a wrong offset!");
static_assert(offsetof(FAIHasPerkCondition, DisplayPercentValue) == 0x000034, "Member 'FAIHasPerkCondition::DisplayPercentValue' has a wrong offset!");

// ScriptStruct DBDBots.AIRandomByDistancePercentagesAtTime
// 0x0030 (0x0030 - 0x0000)
struct FAIRandomByDistancePercentagesAtTime final
{
public:
	struct FAITunableParameter                    PercentageAtStartDistance;                         // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PercentageAtEndDistance;                           // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    AtRelativeTime;                                    // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIRandomByDistancePercentagesAtTime) == 0x000004, "Wrong alignment on FAIRandomByDistancePercentagesAtTime");
static_assert(sizeof(FAIRandomByDistancePercentagesAtTime) == 0x000030, "Wrong size on FAIRandomByDistancePercentagesAtTime");
static_assert(offsetof(FAIRandomByDistancePercentagesAtTime, PercentageAtStartDistance) == 0x000000, "Member 'FAIRandomByDistancePercentagesAtTime::PercentageAtStartDistance' has a wrong offset!");
static_assert(offsetof(FAIRandomByDistancePercentagesAtTime, PercentageAtEndDistance) == 0x000010, "Member 'FAIRandomByDistancePercentagesAtTime::PercentageAtEndDistance' has a wrong offset!");
static_assert(offsetof(FAIRandomByDistancePercentagesAtTime, AtRelativeTime) == 0x000020, "Member 'FAIRandomByDistancePercentagesAtTime::AtRelativeTime' has a wrong offset!");

// ScriptStruct DBDBots.InLockerPerk
// 0x0098 (0x0098 - 0x0000)
struct FInLockerPerk final
{
public:
	struct FDataTableDropdown                     PerkID;                                            // 0x0000(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          PerkNeedToBeFullyCharged;                          // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedToHoldItem;                                    // 0x0031(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedToBeEmptyHanded;                               // 0x0032(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedToBeInjured;                                   // 0x0033(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeedPerkSkillToBeRunnableAtLocation;               // 0x0034(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MustBeFarFromLinkedObject;                         // 0x0035(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumDistanceFromObject;                         // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     LinkedObjectClass;                                 // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UnusableIfLockerPenaltyReceived;                   // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlackboardKeySelector                 BBLockerPenaltyReceived;                           // 0x0050(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	float                                         UnusableUnlessKillerIsFartherThan;                 // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    PerkWeight;                                        // 0x0084(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInLockerPerk) == 0x000008, "Wrong alignment on FInLockerPerk");
static_assert(sizeof(FInLockerPerk) == 0x000098, "Wrong size on FInLockerPerk");
static_assert(offsetof(FInLockerPerk, PerkID) == 0x000000, "Member 'FInLockerPerk::PerkID' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, PerkNeedToBeFullyCharged) == 0x000030, "Member 'FInLockerPerk::PerkNeedToBeFullyCharged' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, NeedToHoldItem) == 0x000031, "Member 'FInLockerPerk::NeedToHoldItem' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, NeedToBeEmptyHanded) == 0x000032, "Member 'FInLockerPerk::NeedToBeEmptyHanded' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, NeedToBeInjured) == 0x000033, "Member 'FInLockerPerk::NeedToBeInjured' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, NeedPerkSkillToBeRunnableAtLocation) == 0x000034, "Member 'FInLockerPerk::NeedPerkSkillToBeRunnableAtLocation' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, MustBeFarFromLinkedObject) == 0x000035, "Member 'FInLockerPerk::MustBeFarFromLinkedObject' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, MinimumDistanceFromObject) == 0x000038, "Member 'FInLockerPerk::MinimumDistanceFromObject' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, LinkedObjectClass) == 0x000040, "Member 'FInLockerPerk::LinkedObjectClass' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, UnusableIfLockerPenaltyReceived) == 0x000048, "Member 'FInLockerPerk::UnusableIfLockerPenaltyReceived' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, BBLockerPenaltyReceived) == 0x000050, "Member 'FInLockerPerk::BBLockerPenaltyReceived' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, UnusableUnlessKillerIsFartherThan) == 0x000080, "Member 'FInLockerPerk::UnusableUnlessKillerIsFartherThan' has a wrong offset!");
static_assert(offsetof(FInLockerPerk, PerkWeight) == 0x000084, "Member 'FInLockerPerk::PerkWeight' has a wrong offset!");

// ScriptStruct DBDBots.AICleansePerkCondition
// 0x0038 (0x0038 - 0x0000)
struct FAICleansePerkCondition final
{
public:
	struct FDataTableDropdown                     CleansePerkID;                                     // 0x0000(0x0030)(Edit, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	EArithmeticKeyOperation                       DisplayPercentQuery;                               // 0x0030(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisplayPercentValue;                               // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAICleansePerkCondition) == 0x000008, "Wrong alignment on FAICleansePerkCondition");
static_assert(sizeof(FAICleansePerkCondition) == 0x000038, "Wrong size on FAICleansePerkCondition");
static_assert(offsetof(FAICleansePerkCondition, CleansePerkID) == 0x000000, "Member 'FAICleansePerkCondition::CleansePerkID' has a wrong offset!");
static_assert(offsetof(FAICleansePerkCondition, DisplayPercentQuery) == 0x000030, "Member 'FAICleansePerkCondition::DisplayPercentQuery' has a wrong offset!");
static_assert(offsetof(FAICleansePerkCondition, DisplayPercentValue) == 0x000034, "Member 'FAICleansePerkCondition::DisplayPercentValue' has a wrong offset!");

// ScriptStruct DBDBots.MovementModeNearActor
// 0x0058 (0x0058 - 0x0000)
struct FMovementModeNearActor final
{
public:
	ECharacterMovementTypes                       NearActorMovementMode;                             // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     NearActorClass;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    NearDistanceSquared;                               // 0x0010(0x0010)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIRoll                                SeeActorRoll;                                      // 0x0020(0x0024)(Edit, DisableEditOnTemplate, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPlayerRole>                           ApplyToPlayerRoles;                                // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovementModeNearActor) == 0x000008, "Wrong alignment on FMovementModeNearActor");
static_assert(sizeof(FMovementModeNearActor) == 0x000058, "Wrong size on FMovementModeNearActor");
static_assert(offsetof(FMovementModeNearActor, NearActorMovementMode) == 0x000000, "Member 'FMovementModeNearActor::NearActorMovementMode' has a wrong offset!");
static_assert(offsetof(FMovementModeNearActor, NearActorClass) == 0x000008, "Member 'FMovementModeNearActor::NearActorClass' has a wrong offset!");
static_assert(offsetof(FMovementModeNearActor, NearDistanceSquared) == 0x000010, "Member 'FMovementModeNearActor::NearDistanceSquared' has a wrong offset!");
static_assert(offsetof(FMovementModeNearActor, SeeActorRoll) == 0x000020, "Member 'FMovementModeNearActor::SeeActorRoll' has a wrong offset!");
static_assert(offsetof(FMovementModeNearActor, ApplyToPlayerRoles) == 0x000048, "Member 'FMovementModeNearActor::ApplyToPlayerRoles' has a wrong offset!");

// ScriptStruct DBDBots.AISkillPerk
// 0x0018 (0x0018 - 0x0000)
struct FAISkillPerk final
{
public:
	TArray<struct FPerkIdDropdown>                Perks;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAISkill*                               Skill;                                             // 0x0010(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAISkillPerk) == 0x000008, "Wrong alignment on FAISkillPerk");
static_assert(sizeof(FAISkillPerk) == 0x000018, "Wrong size on FAISkillPerk");
static_assert(offsetof(FAISkillPerk, Perks) == 0x000000, "Member 'FAISkillPerk::Perks' has a wrong offset!");
static_assert(offsetof(FAISkillPerk, Skill) == 0x000010, "Member 'FAISkillPerk::Skill' has a wrong offset!");

// ScriptStruct DBDBots.AIGoal
// 0x0018 (0x0018 - 0x0000)
struct FAIGoal final
{
public:
	class UObject*                                Source;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                MetaGoal;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Goal;                                              // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIGoal) == 0x000008, "Wrong alignment on FAIGoal");
static_assert(sizeof(FAIGoal) == 0x000018, "Wrong size on FAIGoal");
static_assert(offsetof(FAIGoal, Source) == 0x000000, "Member 'FAIGoal::Source' has a wrong offset!");
static_assert(offsetof(FAIGoal, MetaGoal) == 0x000008, "Member 'FAIGoal::MetaGoal' has a wrong offset!");
static_assert(offsetof(FAIGoal, Goal) == 0x000010, "Member 'FAIGoal::Goal' has a wrong offset!");

// ScriptStruct DBDBots.AIGoalWeight
// 0x0030 (0x0030 - 0x0000)
struct FAIGoalWeight final
{
public:
	struct FAIGoal                                GoalInfo;                                          // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WeightDebug;                                       // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIGoalWeight) == 0x000008, "Wrong alignment on FAIGoalWeight");
static_assert(sizeof(FAIGoalWeight) == 0x000030, "Wrong size on FAIGoalWeight");
static_assert(offsetof(FAIGoalWeight, GoalInfo) == 0x000000, "Member 'FAIGoalWeight::GoalInfo' has a wrong offset!");
static_assert(offsetof(FAIGoalWeight, Weight) == 0x000018, "Member 'FAIGoalWeight::Weight' has a wrong offset!");
static_assert(offsetof(FAIGoalWeight, WeightDebug) == 0x000020, "Member 'FAIGoalWeight::WeightDebug' has a wrong offset!");

// ScriptStruct DBDBots.AIGoalWeightContainer
// 0x0010 (0x0010 - 0x0000)
struct FAIGoalWeightContainer final
{
public:
	TArray<struct FAIGoalWeight>                  WeightedGoals;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAIGoalWeightContainer) == 0x000008, "Wrong alignment on FAIGoalWeightContainer");
static_assert(sizeof(FAIGoalWeightContainer) == 0x000010, "Wrong size on FAIGoalWeightContainer");
static_assert(offsetof(FAIGoalWeightContainer, WeightedGoals) == 0x000000, "Member 'FAIGoalWeightContainer::WeightedGoals' has a wrong offset!");

// ScriptStruct DBDBots.GameStatePressureZoneLevelMapContainer
// 0x0050 (0x0050 - 0x0000)
struct FGameStatePressureZoneLevelMapContainer final
{
public:
	TMap<EAIGameState, EAIPressureZoneLevel>      Map;                                               // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameStatePressureZoneLevelMapContainer) == 0x000008, "Wrong alignment on FGameStatePressureZoneLevelMapContainer");
static_assert(sizeof(FGameStatePressureZoneLevelMapContainer) == 0x000050, "Wrong size on FGameStatePressureZoneLevelMapContainer");
static_assert(offsetof(FGameStatePressureZoneLevelMapContainer, Map) == 0x000000, "Member 'FGameStatePressureZoneLevelMapContainer::Map' has a wrong offset!");

// ScriptStruct DBDBots.DangerStateGameStateMapContainer
// 0x0050 (0x0050 - 0x0000)
struct FDangerStateGameStateMapContainer final
{
public:
	TMap<EAIDangerState, EAIGameState>            Map;                                               // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDangerStateGameStateMapContainer) == 0x000008, "Wrong alignment on FDangerStateGameStateMapContainer");
static_assert(sizeof(FDangerStateGameStateMapContainer) == 0x000050, "Wrong size on FDangerStateGameStateMapContainer");
static_assert(offsetof(FDangerStateGameStateMapContainer, Map) == 0x000000, "Member 'FDangerStateGameStateMapContainer::Map' has a wrong offset!");

// ScriptStruct DBDBots.RelevantNodeMemory
// 0x0018 (0x0018 - 0x0000)
struct FRelevantNodeMemory final
{
public:
	class UBTNode*                                Node;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRelevantNodeMemory) == 0x000008, "Wrong alignment on FRelevantNodeMemory");
static_assert(sizeof(FRelevantNodeMemory) == 0x000018, "Wrong size on FRelevantNodeMemory");
static_assert(offsetof(FRelevantNodeMemory, Node) == 0x000000, "Member 'FRelevantNodeMemory::Node' has a wrong offset!");

// ScriptStruct DBDBots.DistanceToTargetData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDistanceToTargetData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDistanceToTargetData) == 0x000008, "Wrong alignment on FDistanceToTargetData");
static_assert(sizeof(FDistanceToTargetData) == 0x000018, "Wrong size on FDistanceToTargetData");

// ScriptStruct DBDBots.MindFocusObjectEntry
// 0x0078 (0x0078 - 0x0000)
struct FMindFocusObjectEntry final
{
public:
	TArray<class UObject*>                        FocusedBy;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FocusedStartTime;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      CooldownMap;                                       // 0x0018(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMindFocusObjectEntry) == 0x000008, "Wrong alignment on FMindFocusObjectEntry");
static_assert(sizeof(FMindFocusObjectEntry) == 0x000078, "Wrong size on FMindFocusObjectEntry");
static_assert(offsetof(FMindFocusObjectEntry, FocusedBy) == 0x000000, "Member 'FMindFocusObjectEntry::FocusedBy' has a wrong offset!");
static_assert(offsetof(FMindFocusObjectEntry, FocusedStartTime) == 0x000010, "Member 'FMindFocusObjectEntry::FocusedStartTime' has a wrong offset!");
static_assert(offsetof(FMindFocusObjectEntry, CooldownMap) == 0x000018, "Member 'FMindFocusObjectEntry::CooldownMap' has a wrong offset!");

// ScriptStruct DBDBots.WeightedWishedObjectMapContainer
// 0x0050 (0x0050 - 0x0000)
struct FWeightedWishedObjectMapContainer final
{
public:
	TMap<class UObject*, float>                   WeightedWishedObjectMap;                           // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeightedWishedObjectMapContainer) == 0x000008, "Wrong alignment on FWeightedWishedObjectMapContainer");
static_assert(sizeof(FWeightedWishedObjectMapContainer) == 0x000050, "Wrong size on FWeightedWishedObjectMapContainer");
static_assert(offsetof(FWeightedWishedObjectMapContainer, WeightedWishedObjectMap) == 0x000000, "Member 'FWeightedWishedObjectMapContainer::WeightedWishedObjectMap' has a wrong offset!");

// ScriptStruct DBDBots.ExplorableTileInfo
// 0x002C (0x002C - 0x0000)
struct FExplorableTileInfo final
{
public:
	struct FGuid                                  Id;                                                // 0x0000(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Bounds;                                            // 0x0010(0x001C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExplorableTileInfo) == 0x000004, "Wrong alignment on FExplorableTileInfo");
static_assert(sizeof(FExplorableTileInfo) == 0x00002C, "Wrong size on FExplorableTileInfo");
static_assert(offsetof(FExplorableTileInfo, Id) == 0x000000, "Member 'FExplorableTileInfo::Id' has a wrong offset!");
static_assert(offsetof(FExplorableTileInfo, Bounds) == 0x000010, "Member 'FExplorableTileInfo::Bounds' has a wrong offset!");

// ScriptStruct DBDBots.MoveLinkPlayerInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x04) FMoveLinkPlayerInfo final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoveLinkPlayerInfo) == 0x000004, "Wrong alignment on FMoveLinkPlayerInfo");
static_assert(sizeof(FMoveLinkPlayerInfo) == 0x000028, "Wrong size on FMoveLinkPlayerInfo");

// ScriptStruct DBDBots.NavLinkInteractPlayerSetup
// 0x0028 (0x0028 - 0x0000)
struct FNavLinkInteractPlayerSetup final
{
public:
	EPawnInputPressTypes                          Input;                                             // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         InteractionIds;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FAITunableParameter                    InputTimeDeviationInChase;                         // 0x0018(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNavLinkInteractPlayerSetup) == 0x000008, "Wrong alignment on FNavLinkInteractPlayerSetup");
static_assert(sizeof(FNavLinkInteractPlayerSetup) == 0x000028, "Wrong size on FNavLinkInteractPlayerSetup");
static_assert(offsetof(FNavLinkInteractPlayerSetup, Input) == 0x000000, "Member 'FNavLinkInteractPlayerSetup::Input' has a wrong offset!");
static_assert(offsetof(FNavLinkInteractPlayerSetup, InteractionIds) == 0x000008, "Member 'FNavLinkInteractPlayerSetup::InteractionIds' has a wrong offset!");
static_assert(offsetof(FNavLinkInteractPlayerSetup, InputTimeDeviationInChase) == 0x000018, "Member 'FNavLinkInteractPlayerSetup::InputTimeDeviationInChase' has a wrong offset!");

// ScriptStruct DBDBots.NavMovePathPoint
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FNavMovePathPoint final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNavMovePathPoint) == 0x000004, "Wrong alignment on FNavMovePathPoint");
static_assert(sizeof(FNavMovePathPoint) == 0x000014, "Wrong size on FNavMovePathPoint");

// ScriptStruct DBDBots.GameStateEvadeLoopStrategyMapContainer
// 0x0050 (0x0050 - 0x0000)
struct FGameStateEvadeLoopStrategyMapContainer final
{
public:
	TMap<EAIGameState, EAIFleeLoopStrategy>       Map;                                               // 0x0000(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameStateEvadeLoopStrategyMapContainer) == 0x000008, "Wrong alignment on FGameStateEvadeLoopStrategyMapContainer");
static_assert(sizeof(FGameStateEvadeLoopStrategyMapContainer) == 0x000050, "Wrong size on FGameStateEvadeLoopStrategyMapContainer");
static_assert(offsetof(FGameStateEvadeLoopStrategyMapContainer, Map) == 0x000000, "Member 'FGameStateEvadeLoopStrategyMapContainer::Map' has a wrong offset!");

}

