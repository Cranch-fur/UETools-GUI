#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TheK26

#include "Basic.hpp"

#include "StatSystem_structs.hpp"
#include "DBDBots_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DBDCompetence_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "DBDAnimation_classes.hpp"
#include "TheK26_structs.hpp"
#include "GameplayTagUtilities_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Competence_classes.hpp"
#include "SystemUtilities_structs.hpp"


namespace SDK
{

// Class TheK26.AISkill_Interaction_DismissCrow
// 0x0000 (0x0180 - 0x0180)
class UAISkill_Interaction_DismissCrow final : public UAISkill_Interaction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISkill_Interaction_DismissCrow">();
	}
	static class UAISkill_Interaction_DismissCrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISkill_Interaction_DismissCrow>();
	}
};
static_assert(alignof(UAISkill_Interaction_DismissCrow) == 0x000008, "Wrong alignment on UAISkill_Interaction_DismissCrow");
static_assert(sizeof(UAISkill_Interaction_DismissCrow) == 0x000180, "Wrong size on UAISkill_Interaction_DismissCrow");

// Class TheK26.CorrectiveAction
// 0x0050 (0x0418 - 0x03C8)
class UCorrectiveAction final : public UPerk
{
public:
	float                                         _startingTokens[0x3];                              // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _statusEffectName;                                 // 0x03D4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  _allowedInteractionSemanticsForToken;              // 0x03E0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x18];                                     // 0x0400(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CorrectiveAction">();
	}
	static class UCorrectiveAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCorrectiveAction>();
	}
};
static_assert(alignof(UCorrectiveAction) == 0x000008, "Wrong alignment on UCorrectiveAction");
static_assert(sizeof(UCorrectiveAction) == 0x000418, "Wrong size on UCorrectiveAction");
static_assert(offsetof(UCorrectiveAction, _startingTokens) == 0x0003C8, "Member 'UCorrectiveAction::_startingTokens' has a wrong offset!");
static_assert(offsetof(UCorrectiveAction, _statusEffectName) == 0x0003D4, "Member 'UCorrectiveAction::_statusEffectName' has a wrong offset!");
static_assert(offsetof(UCorrectiveAction, _allowedInteractionSemanticsForToken) == 0x0003E0, "Member 'UCorrectiveAction::_allowedInteractionSemanticsForToken' has a wrong offset!");

// Class TheK26.HexPentimento
// 0x0070 (0x04B8 - 0x0448)
class UHexPentimento final : public UHexPerk
{
public:
	TSet<class FName>                             _statusEffectNames;                                // 0x0448(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSubclassOf<class URekindleTotemInteraction>  _rekindleInteractionClass;                         // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ATotem*>                         _blockedTotems;                                    // 0x04A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexPentimento">();
	}
	static class UHexPentimento* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexPentimento>();
	}
};
static_assert(alignof(UHexPentimento) == 0x000008, "Wrong alignment on UHexPentimento");
static_assert(sizeof(UHexPentimento) == 0x0004B8, "Wrong size on UHexPentimento");
static_assert(offsetof(UHexPentimento, _statusEffectNames) == 0x000448, "Member 'UHexPentimento::_statusEffectNames' has a wrong offset!");
static_assert(offsetof(UHexPentimento, _rekindleInteractionClass) == 0x000498, "Member 'UHexPentimento::_rekindleInteractionClass' has a wrong offset!");
static_assert(offsetof(UHexPentimento, _blockedTotems) == 0x0004A0, "Member 'UHexPentimento::_blockedTotems' has a wrong offset!");

// Class TheK26.HinderOnCrowAttachStatusEffect
// 0x00B8 (0x0410 - 0x0358)
class UHinderOnCrowAttachStatusEffect final : public UBaseLingeringStatusEffect
{
public:
	struct FGameplayTag                           _onCrowAttachStateTag;                             // 0x0358(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _hinderOnIdleLingerTime;                           // 0x0368(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x28];                                     // 0x03E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKillerSet(class ASlasherPlayer* killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HinderOnCrowAttachStatusEffect">();
	}
	static class UHinderOnCrowAttachStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHinderOnCrowAttachStatusEffect>();
	}
};
static_assert(alignof(UHinderOnCrowAttachStatusEffect) == 0x000008, "Wrong alignment on UHinderOnCrowAttachStatusEffect");
static_assert(sizeof(UHinderOnCrowAttachStatusEffect) == 0x000410, "Wrong size on UHinderOnCrowAttachStatusEffect");
static_assert(offsetof(UHinderOnCrowAttachStatusEffect, _onCrowAttachStateTag) == 0x000358, "Member 'UHinderOnCrowAttachStatusEffect::_onCrowAttachStateTag' has a wrong offset!");
static_assert(offsetof(UHinderOnCrowAttachStatusEffect, _hinderOnIdleLingerTime) == 0x000368, "Member 'UHinderOnCrowAttachStatusEffect::_hinderOnIdleLingerTime' has a wrong offset!");

// Class TheK26.HinderOnIdleAndAttachStatusEffect
// 0x0038 (0x03C8 - 0x0390)
class UHinderOnIdleAndAttachStatusEffect final : public ULingeringStateTagStatusEffect
{
public:
	struct FGameplayTag                           _onCrowAttachStateTag;                             // 0x0390(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x2C];                                     // 0x039C(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HinderOnIdleAndAttachStatusEffect">();
	}
	static class UHinderOnIdleAndAttachStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHinderOnIdleAndAttachStatusEffect>();
	}
};
static_assert(alignof(UHinderOnIdleAndAttachStatusEffect) == 0x000008, "Wrong alignment on UHinderOnIdleAndAttachStatusEffect");
static_assert(sizeof(UHinderOnIdleAndAttachStatusEffect) == 0x0003C8, "Wrong size on UHinderOnIdleAndAttachStatusEffect");
static_assert(offsetof(UHinderOnIdleAndAttachStatusEffect, _onCrowAttachStateTag) == 0x000390, "Member 'UHinderOnIdleAndAttachStatusEffect::_onCrowAttachStateTag' has a wrong offset!");

// Class TheK26.K26AbilitySubAnimInstance
// 0x0090 (0x05E0 - 0x0550)
class UK26AbilitySubAnimInstance final : public UBaseKillerAnimInstance
{
public:
	float                                         _fireInteractionCooldownTime;                      // 0x0550(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_554[0x4];                                      // 0x0554(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _fireInteractionCooldownTimeTunable;               // 0x0558(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasChargingStarted;                               // 0x05D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasProjectileBeenSummoned;                        // 0x05D9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasChargingEnded;                                 // 0x05DA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _hasProjectileFired;                               // 0x05DB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5DC[0x4];                                      // 0x05DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConsumeHasProjectileBeenSummoned();
	void ConsumeHasProjectileFired();
	void OnHasProjectileBeenSummoned(const int32 remainingAmmo, const int32 maxAmmo);
	void OnHasProjectileFired();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26AbilitySubAnimInstance">();
	}
	static class UK26AbilitySubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26AbilitySubAnimInstance>();
	}
};
static_assert(alignof(UK26AbilitySubAnimInstance) == 0x000010, "Wrong alignment on UK26AbilitySubAnimInstance");
static_assert(sizeof(UK26AbilitySubAnimInstance) == 0x0005E0, "Wrong size on UK26AbilitySubAnimInstance");
static_assert(offsetof(UK26AbilitySubAnimInstance, _fireInteractionCooldownTime) == 0x000550, "Member 'UK26AbilitySubAnimInstance::_fireInteractionCooldownTime' has a wrong offset!");
static_assert(offsetof(UK26AbilitySubAnimInstance, _fireInteractionCooldownTimeTunable) == 0x000558, "Member 'UK26AbilitySubAnimInstance::_fireInteractionCooldownTimeTunable' has a wrong offset!");
static_assert(offsetof(UK26AbilitySubAnimInstance, _hasChargingStarted) == 0x0005D8, "Member 'UK26AbilitySubAnimInstance::_hasChargingStarted' has a wrong offset!");
static_assert(offsetof(UK26AbilitySubAnimInstance, _hasProjectileBeenSummoned) == 0x0005D9, "Member 'UK26AbilitySubAnimInstance::_hasProjectileBeenSummoned' has a wrong offset!");
static_assert(offsetof(UK26AbilitySubAnimInstance, _hasChargingEnded) == 0x0005DA, "Member 'UK26AbilitySubAnimInstance::_hasChargingEnded' has a wrong offset!");
static_assert(offsetof(UK26AbilitySubAnimInstance, _hasProjectileFired) == 0x0005DB, "Member 'UK26AbilitySubAnimInstance::_hasProjectileFired' has a wrong offset!");

// Class TheK26.K26AimingGuide
// 0x0000 (0x0230 - 0x0230)
class AK26AimingGuide final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26AimingGuide">();
	}
	static class AK26AimingGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK26AimingGuide>();
	}
};
static_assert(alignof(AK26AimingGuide) == 0x000008, "Wrong alignment on AK26AimingGuide");
static_assert(sizeof(AK26AimingGuide) == 0x000230, "Wrong size on AK26AimingGuide");

// Class TheK26.K26AmmoHandlerComponent
// 0x0398 (0x0450 - 0x00B8)
class UK26AmmoHandlerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const EK26AmmoState newAmmoState, const int32 currentAmmo, const int32 maxAmmo)> OnCurrentAmmoStateChanged; // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTagStateBool                          _isAmmoOnCooldown;                                 // 0x00D8(0x0030)(Net, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const int32 maxAmmo)> _onMaxAmmoSet;                               // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	float                                         _rechargeEndTime;                                  // 0x0118(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isTunableInit;                                    // 0x011C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     _projectileClass;                                  // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _expirationCooldownTime;                           // 0x0128(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDBDTunableRowHandle>           _firedCooldownTimesPerCrow;                        // 0x01A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _cooldownReductionPerCrowFired;                    // 0x01B8(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _expirationTime;                                   // 0x0238(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _expirationWarningBufferTime;                      // 0x02B8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _maxAmmo;                                          // 0x02E0(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _currentAmmo;                                      // 0x0360(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EK26AmmoCooldownReason                        _lastCooldownReason;                               // 0x0364(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EK26AmmoState                                 _currentAmmoState;                                 // 0x0365(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_366[0x2];                                      // 0x0366(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UK26PathHandlerComponent*               _pathHandler;                                      // 0x0368(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26PowerStatusHandlerComponent*        _statusHandler;                                    // 0x0370(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAuthoritativeActorPoolComponent*       _authoritativeActorPoolComponent;                  // 0x0378(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTagStateBool                          _isOutOfAmmo;                                      // 0x0380(0x0030)(Net, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fallbackFireCooldown;                             // 0x03B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B4[0x9C];                                     // 0x03B4(0x009C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_InitializePoolComponent(const int32 maxAmmo);
	void Authority_OnAmmoInit(class AActor* initAmmo);
	void CallOnMaxAmmoSet(TDelegate<void(const int32 maxAmmo)> callback);
	void Cosmetic_OnAmmoExpired();
	void Cosmetic_OnAmmoHasBeenFired();
	void Cosmetic_OnExpiringWarning();
	void Multicast_OnAmmoExpired();
	void Multicast_OnAmmoHasBeenFired();
	void Multicast_OnCurrentAmmoStateChanged(const EK26AmmoState newState, const int32 currentAmmo, const int32 maxAmmo);
	void Multicast_StartExpiring();
	void Multicast_StartRecharging(const EK26AmmoCooldownReason lastCooldownReason);
	void OnKillerSet(class ASlasherPlayer* killer);
	void OnLevelReadyToPlay();
	void SendHasExpiredDelegate();
	void SetDependencies(class UK26PathHandlerComponent* pathHandler, class UK26PowerStatusHandlerComponent* statusHandler, class UAuthoritativeActorPoolComponent* authoritativeActorPoolComponent);

	int32 GetCurrentAmmo() const;
	EK26AmmoState GetCurrentAmmoState() const;
	EK26AmmoCooldownReason GetCurrentCooldownReason() const;
	int32 GetMaxAmmo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26AmmoHandlerComponent">();
	}
	static class UK26AmmoHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26AmmoHandlerComponent>();
	}
};
static_assert(alignof(UK26AmmoHandlerComponent) == 0x000008, "Wrong alignment on UK26AmmoHandlerComponent");
static_assert(sizeof(UK26AmmoHandlerComponent) == 0x000450, "Wrong size on UK26AmmoHandlerComponent");
static_assert(offsetof(UK26AmmoHandlerComponent, OnCurrentAmmoStateChanged) == 0x0000C8, "Member 'UK26AmmoHandlerComponent::OnCurrentAmmoStateChanged' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _isAmmoOnCooldown) == 0x0000D8, "Member 'UK26AmmoHandlerComponent::_isAmmoOnCooldown' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _onMaxAmmoSet) == 0x000108, "Member 'UK26AmmoHandlerComponent::_onMaxAmmoSet' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _rechargeEndTime) == 0x000118, "Member 'UK26AmmoHandlerComponent::_rechargeEndTime' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _isTunableInit) == 0x00011C, "Member 'UK26AmmoHandlerComponent::_isTunableInit' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _projectileClass) == 0x000120, "Member 'UK26AmmoHandlerComponent::_projectileClass' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _expirationCooldownTime) == 0x000128, "Member 'UK26AmmoHandlerComponent::_expirationCooldownTime' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _firedCooldownTimesPerCrow) == 0x0001A8, "Member 'UK26AmmoHandlerComponent::_firedCooldownTimesPerCrow' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _cooldownReductionPerCrowFired) == 0x0001B8, "Member 'UK26AmmoHandlerComponent::_cooldownReductionPerCrowFired' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _expirationTime) == 0x000238, "Member 'UK26AmmoHandlerComponent::_expirationTime' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _expirationWarningBufferTime) == 0x0002B8, "Member 'UK26AmmoHandlerComponent::_expirationWarningBufferTime' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _maxAmmo) == 0x0002E0, "Member 'UK26AmmoHandlerComponent::_maxAmmo' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _currentAmmo) == 0x000360, "Member 'UK26AmmoHandlerComponent::_currentAmmo' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _lastCooldownReason) == 0x000364, "Member 'UK26AmmoHandlerComponent::_lastCooldownReason' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _currentAmmoState) == 0x000365, "Member 'UK26AmmoHandlerComponent::_currentAmmoState' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _pathHandler) == 0x000368, "Member 'UK26AmmoHandlerComponent::_pathHandler' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _statusHandler) == 0x000370, "Member 'UK26AmmoHandlerComponent::_statusHandler' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _authoritativeActorPoolComponent) == 0x000378, "Member 'UK26AmmoHandlerComponent::_authoritativeActorPoolComponent' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _isOutOfAmmo) == 0x000380, "Member 'UK26AmmoHandlerComponent::_isOutOfAmmo' has a wrong offset!");
static_assert(offsetof(UK26AmmoHandlerComponent, _fallbackFireCooldown) == 0x0003B0, "Member 'UK26AmmoHandlerComponent::_fallbackFireCooldown' has a wrong offset!");

// Class TheK26.K26AnimInstance
// 0x0010 (0x0610 - 0x0600)
class UK26AnimInstance final : public UKillerAnimInstance
{
public:
	bool                                          _isUsingPower;                                     // 0x0600(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_601[0xF];                                      // 0x0601(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26AnimInstance">();
	}
	static class UK26AnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26AnimInstance>();
	}
};
static_assert(alignof(UK26AnimInstance) == 0x000010, "Wrong alignment on UK26AnimInstance");
static_assert(sizeof(UK26AnimInstance) == 0x000610, "Wrong size on UK26AnimInstance");
static_assert(offsetof(UK26AnimInstance, _isUsingPower) == 0x000600, "Member 'UK26AnimInstance::_isUsingPower' has a wrong offset!");

// Class TheK26.K26AttachedCrow
// 0x01C0 (0x03F0 - 0x0230)
class AK26AttachedCrow final : public AActor
{
public:
	uint8                                         Pad_230[0x40];                                     // 0x0230(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTunableStat                           _lingerTime;                                       // 0x0270(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _infectionDelay;                                   // 0x02F0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _infectRadius;                                     // 0x0318(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26PowerOutlineUpdateStrategy*         _outlineUpdateStrategy;                            // 0x0340(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x0348(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   _visualStaticMeshComponent;                        // 0x0350(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        _rootComponent;                                    // 0x0358(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26PowerStatusHandlerComponent*        _statusHandler;                                    // 0x0360(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _authority_isInfecting;                            // 0x0368(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FK26AttachmentStatus                   _attachmentStatus;                                 // 0x0369(0x0002)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_36B[0x85];                                     // 0x036B(0x0085)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_ActivateInfection();
	void Authority_DeactivateInfection();
	void Authority_OnIsWithinOtherSurvivorRangeChanged(class AActor* survivorActor, const bool isInRange);
	void Authority_OnKillerSet(class ASlasherPlayer* killer);
	void Authority_OnOtherAttachedCrowRemoved();
	void Authority_OnOtherSurvivorDamageStateChanged(ECamperDamageState before, ECamperDamageState after);
	void Authority_OnOtherSurvivorGuidedActionChanged();
	void Authority_OnOtherSurvivorPerkFlagsChanged(const struct FGameplayTag& gameplayTag, bool isAdded);
	void Authority_OnPlayerLeftGame(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Authority_OnSurvivorAdded(class ACamperPlayer* survivor);
	void Authority_OnSurvivorDroppedEnd();
	void Authority_OnSurvivorExitLocker(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Authority_OnSurvivorStatusIndicatorSet(const class ACamperPlayer* survivor, class AK26AttachedCrow* attachedCrow);
	void Authority_OnSurvivorWasUnhooked(const struct FGameplayTag& gameEventType, const struct FGameEventData& gameEventData);
	void Cosmetic_OnAttachedCrowRemoved(EFK26AttachedCrowRemovalReason removalReason);
	void Cosmetic_OnAuraHidden();
	void Cosmetic_OnAuraShown();
	void Cosmetic_OnCrowAttached();
	void Cosmetic_OnStartDetaching();
	void Cosmetic_OnStopDetaching();
	void HideOutline();
	void Multicast_OnStartDetaching();
	void Multicast_OnStopDetaching();
	void OnRep_AttachmentStatus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26AttachedCrow">();
	}
	static class AK26AttachedCrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK26AttachedCrow>();
	}
};
static_assert(alignof(AK26AttachedCrow) == 0x000008, "Wrong alignment on AK26AttachedCrow");
static_assert(sizeof(AK26AttachedCrow) == 0x0003F0, "Wrong size on AK26AttachedCrow");
static_assert(offsetof(AK26AttachedCrow, _lingerTime) == 0x000270, "Member 'AK26AttachedCrow::_lingerTime' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _infectionDelay) == 0x0002F0, "Member 'AK26AttachedCrow::_infectionDelay' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _infectRadius) == 0x000318, "Member 'AK26AttachedCrow::_infectRadius' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _outlineUpdateStrategy) == 0x000340, "Member 'AK26AttachedCrow::_outlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _outlineComponent) == 0x000348, "Member 'AK26AttachedCrow::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _visualStaticMeshComponent) == 0x000350, "Member 'AK26AttachedCrow::_visualStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _rootComponent) == 0x000358, "Member 'AK26AttachedCrow::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _statusHandler) == 0x000360, "Member 'AK26AttachedCrow::_statusHandler' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _authority_isInfecting) == 0x000368, "Member 'AK26AttachedCrow::_authority_isInfecting' has a wrong offset!");
static_assert(offsetof(AK26AttachedCrow, _attachmentStatus) == 0x000369, "Member 'AK26AttachedCrow::_attachmentStatus' has a wrong offset!");

// Class TheK26.K26CooldownInteractionDefinition
// 0x0080 (0x06A0 - 0x0620)
class UK26CooldownInteractionDefinition final : public UInteractionDefinition
{
public:
	struct FTunableStat                           _cooldownTime;                                     // 0x0618(0x0080)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_698[0x8];                                      // 0x0698(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnKillerSet(class ASlasherPlayer* killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26CooldownInteractionDefinition">();
	}
	static class UK26CooldownInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26CooldownInteractionDefinition>();
	}
};
static_assert(alignof(UK26CooldownInteractionDefinition) == 0x000010, "Wrong alignment on UK26CooldownInteractionDefinition");
static_assert(sizeof(UK26CooldownInteractionDefinition) == 0x0006A0, "Wrong size on UK26CooldownInteractionDefinition");
static_assert(offsetof(UK26CooldownInteractionDefinition, _cooldownTime) == 0x000618, "Member 'UK26CooldownInteractionDefinition::_cooldownTime' has a wrong offset!");

// Class TheK26.K26CrowAttachmentSubAnimInstance
// 0x0010 (0x0560 - 0x0550)
class UK26CrowAttachmentSubAnimInstance final : public UBaseSurvivorAnimInstance
{
public:
	uint8                                         Pad_548[0x8];                                      // 0x0548(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _hasCrowAttached;                                  // 0x0550(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isRemovingCrow;                                   // 0x0551(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isIdle;                                           // 0x0552(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrawling;                                       // 0x0553(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isDead;                                           // 0x0554(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHooked;                                         // 0x0555(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInsideCloset;                                   // 0x0556(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInteracting;                                    // 0x0557(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isHoldingSmallItem;                               // 0x0558(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isUsingAimItem;                                   // 0x0559(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isCrouched;                                       // 0x055A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55B[0x5];                                      // 0x055B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26CrowAttachmentSubAnimInstance">();
	}
	static class UK26CrowAttachmentSubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26CrowAttachmentSubAnimInstance>();
	}
};
static_assert(alignof(UK26CrowAttachmentSubAnimInstance) == 0x000010, "Wrong alignment on UK26CrowAttachmentSubAnimInstance");
static_assert(sizeof(UK26CrowAttachmentSubAnimInstance) == 0x000560, "Wrong size on UK26CrowAttachmentSubAnimInstance");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _hasCrowAttached) == 0x000550, "Member 'UK26CrowAttachmentSubAnimInstance::_hasCrowAttached' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isRemovingCrow) == 0x000551, "Member 'UK26CrowAttachmentSubAnimInstance::_isRemovingCrow' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isIdle) == 0x000552, "Member 'UK26CrowAttachmentSubAnimInstance::_isIdle' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isCrawling) == 0x000553, "Member 'UK26CrowAttachmentSubAnimInstance::_isCrawling' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isDead) == 0x000554, "Member 'UK26CrowAttachmentSubAnimInstance::_isDead' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isHooked) == 0x000555, "Member 'UK26CrowAttachmentSubAnimInstance::_isHooked' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isInsideCloset) == 0x000556, "Member 'UK26CrowAttachmentSubAnimInstance::_isInsideCloset' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isInteracting) == 0x000557, "Member 'UK26CrowAttachmentSubAnimInstance::_isInteracting' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isHoldingSmallItem) == 0x000558, "Member 'UK26CrowAttachmentSubAnimInstance::_isHoldingSmallItem' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isUsingAimItem) == 0x000559, "Member 'UK26CrowAttachmentSubAnimInstance::_isUsingAimItem' has a wrong offset!");
static_assert(offsetof(UK26CrowAttachmentSubAnimInstance, _isCrouched) == 0x00055A, "Member 'UK26CrowAttachmentSubAnimInstance::_isCrouched' has a wrong offset!");

// Class TheK26.K26CrowPlacementValidatorComponent
// 0x0008 (0x00C0 - 0x00B8)
class UK26CrowPlacementValidatorComponent final : public UActorComponent
{
public:
	class UObjectPlacementValidationWithRestrictionStrategy* _objectPlacementValidationStrategyWithRestrictions; // 0x00B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26CrowPlacementValidatorComponent">();
	}
	static class UK26CrowPlacementValidatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26CrowPlacementValidatorComponent>();
	}
};
static_assert(alignof(UK26CrowPlacementValidatorComponent) == 0x000008, "Wrong alignment on UK26CrowPlacementValidatorComponent");
static_assert(sizeof(UK26CrowPlacementValidatorComponent) == 0x0000C0, "Wrong size on UK26CrowPlacementValidatorComponent");
static_assert(offsetof(UK26CrowPlacementValidatorComponent, _objectPlacementValidationStrategyWithRestrictions) == 0x0000B8, "Member 'UK26CrowPlacementValidatorComponent::_objectPlacementValidationStrategyWithRestrictions' has a wrong offset!");

// Class TheK26.K26CrowProjectile
// 0x04C8 (0x06F8 - 0x0230)
class AK26CrowProjectile final : public AActor
{
public:
	uint8                                         Pad_230[0x10];                                     // 0x0230(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AK26CrowProjectile* crowProjectile)> OnCrowProjectileStateChanged; // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVector                                _originalFireLocation;                             // 0x0250(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EK26ProjectileState, struct FK26ProjectileStateDetails> _projectileStateDetails;            // 0x0260(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _summonTime;                                       // 0x02B0(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _detectionRadiusScaleX;                            // 0x02D8(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _detectionRadiusScaleY;                            // 0x0358(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTunableStat                           _detectionRadiusScaleZ;                            // 0x03D8(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _crowFireAuraVisibilityForSurvivorsTime;           // 0x0458(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _crowSummonAuraVisibilityForSurvivorsTime;         // 0x0480(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _detectionRadiusFromAbove;                         // 0x04A8(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _baseSpeed;                                        // 0x04D0(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _selfDestructTimeOnDestroyed;                      // 0x04F8(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDBDTunableRowHandle                   _rangeToTriggerNearSurvivorSFX;                    // 0x0520(0x0028)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _onPathMovementSpeedModifierCurve;                 // 0x0548(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _offPathMovementSpeedModifierCurve;                // 0x0550(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _projectileOffPathCurveDuration;                   // 0x0558(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55C[0x4];                                      // 0x055C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        _path;                                             // 0x0560(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         _pooledPathIndex;                                  // 0x0570(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EK26ProjectileState                           _currentProjectileState;                           // 0x0574(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_575[0x3];                                      // 0x0575(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UK26PowerOutlineUpdateStrategy*         _outlineUpdateStrategy;                            // 0x0578(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK26PowerOutlineUpdateStrategy*         _crowFlockOutlineUpdateStrategy;                   // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x0588(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       _pathSplineComponent;                              // 0x0590(0x0008)(Edit, ExportObject, Net, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _collisionStaticMeshComponent;                     // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _killerInstinctStaticMeshComponent;                // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDSkeletalMeshComponentBudgeted*      _visualSkeletalMeshComponent;                      // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootComponent;                                    // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDNavModifierComponent*               _dangerNavModifierComponent;                       // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(EK26ProjectileState newState, const struct FK26ProjectileStateDetails& newDetails)> _k26ProjectileStateChangeDelegate; // 0x05C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(const bool acquired)> OnAcquiredChanged;                           // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E0[0x10];                                     // 0x05E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                _forwardDirection;                                 // 0x05F0(0x000C)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _fireTime;                                         // 0x05FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _currentDistanceAlongSpline;                       // 0x0600(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _offPathTime;                                      // 0x0604(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26PowerStatusHandlerComponent*        _statusHandlerComponent;                           // 0x0608(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26AmmoHandlerComponent*               _ammoHandlerComponent;                             // 0x0610(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26PathHandlerComponent*               _pathHandlerComponent;                             // 0x0618(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_620[0xD8];                                     // 0x0620(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCollisionOverlapBegin(class UPrimitiveComponent* overlappedComp, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool fromSweep, const struct FHitResult& sweepResult);
	void Authority_OnCollisionOverlapEnd(class UPrimitiveComponent* overlappedComp, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex);
	void Authority_OnDestroyAttempt(const TArray<class AActor*>& instigatorsForCompletion);
	void Authority_OnDestroyTimerExpired();
	void Authority_OnScoutingOverlapBegin(class UPrimitiveComponent* overlappedComp, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool fromSweep, const struct FHitResult& sweepResult);
	void Authority_OnSummonComplete();
	void Client_LocalKillerStartSummonTimer(const float killerLocalSummonTime);
	void Cosmetic_OnEnteredNearAudioRangeOfSurvivor(class ACamperPlayer* survivor);
	void Cosmetic_OnExpiration();
	void HideOutlineFromSurvivor();
	void Local_OnCollisionOverlapBegin(class UPrimitiveComponent* overlappedComp, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool fromSweep, const struct FHitResult& sweepResult);
	void Local_OnSummonComplete();
	void Multicast_OnExpiration();
	void Multicast_SetStartingPosition(const struct FVector& position, const struct FRotator& angle);
	void Multicast_SetState(const EK26ProjectileState newState, const int32 pooledPathIndex);
	void OnIntroCompleted();
	void OnIsWithinSurvivorRangeChanged(class AActor* survivorActor, const bool isInRange);
	void OnLevelReadyToPlay();
	void OnRep_Path();
	void OnSurvivorAdded(class ACamperPlayer* survivorAdded);
	void ProjectileWentOutOfBoundsEvent();
	void Server_OnSurvivorHit(const EK26ProjectileState stateOnHit, class ACamperPlayer* hitSurvivor);

	float GetDistanceFromFirePosition() const;
	bool IsHitboxBeingShown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26CrowProjectile">();
	}
	static class AK26CrowProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK26CrowProjectile>();
	}
};
static_assert(alignof(AK26CrowProjectile) == 0x000008, "Wrong alignment on AK26CrowProjectile");
static_assert(sizeof(AK26CrowProjectile) == 0x0006F8, "Wrong size on AK26CrowProjectile");
static_assert(offsetof(AK26CrowProjectile, OnCrowProjectileStateChanged) == 0x000240, "Member 'AK26CrowProjectile::OnCrowProjectileStateChanged' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _originalFireLocation) == 0x000250, "Member 'AK26CrowProjectile::_originalFireLocation' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _projectileStateDetails) == 0x000260, "Member 'AK26CrowProjectile::_projectileStateDetails' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _summonTime) == 0x0002B0, "Member 'AK26CrowProjectile::_summonTime' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _detectionRadiusScaleX) == 0x0002D8, "Member 'AK26CrowProjectile::_detectionRadiusScaleX' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _detectionRadiusScaleY) == 0x000358, "Member 'AK26CrowProjectile::_detectionRadiusScaleY' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _detectionRadiusScaleZ) == 0x0003D8, "Member 'AK26CrowProjectile::_detectionRadiusScaleZ' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _crowFireAuraVisibilityForSurvivorsTime) == 0x000458, "Member 'AK26CrowProjectile::_crowFireAuraVisibilityForSurvivorsTime' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _crowSummonAuraVisibilityForSurvivorsTime) == 0x000480, "Member 'AK26CrowProjectile::_crowSummonAuraVisibilityForSurvivorsTime' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _detectionRadiusFromAbove) == 0x0004A8, "Member 'AK26CrowProjectile::_detectionRadiusFromAbove' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _baseSpeed) == 0x0004D0, "Member 'AK26CrowProjectile::_baseSpeed' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _selfDestructTimeOnDestroyed) == 0x0004F8, "Member 'AK26CrowProjectile::_selfDestructTimeOnDestroyed' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _rangeToTriggerNearSurvivorSFX) == 0x000520, "Member 'AK26CrowProjectile::_rangeToTriggerNearSurvivorSFX' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _onPathMovementSpeedModifierCurve) == 0x000548, "Member 'AK26CrowProjectile::_onPathMovementSpeedModifierCurve' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _offPathMovementSpeedModifierCurve) == 0x000550, "Member 'AK26CrowProjectile::_offPathMovementSpeedModifierCurve' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _projectileOffPathCurveDuration) == 0x000558, "Member 'AK26CrowProjectile::_projectileOffPathCurveDuration' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _path) == 0x000560, "Member 'AK26CrowProjectile::_path' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _pooledPathIndex) == 0x000570, "Member 'AK26CrowProjectile::_pooledPathIndex' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _currentProjectileState) == 0x000574, "Member 'AK26CrowProjectile::_currentProjectileState' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _outlineUpdateStrategy) == 0x000578, "Member 'AK26CrowProjectile::_outlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _crowFlockOutlineUpdateStrategy) == 0x000580, "Member 'AK26CrowProjectile::_crowFlockOutlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _outlineComponent) == 0x000588, "Member 'AK26CrowProjectile::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _pathSplineComponent) == 0x000590, "Member 'AK26CrowProjectile::_pathSplineComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _collisionStaticMeshComponent) == 0x000598, "Member 'AK26CrowProjectile::_collisionStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _killerInstinctStaticMeshComponent) == 0x0005A0, "Member 'AK26CrowProjectile::_killerInstinctStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _visualSkeletalMeshComponent) == 0x0005A8, "Member 'AK26CrowProjectile::_visualSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _rootComponent) == 0x0005B0, "Member 'AK26CrowProjectile::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _dangerNavModifierComponent) == 0x0005B8, "Member 'AK26CrowProjectile::_dangerNavModifierComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _k26ProjectileStateChangeDelegate) == 0x0005C0, "Member 'AK26CrowProjectile::_k26ProjectileStateChangeDelegate' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, OnAcquiredChanged) == 0x0005D0, "Member 'AK26CrowProjectile::OnAcquiredChanged' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _forwardDirection) == 0x0005F0, "Member 'AK26CrowProjectile::_forwardDirection' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _fireTime) == 0x0005FC, "Member 'AK26CrowProjectile::_fireTime' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _currentDistanceAlongSpline) == 0x000600, "Member 'AK26CrowProjectile::_currentDistanceAlongSpline' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _offPathTime) == 0x000604, "Member 'AK26CrowProjectile::_offPathTime' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _statusHandlerComponent) == 0x000608, "Member 'AK26CrowProjectile::_statusHandlerComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _ammoHandlerComponent) == 0x000610, "Member 'AK26CrowProjectile::_ammoHandlerComponent' has a wrong offset!");
static_assert(offsetof(AK26CrowProjectile, _pathHandlerComponent) == 0x000618, "Member 'AK26CrowProjectile::_pathHandlerComponent' has a wrong offset!");

// Class TheK26.K26CrowProjectileAnimInstance
// 0x0040 (0x0300 - 0x02C0)
class UK26CrowProjectileAnimInstance final : public UAnimInstance
{
public:
	bool                                          _isInInvalidState;                                 // 0x02C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInSummonState;                                  // 0x02C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInIdleState;                                    // 0x02C2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInFollowPathState;                              // 0x02C3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInOffPathState;                                 // 0x02C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isInDestroyedState;                               // 0x02C5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isBeingFlashlighted;                              // 0x02C6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C7[0x1];                                      // 0x02C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _flashlightProgress;                               // 0x02C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2CC[0x24];                                     // 0x02CC(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	class AK26CrowProjectile*                     _owningCrowProjectile;                             // 0x02F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F8[0x8];                                      // 0x02F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26CrowProjectileAnimInstance">();
	}
	static class UK26CrowProjectileAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26CrowProjectileAnimInstance>();
	}
};
static_assert(alignof(UK26CrowProjectileAnimInstance) == 0x000010, "Wrong alignment on UK26CrowProjectileAnimInstance");
static_assert(sizeof(UK26CrowProjectileAnimInstance) == 0x000300, "Wrong size on UK26CrowProjectileAnimInstance");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _isInInvalidState) == 0x0002C0, "Member 'UK26CrowProjectileAnimInstance::_isInInvalidState' has a wrong offset!");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _isInSummonState) == 0x0002C1, "Member 'UK26CrowProjectileAnimInstance::_isInSummonState' has a wrong offset!");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _isInIdleState) == 0x0002C2, "Member 'UK26CrowProjectileAnimInstance::_isInIdleState' has a wrong offset!");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _isInFollowPathState) == 0x0002C3, "Member 'UK26CrowProjectileAnimInstance::_isInFollowPathState' has a wrong offset!");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _isInOffPathState) == 0x0002C4, "Member 'UK26CrowProjectileAnimInstance::_isInOffPathState' has a wrong offset!");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _isInDestroyedState) == 0x0002C5, "Member 'UK26CrowProjectileAnimInstance::_isInDestroyedState' has a wrong offset!");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _isBeingFlashlighted) == 0x0002C6, "Member 'UK26CrowProjectileAnimInstance::_isBeingFlashlighted' has a wrong offset!");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _flashlightProgress) == 0x0002C8, "Member 'UK26CrowProjectileAnimInstance::_flashlightProgress' has a wrong offset!");
static_assert(offsetof(UK26CrowProjectileAnimInstance, _owningCrowProjectile) == 0x0002F0, "Member 'UK26CrowProjectileAnimInstance::_owningCrowProjectile' has a wrong offset!");

// Class TheK26.K26CrowProjectilePlacementValidationStrategy
// 0x0020 (0x00C0 - 0x00A0)
class UK26CrowProjectilePlacementValidationStrategy final : public URestrictedPlacementAreaStrategy
{
public:
	uint8                                         Pad_A0[0x18];                                      // 0x00A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UK26AmmoHandlerComponent*               _ammoHandler;                                      // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26CrowProjectilePlacementValidationStrategy">();
	}
	static class UK26CrowProjectilePlacementValidationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26CrowProjectilePlacementValidationStrategy>();
	}
};
static_assert(alignof(UK26CrowProjectilePlacementValidationStrategy) == 0x000008, "Wrong alignment on UK26CrowProjectilePlacementValidationStrategy");
static_assert(sizeof(UK26CrowProjectilePlacementValidationStrategy) == 0x0000C0, "Wrong size on UK26CrowProjectilePlacementValidationStrategy");
static_assert(offsetof(UK26CrowProjectilePlacementValidationStrategy, _ammoHandler) == 0x0000B8, "Member 'UK26CrowProjectilePlacementValidationStrategy::_ammoHandler' has a wrong offset!");

// Class TheK26.K26DismissCrowChargeableInteractionDefinition
// 0x00A0 (0x07E0 - 0x0740)
class UK26DismissCrowChargeableInteractionDefinition final : public UChargeableInteractionDefinition
{
public:
	struct FTunableStat                           _chargeTime;                                       // 0x0740(0x0080)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK26PowerStatusHandlerComponent*        _k26PowerStatusHandlerComponent;                   // 0x07C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isLevelReadyToPlay;                               // 0x07C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7C9[0x17];                                     // 0x07C9(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDamageStateChanged(ECamperDamageState oldDamageState, ECamperDamageState currentDamageState);
	void OnKillerSet(class ASlasherPlayer* killer, class UChargeableComponent* chargeableComponent);
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26DismissCrowChargeableInteractionDefinition">();
	}
	static class UK26DismissCrowChargeableInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26DismissCrowChargeableInteractionDefinition>();
	}
};
static_assert(alignof(UK26DismissCrowChargeableInteractionDefinition) == 0x000010, "Wrong alignment on UK26DismissCrowChargeableInteractionDefinition");
static_assert(sizeof(UK26DismissCrowChargeableInteractionDefinition) == 0x0007E0, "Wrong size on UK26DismissCrowChargeableInteractionDefinition");
static_assert(offsetof(UK26DismissCrowChargeableInteractionDefinition, _chargeTime) == 0x000740, "Member 'UK26DismissCrowChargeableInteractionDefinition::_chargeTime' has a wrong offset!");
static_assert(offsetof(UK26DismissCrowChargeableInteractionDefinition, _k26PowerStatusHandlerComponent) == 0x0007C0, "Member 'UK26DismissCrowChargeableInteractionDefinition::_k26PowerStatusHandlerComponent' has a wrong offset!");
static_assert(offsetof(UK26DismissCrowChargeableInteractionDefinition, _isLevelReadyToPlay) == 0x0007C8, "Member 'UK26DismissCrowChargeableInteractionDefinition::_isLevelReadyToPlay' has a wrong offset!");

// Class TheK26.K26FireCrowProjectileInteractionDefinition
// 0x0020 (0x0640 - 0x0620)
class UK26FireCrowProjectileInteractionDefinition final : public UInteractionDefinition
{
public:
	TMulticastInlineDelegate<void()>              OnProjectileFired;                                 // 0x0618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UK26CooldownInteractionDefinition*      _cooldownInteraction;                              // 0x0628(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26AmmoHandlerComponent*               _ammoHandler;                                      // 0x0630(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26PathHandlerComponent*               _pathHandler;                                      // 0x0638(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Multicast_OnProjectileFired(const class ASlasherPlayer* killer);
	void Server_RequestFireOnAmmo(class ASlasherPlayer* killer);
	void SetDependencies(class UK26AmmoHandlerComponent* ammoHandler, class UK26PathHandlerComponent* pathHandler, class UK26CooldownInteractionDefinition* cooldownInteraction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26FireCrowProjectileInteractionDefinition">();
	}
	static class UK26FireCrowProjectileInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26FireCrowProjectileInteractionDefinition>();
	}
};
static_assert(alignof(UK26FireCrowProjectileInteractionDefinition) == 0x000010, "Wrong alignment on UK26FireCrowProjectileInteractionDefinition");
static_assert(sizeof(UK26FireCrowProjectileInteractionDefinition) == 0x000640, "Wrong size on UK26FireCrowProjectileInteractionDefinition");
static_assert(offsetof(UK26FireCrowProjectileInteractionDefinition, OnProjectileFired) == 0x000618, "Member 'UK26FireCrowProjectileInteractionDefinition::OnProjectileFired' has a wrong offset!");
static_assert(offsetof(UK26FireCrowProjectileInteractionDefinition, _cooldownInteraction) == 0x000628, "Member 'UK26FireCrowProjectileInteractionDefinition::_cooldownInteraction' has a wrong offset!");
static_assert(offsetof(UK26FireCrowProjectileInteractionDefinition, _ammoHandler) == 0x000630, "Member 'UK26FireCrowProjectileInteractionDefinition::_ammoHandler' has a wrong offset!");
static_assert(offsetof(UK26FireCrowProjectileInteractionDefinition, _pathHandler) == 0x000638, "Member 'UK26FireCrowProjectileInteractionDefinition::_pathHandler' has a wrong offset!");

// Class TheK26.K26IsLastCrowRemovalReasonDueToInteraction
// 0x0018 (0x0100 - 0x00E8)
class UK26IsLastCrowRemovalReasonDueToInteraction final : public UEventDrivenModifierCondition
{
public:
	class AK26AttachedCrow*                       _owningAttachedCrow;                               // 0x00E8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26PowerStatusHandlerComponent*        _statusHandlerComponent;                           // 0x00F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnKillerSet(class ASlasherPlayer* killer);
	void Authority_OnSurvivorStatusIndicatorSet(const class ACamperPlayer* survivor, class AK26AttachedCrow* attachedCrow);
	void OnLastRemovalReasonSet(EFK26AttachedCrowRemovalReason lastCrowRemovalReason);
	void OnRep_OwningAttachedCrow();
	void OnSurvivorStatusIndicatorSet(class AK26AttachedCrow* attachedCrow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26IsLastCrowRemovalReasonDueToInteraction">();
	}
	static class UK26IsLastCrowRemovalReasonDueToInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26IsLastCrowRemovalReasonDueToInteraction>();
	}
};
static_assert(alignof(UK26IsLastCrowRemovalReasonDueToInteraction) == 0x000008, "Wrong alignment on UK26IsLastCrowRemovalReasonDueToInteraction");
static_assert(sizeof(UK26IsLastCrowRemovalReasonDueToInteraction) == 0x000100, "Wrong size on UK26IsLastCrowRemovalReasonDueToInteraction");
static_assert(offsetof(UK26IsLastCrowRemovalReasonDueToInteraction, _owningAttachedCrow) == 0x0000E8, "Member 'UK26IsLastCrowRemovalReasonDueToInteraction::_owningAttachedCrow' has a wrong offset!");
static_assert(offsetof(UK26IsLastCrowRemovalReasonDueToInteraction, _statusHandlerComponent) == 0x0000F0, "Member 'UK26IsLastCrowRemovalReasonDueToInteraction::_statusHandlerComponent' has a wrong offset!");

// Class TheK26.K26IsSurvivorInRangeOfAnyIdleCrow
// 0x0030 (0x0118 - 0x00E8)
class UK26IsSurvivorInRangeOfAnyIdleCrow final : public UEventDrivenModifierCondition
{
public:
	TMulticastInlineDelegate<void(bool isTrue)>   OnIsTrueChanged;                                   // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACamperPlayer*                          _trackedSurvivor;                                  // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnCrowAddedToPool(class AActor* crowProjectileActor);
	void Authority_OnCrowProjectileStateChanged(class AK26CrowProjectile* crowProjectile);
	void Authority_OnInRangeChanged(const bool inRange);
	void Authority_SetVariables(class ACamperPlayer* trackedSurvivor, class UAuthoritativeActorPoolComponent* authoritativeActorPoolComponent, const float range);
	void Multicast_SetIsTrue(const bool isTrue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26IsSurvivorInRangeOfAnyIdleCrow">();
	}
	static class UK26IsSurvivorInRangeOfAnyIdleCrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26IsSurvivorInRangeOfAnyIdleCrow>();
	}
};
static_assert(alignof(UK26IsSurvivorInRangeOfAnyIdleCrow) == 0x000008, "Wrong alignment on UK26IsSurvivorInRangeOfAnyIdleCrow");
static_assert(sizeof(UK26IsSurvivorInRangeOfAnyIdleCrow) == 0x000118, "Wrong size on UK26IsSurvivorInRangeOfAnyIdleCrow");
static_assert(offsetof(UK26IsSurvivorInRangeOfAnyIdleCrow, OnIsTrueChanged) == 0x0000E8, "Member 'UK26IsSurvivorInRangeOfAnyIdleCrow::OnIsTrueChanged' has a wrong offset!");
static_assert(offsetof(UK26IsSurvivorInRangeOfAnyIdleCrow, _trackedSurvivor) == 0x000100, "Member 'UK26IsSurvivorInRangeOfAnyIdleCrow::_trackedSurvivor' has a wrong offset!");

// Class TheK26.K26KillerInstinctStatusEffect
// 0x0090 (0x03E0 - 0x0350)
class UK26KillerInstinctStatusEffect final : public UStatusEffect
{
public:
	struct FTunableStat                           _lingerDuration;                                   // 0x0350(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UInteractionDefinition>     _openExitGateInteractionClass;                     // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasInitializedLingerDuration;                     // 0x03D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26KillerInstinctStatusEffect">();
	}
	static class UK26KillerInstinctStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26KillerInstinctStatusEffect>();
	}
};
static_assert(alignof(UK26KillerInstinctStatusEffect) == 0x000008, "Wrong alignment on UK26KillerInstinctStatusEffect");
static_assert(sizeof(UK26KillerInstinctStatusEffect) == 0x0003E0, "Wrong size on UK26KillerInstinctStatusEffect");
static_assert(offsetof(UK26KillerInstinctStatusEffect, _lingerDuration) == 0x000350, "Member 'UK26KillerInstinctStatusEffect::_lingerDuration' has a wrong offset!");
static_assert(offsetof(UK26KillerInstinctStatusEffect, _openExitGateInteractionClass) == 0x0003D0, "Member 'UK26KillerInstinctStatusEffect::_openExitGateInteractionClass' has a wrong offset!");
static_assert(offsetof(UK26KillerInstinctStatusEffect, _hasInitializedLingerDuration) == 0x0003D8, "Member 'UK26KillerInstinctStatusEffect::_hasInitializedLingerDuration' has a wrong offset!");

// Class TheK26.K26OnCrowAttachLingeringStatusEffectBase
// 0x0060 (0x03B0 - 0x0350)
class UK26OnCrowAttachLingeringStatusEffectBase final : public UStatusEffect
{
public:
	struct FGameplayTag                           _onCrowAttachStateTag;                             // 0x0350(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _lingerTime;                                       // 0x0360(0x0028)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x28];                                     // 0x0388(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetLingerTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26OnCrowAttachLingeringStatusEffectBase">();
	}
	static class UK26OnCrowAttachLingeringStatusEffectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26OnCrowAttachLingeringStatusEffectBase>();
	}
};
static_assert(alignof(UK26OnCrowAttachLingeringStatusEffectBase) == 0x000008, "Wrong alignment on UK26OnCrowAttachLingeringStatusEffectBase");
static_assert(sizeof(UK26OnCrowAttachLingeringStatusEffectBase) == 0x0003B0, "Wrong size on UK26OnCrowAttachLingeringStatusEffectBase");
static_assert(offsetof(UK26OnCrowAttachLingeringStatusEffectBase, _onCrowAttachStateTag) == 0x000350, "Member 'UK26OnCrowAttachLingeringStatusEffectBase::_onCrowAttachStateTag' has a wrong offset!");
static_assert(offsetof(UK26OnCrowAttachLingeringStatusEffectBase, _lingerTime) == 0x000360, "Member 'UK26OnCrowAttachLingeringStatusEffectBase::_lingerTime' has a wrong offset!");

// Class TheK26.K26P01
// 0x0080 (0x0448 - 0x03C8)
class UK26P01 final : public UPerk
{
public:
	float                                         _generatorBlockDuration[0x3];                      // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _auraRevealDuration[0x3];                          // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _generatorAuraColorForKiller;                      // 0x03E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _survivorsToBeHooked;                              // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _timedRevealToKillerClass;                         // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AGenerator*>                     _blockedGenerators;                                // 0x0400(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         _hookedSurvivors;                                  // 0x0410(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FFastTimer>                     _generatorBlockingTimers;                          // 0x0420(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _timedRevealToKillerEffect;                        // 0x0430(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x10];                                     // 0x0438(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnBlockTimerDone(class AGenerator* generator);
	void OnRep_BlockedGenerators();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26P01">();
	}
	static class UK26P01* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26P01>();
	}
};
static_assert(alignof(UK26P01) == 0x000008, "Wrong alignment on UK26P01");
static_assert(sizeof(UK26P01) == 0x000448, "Wrong size on UK26P01");
static_assert(offsetof(UK26P01, _generatorBlockDuration) == 0x0003C8, "Member 'UK26P01::_generatorBlockDuration' has a wrong offset!");
static_assert(offsetof(UK26P01, _auraRevealDuration) == 0x0003D4, "Member 'UK26P01::_auraRevealDuration' has a wrong offset!");
static_assert(offsetof(UK26P01, _generatorAuraColorForKiller) == 0x0003E0, "Member 'UK26P01::_generatorAuraColorForKiller' has a wrong offset!");
static_assert(offsetof(UK26P01, _survivorsToBeHooked) == 0x0003F0, "Member 'UK26P01::_survivorsToBeHooked' has a wrong offset!");
static_assert(offsetof(UK26P01, _timedRevealToKillerClass) == 0x0003F8, "Member 'UK26P01::_timedRevealToKillerClass' has a wrong offset!");
static_assert(offsetof(UK26P01, _blockedGenerators) == 0x000400, "Member 'UK26P01::_blockedGenerators' has a wrong offset!");
static_assert(offsetof(UK26P01, _hookedSurvivors) == 0x000410, "Member 'UK26P01::_hookedSurvivors' has a wrong offset!");
static_assert(offsetof(UK26P01, _generatorBlockingTimers) == 0x000420, "Member 'UK26P01::_generatorBlockingTimers' has a wrong offset!");
static_assert(offsetof(UK26P01, _timedRevealToKillerEffect) == 0x000430, "Member 'UK26P01::_timedRevealToKillerEffect' has a wrong offset!");

// Class TheK26.K26P02
// 0x0070 (0x0438 - 0x03C8)
class UK26P02 final : public UPerk
{
public:
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _generatorRegressPercentage[0x3];                  // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class ACamperPlayer*>                    _hookedPlayers;                                    // 0x03E0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_430[0x8];                                      // 0x0430(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorHookedOnScourgeHook(const struct FGameEventData& gameEventData);
	void Cosmetic_MakeSurvivorScream(const class ADBDPlayer* screamingSurvivor);
	void Multicast_TriggerPerk(class AGenerator* explodingGenerator);

	float GetGeneratorRegressPercentageAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26P02">();
	}
	static class UK26P02* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26P02>();
	}
};
static_assert(alignof(UK26P02) == 0x000008, "Wrong alignment on UK26P02");
static_assert(sizeof(UK26P02) == 0x000438, "Wrong size on UK26P02");
static_assert(offsetof(UK26P02, _generatorRegressPercentage) == 0x0003D0, "Member 'UK26P02::_generatorRegressPercentage' has a wrong offset!");
static_assert(offsetof(UK26P02, _hookedPlayers) == 0x0003E0, "Member 'UK26P02::_hookedPlayers' has a wrong offset!");

// Class TheK26.K26PathHandlerComponent
// 0x0178 (0x0230 - 0x00B8)
class UK26PathHandlerComponent final : public UActorComponent
{
public:
	struct FDBDTunableRowHandle                   _maxPathDistance;                                  // 0x00B8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _survivorPathVisibilityTimeOnFire;                 // 0x00E0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _defaultProjectileDistanceFromFloor;               // 0x0108(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxPathIterations;                                // 0x0130(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _maxGroundSearchingDistance;                       // 0x0158(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     _visualPathPart;                                   // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     _visualPathEndArrow;                               // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _projectileSummonDistance;                         // 0x0190(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26AmmoHandlerComponent*               _ammoHandler;                                      // 0x01B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26CrowPlacementValidatorComponent*    _placementValidator;                               // 0x01C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FK26PathData>                   _availablePathData;                                // 0x01C8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FK26Path>                       _availablePaths;                                   // 0x01D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x48];                                     // 0x01E8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnMaxAmmoSet(const int32 maxAmmo);
	void Multicast_FillAvailablePathArray(const int32 maxAmmo);
	void OnIterativeAvailablePathUpdate();
	void OnRep_AvailablePathData();
	void SetDependencies(class UK26AmmoHandlerComponent* ammoHandler, class UK26CrowPlacementValidatorComponent* placementValidator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26PathHandlerComponent">();
	}
	static class UK26PathHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26PathHandlerComponent>();
	}
};
static_assert(alignof(UK26PathHandlerComponent) == 0x000008, "Wrong alignment on UK26PathHandlerComponent");
static_assert(sizeof(UK26PathHandlerComponent) == 0x000230, "Wrong size on UK26PathHandlerComponent");
static_assert(offsetof(UK26PathHandlerComponent, _maxPathDistance) == 0x0000B8, "Member 'UK26PathHandlerComponent::_maxPathDistance' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _survivorPathVisibilityTimeOnFire) == 0x0000E0, "Member 'UK26PathHandlerComponent::_survivorPathVisibilityTimeOnFire' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _defaultProjectileDistanceFromFloor) == 0x000108, "Member 'UK26PathHandlerComponent::_defaultProjectileDistanceFromFloor' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _maxPathIterations) == 0x000130, "Member 'UK26PathHandlerComponent::_maxPathIterations' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _maxGroundSearchingDistance) == 0x000158, "Member 'UK26PathHandlerComponent::_maxGroundSearchingDistance' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _visualPathPart) == 0x000180, "Member 'UK26PathHandlerComponent::_visualPathPart' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _visualPathEndArrow) == 0x000188, "Member 'UK26PathHandlerComponent::_visualPathEndArrow' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _projectileSummonDistance) == 0x000190, "Member 'UK26PathHandlerComponent::_projectileSummonDistance' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _ammoHandler) == 0x0001B8, "Member 'UK26PathHandlerComponent::_ammoHandler' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _placementValidator) == 0x0001C0, "Member 'UK26PathHandlerComponent::_placementValidator' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _availablePathData) == 0x0001C8, "Member 'UK26PathHandlerComponent::_availablePathData' has a wrong offset!");
static_assert(offsetof(UK26PathHandlerComponent, _availablePaths) == 0x0001D8, "Member 'UK26PathHandlerComponent::_availablePaths' has a wrong offset!");

// Class TheK26.K26PathPart
// 0x0038 (0x0268 - 0x0230)
class AK26PathPart final : public AActor
{
public:
	class UStaticMeshComponent*                   _mesh;                                             // 0x0230(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x0238(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _visualEffectKiller;                               // 0x0240(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _visualEffectSurvivor;                             // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UK26PowerOutlineUpdateStrategy*         _outlineUpdateStrategy;                            // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        _rootComponent;                                    // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isVisibleForSurvivor;                             // 0x0260(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isVisibleForKiller;                               // 0x0261(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262[0x6];                                      // 0x0262(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26PathPart">();
	}
	static class AK26PathPart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AK26PathPart>();
	}
};
static_assert(alignof(AK26PathPart) == 0x000008, "Wrong alignment on AK26PathPart");
static_assert(sizeof(AK26PathPart) == 0x000268, "Wrong size on AK26PathPart");
static_assert(offsetof(AK26PathPart, _mesh) == 0x000230, "Member 'AK26PathPart::_mesh' has a wrong offset!");
static_assert(offsetof(AK26PathPart, _outlineComponent) == 0x000238, "Member 'AK26PathPart::_outlineComponent' has a wrong offset!");
static_assert(offsetof(AK26PathPart, _visualEffectKiller) == 0x000240, "Member 'AK26PathPart::_visualEffectKiller' has a wrong offset!");
static_assert(offsetof(AK26PathPart, _visualEffectSurvivor) == 0x000248, "Member 'AK26PathPart::_visualEffectSurvivor' has a wrong offset!");
static_assert(offsetof(AK26PathPart, _outlineUpdateStrategy) == 0x000250, "Member 'AK26PathPart::_outlineUpdateStrategy' has a wrong offset!");
static_assert(offsetof(AK26PathPart, _rootComponent) == 0x000258, "Member 'AK26PathPart::_rootComponent' has a wrong offset!");
static_assert(offsetof(AK26PathPart, _isVisibleForSurvivor) == 0x000260, "Member 'AK26PathPart::_isVisibleForSurvivor' has a wrong offset!");
static_assert(offsetof(AK26PathPart, _isVisibleForKiller) == 0x000261, "Member 'AK26PathPart::_isVisibleForKiller' has a wrong offset!");

// Class TheK26.K26PowerChargePresentationItemProgressComponent
// 0x0008 (0x00C0 - 0x00B8)
class UK26PowerChargePresentationItemProgressComponent final : public UPresentationItemProgressComponent
{
public:
	class UK26AmmoHandlerComponent*               _ammoHandler;                                      // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetDependencies(class UK26AmmoHandlerComponent* ammoHandler);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26PowerChargePresentationItemProgressComponent">();
	}
	static class UK26PowerChargePresentationItemProgressComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26PowerChargePresentationItemProgressComponent>();
	}
};
static_assert(alignof(UK26PowerChargePresentationItemProgressComponent) == 0x000008, "Wrong alignment on UK26PowerChargePresentationItemProgressComponent");
static_assert(sizeof(UK26PowerChargePresentationItemProgressComponent) == 0x0000C0, "Wrong size on UK26PowerChargePresentationItemProgressComponent");
static_assert(offsetof(UK26PowerChargePresentationItemProgressComponent, _ammoHandler) == 0x0000B8, "Member 'UK26PowerChargePresentationItemProgressComponent::_ammoHandler' has a wrong offset!");

// Class TheK26.K26PowerChargePresentationPowerFadeComponent
// 0x0008 (0x00C0 - 0x00B8)
class UK26PowerChargePresentationPowerFadeComponent final : public UPresentationPowerFadeComponent
{
public:
	class UK26AmmoHandlerComponent*               _ammoHandler;                                      // 0x00B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetDependencies(class UK26AmmoHandlerComponent* ammoHandler);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26PowerChargePresentationPowerFadeComponent">();
	}
	static class UK26PowerChargePresentationPowerFadeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26PowerChargePresentationPowerFadeComponent>();
	}
};
static_assert(alignof(UK26PowerChargePresentationPowerFadeComponent) == 0x000008, "Wrong alignment on UK26PowerChargePresentationPowerFadeComponent");
static_assert(sizeof(UK26PowerChargePresentationPowerFadeComponent) == 0x0000C0, "Wrong size on UK26PowerChargePresentationPowerFadeComponent");
static_assert(offsetof(UK26PowerChargePresentationPowerFadeComponent, _ammoHandler) == 0x0000B8, "Member 'UK26PowerChargePresentationPowerFadeComponent::_ammoHandler' has a wrong offset!");

// Class TheK26.S29P03
// 0x0010 (0x0490 - 0x0480)
class US29P03 final : public UBoonPerk
{
public:
	float                                         _recoverSpeedPercentage[0x3];                      // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"S29P03">();
	}
	static class US29P03* GetDefaultObj()
	{
		return GetDefaultObjImpl<US29P03>();
	}
};
static_assert(alignof(US29P03) == 0x000008, "Wrong alignment on US29P03");
static_assert(sizeof(US29P03) == 0x000490, "Wrong size on US29P03");
static_assert(offsetof(US29P03, _recoverSpeedPercentage) == 0x000480, "Member 'US29P03::_recoverSpeedPercentage' has a wrong offset!");

// Class TheK26.K26PowerOutlineUpdateStrategy
// 0x0018 (0x00D8 - 0x00C0)
class UK26PowerOutlineUpdateStrategy final : public UOutlineUpdateStrategy
{
public:
	struct FLinearColor                           _k26ProjectileOutlineColour;                       // 0x00C0(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOutlineEnabled;                                 // 0x00D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _isOnlyVisibleForKiller;                           // 0x00D1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOutlineVisibility(bool isActive);

	bool IsOutlineVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26PowerOutlineUpdateStrategy">();
	}
	static class UK26PowerOutlineUpdateStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26PowerOutlineUpdateStrategy>();
	}
};
static_assert(alignof(UK26PowerOutlineUpdateStrategy) == 0x000008, "Wrong alignment on UK26PowerOutlineUpdateStrategy");
static_assert(sizeof(UK26PowerOutlineUpdateStrategy) == 0x0000D8, "Wrong size on UK26PowerOutlineUpdateStrategy");
static_assert(offsetof(UK26PowerOutlineUpdateStrategy, _k26ProjectileOutlineColour) == 0x0000C0, "Member 'UK26PowerOutlineUpdateStrategy::_k26ProjectileOutlineColour' has a wrong offset!");
static_assert(offsetof(UK26PowerOutlineUpdateStrategy, _isOutlineEnabled) == 0x0000D0, "Member 'UK26PowerOutlineUpdateStrategy::_isOutlineEnabled' has a wrong offset!");
static_assert(offsetof(UK26PowerOutlineUpdateStrategy, _isOnlyVisibleForKiller) == 0x0000D1, "Member 'UK26PowerOutlineUpdateStrategy::_isOnlyVisibleForKiller' has a wrong offset!");

// Class TheK26.K26PowerStatusHandlerComponent
// 0x00D8 (0x0190 - 0x00B8)
class UK26PowerStatusHandlerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UInteractionDefinition>> _interactionsDuringWhichTheCrowIsIgnored;      // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_D8[0x18];                                      // 0x00D8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _invincibilityTime;                                // 0x00F0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _killerInstinctDelay;                              // 0x0118(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _killerInstinctGracePeriod;                        // 0x0140(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AActor>                     _statusIndicatorClass;                             // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _k26KillerInstinctStatusEffectName;                // 0x0170(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FK26SurvivorStatus>             _survivorStatusList;                               // 0x0180(0x0010)(Net, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Authority_OnIntroCompleted();
	void Authority_OnKillerInstinctTimePassed(const class ACamperPlayer* survivor);
	void Authority_OnSurvivorAdded(class ACamperPlayer* survivor);
	void Cosmetic_OnCrowDamagedSurvivor(class ASlasherPlayer* killer, class ACamperPlayer* survivor);
	void Cosmetic_OnCrowIdleInterrupt(class ACamperPlayer* survivor);
	void Multicast_OnCrowAttached(class ACamperPlayer* survivor);
	void Multicast_OnCrowDamagedSurvivor(class ASlasherPlayer* killer, class ACamperPlayer* survivor);
	void Multicast_OnCrowDetached(const class ACamperPlayer* survivor);
	void Multicast_OnIdleCrowInterrupt(class ACamperPlayer* survivor);
	void Multicast_OnStartRemovingCrow(const class ACamperPlayer* survivor);
	void Multicast_OnStopRemovingCrow(const class ACamperPlayer* survivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26PowerStatusHandlerComponent">();
	}
	static class UK26PowerStatusHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26PowerStatusHandlerComponent>();
	}
};
static_assert(alignof(UK26PowerStatusHandlerComponent) == 0x000008, "Wrong alignment on UK26PowerStatusHandlerComponent");
static_assert(sizeof(UK26PowerStatusHandlerComponent) == 0x000190, "Wrong size on UK26PowerStatusHandlerComponent");
static_assert(offsetof(UK26PowerStatusHandlerComponent, _interactionsDuringWhichTheCrowIsIgnored) == 0x0000C8, "Member 'UK26PowerStatusHandlerComponent::_interactionsDuringWhichTheCrowIsIgnored' has a wrong offset!");
static_assert(offsetof(UK26PowerStatusHandlerComponent, _invincibilityTime) == 0x0000F0, "Member 'UK26PowerStatusHandlerComponent::_invincibilityTime' has a wrong offset!");
static_assert(offsetof(UK26PowerStatusHandlerComponent, _killerInstinctDelay) == 0x000118, "Member 'UK26PowerStatusHandlerComponent::_killerInstinctDelay' has a wrong offset!");
static_assert(offsetof(UK26PowerStatusHandlerComponent, _killerInstinctGracePeriod) == 0x000140, "Member 'UK26PowerStatusHandlerComponent::_killerInstinctGracePeriod' has a wrong offset!");
static_assert(offsetof(UK26PowerStatusHandlerComponent, _statusIndicatorClass) == 0x000168, "Member 'UK26PowerStatusHandlerComponent::_statusIndicatorClass' has a wrong offset!");
static_assert(offsetof(UK26PowerStatusHandlerComponent, _k26KillerInstinctStatusEffectName) == 0x000170, "Member 'UK26PowerStatusHandlerComponent::_k26KillerInstinctStatusEffectName' has a wrong offset!");
static_assert(offsetof(UK26PowerStatusHandlerComponent, _survivorStatusList) == 0x000180, "Member 'UK26PowerStatusHandlerComponent::_survivorStatusList' has a wrong offset!");

// Class TheK26.K26SpawnCrowProjectileChargeableInteractionDefinition
// 0x0220 (0x0960 - 0x0740)
class UK26SpawnCrowProjectileChargeableInteractionDefinition final : public UChargeableInteractionDefinition
{
public:
	TMulticastInlineDelegate<void()>              OnChargingStarted;                                 // 0x0740(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnChargingStopped;                                 // 0x0750(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 remainingAmmo, int32 maxAmmo)> OnProjectileSummoned;         // 0x0760(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDBDTunableRowHandle                   _chargeCooldownTime;                               // 0x0770(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _summonCooldownTime;                               // 0x0798(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pathLength;                                       // 0x07C0(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _projectileHeight;                                 // 0x07E8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _projectileSummonDistance;                         // 0x0810(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _cooldownGracePeriodPercentage;                    // 0x0838(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _globalSpawnCooldownTime;                          // 0x0860(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDBDTunableRowHandle                   _pathDistanceCheckAttempts;                        // 0x0888(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class AK26AimingGuide>            _aimingGuideClass;                                 // 0x08B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AK26AimingGuide*                        _local_aimingGuide;                                // 0x08B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isConfirmButtonPressed;                           // 0x08C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C1[0x7];                                      // 0x08C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UK26AmmoHandlerComponent*               _ammoHandler;                                      // 0x08C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26PathHandlerComponent*               _pathHandler;                                      // 0x08D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UK26PowerStatusHandlerComponent*        _statusHandler;                                    // 0x08D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _firedFullyChargedEvent;                           // 0x08E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isWaitingForSummonAcknowledgement;                // 0x08E1(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8E2[0x6];                                      // 0x08E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            _globalCooldownMovementSpeedCurve;                 // 0x08E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8F0[0x70];                                     // 0x08F0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanSummonCrow();
	bool CanSummonCrowOnceFullyCharged();
	void Cosmetic_LocalOnSummonCooldownComplete(const int32 amountOfAmmoLeft, const bool isInteractionActive);
	void Cosmetic_OnFullyCharged(class ADBDPlayer* player);
	void Cosmetic_OnSummonButtonUsedWhenCrowSummonIsNotPossible();
	void Local_OnGlobalCooldownDone(class ADBDPlayer* player);
	void Multicast_OnK26CrowSummonAttemptAcknowledged();
	void Multicast_OnK26CrowSummoned(const class ASlasherPlayer* killer, const int32 remainingAmmo, const int32 maxAmmo);
	void OnConfirmButtonPressed(class ASlasherPlayer* killer);
	void OnSummonCooldownComplete();
	void Server_PlaceProjectileWithPath(class ASlasherPlayer* killer, const struct FVector& projectileSpawnPoint, const float killerLocalTime);
	void SetDependencies(class UK26AmmoHandlerComponent* ammoHandler, class UK26PathHandlerComponent* pathHandler, class UK26PowerStatusHandlerComponent* statusHandler);
	void SetSummonCooldown();

	bool IsSummonOnCooldown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"K26SpawnCrowProjectileChargeableInteractionDefinition">();
	}
	static class UK26SpawnCrowProjectileChargeableInteractionDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UK26SpawnCrowProjectileChargeableInteractionDefinition>();
	}
};
static_assert(alignof(UK26SpawnCrowProjectileChargeableInteractionDefinition) == 0x000010, "Wrong alignment on UK26SpawnCrowProjectileChargeableInteractionDefinition");
static_assert(sizeof(UK26SpawnCrowProjectileChargeableInteractionDefinition) == 0x000960, "Wrong size on UK26SpawnCrowProjectileChargeableInteractionDefinition");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, OnChargingStarted) == 0x000740, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::OnChargingStarted' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, OnChargingStopped) == 0x000750, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::OnChargingStopped' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, OnProjectileSummoned) == 0x000760, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::OnProjectileSummoned' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _chargeCooldownTime) == 0x000770, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_chargeCooldownTime' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _summonCooldownTime) == 0x000798, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_summonCooldownTime' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _pathLength) == 0x0007C0, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_pathLength' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _projectileHeight) == 0x0007E8, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_projectileHeight' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _projectileSummonDistance) == 0x000810, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_projectileSummonDistance' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _cooldownGracePeriodPercentage) == 0x000838, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_cooldownGracePeriodPercentage' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _globalSpawnCooldownTime) == 0x000860, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_globalSpawnCooldownTime' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _pathDistanceCheckAttempts) == 0x000888, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_pathDistanceCheckAttempts' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _aimingGuideClass) == 0x0008B0, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_aimingGuideClass' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _local_aimingGuide) == 0x0008B8, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_local_aimingGuide' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _isConfirmButtonPressed) == 0x0008C0, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_isConfirmButtonPressed' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _ammoHandler) == 0x0008C8, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_ammoHandler' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _pathHandler) == 0x0008D0, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_pathHandler' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _statusHandler) == 0x0008D8, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_statusHandler' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _firedFullyChargedEvent) == 0x0008E0, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_firedFullyChargedEvent' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _isWaitingForSummonAcknowledgement) == 0x0008E1, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_isWaitingForSummonAcknowledgement' has a wrong offset!");
static_assert(offsetof(UK26SpawnCrowProjectileChargeableInteractionDefinition, _globalCooldownMovementSpeedCurve) == 0x0008E8, "Member 'UK26SpawnCrowProjectileChargeableInteractionDefinition::_globalCooldownMovementSpeedCurve' has a wrong offset!");

// Class TheK26.Overcome
// 0x0030 (0x03F8 - 0x03C8)
class UOvercome final : public UPerk
{
public:
	float                                         _exhaustionDuration[0x3];                          // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _injuredModifiedMovementSpeedBurstDurationWindow;  // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UActivatableExhaustedEffect> _exhaustedEffectToImpose;                         // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _injuredModifiedMovementSpeedBurstStatusEffectToImpose; // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UActivatableExhaustedEffect*            _exhaustedEffect;                                  // 0x03E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStatusEffect*                          _injuredModifiedMovementSpeedBurstStatusEffect;    // 0x03F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Overcome">();
	}
	static class UOvercome* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOvercome>();
	}
};
static_assert(alignof(UOvercome) == 0x000008, "Wrong alignment on UOvercome");
static_assert(sizeof(UOvercome) == 0x0003F8, "Wrong size on UOvercome");
static_assert(offsetof(UOvercome, _exhaustionDuration) == 0x0003C8, "Member 'UOvercome::_exhaustionDuration' has a wrong offset!");
static_assert(offsetof(UOvercome, _injuredModifiedMovementSpeedBurstDurationWindow) == 0x0003D4, "Member 'UOvercome::_injuredModifiedMovementSpeedBurstDurationWindow' has a wrong offset!");
static_assert(offsetof(UOvercome, _exhaustedEffectToImpose) == 0x0003D8, "Member 'UOvercome::_exhaustedEffectToImpose' has a wrong offset!");
static_assert(offsetof(UOvercome, _injuredModifiedMovementSpeedBurstStatusEffectToImpose) == 0x0003E0, "Member 'UOvercome::_injuredModifiedMovementSpeedBurstStatusEffectToImpose' has a wrong offset!");
static_assert(offsetof(UOvercome, _exhaustedEffect) == 0x0003E8, "Member 'UOvercome::_exhaustedEffect' has a wrong offset!");
static_assert(offsetof(UOvercome, _injuredModifiedMovementSpeedBurstStatusEffect) == 0x0003F0, "Member 'UOvercome::_injuredModifiedMovementSpeedBurstStatusEffect' has a wrong offset!");

// Class TheK26.RekindledTotem
// 0x0048 (0x0288 - 0x0240)
class ARekindledTotem final : public AStaticMeshActor
{
public:
	struct FLinearColor                           _auraColor;                                        // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USourceBasedOutlineUpdateStrategy*      _outlineStrategy;                                  // 0x0250(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDBDOutlineComponent*                   _outlineComponent;                                 // 0x0258(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x28];                                     // 0x0260(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CleanseTotem(class ATotem* totem, const ETotemState oldTotemState);
	void Cosmetic_HideShadowTotem(bool instant);
	void Cosmetic_ShowShadowTotem(bool instant);
	void OnParentTotemEndPlay(class AActor* actor, EEndPlayReason endPlayReason);
	void RebuildTotem(class ATotem* totem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RekindledTotem">();
	}
	static class ARekindledTotem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARekindledTotem>();
	}
};
static_assert(alignof(ARekindledTotem) == 0x000008, "Wrong alignment on ARekindledTotem");
static_assert(sizeof(ARekindledTotem) == 0x000288, "Wrong size on ARekindledTotem");
static_assert(offsetof(ARekindledTotem, _auraColor) == 0x000240, "Member 'ARekindledTotem::_auraColor' has a wrong offset!");
static_assert(offsetof(ARekindledTotem, _outlineStrategy) == 0x000250, "Member 'ARekindledTotem::_outlineStrategy' has a wrong offset!");
static_assert(offsetof(ARekindledTotem, _outlineComponent) == 0x000258, "Member 'ARekindledTotem::_outlineComponent' has a wrong offset!");

// Class TheK26.RekindleTotemInteraction
// 0x0020 (0x0640 - 0x0620)
class URekindleTotemInteraction final : public UInteractionDefinition
{
public:
	float                                         _slasherFacingTolerance;                           // 0x0618(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61C[0x4];                                      // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ARekindledTotem>            _rekindledTotemClass;                              // 0x0620(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ARekindledTotem*                        _rekindledTotem;                                   // 0x0628(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_630[0x10];                                     // 0x0630(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RekindleTotemInteraction">();
	}
	static class URekindleTotemInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<URekindleTotemInteraction>();
	}
};
static_assert(alignof(URekindleTotemInteraction) == 0x000010, "Wrong alignment on URekindleTotemInteraction");
static_assert(sizeof(URekindleTotemInteraction) == 0x000640, "Wrong size on URekindleTotemInteraction");
static_assert(offsetof(URekindleTotemInteraction, _slasherFacingTolerance) == 0x000618, "Member 'URekindleTotemInteraction::_slasherFacingTolerance' has a wrong offset!");
static_assert(offsetof(URekindleTotemInteraction, _rekindledTotemClass) == 0x000620, "Member 'URekindleTotemInteraction::_rekindledTotemClass' has a wrong offset!");
static_assert(offsetof(URekindleTotemInteraction, _rekindledTotem) == 0x000628, "Member 'URekindleTotemInteraction::_rekindledTotem' has a wrong offset!");

}

