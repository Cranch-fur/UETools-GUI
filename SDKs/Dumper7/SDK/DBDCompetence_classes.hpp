#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DBDCompetence

#include "Basic.hpp"

#include "DeadByDaylight_structs.hpp"
#include "DeadByDaylight_classes.hpp"
#include "DataTableUtilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "SystemUtilities_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DBDSharedTypes_structs.hpp"
#include "Competence_classes.hpp"
#include "DBDCompetence_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayUtilities_structs.hpp"
#include "NetworkUtilities_structs.hpp"
#include "DBDGameplay_structs.hpp"
#include "StatSystem_structs.hpp"


namespace SDK
{

// Class DBDCompetence.HasPlayerReachedWiggleFillPercentCondition
// 0x0008 (0x00F0 - 0x00E8)
class UHasPlayerReachedWiggleFillPercentCondition final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x4];                                       // 0x00E8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          _isWigglePercentReached;                           // 0x00EC(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnOwnerWiggleChargePercentChanged(class UChargeableComponent* chargeableComponent, float percentCompletionChange, float totalPercentComplete);
	void OnRep_IsWigglePercentReached();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasPlayerReachedWiggleFillPercentCondition">();
	}
	static class UHasPlayerReachedWiggleFillPercentCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasPlayerReachedWiggleFillPercentCondition>();
	}
};
static_assert(alignof(UHasPlayerReachedWiggleFillPercentCondition) == 0x000008, "Wrong alignment on UHasPlayerReachedWiggleFillPercentCondition");
static_assert(sizeof(UHasPlayerReachedWiggleFillPercentCondition) == 0x0000F0, "Wrong size on UHasPlayerReachedWiggleFillPercentCondition");
static_assert(offsetof(UHasPlayerReachedWiggleFillPercentCondition, _isWigglePercentReached) == 0x0000EC, "Member 'UHasPlayerReachedWiggleFillPercentCondition::_isWigglePercentReached' has a wrong offset!");

// Class DBDCompetence.NoOneLeftBehind
// 0x0038 (0x0400 - 0x03C8)
class UNoOneLeftBehind final : public UPerk
{
public:
	float                                         _movementSpeedPercentage;                          // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _movementSpeedDuration;                            // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _modifyHealOtherSpeedEffect;                       // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _modifyUnhookOtherSpeedEffect;                     // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _movementSpeedEffect;                              // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _actionSpeedModifierValuePerLevel[0x3];            // 0x03E8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _alertKillerRevealEffect;                          // 0x03F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnExitGatePoweredApplicableChanged(class UGameplayModifierContainer* container, bool active);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NoOneLeftBehind">();
	}
	static class UNoOneLeftBehind* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNoOneLeftBehind>();
	}
};
static_assert(alignof(UNoOneLeftBehind) == 0x000008, "Wrong alignment on UNoOneLeftBehind");
static_assert(sizeof(UNoOneLeftBehind) == 0x000400, "Wrong size on UNoOneLeftBehind");
static_assert(offsetof(UNoOneLeftBehind, _movementSpeedPercentage) == 0x0003C8, "Member 'UNoOneLeftBehind::_movementSpeedPercentage' has a wrong offset!");
static_assert(offsetof(UNoOneLeftBehind, _movementSpeedDuration) == 0x0003CC, "Member 'UNoOneLeftBehind::_movementSpeedDuration' has a wrong offset!");
static_assert(offsetof(UNoOneLeftBehind, _modifyHealOtherSpeedEffect) == 0x0003D0, "Member 'UNoOneLeftBehind::_modifyHealOtherSpeedEffect' has a wrong offset!");
static_assert(offsetof(UNoOneLeftBehind, _modifyUnhookOtherSpeedEffect) == 0x0003D8, "Member 'UNoOneLeftBehind::_modifyUnhookOtherSpeedEffect' has a wrong offset!");
static_assert(offsetof(UNoOneLeftBehind, _movementSpeedEffect) == 0x0003E0, "Member 'UNoOneLeftBehind::_movementSpeedEffect' has a wrong offset!");
static_assert(offsetof(UNoOneLeftBehind, _actionSpeedModifierValuePerLevel) == 0x0003E8, "Member 'UNoOneLeftBehind::_actionSpeedModifierValuePerLevel' has a wrong offset!");
static_assert(offsetof(UNoOneLeftBehind, _alertKillerRevealEffect) == 0x0003F8, "Member 'UNoOneLeftBehind::_alertKillerRevealEffect' has a wrong offset!");

// Class DBDCompetence.EnduranceEffect
// 0x0010 (0x0360 - 0x0350)
class UEnduranceEffect : public UStatusEffect
{
public:
	TSubclassOf<class UStatusEffect>              _enduranceHighlightEffectClass;                    // 0x0350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x8];                                      // 0x0358(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnduranceEffect">();
	}
	static class UEnduranceEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnduranceEffect>();
	}
};
static_assert(alignof(UEnduranceEffect) == 0x000008, "Wrong alignment on UEnduranceEffect");
static_assert(sizeof(UEnduranceEffect) == 0x000360, "Wrong size on UEnduranceEffect");
static_assert(offsetof(UEnduranceEffect, _enduranceHighlightEffectClass) == 0x000350, "Member 'UEnduranceEffect::_enduranceHighlightEffectClass' has a wrong offset!");

// Class DBDCompetence.HeadOn
// 0x0078 (0x0440 - 0x03C8)
class UHeadOn final : public UPerk
{
public:
	bool                                          IsPerformingHeadOn;                                // 0x03C8(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExhaustOnlyOnSuccessfulStun;                       // 0x03C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StunKillersEnteringStunZone;                       // 0x03CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CB[0x1];                                      // 0x03CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _hideDuration[0x3];                                // 0x03CC(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALocker*                                _locker;                                           // 0x03D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x30];                                     // 0x03E0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         _stunnableActorsInZone;                            // 0x0410(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x20];                                     // 0x0420(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_ActivatePerk();
	void Multicast_TriggerStunOnActor(class UObject* stunnableInterfaceUObject, class ADBDPlayer* stunner);
	void OnHeadOnAnimationComplete();
	void OnPawnOverlapEnter(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex, bool bFromSweep, const struct FHitResult& sweepResult);
	void OnPawnOverlapExit(class UPrimitiveComponent* hitComponent, class AActor* otherActor, class UPrimitiveComponent* otherComp, int32 otherBodyIndex);

	bool CanApplyHeadOnInteraction() const;
	float GetHideDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeadOn">();
	}
	static class UHeadOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeadOn>();
	}
};
static_assert(alignof(UHeadOn) == 0x000008, "Wrong alignment on UHeadOn");
static_assert(sizeof(UHeadOn) == 0x000440, "Wrong size on UHeadOn");
static_assert(offsetof(UHeadOn, IsPerformingHeadOn) == 0x0003C8, "Member 'UHeadOn::IsPerformingHeadOn' has a wrong offset!");
static_assert(offsetof(UHeadOn, ExhaustOnlyOnSuccessfulStun) == 0x0003C9, "Member 'UHeadOn::ExhaustOnlyOnSuccessfulStun' has a wrong offset!");
static_assert(offsetof(UHeadOn, StunKillersEnteringStunZone) == 0x0003CA, "Member 'UHeadOn::StunKillersEnteringStunZone' has a wrong offset!");
static_assert(offsetof(UHeadOn, _hideDuration) == 0x0003CC, "Member 'UHeadOn::_hideDuration' has a wrong offset!");
static_assert(offsetof(UHeadOn, _locker) == 0x0003D8, "Member 'UHeadOn::_locker' has a wrong offset!");
static_assert(offsetof(UHeadOn, _stunnableActorsInZone) == 0x000410, "Member 'UHeadOn::_stunnableActorsInZone' has a wrong offset!");

// Class DBDCompetence.ActivatableEnduranceEffect
// 0x0000 (0x0360 - 0x0360)
class UActivatableEnduranceEffect final : public UEnduranceEffect
{
public:
	void Authority_Start(const float duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivatableEnduranceEffect">();
	}
	static class UActivatableEnduranceEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivatableEnduranceEffect>();
	}
};
static_assert(alignof(UActivatableEnduranceEffect) == 0x000008, "Wrong alignment on UActivatableEnduranceEffect");
static_assert(sizeof(UActivatableEnduranceEffect) == 0x000360, "Wrong size on UActivatableEnduranceEffect");

// Class DBDCompetence.AdjustableCooldownStatusEffect
// 0x0010 (0x0360 - 0x0350)
class UAdjustableCooldownStatusEffect : public UStatusEffect
{
public:
	struct FGameplayTag                           CooldownModifierType;                              // 0x0350(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdjustableCooldownStatusEffect">();
	}
	static class UAdjustableCooldownStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdjustableCooldownStatusEffect>();
	}
};
static_assert(alignof(UAdjustableCooldownStatusEffect) == 0x000008, "Wrong alignment on UAdjustableCooldownStatusEffect");
static_assert(sizeof(UAdjustableCooldownStatusEffect) == 0x000360, "Wrong size on UAdjustableCooldownStatusEffect");
static_assert(offsetof(UAdjustableCooldownStatusEffect, CooldownModifierType) == 0x000350, "Member 'UAdjustableCooldownStatusEffect::CooldownModifierType' has a wrong offset!");

// Class DBDCompetence.HemorrhageStatusEffect
// 0x0070 (0x03D0 - 0x0360)
class UHemorrhageStatusEffect final : public UAdjustableCooldownStatusEffect
{
public:
	float                                         _cooldownFXTime;                                   // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _removeEffectWhenFullyHealed;                      // 0x0364(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_365[0x6B];                                     // 0x0365(0x006B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorHealed(const struct FCamperHealResult& healResult);
	void OnStoppedHealing(const class ADBDPlayer* instigator, const class ADBDPlayer* target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HemorrhageStatusEffect">();
	}
	static class UHemorrhageStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHemorrhageStatusEffect>();
	}
};
static_assert(alignof(UHemorrhageStatusEffect) == 0x000008, "Wrong alignment on UHemorrhageStatusEffect");
static_assert(sizeof(UHemorrhageStatusEffect) == 0x0003D0, "Wrong size on UHemorrhageStatusEffect");
static_assert(offsetof(UHemorrhageStatusEffect, _cooldownFXTime) == 0x000360, "Member 'UHemorrhageStatusEffect::_cooldownFXTime' has a wrong offset!");
static_assert(offsetof(UHemorrhageStatusEffect, _removeEffectWhenFullyHealed) == 0x000364, "Member 'UHemorrhageStatusEffect::_removeEffectWhenFullyHealed' has a wrong offset!");

// Class DBDCompetence.BaseLingeringStatusEffect
// 0x0008 (0x0358 - 0x0350)
class UBaseLingeringStatusEffect : public UStatusEffect
{
public:
	float                                         _lingerDuration;                                   // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_ActivateEffect();
	void Authority_DeactivateEffect();
	void SetLingerDuration(float lingerDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseLingeringStatusEffect">();
	}
	static class UBaseLingeringStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseLingeringStatusEffect>();
	}
};
static_assert(alignof(UBaseLingeringStatusEffect) == 0x000008, "Wrong alignment on UBaseLingeringStatusEffect");
static_assert(sizeof(UBaseLingeringStatusEffect) == 0x000358, "Wrong size on UBaseLingeringStatusEffect");
static_assert(offsetof(UBaseLingeringStatusEffect, _lingerDuration) == 0x000350, "Member 'UBaseLingeringStatusEffect::_lingerDuration' has a wrong offset!");

// Class DBDCompetence.LingeringStateTagStatusEffect
// 0x0038 (0x0390 - 0x0358)
class ULingeringStateTagStatusEffect : public UBaseLingeringStatusEffect
{
public:
	struct FGameplayTag                           _ownerStateTag;                                    // 0x0358(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x2C];                                     // 0x0364(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LingeringStateTagStatusEffect">();
	}
	static class ULingeringStateTagStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULingeringStateTagStatusEffect>();
	}
};
static_assert(alignof(ULingeringStateTagStatusEffect) == 0x000008, "Wrong alignment on ULingeringStateTagStatusEffect");
static_assert(sizeof(ULingeringStateTagStatusEffect) == 0x000390, "Wrong size on ULingeringStateTagStatusEffect");
static_assert(offsetof(ULingeringStateTagStatusEffect, _ownerStateTag) == 0x000358, "Member 'ULingeringStateTagStatusEffect::_ownerStateTag' has a wrong offset!");

// Class DBDCompetence.HexPerk
// 0x0028 (0x0448 - 0x0420)
class UHexPerk : public UTotemBoundPerk
{
public:
	TArray<class ADBDPlayer*>                     _playersWhoKnowCurse;                              // 0x0420(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class ADBDPlayer*>                     _oldPlayersWhoKnowCurse;                           // 0x0430(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_440[0x8];                                      // 0x0440(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_RevealCurseToAllSurvivors(bool revealed);
	void Authority_SetCurseRevealedToPlayer(class ADBDPlayer* player, const bool revealed);
	void OnRep_PlayersWhoKnowCurse();
	void UpdateCursedStatusViewOnLocalPlayer();

	bool IsCurseRevealedToPlayer(const class ADBDPlayer* player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexPerk">();
	}
	static class UHexPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexPerk>();
	}
};
static_assert(alignof(UHexPerk) == 0x000008, "Wrong alignment on UHexPerk");
static_assert(sizeof(UHexPerk) == 0x000448, "Wrong size on UHexPerk");
static_assert(offsetof(UHexPerk, _playersWhoKnowCurse) == 0x000420, "Member 'UHexPerk::_playersWhoKnowCurse' has a wrong offset!");
static_assert(offsetof(UHexPerk, _oldPlayersWhoKnowCurse) == 0x000430, "Member 'UHexPerk::_oldPlayersWhoKnowCurse' has a wrong offset!");

// Class DBDCompetence.ExhaustedEffect
// 0x0008 (0x0368 - 0x0360)
class UExhaustedEffect : public UAdjustableCooldownStatusEffect
{
public:
	float                                         CooldownModifier;                                  // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExhaustedEffect">();
	}
	static class UExhaustedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExhaustedEffect>();
	}
};
static_assert(alignof(UExhaustedEffect) == 0x000008, "Wrong alignment on UExhaustedEffect");
static_assert(sizeof(UExhaustedEffect) == 0x000368, "Wrong size on UExhaustedEffect");
static_assert(offsetof(UExhaustedEffect, CooldownModifier) == 0x000360, "Member 'UExhaustedEffect::CooldownModifier' has a wrong offset!");

// Class DBDCompetence.Whispers
// 0x0090 (0x0458 - 0x03C8)
class UWhispers final : public UPerk
{
public:
	float                                         _timeBetweenAudio;                                 // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CC[0x34];                                     // 0x03CC(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _survivorsInRange;                                 // 0x0400(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_404[0x54];                                     // 0x0404(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Multicast_FireAudioEvent(const int32 survivorsInRange);
	void OnRep_SurvivorsInRange();
	void OnWhispersAudio();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Whispers">();
	}
	static class UWhispers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWhispers>();
	}
};
static_assert(alignof(UWhispers) == 0x000008, "Wrong alignment on UWhispers");
static_assert(sizeof(UWhispers) == 0x000458, "Wrong size on UWhispers");
static_assert(offsetof(UWhispers, _timeBetweenAudio) == 0x0003C8, "Member 'UWhispers::_timeBetweenAudio' has a wrong offset!");
static_assert(offsetof(UWhispers, _survivorsInRange) == 0x000400, "Member 'UWhispers::_survivorsInRange' has a wrong offset!");

// Class DBDCompetence.HexDevourHope
// 0x0080 (0x04C8 - 0x0448)
class UHexDevourHope final : public UHexPerk
{
public:
	TSubclassOf<class UStatusEffect>              _devourHopeSpeedStatusEffect;                      // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _exposedStatusEffect;                              // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _rangeFromUnhookedSurvivorNeeded;                  // 0x0458(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _tokenThresholdToImposeSpeedBoost;                 // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _tokenThresholdToImposeExposeEffect;               // 0x0464(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _tokenThresholdToImposeAbilityToKill;              // 0x0468(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _attackGameEvents;                                 // 0x0470(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         _moveSpeedIncrement[0x3];                          // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49C[0x14];                                     // 0x049C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   _vulnerabilityStatusViewID;                        // 0x04B0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4BC[0xC];                                      // 0x04BC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetMoveSpeedIncrement(int32 perkLevel) const;
	float GetRangeFromUnhookedSurvivorNeeded(int32 perkLevel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexDevourHope">();
	}
	static class UHexDevourHope* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexDevourHope>();
	}
};
static_assert(alignof(UHexDevourHope) == 0x000008, "Wrong alignment on UHexDevourHope");
static_assert(sizeof(UHexDevourHope) == 0x0004C8, "Wrong size on UHexDevourHope");
static_assert(offsetof(UHexDevourHope, _devourHopeSpeedStatusEffect) == 0x000448, "Member 'UHexDevourHope::_devourHopeSpeedStatusEffect' has a wrong offset!");
static_assert(offsetof(UHexDevourHope, _exposedStatusEffect) == 0x000450, "Member 'UHexDevourHope::_exposedStatusEffect' has a wrong offset!");
static_assert(offsetof(UHexDevourHope, _rangeFromUnhookedSurvivorNeeded) == 0x000458, "Member 'UHexDevourHope::_rangeFromUnhookedSurvivorNeeded' has a wrong offset!");
static_assert(offsetof(UHexDevourHope, _tokenThresholdToImposeSpeedBoost) == 0x000460, "Member 'UHexDevourHope::_tokenThresholdToImposeSpeedBoost' has a wrong offset!");
static_assert(offsetof(UHexDevourHope, _tokenThresholdToImposeExposeEffect) == 0x000464, "Member 'UHexDevourHope::_tokenThresholdToImposeExposeEffect' has a wrong offset!");
static_assert(offsetof(UHexDevourHope, _tokenThresholdToImposeAbilityToKill) == 0x000468, "Member 'UHexDevourHope::_tokenThresholdToImposeAbilityToKill' has a wrong offset!");
static_assert(offsetof(UHexDevourHope, _attackGameEvents) == 0x000470, "Member 'UHexDevourHope::_attackGameEvents' has a wrong offset!");
static_assert(offsetof(UHexDevourHope, _moveSpeedIncrement) == 0x000490, "Member 'UHexDevourHope::_moveSpeedIncrement' has a wrong offset!");
static_assert(offsetof(UHexDevourHope, _vulnerabilityStatusViewID) == 0x0004B0, "Member 'UHexDevourHope::_vulnerabilityStatusViewID' has a wrong offset!");

// Class DBDCompetence.KillerSubjectProvider
// 0x0008 (0x0050 - 0x0048)
class UKillerSubjectProvider final : public UModifierSubjectProvider
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisterWhenKillerSet(class ASlasherPlayer* killer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerSubjectProvider">();
	}
	static class UKillerSubjectProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerSubjectProvider>();
	}
};
static_assert(alignof(UKillerSubjectProvider) == 0x000008, "Wrong alignment on UKillerSubjectProvider");
static_assert(sizeof(UKillerSubjectProvider) == 0x000050, "Wrong size on UKillerSubjectProvider");

// Class DBDCompetence.ActivatableExhaustedEffect
// 0x0000 (0x0368 - 0x0368)
class UActivatableExhaustedEffect final : public UExhaustedEffect
{
public:
	void Authority_OnHookCamper(const struct FGameplayTag& gameEvent, const struct FGameEventData& gameEventData);
	void Authority_Start(const float duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivatableExhaustedEffect">();
	}
	static class UActivatableExhaustedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivatableExhaustedEffect>();
	}
};
static_assert(alignof(UActivatableExhaustedEffect) == 0x000008, "Wrong alignment on UActivatableExhaustedEffect");
static_assert(sizeof(UActivatableExhaustedEffect) == 0x000368, "Wrong size on UActivatableExhaustedEffect");

// Class DBDCompetence.HexHauntedGround
// 0x0020 (0x0468 - 0x0448)
class UHexHauntedGround final : public UHexPerk
{
public:
	float                                         _exposedStatusEffectDuration[0x3];                 // 0x0448(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_454[0x14];                                     // 0x0454(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexHauntedGround">();
	}
	static class UHexHauntedGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexHauntedGround>();
	}
};
static_assert(alignof(UHexHauntedGround) == 0x000008, "Wrong alignment on UHexHauntedGround");
static_assert(sizeof(UHexHauntedGround) == 0x000468, "Wrong size on UHexHauntedGround");
static_assert(offsetof(UHexHauntedGround, _exposedStatusEffectDuration) == 0x000448, "Member 'UHexHauntedGround::_exposedStatusEffectDuration' has a wrong offset!");

// Class DBDCompetence.ActivateOnEventTimedStatusEffect
// 0x0030 (0x0380 - 0x0350)
class UActivateOnEventTimedStatusEffect : public UStatusEffect
{
public:
	TSubclassOf<class UActivateOnEventBaseActivationStrategy> _activationStrategyClass;              // 0x0350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  _eventsToActivateOn;                               // 0x0358(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UActivateOnEventBaseActivationStrategy* _activationStrategy;                               // 0x0378(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateOnEventTimedStatusEffect">();
	}
	static class UActivateOnEventTimedStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateOnEventTimedStatusEffect>();
	}
};
static_assert(alignof(UActivateOnEventTimedStatusEffect) == 0x000008, "Wrong alignment on UActivateOnEventTimedStatusEffect");
static_assert(sizeof(UActivateOnEventTimedStatusEffect) == 0x000380, "Wrong size on UActivateOnEventTimedStatusEffect");
static_assert(offsetof(UActivateOnEventTimedStatusEffect, _activationStrategyClass) == 0x000350, "Member 'UActivateOnEventTimedStatusEffect::_activationStrategyClass' has a wrong offset!");
static_assert(offsetof(UActivateOnEventTimedStatusEffect, _eventsToActivateOn) == 0x000358, "Member 'UActivateOnEventTimedStatusEffect::_eventsToActivateOn' has a wrong offset!");
static_assert(offsetof(UActivateOnEventTimedStatusEffect, _activationStrategy) == 0x000378, "Member 'UActivateOnEventTimedStatusEffect::_activationStrategy' has a wrong offset!");

// Class DBDCompetence.ActivateOnEventBaseActivationStrategy
// 0x0000 (0x0030 - 0x0030)
class UActivateOnEventBaseActivationStrategy : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateOnEventBaseActivationStrategy">();
	}
	static class UActivateOnEventBaseActivationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateOnEventBaseActivationStrategy>();
	}
};
static_assert(alignof(UActivateOnEventBaseActivationStrategy) == 0x000008, "Wrong alignment on UActivateOnEventBaseActivationStrategy");
static_assert(sizeof(UActivateOnEventBaseActivationStrategy) == 0x000030, "Wrong size on UActivateOnEventBaseActivationStrategy");

// Class DBDCompetence.ActivateOnEventAlwaysActivationStrategy
// 0x0000 (0x0030 - 0x0030)
class UActivateOnEventAlwaysActivationStrategy final : public UActivateOnEventBaseActivationStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateOnEventAlwaysActivationStrategy">();
	}
	static class UActivateOnEventAlwaysActivationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateOnEventAlwaysActivationStrategy>();
	}
};
static_assert(alignof(UActivateOnEventAlwaysActivationStrategy) == 0x000008, "Wrong alignment on UActivateOnEventAlwaysActivationStrategy");
static_assert(sizeof(UActivateOnEventAlwaysActivationStrategy) == 0x000030, "Wrong size on UActivateOnEventAlwaysActivationStrategy");

// Class DBDCompetence.OwningSlasherHasBeenStill
// 0x0008 (0x00D8 - 0x00D0)
class UOwningSlasherHasBeenStill final : public UGameplayModifierCondition
{
public:
	float                                         _secondsOfStillnessRequired;                       // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _getStillnessValueFromOwningEffect;                // 0x00D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OwningSlasherHasBeenStill">();
	}
	static class UOwningSlasherHasBeenStill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOwningSlasherHasBeenStill>();
	}
};
static_assert(alignof(UOwningSlasherHasBeenStill) == 0x000008, "Wrong alignment on UOwningSlasherHasBeenStill");
static_assert(sizeof(UOwningSlasherHasBeenStill) == 0x0000D8, "Wrong size on UOwningSlasherHasBeenStill");
static_assert(offsetof(UOwningSlasherHasBeenStill, _secondsOfStillnessRequired) == 0x0000D0, "Member 'UOwningSlasherHasBeenStill::_secondsOfStillnessRequired' has a wrong offset!");
static_assert(offsetof(UOwningSlasherHasBeenStill, _getStillnessValueFromOwningEffect) == 0x0000D4, "Member 'UOwningSlasherHasBeenStill::_getStillnessValueFromOwningEffect' has a wrong offset!");

// Class DBDCompetence.ActivateOnEventTargetActivationStrategy
// 0x0000 (0x0030 - 0x0030)
class UActivateOnEventTargetActivationStrategy final : public UActivateOnEventBaseActivationStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateOnEventTargetActivationStrategy">();
	}
	static class UActivateOnEventTargetActivationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateOnEventTargetActivationStrategy>();
	}
};
static_assert(alignof(UActivateOnEventTargetActivationStrategy) == 0x000008, "Wrong alignment on UActivateOnEventTargetActivationStrategy");
static_assert(sizeof(UActivateOnEventTargetActivationStrategy) == 0x000030, "Wrong size on UActivateOnEventTargetActivationStrategy");

// Class DBDCompetence.ActivateOnEventInstigatorActivationStrategy
// 0x0000 (0x0030 - 0x0030)
class UActivateOnEventInstigatorActivationStrategy final : public UActivateOnEventBaseActivationStrategy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActivateOnEventInstigatorActivationStrategy">();
	}
	static class UActivateOnEventInstigatorActivationStrategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActivateOnEventInstigatorActivationStrategy>();
	}
};
static_assert(alignof(UActivateOnEventInstigatorActivationStrategy) == 0x000008, "Wrong alignment on UActivateOnEventInstigatorActivationStrategy");
static_assert(sizeof(UActivateOnEventInstigatorActivationStrategy) == 0x000030, "Wrong size on UActivateOnEventInstigatorActivationStrategy");

// Class DBDCompetence.Adrenaline
// 0x0040 (0x0408 - 0x03C8)
class UAdrenaline final : public UPerk
{
public:
	class FName                                   _exhaustedEffectID;                                // 0x03C8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _speedEffect;                                      // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _exhaustionEffect;                                 // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _movementSpeedDuration;                            // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _movementSpeedPercentage;                          // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x18];                                     // 0x03F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_AttemptApplyPerk();
	void Multicast_DispatchAdrenalineEvents(const bool isHealthy, const float healAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Adrenaline">();
	}
	static class UAdrenaline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdrenaline>();
	}
};
static_assert(alignof(UAdrenaline) == 0x000008, "Wrong alignment on UAdrenaline");
static_assert(sizeof(UAdrenaline) == 0x000408, "Wrong size on UAdrenaline");
static_assert(offsetof(UAdrenaline, _exhaustedEffectID) == 0x0003C8, "Member 'UAdrenaline::_exhaustedEffectID' has a wrong offset!");
static_assert(offsetof(UAdrenaline, _speedEffect) == 0x0003D8, "Member 'UAdrenaline::_speedEffect' has a wrong offset!");
static_assert(offsetof(UAdrenaline, _exhaustionEffect) == 0x0003E0, "Member 'UAdrenaline::_exhaustionEffect' has a wrong offset!");
static_assert(offsetof(UAdrenaline, _movementSpeedDuration) == 0x0003E8, "Member 'UAdrenaline::_movementSpeedDuration' has a wrong offset!");
static_assert(offsetof(UAdrenaline, _movementSpeedPercentage) == 0x0003EC, "Member 'UAdrenaline::_movementSpeedPercentage' has a wrong offset!");

// Class DBDCompetence.AlertKillerRevealEffect
// 0x0000 (0x0350 - 0x0350)
class UAlertKillerRevealEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlertKillerRevealEffect">();
	}
	static class UAlertKillerRevealEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlertKillerRevealEffect>();
	}
};
static_assert(alignof(UAlertKillerRevealEffect) == 0x000008, "Wrong alignment on UAlertKillerRevealEffect");
static_assert(sizeof(UAlertKillerRevealEffect) == 0x000350, "Wrong size on UAlertKillerRevealEffect");

// Class DBDCompetence.AllHexTotemsAreActive
// 0x0018 (0x0100 - 0x00E8)
class UAllHexTotemsAreActive final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AllHexTotemsAreActive">();
	}
	static class UAllHexTotemsAreActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAllHexTotemsAreActive>();
	}
};
static_assert(alignof(UAllHexTotemsAreActive) == 0x000008, "Wrong alignment on UAllHexTotemsAreActive");
static_assert(sizeof(UAllHexTotemsAreActive) == 0x000100, "Wrong size on UAllHexTotemsAreActive");

// Class DBDCompetence.AnyActorPairQueryRangeIsTrue
// 0x0010 (0x0100 - 0x00F0)
class UAnyActorPairQueryRangeIsTrue : public URangeBasedCondition
{
public:
	uint8                                         Pad_F0[0x10];                                      // 0x00F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInRangeChanged(const bool inRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnyActorPairQueryRangeIsTrue">();
	}
	static class UAnyActorPairQueryRangeIsTrue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnyActorPairQueryRangeIsTrue>();
	}
};
static_assert(alignof(UAnyActorPairQueryRangeIsTrue) == 0x000008, "Wrong alignment on UAnyActorPairQueryRangeIsTrue");
static_assert(sizeof(UAnyActorPairQueryRangeIsTrue) == 0x000100, "Wrong size on UAnyActorPairQueryRangeIsTrue");

// Class DBDCompetence.PlayerIsInExitArea
// 0x0008 (0x00D8 - 0x00D0)
class UPlayerIsInExitArea final : public UGameplayModifierCondition
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayerEnterExitArea();
	void PlayerExitExitArea();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerIsInExitArea">();
	}
	static class UPlayerIsInExitArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerIsInExitArea>();
	}
};
static_assert(alignof(UPlayerIsInExitArea) == 0x000008, "Wrong alignment on UPlayerIsInExitArea");
static_assert(sizeof(UPlayerIsInExitArea) == 0x0000D8, "Wrong size on UPlayerIsInExitArea");

// Class DBDCompetence.AnyMeansNecessary
// 0x0018 (0x03E0 - 0x03C8)
class UAnyMeansNecessary final : public UPerk
{
public:
	float                                         _actionSpeedBonus[0x3];                            // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _anyMeansNecessaryActionSpeedEffect;               // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnPalletPulledUp(const struct FGameplayTag& gameplayTag, const struct FGameEventData& gameEventData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnyMeansNecessary">();
	}
	static class UAnyMeansNecessary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnyMeansNecessary>();
	}
};
static_assert(alignof(UAnyMeansNecessary) == 0x000008, "Wrong alignment on UAnyMeansNecessary");
static_assert(sizeof(UAnyMeansNecessary) == 0x0003E0, "Wrong size on UAnyMeansNecessary");
static_assert(offsetof(UAnyMeansNecessary, _actionSpeedBonus) == 0x0003C8, "Member 'UAnyMeansNecessary::_actionSpeedBonus' has a wrong offset!");
static_assert(offsetof(UAnyMeansNecessary, _anyMeansNecessaryActionSpeedEffect) == 0x0003D8, "Member 'UAnyMeansNecessary::_anyMeansNecessaryActionSpeedEffect' has a wrong offset!");

// Class DBDCompetence.AnySurvivorHasObjectState
// 0x0070 (0x0158 - 0x00E8)
class UAnySurvivorHasObjectState final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x50];                                      // 0x00E8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           _stateTag;                                         // 0x0138(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_144[0x14];                                     // 0x0144(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSurvivorAdded(class ACamperPlayer* survivor);
	void OnSurvivorRemoved(class ACamperPlayer* survivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnySurvivorHasObjectState">();
	}
	static class UAnySurvivorHasObjectState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnySurvivorHasObjectState>();
	}
};
static_assert(alignof(UAnySurvivorHasObjectState) == 0x000008, "Wrong alignment on UAnySurvivorHasObjectState");
static_assert(sizeof(UAnySurvivorHasObjectState) == 0x000158, "Wrong size on UAnySurvivorHasObjectState");
static_assert(offsetof(UAnySurvivorHasObjectState, _stateTag) == 0x000138, "Member 'UAnySurvivorHasObjectState::_stateTag' has a wrong offset!");

// Class DBDCompetence.OriginatingEffectIsApplicable
// 0x0008 (0x00F0 - 0x00E8)
class UOriginatingEffectIsApplicable final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OriginatingEffectIsApplicable">();
	}
	static class UOriginatingEffectIsApplicable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOriginatingEffectIsApplicable>();
	}
};
static_assert(alignof(UOriginatingEffectIsApplicable) == 0x000008, "Wrong alignment on UOriginatingEffectIsApplicable");
static_assert(sizeof(UOriginatingEffectIsApplicable) == 0x0000F0, "Wrong size on UOriginatingEffectIsApplicable");

// Class DBDCompetence.Babysitter
// 0x0038 (0x0400 - 0x03C8)
class UBabysitter final : public UPerk
{
public:
	float                                         _scratchMarkHidingTime[0x3];                       // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteEffect[0x3];                                 // 0x03D4(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _showAuraTime[0x3];                                // 0x03E0(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cooldownTime[0x3];                                // 0x03EC(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _perkEffect;                                       // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Babysitter">();
	}
	static class UBabysitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBabysitter>();
	}
};
static_assert(alignof(UBabysitter) == 0x000008, "Wrong alignment on UBabysitter");
static_assert(sizeof(UBabysitter) == 0x000400, "Wrong size on UBabysitter");
static_assert(offsetof(UBabysitter, _scratchMarkHidingTime) == 0x0003C8, "Member 'UBabysitter::_scratchMarkHidingTime' has a wrong offset!");
static_assert(offsetof(UBabysitter, _hasteEffect) == 0x0003D4, "Member 'UBabysitter::_hasteEffect' has a wrong offset!");
static_assert(offsetof(UBabysitter, _showAuraTime) == 0x0003E0, "Member 'UBabysitter::_showAuraTime' has a wrong offset!");
static_assert(offsetof(UBabysitter, _cooldownTime) == 0x0003EC, "Member 'UBabysitter::_cooldownTime' has a wrong offset!");
static_assert(offsetof(UBabysitter, _perkEffect) == 0x0003F8, "Member 'UBabysitter::_perkEffect' has a wrong offset!");

// Class DBDCompetence.BabysitterEffect
// 0x0000 (0x0350 - 0x0350)
class UBabysitterEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BabysitterEffect">();
	}
	static class UBabysitterEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBabysitterEffect>();
	}
};
static_assert(alignof(UBabysitterEffect) == 0x000008, "Wrong alignment on UBabysitterEffect");
static_assert(sizeof(UBabysitterEffect) == 0x000350, "Wrong size on UBabysitterEffect");

// Class DBDCompetence.RemoveOnOriginatingSurvivorGoneStatusEffect
// 0x0008 (0x0358 - 0x0350)
class URemoveOnOriginatingSurvivorGoneStatusEffect : public UStatusEffect
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorRemoved(class ACamperPlayer* survivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemoveOnOriginatingSurvivorGoneStatusEffect">();
	}
	static class URemoveOnOriginatingSurvivorGoneStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemoveOnOriginatingSurvivorGoneStatusEffect>();
	}
};
static_assert(alignof(URemoveOnOriginatingSurvivorGoneStatusEffect) == 0x000008, "Wrong alignment on URemoveOnOriginatingSurvivorGoneStatusEffect");
static_assert(sizeof(URemoveOnOriginatingSurvivorGoneStatusEffect) == 0x000358, "Wrong size on URemoveOnOriginatingSurvivorGoneStatusEffect");

// Class DBDCompetence.ProveThyselfEffect
// 0x00C0 (0x0418 - 0x0358)
class UProveThyselfEffect final : public URemoveOnOriginatingSurvivorGoneStatusEffect
{
public:
	uint8                                         Pad_358[0x20];                                     // 0x0358(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDBDTunableRowHandle                   _proveThyselfRange;                                // 0x0378(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _speedPercentageAddedPerSurvivorRepairingInRange;  // 0x03A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A4[0x74];                                     // 0x03A4(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInRangeOfOriginatorChanged(const bool inRange, class ACamperPlayer* survivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProveThyselfEffect">();
	}
	static class UProveThyselfEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProveThyselfEffect>();
	}
};
static_assert(alignof(UProveThyselfEffect) == 0x000008, "Wrong alignment on UProveThyselfEffect");
static_assert(sizeof(UProveThyselfEffect) == 0x000418, "Wrong size on UProveThyselfEffect");
static_assert(offsetof(UProveThyselfEffect, _proveThyselfRange) == 0x000378, "Member 'UProveThyselfEffect::_proveThyselfRange' has a wrong offset!");
static_assert(offsetof(UProveThyselfEffect, _speedPercentageAddedPerSurvivorRepairingInRange) == 0x0003A0, "Member 'UProveThyselfEffect::_speedPercentageAddedPerSurvivorRepairingInRange' has a wrong offset!");

// Class DBDCompetence.BaseIsPerkUsableCondition
// 0x0008 (0x00F0 - 0x00E8)
class UBaseIsPerkUsableCondition : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseIsPerkUsableCondition">();
	}
	static class UBaseIsPerkUsableCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseIsPerkUsableCondition>();
	}
};
static_assert(alignof(UBaseIsPerkUsableCondition) == 0x000008, "Wrong alignment on UBaseIsPerkUsableCondition");
static_assert(sizeof(UBaseIsPerkUsableCondition) == 0x0000F0, "Wrong size on UBaseIsPerkUsableCondition");

// Class DBDCompetence.BaseIsPlayerPerformingInteraction
// 0x0030 (0x0118 - 0x00E8)
class UBaseIsPlayerPerformingInteraction : public UEventDrivenModifierCondition
{
public:
	struct FGameplayTagContainer                  _interactionSemantics;                             // 0x00E8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetInteractionSemantics(const struct FGameplayTagContainer& interactionSemantics);
	void UpdateIsTrue(class UInteractionDefinition* interactionDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseIsPlayerPerformingInteraction">();
	}
	static class UBaseIsPlayerPerformingInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseIsPlayerPerformingInteraction>();
	}
};
static_assert(alignof(UBaseIsPlayerPerformingInteraction) == 0x000008, "Wrong alignment on UBaseIsPlayerPerformingInteraction");
static_assert(sizeof(UBaseIsPlayerPerformingInteraction) == 0x000118, "Wrong size on UBaseIsPlayerPerformingInteraction");
static_assert(offsetof(UBaseIsPlayerPerformingInteraction, _interactionSemantics) == 0x0000E8, "Member 'UBaseIsPlayerPerformingInteraction::_interactionSemantics' has a wrong offset!");

// Class DBDCompetence.SmallGame
// 0x0028 (0x03F0 - 0x03C8)
class USmallGame final : public UPerk
{
public:
	float                                         _detectionConeAngle[0x3];                          // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _detectionConeAngleReductionRate[0x3];             // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _totemDetected;                                    // 0x03E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0xF];                                      // 0x03E1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_SetTotemDetected(bool value);
	void Multicast_TotemFound();
	void SearchForTotems();
	void VFXTotemFound();

	float GetDetectionConeAngle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SmallGame">();
	}
	static class USmallGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<USmallGame>();
	}
};
static_assert(alignof(USmallGame) == 0x000008, "Wrong alignment on USmallGame");
static_assert(sizeof(USmallGame) == 0x0003F0, "Wrong size on USmallGame");
static_assert(offsetof(USmallGame, _detectionConeAngle) == 0x0003C8, "Member 'USmallGame::_detectionConeAngle' has a wrong offset!");
static_assert(offsetof(USmallGame, _detectionConeAngleReductionRate) == 0x0003D4, "Member 'USmallGame::_detectionConeAngleReductionRate' has a wrong offset!");
static_assert(offsetof(USmallGame, _totemDetected) == 0x0003E0, "Member 'USmallGame::_totemDetected' has a wrong offset!");

// Class DBDCompetence.BetterTogether
// 0x0068 (0x0430 - 0x03C8)
class UBetterTogether final : public UPerk
{
public:
	bool                                          ShouldRevealKiller;                                // 0x03C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldRevealSurvivors;                             // 0x03C9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CA[0x2];                                      // 0x03CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RevealDistance;                                    // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ADBDPlayer*>                     _affectedCampers;                                  // 0x03D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 _genToReveal;                                      // 0x03E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _durationByLevel[0x3];                             // 0x03F0(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3FC[0x24];                                     // 0x03FC(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _timedSurvivorRevealEffect;                        // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _timedKillerRevealEffect;                          // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetRevealDistance();
	void OnStartedGeneratorRepair(const struct FGameplayTag& gameplayTag, const struct FGameEventData& gameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BetterTogether">();
	}
	static class UBetterTogether* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBetterTogether>();
	}
};
static_assert(alignof(UBetterTogether) == 0x000008, "Wrong alignment on UBetterTogether");
static_assert(sizeof(UBetterTogether) == 0x000430, "Wrong size on UBetterTogether");
static_assert(offsetof(UBetterTogether, ShouldRevealKiller) == 0x0003C8, "Member 'UBetterTogether::ShouldRevealKiller' has a wrong offset!");
static_assert(offsetof(UBetterTogether, ShouldRevealSurvivors) == 0x0003C9, "Member 'UBetterTogether::ShouldRevealSurvivors' has a wrong offset!");
static_assert(offsetof(UBetterTogether, RevealDistance) == 0x0003CC, "Member 'UBetterTogether::RevealDistance' has a wrong offset!");
static_assert(offsetof(UBetterTogether, _affectedCampers) == 0x0003D0, "Member 'UBetterTogether::_affectedCampers' has a wrong offset!");
static_assert(offsetof(UBetterTogether, _genToReveal) == 0x0003E8, "Member 'UBetterTogether::_genToReveal' has a wrong offset!");
static_assert(offsetof(UBetterTogether, _durationByLevel) == 0x0003F0, "Member 'UBetterTogether::_durationByLevel' has a wrong offset!");
static_assert(offsetof(UBetterTogether, _timedSurvivorRevealEffect) == 0x000420, "Member 'UBetterTogether::_timedSurvivorRevealEffect' has a wrong offset!");
static_assert(offsetof(UBetterTogether, _timedKillerRevealEffect) == 0x000428, "Member 'UBetterTogether::_timedKillerRevealEffect' has a wrong offset!");

// Class DBDCompetence.SecondsToRateModifierBaseAddon
// 0x0110 (0x03C8 - 0x02B8)
class USecondsToRateModifierBaseAddon final : public UItemAddon
{
public:
	struct FTunableStat                           _chargeRate;                                       // 0x02B8(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTunableStat                           _maxCharge;                                        // 0x0338(0x0080)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _secondsToAdd;                                     // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           _rateModifierTagToCompute;                         // 0x03BC(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SecondsToRateModifierBaseAddon">();
	}
	static class USecondsToRateModifierBaseAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<USecondsToRateModifierBaseAddon>();
	}
};
static_assert(alignof(USecondsToRateModifierBaseAddon) == 0x000008, "Wrong alignment on USecondsToRateModifierBaseAddon");
static_assert(sizeof(USecondsToRateModifierBaseAddon) == 0x0003C8, "Wrong size on USecondsToRateModifierBaseAddon");
static_assert(offsetof(USecondsToRateModifierBaseAddon, _chargeRate) == 0x0002B8, "Member 'USecondsToRateModifierBaseAddon::_chargeRate' has a wrong offset!");
static_assert(offsetof(USecondsToRateModifierBaseAddon, _maxCharge) == 0x000338, "Member 'USecondsToRateModifierBaseAddon::_maxCharge' has a wrong offset!");
static_assert(offsetof(USecondsToRateModifierBaseAddon, _secondsToAdd) == 0x0003B8, "Member 'USecondsToRateModifierBaseAddon::_secondsToAdd' has a wrong offset!");
static_assert(offsetof(USecondsToRateModifierBaseAddon, _rateModifierTagToCompute) == 0x0003BC, "Member 'USecondsToRateModifierBaseAddon::_rateModifierTagToCompute' has a wrong offset!");

// Class DBDCompetence.BlessedStatusEffect
// 0x0010 (0x0360 - 0x0350)
class UBlessedStatusEffect : public UStatusEffect
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBlessedVignetteController> _vignetteControllerBlueprint;                      // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnSurvivorRemovedFromGame(class ACamperPlayer* survivor);
	void OnEnterBoonRange();
	void OnExitBoonRange();

	float GetBoonTotemBlessingRange() const;
	class ATotem* GetBoundTotem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlessedStatusEffect">();
	}
	static class UBlessedStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlessedStatusEffect>();
	}
};
static_assert(alignof(UBlessedStatusEffect) == 0x000008, "Wrong alignment on UBlessedStatusEffect");
static_assert(sizeof(UBlessedStatusEffect) == 0x000360, "Wrong size on UBlessedStatusEffect");
static_assert(offsetof(UBlessedStatusEffect, _vignetteControllerBlueprint) == 0x000358, "Member 'UBlessedStatusEffect::_vignetteControllerBlueprint' has a wrong offset!");

// Class DBDCompetence.BloodEcho
// 0x0018 (0x03E0 - 0x03C8)
class UBloodEcho final : public UPerk
{
public:
	struct FGameplayTag                           _statusEffectDurationTag;                          // 0x03C8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cooldownDuration[0x3];                            // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	float GetCooldownDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BloodEcho">();
	}
	static class UBloodEcho* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBloodEcho>();
	}
};
static_assert(alignof(UBloodEcho) == 0x000008, "Wrong alignment on UBloodEcho");
static_assert(sizeof(UBloodEcho) == 0x0003E0, "Wrong size on UBloodEcho");
static_assert(offsetof(UBloodEcho, _statusEffectDurationTag) == 0x0003C8, "Member 'UBloodEcho::_statusEffectDurationTag' has a wrong offset!");
static_assert(offsetof(UBloodEcho, _cooldownDuration) == 0x0003D4, "Member 'UBloodEcho::_cooldownDuration' has a wrong offset!");

// Class DBDCompetence.ProveThyself
// 0x00A8 (0x0470 - 0x03C8)
class UProveThyself final : public UPerk
{
public:
	struct FDBDTunableRowHandle                   _proveThyselfRange;                                // 0x03C8(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x60];                                     // 0x03F0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FForAllSurvivorsStatusEffectImposer    _proveThyselfEffectImposer;                        // 0x0450(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSurvivorInOwnerRangeChanged(const bool inRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProveThyself">();
	}
	static class UProveThyself* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProveThyself>();
	}
};
static_assert(alignof(UProveThyself) == 0x000008, "Wrong alignment on UProveThyself");
static_assert(sizeof(UProveThyself) == 0x000470, "Wrong size on UProveThyself");
static_assert(offsetof(UProveThyself, _proveThyselfRange) == 0x0003C8, "Member 'UProveThyself::_proveThyselfRange' has a wrong offset!");
static_assert(offsetof(UProveThyself, _proveThyselfEffectImposer) == 0x000450, "Member 'UProveThyself::_proveThyselfEffectImposer' has a wrong offset!");

// Class DBDCompetence.BoonDestroyer
// 0x0018 (0x03E0 - 0x03C8)
class UBoonDestroyer final : public UPerk
{
public:
	float                                         _survivorAuraRevealDuration[0x3];                  // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _survivorRevealEffect;                             // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoonDestroyer">();
	}
	static class UBoonDestroyer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoonDestroyer>();
	}
};
static_assert(alignof(UBoonDestroyer) == 0x000008, "Wrong alignment on UBoonDestroyer");
static_assert(sizeof(UBoonDestroyer) == 0x0003E0, "Wrong size on UBoonDestroyer");
static_assert(offsetof(UBoonDestroyer, _survivorAuraRevealDuration) == 0x0003C8, "Member 'UBoonDestroyer::_survivorAuraRevealDuration' has a wrong offset!");
static_assert(offsetof(UBoonDestroyer, _survivorRevealEffect) == 0x0003D8, "Member 'UBoonDestroyer::_survivorRevealEffect' has a wrong offset!");

// Class DBDCompetence.SpawnEffectsOnAllSurvivorsBaseAddon
// 0x0010 (0x02C8 - 0x02B8)
class USpawnEffectsOnAllSurvivorsBaseAddon : public UItemAddon
{
public:
	bool                                          _canCreateMultipleInstances;                       // 0x02B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0xF];                                      // 0x02B9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnEffectsOnAllSurvivorsBaseAddon">();
	}
	static class USpawnEffectsOnAllSurvivorsBaseAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnEffectsOnAllSurvivorsBaseAddon>();
	}
};
static_assert(alignof(USpawnEffectsOnAllSurvivorsBaseAddon) == 0x000008, "Wrong alignment on USpawnEffectsOnAllSurvivorsBaseAddon");
static_assert(sizeof(USpawnEffectsOnAllSurvivorsBaseAddon) == 0x0002C8, "Wrong size on USpawnEffectsOnAllSurvivorsBaseAddon");
static_assert(offsetof(USpawnEffectsOnAllSurvivorsBaseAddon, _canCreateMultipleInstances) == 0x0002B8, "Member 'USpawnEffectsOnAllSurvivorsBaseAddon::_canCreateMultipleInstances' has a wrong offset!");

// Class DBDCompetence.SimpleSpawnEffectsOnAllSurvivorsAddon
// 0x0010 (0x02D8 - 0x02C8)
class USimpleSpawnEffectsOnAllSurvivorsAddon : public USpawnEffectsOnAllSurvivorsBaseAddon
{
public:
	TArray<struct FSimpleSpawnEffectsOnAllSurvivorsAddonParams> _statusEffectsSpawnParams;           // 0x02C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleSpawnEffectsOnAllSurvivorsAddon">();
	}
	static class USimpleSpawnEffectsOnAllSurvivorsAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleSpawnEffectsOnAllSurvivorsAddon>();
	}
};
static_assert(alignof(USimpleSpawnEffectsOnAllSurvivorsAddon) == 0x000008, "Wrong alignment on USimpleSpawnEffectsOnAllSurvivorsAddon");
static_assert(sizeof(USimpleSpawnEffectsOnAllSurvivorsAddon) == 0x0002D8, "Wrong size on USimpleSpawnEffectsOnAllSurvivorsAddon");
static_assert(offsetof(USimpleSpawnEffectsOnAllSurvivorsAddon, _statusEffectsSpawnParams) == 0x0002C8, "Member 'USimpleSpawnEffectsOnAllSurvivorsAddon::_statusEffectsSpawnParams' has a wrong offset!");

// Class DBDCompetence.BoonPerk
// 0x0060 (0x0480 - 0x0420)
class UBoonPerk : public UTotemBoundPerk
{
public:
	TSubclassOf<class UBlessedStatusEffect>       _blessedStatusEffectClass;                         // 0x0420(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlessedStatusEffect*                   _blessedStatusEffect;                              // 0x0428(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x50];                                     // 0x0430(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorRemoved(class ACamperPlayer* survivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoonPerk">();
	}
	static class UBoonPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoonPerk>();
	}
};
static_assert(alignof(UBoonPerk) == 0x000008, "Wrong alignment on UBoonPerk");
static_assert(sizeof(UBoonPerk) == 0x000480, "Wrong size on UBoonPerk");
static_assert(offsetof(UBoonPerk, _blessedStatusEffectClass) == 0x000420, "Member 'UBoonPerk::_blessedStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UBoonPerk, _blessedStatusEffect) == 0x000428, "Member 'UBoonPerk::_blessedStatusEffect' has a wrong offset!");

// Class DBDCompetence.BoonTotemIsActive
// 0x0018 (0x0100 - 0x00E8)
class UBoonTotemIsActive final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BoonTotemIsActive">();
	}
	static class UBoonTotemIsActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBoonTotemIsActive>();
	}
};
static_assert(alignof(UBoonTotemIsActive) == 0x000008, "Wrong alignment on UBoonTotemIsActive");
static_assert(sizeof(UBoonTotemIsActive) == 0x000100, "Wrong size on UBoonTotemIsActive");

// Class DBDCompetence.StatsSystemUtilities
// 0x0000 (0x0030 - 0x0030)
class UStatsSystemUtilities final : public UBlueprintFunctionLibrary
{
public:
	static float GetStatValueBP(const struct FTunableStat& theStat);
	static void InitStatBP(struct FTunableStat& theStat, TScriptInterface<class IModifierProvider> modifierProvider);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatsSystemUtilities">();
	}
	static class UStatsSystemUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatsSystemUtilities>();
	}
};
static_assert(alignof(UStatsSystemUtilities) == 0x000008, "Wrong alignment on UStatsSystemUtilities");
static_assert(sizeof(UStatsSystemUtilities) == 0x000030, "Wrong size on UStatsSystemUtilities");

// Class DBDCompetence.Breakout
// 0x0088 (0x0450 - 0x03C8)
class UBreakout final : public UPerk
{
public:
	class ASlasherPlayer*                         _slasher;                                          // 0x03C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADBDPlayer*                             _playerOwner;                                      // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _hasteStatusEffect;                                // 0x03D8(0x0008)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _wiggleStatusEffect;                               // 0x03E0(0x0008)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteEffect[0x3];                                 // 0x03E8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _wiggleEffect;                                     // 0x03F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _survivorDistanceMax;                              // 0x03F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isPerkActive;                                     // 0x03FC(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3FD[0x53];                                     // 0x03FD(0x0053)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_ImposeWiggleStatusEffect(class ACamperPlayer* survivor);
	void Authority_OnRangeChanged(const bool inRange);
	void OnRep_IsPerkActive();
	void OnSlasherSet(class ASlasherPlayer* slasher);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Breakout">();
	}
	static class UBreakout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBreakout>();
	}
};
static_assert(alignof(UBreakout) == 0x000008, "Wrong alignment on UBreakout");
static_assert(sizeof(UBreakout) == 0x000450, "Wrong size on UBreakout");
static_assert(offsetof(UBreakout, _slasher) == 0x0003C8, "Member 'UBreakout::_slasher' has a wrong offset!");
static_assert(offsetof(UBreakout, _playerOwner) == 0x0003D0, "Member 'UBreakout::_playerOwner' has a wrong offset!");
static_assert(offsetof(UBreakout, _hasteStatusEffect) == 0x0003D8, "Member 'UBreakout::_hasteStatusEffect' has a wrong offset!");
static_assert(offsetof(UBreakout, _wiggleStatusEffect) == 0x0003E0, "Member 'UBreakout::_wiggleStatusEffect' has a wrong offset!");
static_assert(offsetof(UBreakout, _hasteEffect) == 0x0003E8, "Member 'UBreakout::_hasteEffect' has a wrong offset!");
static_assert(offsetof(UBreakout, _wiggleEffect) == 0x0003F4, "Member 'UBreakout::_wiggleEffect' has a wrong offset!");
static_assert(offsetof(UBreakout, _survivorDistanceMax) == 0x0003F8, "Member 'UBreakout::_survivorDistanceMax' has a wrong offset!");
static_assert(offsetof(UBreakout, _isPerkActive) == 0x0003FC, "Member 'UBreakout::_isPerkActive' has a wrong offset!");

// Class DBDCompetence.BuckleUp
// 0x0020 (0x03E8 - 0x03C8)
class UBuckleUp final : public UPerk
{
public:
	float                                         _perkDuration[0x3];                                // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteValue;                                       // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _revealKillerStatusEffect;                         // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _hasteStatusEffect;                                // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuckleUp">();
	}
	static class UBuckleUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuckleUp>();
	}
};
static_assert(alignof(UBuckleUp) == 0x000008, "Wrong alignment on UBuckleUp");
static_assert(sizeof(UBuckleUp) == 0x0003E8, "Wrong size on UBuckleUp");
static_assert(offsetof(UBuckleUp, _perkDuration) == 0x0003C8, "Member 'UBuckleUp::_perkDuration' has a wrong offset!");
static_assert(offsetof(UBuckleUp, _hasteValue) == 0x0003D4, "Member 'UBuckleUp::_hasteValue' has a wrong offset!");
static_assert(offsetof(UBuckleUp, _revealKillerStatusEffect) == 0x0003D8, "Member 'UBuckleUp::_revealKillerStatusEffect' has a wrong offset!");
static_assert(offsetof(UBuckleUp, _hasteStatusEffect) == 0x0003E0, "Member 'UBuckleUp::_hasteStatusEffect' has a wrong offset!");

// Class DBDCompetence.Solidarity
// 0x0038 (0x0400 - 0x03C8)
class USolidarity final : public UPerk
{
public:
	bool                                          _allowMedkit;                                      // 0x03C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C9[0xF];                                      // 0x03C9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UChargeableComponent*                   _healerHPSlot;                                     // 0x03D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableComponent*                   _targetHPSlot;                                     // 0x03E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChargeableInteractionDefinition*       _healOtherInteraction;                             // 0x03E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x10];                                     // 0x03F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnHealthChargeApplied(float individualChargeAmount, float totalChargeAmount, class AActor* chargeInstigator, bool wasCoop, float deltaTime);
	void Authority_OnSkillCheckResponse(bool success, bool bonus, class ADBDPlayer* player, bool triggerLoudNoise, bool hadInput, ESkillCheckCustomType type, float chargeChange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Solidarity">();
	}
	static class USolidarity* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolidarity>();
	}
};
static_assert(alignof(USolidarity) == 0x000008, "Wrong alignment on USolidarity");
static_assert(sizeof(USolidarity) == 0x000400, "Wrong size on USolidarity");
static_assert(offsetof(USolidarity, _allowMedkit) == 0x0003C8, "Member 'USolidarity::_allowMedkit' has a wrong offset!");
static_assert(offsetof(USolidarity, _healerHPSlot) == 0x0003D8, "Member 'USolidarity::_healerHPSlot' has a wrong offset!");
static_assert(offsetof(USolidarity, _targetHPSlot) == 0x0003E0, "Member 'USolidarity::_targetHPSlot' has a wrong offset!");
static_assert(offsetof(USolidarity, _healOtherInteraction) == 0x0003E8, "Member 'USolidarity::_healOtherInteraction' has a wrong offset!");

// Class DBDCompetence.CalmSpirit
// 0x0018 (0x03E0 - 0x03C8)
class UCalmSpirit final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _calmSpiritEffectClass;                            // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _actionSpeed[0x3];                                 // 0x03D0(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CalmSpirit">();
	}
	static class UCalmSpirit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCalmSpirit>();
	}
};
static_assert(alignof(UCalmSpirit) == 0x000008, "Wrong alignment on UCalmSpirit");
static_assert(sizeof(UCalmSpirit) == 0x0003E0, "Wrong size on UCalmSpirit");
static_assert(offsetof(UCalmSpirit, _calmSpiritEffectClass) == 0x0003C8, "Member 'UCalmSpirit::_calmSpiritEffectClass' has a wrong offset!");
static_assert(offsetof(UCalmSpirit, _actionSpeed) == 0x0003D0, "Member 'UCalmSpirit::_actionSpeed' has a wrong offset!");

// Class DBDCompetence.Camaraderie
// 0x0058 (0x0420 - 0x03C8)
class UCamaraderie final : public UPerk
{
public:
	float                                         _percentUseItem[0x3];                              // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _pauseTimer[0x3];                                  // 0x03D4(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _camaraderieNotificationEffectClass;               // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x38];                                     // 0x03E8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Camaraderie">();
	}
	static class UCamaraderie* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCamaraderie>();
	}
};
static_assert(alignof(UCamaraderie) == 0x000008, "Wrong alignment on UCamaraderie");
static_assert(sizeof(UCamaraderie) == 0x000420, "Wrong size on UCamaraderie");
static_assert(offsetof(UCamaraderie, _percentUseItem) == 0x0003C8, "Member 'UCamaraderie::_percentUseItem' has a wrong offset!");
static_assert(offsetof(UCamaraderie, _pauseTimer) == 0x0003D4, "Member 'UCamaraderie::_pauseTimer' has a wrong offset!");
static_assert(offsetof(UCamaraderie, _camaraderieNotificationEffectClass) == 0x0003E0, "Member 'UCamaraderie::_camaraderieNotificationEffectClass' has a wrong offset!");

// Class DBDCompetence.CollectableOwnerSubjectProvider
// 0x0018 (0x0060 - 0x0048)
class UCollectableOwnerSubjectProvider final : public UModifierSubjectProvider
{
public:
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectableOwnerSubjectProvider">();
	}
	static class UCollectableOwnerSubjectProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectableOwnerSubjectProvider>();
	}
};
static_assert(alignof(UCollectableOwnerSubjectProvider) == 0x000008, "Wrong alignment on UCollectableOwnerSubjectProvider");
static_assert(sizeof(UCollectableOwnerSubjectProvider) == 0x000060, "Wrong size on UCollectableOwnerSubjectProvider");

// Class DBDCompetence.CorruptIntervention
// 0x0070 (0x0438 - 0x03C8)
class UCorruptIntervention final : public UPerk
{
public:
	uint8                                         _blockedGeneratorCount[0x3];                       // 0x03C8(0x0001)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CB[0x1];                                      // 0x03CB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _generatorBlockDuration[0x3];                      // 0x03CC(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _generatorAuraColorForKiller;                      // 0x03D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AGenerator*>                     _blockedGenerators;                                // 0x03E8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x40];                                     // 0x03F8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnLevelReadyToPlay();
	void Authority_TryActivatePerk();
	void LevelReadyToBlockedGenerators();
	void OnRep_BlockedGenerators();

	float GetGeneratorBlockDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CorruptIntervention">();
	}
	static class UCorruptIntervention* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCorruptIntervention>();
	}
};
static_assert(alignof(UCorruptIntervention) == 0x000008, "Wrong alignment on UCorruptIntervention");
static_assert(sizeof(UCorruptIntervention) == 0x000438, "Wrong size on UCorruptIntervention");
static_assert(offsetof(UCorruptIntervention, _blockedGeneratorCount) == 0x0003C8, "Member 'UCorruptIntervention::_blockedGeneratorCount' has a wrong offset!");
static_assert(offsetof(UCorruptIntervention, _generatorBlockDuration) == 0x0003CC, "Member 'UCorruptIntervention::_generatorBlockDuration' has a wrong offset!");
static_assert(offsetof(UCorruptIntervention, _generatorAuraColorForKiller) == 0x0003D8, "Member 'UCorruptIntervention::_generatorAuraColorForKiller' has a wrong offset!");
static_assert(offsetof(UCorruptIntervention, _blockedGenerators) == 0x0003E8, "Member 'UCorruptIntervention::_blockedGenerators' has a wrong offset!");

// Class DBDCompetence.Coulrophobia
// 0x0018 (0x03E0 - 0x03C8)
class UCoulrophobia final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _coulrophobiaEffect;                               // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _healPenalty[0x3];                                 // 0x03D0(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Coulrophobia">();
	}
	static class UCoulrophobia* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoulrophobia>();
	}
};
static_assert(alignof(UCoulrophobia) == 0x000008, "Wrong alignment on UCoulrophobia");
static_assert(sizeof(UCoulrophobia) == 0x0003E0, "Wrong size on UCoulrophobia");
static_assert(offsetof(UCoulrophobia, _coulrophobiaEffect) == 0x0003C8, "Member 'UCoulrophobia::_coulrophobiaEffect' has a wrong offset!");
static_assert(offsetof(UCoulrophobia, _healPenalty) == 0x0003D0, "Member 'UCoulrophobia::_healPenalty' has a wrong offset!");

// Class DBDCompetence.CruelConfinement
// 0x00A0 (0x0468 - 0x03C8)
class UCruelConfinement final : public UPerk
{
public:
	float                                         _effectiveRadius[0x3];                             // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _blockDuration[0x3];                               // 0x03D4(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _windowAuraColor;                                  // 0x03E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AGenerator*, struct FWindowBlockableList> _blockableLists;                            // 0x03F0(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_440[0x28];                                     // 0x0440(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetBlockDurationAtLevel();
	float GetEffectiveRadiusAtLevel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CruelConfinement">();
	}
	static class UCruelConfinement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCruelConfinement>();
	}
};
static_assert(alignof(UCruelConfinement) == 0x000008, "Wrong alignment on UCruelConfinement");
static_assert(sizeof(UCruelConfinement) == 0x000468, "Wrong size on UCruelConfinement");
static_assert(offsetof(UCruelConfinement, _effectiveRadius) == 0x0003C8, "Member 'UCruelConfinement::_effectiveRadius' has a wrong offset!");
static_assert(offsetof(UCruelConfinement, _blockDuration) == 0x0003D4, "Member 'UCruelConfinement::_blockDuration' has a wrong offset!");
static_assert(offsetof(UCruelConfinement, _windowAuraColor) == 0x0003E0, "Member 'UCruelConfinement::_windowAuraColor' has a wrong offset!");
static_assert(offsetof(UCruelConfinement, _blockableLists) == 0x0003F0, "Member 'UCruelConfinement::_blockableLists' has a wrong offset!");

// Class DBDCompetence.DarkDevotion
// 0x0018 (0x03E0 - 0x03C8)
class UDarkDevotion final : public UPerk
{
public:
	class UTerrorRadiusEmitterComponent*          _obsessionTerrorRadiusEmitter;                     // 0x03C8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _obsessionTerrorRadius;                            // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _simulatedFixedDistance;                           // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkDevotion">();
	}
	static class UDarkDevotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarkDevotion>();
	}
};
static_assert(alignof(UDarkDevotion) == 0x000008, "Wrong alignment on UDarkDevotion");
static_assert(sizeof(UDarkDevotion) == 0x0003E0, "Wrong size on UDarkDevotion");
static_assert(offsetof(UDarkDevotion, _obsessionTerrorRadiusEmitter) == 0x0003C8, "Member 'UDarkDevotion::_obsessionTerrorRadiusEmitter' has a wrong offset!");
static_assert(offsetof(UDarkDevotion, _obsessionTerrorRadius) == 0x0003D0, "Member 'UDarkDevotion::_obsessionTerrorRadius' has a wrong offset!");
static_assert(offsetof(UDarkDevotion, _simulatedFixedDistance) == 0x0003D4, "Member 'UDarkDevotion::_simulatedFixedDistance' has a wrong offset!");

// Class DBDCompetence.DarkSense
// 0x0048 (0x0410 - 0x03C8)
class UDarkSense final : public UPerk
{
public:
	float                                         _killerRevealDuration[0x3];                        // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _darkSenseRevealRange;                             // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _timedRevealEffect;                                // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x30];                                     // 0x03E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnInRangeChanged(const bool inRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkSense">();
	}
	static class UDarkSense* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarkSense>();
	}
};
static_assert(alignof(UDarkSense) == 0x000008, "Wrong alignment on UDarkSense");
static_assert(sizeof(UDarkSense) == 0x000410, "Wrong size on UDarkSense");
static_assert(offsetof(UDarkSense, _killerRevealDuration) == 0x0003C8, "Member 'UDarkSense::_killerRevealDuration' has a wrong offset!");
static_assert(offsetof(UDarkSense, _darkSenseRevealRange) == 0x0003D4, "Member 'UDarkSense::_darkSenseRevealRange' has a wrong offset!");
static_assert(offsetof(UDarkSense, _timedRevealEffect) == 0x0003D8, "Member 'UDarkSense::_timedRevealEffect' has a wrong offset!");

// Class DBDCompetence.DBDConditionFactory
// 0x0000 (0x0030 - 0x0030)
class UDBDConditionFactory final : public UBlueprintFunctionLibrary
{
public:
	static class UDoesPerkHaveToken* DoesPerkHaveToken(TScriptInterface<class IConditionReceiver> conditionReceiver, class UPerk* perk);
	static class UIsPlayerPerformingInteraction* IsPlayerPerformingInteraction(TScriptInterface<class IConditionReceiver> conditionReceiver, const struct FGameplayTagContainer& interactionSemantics);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DBDConditionFactory">();
	}
	static class UDBDConditionFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDBDConditionFactory>();
	}
};
static_assert(alignof(UDBDConditionFactory) == 0x000008, "Wrong alignment on UDBDConditionFactory");
static_assert(sizeof(UDBDConditionFactory) == 0x000030, "Wrong size on UDBDConditionFactory");

// Class DBDCompetence.DeadMansSwitchEffect
// 0x0000 (0x0350 - 0x0350)
class UDeadMansSwitchEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeadMansSwitchEffect">();
	}
	static class UDeadMansSwitchEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeadMansSwitchEffect>();
	}
};
static_assert(alignof(UDeadMansSwitchEffect) == 0x000008, "Wrong alignment on UDeadMansSwitchEffect");
static_assert(sizeof(UDeadMansSwitchEffect) == 0x000350, "Wrong size on UDeadMansSwitchEffect");

// Class DBDCompetence.DeceptionEffect
// 0x0008 (0x0358 - 0x0350)
class UDeceptionEffect final : public UStatusEffect
{
public:
	bool                                          _hideBloodTrailsWhenCamperFakeEnterLocker;         // 0x0350(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeceptionEffect">();
	}
	static class UDeceptionEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeceptionEffect>();
	}
};
static_assert(alignof(UDeceptionEffect) == 0x000008, "Wrong alignment on UDeceptionEffect");
static_assert(sizeof(UDeceptionEffect) == 0x000358, "Wrong size on UDeceptionEffect");
static_assert(offsetof(UDeceptionEffect, _hideBloodTrailsWhenCamperFakeEnterLocker) == 0x000350, "Member 'UDeceptionEffect::_hideBloodTrailsWhenCamperFakeEnterLocker' has a wrong offset!");

// Class DBDCompetence.TestCollectable
// 0x0000 (0x04B0 - 0x04B0)
class ATestCollectable final : public ACollectable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestCollectable">();
	}
	static class ATestCollectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestCollectable>();
	}
};
static_assert(alignof(ATestCollectable) == 0x000008, "Wrong alignment on ATestCollectable");
static_assert(sizeof(ATestCollectable) == 0x0004B0, "Wrong size on ATestCollectable");

// Class DBDCompetence.DecisiveStrike
// 0x00A0 (0x0468 - 0x03C8)
class UDecisiveStrike final : public UPerk
{
public:
	float                                         _timeAfterUnhook[0x3];                             // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _skillCheckDelay;                                  // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _skillCheckBuffer;                                 // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _killerHearsSkillCheckCue;                         // 0x03DC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DD[0x7B];                                     // 0x03DD(0x007B)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _increaseObsessionChanceEffect;                    // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasBeenAttempted;                                 // 0x0460(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_461[0x7];                                      // 0x0461(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerPickedUp(class ADBDPlayer* picker);
	void OnPickUpEnded(class ADBDPlayer* picker);
	void OnRep_HasBeenAttempted();
	void OnSkillCheck(bool hadInput, bool success, bool bonus, ESkillCheckCustomType type, class ADBDPlayer* player);
	void OnUnhookedTimerEnded();

	float GetDurationAfterUnhook() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecisiveStrike">();
	}
	static class UDecisiveStrike* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecisiveStrike>();
	}
};
static_assert(alignof(UDecisiveStrike) == 0x000008, "Wrong alignment on UDecisiveStrike");
static_assert(sizeof(UDecisiveStrike) == 0x000468, "Wrong size on UDecisiveStrike");
static_assert(offsetof(UDecisiveStrike, _timeAfterUnhook) == 0x0003C8, "Member 'UDecisiveStrike::_timeAfterUnhook' has a wrong offset!");
static_assert(offsetof(UDecisiveStrike, _skillCheckDelay) == 0x0003D4, "Member 'UDecisiveStrike::_skillCheckDelay' has a wrong offset!");
static_assert(offsetof(UDecisiveStrike, _skillCheckBuffer) == 0x0003D8, "Member 'UDecisiveStrike::_skillCheckBuffer' has a wrong offset!");
static_assert(offsetof(UDecisiveStrike, _killerHearsSkillCheckCue) == 0x0003DC, "Member 'UDecisiveStrike::_killerHearsSkillCheckCue' has a wrong offset!");
static_assert(offsetof(UDecisiveStrike, _increaseObsessionChanceEffect) == 0x000458, "Member 'UDecisiveStrike::_increaseObsessionChanceEffect' has a wrong offset!");
static_assert(offsetof(UDecisiveStrike, _hasBeenAttempted) == 0x000460, "Member 'UDecisiveStrike::_hasBeenAttempted' has a wrong offset!");

// Class DBDCompetence.DejaVu
// 0x0058 (0x0420 - 0x03C8)
class UDejaVu final : public UPerk
{
public:
	int32                                         _numGeneratorsToReveal;                            // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _perkEffectDurations[0x3];                         // 0x03CC(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _actionSpeeds[0x3];                                // 0x03D8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _generatorAuraColor;                               // 0x03E4(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGenerator*>                     _revealedGenerators;                               // 0x03F8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x18];                                     // 0x0408(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnGeneratorRepaired(int32 activatedGeneratorCount);
	void Authority_TryActivatePerk();
	void LevelReadyToRevealOutlineGenerators();
	void OnRep_RevealedGenerators();

	float GetActionSpeedsAtLevel() const;
	float GetPerkDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DejaVu">();
	}
	static class UDejaVu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDejaVu>();
	}
};
static_assert(alignof(UDejaVu) == 0x000008, "Wrong alignment on UDejaVu");
static_assert(sizeof(UDejaVu) == 0x000420, "Wrong size on UDejaVu");
static_assert(offsetof(UDejaVu, _numGeneratorsToReveal) == 0x0003C8, "Member 'UDejaVu::_numGeneratorsToReveal' has a wrong offset!");
static_assert(offsetof(UDejaVu, _perkEffectDurations) == 0x0003CC, "Member 'UDejaVu::_perkEffectDurations' has a wrong offset!");
static_assert(offsetof(UDejaVu, _actionSpeeds) == 0x0003D8, "Member 'UDejaVu::_actionSpeeds' has a wrong offset!");
static_assert(offsetof(UDejaVu, _generatorAuraColor) == 0x0003E4, "Member 'UDejaVu::_generatorAuraColor' has a wrong offset!");
static_assert(offsetof(UDejaVu, _revealedGenerators) == 0x0003F8, "Member 'UDejaVu::_revealedGenerators' has a wrong offset!");

// Class DBDCompetence.TimedStatusEffect
// 0x0000 (0x0350 - 0x0350)
class UTimedStatusEffect : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimedStatusEffect">();
	}
	static class UTimedStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimedStatusEffect>();
	}
};
static_assert(alignof(UTimedStatusEffect) == 0x000008, "Wrong alignment on UTimedStatusEffect");
static_assert(sizeof(UTimedStatusEffect) == 0x000350, "Wrong size on UTimedStatusEffect");

// Class DBDCompetence.UndetectableTimedEffect
// 0x0000 (0x0350 - 0x0350)
class UUndetectableTimedEffect final : public UTimedStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UndetectableTimedEffect">();
	}
	static class UUndetectableTimedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUndetectableTimedEffect>();
	}
};
static_assert(alignof(UUndetectableTimedEffect) == 0x000008, "Wrong alignment on UUndetectableTimedEffect");
static_assert(sizeof(UUndetectableTimedEffect) == 0x000350, "Wrong size on UUndetectableTimedEffect");

// Class DBDCompetence.DelayedHealEffect
// 0x0008 (0x0358 - 0x0350)
class UDelayedHealEffect final : public UStatusEffect
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnActivationTimerComplete();
	void Authority_OnOwningCamperHealthChanged(ECamperDamageState before, ECamperDamageState after);
	void Authority_OnOwningCamperPickedUp(class ADBDPlayer* picker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DelayedHealEffect">();
	}
	static class UDelayedHealEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDelayedHealEffect>();
	}
};
static_assert(alignof(UDelayedHealEffect) == 0x000008, "Wrong alignment on UDelayedHealEffect");
static_assert(sizeof(UDelayedHealEffect) == 0x000358, "Wrong size on UDelayedHealEffect");

// Class DBDCompetence.DidGameEventOccurred
// 0x0038 (0x0120 - 0x00E8)
class UDidGameEventOccurred final : public UEventDrivenModifierCondition
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x00E8(0x000C)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x2C];                                      // 0x00F4(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DidGameEventOccurred">();
	}
	static class UDidGameEventOccurred* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDidGameEventOccurred>();
	}
};
static_assert(alignof(UDidGameEventOccurred) == 0x000008, "Wrong alignment on UDidGameEventOccurred");
static_assert(sizeof(UDidGameEventOccurred) == 0x000120, "Wrong size on UDidGameEventOccurred");
static_assert(offsetof(UDidGameEventOccurred, EventTag) == 0x0000E8, "Member 'UDidGameEventOccurred::EventTag' has a wrong offset!");

// Class DBDCompetence.TestDBDGameState
// 0x0000 (0x0868 - 0x0868)
class ATestDBDGameState final : public ADBDGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestDBDGameState">();
	}
	static class ATestDBDGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestDBDGameState>();
	}
};
static_assert(alignof(ATestDBDGameState) == 0x000008, "Wrong alignment on ATestDBDGameState");
static_assert(sizeof(ATestDBDGameState) == 0x000868, "Wrong size on ATestDBDGameState");

// Class DBDCompetence.Distortion
// 0x0030 (0x03F8 - 0x03C8)
class UDistortion final : public UPerk
{
public:
	float                                         _activationDurations[0x3];                         // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _auraBlockIsActive;                                // 0x03D4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D5[0x3];                                      // 0x03D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _regainTokenDurationTimer;                         // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DC[0x1C];                                     // 0x03DC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAuraBlockedCosmetic();
	void OnRep_AuraBlockIsActive();

	bool AuraBlockCanBeActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Distortion">();
	}
	static class UDistortion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistortion>();
	}
};
static_assert(alignof(UDistortion) == 0x000008, "Wrong alignment on UDistortion");
static_assert(sizeof(UDistortion) == 0x0003F8, "Wrong size on UDistortion");
static_assert(offsetof(UDistortion, _activationDurations) == 0x0003C8, "Member 'UDistortion::_activationDurations' has a wrong offset!");
static_assert(offsetof(UDistortion, _auraBlockIsActive) == 0x0003D4, "Member 'UDistortion::_auraBlockIsActive' has a wrong offset!");
static_assert(offsetof(UDistortion, _regainTokenDurationTimer) == 0x0003D8, "Member 'UDistortion::_regainTokenDurationTimer' has a wrong offset!");

// Class DBDCompetence.DoesPerkHaveToken
// 0x0010 (0x00F8 - 0x00E8)
class UDoesPerkHaveToken final : public UEventDrivenModifierCondition
{
public:
	TWeakObjectPtr<class UPerk>                   _perk;                                             // 0x00E8(0x0008)(ExportObject, Net, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Perk();
	void SetPerk(class UPerk* perk);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoesPerkHaveToken">();
	}
	static class UDoesPerkHaveToken* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoesPerkHaveToken>();
	}
};
static_assert(alignof(UDoesPerkHaveToken) == 0x000008, "Wrong alignment on UDoesPerkHaveToken");
static_assert(sizeof(UDoesPerkHaveToken) == 0x0000F8, "Wrong size on UDoesPerkHaveToken");
static_assert(offsetof(UDoesPerkHaveToken, _perk) == 0x0000E8, "Member 'UDoesPerkHaveToken::_perk' has a wrong offset!");

// Class DBDCompetence.TestAnyActorPairQueryRangeIsTrue
// 0x0008 (0x0108 - 0x0100)
class UTestAnyActorPairQueryRangeIsTrue final : public UAnyActorPairQueryRangeIsTrue
{
public:
	class UActorPairQueryEvaluatorComponent*      _actorPairQueryEvaluatorComponent;                 // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestAnyActorPairQueryRangeIsTrue">();
	}
	static class UTestAnyActorPairQueryRangeIsTrue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTestAnyActorPairQueryRangeIsTrue>();
	}
};
static_assert(alignof(UTestAnyActorPairQueryRangeIsTrue) == 0x000008, "Wrong alignment on UTestAnyActorPairQueryRangeIsTrue");
static_assert(sizeof(UTestAnyActorPairQueryRangeIsTrue) == 0x000108, "Wrong size on UTestAnyActorPairQueryRangeIsTrue");
static_assert(offsetof(UTestAnyActorPairQueryRangeIsTrue, _actorPairQueryEvaluatorComponent) == 0x000100, "Member 'UTestAnyActorPairQueryRangeIsTrue::_actorPairQueryEvaluatorComponent' has a wrong offset!");

// Class DBDCompetence.DownedByBasicAttack
// 0x0058 (0x0140 - 0x00E8)
class UDownedByBasicAttack final : public UEventDrivenModifierCondition
{
public:
	bool                                          _replicatedIsTrue;                                 // 0x00E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E9[0x57];                                      // 0x00E9(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ReplicatedIsTrue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DownedByBasicAttack">();
	}
	static class UDownedByBasicAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDownedByBasicAttack>();
	}
};
static_assert(alignof(UDownedByBasicAttack) == 0x000008, "Wrong alignment on UDownedByBasicAttack");
static_assert(sizeof(UDownedByBasicAttack) == 0x000140, "Wrong size on UDownedByBasicAttack");
static_assert(offsetof(UDownedByBasicAttack, _replicatedIsTrue) == 0x0000E8, "Member 'UDownedByBasicAttack::_replicatedIsTrue' has a wrong offset!");

// Class DBDCompetence.DyingLight
// 0x0040 (0x0408 - 0x03C8)
class UDyingLight final : public UPerk
{
public:
	TArray<float>                                 _actionSpeedPenaltyPerToken;                       // 0x03C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         _obsessionActionSpeedBonus;                        // 0x03D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _obsessionStatusEffectID;                          // 0x03DC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _nonObsessionStatusEffectID;                       // 0x03E8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStatusEffect*>                  _survivorDebuffs;                                  // 0x03F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void OnObsessionChanged(class ACamperPlayer* newObsession, class ACamperPlayer* previousObsession);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DyingLight">();
	}
	static class UDyingLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDyingLight>();
	}
};
static_assert(alignof(UDyingLight) == 0x000008, "Wrong alignment on UDyingLight");
static_assert(sizeof(UDyingLight) == 0x000408, "Wrong size on UDyingLight");
static_assert(offsetof(UDyingLight, _actionSpeedPenaltyPerToken) == 0x0003C8, "Member 'UDyingLight::_actionSpeedPenaltyPerToken' has a wrong offset!");
static_assert(offsetof(UDyingLight, _obsessionActionSpeedBonus) == 0x0003D8, "Member 'UDyingLight::_obsessionActionSpeedBonus' has a wrong offset!");
static_assert(offsetof(UDyingLight, _obsessionStatusEffectID) == 0x0003DC, "Member 'UDyingLight::_obsessionStatusEffectID' has a wrong offset!");
static_assert(offsetof(UDyingLight, _nonObsessionStatusEffectID) == 0x0003E8, "Member 'UDyingLight::_nonObsessionStatusEffectID' has a wrong offset!");
static_assert(offsetof(UDyingLight, _survivorDebuffs) == 0x0003F8, "Member 'UDyingLight::_survivorDebuffs' has a wrong offset!");

// Class DBDCompetence.EnduranceHighlightEffect
// 0x0008 (0x0358 - 0x0350)
class UEnduranceHighlightEffect final : public UStatusEffect
{
public:
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnduranceHighlightEffect">();
	}
	static class UEnduranceHighlightEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnduranceHighlightEffect>();
	}
};
static_assert(alignof(UEnduranceHighlightEffect) == 0x000008, "Wrong alignment on UEnduranceHighlightEffect");
static_assert(sizeof(UEnduranceHighlightEffect) == 0x000358, "Wrong size on UEnduranceHighlightEffect");

// Class DBDCompetence.ExposedEffect
// 0x0000 (0x0360 - 0x0360)
class UExposedEffect : public UAdjustableCooldownStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExposedEffect">();
	}
	static class UExposedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExposedEffect>();
	}
};
static_assert(alignof(UExposedEffect) == 0x000008, "Wrong alignment on UExposedEffect");
static_assert(sizeof(UExposedEffect) == 0x000360, "Wrong size on UExposedEffect");

// Class DBDCompetence.Fixated
// 0x0000 (0x03C8 - 0x03C8)
class UFixated final : public UPerk
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Fixated">();
	}
	static class UFixated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFixated>();
	}
};
static_assert(alignof(UFixated) == 0x000008, "Wrong alignment on UFixated");
static_assert(sizeof(UFixated) == 0x0003C8, "Wrong size on UFixated");

// Class DBDCompetence.FlipFlop
// 0x0018 (0x03E0 - 0x03C8)
class UFlipFlop final : public UPerk
{
public:
	float                                         _recoveryProgressionConversionRatio[0x3];          // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _maxWiggleProgression[0x3];                        // 0x03D4(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Authority_OnPickedUp(class ADBDPlayer* picker);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlipFlop">();
	}
	static class UFlipFlop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlipFlop>();
	}
};
static_assert(alignof(UFlipFlop) == 0x000008, "Wrong alignment on UFlipFlop");
static_assert(sizeof(UFlipFlop) == 0x0003E0, "Wrong size on UFlipFlop");
static_assert(offsetof(UFlipFlop, _recoveryProgressionConversionRatio) == 0x0003C8, "Member 'UFlipFlop::_recoveryProgressionConversionRatio' has a wrong offset!");
static_assert(offsetof(UFlipFlop, _maxWiggleProgression) == 0x0003D4, "Member 'UFlipFlop::_maxWiggleProgression' has a wrong offset!");

// Class DBDCompetence.WeddingRing
// 0x0008 (0x02C0 - 0x02B8)
class UWeddingRing final : public UItemAddon
{
public:
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeddingRing">();
	}
	static class UWeddingRing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeddingRing>();
	}
};
static_assert(alignof(UWeddingRing) == 0x000008, "Wrong alignment on UWeddingRing");
static_assert(sizeof(UWeddingRing) == 0x0002C0, "Wrong size on UWeddingRing");

// Class DBDCompetence.FurtiveChase
// 0x0010 (0x03D8 - 0x03C8)
class UFurtiveChase final : public UPerk
{
public:
	int32                                         _maxTokensByLevel[0x3];                            // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _terrorRadiusSuppressionPerToken;                  // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FurtiveChase">();
	}
	static class UFurtiveChase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFurtiveChase>();
	}
};
static_assert(alignof(UFurtiveChase) == 0x000008, "Wrong alignment on UFurtiveChase");
static_assert(sizeof(UFurtiveChase) == 0x0003D8, "Wrong size on UFurtiveChase");
static_assert(offsetof(UFurtiveChase, _maxTokensByLevel) == 0x0003C8, "Member 'UFurtiveChase::_maxTokensByLevel' has a wrong offset!");
static_assert(offsetof(UFurtiveChase, _terrorRadiusSuppressionPerToken) == 0x0003D4, "Member 'UFurtiveChase::_terrorRadiusSuppressionPerToken' has a wrong offset!");

// Class DBDCompetence.GateBlockerEffect
// 0x0038 (0x0388 - 0x0350)
class UGateBlockerEffect : public UStatusEffect
{
public:
	float                                         _blockGateLingeringTime;                           // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0x34];                                     // 0x0354(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RemoveCantEscapeFlag();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GateBlockerEffect">();
	}
	static class UGateBlockerEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGateBlockerEffect>();
	}
};
static_assert(alignof(UGateBlockerEffect) == 0x000008, "Wrong alignment on UGateBlockerEffect");
static_assert(sizeof(UGateBlockerEffect) == 0x000388, "Wrong size on UGateBlockerEffect");
static_assert(offsetof(UGateBlockerEffect, _blockGateLingeringTime) == 0x000350, "Member 'UGateBlockerEffect::_blockGateLingeringTime' has a wrong offset!");

// Class DBDCompetence.ThrillingTremors
// 0x0060 (0x0428 - 0x03C8)
class UThrillingTremors final : public UPerk
{
public:
	int32                                         _cooldownByLevel[0x3];                             // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _durationByLevel[0x3];                             // 0x03D4(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _disableWhenSurvivorPutDownOrUnhooked;             // 0x03E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           _generatorAuraColorForKiller;                      // 0x03E4(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AGenerator*>                     _blockedGenerators;                                // 0x03F8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class AGenerator*>                     _revealedGenerators;                               // 0x0408(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x10];                                     // 0x0418(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_BlockedGenerators();

	int32 GetCooldownAtLevel() const;
	float GetDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrillingTremors">();
	}
	static class UThrillingTremors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThrillingTremors>();
	}
};
static_assert(alignof(UThrillingTremors) == 0x000008, "Wrong alignment on UThrillingTremors");
static_assert(sizeof(UThrillingTremors) == 0x000428, "Wrong size on UThrillingTremors");
static_assert(offsetof(UThrillingTremors, _cooldownByLevel) == 0x0003C8, "Member 'UThrillingTremors::_cooldownByLevel' has a wrong offset!");
static_assert(offsetof(UThrillingTremors, _durationByLevel) == 0x0003D4, "Member 'UThrillingTremors::_durationByLevel' has a wrong offset!");
static_assert(offsetof(UThrillingTremors, _disableWhenSurvivorPutDownOrUnhooked) == 0x0003E0, "Member 'UThrillingTremors::_disableWhenSurvivorPutDownOrUnhooked' has a wrong offset!");
static_assert(offsetof(UThrillingTremors, _generatorAuraColorForKiller) == 0x0003E4, "Member 'UThrillingTremors::_generatorAuraColorForKiller' has a wrong offset!");
static_assert(offsetof(UThrillingTremors, _blockedGenerators) == 0x0003F8, "Member 'UThrillingTremors::_blockedGenerators' has a wrong offset!");
static_assert(offsetof(UThrillingTremors, _revealedGenerators) == 0x000408, "Member 'UThrillingTremors::_revealedGenerators' has a wrong offset!");

// Class DBDCompetence.HasActiveHeartbeatEmitters
// 0x0020 (0x0108 - 0x00E8)
class UHasActiveHeartbeatEmitters final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x20];                                      // 0x00E8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasActiveHeartbeatEmitters">();
	}
	static class UHasActiveHeartbeatEmitters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasActiveHeartbeatEmitters>();
	}
};
static_assert(alignof(UHasActiveHeartbeatEmitters) == 0x000008, "Wrong alignment on UHasActiveHeartbeatEmitters");
static_assert(sizeof(UHasActiveHeartbeatEmitters) == 0x000108, "Wrong size on UHasActiveHeartbeatEmitters");

// Class DBDCompetence.HasCleansedTotemInnerStrength
// 0x0018 (0x0100 - 0x00E8)
class UHasCleansedTotemInnerStrength final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasCleansedTotemInnerStrength">();
	}
	static class UHasCleansedTotemInnerStrength* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasCleansedTotemInnerStrength>();
	}
};
static_assert(alignof(UHasCleansedTotemInnerStrength) == 0x000008, "Wrong alignment on UHasCleansedTotemInnerStrength");
static_assert(sizeof(UHasCleansedTotemInnerStrength) == 0x000100, "Wrong size on UHasCleansedTotemInnerStrength");

// Class DBDCompetence.ZanshinTactics
// 0x0010 (0x03D8 - 0x03C8)
class UZanshinTactics final : public UPerk
{
public:
	float                                         _coolDownDuration[0x3];                            // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZanshinTactics">();
	}
	static class UZanshinTactics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UZanshinTactics>();
	}
};
static_assert(alignof(UZanshinTactics) == 0x000008, "Wrong alignment on UZanshinTactics");
static_assert(sizeof(UZanshinTactics) == 0x0003D8, "Wrong size on UZanshinTactics");
static_assert(offsetof(UZanshinTactics, _coolDownDuration) == 0x0003C8, "Member 'UZanshinTactics::_coolDownDuration' has a wrong offset!");

// Class DBDCompetence.HasFlag
// 0x0040 (0x0128 - 0x00E8)
class UHasFlag final : public UEventDrivenModifierCondition
{
public:
	struct FGameplayTag                           _flag;                                             // 0x00E8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0x34];                                      // 0x00F4(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasFlag">();
	}
	static class UHasFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasFlag>();
	}
};
static_assert(alignof(UHasFlag) == 0x000008, "Wrong alignment on UHasFlag");
static_assert(sizeof(UHasFlag) == 0x000128, "Wrong size on UHasFlag");
static_assert(offsetof(UHasFlag, _flag) == 0x0000E8, "Member 'UHasFlag::_flag' has a wrong offset!");

// Class DBDCompetence.HasLineOfSightQueryComponent
// 0x0010 (0x00C8 - 0x00B8)
class UHasLineOfSightQueryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HasLineOfSightQueryComponent">();
	}
	static class UHasLineOfSightQueryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHasLineOfSightQueryComponent>();
	}
};
static_assert(alignof(UHasLineOfSightQueryComponent) == 0x000008, "Wrong alignment on UHasLineOfSightQueryComponent");
static_assert(sizeof(UHasLineOfSightQueryComponent) == 0x0000C8, "Wrong size on UHasLineOfSightQueryComponent");

// Class DBDCompetence.MonstrousShrine
// 0x0030 (0x03F8 - 0x03C8)
class UMonstrousShrine final : public UPerk
{
public:
	uint8                                         Pad_3C8[0x18];                                     // 0x03C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _fasterDrainPercentage[0x3];                       // 0x03E0(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _fasterDrainOnScourgeHookEffect;                   // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Authority_OnSurvivorHookedOnScourgeHook(const struct FGameEventData& gameEventData);
	void Authority_OnSurvivorUnhookedOnScourgeHook(const struct FGameEventData& gameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MonstrousShrine">();
	}
	static class UMonstrousShrine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMonstrousShrine>();
	}
};
static_assert(alignof(UMonstrousShrine) == 0x000008, "Wrong alignment on UMonstrousShrine");
static_assert(sizeof(UMonstrousShrine) == 0x0003F8, "Wrong size on UMonstrousShrine");
static_assert(offsetof(UMonstrousShrine, _fasterDrainPercentage) == 0x0003E0, "Member 'UMonstrousShrine::_fasterDrainPercentage' has a wrong offset!");
static_assert(offsetof(UMonstrousShrine, _fasterDrainOnScourgeHookEffect) == 0x0003F0, "Member 'UMonstrousShrine::_fasterDrainOnScourgeHookEffect' has a wrong offset!");

// Class DBDCompetence.HexNoOneEscapesDeath
// 0x0070 (0x04B8 - 0x0448)
class UHexNoOneEscapesDeath final : public UHexPerk
{
public:
	TSubclassOf<class UStatusEffect>              _hasteImposedEffectClass;                          // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _exposedEffectClass;                               // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _revealCurseWhenTotemShownToSurvivor;              // 0x0458(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _revealCurseWhenSurvivorGetHits;                   // 0x0459(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45A[0x2];                                      // 0x045A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _auraRevealStartDistance;                          // 0x045C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _auraRevealEndDistance;                            // 0x0460(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _auraRevealDuration;                               // 0x0464(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hastePerLevel[0x3];                               // 0x0468(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _shouldActivateTotemOutline;                       // 0x0474(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_475[0x43];                                     // 0x0475(0x0043)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const float GetHasteAtLevel();
	void OnRep_SetShouldActivateTotemOutline();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexNoOneEscapesDeath">();
	}
	static class UHexNoOneEscapesDeath* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexNoOneEscapesDeath>();
	}
};
static_assert(alignof(UHexNoOneEscapesDeath) == 0x000008, "Wrong alignment on UHexNoOneEscapesDeath");
static_assert(sizeof(UHexNoOneEscapesDeath) == 0x0004B8, "Wrong size on UHexNoOneEscapesDeath");
static_assert(offsetof(UHexNoOneEscapesDeath, _hasteImposedEffectClass) == 0x000448, "Member 'UHexNoOneEscapesDeath::_hasteImposedEffectClass' has a wrong offset!");
static_assert(offsetof(UHexNoOneEscapesDeath, _exposedEffectClass) == 0x000450, "Member 'UHexNoOneEscapesDeath::_exposedEffectClass' has a wrong offset!");
static_assert(offsetof(UHexNoOneEscapesDeath, _revealCurseWhenTotemShownToSurvivor) == 0x000458, "Member 'UHexNoOneEscapesDeath::_revealCurseWhenTotemShownToSurvivor' has a wrong offset!");
static_assert(offsetof(UHexNoOneEscapesDeath, _revealCurseWhenSurvivorGetHits) == 0x000459, "Member 'UHexNoOneEscapesDeath::_revealCurseWhenSurvivorGetHits' has a wrong offset!");
static_assert(offsetof(UHexNoOneEscapesDeath, _auraRevealStartDistance) == 0x00045C, "Member 'UHexNoOneEscapesDeath::_auraRevealStartDistance' has a wrong offset!");
static_assert(offsetof(UHexNoOneEscapesDeath, _auraRevealEndDistance) == 0x000460, "Member 'UHexNoOneEscapesDeath::_auraRevealEndDistance' has a wrong offset!");
static_assert(offsetof(UHexNoOneEscapesDeath, _auraRevealDuration) == 0x000464, "Member 'UHexNoOneEscapesDeath::_auraRevealDuration' has a wrong offset!");
static_assert(offsetof(UHexNoOneEscapesDeath, _hastePerLevel) == 0x000468, "Member 'UHexNoOneEscapesDeath::_hastePerLevel' has a wrong offset!");
static_assert(offsetof(UHexNoOneEscapesDeath, _shouldActivateTotemOutline) == 0x000474, "Member 'UHexNoOneEscapesDeath::_shouldActivateTotemOutline' has a wrong offset!");

// Class DBDCompetence.HexRuin
// 0x00C8 (0x0510 - 0x0448)
class UHexRuin final : public UHexPerk
{
public:
	uint8                                         Pad_448[0x18];                                     // 0x0448(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AGenerator*, struct FFastTimer>    _curseActivationTimers;                            // 0x0460(0x0050)(Transient, NativeAccessSpecifierPrivate)
	float                                         _regressionModifier[0x3];                          // 0x04B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AGenerator*, uint64>               _gameplayModifierHandles;                          // 0x04C0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void Authority_SetupCurseOnAllGenerators();

	const float GetRegressionModifierByLevel(int32 perkLevel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexRuin">();
	}
	static class UHexRuin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexRuin>();
	}
};
static_assert(alignof(UHexRuin) == 0x000008, "Wrong alignment on UHexRuin");
static_assert(sizeof(UHexRuin) == 0x000510, "Wrong size on UHexRuin");
static_assert(offsetof(UHexRuin, _curseActivationTimers) == 0x000460, "Member 'UHexRuin::_curseActivationTimers' has a wrong offset!");
static_assert(offsetof(UHexRuin, _regressionModifier) == 0x0004B0, "Member 'UHexRuin::_regressionModifier' has a wrong offset!");
static_assert(offsetof(UHexRuin, _gameplayModifierHandles) == 0x0004C0, "Member 'UHexRuin::_gameplayModifierHandles' has a wrong offset!");

// Class DBDCompetence.HexThirdSeal
// 0x0038 (0x0480 - 0x0448)
class UHexThirdSeal final : public UHexPerk
{
public:
	int32                                         _numOfHitPlayers;                                  // 0x0448(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44C[0x1C];                                     // 0x044C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _thirdSealBlindnessEffect;                         // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _maximumBlindableSurvivors[0x3];                   // 0x0470(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_NumOfHitPlayers();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexThirdSeal">();
	}
	static class UHexThirdSeal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexThirdSeal>();
	}
};
static_assert(alignof(UHexThirdSeal) == 0x000008, "Wrong alignment on UHexThirdSeal");
static_assert(sizeof(UHexThirdSeal) == 0x000480, "Wrong size on UHexThirdSeal");
static_assert(offsetof(UHexThirdSeal, _numOfHitPlayers) == 0x000448, "Member 'UHexThirdSeal::_numOfHitPlayers' has a wrong offset!");
static_assert(offsetof(UHexThirdSeal, _thirdSealBlindnessEffect) == 0x000468, "Member 'UHexThirdSeal::_thirdSealBlindnessEffect' has a wrong offset!");
static_assert(offsetof(UHexThirdSeal, _maximumBlindableSurvivors) == 0x000470, "Member 'UHexThirdSeal::_maximumBlindableSurvivors' has a wrong offset!");

// Class DBDCompetence.HexThrillOfTheHunt
// 0x0018 (0x0460 - 0x0448)
class UHexThrillOfTheHunt final : public UHexPerk
{
public:
	TSubclassOf<class UStatusEffect>              _thrillOfTheHuntStatusEffect;                      // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStatusEffect*>                  _survivorThrillOfTheHuntEffects;                   // 0x0450(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexThrillOfTheHunt">();
	}
	static class UHexThrillOfTheHunt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexThrillOfTheHunt>();
	}
};
static_assert(alignof(UHexThrillOfTheHunt) == 0x000008, "Wrong alignment on UHexThrillOfTheHunt");
static_assert(sizeof(UHexThrillOfTheHunt) == 0x000460, "Wrong size on UHexThrillOfTheHunt");
static_assert(offsetof(UHexThrillOfTheHunt, _thrillOfTheHuntStatusEffect) == 0x000448, "Member 'UHexThrillOfTheHunt::_thrillOfTheHuntStatusEffect' has a wrong offset!");
static_assert(offsetof(UHexThrillOfTheHunt, _survivorThrillOfTheHuntEffects) == 0x000450, "Member 'UHexThrillOfTheHunt::_survivorThrillOfTheHuntEffects' has a wrong offset!");

// Class DBDCompetence.ObsessionTargetSubjectProvider
// 0x0010 (0x0058 - 0x0048)
class UObsessionTargetSubjectProvider final : public UModifierSubjectProvider
{
public:
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObsessionTargetSubjectProvider">();
	}
	static class UObsessionTargetSubjectProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObsessionTargetSubjectProvider>();
	}
};
static_assert(alignof(UObsessionTargetSubjectProvider) == 0x000008, "Wrong alignment on UObsessionTargetSubjectProvider");
static_assert(sizeof(UObsessionTargetSubjectProvider) == 0x000058, "Wrong size on UObsessionTargetSubjectProvider");

// Class DBDCompetence.HexThrillOfTheHuntStatusEffect
// 0x0010 (0x0360 - 0x0350)
class UHexThrillOfTheHuntStatusEffect final : public UStatusEffect
{
public:
	float                                         _hunterPointsBonusPercent;                         // 0x0350(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _speedPenaltyPercents[0x3];                        // 0x0354(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HexThrillOfTheHuntStatusEffect">();
	}
	static class UHexThrillOfTheHuntStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHexThrillOfTheHuntStatusEffect>();
	}
};
static_assert(alignof(UHexThrillOfTheHuntStatusEffect) == 0x000008, "Wrong alignment on UHexThrillOfTheHuntStatusEffect");
static_assert(sizeof(UHexThrillOfTheHuntStatusEffect) == 0x000360, "Wrong size on UHexThrillOfTheHuntStatusEffect");
static_assert(offsetof(UHexThrillOfTheHuntStatusEffect, _hunterPointsBonusPercent) == 0x000350, "Member 'UHexThrillOfTheHuntStatusEffect::_hunterPointsBonusPercent' has a wrong offset!");
static_assert(offsetof(UHexThrillOfTheHuntStatusEffect, _speedPenaltyPercents) == 0x000354, "Member 'UHexThrillOfTheHuntStatusEffect::_speedPenaltyPercents' has a wrong offset!");

// Class DBDCompetence.HideSurvivorVFXForKillerEffect
// 0x0000 (0x0350 - 0x0350)
class UHideSurvivorVFXForKillerEffect final : public UStatusEffect
{
public:
	void HideVFX(bool hide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HideSurvivorVFXForKillerEffect">();
	}
	static class UHideSurvivorVFXForKillerEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHideSurvivorVFXForKillerEffect>();
	}
};
static_assert(alignof(UHideSurvivorVFXForKillerEffect) == 0x000008, "Wrong alignment on UHideSurvivorVFXForKillerEffect");
static_assert(sizeof(UHideSurvivorVFXForKillerEffect) == 0x000350, "Wrong size on UHideSurvivorVFXForKillerEffect");

// Class DBDCompetence.HighestLevelAndClosestEffectCondition
// 0x0048 (0x0118 - 0x00D0)
class UHighestLevelAndClosestEffectCondition final : public UGameplayModifierCondition
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UStatusEffect*>                  _effectsLevel1;                                    // 0x00D8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  _effectsLevel2;                                    // 0x00E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UStatusEffect*>                  _effectsLevel3;                                    // 0x00F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitEffectArrays(class FName effectIDLevel1, class FName effectIDLevel2, class FName effectIDLevel3);
	void SetCurrentEffectLevel(int32 level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HighestLevelAndClosestEffectCondition">();
	}
	static class UHighestLevelAndClosestEffectCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHighestLevelAndClosestEffectCondition>();
	}
};
static_assert(alignof(UHighestLevelAndClosestEffectCondition) == 0x000008, "Wrong alignment on UHighestLevelAndClosestEffectCondition");
static_assert(sizeof(UHighestLevelAndClosestEffectCondition) == 0x000118, "Wrong size on UHighestLevelAndClosestEffectCondition");
static_assert(offsetof(UHighestLevelAndClosestEffectCondition, _effectsLevel1) == 0x0000D8, "Member 'UHighestLevelAndClosestEffectCondition::_effectsLevel1' has a wrong offset!");
static_assert(offsetof(UHighestLevelAndClosestEffectCondition, _effectsLevel2) == 0x0000E8, "Member 'UHighestLevelAndClosestEffectCondition::_effectsLevel2' has a wrong offset!");
static_assert(offsetof(UHighestLevelAndClosestEffectCondition, _effectsLevel3) == 0x0000F8, "Member 'UHighestLevelAndClosestEffectCondition::_effectsLevel3' has a wrong offset!");

// Class DBDCompetence.HopePerk
// 0x0018 (0x03E0 - 0x03C8)
class UHopePerk final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _hopePerkEffect;                                   // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _hasteEffect[0x3];                                 // 0x03D0(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HopePerk">();
	}
	static class UHopePerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHopePerk>();
	}
};
static_assert(alignof(UHopePerk) == 0x000008, "Wrong alignment on UHopePerk");
static_assert(sizeof(UHopePerk) == 0x0003E0, "Wrong size on UHopePerk");
static_assert(offsetof(UHopePerk, _hopePerkEffect) == 0x0003C8, "Member 'UHopePerk::_hopePerkEffect' has a wrong offset!");
static_assert(offsetof(UHopePerk, _hasteEffect) == 0x0003D0, "Member 'UHopePerk::_hasteEffect' has a wrong offset!");

// Class DBDCompetence.ImAllEars
// 0x0058 (0x0420 - 0x03C8)
class UImAllEars final : public UPerk
{
public:
	int32                                         _cooldownByLevel[0x3];                             // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _durationByLevel[0x3];                             // 0x03D4(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _useTerrorRadius;                                  // 0x03E0(0x0001)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _triggerOutsideRadius;                             // 0x03E4(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x38];                                     // 0x03E8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetCooldownAtLevel();
	float GetDurationAtLevel();
	void Server_OnCamperLoudNoise(const struct FGameplayTag& gameplayTag, const struct FGameEventData& gameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImAllEars">();
	}
	static class UImAllEars* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImAllEars>();
	}
};
static_assert(alignof(UImAllEars) == 0x000008, "Wrong alignment on UImAllEars");
static_assert(sizeof(UImAllEars) == 0x000420, "Wrong size on UImAllEars");
static_assert(offsetof(UImAllEars, _cooldownByLevel) == 0x0003C8, "Member 'UImAllEars::_cooldownByLevel' has a wrong offset!");
static_assert(offsetof(UImAllEars, _durationByLevel) == 0x0003D4, "Member 'UImAllEars::_durationByLevel' has a wrong offset!");
static_assert(offsetof(UImAllEars, _useTerrorRadius) == 0x0003E0, "Member 'UImAllEars::_useTerrorRadius' has a wrong offset!");
static_assert(offsetof(UImAllEars, _triggerOutsideRadius) == 0x0003E4, "Member 'UImAllEars::_triggerOutsideRadius' has a wrong offset!");

// Class DBDCompetence.ImmediateUndetectableEffect
// 0x0000 (0x0350 - 0x0350)
class UImmediateUndetectableEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImmediateUndetectableEffect">();
	}
	static class UImmediateUndetectableEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImmediateUndetectableEffect>();
	}
};
static_assert(alignof(UImmediateUndetectableEffect) == 0x000008, "Wrong alignment on UImmediateUndetectableEffect");
static_assert(sizeof(UImmediateUndetectableEffect) == 0x000350, "Wrong size on UImmediateUndetectableEffect");

// Class DBDCompetence.OnEventBaseAddon
// 0x0010 (0x02C8 - 0x02B8)
class UOnEventBaseAddon : public UItemAddon
{
public:
	struct FGameplayTag                           _eventToListenTo;                                  // 0x02B8(0x000C)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEventFired(const struct FGameEventData& gameEventData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnEventBaseAddon">();
	}
	static class UOnEventBaseAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnEventBaseAddon>();
	}
};
static_assert(alignof(UOnEventBaseAddon) == 0x000008, "Wrong alignment on UOnEventBaseAddon");
static_assert(sizeof(UOnEventBaseAddon) == 0x0002C8, "Wrong size on UOnEventBaseAddon");
static_assert(offsetof(UOnEventBaseAddon, _eventToListenTo) == 0x0002B8, "Member 'UOnEventBaseAddon::_eventToListenTo' has a wrong offset!");

// Class DBDCompetence.ImposeStatusEffectOnEventAddon
// 0x0020 (0x02E8 - 0x02C8)
class UImposeStatusEffectOnEventAddon : public UOnEventBaseAddon
{
public:
	float                                         _statusEffectTime;                                 // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   _statusEffectNameDeprecated;                       // 0x02CC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _statusEffect;                                     // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EImposeEffectTo                               _imposeEffectTo;                                   // 0x02E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E1[0x7];                                      // 0x02E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImposeStatusEffectOnEventAddon">();
	}
	static class UImposeStatusEffectOnEventAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImposeStatusEffectOnEventAddon>();
	}
};
static_assert(alignof(UImposeStatusEffectOnEventAddon) == 0x000008, "Wrong alignment on UImposeStatusEffectOnEventAddon");
static_assert(sizeof(UImposeStatusEffectOnEventAddon) == 0x0002E8, "Wrong size on UImposeStatusEffectOnEventAddon");
static_assert(offsetof(UImposeStatusEffectOnEventAddon, _statusEffectTime) == 0x0002C8, "Member 'UImposeStatusEffectOnEventAddon::_statusEffectTime' has a wrong offset!");
static_assert(offsetof(UImposeStatusEffectOnEventAddon, _statusEffectNameDeprecated) == 0x0002CC, "Member 'UImposeStatusEffectOnEventAddon::_statusEffectNameDeprecated' has a wrong offset!");
static_assert(offsetof(UImposeStatusEffectOnEventAddon, _statusEffect) == 0x0002D8, "Member 'UImposeStatusEffectOnEventAddon::_statusEffect' has a wrong offset!");
static_assert(offsetof(UImposeStatusEffectOnEventAddon, _imposeEffectTo) == 0x0002E0, "Member 'UImposeStatusEffectOnEventAddon::_imposeEffectTo' has a wrong offset!");

// Class DBDCompetence.InfectiousFright
// 0x0048 (0x0410 - 0x03C8)
class UInfectiousFright final : public UPerk
{
public:
	bool                                          _revealPlayerInTerrorRadius;                       // 0x03C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         _perkActivationCount;                              // 0x03C9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3CA[0x6];                                      // 0x03CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACamperPlayer*>                  _revealedSurvivors;                                // 0x03D0(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class ACamperPlayer*                          _targetSurvivor;                                   // 0x03E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x28];                                     // 0x03E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_PerkActivationCount();
	void RevealSurvivorLocation(class ACamperPlayer* target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InfectiousFright">();
	}
	static class UInfectiousFright* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInfectiousFright>();
	}
};
static_assert(alignof(UInfectiousFright) == 0x000008, "Wrong alignment on UInfectiousFright");
static_assert(sizeof(UInfectiousFright) == 0x000410, "Wrong size on UInfectiousFright");
static_assert(offsetof(UInfectiousFright, _revealPlayerInTerrorRadius) == 0x0003C8, "Member 'UInfectiousFright::_revealPlayerInTerrorRadius' has a wrong offset!");
static_assert(offsetof(UInfectiousFright, _perkActivationCount) == 0x0003C9, "Member 'UInfectiousFright::_perkActivationCount' has a wrong offset!");
static_assert(offsetof(UInfectiousFright, _revealedSurvivors) == 0x0003D0, "Member 'UInfectiousFright::_revealedSurvivors' has a wrong offset!");
static_assert(offsetof(UInfectiousFright, _targetSurvivor) == 0x0003E0, "Member 'UInfectiousFright::_targetSurvivor' has a wrong offset!");

// Class DBDCompetence.InnerStrength
// 0x0038 (0x0400 - 0x03C8)
class UInnerStrength final : public UPerk
{
public:
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _hideDuration[0x3];                                // 0x03D0(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DC[0x24];                                     // 0x03DC(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnPlayerImmobilizeStateChanged(const ECamperImmobilizeState oldImmobilizeState, const ECamperImmobilizeState newImmobilizeState);

	float GetHideDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InnerStrength">();
	}
	static class UInnerStrength* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInnerStrength>();
	}
};
static_assert(alignof(UInnerStrength) == 0x000008, "Wrong alignment on UInnerStrength");
static_assert(sizeof(UInnerStrength) == 0x000400, "Wrong size on UInnerStrength");
static_assert(offsetof(UInnerStrength, _hideDuration) == 0x0003D0, "Member 'UInnerStrength::_hideDuration' has a wrong offset!");

// Class DBDCompetence.Insidious
// 0x0018 (0x03E0 - 0x03C8)
class UInsidious final : public UPerk
{
public:
	float                                         _stillnessRequired[0x3];                           // 0x03C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _insidiousEffect;                                  // 0x03D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Insidious">();
	}
	static class UInsidious* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInsidious>();
	}
};
static_assert(alignof(UInsidious) == 0x000008, "Wrong alignment on UInsidious");
static_assert(sizeof(UInsidious) == 0x0003E0, "Wrong size on UInsidious");
static_assert(offsetof(UInsidious, _stillnessRequired) == 0x0003C8, "Member 'UInsidious::_stillnessRequired' has a wrong offset!");
static_assert(offsetof(UInsidious, _insidiousEffect) == 0x0003D8, "Member 'UInsidious::_insidiousEffect' has a wrong offset!");

// Class DBDCompetence.InsidiousEffect
// 0x0000 (0x0350 - 0x0350)
class UInsidiousEffect final : public UStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InsidiousEffect">();
	}
	static class UInsidiousEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInsidiousEffect>();
	}
};
static_assert(alignof(UInsidiousEffect) == 0x000008, "Wrong alignment on UInsidiousEffect");
static_assert(sizeof(UInsidiousEffect) == 0x000350, "Wrong size on UInsidiousEffect");

// Class DBDCompetence.IsActivationTimerActive
// 0x0018 (0x0100 - 0x00E8)
class UIsActivationTimerActive final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsActivationTimerActive">();
	}
	static class UIsActivationTimerActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsActivationTimerActive>();
	}
};
static_assert(alignof(UIsActivationTimerActive) == 0x000008, "Wrong alignment on UIsActivationTimerActive");
static_assert(sizeof(UIsActivationTimerActive) == 0x000100, "Wrong size on UIsActivationTimerActive");

// Class DBDCompetence.IsActivationTimerActiveAndNotPaused
// 0x0020 (0x0108 - 0x00E8)
class UIsActivationTimerActiveAndNotPaused final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x20];                                      // 0x00E8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsActivationTimerActiveAndNotPaused">();
	}
	static class UIsActivationTimerActiveAndNotPaused* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsActivationTimerActiveAndNotPaused>();
	}
};
static_assert(alignof(UIsActivationTimerActiveAndNotPaused) == 0x000008, "Wrong alignment on UIsActivationTimerActiveAndNotPaused");
static_assert(sizeof(UIsActivationTimerActiveAndNotPaused) == 0x000108, "Wrong size on UIsActivationTimerActiveAndNotPaused");

// Class DBDCompetence.IsBestProveThyselfEffectInRange
// 0x0028 (0x0110 - 0x00E8)
class UIsBestProveThyselfEffectInRange final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x28];                                      // 0x00E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInRangeChanged(const bool inRange, class UProveThyselfEffect* proveThyselfEffect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsBestProveThyselfEffectInRange">();
	}
	static class UIsBestProveThyselfEffectInRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsBestProveThyselfEffectInRange>();
	}
};
static_assert(alignof(UIsBestProveThyselfEffectInRange) == 0x000008, "Wrong alignment on UIsBestProveThyselfEffectInRange");
static_assert(sizeof(UIsBestProveThyselfEffectInRange) == 0x000110, "Wrong size on UIsBestProveThyselfEffectInRange");

// Class DBDCompetence.IsBoonBlessed
// 0x0018 (0x0100 - 0x00E8)
class UIsBoonBlessed final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsBoonBlessed">();
	}
	static class UIsBoonBlessed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsBoonBlessed>();
	}
};
static_assert(alignof(UIsBoonBlessed) == 0x000008, "Wrong alignment on UIsBoonBlessed");
static_assert(sizeof(UIsBoonBlessed) == 0x000100, "Wrong size on UIsBoonBlessed");

// Class DBDCompetence.IsClosestEffectCondition
// 0x0000 (0x00D0 - 0x00D0)
class UIsClosestEffectCondition final : public UGameplayModifierCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsClosestEffectCondition">();
	}
	static class UIsClosestEffectCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsClosestEffectCondition>();
	}
};
static_assert(alignof(UIsClosestEffectCondition) == 0x000008, "Wrong alignment on UIsClosestEffectCondition");
static_assert(sizeof(UIsClosestEffectCondition) == 0x0000D0, "Wrong size on UIsClosestEffectCondition");

// Class DBDCompetence.IsCooldownTimerActive
// 0x0018 (0x0100 - 0x00E8)
class UIsCooldownTimerActive final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsCooldownTimerActive">();
	}
	static class UIsCooldownTimerActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsCooldownTimerActive>();
	}
};
static_assert(alignof(UIsCooldownTimerActive) == 0x000008, "Wrong alignment on UIsCooldownTimerActive");
static_assert(sizeof(UIsCooldownTimerActive) == 0x000100, "Wrong size on UIsCooldownTimerActive");

// Class DBDCompetence.IsHexCursed
// 0x0018 (0x0100 - 0x00E8)
class UIsHexCursed final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsHexCursed">();
	}
	static class UIsHexCursed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsHexCursed>();
	}
};
static_assert(alignof(UIsHexCursed) == 0x000008, "Wrong alignment on UIsHexCursed");
static_assert(sizeof(UIsHexCursed) == 0x000100, "Wrong size on UIsHexCursed");

// Class DBDCompetence.IsHighestLevelAndClosestOriginatingEffect
// 0x0028 (0x00F8 - 0x00D0)
class UIsHighestLevelAndClosestOriginatingEffect final : public UGameplayModifierCondition
{
public:
	TArray<class UStatusEffect*>                  _applicableEffects;                                // 0x00D0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x18];                                      // 0x00E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStatusEffectAddedOrRemoved(class UStatusEffect* effect, bool valid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsHighestLevelAndClosestOriginatingEffect">();
	}
	static class UIsHighestLevelAndClosestOriginatingEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsHighestLevelAndClosestOriginatingEffect>();
	}
};
static_assert(alignof(UIsHighestLevelAndClosestOriginatingEffect) == 0x000008, "Wrong alignment on UIsHighestLevelAndClosestOriginatingEffect");
static_assert(sizeof(UIsHighestLevelAndClosestOriginatingEffect) == 0x0000F8, "Wrong size on UIsHighestLevelAndClosestOriginatingEffect");
static_assert(offsetof(UIsHighestLevelAndClosestOriginatingEffect, _applicableEffects) == 0x0000D0, "Member 'UIsHighestLevelAndClosestOriginatingEffect::_applicableEffects' has a wrong offset!");

// Class DBDCompetence.IsHighestTierOriginatingPerk
// 0x0028 (0x0110 - 0x00E8)
class UIsHighestTierOriginatingPerk final : public UEventDrivenModifierCondition
{
public:
	TArray<class UStatusEffect*>                  _applicableEffects;                                // 0x00E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x18];                                      // 0x00F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStatusEffectAddedOrRemoved(class UStatusEffect* effect, bool valid);
	void OnStatusEffectApplicableChanged(class UGameplayModifierContainer* gameplayModifierContainer, bool isApplicable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsHighestTierOriginatingPerk">();
	}
	static class UIsHighestTierOriginatingPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsHighestTierOriginatingPerk>();
	}
};
static_assert(alignof(UIsHighestTierOriginatingPerk) == 0x000008, "Wrong alignment on UIsHighestTierOriginatingPerk");
static_assert(sizeof(UIsHighestTierOriginatingPerk) == 0x000110, "Wrong size on UIsHighestTierOriginatingPerk");
static_assert(offsetof(UIsHighestTierOriginatingPerk, _applicableEffects) == 0x0000E8, "Member 'UIsHighestTierOriginatingPerk::_applicableEffects' has a wrong offset!");

// Class DBDCompetence.IsInAnyHookedSurvivorOriginatorAuraReadingRange
// 0x00B0 (0x01A0 - 0x00F0)
class UIsInAnyHookedSurvivorOriginatorAuraReadingRange final : public URangeBasedCondition
{
public:
	uint8                                         Pad_F0[0xB0];                                      // 0x00F0(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsInAnyHookedSurvivorOriginatorAuraReadingRange">();
	}
	static class UIsInAnyHookedSurvivorOriginatorAuraReadingRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsInAnyHookedSurvivorOriginatorAuraReadingRange>();
	}
};
static_assert(alignof(UIsInAnyHookedSurvivorOriginatorAuraReadingRange) == 0x000008, "Wrong alignment on UIsInAnyHookedSurvivorOriginatorAuraReadingRange");
static_assert(sizeof(UIsInAnyHookedSurvivorOriginatorAuraReadingRange) == 0x0001A0, "Wrong size on UIsInAnyHookedSurvivorOriginatorAuraReadingRange");

// Class DBDCompetence.IsInRangeOfHookedSurvivor
// 0x00F0 (0x01E0 - 0x00F0)
class UIsInRangeOfHookedSurvivor : public URangeBasedCondition
{
public:
	uint8                                         Pad_F0[0xF0];                                      // 0x00F0(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsInRangeOfHookedSurvivor">();
	}
	static class UIsInRangeOfHookedSurvivor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsInRangeOfHookedSurvivor>();
	}
};
static_assert(alignof(UIsInRangeOfHookedSurvivor) == 0x000008, "Wrong alignment on UIsInRangeOfHookedSurvivor");
static_assert(sizeof(UIsInRangeOfHookedSurvivor) == 0x0001E0, "Wrong size on UIsInRangeOfHookedSurvivor");

// Class DBDCompetence.IsInRangeOfOriginatingPlayer
// 0x0028 (0x0118 - 0x00F0)
class UIsInRangeOfOriginatingPlayer final : public URangeBasedCondition
{
public:
	uint8                                         Pad_F0[0x28];                                      // 0x00F0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInRangeChanged(const bool inRange);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsInRangeOfOriginatingPlayer">();
	}
	static class UIsInRangeOfOriginatingPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsInRangeOfOriginatingPlayer>();
	}
};
static_assert(alignof(UIsInRangeOfOriginatingPlayer) == 0x000008, "Wrong alignment on UIsInRangeOfOriginatingPlayer");
static_assert(sizeof(UIsInRangeOfOriginatingPlayer) == 0x000118, "Wrong size on UIsInRangeOfOriginatingPlayer");

// Class DBDCompetence.IsLifetimeActive
// 0x0010 (0x00F8 - 0x00E8)
class UIsLifetimeActive final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsLifetimeActive">();
	}
	static class UIsLifetimeActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsLifetimeActive>();
	}
};
static_assert(alignof(UIsLifetimeActive) == 0x000008, "Wrong alignment on UIsLifetimeActive");
static_assert(sizeof(UIsLifetimeActive) == 0x0000F8, "Wrong size on UIsLifetimeActive");

// Class DBDCompetence.IsOnHitSprintEffectActive
// 0x0000 (0x00E8 - 0x00E8)
class UIsOnHitSprintEffectActive final : public UEventDrivenModifierCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOnHitSprintEffectActive">();
	}
	static class UIsOnHitSprintEffectActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOnHitSprintEffectActive>();
	}
};
static_assert(alignof(UIsOnHitSprintEffectActive) == 0x000008, "Wrong alignment on UIsOnHitSprintEffectActive");
static_assert(sizeof(UIsOnHitSprintEffectActive) == 0x0000E8, "Wrong size on UIsOnHitSprintEffectActive");

// Class DBDCompetence.IsOriginatingPerkBoundToTotems
// 0x0010 (0x00F8 - 0x00E8)
class UIsOriginatingPerkBoundToTotems final : public UEventDrivenModifierCondition
{
public:
	EComparisonOperation                          _comparisonOperator;                               // 0x00E8(0x0001)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         _totemCount;                                       // 0x00EC(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(EComparisonOperation comparisonOperator, int32 totemCount);
	void OnRep_TotemCount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOriginatingPerkBoundToTotems">();
	}
	static class UIsOriginatingPerkBoundToTotems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOriginatingPerkBoundToTotems>();
	}
};
static_assert(alignof(UIsOriginatingPerkBoundToTotems) == 0x000008, "Wrong alignment on UIsOriginatingPerkBoundToTotems");
static_assert(sizeof(UIsOriginatingPerkBoundToTotems) == 0x0000F8, "Wrong size on UIsOriginatingPerkBoundToTotems");
static_assert(offsetof(UIsOriginatingPerkBoundToTotems, _comparisonOperator) == 0x0000E8, "Member 'UIsOriginatingPerkBoundToTotems::_comparisonOperator' has a wrong offset!");
static_assert(offsetof(UIsOriginatingPerkBoundToTotems, _totemCount) == 0x0000EC, "Member 'UIsOriginatingPerkBoundToTotems::_totemCount' has a wrong offset!");

// Class DBDCompetence.IsOriginatingPerkUsableCondition
// 0x0000 (0x00F0 - 0x00F0)
class UIsOriginatingPerkUsableCondition final : public UBaseIsPerkUsableCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOriginatingPerkUsableCondition">();
	}
	static class UIsOriginatingPerkUsableCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOriginatingPerkUsableCondition>();
	}
};
static_assert(alignof(UIsOriginatingPerkUsableCondition) == 0x000008, "Wrong alignment on UIsOriginatingPerkUsableCondition");
static_assert(sizeof(UIsOriginatingPerkUsableCondition) == 0x0000F0, "Wrong size on UIsOriginatingPerkUsableCondition");

// Class DBDCompetence.IsOwningPlayerInRangeFromHook
// 0x0008 (0x0108 - 0x0100)
class UIsOwningPlayerInRangeFromHook : public UAnyActorPairQueryRangeIsTrue
{
public:
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOwningPlayerInRangeFromHook">();
	}
	static class UIsOwningPlayerInRangeFromHook* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOwningPlayerInRangeFromHook>();
	}
};
static_assert(alignof(UIsOwningPlayerInRangeFromHook) == 0x000008, "Wrong alignment on UIsOwningPlayerInRangeFromHook");
static_assert(sizeof(UIsOwningPlayerInRangeFromHook) == 0x000108, "Wrong size on UIsOwningPlayerInRangeFromHook");

// Class DBDCompetence.IsOwningPlayerInHookRangeWhenKillerCarry
// 0x0018 (0x0120 - 0x0108)
class UIsOwningPlayerInHookRangeWhenKillerCarry final : public UIsOwningPlayerInRangeFromHook
{
public:
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOwningPlayerInHookRangeWhenKillerCarry">();
	}
	static class UIsOwningPlayerInHookRangeWhenKillerCarry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOwningPlayerInHookRangeWhenKillerCarry>();
	}
};
static_assert(alignof(UIsOwningPlayerInHookRangeWhenKillerCarry) == 0x000008, "Wrong alignment on UIsOwningPlayerInHookRangeWhenKillerCarry");
static_assert(sizeof(UIsOwningPlayerInHookRangeWhenKillerCarry) == 0x000120, "Wrong size on UIsOwningPlayerInHookRangeWhenKillerCarry");

// Class DBDCompetence.IsOwningPlayerLastSurvivor
// 0x0008 (0x00F0 - 0x00E8)
class UIsOwningPlayerLastSurvivor final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x8];                                       // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOwningPlayerLastSurvivor">();
	}
	static class UIsOwningPlayerLastSurvivor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOwningPlayerLastSurvivor>();
	}
};
static_assert(alignof(UIsOwningPlayerLastSurvivor) == 0x000008, "Wrong alignment on UIsOwningPlayerLastSurvivor");
static_assert(sizeof(UIsOwningPlayerLastSurvivor) == 0x0000F0, "Wrong size on UIsOwningPlayerLastSurvivor");

// Class DBDCompetence.IsOwningSurvivorAuraRevealedToKiller
// 0x0000 (0x00D0 - 0x00D0)
class UIsOwningSurvivorAuraRevealedToKiller final : public UGameplayModifierCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsOwningSurvivorAuraRevealedToKiller">();
	}
	static class UIsOwningSurvivorAuraRevealedToKiller* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsOwningSurvivorAuraRevealedToKiller>();
	}
};
static_assert(alignof(UIsOwningSurvivorAuraRevealedToKiller) == 0x000008, "Wrong alignment on UIsOwningSurvivorAuraRevealedToKiller");
static_assert(sizeof(UIsOwningSurvivorAuraRevealedToKiller) == 0x0000D0, "Wrong size on UIsOwningSurvivorAuraRevealedToKiller");

// Class DBDCompetence.IsPerkUsableCondition
// 0x0000 (0x00F0 - 0x00F0)
class UIsPerkUsableCondition final : public UBaseIsPerkUsableCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsPerkUsableCondition">();
	}
	static class UIsPerkUsableCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsPerkUsableCondition>();
	}
};
static_assert(alignof(UIsPerkUsableCondition) == 0x000008, "Wrong alignment on UIsPerkUsableCondition");
static_assert(sizeof(UIsPerkUsableCondition) == 0x0000F0, "Wrong size on UIsPerkUsableCondition");

// Class DBDCompetence.IsPlayerLookingAtKillerCondition
// 0x0018 (0x0100 - 0x00E8)
class UIsPlayerLookingAtKillerCondition final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _precisionAngleDegrees;                            // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isLookingTowards;                                 // 0x00FC(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPawnControllerChanged(class APawn* pawn, class AController* controller);
	void OnRep_IsLookingTowards(const bool isLookingTowards);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsPlayerLookingAtKillerCondition">();
	}
	static class UIsPlayerLookingAtKillerCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsPlayerLookingAtKillerCondition>();
	}
};
static_assert(alignof(UIsPlayerLookingAtKillerCondition) == 0x000008, "Wrong alignment on UIsPlayerLookingAtKillerCondition");
static_assert(sizeof(UIsPlayerLookingAtKillerCondition) == 0x000100, "Wrong size on UIsPlayerLookingAtKillerCondition");
static_assert(offsetof(UIsPlayerLookingAtKillerCondition, _precisionAngleDegrees) == 0x0000F8, "Member 'UIsPlayerLookingAtKillerCondition::_precisionAngleDegrees' has a wrong offset!");
static_assert(offsetof(UIsPlayerLookingAtKillerCondition, _isLookingTowards) == 0x0000FC, "Member 'UIsPlayerLookingAtKillerCondition::_isLookingTowards' has a wrong offset!");

// Class DBDCompetence.IsPlayerPerfInteractionWithNoItem
// 0x0040 (0x0158 - 0x0118)
class UIsPlayerPerfInteractionWithNoItem final : public UBaseIsPlayerPerformingInteraction
{
public:
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  _useItemInteractionSemantics;                      // 0x0128(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ELoadoutItemType                              _itemType;                                         // 0x0150(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCollectableChargeStateChange(bool empty);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsPlayerPerfInteractionWithNoItem">();
	}
	static class UIsPlayerPerfInteractionWithNoItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsPlayerPerfInteractionWithNoItem>();
	}
};
static_assert(alignof(UIsPlayerPerfInteractionWithNoItem) == 0x000008, "Wrong alignment on UIsPlayerPerfInteractionWithNoItem");
static_assert(sizeof(UIsPlayerPerfInteractionWithNoItem) == 0x000158, "Wrong size on UIsPlayerPerfInteractionWithNoItem");
static_assert(offsetof(UIsPlayerPerfInteractionWithNoItem, _useItemInteractionSemantics) == 0x000128, "Member 'UIsPlayerPerfInteractionWithNoItem::_useItemInteractionSemantics' has a wrong offset!");
static_assert(offsetof(UIsPlayerPerfInteractionWithNoItem, _itemType) == 0x000150, "Member 'UIsPlayerPerfInteractionWithNoItem::_itemType' has a wrong offset!");

// Class DBDCompetence.IsPlayerPerformingItemInteraction
// 0x0020 (0x0138 - 0x0118)
class UIsPlayerPerformingItemInteraction final : public UBaseIsPlayerPerformingInteraction
{
public:
	uint8                                         Pad_118[0x20];                                     // 0x0118(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCollectableChargeStateChange(bool empty);
	void OnCollectableDropped();
	void OnCollectablePickedUp(class ADBDPlayer* player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsPlayerPerformingItemInteraction">();
	}
	static class UIsPlayerPerformingItemInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsPlayerPerformingItemInteraction>();
	}
};
static_assert(alignof(UIsPlayerPerformingItemInteraction) == 0x000008, "Wrong alignment on UIsPlayerPerformingItemInteraction");
static_assert(sizeof(UIsPlayerPerformingItemInteraction) == 0x000138, "Wrong size on UIsPlayerPerformingItemInteraction");

// Class DBDCompetence.IsPlayerPerformingInteraction
// 0x0040 (0x0128 - 0x00E8)
class UIsPlayerPerformingInteraction : public UEventDrivenModifierCondition
{
public:
	struct FGameplayTagContainer                  _interactionSemantics;                             // 0x00E8(0x0020)(Edit, BlueprintVisible, Net, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetInteractionSemantics(const struct FGameplayTagContainer& interactionSemantics);
	void UpdateIsTrue(class UInteractionDefinition* interactionDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsPlayerPerformingInteraction">();
	}
	static class UIsPlayerPerformingInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsPlayerPerformingInteraction>();
	}
};
static_assert(alignof(UIsPlayerPerformingInteraction) == 0x000008, "Wrong alignment on UIsPlayerPerformingInteraction");
static_assert(sizeof(UIsPlayerPerformingInteraction) == 0x000128, "Wrong size on UIsPlayerPerformingInteraction");
static_assert(offsetof(UIsPlayerPerformingInteraction, _interactionSemantics) == 0x0000E8, "Member 'UIsPlayerPerformingInteraction::_interactionSemantics' has a wrong offset!");

// Class DBDCompetence.IsSubjectInteractingWithOriginatingPlayer
// 0x0018 (0x0100 - 0x00E8)
class UIsSubjectInteractingWithOriginatingPlayer final : public UEventDrivenModifierCondition
{
public:
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IsSubjectInteractingWithOriginatingPlayer">();
	}
	static class UIsSubjectInteractingWithOriginatingPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIsSubjectInteractingWithOriginatingPlayer>();
	}
};
static_assert(alignof(UIsSubjectInteractingWithOriginatingPlayer) == 0x000008, "Wrong alignment on UIsSubjectInteractingWithOriginatingPlayer");
static_assert(sizeof(UIsSubjectInteractingWithOriginatingPlayer) == 0x000100, "Wrong size on UIsSubjectInteractingWithOriginatingPlayer");

// Class DBDCompetence.KillerConditionalSpeedCurveEffect
// 0x0008 (0x0358 - 0x0350)
class UKillerConditionalSpeedCurveEffect final : public UStatusEffect
{
public:
	class UCurveFloat*                            _speedCurve;                                       // 0x0350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerConditionalSpeedCurveEffect">();
	}
	static class UKillerConditionalSpeedCurveEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerConditionalSpeedCurveEffect>();
	}
};
static_assert(alignof(UKillerConditionalSpeedCurveEffect) == 0x000008, "Wrong alignment on UKillerConditionalSpeedCurveEffect");
static_assert(sizeof(UKillerConditionalSpeedCurveEffect) == 0x000358, "Wrong size on UKillerConditionalSpeedCurveEffect");
static_assert(offsetof(UKillerConditionalSpeedCurveEffect, _speedCurve) == 0x000350, "Member 'UKillerConditionalSpeedCurveEffect::_speedCurve' has a wrong offset!");

// Class DBDCompetence.KillerIsLowOnAmmo
// 0x0018 (0x0100 - 0x00E8)
class UKillerIsLowOnAmmo final : public UEventDrivenModifierCondition
{
public:
	int32                                         _ammoThreshold;                                    // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_EC[0x14];                                      // 0x00EC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillerIsLowOnAmmo">();
	}
	static class UKillerIsLowOnAmmo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillerIsLowOnAmmo>();
	}
};
static_assert(alignof(UKillerIsLowOnAmmo) == 0x000008, "Wrong alignment on UKillerIsLowOnAmmo");
static_assert(sizeof(UKillerIsLowOnAmmo) == 0x000100, "Wrong size on UKillerIsLowOnAmmo");
static_assert(offsetof(UKillerIsLowOnAmmo, _ammoThreshold) == 0x0000E8, "Member 'UKillerIsLowOnAmmo::_ammoThreshold' has a wrong offset!");

// Class DBDCompetence.KindredPerk
// 0x0030 (0x03F8 - 0x03C8)
class UKindredPerk final : public UPerk
{
public:
	TArray<float>                                 _killerAuraRevealRange;                            // 0x03C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _kindredRevealKillerOther;                         // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _kindredRevealKillerOwner;                         // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _kindredRevealSurvivors;                           // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x8];                                      // 0x03F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KindredPerk">();
	}
	static class UKindredPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKindredPerk>();
	}
};
static_assert(alignof(UKindredPerk) == 0x000008, "Wrong alignment on UKindredPerk");
static_assert(sizeof(UKindredPerk) == 0x0003F8, "Wrong size on UKindredPerk");
static_assert(offsetof(UKindredPerk, _killerAuraRevealRange) == 0x0003C8, "Member 'UKindredPerk::_killerAuraRevealRange' has a wrong offset!");
static_assert(offsetof(UKindredPerk, _kindredRevealKillerOther) == 0x0003D8, "Member 'UKindredPerk::_kindredRevealKillerOther' has a wrong offset!");
static_assert(offsetof(UKindredPerk, _kindredRevealKillerOwner) == 0x0003E0, "Member 'UKindredPerk::_kindredRevealKillerOwner' has a wrong offset!");
static_assert(offsetof(UKindredPerk, _kindredRevealSurvivors) == 0x0003E8, "Member 'UKindredPerk::_kindredRevealSurvivors' has a wrong offset!");

// Class DBDCompetence.LingeringBlessedStatusEffect
// 0x0028 (0x0388 - 0x0360)
class ULingeringBlessedStatusEffect final : public UBlessedStatusEffect
{
public:
	uint8                                         Pad_360[0x4];                                      // 0x0360(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _lingerDuration;                                   // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0x20];                                     // 0x0368(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnInRangeChanged(const bool inRange);
	void SetLingerDuration(const float lingerDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LingeringBlessedStatusEffect">();
	}
	static class ULingeringBlessedStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULingeringBlessedStatusEffect>();
	}
};
static_assert(alignof(ULingeringBlessedStatusEffect) == 0x000008, "Wrong alignment on ULingeringBlessedStatusEffect");
static_assert(sizeof(ULingeringBlessedStatusEffect) == 0x000388, "Wrong size on ULingeringBlessedStatusEffect");
static_assert(offsetof(ULingeringBlessedStatusEffect, _lingerDuration) == 0x000364, "Member 'ULingeringBlessedStatusEffect::_lingerDuration' has a wrong offset!");

// Class DBDCompetence.LingeringBlindnessEffect
// 0x0060 (0x03C0 - 0x0360)
class ULingeringBlindnessEffect final : public UAdjustableCooldownStatusEffect
{
public:
	struct FGameplayTag                           startBlindnessEventTag;                            // 0x0360(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           endBlindnessEventTag;                              // 0x036C(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           _state;                                            // 0x0378(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_384[0x3C];                                     // 0x0384(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LingeringBlindnessEffect">();
	}
	static class ULingeringBlindnessEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULingeringBlindnessEffect>();
	}
};
static_assert(alignof(ULingeringBlindnessEffect) == 0x000008, "Wrong alignment on ULingeringBlindnessEffect");
static_assert(sizeof(ULingeringBlindnessEffect) == 0x0003C0, "Wrong size on ULingeringBlindnessEffect");
static_assert(offsetof(ULingeringBlindnessEffect, startBlindnessEventTag) == 0x000360, "Member 'ULingeringBlindnessEffect::startBlindnessEventTag' has a wrong offset!");
static_assert(offsetof(ULingeringBlindnessEffect, endBlindnessEventTag) == 0x00036C, "Member 'ULingeringBlindnessEffect::endBlindnessEventTag' has a wrong offset!");
static_assert(offsetof(ULingeringBlindnessEffect, _state) == 0x000378, "Member 'ULingeringBlindnessEffect::_state' has a wrong offset!");

// Class DBDCompetence.LingeringExhaustedEffect
// 0x0060 (0x03C8 - 0x0368)
class ULingeringExhaustedEffect final : public UExhaustedEffect
{
public:
	struct FGameplayTag                           startExhaustedEventTag;                            // 0x0368(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           endExhaustedEventTag;                              // 0x0374(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           _state;                                            // 0x0380(0x000C)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38C[0x3C];                                     // 0x038C(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LingeringExhaustedEffect">();
	}
	static class ULingeringExhaustedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULingeringExhaustedEffect>();
	}
};
static_assert(alignof(ULingeringExhaustedEffect) == 0x000008, "Wrong alignment on ULingeringExhaustedEffect");
static_assert(sizeof(ULingeringExhaustedEffect) == 0x0003C8, "Wrong size on ULingeringExhaustedEffect");
static_assert(offsetof(ULingeringExhaustedEffect, startExhaustedEventTag) == 0x000368, "Member 'ULingeringExhaustedEffect::startExhaustedEventTag' has a wrong offset!");
static_assert(offsetof(ULingeringExhaustedEffect, endExhaustedEventTag) == 0x000374, "Member 'ULingeringExhaustedEffect::endExhaustedEventTag' has a wrong offset!");
static_assert(offsetof(ULingeringExhaustedEffect, _state) == 0x000380, "Member 'ULingeringExhaustedEffect::_state' has a wrong offset!");

// Class DBDCompetence.LingeringMultiStateTagStatusEffect
// 0x0078 (0x03D0 - 0x0358)
class ULingeringMultiStateTagStatusEffect : public UBaseLingeringStatusEffect
{
public:
	TArray<struct FGameplayTag>                   _ownerStateTag;                                    // 0x0358(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EMultiLingeringStateTagStrategy               _strategy;                                         // 0x0368(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_369[0x67];                                     // 0x0369(0x0067)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LingeringMultiStateTagStatusEffect">();
	}
	static class ULingeringMultiStateTagStatusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULingeringMultiStateTagStatusEffect>();
	}
};
static_assert(alignof(ULingeringMultiStateTagStatusEffect) == 0x000008, "Wrong alignment on ULingeringMultiStateTagStatusEffect");
static_assert(sizeof(ULingeringMultiStateTagStatusEffect) == 0x0003D0, "Wrong size on ULingeringMultiStateTagStatusEffect");
static_assert(offsetof(ULingeringMultiStateTagStatusEffect, _ownerStateTag) == 0x000358, "Member 'ULingeringMultiStateTagStatusEffect::_ownerStateTag' has a wrong offset!");
static_assert(offsetof(ULingeringMultiStateTagStatusEffect, _strategy) == 0x000368, "Member 'ULingeringMultiStateTagStatusEffect::_strategy' has a wrong offset!");

// Class DBDCompetence.LuckyBreak
// 0x0058 (0x0420 - 0x03C8)
class ULuckyBreak final : public UPerk
{
public:
	float                                         _maxActivationTime[0x3];                           // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _minActivationTime;                                // 0x03D4(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _healingTimeToActivationTimeRatio;                 // 0x03D8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isRecharging;                                     // 0x03DC(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DD[0x3];                                      // 0x03DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpeedBasedNetSyncedValue              _activationTime;                                   // 0x03E0(0x0038)(Net, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivationTimerEnded();
	void Authority_OnDamageStateChanged(ECamperDamageState oldDamageState, ECamperDamageState currentDamageState);
	void Authority_TryActivatePerk();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LuckyBreak">();
	}
	static class ULuckyBreak* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULuckyBreak>();
	}
};
static_assert(alignof(ULuckyBreak) == 0x000008, "Wrong alignment on ULuckyBreak");
static_assert(sizeof(ULuckyBreak) == 0x000420, "Wrong size on ULuckyBreak");
static_assert(offsetof(ULuckyBreak, _maxActivationTime) == 0x0003C8, "Member 'ULuckyBreak::_maxActivationTime' has a wrong offset!");
static_assert(offsetof(ULuckyBreak, _minActivationTime) == 0x0003D4, "Member 'ULuckyBreak::_minActivationTime' has a wrong offset!");
static_assert(offsetof(ULuckyBreak, _healingTimeToActivationTimeRatio) == 0x0003D8, "Member 'ULuckyBreak::_healingTimeToActivationTimeRatio' has a wrong offset!");
static_assert(offsetof(ULuckyBreak, _isRecharging) == 0x0003DC, "Member 'ULuckyBreak::_isRecharging' has a wrong offset!");
static_assert(offsetof(ULuckyBreak, _activationTime) == 0x0003E0, "Member 'ULuckyBreak::_activationTime' has a wrong offset!");

// Class DBDCompetence.MakeYourChoice
// 0x0008 (0x03D0 - 0x03C8)
class UMakeYourChoice final : public UPerk
{
public:
	float                                         MinimumHookedSurvivorDistance;                     // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanApplyExposedEffect(const class AActor* unhooker) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MakeYourChoice">();
	}
	static class UMakeYourChoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMakeYourChoice>();
	}
};
static_assert(alignof(UMakeYourChoice) == 0x000008, "Wrong alignment on UMakeYourChoice");
static_assert(sizeof(UMakeYourChoice) == 0x0003D0, "Wrong size on UMakeYourChoice");
static_assert(offsetof(UMakeYourChoice, MinimumHookedSurvivorDistance) == 0x0003C8, "Member 'UMakeYourChoice::MinimumHookedSurvivorDistance' has a wrong offset!");

// Class DBDCompetence.MindBreaker
// 0x0038 (0x0400 - 0x03C8)
class UMindBreaker final : public UPerk
{
public:
	float                                         _effectDurationAfterRepair[0x3];                   // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0x2C];                                     // 0x03D4(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MindBreaker">();
	}
	static class UMindBreaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMindBreaker>();
	}
};
static_assert(alignof(UMindBreaker) == 0x000008, "Wrong alignment on UMindBreaker");
static_assert(sizeof(UMindBreaker) == 0x000400, "Wrong size on UMindBreaker");
static_assert(offsetof(UMindBreaker, _effectDurationAfterRepair) == 0x0003C8, "Member 'UMindBreaker::_effectDurationAfterRepair' has a wrong offset!");

// Class DBDCompetence.Nemesis
// 0x0020 (0x03E8 - 0x03C8)
class UNemesis final : public UPerk
{
public:
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _revealToKillerTime[0x3];                          // 0x03D0(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _obliviousTime[0x3];                               // 0x03DC(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Nemesis">();
	}
	static class UNemesis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNemesis>();
	}
};
static_assert(alignof(UNemesis) == 0x000008, "Wrong alignment on UNemesis");
static_assert(sizeof(UNemesis) == 0x0003E8, "Wrong size on UNemesis");
static_assert(offsetof(UNemesis, _revealToKillerTime) == 0x0003D0, "Member 'UNemesis::_revealToKillerTime' has a wrong offset!");
static_assert(offsetof(UNemesis, _obliviousTime) == 0x0003DC, "Member 'UNemesis::_obliviousTime' has a wrong offset!");

// Class DBDCompetence.ObliviousEffect
// 0x0000 (0x0360 - 0x0360)
class UObliviousEffect : public UAdjustableCooldownStatusEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObliviousEffect">();
	}
	static class UObliviousEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObliviousEffect>();
	}
};
static_assert(alignof(UObliviousEffect) == 0x000008, "Wrong alignment on UObliviousEffect");
static_assert(sizeof(UObliviousEffect) == 0x000360, "Wrong size on UObliviousEffect");

// Class DBDCompetence.OnEventSetTimerAddon
// 0x0008 (0x02D0 - 0x02C8)
class UOnEventSetTimerAddon final : public UOnEventBaseAddon
{
public:
	float                                         _addonEffectTime;                                  // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnEventSetTimerAddon">();
	}
	static class UOnEventSetTimerAddon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnEventSetTimerAddon>();
	}
};
static_assert(alignof(UOnEventSetTimerAddon) == 0x000008, "Wrong alignment on UOnEventSetTimerAddon");
static_assert(sizeof(UOnEventSetTimerAddon) == 0x0002D0, "Wrong size on UOnEventSetTimerAddon");
static_assert(offsetof(UOnEventSetTimerAddon, _addonEffectTime) == 0x0002C8, "Member 'UOnEventSetTimerAddon::_addonEffectTime' has a wrong offset!");

// Class DBDCompetence.OwningPlayerInBoonBlessingRange
// 0x0008 (0x0108 - 0x0100)
class UOwningPlayerInBoonBlessingRange final : public UAnyActorPairQueryRangeIsTrue
{
public:
	class ATotem*                                 _boundTotem;                                       // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OwningPlayerInBoonBlessingRange">();
	}
	static class UOwningPlayerInBoonBlessingRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOwningPlayerInBoonBlessingRange>();
	}
};
static_assert(alignof(UOwningPlayerInBoonBlessingRange) == 0x000008, "Wrong alignment on UOwningPlayerInBoonBlessingRange");
static_assert(sizeof(UOwningPlayerInBoonBlessingRange) == 0x000108, "Wrong size on UOwningPlayerInBoonBlessingRange");
static_assert(offsetof(UOwningPlayerInBoonBlessingRange, _boundTotem) == 0x000100, "Member 'UOwningPlayerInBoonBlessingRange::_boundTotem' has a wrong offset!");

// Class DBDCompetence.OwningPlayerInTotemRange
// 0x0018 (0x0118 - 0x0100)
class UOwningPlayerInTotemRange : public UAnyActorPairQueryRangeIsTrue
{
public:
	uint8                                         Pad_100[0x18];                                     // 0x0100(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelReadyToPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OwningPlayerInTotemRange">();
	}
	static class UOwningPlayerInTotemRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOwningPlayerInTotemRange>();
	}
};
static_assert(alignof(UOwningPlayerInTotemRange) == 0x000008, "Wrong alignment on UOwningPlayerInTotemRange");
static_assert(sizeof(UOwningPlayerInTotemRange) == 0x000118, "Wrong size on UOwningPlayerInTotemRange");

// Class DBDCompetence.OwningPlayerInDullTotemRange
// 0x0000 (0x0118 - 0x0118)
class UOwningPlayerInDullTotemRange final : public UOwningPlayerInTotemRange
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OwningPlayerInDullTotemRange">();
	}
	static class UOwningPlayerInDullTotemRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOwningPlayerInDullTotemRange>();
	}
};
static_assert(alignof(UOwningPlayerInDullTotemRange) == 0x000008, "Wrong alignment on UOwningPlayerInDullTotemRange");
static_assert(sizeof(UOwningPlayerInDullTotemRange) == 0x000118, "Wrong size on UOwningPlayerInDullTotemRange");

// Class DBDCompetence.PharmacyPerk
// 0x0018 (0x03E0 - 0x03C8)
class UPharmacyPerk final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _pharmacyEffectClass;                              // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _searchSpeeds[0x3];                                // 0x03D0(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PharmacyPerk">();
	}
	static class UPharmacyPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPharmacyPerk>();
	}
};
static_assert(alignof(UPharmacyPerk) == 0x000008, "Wrong alignment on UPharmacyPerk");
static_assert(sizeof(UPharmacyPerk) == 0x0003E0, "Wrong size on UPharmacyPerk");
static_assert(offsetof(UPharmacyPerk, _pharmacyEffectClass) == 0x0003C8, "Member 'UPharmacyPerk::_pharmacyEffectClass' has a wrong offset!");
static_assert(offsetof(UPharmacyPerk, _searchSpeeds) == 0x0003D0, "Member 'UPharmacyPerk::_searchSpeeds' has a wrong offset!");

// Class DBDCompetence.Poised
// 0x0028 (0x03F0 - 0x03C8)
class UPoised final : public UPerk
{
public:
	float                                         _activationTime[0x3];                              // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0x1C];                                     // 0x03D4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetActivationTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Poised">();
	}
	static class UPoised* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPoised>();
	}
};
static_assert(alignof(UPoised) == 0x000008, "Wrong alignment on UPoised");
static_assert(sizeof(UPoised) == 0x0003F0, "Wrong size on UPoised");
static_assert(offsetof(UPoised, _activationTime) == 0x0003C8, "Member 'UPoised::_activationTime' has a wrong offset!");

// Class DBDCompetence.QuickAndQuiet
// 0x0000 (0x03C8 - 0x03C8)
class UQuickAndQuiet final : public UPerk
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuickAndQuiet">();
	}
	static class UQuickAndQuiet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuickAndQuiet>();
	}
};
static_assert(alignof(UQuickAndQuiet) == 0x000008, "Wrong alignment on UQuickAndQuiet");
static_assert(sizeof(UQuickAndQuiet) == 0x0003C8, "Wrong size on UQuickAndQuiet");

// Class DBDCompetence.ResiliencePerk
// 0x0010 (0x03D8 - 0x03C8)
class UResiliencePerk final : public UPerk
{
public:
	float                                         _actionSpeed[0x3];                                 // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResiliencePerk">();
	}
	static class UResiliencePerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResiliencePerk>();
	}
};
static_assert(alignof(UResiliencePerk) == 0x000008, "Wrong alignment on UResiliencePerk");
static_assert(sizeof(UResiliencePerk) == 0x0003D8, "Wrong size on UResiliencePerk");
static_assert(offsetof(UResiliencePerk, _actionSpeed) == 0x0003C8, "Member 'UResiliencePerk::_actionSpeed' has a wrong offset!");

// Class DBDCompetence.Saboteur
// 0x0058 (0x0420 - 0x03C8)
class USaboteur final : public UPerk
{
public:
	float                                         _cooldownDuration[0x3];                            // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _revealHookDistance[0x3];                          // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FLinearColor                           _scourgeHooksAuraColour;                           // 0x03E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _saboteurEffect;                                   // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMeatHookOutlineUpdateStrategy*> _revealedMeatHooksOultineStrategy;                 // 0x03F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x18];                                     // 0x0408(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetCooldownDurationAtLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Saboteur">();
	}
	static class USaboteur* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaboteur>();
	}
};
static_assert(alignof(USaboteur) == 0x000008, "Wrong alignment on USaboteur");
static_assert(sizeof(USaboteur) == 0x000420, "Wrong size on USaboteur");
static_assert(offsetof(USaboteur, _cooldownDuration) == 0x0003C8, "Member 'USaboteur::_cooldownDuration' has a wrong offset!");
static_assert(offsetof(USaboteur, _revealHookDistance) == 0x0003D4, "Member 'USaboteur::_revealHookDistance' has a wrong offset!");
static_assert(offsetof(USaboteur, _scourgeHooksAuraColour) == 0x0003E0, "Member 'USaboteur::_scourgeHooksAuraColour' has a wrong offset!");
static_assert(offsetof(USaboteur, _saboteurEffect) == 0x0003F0, "Member 'USaboteur::_saboteurEffect' has a wrong offset!");
static_assert(offsetof(USaboteur, _revealedMeatHooksOultineStrategy) == 0x0003F8, "Member 'USaboteur::_revealedMeatHooksOultineStrategy' has a wrong offset!");

// Class DBDCompetence.SecondWind
// 0x0048 (0x0410 - 0x03C8)
class USecondWind final : public UPerk
{
public:
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ESecondWindState                              _currentState;                                     // 0x03D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D1[0x3];                                      // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _amountHealed;                                     // 0x03D4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         _numberOfHealStateToHealToActivate[0x3];           // 0x03E0(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _durationOfHeal[0x3];                              // 0x03EC(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _brokenStatusEffectClass;                          // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _applyBrokenEffect;                                // 0x0400(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_401[0xF];                                      // 0x0401(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnHealProgress(float individualChargeAmount, float totalChargeAmount, class AActor* chargeInstigator, bool wasCoop, float deltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SecondWind">();
	}
	static class USecondWind* GetDefaultObj()
	{
		return GetDefaultObjImpl<USecondWind>();
	}
};
static_assert(alignof(USecondWind) == 0x000008, "Wrong alignment on USecondWind");
static_assert(sizeof(USecondWind) == 0x000410, "Wrong size on USecondWind");
static_assert(offsetof(USecondWind, _currentState) == 0x0003D0, "Member 'USecondWind::_currentState' has a wrong offset!");
static_assert(offsetof(USecondWind, _amountHealed) == 0x0003D4, "Member 'USecondWind::_amountHealed' has a wrong offset!");
static_assert(offsetof(USecondWind, _numberOfHealStateToHealToActivate) == 0x0003E0, "Member 'USecondWind::_numberOfHealStateToHealToActivate' has a wrong offset!");
static_assert(offsetof(USecondWind, _durationOfHeal) == 0x0003EC, "Member 'USecondWind::_durationOfHeal' has a wrong offset!");
static_assert(offsetof(USecondWind, _brokenStatusEffectClass) == 0x0003F8, "Member 'USecondWind::_brokenStatusEffectClass' has a wrong offset!");
static_assert(offsetof(USecondWind, _applyBrokenEffect) == 0x000400, "Member 'USecondWind::_applyBrokenEffect' has a wrong offset!");

// Class DBDCompetence.SelfCare
// 0x0018 (0x03E0 - 0x03C8)
class USelfCare final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _selfHealNoMedkitSpeedPenaltyEffectClass;          // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _selfHealSpeedPenalty[0x3];                        // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SelfCare">();
	}
	static class USelfCare* GetDefaultObj()
	{
		return GetDefaultObjImpl<USelfCare>();
	}
};
static_assert(alignof(USelfCare) == 0x000008, "Wrong alignment on USelfCare");
static_assert(sizeof(USelfCare) == 0x0003E0, "Wrong size on USelfCare");
static_assert(offsetof(USelfCare, _selfHealNoMedkitSpeedPenaltyEffectClass) == 0x0003C8, "Member 'USelfCare::_selfHealNoMedkitSpeedPenaltyEffectClass' has a wrong offset!");
static_assert(offsetof(USelfCare, _selfHealSpeedPenalty) == 0x0003D0, "Member 'USelfCare::_selfHealSpeedPenalty' has a wrong offset!");

// Class DBDCompetence.SingleGateBlockerEffect
// 0x0050 (0x03D8 - 0x0388)
class USingleGateBlockerEffect final : public UGateBlockerEffect
{
public:
	float                                         _distanceThreshold;                                // 0x0388(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AEscapeDoor*                            _gate;                                             // 0x0390(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInRange;                                        // 0x0398(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_399[0x3F];                                     // 0x0399(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SingleGateBlockerEffect">();
	}
	static class USingleGateBlockerEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<USingleGateBlockerEffect>();
	}
};
static_assert(alignof(USingleGateBlockerEffect) == 0x000008, "Wrong alignment on USingleGateBlockerEffect");
static_assert(sizeof(USingleGateBlockerEffect) == 0x0003D8, "Wrong size on USingleGateBlockerEffect");
static_assert(offsetof(USingleGateBlockerEffect, _distanceThreshold) == 0x000388, "Member 'USingleGateBlockerEffect::_distanceThreshold' has a wrong offset!");
static_assert(offsetof(USingleGateBlockerEffect, _gate) == 0x000390, "Member 'USingleGateBlockerEffect::_gate' has a wrong offset!");
static_assert(offsetof(USingleGateBlockerEffect, _isInRange) == 0x000398, "Member 'USingleGateBlockerEffect::_isInRange' has a wrong offset!");

// Class DBDCompetence.SoleSurvivor
// 0x0060 (0x0428 - 0x03C8)
class USoleSurvivor final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _modifyActionSpeedWhenRepairingEffect;             // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _modifyActionSpeedWhenOpeningGateOrHatchEffect;    // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _actionSpeedsRepairing[0x3];                       // 0x03D8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _actionSpeedsOpeningGateOrHatch[0x3];              // 0x03E4(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _auraHideDistancePerDeadOrDisconnectedSurvivor[0x3]; // 0x03F0(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ACamperPlayer*>                  _otherSurvivors;                                   // 0x0400(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x18];                                     // 0x0410(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnSurvivorAdded(const class ACamperPlayer* survivor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SoleSurvivor">();
	}
	static class USoleSurvivor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USoleSurvivor>();
	}
};
static_assert(alignof(USoleSurvivor) == 0x000008, "Wrong alignment on USoleSurvivor");
static_assert(sizeof(USoleSurvivor) == 0x000428, "Wrong size on USoleSurvivor");
static_assert(offsetof(USoleSurvivor, _modifyActionSpeedWhenRepairingEffect) == 0x0003C8, "Member 'USoleSurvivor::_modifyActionSpeedWhenRepairingEffect' has a wrong offset!");
static_assert(offsetof(USoleSurvivor, _modifyActionSpeedWhenOpeningGateOrHatchEffect) == 0x0003D0, "Member 'USoleSurvivor::_modifyActionSpeedWhenOpeningGateOrHatchEffect' has a wrong offset!");
static_assert(offsetof(USoleSurvivor, _actionSpeedsRepairing) == 0x0003D8, "Member 'USoleSurvivor::_actionSpeedsRepairing' has a wrong offset!");
static_assert(offsetof(USoleSurvivor, _actionSpeedsOpeningGateOrHatch) == 0x0003E4, "Member 'USoleSurvivor::_actionSpeedsOpeningGateOrHatch' has a wrong offset!");
static_assert(offsetof(USoleSurvivor, _auraHideDistancePerDeadOrDisconnectedSurvivor) == 0x0003F0, "Member 'USoleSurvivor::_auraHideDistancePerDeadOrDisconnectedSurvivor' has a wrong offset!");
static_assert(offsetof(USoleSurvivor, _otherSurvivors) == 0x000400, "Member 'USoleSurvivor::_otherSurvivors' has a wrong offset!");

// Class DBDCompetence.SpawningEffectPerk
// 0x00B8 (0x0480 - 0x03C8)
class USpawningEffectPerk : public UPerk
{
public:
	struct FPerkLevelEffectArray                  _perkLevelEffects[0x3];                            // 0x03C8(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	struct FPlayerStatusEffectSpawnerHelper       _effectSpawnerHelper;                              // 0x03F8(0x0088)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawningEffectPerk">();
	}
	static class USpawningEffectPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawningEffectPerk>();
	}
};
static_assert(alignof(USpawningEffectPerk) == 0x000008, "Wrong alignment on USpawningEffectPerk");
static_assert(sizeof(USpawningEffectPerk) == 0x000480, "Wrong size on USpawningEffectPerk");
static_assert(offsetof(USpawningEffectPerk, _perkLevelEffects) == 0x0003C8, "Member 'USpawningEffectPerk::_perkLevelEffects' has a wrong offset!");
static_assert(offsetof(USpawningEffectPerk, _effectSpawnerHelper) == 0x0003F8, "Member 'USpawningEffectPerk::_effectSpawnerHelper' has a wrong offset!");

// Class DBDCompetence.SpiesFromTheShadows
// 0x0008 (0x03D0 - 0x03C8)
class USpiesFromTheShadows final : public UPerk
{
public:
	float                                         _cooldownDurationSecs;                             // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpiesFromTheShadows">();
	}
	static class USpiesFromTheShadows* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpiesFromTheShadows>();
	}
};
static_assert(alignof(USpiesFromTheShadows) == 0x000008, "Wrong alignment on USpiesFromTheShadows");
static_assert(sizeof(USpiesFromTheShadows) == 0x0003D0, "Wrong size on USpiesFromTheShadows");
static_assert(offsetof(USpiesFromTheShadows, _cooldownDurationSecs) == 0x0003C8, "Member 'USpiesFromTheShadows::_cooldownDurationSecs' has a wrong offset!");

// Class DBDCompetence.SpineChillPerk
// 0x0090 (0x0458 - 0x03C8)
class USpineChillPerk final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _spineChillEffectClass;                            // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _actionSpeed[0x3];                                 // 0x03D0(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _lingerDuration;                                   // 0x03DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _range;                                            // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _precisionAngleDegrees;                            // 0x03E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isInRange;                                        // 0x03E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E9[0x6F];                                     // 0x03E9(0x006F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const bool AreTriggersMet();
	void Authority_OnInRangeChanged(const bool inRange);
	void Authority_OnIsInLineOfSightChanged(const bool isInLineOfSight);
	void Authority_OnIsLookingTowardsChanged(const bool isLookingTowards);
	const float GetActionSpeed(int32 perkLevel);
	const float GetLingerDuration();
	const float GetRange();
	const bool HasLineOfSight();
	const bool IsInRange();
	const bool IsLookingTowards();
	void OnRep_IsInRange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpineChillPerk">();
	}
	static class USpineChillPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpineChillPerk>();
	}
};
static_assert(alignof(USpineChillPerk) == 0x000008, "Wrong alignment on USpineChillPerk");
static_assert(sizeof(USpineChillPerk) == 0x000458, "Wrong size on USpineChillPerk");
static_assert(offsetof(USpineChillPerk, _spineChillEffectClass) == 0x0003C8, "Member 'USpineChillPerk::_spineChillEffectClass' has a wrong offset!");
static_assert(offsetof(USpineChillPerk, _actionSpeed) == 0x0003D0, "Member 'USpineChillPerk::_actionSpeed' has a wrong offset!");
static_assert(offsetof(USpineChillPerk, _lingerDuration) == 0x0003DC, "Member 'USpineChillPerk::_lingerDuration' has a wrong offset!");
static_assert(offsetof(USpineChillPerk, _range) == 0x0003E0, "Member 'USpineChillPerk::_range' has a wrong offset!");
static_assert(offsetof(USpineChillPerk, _precisionAngleDegrees) == 0x0003E4, "Member 'USpineChillPerk::_precisionAngleDegrees' has a wrong offset!");
static_assert(offsetof(USpineChillPerk, _isInRange) == 0x0003E8, "Member 'USpineChillPerk::_isInRange' has a wrong offset!");

// Class DBDCompetence.SprintBurst
// 0x0020 (0x03E8 - 0x03C8)
class USprintBurst final : public UPerk
{
public:
	float                                         _exhaustionDuration[0x3];                          // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _sprintDuration;                                   // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActivatableExhaustedEffect*            _exhaustedEffect;                                  // 0x03D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x8];                                      // 0x03E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnIsRunningAndMovingChanged(const bool isRunningAndMoving);
	void Authority_OnPerkFlagsChanged(const struct FGameplayTag& gameplayTag, bool isAdded);

	float GetExhaustedDuration() const;
	float GetSprintDuration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SprintBurst">();
	}
	static class USprintBurst* GetDefaultObj()
	{
		return GetDefaultObjImpl<USprintBurst>();
	}
};
static_assert(alignof(USprintBurst) == 0x000008, "Wrong alignment on USprintBurst");
static_assert(sizeof(USprintBurst) == 0x0003E8, "Wrong size on USprintBurst");
static_assert(offsetof(USprintBurst, _exhaustionDuration) == 0x0003C8, "Member 'USprintBurst::_exhaustionDuration' has a wrong offset!");
static_assert(offsetof(USprintBurst, _sprintDuration) == 0x0003D4, "Member 'USprintBurst::_sprintDuration' has a wrong offset!");
static_assert(offsetof(USprintBurst, _exhaustedEffect) == 0x0003D8, "Member 'USprintBurst::_exhaustedEffect' has a wrong offset!");

// Class DBDCompetence.StakeOutPerk
// 0x0038 (0x0400 - 0x03C8)
class UStakeOutPerk final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _stakeOutStatusEffectClass;                        // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStatusEffect*                          _stakeOutStatusEffect;                             // 0x03D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 _maxTokensByLevel;                                 // 0x03D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         _tokenChargeTime;                                  // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EC[0x14];                                     // 0x03EC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Local_BroadcastConsumeToken();
	void Server_ConsumeToken();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StakeOutPerk">();
	}
	static class UStakeOutPerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStakeOutPerk>();
	}
};
static_assert(alignof(UStakeOutPerk) == 0x000008, "Wrong alignment on UStakeOutPerk");
static_assert(sizeof(UStakeOutPerk) == 0x000400, "Wrong size on UStakeOutPerk");
static_assert(offsetof(UStakeOutPerk, _stakeOutStatusEffectClass) == 0x0003C8, "Member 'UStakeOutPerk::_stakeOutStatusEffectClass' has a wrong offset!");
static_assert(offsetof(UStakeOutPerk, _stakeOutStatusEffect) == 0x0003D0, "Member 'UStakeOutPerk::_stakeOutStatusEffect' has a wrong offset!");
static_assert(offsetof(UStakeOutPerk, _maxTokensByLevel) == 0x0003D8, "Member 'UStakeOutPerk::_maxTokensByLevel' has a wrong offset!");
static_assert(offsetof(UStakeOutPerk, _tokenChargeTime) == 0x0003E8, "Member 'UStakeOutPerk::_tokenChargeTime' has a wrong offset!");

// Class DBDCompetence.StatusEffectOriginatorSubjectProvider
// 0x0000 (0x0048 - 0x0048)
class UStatusEffectOriginatorSubjectProvider final : public UModifierSubjectProvider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatusEffectOriginatorSubjectProvider">();
	}
	static class UStatusEffectOriginatorSubjectProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatusEffectOriginatorSubjectProvider>();
	}
};
static_assert(alignof(UStatusEffectOriginatorSubjectProvider) == 0x000008, "Wrong alignment on UStatusEffectOriginatorSubjectProvider");
static_assert(sizeof(UStatusEffectOriginatorSubjectProvider) == 0x000048, "Wrong size on UStatusEffectOriginatorSubjectProvider");

// Class DBDCompetence.Surge
// 0x0040 (0x0408 - 0x03C8)
class USurge final : public UPerk
{
public:
	float                                         _zoneRadius[0x3];                                  // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _instantRegression[0x3];                           // 0x03D4(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _cooldownDuration[0x3];                            // 0x03E0(0x0004)(Edit, EditFixedSize, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _hasCooldown;                                      // 0x03EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _useTerrorRadiusInsteadOfFixedDistance;            // 0x03ED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3EE[0x1A];                                     // 0x03EE(0x001A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_TriggerEffects(const TArray<class AGenerator*>& generators);

	const float GetCooldownDurationAtLevel() const;
	const bool GetHasCooldown() const;
	const float GetInstantRegressionAtLevel() const;
	float GetZoneRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Surge">();
	}
	static class USurge* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurge>();
	}
};
static_assert(alignof(USurge) == 0x000008, "Wrong alignment on USurge");
static_assert(sizeof(USurge) == 0x000408, "Wrong size on USurge");
static_assert(offsetof(USurge, _zoneRadius) == 0x0003C8, "Member 'USurge::_zoneRadius' has a wrong offset!");
static_assert(offsetof(USurge, _instantRegression) == 0x0003D4, "Member 'USurge::_instantRegression' has a wrong offset!");
static_assert(offsetof(USurge, _cooldownDuration) == 0x0003E0, "Member 'USurge::_cooldownDuration' has a wrong offset!");
static_assert(offsetof(USurge, _hasCooldown) == 0x0003EC, "Member 'USurge::_hasCooldown' has a wrong offset!");
static_assert(offsetof(USurge, _useTerrorRadiusInsteadOfFixedDistance) == 0x0003ED, "Member 'USurge::_useTerrorRadiusInsteadOfFixedDistance' has a wrong offset!");

// Class DBDCompetence.SurvivorWasRecentlyUnhookedEffect
// 0x0028 (0x0378 - 0x0350)
class USurvivorWasRecentlyUnhookedEffect final : public UStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _survivorWasRecentlyUnhookedDuration;              // 0x0350(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SurvivorWasRecentlyUnhookedEffect">();
	}
	static class USurvivorWasRecentlyUnhookedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<USurvivorWasRecentlyUnhookedEffect>();
	}
};
static_assert(alignof(USurvivorWasRecentlyUnhookedEffect) == 0x000008, "Wrong alignment on USurvivorWasRecentlyUnhookedEffect");
static_assert(sizeof(USurvivorWasRecentlyUnhookedEffect) == 0x000378, "Wrong size on USurvivorWasRecentlyUnhookedEffect");
static_assert(offsetof(USurvivorWasRecentlyUnhookedEffect, _survivorWasRecentlyUnhookedDuration) == 0x000350, "Member 'USurvivorWasRecentlyUnhookedEffect::_survivorWasRecentlyUnhookedDuration' has a wrong offset!");

// Class DBDCompetence.TheMettleOfMan
// 0x0050 (0x0418 - 0x03C8)
class UTheMettleOfMan final : public UPerk
{
public:
	int32                                         _tokenNeededToActivate[0x3];                       // 0x03C8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _revealOutsideRange[0x3];                          // 0x03D4(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _mustBeInjured;                                    // 0x03E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UStatusEffect>              _enduranceHighlightEffectClass;                    // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         _numTokenSoFar;                                    // 0x03F0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETheMettleOfManPhase                          _currentPhase;                                     // 0x03F4(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F5[0xB];                                      // 0x03F5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class UStatusEffect*                          _revealToKillerEffect;                             // 0x0400(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_408[0x10];                                     // 0x0408(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_CurrentPhase();
	void OnRep_NumTokenSoFar();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TheMettleOfMan">();
	}
	static class UTheMettleOfMan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTheMettleOfMan>();
	}
};
static_assert(alignof(UTheMettleOfMan) == 0x000008, "Wrong alignment on UTheMettleOfMan");
static_assert(sizeof(UTheMettleOfMan) == 0x000418, "Wrong size on UTheMettleOfMan");
static_assert(offsetof(UTheMettleOfMan, _tokenNeededToActivate) == 0x0003C8, "Member 'UTheMettleOfMan::_tokenNeededToActivate' has a wrong offset!");
static_assert(offsetof(UTheMettleOfMan, _revealOutsideRange) == 0x0003D4, "Member 'UTheMettleOfMan::_revealOutsideRange' has a wrong offset!");
static_assert(offsetof(UTheMettleOfMan, _mustBeInjured) == 0x0003E0, "Member 'UTheMettleOfMan::_mustBeInjured' has a wrong offset!");
static_assert(offsetof(UTheMettleOfMan, _enduranceHighlightEffectClass) == 0x0003E8, "Member 'UTheMettleOfMan::_enduranceHighlightEffectClass' has a wrong offset!");
static_assert(offsetof(UTheMettleOfMan, _numTokenSoFar) == 0x0003F0, "Member 'UTheMettleOfMan::_numTokenSoFar' has a wrong offset!");
static_assert(offsetof(UTheMettleOfMan, _currentPhase) == 0x0003F4, "Member 'UTheMettleOfMan::_currentPhase' has a wrong offset!");
static_assert(offsetof(UTheMettleOfMan, _revealToKillerEffect) == 0x000400, "Member 'UTheMettleOfMan::_revealToKillerEffect' has a wrong offset!");

// Class DBDCompetence.TimedObliviousEffect
// 0x0000 (0x0360 - 0x0360)
class UTimedObliviousEffect : public UObliviousEffect
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimedObliviousEffect">();
	}
	static class UTimedObliviousEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimedObliviousEffect>();
	}
};
static_assert(alignof(UTimedObliviousEffect) == 0x000008, "Wrong alignment on UTimedObliviousEffect");
static_assert(sizeof(UTimedObliviousEffect) == 0x000360, "Wrong size on UTimedObliviousEffect");

// Class DBDCompetence.Tinkerer
// 0x0078 (0x0440 - 0x03C8)
class UTinkerer final : public UPerk
{
public:
	TSubclassOf<class UStatusEffect>              _undetectableEffectClass;                          // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _triggerThreshold;                                 // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _distanceThreshold;                                // 0x03D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _activationTime[0x3];                              // 0x03D8(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class AActor*, float>                    _generatorActivationTimes;                         // 0x03E8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x8];                                      // 0x0438(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Authority_OnGeneratorChargePercentChanged(class UChargeableComponent* chargeableComponent, float percentCompletionChange, float totalPercentComplete);
	void Authority_OnGeneratorReachedThreshold(class AGenerator* generator);
	void Authority_OnLevelReadyToPlay();
	void Authority_OnUndetectableAttackSuccessNearActiveGenerator(class ADBDPlayer* instigator, class ADBDPlayer* target);
	void Authority_OnUndetectableGeneratorInterrupt(class ADBDPlayer* instigator, class ADBDPlayer* target);

	float GetActivationTimeAtLevel() const;
	float GetTriggerThreshold() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tinkerer">();
	}
	static class UTinkerer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTinkerer>();
	}
};
static_assert(alignof(UTinkerer) == 0x000008, "Wrong alignment on UTinkerer");
static_assert(sizeof(UTinkerer) == 0x000440, "Wrong size on UTinkerer");
static_assert(offsetof(UTinkerer, _undetectableEffectClass) == 0x0003C8, "Member 'UTinkerer::_undetectableEffectClass' has a wrong offset!");
static_assert(offsetof(UTinkerer, _triggerThreshold) == 0x0003D0, "Member 'UTinkerer::_triggerThreshold' has a wrong offset!");
static_assert(offsetof(UTinkerer, _distanceThreshold) == 0x0003D4, "Member 'UTinkerer::_distanceThreshold' has a wrong offset!");
static_assert(offsetof(UTinkerer, _activationTime) == 0x0003D8, "Member 'UTinkerer::_activationTime' has a wrong offset!");
static_assert(offsetof(UTinkerer, _generatorActivationTimes) == 0x0003E8, "Member 'UTinkerer::_generatorActivationTimes' has a wrong offset!");

// Class DBDCompetence.UnhookedMovementSpeedBonusEffect
// 0x0030 (0x0380 - 0x0350)
class UUnhookedMovementSpeedBonusEffect final : public UStatusEffect
{
public:
	struct FDBDTunableRowHandle                   _movementSpeedBonusPercent;                        // 0x0350(0x0028)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UnhookedMovementSpeedBonusEffect">();
	}
	static class UUnhookedMovementSpeedBonusEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUnhookedMovementSpeedBonusEffect>();
	}
};
static_assert(alignof(UUnhookedMovementSpeedBonusEffect) == 0x000008, "Wrong alignment on UUnhookedMovementSpeedBonusEffect");
static_assert(sizeof(UUnhookedMovementSpeedBonusEffect) == 0x000380, "Wrong size on UUnhookedMovementSpeedBonusEffect");
static_assert(offsetof(UUnhookedMovementSpeedBonusEffect, _movementSpeedBonusPercent) == 0x000350, "Member 'UUnhookedMovementSpeedBonusEffect::_movementSpeedBonusPercent' has a wrong offset!");

// Class DBDCompetence.WereGonnaLiveForever
// 0x0028 (0x03F0 - 0x03C8)
class UWereGonnaLiveForever final : public UPerk
{
public:
	float                                         _healSpeedIncrease;                                // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _enduranceEffectLevels[0x3];                       // 0x03CC(0x0004)(Edit, EditFixedSize, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UStatusEffect>              _healSpeedFromDyingStatusEffect;                   // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _enduranceEffect;                                  // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          _isPerkEnabled;                                    // 0x03E8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_PerkEnabled();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WereGonnaLiveForever">();
	}
	static class UWereGonnaLiveForever* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWereGonnaLiveForever>();
	}
};
static_assert(alignof(UWereGonnaLiveForever) == 0x000008, "Wrong alignment on UWereGonnaLiveForever");
static_assert(sizeof(UWereGonnaLiveForever) == 0x0003F0, "Wrong size on UWereGonnaLiveForever");
static_assert(offsetof(UWereGonnaLiveForever, _healSpeedIncrease) == 0x0003C8, "Member 'UWereGonnaLiveForever::_healSpeedIncrease' has a wrong offset!");
static_assert(offsetof(UWereGonnaLiveForever, _enduranceEffectLevels) == 0x0003CC, "Member 'UWereGonnaLiveForever::_enduranceEffectLevels' has a wrong offset!");
static_assert(offsetof(UWereGonnaLiveForever, _healSpeedFromDyingStatusEffect) == 0x0003D8, "Member 'UWereGonnaLiveForever::_healSpeedFromDyingStatusEffect' has a wrong offset!");
static_assert(offsetof(UWereGonnaLiveForever, _enduranceEffect) == 0x0003E0, "Member 'UWereGonnaLiveForever::_enduranceEffect' has a wrong offset!");
static_assert(offsetof(UWereGonnaLiveForever, _isPerkEnabled) == 0x0003E8, "Member 'UWereGonnaLiveForever::_isPerkEnabled' has a wrong offset!");

// Class DBDCompetence.YamaokaFamilyCrest
// 0x0040 (0x02F8 - 0x02B8)
class UYamaokaFamilyCrest final : public UItemAddon
{
public:
	float                                         _revealDuration;                                   // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _revealRange;                                      // 0x02BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UStatusEffect>              _revealAuraToKillerEffectClass;                    // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ACamperPlayer*>                  _survivorsToReveal;                                // 0x02C8(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         _addonActivationCount;                             // 0x02D8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2D9[0x1F];                                     // 0x02D9(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AddonActivationCount();
	void RevealSurvivor(class ACamperPlayer* survivorToReveal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"YamaokaFamilyCrest">();
	}
	static class UYamaokaFamilyCrest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UYamaokaFamilyCrest>();
	}
};
static_assert(alignof(UYamaokaFamilyCrest) == 0x000008, "Wrong alignment on UYamaokaFamilyCrest");
static_assert(sizeof(UYamaokaFamilyCrest) == 0x0002F8, "Wrong size on UYamaokaFamilyCrest");
static_assert(offsetof(UYamaokaFamilyCrest, _revealDuration) == 0x0002B8, "Member 'UYamaokaFamilyCrest::_revealDuration' has a wrong offset!");
static_assert(offsetof(UYamaokaFamilyCrest, _revealRange) == 0x0002BC, "Member 'UYamaokaFamilyCrest::_revealRange' has a wrong offset!");
static_assert(offsetof(UYamaokaFamilyCrest, _revealAuraToKillerEffectClass) == 0x0002C0, "Member 'UYamaokaFamilyCrest::_revealAuraToKillerEffectClass' has a wrong offset!");
static_assert(offsetof(UYamaokaFamilyCrest, _survivorsToReveal) == 0x0002C8, "Member 'UYamaokaFamilyCrest::_survivorsToReveal' has a wrong offset!");
static_assert(offsetof(UYamaokaFamilyCrest, _addonActivationCount) == 0x0002D8, "Member 'UYamaokaFamilyCrest::_addonActivationCount' has a wrong offset!");

}

